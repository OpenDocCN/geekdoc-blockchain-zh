- en: Part 3\.
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分
- en: You can think of [part 3](#part03) as the core of the book. After learning all
    the foundation content in the previous parts, you’re ready to transition to real-world
    Ethereum. In [chapter 9](kindle_split_022.xhtml#ch09), you’ll become familiar
    with the wider ecosystem, which includes, among other elements, the Ethereum Name
    Service (ENS); decentralized storage networks, such as IPFS and Swarm; and oracle
    and other development frameworks. Then you’ll start to use professional development
    tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将[第3部分](#part03)视为本书的核心。在学习了前两部分的所有基础内容后，你准备好过渡到现实世界的以太坊。在[第9章](kindle_split_022.xhtml#ch09)中，你将熟悉更广泛的生态系统，其中包括其他元素，如以太坊名称服务（ENS）；去中心化存储网络，如IPFS和Swarm；以及预言机和其他开发框架。然后，你将开始使用专业开发工具。
- en: In [chapter 10](kindle_split_023.xhtml#ch10), you’ll learn how to test smart
    contracts with the JavaScript Mocha framework, and in [chapter 11](kindle_split_024.xhtml#ch11),
    you’ll improve the development cycle with the Truffle framework, which will allow
    you to easily compile, test, and deploy your contracts. Finally, in [chapter 12](kindle_split_025.xhtml#ch12),
    you’ll put everything together by building an end-to-end voting Dapp from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](kindle_split_023.xhtml#ch10)中，你将学习如何使用JavaScript Mocha框架测试智能合约，在第[11章](kindle_split_024.xhtml#ch11)中，你将使用Truffle框架改进开发周期，该框架将允许你轻松编译、测试和部署你的合约。最后，在第[12章](kindle_split_025.xhtml#ch12)中，你将综合运用所学知识，从头开始构建一个端到端的投票Dapp。
- en: 'After completing this part, you’ll have achieved a major milestone: you’ll
    understand how Ethereum works, inside and out, and will be aware of most of its
    ecosystem. If you’re eager to build your own Dapp, though, I strongly encourage
    you to keep reading so you can learn the more advanced concepts in [part 4](kindle_split_026.xhtml#part04).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一部分后，你将实现一个重要里程碑：你将深入理解以太坊的运作方式，并对其生态系统有全面的了解。如果你渴望建立自己的Dapp，我强烈建议你继续阅读，以便学习[第4部分](kindle_split_026.xhtml#part04)的更高级概念。
- en: Chapter 9\. The Ethereum ecosystem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。以太坊生态系统
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容涵盖**'
- en: A bird’s-eye view of the full Ethereum ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊生态系统的全局鸟瞰
- en: Decentralized address resolution with ENS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ENS的分布式地址解析
- en: Decentralized content storage on Swarm and IPFS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Swarm和IPFS上的去中心化内容存储
- en: External data access through oracles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过预言机的外部数据访问
- en: Dapp frameworks and IDEs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapp框架和IDE
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In previous chapters, you learned about the main components of the Ethereum
    platform and how to implement and deploy a decentralized application using simple
    tools such as the Remix IDE and the geth console. You then improved the efficiency
    of the development cycle by partially automating the deployment with Node.js.
    You made further efficiency improvements by deploying and running your smart contracts
    on a private network and, ultimately, on Ganache, where you progressively reduced
    and almost eliminated the impact of infrastructural aspects of the Ethereum platform
    on the run and test cycle.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你学习了以太坊平台的主要组成部分以及如何使用Remix IDE和geth控制台等简单工具来实现和部署去中心化应用。然后，你通过使用Node.js部分自动化部署，提高了开发效率。你进一步通过在私有网络和Ganache上部署和运行智能合约，以及逐步减少和几乎消除了以太坊平台的基础设施对运行和测试周期的影响，从而提高了效率。
- en: The tool set you’ve used so far has been pretty basic, but it has helped you
    understand every step of the build and deployment process of a smart contract.
    You’ve also learned about every step of the lifecycle of a transaction, from its
    creation, through a Web3 call, to its propagation to the network, to its mining,
    and ultimately to its persistence on the blockchain. Although you might have found
    these tools helpful and effective for getting started quickly and for learning
    various concepts in detail, if you decide to develop Ethereum applications on
    a regular basis, you’d use a different tool set.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止你所使用的工具集相当基础，但它帮助你理解了智能合约的构建和部署过程中的每一个步骤。你还学习了交易的整个生命周期，从它的创建、通过Web3调用、传播到网络、挖掘，最终持久化在区块链上。虽然你可能会发现这些工具对于快速入门和详细学习各种概念很有帮助，但如果你决定定期开发以太坊应用程序，你会使用另一套工具。
- en: This chapter gives you an overview of the wider Ethereum ecosystem, both from
    a platform point of view and from a development tool set point of view. You’ll
    learn about additional components of the Ethereum platform and alternative IDEs
    and frameworks that will allow you to develop and deploy Dapps with less effort.
    But before we start to explore the full Ethereum ecosystem, I’ll recap the current
    view of the platform and the development tool set.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了更广泛的以太坊生态系统的概述，既从平台的角度也从开发工具集的角度。您将了解到以太坊平台的更多组件以及允许您更轻松地开发和部署 Dapps
    的其他 IDE 和框架。但在我们开始探索完整的以太坊生态系统之前，我将回顾一下平台和开发工具集的当前视图。
- en: 9.1\. The core components
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 核心组件
- en: '[Figure 9.1](#ch09fig01) summarizes all you know so far about the Ethereum
    platform and the development toolset.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.1](#ch09fig01) 总结了您迄今为止关于以太坊平台和开发工具集的所有知识。'
- en: 'Figure 9.1\. Core components of the Ethereum platform you’ve learned so far:
    geth, Ethereum wallet, MetaMask, Ganache, Remix, solc, and Web3.js'
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1. 您迄今为止学习的以太坊平台的核心组件：geth、以太坊钱包、MetaMask、Ganache、Remix、solc 和 Web3.js。
- en: '![](Images/fig09-01_alt.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-01_alt.jpg)'
- en: Although you’ve installed the Go Ethereum client (geth) and the Ethereum wallet,
    you’re aware you could have installed alternative clients, such as cpp-ethereum
    (eth), Parity, Ethereum(J), or pyethapp. Most of these come with a related wallet.
    You also could have decided to connect to an external MetaMask node (in fact,
    an Infura node, as you’ll see later) with MetaMask or to a mock node with Ganache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您已经安装了 Go Ethereum 客户端 (geth) 和以太坊钱包，但您知道您还可以安装其他客户端，例如 cpp-ethereum (eth)、Parity、Ethereum(J)
    或 pyethapp。其中大多数都带有相关的钱包。您还可以决定使用 MetaMask 连接外部 MetaMask 节点（实际上，如稍后您将看到的，是一个 Infura
    节点）或使用 Ganache 连接模拟节点。
- en: You’ve developed your smart contracts in Solidity using Remix (Browser Solidity).
    When needed, you’ve moved the code to text files and compiled them with the solc
    compiler. In theory, you could have implemented smart contracts in other EVM languages,
    such as Serpent or LLL, but currently Solidity is widely regarded as the most
    reliable and secure language. Time will tell if Serpent makes a comeback or new
    alternatives such as Viper start to gather momentum.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 Remix（浏览器 Solidity）在 Solidity 中开发了您的智能合约。需要时，您将代码移动到文本文件并使用 solc 编译器编译它们。从理论上讲，您可以使用其他
    EVM 语言（如 Serpent 或 LLL）实现智能合约，但目前 Solidity 被广泛认为是最高可靠性和最安全的语言。时间将告诉我们 Serpent
    是否会有所回归，或者像 Viper 这样的新替代方案是否会开始获得动力。
- en: You interacted with the network, including your deployed contracts, in Web3.js,
    initially through the interactive geth console. Then you moved to Node.js for
    better extensibility and automation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您最初通过交互式 geth 控制台与网络（包括您部署的合约）交互。然后，您转向 Node.js 以获得更好的可扩展性和自动化。
- en: Web3.js is a JavaScript-specific high-level API that wraps the low-level JSON-RPC
    API. Other high-level APIs are available that target other languages, such as
    web3.j (for Java), NETEthereum (for .NET), and Ethereum.ruby (for ruby).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Web3.js 是一个针对 JavaScript 的特定高级 API，它封装了低级的 JSON-RPC API。还有针对其他语言的其他高级 API，例如
    web3.j（用于 Java）、NETEthereum（用于 .NET）和 Ethereum.ruby（用于 ruby）。
- en: 9.2\. A bird’s-eye view of the full ecosystem
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 完整生态系统的鸟瞰图。
- en: '[Figure 9.2](#ch09fig02) provides a full view of the current Ethereum ecosystem,
    where you can see an additional set of development IDEs and frameworks, such as
    Truffle, aimed at improving the development experience. UI frameworks such as
    meteor and Angular aren’t Ethereum-specific, but they’re widely adopted to build
    modern Dapp UIs. Also, generic testing frameworks such as Mocha and Jasmine are
    becoming a common feature of Dapp development environments.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.2](#ch09fig02) 提供了当前以太坊生态系统的全面视图，您可以看到一套额外的开发 IDE 和框架，例如 Truffle，旨在改善开发体验。像
    meteor 和 Angular 这样的 UI 框架并不是以太坊特定的，但它们被广泛采用来构建现代 Dapp UI。此外，像 Mocha 和 Jasmine
    这样的通用测试框架正在成为 Dapp 开发环境的一个常见特征。'
- en: 'You can also see additional infrastructural elements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到一些额外的基础设施元素：
- en: '*Ethereum Name Service (ENS)*—This is a smart contract for the decentralized
    resolution of human-readable names, such as `roberto.manning.eth`, into Ethereum
    addresses, such as `0x829bd824b016326a401d083b33d092293333a830`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以太坊名称服务 (ENS)**—这是一个用于将诸如 `roberto.manning.eth` 等人读名字解析为以太坊地址（如 `0x829bd824b016326a401d083b33d092293333a830`）的智慧合约。'
- en: '*Swarm and IPFS*—These are two competing networks for decentralized storage
    of content that Ethereum blockchain transactions can then reference through hash
    IDs (or friendly names resolved into hashes by ENS). Swarm comes directly under
    the Ethereum umbrella and is Ethereum-aware; IPFS is a general technology-agnostic
    protocol that provides similar functionality.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Swarm和IPFS*—这两个是为去中心化内容存储而竞争的网络，以太坊区块链交易可以通过哈希ID（或通过ENS解析为哈希的友好名称）引用。Swarm直接隶属于以太坊旗下，是了解以太坊的；IPFS是一个通用技术无关的协议，提供类似功能。'
- en: '*Oracle frameworks*—These are smart contract frameworks (such as Oraclize)
    for accessing real-world data in a way that guarantees data authenticity and consistent
    processing of such data throughout the entire Ethereum network.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预言机框架*—这些是智能合约框架（如Oraclize），通过确保数据真实性和在整个以太坊网络上一致处理数据的方式，访问现实世界数据。'
- en: '*Whisper*—This is a network for decentralized messaging that provides Ethereum
    smart contracts with asynchronous peer-to-peer communication, with resilience
    and privacy as main features. The Whisper API allows contracts to send messages
    with various degrees of security and privacy, from plain text and fully traceable
    to encrypted and virtually untraceable (so-called *dark messages*).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Whisper*—这是一个去中心化消息网络，为以太坊智能合约提供异步点对点通信，其主要特点是有弹性且私密。Whisper API允许合约发送具有不同安全性和私密性的消息，从纯文本和完全可追踪到加密且几乎无法追踪（所谓的*暗消息*）。'
- en: Figure 9.2\. Full view of the current Ethereum ecosystem, showing the items
    we haven’t yet covered in bold
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 当前以太坊生态系统的全面视图，以粗体显示我们尚未涵盖的项目
- en: '![](Images/fig09-02_alt.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig09-02_alt.jpg)'
- en: '*Infura nodes*—This is a set of Ethereum nodes that are hosted by Infura, a
    service owned by ConsenSys (the company also behind Truffle). Infura provides
    clients as a cloud service, with built-in security and privacy features. As for
    conventional cloud providers, Infura allows startups and independent developers
    to build Ethereum applications professionally without having to buy physical servers.
    MetaMask connects to these nodes.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Infura节点*—这是由Infura托管的一组以太坊节点，Infura是ConsenSys（也是Truffle背后的公司）拥有的服务。Infura作为云服务向客户提供节点，内置安全和隐私功能。与传统的云服务提供商一样，Infura允许初创企业和独立开发者专业地构建以太坊应用程序，而无需购买物理服务器。MetaMask连接到这些节点。'
- en: The next few sections will examine in detail ENS, Swarm, IPFS, and oracle frameworks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将详细探讨ENS、Swarm、IPFS和预言机框架。
- en: Whisper falls in the realm of message-oriented protocols. This is an advanced
    topic, so I won’t cover it further. But if you have experience in message-oriented
    applications and are eager to learn more, I encourage you to look at the Whisper
    documentation on the Ethereum wiki on GitHub ([http://mng.bz/nQP4](http://mng.bz/nQP4)
    and [https://github.com/ethereum/wiki/wiki/Whisper](https://github.com/ethereum/wiki/wiki/Whisper)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Whisper属于消息导向协议领域。这是一个高级主题，所以我不会进一步介绍。但是，如果你有消息导向应用程序的经验，并且渴望了解更多，我鼓励你查看GitHub上以太坊维基上的Whisper文档
    ([http://mng.bz/nQP4](http://mng.bz/nQP4) 和 [https://github.com/ethereum/wiki/wiki/Whisper](https://github.com/ethereum/wiki/wiki/Whisper))。
- en: From a conceptual point of view, Infura nodes work exactly like other full Ethereum
    nodes. Bear in mind, though, that Infura clients support a subset of the JSON-RPC
    standard, so you should check their technical documentation if you’re interested
    in exploring them further.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Infura节点的工作方式与其他完整以太坊节点完全一样。不过，请注意，Infura客户端支持JSON-RPC标准的子集，所以如果你对进一步探索它们感兴趣，你应该查看它们的
    technical documentation。
- en: Before closing this chapter, I’ll briefly present the main development tools
    for building Dapps. When I move on to the next chapter, I’ll focus on Truffle,
    the main smart contract development IDE, which I’ll cover in detail through hands-on
    examples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭本章之前，我将简要介绍构建Dapps的主要开发工具。当我进入下一章时，我将重点介绍Truffle，这是主要的智能合约开发IDE，我将通过实际操作示例进行详细介绍。
- en: 9.3\. Decentralized address resolution with ENS
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 使用ENS进行去中心化地址解析
- en: The Ethereum Name Service, also known as ENS, manages decentralized address
    resolution, offering a decentralized and secure way to reference resource addresses,
    such as account and contract addresses, through human-readable domain names. An
    Ethereum domain name is, as for internet domain names, a hierarchical dot-separated
    name. Each part of the domain name (delimited by dots) is called a label. Labels
    include the *root domain* at the right, for example eth, followed by the *domain
    name* at its immediate left, followed by child *subdomains*, moving further to
    the left, as illustrated in [figure 9.3](#ch09fig03).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊名称服务，也称为 ENS，管理去中心化的地址解析，提供了一种去中心化和安全的方式来引用资源地址，例如通过人类可读的域名来引用账户和合约地址。与互联网域名类似，以太坊域名是一个分层的点分隔名。域名中的每个部分（由点分隔）都称为一个标签。标签包括右侧的*根域名*，例如
    eth，紧邻其左侧的*域名*，以及进一步向左的嵌套子*子域名*，如图 9.3 所示 [figure 9.3](#ch09fig03)。
- en: Figure 9.3\. The structure of an ENS name. You can see the root domain, eth,
    at the far right, followed by the domain name at its left, and nested child subdomains
    moving from right to left.
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3。ENS 名称的结构。您可以看到最右侧的根域名 eth，紧邻其左侧的域名，以及从右向左的嵌套子域名。
- en: '![](Images/fig09-03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-03.jpg)'
- en: 'For example, you could send Ether to `roberto.manning.eth` (which is a subdomain
    of eth) rather than to `0xe6f8d18d692eeb02c3321bb9a33542903073ba92`, or you could
    reference a contract with `simplecoin.eth` rather than with its original deployment
    address: `0x3bcfb560e66094ca39616c98a3b685098d2e7766`, as illustrated in [figure
    9.4](#ch09fig04). ENS also allows you to reference other resources, such as Swarm
    and IPFS content hashes (which we’ll meet later in the next section), through
    friendly names.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将以太币发送到 `roberto.manning.eth`（这是 eth 的子域名）而不是 `0xe6f8d18d692eeb02c3321bb9a33542903073ba92`，或者您可以使用
    `simplecoin.eth` 引用一个合约，而不是使用其原始部署地址：`0x3bcfb560e66094ca39616c98a3b685098d2e7766`，如图
    9.4 所示 [figure 9.4](#ch09fig04)。ENS 还允许您通过友好名称引用其他资源，例如 Swarm 和 IPFS 的内容哈希（我们将在下一节中介绍）。
- en: Figure 9.4\. ENS resolves names into external (user) addresses, contract addresses,
    and Swarm content hashes. You can’t tell from the domain name itself if it’s mapped
    to an address or a Swarm hash. As you’ll see later, a domain name must be mapped
    explicitly to a specific name resolver for either an address or a Swarm hash (or
    some other resource identifier).
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4。ENS 将名称解析为外部（用户）地址、合约地址和 Swarm 内容哈希。从域名本身无法判断它是否映射到一个地址或 Swarm 哈希。正如您稍后所看到的，一个域名必须明确映射到一个特定的名称解析器，以映射到一个地址或
    Swarm 哈希（或其他资源标识符）。
- en: '![](Images/fig09-04_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-04_alt.jpg)'
- en: 'ENS is encapsulated as a smart contract, and because its logic and state are
    stored on the blockchain, and therefore decentralized across the Ethereum network,
    it’s considered inherently more secure than a centralized service such as the
    internet Domain Name Service (DNS). Another advantage of ENS is that it’s decentralized
    not only from an infrastructural point of view, but also from a governance point
    of view: domain names aren’t managed by a central authority, but they can be registered
    directly by the interested parties through registrars. A registrar is a smart
    contract that manages a specific root domain, such as eth. Domains are assigned
    to the winners of open auctions executed on the related registrar contract, and
    they also become the owners of the child subdomains.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ENS 被封装成一个智能合约，由于其逻辑和状态存储在区块链上，并且因此在整个以太坊网络中分散存储，所以它被认为比像互联网域名服务（DNS）这样的集中式服务更安全。ENS
    的另一个优势是，它不仅在基础设施层面上是去中心化的，而且在治理层面上也是去中心化的：域名不由中央权威机构管理，而是可以直接由感兴趣的各方通过注册商注册。注册商是一个管理特定根域（如
    eth）的智能合约，域名分配给在相关注册商合约上执行的开放拍卖的胜出者，他们也将成为子域的所有者。
- en: 9.3.1\. ENS design
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1。ENS 设计
- en: 'The ENS system is structured as three main components:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ENS 系统由三个主要组件组成：
- en: '*Registrar*—This is a contract that manages domain ownership. You must claim
    a domain name through the registrar and associate it with one of your accounts
    before you can register specific full domain names associated with it. Specific
    registrars handle each root domain, such as .eth, which is the root domain for
    names associated with Ethereum mainnet addresses, or .swarm, which is the root
    domain for names associated with swarm content hashes. Note that you must perform
    the ownership of domain names pointing to TESTNET Ethereum addresses through a
    test registrar that manages the .test root domain. This is a separate registrar
    from the one managing the .eth root domain.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册商—这是一个管理域名所有权的合约。你必须通过注册商认领一个域名，并将其与你的一个账户关联，然后才能注册与它关联的具体全域名。特定的注册商处理每个根域名，例如.eth，这是与以太坊主网地址关联的名称的根域名，或者.swarm，这是与swarm内容哈希关联的名称的根域名。请注意，你必须通过管理.test根域名的测试注册商来执行指向TESTNET以太坊地址的域名所有权，这是一个与管理和.eth根域名的注册商分开的注册商。
- en: '*Resolvers*—These are smart contracts that implement a common ABI interface
    specified in Ethereum Improvement Proposal (EIP) 137, which you can consult here:
    [http://eips.ethereum.org/EIPS/eip-137](http://eips.ethereum.org/EIPS/eip-137).
    A resolver translates a domain name into a resource identifier. Each resolver
    is specific to one resource type. For example, there’s a resolver for Ethereum
    addresses (called public resolver), another resolver for IPFS content hashes,
    and so on.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器—这些是实现以太坊改进提案（EIP）137中指定的通用ABI接口的智能合约，你可以在这里查阅： [http://eips.ethereum.org/EIPS/eip-137](http://eips.ethereum.org/EIPS/eip-137)。解析器将域名翻译成资源标识符。每个解析器都针对一种特定的资源类型。例如，有一个针对以太坊地址（称为公共解析器）的解析器，另一个针对IPFS内容哈希的解析器，等等。
- en: '*Registry*—This is, in a nutshell, a map between domain (or subdomain) names
    and domain name resolvers.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表—简而言之，这是一个域名（或子域名）名称与域名解析器的映射。
- en: 'The simple design of the ENS registry, shown in [figure 9.5](#ch09fig05), makes
    it easily extensible, so you can reference custom resolvers implementing address
    translation rules of any complexity. Also, it can support a new resource type
    in the future without needing any modification and redeployment of the registry:
    a domain name for a new resource type will point to a new resolver. [Figure 9.6](#ch09fig06)
    shows the domain name resolution process.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ENS注册表的简单设计，如图9.5所示，使其容易扩展，因此你可以引用实现任何复杂度的地址转换规则的自定义解析器。此外，它可以在未来支持新的资源类型，而不需要对注册表进行任何修改和重新部署：新资源类型的域名将指向新的解析器。图9.6显示了域名解析过程。
- en: Figure 9.5\. The ENS registry design. The ENS registry contract is a map between
    resource types and related domain resolver contracts. In the future, it can support
    a new resource type by pointing a domain name (associated with the new resource
    type) to a new resolver. Domain ownership is registered through a specific registrar.
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5 ENS注册表设计。ENS注册表合约是一个资源类型与相关域名解析器合约之间的映射。将来，它可以通过将域名（与新资源类型关联）指向新解析器来支持新的资源类型。域名所有权通过特定的注册商注册。
- en: '![](Images/fig09-05_alt.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-05_alt.jpg)'
- en: 'Figure 9.6\. The domain name resolution process: 1\. you query the Registry
    to identify the correct resolver; 2\. you request the relevant resolver to translate
    the domain name into an address.'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6 域名解析过程：1. 查询注册表以确定正确的解析器；2. 请求相关解析器将域名翻译成地址。
- en: '![](Images/fig09-06_alt.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-06_alt.jpg)'
- en: 'As you can see in [figure 9.6](#ch09fig06), a domain name is resolved in a
    two-step process:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图9.6中所看到的，域名解析是一个两步过程：
- en: You query the Registry to identify the correct resolver associated with the
    domain name you want to resolve, and the Registry returns the contract address
    of the relevant resolver.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你要查询注册表以确定与你要解析的域名关联的正确解析器，注册表将返回相关解析器的合约地址。
- en: You request the relevant resolver to translate the domain name into a resource
    identifier, such as an Ethereum address or a Swarm hash.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你请求相关解析器将域名翻译成资源标识符，例如以太坊地址或Swarm哈希。
- en: Every mapping record stored on the registry contains the information shown in
    [table 9.1](#ch09table01).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在注册表上的每个映射记录都包含表9.1所示的信息。
- en: Table 9.1\. ENS registry mapping record
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1 ENS注册表映射记录
- en: '| Field | Description | Example |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Domain name | For performance and privacy reasons, a hash of the domain name,
    called Namehash, is used rather than the domain name itself. Read the sidebar
    if you want to know more about this. | 0x98d934feea78b34... (Namehash of Roberto.manning.eth)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 域名 | 出于性能和隐私原因，使用域名的哈希值，称为Namehash，而不是域名本身。如果你想了解更多，请阅读侧边栏。 | 0x98d934feea78b34...
    (Roberto.manning.eth的Namehash) |'
- en: '| Domain owner | The address of the external (user) account or contract account
    owning the domain name | 0xcEcEaA8edc0830C... |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 域名所有者 | 拥有域名地址的外部（用户）账户或合同账户的地址 | 0xcEcEaA8edc0830C... |'
- en: '| Domain name resolver | The address of the resolver contract able to resolve
    the domain name for the related resource type | 0x455abc566... (public resolver
    address) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 域名解析器 | 能够解析相关资源类型的域名地址的解析器合同地址 | 0x455abc566... (公共解析器地址) |'
- en: '| Time to live | This specifies how long the mapping record should be kept
    on the registry. It can be indefinite or a specified duration. | 6778676878 (expiry
    date as UNIX epoch) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 生存时间 | 这指定了映射记录在注册表中应保持的时间。它可以是无限期或一个特定的持续时间。 | 6778676878 (UNIX epoch 过期日期)
    |'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Namehash**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Namehash**'
- en: 'For performance reasons and for the privacy of the domain owners, ENS works
    against a 32-byte hash of the domain name rather than its plain string representation.
    This hash is determined through a recursive algorithm called *Namehash*, which,
    if applied, for example, to `roberto.manning.eth`, works as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，为了保护域名所有者的隐私，ENS针对域名32字节的哈希而不是其明文字符串表示形式工作。这个哈希是通过一个称为*Namehash*的递归算法确定的，如果应用于例如`roberto.manning.eth`，则按照以下方式工作：
- en: 'Split the full domain name into labels, delimited by the dots; order them from
    the last to the first; and add an empty label as a first item:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将完整域名拆分为由点分隔的标签；从最后一个到第一个顺序排列；并添加一个空标签作为第一个项目：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pick the first item. Because it’s empty, determine the associated namehash
    by setting it to 32 ‘0’ bytes. The namehash corresponding to an increasing part
    of the full domain name is called *node*. So far, here’s what you have:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个项目。因为它是空的，所以通过将其设置为32个'0'字节来确定相关的namehash。与完整域名的增加部分对应的namehash称为*节点*。到目前为止，你已经有了以下内容：
- en: '[PRE1]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Pick the second label (`''eth''`) and determine its associated label hash by
    applying the `keccak256` hashing function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第二个标签（`'eth'`）并通过应用`keccak256`散列函数确定其关联的标签散列：
- en: '[PRE2]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Determine the node associated with the second label by hashing the concatenation
    of the previous node with the current label hash:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将前一个节点与当前标签散列连接起来进行哈希，确定与第二个标签关联的节点：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pick the third item `('manning')` and repeat steps 3 and 4.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第三个条目`('manning')`，并重复步骤3和4。
- en: Pick the fourth item `('roberto')` and repeat steps 3 and 4. Finally, the namehash
    of `roberto.manning.eth` is
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第四个条目`('roberto')`，并重复步骤3和4。最后，`roberto.manning.eth`的namehash是
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can get an idea of the output taken by the Namehash algorithm to hash `roberto`
    `.manning.eth` in the table. **Namehash algorithm steps to hash Roberto.manning.eth**
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以从表中获取Namehash算法输出，该算法用于散列`roberto` `.manning.eth`。**散列Roberto.manning.eth的Namehash算法步骤**
- en: '| Step | Label | labelHash | keccak256 (node+labelHash) | Node |'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 步骤 | 标签 | 标签散列 | keccak256 (节点+标签散列) | 节点 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | '''' | N/A | N/A | 0x000000000000... |'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | '''' | N/A | N/A | 0x000000000000... |'
- en: '| 2 | ''eth'' | 0x4f5b812789fc... | keccak256 (0x0000... 0x4f5b812789f...)
    | 0x93cdeb708b7... |'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | ''eth'' | 0x4f5b812789fc... | keccak256 (0x0000... 0x4f5b812789f...)
    | 0x93cdeb708b7... |'
- en: '| 3 | ''manning'' | 0x4b2455c1404... | keccak256 (0x93cde... 4b2455c...) |
    0x03ae0f9c3e92... |'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | ''manning'' | 0x4b2455c1404... | keccak256 (0x93cde... 4b2455c...) |
    0x03ae0f9c3e92... |'
- en: '| 4 | ''roberto'' | 0x6002ea314e6 | keccak256 (0x03e0... 6002ea3...) | 0x5fd962d5ca4599b3b6
    |'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | ''roberto'' | 0x6002ea314e6 | keccak256 (0x03e0... 6002ea3...) | 0x5fd962d5ca4599b3b6
    |'
- en: 'Here’s a JavaScript implementation of the process from Nick Johnson’s ENS utility
    library `ensutils.js` (see next section for more details), which you can run in
    the geth console or in the Node.js console:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是从Nick Johnson的ENS工具库`ensutils.js`中的JavaScript实现的过程（下一节有更多详细信息），你可以在geth控制台或Node.js控制台中运行：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** Node corresponding to empty label '' '''
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 空标签'' ''对应的节点'
- en: '***2*** Splits the full domain name into its constituent labels'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将完整域名拆分为其构成标签'
- en: '***3*** Gets current label'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 获取当前标签'
- en: '***4*** Calculates label hash'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 计算标签散列'
- en: '***5*** Concatenates previous node with current label hash (removes ''0x''
    from label hash) and calculates current node using hex encoding'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 将前一个节点与当前标签散列连接（从标签散列中移除''0x''），并使用十六进制编码计算当前节点'
- en: '***6*** Returns final node as a string'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 将最终节点作为字符串返回'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The `web3.sha3()` function creates a keccak256 hash. It doesn’t follow the SHA-3
    standard, as the name would suggest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.sha3()`函数创建了一个keccak256散列。它并不遵循SHA-3标准，正如它的名字所暗示的那样。'
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.2\. Registering a domain name
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 注册域名
- en: Enough theory! Let’s see how to register a domain name on the ENS instance running
    on the Ropsten testnet from the geth console.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理论足够了！让我们看看如何从geth控制台在Ropsten测试网络上注册ENS实例的域名。
- en: 'First of all, download the ENS JavaScript utility library from here: [http://mng.bz/vN9r](http://mng.bz/vN9r).
    Place this JavaScript file in a folder, for example, C:\ethereum\ens.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从这里下载ENS JavaScript工具库：[http://mng.bz/vN9r](http://mng.bz/vN9r)。将这个JavaScript文件放在一个文件夹中，例如，C:\ethereum\ens。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although useful for learning ENS, the ENS JavaScript utility libraries ensutils.js
    and ensutils-testnet.js aren’t meant to be used to build a production Dapp.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于学习ENS很有用，但ENS JavaScript工具库ensutils.js和ensutils-testnet.js并不适合用于构建生产Dapp。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now, from an OS shell, start up geth against TESTNET, as you’ve done several
    times before. (Remember to use the `--bootnodes` option if peer nodes aren’t located
    quickly, as you did at the start of [chapter 8](kindle_split_020.xhtml#ch08).)
    Type the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从操作系统壳中，像之前多次那样启动geth对TESTNET网络。 (如果对等节点没有快速定位，记得使用`--bootnodes`选项，就像在[第8章](kindle_split_020.xhtml#ch08)开始时那样。)
    输入以下内容：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Geth will start synchronizing, as expected. From a separate command shell,
    start an interactive console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Geth将开始同步，如预期那样。从另一个命令行窗口，启动一个交互式控制台：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then import the ENS utility library on the interactive geth console you’ve
    attached:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您附加的交互式geth控制台上导入ENS工具库：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Registering a domain on the TESTNET network means registering it on the `.test`
    root domain rather than on `.eth`, which is associated with MAINNET, the public
    production network. This means you must use the test registrar.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在TESTNET网络上注册域名意味着在`.test`根域名上注册，而不是与MAINNET（公共生产网络）关联的`.eth`。这意味着您必须使用测试注册商。
- en: The domain name I’ll be registering is `roberto.manning.test`. Pick a similar
    three-label domain name and adapt the instructions that I’m about to give you,
    accordingly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要注册的域名是`roberto.manning.test`。选择一个类似的三标签域名，并相应地调整我即将给出的指示。
- en: Checking Domain Ownership
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查域名所有权
- en: First of all, I have to check if anyone else already owns the `manning` domain.
    If someone does, I won’t be able to register my full domain name (`roberto.manning.test`);
    I’d have to ask the current owner to do it for me.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我必须检查是否还有其他人已经拥有`manning`域名。如果有，我就无法注册我的完整域名（`roberto.manning.test`）；我得请求当前所有者为我操作。
- en: 'This is how you can check if the `manning` domain is free on the test registrar:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以在测试注册商上检查`manning`域名是否可用的方法：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Check the value of `domainExpiryDate` (by entering it at the prompt). If it’s
    earlier than today, the domain is free; otherwise, you must choose another domain
    and repeat the check.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`domainExpiryDate`的值（通过在提示符下输入它）。如果它早于今天，域名是免费的；否则，您必须选择另一个域名并重复检查。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering what happens in the unlikely event that ownership of
    '`manning`' hasn’t been registered yet but another name with the same `web.sha3()`
    hash has been registered. If this happens, you won’t be able to register '`manning`'
    because it would appear to the registrar as already taken.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，在不太可能的情况下，`manning`的拥有权尚未注册，但另一个具有相同`web.sha3()`哈希的名称已被注册会发生什么。如果这种情况发生，您将无法注册`manning`，因为它会向注册商显示出已被占用。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Registering Domain Ownership
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册域名所有权
- en: 'After checking that the account is free, you can claim it by registering it
    through the test registrar against one of your TESTNET accounts; for example,
    `eth.accounts[0]`. (Make sure `accounts[0]` has enough Ether to execute the transaction
    by checking, as usual: `eth.getBalance(eth.accounts[0]);` also, replace your `accounts[0]`
    password.) Enter the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查账户空闲之后，您可以通过将账户注册到测试注册商之一来认领它；例如，`eth.accounts[0]`。 (确保`accounts[0]`有足够的以太币来执行交易，通过像往常一样检查：`eth.getBalance(eth.accounts[0]);`
    也替换您的`accounts[0]`密码。) 输入以下内容：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check the value of `tx1`, and then check that the related transaction has been
    mined by going to Ropsten etherscan: [https://ropsten.etherscan.io](https://ropsten.etherscan.io).
    Note that registering domain ownership on MAINNET is a more complex process. (See
    [https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/) for
    more details.)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`tx1`的值，然后检查相关交易是否已经挖矿，前往Ropsten etherscan： [https://ropsten.etherscan.io](https://ropsten.etherscan.io)。注意在MAINNET上注册域名所有权是一个更复杂的过程。（更多详情请参见[https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/)）
- en: Registering the domain name
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册域名
- en: Once the domain ownership transaction has been mined, it’s time to set up the
    domain name mapping configuration you saw in [table 9.1](#ch09table01). You already
    set some of the configuration (the domain account owner) by registering the domain
    ownership through the registrar. Now you have to configure the resolver and the
    target address that the domain name will be mapped to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦域名所有权交易被挖矿，就是设置您在[表9.1](#ch09table01)中看到的域名映射配置的时候了。您已经通过注册域名所有权通过注册商设置了某些配置（域名账户所有者）。现在您必须配置解析器和域名将被映射到的目标地址。
- en: 'You can map your domain name to the public resolver (which, as you know, maps
    a domain name to a given Ethereum address) through the ENS registry as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将您的域名映射到公共解析器（您知道，它将域名映射到给定的以太坊地址）通过ENS注册表如下：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check on Ropsten etherscan if `tx2` has been mined, then configure the public
    resolver to point your domain name to the target address (for example, your test
    `accounts[1]`), as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ropsten etherscan上检查`tx2`是否已挖矿，然后配置公共解析器将您的域名指向目标地址（例如，您的测试`accounts[1]`），如下所示：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Registering the Subdomain
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册子域名
- en: 'Registering the ownership of a subdomain is slightly different from registering
    the ownership of a domain, as you don’t perform it through the registrar, but
    through the ENS registry. Assign the ownership of the subdomain `Roberto.manning`
    to `accounts[2]`, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注册子域名的所有权与注册域名的所有权略有不同，因为您不是通过注册商进行操作，而是通过ENS注册表。将子域名的所有权`Roberto.manning`分配给`accounts[2]`，如下所示：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: 'The account running the transaction must be the owner of the `''manning.test''`
    domain: `accounts[0]`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行交易的账户必须是`'manning.test'`域的所有者：`accounts[0]`。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Using `accounts[2]`, the owner of the `''roberto.manning.test''` subdomain,
    you can now map it to the public resolver as usual:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`accounts[2]`，`'roberto.manning.test'`子域的所有者，您现在可以像往常一样将其映射到公共解析器：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, you can configure the public resolver to point your domain name to
    the target address (for example, your test `accounts[3]`), as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以配置公共解析器将您的域名指向目标地址（例如，您的测试`accounts[3]`），如下所示：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 9.3.3\. Resolving a domain name
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3. 解析域名
- en: 'Resolving a domain name into an address is straightforward. Resolve `''manning.test''`
    first:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将域名解析为地址是直接的。首先解析`'manning.test'`：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You’ll see
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and you can verify this is your `accounts[1]` address, as expected:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证这是您的`accounts[1]`地址，如预期那样：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a shortcut to resolve the domain name:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解析域名的一个快捷方式：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re interested in learning more about ENS—for example, to claim an .eth
    domain name in MAINNET through a commit-reveal bid—I encourage you to consult
    the official documentation written by Nick Johnson, the creator of ENS. You can
    find it at [https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣了解更多关于ENS的信息—例如，通过提交揭示出价在MAINNET上获取.eth域名—我鼓励您查阅由ENS的创建者Nick Johnson编写的官方文档。您可以在[https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/)找到它。
- en: 9.4\. Decentralized content storage
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 去中心化内容存储
- en: 'A common use case for decentralized applications is to store a sequence of
    documents proving, for example, the provenance of goods traded through the applications.
    A typical example is diamonds, which traditionally are accompanied by paper certificates
    showing that they come from legitimate mines and traders. For more complex supply
    chains, such as in the field of international trade finance ([https://en.wikipedia.org/wiki/Trade_finance](https://en.wikipedia.org/wiki/Trade_finance)),
    which involves multiple parties, such as a supplier, the bank of the supplier,
    a shipping company, an end client, and their bank, the paperwork might be more
    voluminous. Storing the equivalent electronic documentation directly on the blockchain
    would work but wouldn’t be ideal for a couple of reasons:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序的一个常见用例是存储一系列文档，例如，证明通过应用程序交易的商品的来源。一个典型的例子是钻石，传统上它们附有纸质证书，显示它们来自合法的矿山和贸易商。对于更复杂的供应链，例如在国际贸易金融领域（[https://en.wikipedia.org/wiki/Trade_finance](https://en.wikipedia.org/wiki/Trade_finance)），涉及到供应商、供应商银行、航运公司、最终客户及其银行等多个方，文件可能更加庞大。直接在区块链上存储等效的电子文档可以工作，但有两个原因使其不是理想的解决方案：
- en: The electronic documentation would bloat transactions referencing it, which
    would be processed more slowly.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子文档将使引用它的交易膨胀，从而导致处理速度变慢。
- en: Bigger transactions require more gas to process and are therefore more expensive.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的交易需要更多的燃料（gas）来处理，因此成本更高。
- en: An alternative solution would be to store the electronic documentation on an
    off-blockchain database and include in the transaction only a cryptographic hash
    of each of the documents, to prove their content. This solution isn’t perfect,
    though, because the off-blockchain database would be a centralized resource not
    easily accessible by the Ethereum nodes. Even if the decentralized application
    could access the database where the documentation was stored, having this centralized
    repository would be contrary to the spirit of decentralized applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是将电子文档存储在区块链外的数据库中，在交易中只包含每份文档的加密哈希值，以证明其内容。这个解决方案并不完美，因为区块链外的数据库将是集中式的资源，不易被以太坊节点访问。即使去中心化应用程序能够访问存储文档的数据库，但拥有这样一个集中式的仓库与去中心化应用程序的精神是相悖的。
- en: An ideal solution instead would be based on a decentralized storage repository.
    This is exactly what the Swarm platform, which is partially associated with Ethereum,
    aims to provide. Another valid alternative would be to use the existing IPFS distributed
    storage network. Let’s explore these two options.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个理想的解决方案将基于去中心化的存储仓库。这正是部分与以太坊相关的Swarm平台旨在提供的。另一个有效的替代方案将是使用现有的IPFS分布式存储网络。让我们探讨这两种选项。
- en: 9.4.1\. Swarm overview
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1 Swarm概览
- en: Swarm is a content distribution platform whose main objective is to provide
    decentralized and redundant storage to Ethereum Dapps. It focuses specifically
    on holding and exposing smart contract data and code, as well as blockchain data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm是一个内容分发平台，其主要目标是向以太坊Dapps提供去中心化和冗余的存储。它专注于持有和公开智能合约数据和代码，以及区块链数据。
- en: 'Storage is decentralized in Swarm through a P2P network that makes it resistant
    to distributed denial of service (DDoS) attacks and censorship, and that provides
    fault tolerance and guarantees zero downtime because it has no single point of
    failure. The architecture of the P2P Swarm network, shown in [figure 9.7](#ch09fig07),
    is similar to that of the Ethereum network: each node runs a Swarm client that
    manages local storage and communicates with its peer nodes through a common standard
    protocol called *bzz*. Currently, only one client implementation is available,
    written in the Go language, and it’s included in the Geth & Tools package you
    can download from the Go Ethereum website. The main difference with the Ethereum
    network is that all Ethereum nodes have the same copy of the blockchain database,
    whereas each Swarm node contains a different set of data, also illustrated in
    [figure 9.7](#ch09fig07).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过P2P网络在Swarm中进行存储，使其抵抗分布式拒绝服务（DDoS）攻击和审查，并提供容错性，保证零停机，因为它没有单点故障。如图[9.7](#ch09fig07)所示的P2P
    Swarm网络架构与以太坊网络类似：每个节点运行一个管理本地存储并通过名为*bzz*的通用标准协议与同行节点通信的Swarm客户端。目前，只有一个客户端实现可用，是用Go语言编写的，并包含在您可以从Go
    Ethereum网站下载的Geth & Tools包中。与以太坊网络的主要区别在于，所有以太坊节点都有区块链数据库的相同副本，而每个Swarm节点包含不同的数据集，如图[9.7](#ch09fig07)所示。
- en: Figure 9.7\. Architectural diagram of a Swarm network. The Swarm network, made
    of nodes each running a Swarm client, is similar to the Ethereum network, in which
    every node runs an Ethereum client. Contrary to Ethereum nodes, which all have
    the same copy of the blockchain data, each Swarm node contains a different set
    of data.
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. Swarm网络的架构图。Swarm网络由运行Swarm客户端的节点组成，类似于以太坊网络，每个节点都运行一个以太坊客户端。与以太坊节点不同，所有以太坊节点都拥有区块链数据的相同副本，而每个Swarm节点包含一组不同的数据。
- en: '![](Images/fig09-07_alt.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-07_alt.jpg)'
- en: A Swarm node is linked to an Ethereum account known as a *swarm base account*.
    The (keccak 256-bit) hash of the address of the swarm base account determines
    the *swarm base address*, which is the address of a Swarm node within the Swarm
    network. A Swarm network is associated with a specific Ethereum network. For example,
    the main production Swarm network is associated with MAINNET, and a Swarm network
    is associated with the Ropsten Ethereum network. Because Swarm is part of the
    Ethereum technology stack, it makes full use of other components of the ecosystem,
    such as ENS.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm节点与一个称为*swarm基础账户*的以太坊账户关联。swarm基础账户地址的（keccak 256位）哈希值确定*swarm基础地址*，即Swarm网络中的Swarm节点地址。Swarm网络与特定的以太坊网络相关联。例如，主生产Swarm网络与MAINNET相关联，Swarm网络与Ropsten以太坊网络相关联。由于Swarm是Ethereum技术栈的一部分，它充分利用了生态系统的其他组件，如ENS。
- en: When content is uploaded to Swarm, it’s broken down into 4 KB *chunks* that
    get scattered throughout the Swarm network. The upload process is illustrated
    in [figure 9.8](#ch09fig08).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当内容上传到Swarm时，它被分解成4KB大小的*块*，这些块散布在Swarm网络的各个部分。上传过程如图[9.8](#ch09fig08)所示。
- en: 'It involves the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下步骤：
- en: The caller uploads the content, typically a file, to the distributed preimage
    archive (DPA), which is the storage and retrieval gateway.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将内容（通常是文件）上传到分布式预像归档（DPA），这是存储和检索网关。
- en: The DPA calls a component called *chunker*.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包访问（DPA）调用一个名为*块分割器*的组件。
- en: The chunker
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分割器
- en: chops the content up into 4 KB pieces called chunks
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容分割成4KB大小的块，称为块
- en: calculates cryptographic hashes of its chunks
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算其块的加密哈希值
- en: The hashes of the chunks (or blocks) are placed in a chunks-index document.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块（或区块）的哈希值存储在一个名为chunks-index的文档中。
- en: If the chunks-index document is bigger than 4 KB, it’s chopped up into chunks
    whose hashes are then placed into a further document. This process goes on until
    the chunks are organized into a tree structure with a root index document at the
    top, followed by a layer of index chunks in the middle and the content chunks
    at the bottom, as illustrated in [figure 9.9](#ch09fig09). This data structure
    is a Merkle tree, the same data structure a blockchain database uses to link its
    blocks.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果chunks-index文档大于4KB，它将被分割成块，其哈希值随后放置在另一个文档中。这个过程一直持续到块被组织成一个树结构，顶部是一个根索引文档，中间是一层索引块，底部是内容块，如图[9.9](#ch09fig09)所示。这种数据结构是一个默克尔树，这是区块链数据库用来链接其区块的相同数据结构。
- en: 'Figure 9.8\. The Swarm upload process: 1\. the caller uploads a file to the
    distributed preimage archive gateway; 2\. the DPA sends the file to a chunker;
    3\. the chunker chops the file into 4 KB chunks and calculates a hash for each
    one; 4\. the chunk hashes are placed in a chunk-index document; 5\. the chunkindex
    document is chunked and reorganized in a Merkle tree structure, whose root hash
    is called root key; 6\. the chunker stores each chunk onto the netStore against
    its hash; 7\. the netStore distributes 4 KB chunks across the Swarm network; 8\.
    the chunker returns the root key to the DPA; 9\. finally, the DPA returns the
    root key to the caller.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8。Swarm上传过程：1. 调用者将文件上传到分布式预图像档案网关；2. DPA将文件发送到块分割器；3. 块分割器将文件切成4 KB块并计算每个块的哈希值；4.
    块哈希值放置在块索引文档中；5. 块索引文档被切成块，并重新组织成Merkle树结构，其根哈希称为根键；6. 块分割器将每个块根据其哈希值存储到网络存储中；7.
    网络存储将4 KB块分布在Swarm网络中；8. 块分割器将根键返回给DPA；9. 最后，DPA将根键返回给调用者。
- en: '![](Images/fig09-08_alt.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig09-08_alt.jpg)'
- en: The chunker stores each chunk on the netStore against its hash key.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分割器根据其哈希键在每个块上存储块。
- en: The netStore is an implementation of a *distributed hash table* (DHT) across
    the Swarm network, so chunks are stored on many Swarm nodes. Because the key of
    this distributed hash table is a cryptographic hash key, which is a representation
    of the underlying content, this way of storing data is also known as *content
    addressable storage* (CAS).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络存储是Swarm网络上分布式哈希表（DHT）的一个实现，因此块存储在许多Swarm节点上。由于这个分布式哈希表的键是一个加密哈希键，它是底层内容的一种表示，这种存储数据的方式也被称为内容可寻址存储（CAS）。
- en: The chunker returns the hash key of the root index document, known as *root
    key*, and hands it back to the DPA.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分割器返回根索引文档的哈希键，称为*根键*，并将其交还给DPA。
- en: The DPA finally returns the root key to the caller. This will later be used
    to download the original file from Swarm.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，DPA将根键返回给调用者。这将在稍后用于从Swarm下载原始文件。
- en: Figure 9.9\. Chunk and chunk-index Merkle tree structure. The document at the
    top contains the hashes of chunks of the initial chunk-index document (containing
    the hashes of all 4 KB chunks). The intermediate layer is made of chunks of the
    initial chunk-index document. The layer at the bottom contains the 4 KB chunks
    of the original file.
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9。块和块索引Merkle树结构。顶部的文档包含初始块索引文档（包含所有4 KB块的哈希值）的块哈希。中间层由初始块索引文档的块组成。最底层包含原始文件的4
    KB块。
- en: '![](Images/fig09-09_alt.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-09_alt.jpg)'
- en: 'The download process goes through a similar workflow, but in reverse order,
    as shown in [figure 9.10](#ch09fig10):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下载过程经历一个类似的流程，但顺序相反，如图9.10[所示](#ch09fig10)：
- en: A caller hands a root key to the DPA.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将根键交给DPA。
- en: The DPA calls the chunker, and it supplies the root key.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DPA调用块分割器，它提供了根键。
- en: The chunker retrieves the root chunk associated with the root key from the netStore,
    then walks the tree until it has retrieved all the chunks from the Swarm network.
    While chunks are flowing from their netStore location (the specific Swarm node
    they’re stored on) to the chunker, they get cached into each Swarm node they go
    through, so often if the same content is requested, subsequent downloads will
    be faster.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分割器从网络存储中检索与根键关联的根块，然后遍历树结构，直到从Swarm网络中检索到所有块。当块从它们的网络存储位置（它们存储在的具体Swarm节点）流向块分割器时，它们会在每个经过的Swarm节点中缓存，因此如果请求相同的内容，后续下载通常会更快。
- en: The chunker reconstructs the file from the chunks and returns it to the DPA.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分割器从块中重建文件，并将其返回给数据包协议器。
- en: The DPA returns the requested file to the caller.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包协议器将请求的文件返回给调用者。
- en: From an operational point of view, the sustainability of the Swarm platform
    is based on monetary incentives aimed at encouraging and rewarding participants
    who provide the underlying storage resources. Storage is traded between participants
    who require it and those who provide it, so it tends to be allocated efficiently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作角度来看，Swarm平台的可持续性基于旨在鼓励和奖励提供底层存储资源的参与者的货币激励。存储在需要它的参与者和提供它的参与者之间进行交易，因此它倾向于被高效地分配。
- en: 'Figure 9.10\. The Swarm download process: 1\. a caller hands a root key to
    the DPA; 2\. the DPA calls the chunker, and it supplies the root key; 3\. the
    chunker retrieves the root chunk associated with the root key from the netStore,
    then walks the tree until it has retrieved all the chunks from the Swarm network;
    4\. the chunker reconstructs the file from the chunks and returns it to the DPA;
    5\. the DPA returns the requested file to the caller.'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.10\. Swarm 下载过程：1\. 调用者将根密钥交给 DPA；2\. DPA 调用分块器，并提供根密钥；3\. 分块器从 netStore
    检索与根密钥关联的根块，然后遍历树，直到它从 Swarm 网络检索到所有的块；4\. 分块器从块中重构文件并将其返回给 DPA；5\. DPA 将请求的文件返回给调用者。
- en: '![](Images/fig09-10_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-10_alt.jpg)'
- en: 9.4.2\. Uploading and downloading content to and from Swarm
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 使用 Swarm 上传和下载内容
- en: In this section, I’ll show you how to upload content to Swarm, get its root
    key, and then download it back from Swarm using the root key.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何将内容上传到 Swarm，获取其根密钥，然后使用根密钥从 Swarm 下载内容。
- en: Connecting to Swarm
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接到 Swarm
- en: 'The first step you have to take is to download the Swarm client, swarm.exe,
    from the Go Ethereum website. If you downloaded geth from the Geth & Tools archive
    (or installer) link, you should already have swarm.exe in the same folder you’re
    running geth from. Otherwise, go back to the Go Ethereum website and download
    the Geth & Tools 1.8.12 package, which I believe is the latest archive still containing
    swarm.exe. Unzip it and copy swarm.exe into the same folder where you’ve placed
    geth.exe. In my case, I’ve placed it here: C:\Program Files\geth.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先做的步骤是从未经 Geth & Tools 归档（或安装程序）链接下载的 Swarm 客户端，swarm.exe，从 Go Ethereum
    网站下载。如果你从 Geth & Tools 存档链接（或安装程序）下载了 geth，你应该已经在运行 geth 的相同文件夹中已经有了 swarm.exe。否则，回到
    Go Ethereum 网站下载 Geth & Tools 1.8.12 包，我相信这是仍然包含 swarm.exe 的最新存档。解压缩它并将 swarm.exe
    复制到您放置 geth.exe 的相同文件夹中。在我的案例中，我将其放在这里：C:\Program Files\geth。
- en: 'Now start up geth against TESTNET. (Remember to use the `--bootnodes` option
    if peer nodes aren’t located quickly, as you did at the start of [chapter 8](kindle_split_020.xhtml#ch08).)
    Type the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在针对 TESTNET 启动 geth。 (如果对等节点没有快速定位，请记得使用 `--bootnodes` 选项，正如你在第 8 章开始时所做的那样。)
    输入以下内容：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Geth will start synchronizing, as expected. From a separate command shell,
    start an interactive console:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所预期的，geth 将开始同步。从另一个命令提示符窗口，启动一个交互式控制台：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, from the interactive console, get the address of your testnet `accounts[1]`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从交互式控制台获取您的测试网 `accounts[1]` 的地址：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You’ll run the Swarm client under this account by opening a new OS console
    and executing the following command from the folder where you placed the swarm
    executable (replacing your Ethereum testnet folder accordingly):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在此账户下运行 Swarm 客户端，通过打开一个新的操作系统控制台，从放置 swarm 可执行文件的文件夹执行以下命令（相应地替换您的 Ethereum
    测试网文件夹）：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Table 9.2](#ch09table02) explains the options I’ve used to start up the Swarm
    client.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9.2](#ch09table02) 解释了启动 Swarm 客户端时我使用的选项。'
- en: Table 9.2\. Options used to start up the Swarm client
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.2\. 启动 Swarm 客户端时使用的选项
- en: '| Option | Purpose |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 目的 |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| --datadir | Specifies the datadir path related to the environment to use—in
    our case, TESTNET (Ropsten) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --datadir | 指定与要使用的环境相关的 datadir 路径——在我们的案例中，是 TESTNET (Ropsten) |'
- en: '| --bzzaccount | Specifies the Ethereum account to use—in our case, TESTNET
    accounts[1] |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --bzzaccount | 指定要使用的 Ethereum 账户——在我们的案例中，是 TESTNET accounts[1] |'
- en: As you can see in [figure 9.11](#ch09fig11), you’ll be asked to unlock `accounts[1]`
    by providing its password. Enter the password, as requested, and the client will
    start up with output similar to that in the screenshot in [figure 9.12](#ch09fig12).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [图 9.11](#ch09fig11) 中看到的，系统会要求你通过提供其密码来解锁 `accounts[1]`。输入要求的密码，客户端将输出类似于
    [图 9.12](#ch09fig12) 截图中的内容启动。
- en: Figure 9.11\. Unlocking the Ethereum account you’re using to start up the Swarm
    client
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. 解锁用于启动 Swarm 客户端的 Ethereum 账户
- en: '![](Images/fig09-11_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-11_alt.jpg)'
- en: 'It might take a few minutes before your Swarm client synchronizes with a number
    of peers (by default up to a maximum of 25). Output similar to the following indicates
    capable peers have been found:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Swarm 客户端与多个对等节点（默认最多 25 个）同步之前，可能需要几分钟时间。输出类似于以下内容表示已经找到了有能力的对等节点：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Figure 9.12\. Swarm start-up output
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. Swarm 启动输出
- en: '![](Images/fig09-12_alt.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-12_alt.jpg)'
- en: Uploading Content
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 上传内容
- en: 'Now that you’re connected to the Swarm network, you can upload some sample
    text onto the network. Open a new OS console and submit this HTTP request to your
    Swarm client through curl:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接到Swarm网络，你可以将一些示例文本上传到网络上。打开一个新的操作系统控制台，并通过curl向你的Swarm客户端提交这个HTTP请求：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You’ll immediately get a response showing the root key associated with the
    submitted content:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你将立即得到一个显示与提交的内容相关联的根密钥的响应：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Downloading Content
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 下载内容
- en: 'To get the content back from Swarm, you can now submit a new request that includes
    the root key you obtained:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Swarm获取内容，你现在可以提交一个新的请求，包括你获得的根密钥：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As expected, you’ll get back the text you submitted earlier:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，你会得到你之前提交的文字：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The official documentation is an excellent resource to learn more about Swarm
    and to try out more advanced features: [http://mng.bz/4OBv](http://mng.bz/4OBv).
    But you also should be aware that the Swarm initiative has been criticized by
    some members of the decentralized web community for duplicating the effort of
    IPFS, a project with similar objectives but with a more general purpose. The following
    section explains IPFS and the reason for the controversy.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档是了解Swarm更多信息和尝试更多高级功能的绝佳资源：[http://mng.bz/4OBv](http://mng.bz/4OBv)。但是你也应该知道，Swarm计划已经被一些去中心化网络社区的成员批评，认为它复制了IPFS的努力，而IPFS是一个具有类似目标但用途更广泛的计划。下一节解释了IPFS和争议的原因。
- en: 9.4.3\. IPFS overview
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3 IPFS概览
- en: IPFS stands for InterPlanetary File System and, as you might guess from its
    name, is a hypermedia distribution protocol whose objective is to support a decentralized
    way of storing and sharing files. With Swarm, storage is distributed over a P2P
    network, which you can consider a distributed file system. The IPFS way of storing
    files provides the same benefits as the Swarm network, such as zero downtime and
    resistance to DDoS attacks and censorship.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS代表星际文件系统，从它的名字你可以猜测到，它是一个超媒体分发协议，旨在支持一种去中心化的存储和分享文件的方式。有了Swarm，存储是分布在一个P2P网络上的，你可以把它看作是一个分布式文件系统。IPFS存储文件的方式提供了与Swarm网络相同的优势，比如零停机时间和抵抗DDoS攻击及审查。
- en: Files aren’t stored in their entirety in a single network location; they’re
    broken down into *blocks*, which are then transformed into IPFS objects and scattered
    across the network. An IPFS object is a simple structure containing two properties
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 文件并不是完整地存储在一个单一的网络位置；它们被分解为*块*，然后被转换成IPFS对象并散布在网络上。IPFS对象是一个包含两个属性的简单结构：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'where a Link object has the following structure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其中链接对象具有以下结构：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each IPFS object is referenced by its hash.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IPFS对象都是由其哈希值引用的。
- en: An example of the IPFS object associated with a small file that’s decomposed
    into a single file block is shown in the following listing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小文件分解为单个文件块的IPFS对象示例如下。
- en: Listing 9.1\. IPFS object associated with a file containing a single block
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1 与单个块的IPFS对象关联
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **There are no links to other IPFS objects because the file is made
    of a single block.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **由于文件由一个块组成，所以没有指向其他IPFS对象的链接。**'
- en: '***2*** **This is unstructured binary data contained in the file (up to a max
    of 256 KB).**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **文件中包含的不结构化二进制数据（最大256KB）。**'
- en: An example of the IPFS object associated with a large file, bigger than 256
    KB and broken down into multiple blocks, is shown in the following listing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型文件的IPFS对象示例，大于256KB并分解为多个块，如下面的列表所示。
- en: Listing 9.2\. IPFS object of a file larger than 256 KB, split into various blocks
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2 IPFS文件大于256KB，分成多个块
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1*** **This file has been split into multiple blocks of 256 KB, each corresponding
    to an item in the Links list.**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **这个文件被分成了多个256KB的块，每个块对应于链接列表中的一个条目。**'
- en: '***2*** **Block name**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **块名**'
- en: '***3*** **Block hash**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **块哈希**'
- en: '***4*** **Block size (256 KB)**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** **块大小（256KB）**'
- en: Each block referenced in the Links array is represented by a document like that
    shown in [listing 9.1](#ch09ex01). The workflow followed by an IPFS client for
    uploading a file on IPFS is illustrated in [figure 9.13](#ch09fig13).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中引用的每个块都由一个如[列表 9.1](#ch09ex01)所示的文档表示。IPFS客户端上传文件到IPFS的工作流程在[图 9.13](#ch09fig13)中说明。
- en: 'Let’s follow the steps of the upload workflow in detail:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细跟随上传工作流程的步骤：
- en: A user uploads a file to an IPFS node.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将文件上传到IPFS节点。
- en: The IPFS node breaks the file down into blocks of a certain size (typically
    256 KB).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPFS节点将文件分解为一定大小的块（通常是256KB）。
- en: An IPFS object is created for each file block. This looks like the one shown
    in [listing 9.1](#ch09ex01). A cryptographic hash is calculated for each IPFS
    object and associated with it.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个文件块创建一个IPFS对象。这看起来像所示在[列表9.1](#ch09ex01)中的那个。为每个IPFS对象计算加密哈希，并与它关联。
- en: An IPFS object is created for the file. This contains links to IPFS objects
    associated with all the file blocks and looks like the IPFS object shown in [listing
    9.2](#ch09ex02). A cryptographic hash is calculated for this IPFS object.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文件创建一个IPFS对象。这包含到所有文件块关联的IPFS对象的链接，看起来像[列表9.2](#ch09ex02)中显示的IPFS对象。为这个IPFS对象计算加密哈希。
- en: 'Figure 9.13\. The IPFS upload process: 1\. a user uploads a file to an IPFS
    node; 2\. the IPFS node breaks down the file into 256 KB blocks; 3\. an IPFS object
    is created for each file block; 4\. an IPFS object is created for the file, and
    it contains links to IPFS objects associated with all the file blocks; 5\. each
    block is stored at a different network location, and an index holding a map between
    block hashes and corresponding network locations is maintained on each node.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.13\。IPFS上传过程：1\. 用户将文件上传到IPFS节点；2\. IPFS节点将文件分解为256 KB的块；3\. 为每个文件块创建一个IPFS对象；4\.
    为文件创建一个IPFS对象，其中包含到所有文件块关联的IPFS对象的链接；5\. 每个块存储在不同的网络位置，并且在每个节点上维护一个索引，该索引持有块哈希和相应的网络位置之间的映射。
- en: '![](Images/fig09-13_alt.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig09-13_alt.jpg)'
- en: Each block is stored at a different network location, and an index holding a
    map between block hashes and corresponding network locations is maintained on
    each node. You might have realized content is referenced by its own cryptographic
    hash key, as in the case of the Swarm platform, so you can also consider IPFS
    to be content addressable storage (CAS).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个块存储在不同的网络位置，并且在每个节点上维护一个索引，该索引持有块哈希和相应的网络位置之间的映射。您可能已经意识到内容以其自己的加密哈希键引用，正如Swarm平台的情况一样，因此您还可以将IPFS视为内容可寻址存储（CAS）。
- en: Given that content is referenced by its hash, this design is focused on managing
    efficiently immutable files. For example, only one copy of a document has to exist
    in the network because its hash must point only to one network location, so duplication
    is eliminated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到内容以其哈希值引用，这种设计主要集中在高效管理不可变文件。例如，因为其哈希必须只指向一个网络位置，所以网络上只需要存在文档的一个副本，因此消除了重复。
- en: But IPFS is also capable of managing mutable documents by tracking their changes
    through versioning. When a file changes, only its amended blocks need to be hashed,
    stored on the network, and indexed, and the unaffected blocks will be reused.
    The workflow of the download process is shown in [figure 9.14](#ch09fig14).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，IPFS也通过跟踪通过版本控制它们的变化来管理可变文档。当文件更改时，只需对其更改的块进行哈希、存储在网络上、索引，而未受影响的块将被重用。下载过程的工作流程显示在[图9.14](#ch09fig14)中。
- en: 'Here are the steps of the workflow in detail:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是工作流程的详细步骤：
- en: 'Figure 9.14\. The IPFS file download process: 1\. IPFS is queried for a file
    associated with a certain IPFS file object hash key; 2\. the IPFS client requests
    the file object from the corresponding IPFS node; 3\. the requested node returns
    the IPFS file object; 4\. the IPFS client scans each link on the Links property
    of the IPFS file object; 5\. each requested IPFS node returns the corresponding
    IPFS block object; 6\. the original file is recomposed on the IPFS node serving
    the request, and it’s returned to the caller.'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14\。IPFS文件下载过程：1\. 查询IPFS与某个IPFS文件对象哈希键关联的文件；2\. IPFS客户端从相应的IPFS节点请求文件对象；3\.
    请求的节点返回IPFS文件对象；4\. IPFS客户端扫描IPFS文件对象Links属性上的每个链接；5\. 每个请求的IPFS节点返回相应的IPFS块对象；6\.
    在提供请求的IPFS节点上重新组合原始文件，并将其返回给调用者。
- en: '![](Images/fig09-14_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-14_alt.jpg)'
- en: A user queries IPFS for a file associated with a certain IPFS file object hash
    key.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户查询与某个IPFS文件对象哈希键关联的IPFS文件。
- en: The IPFS client retrieves the network location of the IPFS file object associated
    with the provided hash key by looking it up on the local IPFS index, and then
    it requests the file object from the corresponding IPFS node.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPFS客户端通过在本地IPFS索引上查找来检索与提供的哈希键关联的IPFS文件对象的网络位置，然后从相应的IPFS节点请求文件对象。
- en: The requested node returns the IPFS file object.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的节点返回IPFS文件对象。
- en: The IPFS client scans each link on the Links property of the IPFS file object.
    For each link, it retrieves the network location associated with the IPFS object
    key from the local index and then uses the network location to retrieve the corresponding
    IPFS block object.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPFS客户端扫描IPFS文件对象Links属性下的每个链接。对于每个链接，它从本地索引中检索与IPFS对象键关联的网络位置，然后使用网络位置检索相应的IPFS块对象。
- en: Each requested IPFS node returns the corresponding IPFS block object.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个请求的IPFS节点返回相应的IPFS块对象。
- en: The original file is recomposed on the IPFS node serving the request, and it’s
    returned to the caller.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始文件在响应请求的IPFS节点上重新组合，然后返回给调用者。
- en: Contrary to Swarm, IPFS gives no direct incentives to its P2P participants for
    contributing to the network’s file storage resources, and it relies on FileCoin,
    a separate but related initiative based on the Bitcoin blockchain, to reward active
    participants.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与Swarm相反，IPFS没有直接激励其P2P参与者为网络文件存储资源做出贡献，它依赖于基于比特币区块链的独立但相关的FileCoin计划来奖励活跃参与者。
- en: 'If you want to learn more about IPFS, download the client and give it a go
    at [https://ipfs.io/docs/getting-started/](https://ipfs.io/docs/getting-started/).
    I recommend you also have a look at the Git book *The Decentralized Web Primer*,
    which has various tutorials on how to install an IPFS client and how to interact
    with the network and examine IPFS objects through common operations such as uploading
    and then downloading a file: [http://mng.bz/QQxQ](http://mng.bz/QQxQ). (Click
    the green Read button to access the content.)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于IPFS的信息，下载客户端并尝试一下[https://ipfs.io/docs/getting-started/](https://ipfs.io/docs/getting-started/)。我建议你也看看Git书籍《去中心化网络入门》，其中有很多关于如何安装IPFS客户端以及如何通过上传和下载文件等常见操作与网络互动并检查IPFS对象的教程：[http://mng.bz/QQxQ](http://mng.bz/QQxQ)。（点击绿色的阅读按钮访问内容。）
- en: 9.4.4\. Swarm vs. IPFS
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.4. Swarm 与 IPFS
- en: At this point, do you think Swarm is duplicating the effort of IPFS, as some
    members of the decentralized web have argued? Now that you know about both decentralized
    content management infrastructures, you can probably judge for yourself whether
    the Swarm initiative has been worthwhile. [Table 9.3](#ch09table03), which summarizes
    the main features of both platforms, might help you answer the question.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，你认为Swarm是否在复制IPFS的努力，正如一些去中心化网络成员所争论的那样？既然你已经了解了这两个去中心化内容管理基础设施，你可能自己可以判断Swarm计划是否值得。表9.3（#ch09table03），总结了这两个平台的的主要特性，可能帮助你回答这个问题。
- en: Table 9.3\. Comparison of Swarm vs. IPFS
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.3. Swarm 与 IPFS 对比
- en: '| Feature | Swarm | IPFS |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | Swarm | IPFS |'
- en: '| --- | --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Storage architecture | Decentralized | Decentralized |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 存储架构 | 去中心化 | 去中心化 |'
- en: '| Network architecture | P2P | P2P |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 网络架构 | P2P | P2P |'
- en: '| Content Accessible Storage | Yes | Yes |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 可访问存储内容 | 是 | 是 |'
- en: '| Block/chunk size | 4 KB | 256 KB |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 块/区块大小 | 4 KB | 256 KB |'
- en: '| Native integration with Ethereum | Yes | No |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 与以太坊的本地集成 | 是 | 否 |'
- en: '| Incentive strategy | Built-in | External (through FileCoin) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 激励策略 | 内置 | 外部（通过FileCoin） |'
- en: 'Fans of the Swarm platform argue that its smaller chunk size, which allows
    much lower transmission latency, and its deeper integration with Ethereum are
    by themselves two key reasons for the existence of Swarm. You can find further
    analysis of the difference between Swarm and IPFS online on various forums, such
    as Ethereum stack exchange: [http://mng.bz/Xg0p](http://mng.bz/Xg0p).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm平台的粉丝认为，其更小的区块大小，允许更低的传输延迟，以及与以太坊更深入的集成，本身就是Swarm存在的两个关键原因。你可以在各种论坛上找到Swarm与IPFS之间差异的进一步分析，例如以太坊问答论坛：[http://mng.bz/Xg0p](http://mng.bz/Xg0p)。
- en: 9.5\. Accessing external data through oracles
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 通过预言机访问外部数据
- en: 'Conventional web applications consume a variety of external services, typically
    by performing REST API calls or invoking legacy web services. You might be surprised
    to hear that this isn’t possible in the Dapp world. By design, Ethereum contracts
    can’t access external sources. This is to avoid two main set of issues:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的网络应用程序消耗各种外部服务，通常是通过执行REST API调用或调用遗留的Web服务。你可能会惊讶地听说这在Dapp世界是不可能的。按设计，以太坊合约不能访问外部资源。这是为了避免两组主要问题：
- en: '*Trust issues*—Participants might be wary about the authenticity of the data
    and its potential manipulation before making it into the blockchain.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任问题*——参与者可能会对数据的真实性及其进入区块链前的潜在操纵持谨慎态度。'
- en: '*Technical issues*—The data provider might struggle to serve thousands of simultaneous
    requests coming from the Ethereum network, therefore compromising the block creation
    and validation process.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术问题*——数据提供者可能难以服务于来自以太坊网络的成千上万的并发请求，因此会妥协区块创建和验证过程。'
- en: 'How do you get external data into your smart contract so you can work around
    the restrictions that the Ethereum infrastructure imposes and be confident about
    the data’s authenticity? You do it through oracles. An *oracle* is, in short,
    a bridge between the blockchain network and the outside world. It takes care of
    fetching the queried data from external data providers, and then it returns it
    to the requesting contract together with a *proof of authenticity*. Having the
    process arranged that way, you can see an oracle as a middleman that merely plays
    a facilitating role. Although it’s a point of centralization, the requesting contract
    doesn’t need to trust the oracle because the oracle can’t modify the data it’s
    returning without invalidating it against the proof of authenticity (which the
    end user can verify). [Figure 9.15](#ch09fig15) shows the main components that
    are part of a typical oracle-based data-feeding solution:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何将外部数据引入智能合约，以便绕过以太坊基础设施施加的限制，并确信数据的 authenticity？ 通过预言机实现。简而言之，*预言机* 是区块链网络与外部世界之间的桥梁。它负责从外部数据提供者获取查询的数据，然后将其与一个
    *真实性证明* 一同返回给请求合约。按照这种方式安排流程，您可以将预言机视为一个仅仅发挥促进作用的中间人。尽管它是一个集中点，但请求合约不需要信任预言机，因为预言机在没有使其与真实性证明（最终用户可以验证）无效的情况下，无法修改其返回的数据。（#ch09fig15）展示了典型预言机基础数据喂养解决方案的主要组成部分：
- en: '*A contract*—This executes a query to retrieve some data.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合约*——执行查询以检索某些数据。'
- en: '*An oracle*—This connects the contract to the relevant data provider by resolving
    the query and fetching the data from the data provider.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预言机*——通过解决查询并从数据提供者获取数据，将合约连接到相关数据提供者。'
- en: Figure 9.15\. An oracle is a bridge between the blockchain network and the outside
    world. It takes care of fetching the requested data from external data providers
    and returns it to the requesting contract with a proof of authenticity.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.15. 预言机是区块链网络与外部世界之间的桥梁。它负责从外部数据提供者获取所需的数据，并将其与真实性证明一起返回给请求合约。
- en: '![](Images/fig09-15_alt.jpg)'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig09-15_alt.jpg)'
- en: '*A set of data sources*—These might include REST APIs, legacy web services,
    online random generators, or online calculators, for example.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一组数据源*——这些可能包括 REST API、遗留的 Web 服务、在线随机生成器或在线计算器，例如。'
- en: '*TLSNotary*—This service generates cryptographic proofs of online data.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TLSNotary*——该服务生成在线数据的加密真实性证明。'
- en: '*IPFS store*—This is where data returned together gets stored with proof of
    authenticity for later off-blockchain verification, if needed.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPFS 存储*——这是数据和真实性证明一起存储的地方，以供以后离线区块链验证，如有需要。'
- en: 9.5.1\. Feeding oracles
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1. 喂养预言机
- en: 'You can use two main strategies for feeding an oracle so consumers can trust
    its data:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用两种主要策略来喂养预言机，以便消费者相信其数据：
- en: '*Independent participants can feed an oracle.* In this case, the oracle aggregates
    the original data coming from the different participants through a consensus model,
    and then it feeds the data to the consumer.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*独立参与者可以喂养预言机*。在这种情况下，预言机通过共识模型聚合来自不同参与者的原始数据，然后将数据提供给消费者。'
- en: '*A single data provider can feed an oracle.* In this case, the oracle supplies
    the consumer a copy of the original data, accompanied with a proof of authenticity
    of that data.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一个数据提供者可以喂养一个预言机*。在这种情况下，预言机向消费者提供原始数据的副本，并附有该数据的真实性证明。'
- en: Oracle Fed by Independent Participants
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Oracle 喂养独立参与者
- en: 'When independent participants feed an oracle, the approved data set is generated
    on a consensus basis, for example by averaging numeric values or selecting the
    most frequent non-numeric values. This way of feeding data, which happens in a
    decentralized fashion and is subject to a consensus, seems to naturally fit the
    spirit of decentralized applications. But it has various drawbacks:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当独立参与者喂养预言机时，经过共识生成的批准数据集，例如通过平均数值或选择最频繁的非数值。这种数据喂养方式，以去中心化的方式进行，并受到共识的约束，似乎很自然地符合去中心化应用程序的精神。但它有各种缺点：
- en: A high number of feeders might be necessary to generate a reliable data set.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要大量的数据提供者来生成一个可靠的数据集。
- en: The oracle provider relies on feeders constantly keeping up with new data requests.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预言机提供商依赖于数据提供者不断跟上新的数据请求。
- en: All the data feeders might expect to get paid regardless of the quality of their
    data. This might prove expensive for the oracle provider.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的数据提供者可能期望得到支付，不管他们的数据质量如何。这可能会证明对预言机提供商来说很昂贵。
- en: Oracle Fed by the Provider from a Single Data Source
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 由单一数据源提供的预言机
- en: When a single source feeds an oracle, it demonstrates that the exposed data
    is genuine and untampered with by returning it to a client together with a proof
    of authenticity document. Services such as TLSNotary can generate the document,
    and it’s based on various technologies, such as auditable virtual machines and
    trusted execution environments.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个单一的数据源喂养一个预言机时，它通过与数据真实性证明文档一起返回数据给客户端，从而展示暴露的数据是真实且未被篡改的。像TLSNotary这样的服务可以生成该文档，它基于各种技术，比如可审计的虚拟机和可信执行环境。
- en: 'Oraclize offers one of the most popular frameworks for feeding smart contracts
    from a single source. This solution has two main advantages with respect to oracles
    fed by multiple participants:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize提供了从单一数据源喂养智能合约最受欢迎的框架之一。与由多个参与者喂养的预言机相比，这个解决方案有两个主要优点：
- en: Dapp developers and users don’t need to trust Oraclize, as they can verify the
    truthfulness of the data independently against the proof of authenticity, both
    on-chain from within contract code and off-chain through web verification tools.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dapp开发者和用户不需要信任Oraclize，因为他们可以独立地通过合约代码内的链上验证和链下通过网络验证工具来验证数据的真伪。
- en: Data providers don’t need to implement new ways of distributing data, on top
    of their current web services or web APIs, to feed decentralized applications.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据提供者不需要实现新的数据分发方式，除了他们当前的Web服务或Web API，来喂养去中心化应用。
- en: Enough talking! I’ll now show you how to build your first oracle consumer contract.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不多说了！我现在将向你展示如何构建你的第一个预言机消费者合约。
- en: 9.5.2\. Building a data-aware contract with Oraclize
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. 使用Oraclize构建一个数据驱动的合约
- en: If you want to hook a contract into Oraclize, you have to
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将一个合约连接到Oraclize，你必须
- en: import a Solidity file named oraclizeAPI.sol, available from the Oraclize GitHub
    repository
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入一个名为oraclizeAPI.sol的Solidity文件，可以从Oraclize GitHub仓库获取
- en: inherit your contract from a base contract called usingOraclize
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承你的合约自一个叫做usingOraclize的基合约
- en: Your contract, as illustrated in the sample oracle shown in [listing 9.3](#ch09ex03)
    (which comes from the Oraclize documentation), should contain
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你的合约，如图[9.3](#ch09ex03)所示的示例预言机（来自Oraclize文档），应该包含
- en: one or more *state variables* holding the latest value of a copy of the external
    data being requested; in this example, ETHXBT (the Ether to Bitcoin exchange rate)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个*状态变量*，持有请求的外部数据的最新副本；在这个例子中，ETHXBT（以太坊对比特币的汇率）
- en: an `update()` function that an end user can invoke to refresh the local copy
    of the external data through a request to Oraclize
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`update()`函数，终端用户可以调用它通过请求Oraclize来刷新外部数据的本地副本。
- en: a callback function named `__callback`, which is invoked from the result transaction
    that Oraclize produces
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`__callback`的回调函数，它从Oraclize产生的结果交易中被调用
- en: Listing 9.3\. Contract providing ETHXBT rate from the Kraken exchange through
    Oraclize
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 通过Oraclize从Kraken交易所获取ETHXBT率的合约
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** **Imports the Oraclize client code from their GitHub repository**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从他们的GitHub仓库导入Oraclize客户端代码**'
- en: '***2*** **Inherits from the base contract usingOraclize**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **继承自基合约usingOraclize**'
- en: '***3*** **State variable holding the external data: exchange rate for Ether
    to Bitcoin from Kraken**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **持有外部数据的状态变量：从Kraken获取的以太坊对比特币的汇率**'
- en: '***4*** **Event logging whether the data query has been sent to Oraclize**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **记录事件，事件表明数据查询是否已发送给Oraclize**'
- en: '***5*** **Event logging whether Oraclize has returned the requested data**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **记录事件，表明Oraclize是否已返回请求的数据**'
- en: '***6*** **Contract constructor**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **合约构造函数**'
- en: '***7*** **Specifies that the data requested should be accompanied by TLSNotary
    proof and that the proof should get stored on IPFS**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **指定请求的数据应伴随TLSNotary证明，并且证明应该存储在IPFS上**'
- en: '***8*** **Sets the ETHXBT state variable when the contract is created**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **在合约创建时设置ETHXBT状态变量**'
- en: '***9*** **Callback invoked by Oraclize when returning the requested data to
    the contract**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **当Oraclize将请求的数据返回给合约时调用的回调**'
- en: '***10*** **Updates the ETHXBT state with the value that Oraclize returned**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **用Oraclize返回的值更新ETHXBT状态**'
- en: '***11*** **Logs the requested data that Oraclize has returned**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **记录Oraclize返回的请求数据**'
- en: '***12*** **Triggers a new update so that the contract keeps refreshing ETHXBT
    continuously**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** **触发新的更新，使合约持续刷新ETHXBT**'
- en: '***13*** **Triggers the update of ETHXBT, which can be invoked by an end user
    or internally, as mentioned previously**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13*** **触发ETHXBT的更新，如前所述，可以由终端用户或内部调用**'
- en: '***14*** **Checks if the contract has enough Ether to fund the data request
    to Oraclize**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***14*** **检查合约是否有足够的以太币资助向Oraclize的数据请求**'
- en: '***15*** **Data request query to Oraclize**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***15*** **向Oraclize的数据请求查询**'
- en: Oraclize Data Request
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Oraclize数据请求
- en: 'Look closely at the data request to the Oraclize engine within the update method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察更新方法中向Oraclize引擎的数据请求：
- en: '[PRE34]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The data request is performed by calling the `oraclize_query()` function, inherited
    from the `usingOraclize` base contract, with a set of parameters, as shown in
    [figure 9.16](#ch09fig16):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 数据请求是通过调用`oraclize_query()`函数实现的，该函数继承自`usingOraclize`基合约，并带有如图9.16所示的一组参数：
- en: '*Request delay*—Number of seconds that should be waited before retrieving the
    data (can also be an absolute timestamp in the future)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请求延迟*—在检索数据之前应等待的秒数（也可以是一个未来的绝对时间戳）'
- en: '*Data source type*—Oraclize supports various data sources types, but we’ll
    focus mainly on the following:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源类型*—Oraclize支持各种数据源类型，但我们主要关注以下类型：
- en: '*URL*—Website or HTTP API endpoint'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URL*—网站或HTTP API端点'
- en: '*IPFS*—Identifier of an IPFS file (content hash)'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPFS*—IPFS文件的标识符（内容哈希）'
- en: '*Query*—This is a single parameter or an array of parameters whose values depend
    on the data source type. For example, for requests of type URL, if you supply
    only one parameter (the URL of the data source), the call is assumed to be an
    HTTP GET request. If you supply two parameters, the second is assumed to be the
    body of an HTTP POST request. For a request of type IPFS, the only parameter that
    you should supply is the IPFS content hash.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询*—这是一个单独的参数或参数数组，其值取决于数据源类型。例如，对于URL类型的请求，如果您只提供一个参数（数据源的URL），则假设这是一个HTTP
    GET请求。如果您提供两个参数，第二个参数被认为是HTTP POST请求的正文。对于IPFS类型的请求，您应该提供的唯一参数是IPFS内容哈希。'
- en: Figure 9.16\. `oraclize_query()` parameters
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.16. `oraclize_query()`参数
- en: '![](Images/fig09-16_alt.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig09-16_alt.jpg)'
- en: As you can see in [figure 9.16](#ch09fig16), results are extracted from the
    query through a result parser, which depends on the nature of the data source
    being called. [Table 9.4](#ch09table04) summarizes the supported parsers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[图9.16](#ch09fig16)中所看到的，结果通过结果解析器从查询中提取，这取决于被调用数据源的性质。 [表9.4](#ch09table04)总结了支持的解析器。
- en: Table 9.4\. Oraclize query result parsers
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.4. Oraclize查询结果解析器
- en: '| Parser type | Parser identifier | Description |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 解析器类型 | 解析器标识符 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| JSON parser | json | Converts results to a JSON object, which you can extract
    specific properties from |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| JSON解析器 | json | 将结果转换为JSON对象，您可以从中提取特定的属性 |'
- en: '| XML parser | xml | Typically parses legacy web service results |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| XML解析器 | xml | 通常用于解析遗留的Web服务结果 |'
- en: '| HTML parser | html | Useful for HTML scraping |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| HTML解析器 | html | 适用于HTML抓取 |'
- en: '| Binary helper | binary | Can extract items from binary results with slice(offset,
    length) |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 二进制助手 | binary | 使用slice(offset, length)从二进制结果中提取项目 |'
- en: Results Callback Function
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果回调函数
- en: 'Now that you’ve learned how to perform a data request, we’ll look at how the
    Oraclize engine responds with the results. As you saw in [figure 9.15](#ch09fig15),
    when processing a request, the Oraclize engine grabs the results from the relevant
    data source, and then it creates a result transaction, which it sends back to
    the Ethereum network. This transaction is also known as an *Oraclize callback
    transaction*, because during its execution, it calls back the oracle contract
    performing the request on its `__callback` function:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学会了如何进行数据请求，我们将看看Oraclize引擎是如何响应结果的。正如你在[图9.15](#ch09fig15)中看到的，当处理请求时，Oraclize引擎从相关数据源抓取结果，然后它创建一个结果交易，将其发送回以太坊网络。这个交易也被称为*Oraclize回调交易*，因为在其执行过程中，它通过调用其`__callback`函数来回调进行请求的预言合约：
- en: '[PRE35]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you call the `__callback` function from the result transaction, the value
    of the ETHXBT state variable is updated. You can then use it in the rest of the
    code.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从结果交易中调用`__callback`函数时，ETHXBT状态变量的值会更新。然后你可以在代码的其余部分使用它。
- en: 9.5.3\. Running the data-aware contract
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3. 运行数据感知合约
- en: 'If you want to run the data-aware contract from [listing 9.3](#ch09ex03), you
    need the Oraclize Remix plugin, which directly references the oraclizeAPI.sol
    file, including using the Oraclize contract from GitHub: http://mng.bz/y1ry.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要运行来自[列表9.3](#ch09ex03)的数据意识合约，你需要Oraclize Remix插件，它直接引用了oraclizeAPI.sol文件，包括使用来自GitHub的Oraclize合约：http://mng.bz/y1ry。
- en: A dialog box will appear, warning that “Remix is going to load the extension
    “Oraclize” located at https://remix-plugin.oraclize.it. Are you sure to load this
    external extension?” Click OK.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一个对话框，警告“Remix即将加载位于https://remix-plugin.oraclize.it的“Oraclize”扩展。您确定要加载这个外部扩展吗？”点击确定。
- en: I encourage you to try out the KrakenPriceTicker.sol, which you can find already
    set up within the Gist menu on the left side of the screen (Gist > KrakenPriceTicker).
    Before running it
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试一下KrakenPriceTicker.sol，你可以在屏幕左侧的Gist菜单中找到它，已经设置好了（Gist > KrakenPriceTicker）。在运行它之前
- en: check and make sure the compiler version is set to 0.4.24+commit.e67f0147 in
    the Solidity Version panel (on the Settings tab)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查并确保在Solidity版本面板（在设置选项卡中）中的编译器版本设置为0.4.24+commit.e67f0147。
- en: check and make sure the Environment is set to JavaScript VM (on the Run tab)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查并确保环境设置为JavaScript VM（在运行选项卡上）。
- en: 'After having done so, do the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做之后，执行以下操作：
- en: Open the Run tab and click Deploy.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开运行标签并点击部署。
- en: Click the KrakenPriceTicker drop-down in the bottom Deployed Contracts panel.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击KrakenPriceTicker下拉菜单，位于底部的已部署合约面板中。
- en: Click Update. (If you want to emulate the behavior of a contract call, you could
    also set the Value field at the top of the screen, for example to 20 Finney, but
    within Remix, this isn’t necessary.) At this point, the value of ETHXBT gets updated.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击更新。（如果你想要模拟合约调用的行为，你也可以在屏幕顶部的值字段设置，例如设置为20 Finney，但在Remix中这并不必要。）此时，ETHXBT的值得到更新。
- en: Click the ETHXBT button to check the value of the exchange rate.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击ETHXBT按钮查看汇率值。
- en: 9.6\. Dapp frameworks and IDEs
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6. Dapp框架和IDE
- en: 'Four categories of tools can improve the Dapp development cycle:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过四种工具类别来改善Dapp开发周期：
- en: Development IDEs
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发IDE
- en: Development frameworks
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发框架
- en: Testing frameworks
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架
- en: Web UI frameworks
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web UI框架
- en: 9.6.1\. Development IDEs
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.1. 开发IDE
- en: Development IDEs and development frameworks are tools that help you speed up
    the development cycle. Although IDEs and development frameworks offer similar
    functionality, the former are slightly more focused on code editing and compilation,
    whereas the latter offer powerful deployment capabilities.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 开发IDE和开发框架是帮助您加快开发周期的工具。尽管IDE和开发框架提供类似的功能，但前者更专注于代码编辑和编译，而后者提供了强大的部署能力。
- en: For a few months, Ethereum Studio appeared to be the de facto IDE for developing
    Ethereum Dapps, because it provided good code editing capabilities coupled with
    Web3 integration and smooth contract deployment functionality. But then ether.camp,
    the company behind it, stopped supporting it. As a result, developers are advised
    to instead use generic code editing tools, such as Sublime, Atom, Visual Studio
    Code, Vi, and Emacs, configured with the related Solidity plugin.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个月的时间里，以太坊工作室似乎是开发以太坊Dapps的事实上的IDE，因为它提供了良好的代码编辑能力，集成了Web3，并具有平滑的合约部署功能。但是随后，以太坊背后的公司ether.camp停止了对它的支持。因此，建议开发者转而使用通用代码编辑工具，如Sublime、Atom、Visual
    Studio Code、Vi和Emacs，并配置了相关的Solidity插件。
- en: 9.6.2\. Development frameworks
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.2. 开发框架
- en: The objective of Ethereum development frameworks is to streamline the development
    cycle and allow developers to focus on writing code rather than spending most
    of their time compiling it, redeploying it, and retesting it manually.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊开发框架的目的是简化开发周期，让开发者能够专注于编写代码，而不是花费大部分时间编译、重新部署和手动重新测试它。
- en: 'Various third-party smart contract frameworks have appeared since the launch
    of the Ethereum platform:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 自以太坊平台推出以来，出现了各种第三方的智能合约框架：
- en: Truffle
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle
- en: Populus
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Populus
- en: Dapp (formerly known as Dapple)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapp（原名Dapple）
- en: Embark
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Embark
- en: Truffle
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Truffle
- en: Truffle is probably the most advanced Ethereum development framework, and it
    focuses mainly on simplifying the building, testing, packaging, and deployment
    of Solidity contracts. It’s distributed as a Node.js package and provides a REPL
    console.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle可能是最先进的以太坊开发框架，它主要专注于简化Solidity合约的构建、测试、打包和部署。它作为Node.js包分发并提供一个REPL控制台。
- en: Truffle’s key selling point is migration—the way this framework manages the
    scripting and configuration of contract deployment. This is the framework you’ll
    use in the next few chapters.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle的主要卖点是迁移——这个框架管理智能合约部署的脚本和配置的方式。这是您在接下来的几章中将会使用的框架。
- en: Populus
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Populus
- en: Populus is functionally similar to Truffle in that it’s designed to simplify
    the compile-test-deploy cycle by working on smart contract projects organized
    with a specific folder structure. It provides configuration management that allows
    you to progress smoothly throughout development from an in-memory blockchain such
    as Ganache, to a private internal network, and finally to a public one. The peculiarity
    of Populus with respect to other frameworks is that it allows a developer to script
    unit tests or deployment instructions in python.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Populus在功能上与Truffle相似，它旨在通过在特定文件结构下工作的智能合约项目来简化编译-测试-部署周期。它提供了配置管理，使您能够顺利地从Ganache之类的内存区块链，过渡到私有内部网络，最终过渡到公共网络。Populus与其他框架相比的独特之处在于，它允许开发者在Python中编写单元测试或部署说明。
- en: Embark
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Embark
- en: Embark aims to be a platform-agnostic Dapp framework to simplify the development
    and deployment of any decentralized application. This framework simplifies the
    management of multicontract Dapps, and you can configure it to automatically deploy
    a contract when a code change is detected. It allows decentralized storage through
    the IPFS protocol (and Swarm) and decentralized messaging through the Whisper
    protocol.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Embark旨在成为一个与平台无关的Dapp框架，以简化任何去中心化应用程序的开发和部署。这个框架简化了多合约Dapp的管理，并且您可以配置它在检测到代码更改时自动部署合约。它通过IPFS协议（和Swarm）支持去中心化存储，并通过Whisper协议支持去中心化消息传递。
- en: Dapp
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Dapp
- en: The Dapp framework is geared mainly toward the Linux world and is distributed
    through the Nix Package manager. The emphasis of this framework is on contract
    packaging under the Ethereum Smart Contract Packaging Specification ([https://github.com/ethereum/EIPs/issues/190](https://github.com/ethereum/EIPs/issues/190))
    and contract code storage decentralization through the IPFS protocol, which we
    examined in [section 9.4](#ch09lev1sec4). Dapp also provides a unit testing facility
    through ethrun and ds-test.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Dapp框架主要面向Linux世界，并通过Nix包管理器分发。这个框架的重点是按照以太坊智能合约打包规范（[https://github.com/ethereum/EIPs/issues/190](https://github.com/ethereum/EIPs/issues/190)）对合约打包以及通过IPFS协议进行合约代码存储的去中心化，我们在[第9.4节](#ch09lev1sec4)中介绍了IPFS协议。Dapp还通过ethrun和ds-test提供单元测试设施。
- en: Deciding which development framework to adopt might be difficult, as all of
    them offer similar compile-test-deploy functionality, although delivered in slightly
    different ways. It might sound obvious, but the best way to determine which one
    suits your needs best is to try out all of them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 决定采用哪个开发框架可能很困难，因为所有这些框架都提供类似的编译-测试-部署功能，尽管以略微不同的方式提供。听起来可能很显然，但确定哪个最适合您需求的最佳方式是尝试它们全部。
- en: Given the bias of the Ethereum platform toward JavaScript, it’s natural that
    several generic JavaScript frameworks have become a common feature of the Ethereum
    ecosystem. Let’s see why you should consider including JavaScript testing and
    UI frameworks in your development environment.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊平台倾向于JavaScript，因此几个通用的JavaScript框架自然成为了以太坊生态系统的常见特征。让我们看看为什么您应该考虑在您的开发环境中包括JavaScript测试和UI框架。
- en: 9.6.3\. Testing frameworks
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.3. 测试框架
- en: Using a generic JavaScript testing framework, as opposed to the unit testing
    functionality that a main development framework (such as Truffle or embark) offers,
    provides
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用的JavaScript测试框架（例如Truffle或Embark的单元测试功能），提供了
- en: more advanced unit testing capabilities, for example, support for async calls,
    exit status values for continuous integration systems, timeout handling, meta-generation
    of test cases, and more extensibility around the use of assert libraries
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的单元测试功能，例如，支持异步调用、连续集成系统的退出状态值、超时处理、测试用例的元生成以及更多关于断言库使用的扩展性。
- en: 'better system testing automation: you can automate tests involving end-to-end
    interaction through a private or public test network, and they can handle timeouts,
    retries, and other use cases around communication with the contract'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的系统测试自动化：您可以通过私有或公共测试网络自动化涉及端到端交互的测试，并且它们可以处理超时、重试以及与智能合约通信的其他用例。
- en: The two most popular JavaScript unit testing frameworks used for developing
    decentralized applications are Mocha and Jasmine, and you’ll be using Mocha in
    the next few chapters. Let’s now move on to the web UI frameworks.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 开发去中心化应用程序最流行的两个JavaScript单元测试框架是Mocha和Jasmine，您将在接下来的几章中使用Mocha。现在让我们转向Web
    UI框架。
- en: 9.6.4\. Web UI frameworks
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.4\. Web UI框架
- en: Although the UI is an important element of a Dapp, because it connects the end
    user with the backend smart contracts, the Ethereum platform doesn’t yet fully
    support any technology to develop the presentation layer of an Ethereum application.
    Because you can include and reference web3.js on the JavaScript of a plain html5
    web page, it’s natural to think that an easy way of exposing a Dapp is through
    web pages.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UI是Dapp的一个重要组成部分，因为它将最终用户与后端智能合约连接起来，但以太坊平台尚未完全支持任何技术来开发以太坊应用程序的展示层。因为您可以在纯html5网页的JavaScript中包含和引用web3.js，所以通过网页暴露Dapp似乎是一个简单的途径。
- en: Given the abundance of excellent JavaScript UI frameworks, it’s hard to recommend
    any one framework in particular. But it’s worth mentioning that frameworks such
    as Meteor, Angular, Vue, and, more recently, React are getting increasing traction
    in the Ethereum community. As far as we’re concerned, we’ll stick to minimalistic
    solutions based on plain HTML and JavaScript, but feel free to embellish the UI
    code with the framework of your choice.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 由于优秀的前端JavaScript框架众多，很难推荐任何一个特定的框架。但值得一提的是，像Meteor、Angular、Vue以及最近兴起的React等框架在以太坊社区中越来越受欢迎。就我们而言，我们将坚持使用基于纯HTML和JavaScript的简约解决方案，但随意使用您选择的框架来美化UI代码。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'The previous chapters introduced a restricted view of the Ethereum ecosystem,
    limited to the following:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几章介绍了对以太坊生态系统的一个受限视图，限于以下内容：
- en: '*Core infrastructural components*—The Go Ethereum (geth) client, the Ethereum
    wallet, MetaMask, and Ganache'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心基础设施组件**—Go Ethereum (geth)客户端、以太坊钱包、MetaMask和Ganache'
- en: '*Core development tools*—Solidity (the EVM smart contract language), Remix
    (the online Solidity IDE), solc (the solidity compiler), JSON-RPC (the low-level
    Ethereum client API), Web3.js (a high-level Ethereum client API written in JavaScript),
    Node.js (not Ethereum-specific JavaScript runtime)'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心开发工具**—Solidity（EVM智能合约语言）、Remix（在线Solidity IDE）、solc（Solidity编译器）、JSON-RPC（低级以太坊客户端API）、Web3.js（用JavaScript编写的的高级以太坊客户端API）、Node.js（非以太坊特定的JavaScript运行时）'
- en: The Ethereum ecosystem includes a wider set of infrastructural components, such
    as ENS (for decentralized name resolution to addresses), Swarm and IPFS (for decentralized
    content storage), Whisper (for decentralized messaging), oracles (for importing
    data from public web-based data providers), and Infura (for managed Ethereum nodes).
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊生态系统包括一组更广泛的基础设施组件，如ENS（用于去中心化名称解析到地址）、Swarm和IPFS（用于去中心化内容存储）、Whisper（用于去中心化消息传递）、预言机（用于从公共基于web的数据提供商导入数据）以及Infura（用于托管以太坊节点）。
- en: The Ethereum Name Service, also known as ENS, offers a decentralized and secure
    way to reference resource addresses, such as account and contract addresses, through
    human-readable domain names. It has objectives similar to the internet DNS.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊名称服务（ENS），也称为ENS，提供了一种去中心化和安全的方式来通过人类可读的域名引用资源地址，如账户和合约地址。它的目标与互联网DNS类似。
- en: Storing relatively big content on the blockchain isn’t recommended because it’s
    clumsy and expensive. A better solution is to use decentralized storage systems,
    such as Swarm and IPFS.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相对较大的内容存储在区块链上是不推荐的，因为这既笨拙又昂贵。一个更好的解决方案是使用去中心化存储系统，如Swarm和IPFS。
- en: Swarm is based on the Ethereum technology stack and is Ethereum network-aware,
    and it’s often the preferred solution for storing content off-chain that can be
    referenced on the Ethereum blockchain through cryptographic hash-based identifiers.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swarm基于以太坊技术栈，并且对以太坊网络有感知，通常它是存储可以基于加密哈希标识符在以太坊区块链上引用的离链内容的偏好解决方案。
- en: IPFS is a technology-agnostic protocol for content storage and offers a more
    widely known and tested solution, at the expense of inferior performance and looser
    Ethereum integration.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPFS是一种内容存储的技术中立协议，提供了一个更广为人知且经过测试的解决方案，代价是性能较差和与以太坊的集成不够紧密。
- en: Oracles, such as Oraclize, allow smart contracts to import data from outside
    the Ethereum network and accompany it with a proof of authenticity.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预言机，如Oraclize，允许智能合约从以太坊网络之外的来源导入数据，并伴随有真实性的证明。
- en: The Ethereum ecosystem also includes a wider set of development tools, such
    as Truffle, the main smart contract framework; generic JavaScript testing frameworks,
    such as Mocha and Jasmine; and JavaScript web UI frameworks, such as Angular,
    ReactJS, and Meteor.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊生态系统还包括一套更广泛的开发工具，如Truffle，主要的智能合约框架；通用的JavaScript测试框架，如Mocha和Jasmine；以及JavaScript网页用户界面框架，如Angular、ReactJS和Meteor。
- en: Chapter 10\. Unit testing contracts with Mocha
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 使用Mocha对智能合约进行单元测试
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容概述**'
- en: Installing and setting up Mocha, a JavaScript unit testing framework
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并设置Mocha，一个JavaScript单元测试框架
- en: Unit testing `SimpleCoin` with Mocha
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mocha对`SimpleCoin`进行单元测试
- en: Writing tests performing negative checks, verifying expected exceptions are
    thrown
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写执行负检查的测试，验证预期异常是否被抛出
- en: Writing tests performing positive checks, verifying logic is executed successfully
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写执行正检查的测试，验证逻辑成功执行
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In previous chapters, you learned how to develop an Ethereum Dapp by using simple
    tools that the platform offers. You were able, with some effort, to build an end-to-end
    Dapp, including a simple web UI and a smart contract layer (including libraries)
    and to deploy it to the public test network. You wrote Solidity and Web3.js code
    through Remix or even through plain text editors and launched simple deployment
    scripts manually, initially on the geth console and later on Node.js.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了如何使用平台提供的简单工具来开发一个以太坊Dapp。你能够通过一些努力，构建一个端到端的Dapp，包括一个简单的网页用户界面和一个智能合约层（包括库），并将其部署到公共测试网络。你通过Remix甚至纯文本编辑器编写了Solidity和Web3.js代码，并最初在geth控制台，后来在Node.js上手动启动了简单的部署脚本。
- en: Although this way of developing a Dapp is acceptable while learning, it isn’t
    efficient when you start to dedicate more time to developing decentralized applications,
    especially if you do it professionally. As you learned in the chapter dedicated
    to the Ethereum ecosystem, various third-party development tools are available
    to improve code editing to help you unit test your contracts and speed up the
    development cycle.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种开发Dapp的方式在学习时是可以接受的，但当你开始花更多时间开发去中心化应用，尤其是如果你是专业做这行的话，这种方式并不高效。正如你在专门介绍以太坊生态系统的章节中学到的，有各种第三方开发工具可供选择，以提高代码编辑能力，帮助你单元测试你的合约并加快开发周期。
- en: In this chapter, I’ll present Mocha, a JavaScript unit testing framework that
    will allow you to easily automate unit tests for your contracts. In the next chapter,
    you’ll learn how to set up Truffle, through which you’ll automate build and deployment
    of your Dapps. Finally, you’ll also incorporate Mocha tests within Truffle, making
    it your fully integrated development environment.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍Mocha，一个JavaScript单元测试框架，它将允许你轻松自动化你的合约的单元测试。在下一章中，你将学习如何设置Truffle，通过它你将自动化你的Dapp的构建和部署。最后，你还将把Mocha测试集成到Truffle中，使它成为你的完全集成的开发环境。
- en: You’ll learn Mocha by writing a unit test suite for `SimpleCoin`. Before you
    start, I’ll show you briefly how to install the framework and set up the working
    directory.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过编写一个针对`SimpleCoin`的单元测试套件来学习Mocha。在开始之前，我会简要地告诉你如何安装这个框架并设置工作目录。
- en: 10.1\. Installing Mocha
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 安装Mocha
- en: 'Mocha is executed through Node.js, so you have to install it using `npm`. Because
    you’ll be writing tests for various smart contracts, it’s best to install it globally.
    (You might have to Run it as an Administrator, depending on your security configuration.)
    Here’s how to install it:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是通过Node.js执行的，所以你必须使用`npm`来安装它。因为你要为各种智能合约编写测试，全局安装是最好的。（根据你的安全配置，你可能需要以管理员身份运行它。）以下是安装步骤：
- en: '[PRE36]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s it! The next step is to prepare a working directory for your `SimpleCoin`
    tests.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了！下一步是为你自己的`SimpleCoin`测试准备一个工作目录。
- en: 10.2\. Setting up SimpleCoin in Mocha
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 在Mocha中设置SimpleCoin
- en: You should place tests against an Ethereum smart contract in a working directory
    configured for Node.js and set up with Ethereum packages such as Web3 and Ganache.
    Create a working directory for the `SimpleCoin` unit tests you’re going to write.
    I’ve created mine as C:\Ethereum\mocha\SimpleCoin.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将针对以太坊智能合约的测试放置在一个为Node.js配置好的工作目录中，并设置有以太坊包如Web3和Ganache。为你要写的`SimpleCoin`单元测试创建一个工作目录。我创建的我的目录是C:\Ethereum\mocha\SimpleCoin。
- en: Now create a package.json configuration file for Node.js in this folder and
    set the test script to Mocha, as shown in the following listing.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这个文件夹中为Node.js创建一个package.json配置文件，并将测试脚本设置为Mocha，如下面的列表所示。
- en: Listing 10.1\. package.json
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1. package.json
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also create it interactively by opening an OS shell, moving to the working
    directory you’ve created, and running
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过打开一个操作系统终端，移动到你创建的工作目录，并运行以下命令来交互式地创建它：
- en: '[PRE38]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once you have the directory and configuration file created, you can quickly
    try out how Mocha executes tests. Create a dummyTests.js file containing the example
    test shown in the following listing.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了目录和配置文件，你可以快速尝试Mocha如何执行测试。创建一个dummyTests.js文件，包含下面列表中的示例测试。
- en: Listing 10.2\. dummyTests.js
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. dummyTests.js
- en: '[PRE39]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** **Imports the default assert library**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导入默认的断言库**'
- en: '***2*** **Names the test suite**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **命名测试套件**'
- en: '***3*** **Names the functionality being tested**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **命名被测试的功能**'
- en: '***4*** **Describes the specific test**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **描述具体的测试**'
- en: '***5*** **Actual test**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **实际测试**'
- en: 'You can run this test file as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式运行这个测试文件：
- en: '[PRE40]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And you’ll get this output:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会得到这个输出：
- en: '[PRE41]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you may have noticed, the assert library referenced at the top of the test
    script is the default assert library that the framework provides. If you want,
    you can install and then reference any of the following assert frameworks:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，测试脚本顶部引用的断言库是框架提供的默认断言库。如果你愿意，你可以安装并引用以下断言框架中的任何一个：
- en: Should.js ([https://shouldjs.github.io/](https://shouldjs.github.io/))
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该.js ([https://shouldjs.github.io/](https://shouldjs.github.io/))
- en: Expect.js ([https://github.com/Automattic/expect.js/](https://github.com/Automattic/expect.js/))
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望.js ([https://github.com/Automattic/expect.js/](https://github.com/Automattic/expect.js/))
- en: Chai.js ([www.chaijs.com/](http://www.chaijs.com/))
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai.js ([www.chaijs.com/](http://www.chaijs.com/))
- en: Better-assert ([https://github.com/tj/better-assert](https://github.com/tj/better-assert))
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的断言([https://github.com/tj/better-assert](https://github.com/tj/better-assert))
- en: Unexpected ([https://github.com/unexpectedjs/unexpected](https://github.com/unexpectedjs/unexpected))
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的([https://github.com/unexpectedjs/unexpected](https://github.com/unexpectedjs/unexpected))
- en: 'The testing working directory is almost ready. Before you can use it for testing
    smart contracts, you must install the following node packages: solc, Web3, and
    Ganache. If you haven’t installed them globally already, you can do so as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作目录几乎准备好了。在你可以用它来测试智能合约之前，你必须安装以下节点包：solc、Web3和Ganache。如果你还没有全局安装它们，你可以按照以下方式进行安装：
- en: '[PRE42]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can install these packages only in the testing folder as
    follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以像以下方式只在测试目录中安装这些包：
- en: '[PRE43]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 10.3\. Writing unit tests for SimpleCoin
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 为SimpleCoin编写单元测试
- en: 'You’re all set up to write some tests against `SimpleCoin`. Now I can show
    you how to unit test a solidity contract in Mocha. This isn’t meant to be a tutorial
    on unit testing, though, and I’ll assume you have basic knowledge of or experience
    in unit testing. If you don’t know anything about unit testing but wish to learn
    more on the topic, I can recommend two excellent books that will give you a solid
    foundation: *Effective Unit Testing* by Lasse Koskela and *The Art of Unit Testing*
    by Michael Feathers and Robert C. Martin, both published by Manning.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好用`SimpleCoin`编写一些测试了。现在，我将向你展示如何在Mocha中单元测试一个solidity合约。这并不是一个关于单元测试的教程，尽管如此，但我将假设你已经具备单元测试的基本知识或经验。如果你对单元测试一无所知，但希望了解更多关于这个主题的信息，我可以推荐两本非常好的书籍，它们将为你打下坚实的基础：由Lasse
    Koskela编写的《Effective Unit Testing》和由Michael Feathers和Robert C. Martin合著的《The Art
    of Unit Testing》，这两本书都由Manning出版。
- en: 'You’ll be creating tests against the functionality offered by the extended
    version of `SimpleCoin` you implemented back in [chapter 5](kindle_split_017.xhtml#ch05).
    I’ve repeated it in the next listing for your convenience, and you can place it
    in the following file: c:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你将针对`SimpleCoin`扩展版本提供的功能创建测试，这个版本是在第[5章](kindle_split_017.xhtml#ch05)中实现的。我重复了下一个列表中的内容，以便你的方便，你可以将其放在以下文件中：c:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol。
- en: Listing 10.3\. SimpleCoin.sol, latest code from [chapter 5](kindle_split_017.xhtml#ch05)
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. SimpleCoin.sol，来自第[5章](kindle_split_017.xhtml#ch05)的最新代码
- en: '[PRE44]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 10.3.1\. The testing plan
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 测试计划
- en: Unit testing a Solidity contract means verifying that all the public methods
    the contract exposes, including the contract constructor, behave as expected,
    with both valid and invalid input. First, I’ll help you verify that the constructor
    initializes the contract as expected. You’ll do so by correctly setting the contract
    owner value and the initial state according to the account used to execute the
    deployment transaction and the values fed to the constructor parameters.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对Solidity合约进行单元测试意味着验证合约公开的所有方法，包括合约构造函数，是否如预期那样运行，既包括有效的输入也包括无效的输入。首先，我会帮助你验证构造函数是否按照预期初始化了合约。你会通过正确设置合约所有者的值和根据执行部署交易所用的账户以及传递给构造函数参数的值来设置初始状态来实现。
- en: 'Then I’ll show you a set of tests for the typical negative and positive checks
    you want to perform against any contract function. By *positive* checks, I mean
    those verifying successful logic execution: a contract function invoked by an
    authorized user and fed with valid input within the constraints defined by all
    modifiers decorating the function and acceptable to the function logic executes
    successfully.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我会展示给你一系列针对任何合约函数所需的典型正面和负面检查的测试。所谓*正面*检查是指验证成功逻辑执行的检查：一个被授权用户调用，并传递所有修饰符定义的约束内有效输入的合约函数，且输入被函数逻辑接受，能够成功执行。
- en: 'By *negative* checks I mean those verifying expected exceptions are thrown
    for an unauthorized caller or invalid input:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的*负面*检查是指那些验证未授权调用者或无效输入时预期抛出异常的检查：
- en: A contract function that is restricted to certain callers through a modifier
    throws an expected exception if the caller isn’t authorized to invoke it.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通过修饰符限制为特定调用者的合约函数，如果调用者没有权限调用它，将抛出预期异常。
- en: A contract function that receives input that doesn’t meet other constraints
    defined by additional modifiers or `require` conditions throws an expected exception.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合约函数如果接收到不符合额外修饰符或`require`条件定义的其他约束的输入，将抛出预期异常。
- en: Once you’re familiar with these types of tests, you’ll be able to write tests
    against any contract function. You can start by testing `SimpleCoin`’s constructor.
    While we look into that, I’ll also give you a general idea of how to initialize
    and structure your tests.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了这类测试，你就能针对任何合约函数编写测试了。你可以从测试`SimpleCoin`的构造函数开始。在研究这个的过程中，我也会给你一个关于如何初始化和结构化你的测试的一般性建议。
- en: 10.3.2\. Unit testing the constructor
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2 单元测试构造函数
- en: 'As you know, testing a piece of code means executing the code under test and
    then verifying assumptions about what should have happened. You execute the code
    of the contract constructor only during its deployment, so your test must deploy
    `SimpleCoin` and then verify that the construction was executed correctly, specifically
    by checking the following:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，测试代码意味着执行被测试的代码，然后验证关于应该发生的事情的假设。你只在合约部署时执行合约构造函数的代码，所以你的测试必须部署`SimpleCoin`，然后验证构造是否正确执行，具体是通过检查以下内容：
- en: The contract owner is the same account as the sender of the deployment transaction.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约所有者与部署交易的发件人同一账户。
- en: The token balance of the contract owner is the same as the initial supply amount
    being fed to the constructor.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约所有者的代币余额与传递给构造函数的初始供应量相同。
- en: Unit tests must generally run as quickly as possible, because you’re likely
    to execute them many times through your development cycle. In the case of enterprise
    applications, the main source of latency comes from accessing environmental resources,
    such as the file system, databases, and network. The most common way of reducing
    or eliminating such latency is to emulate access to these resources with isolation
    (or mocking) frameworks, such as jMock and EasyMock for Java applications and
    Moq, NMock, and Rhino Mocks for .net applications.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常应尽可能快速运行，因为你很可能在开发周期内多次执行它们。在企业应用中，延迟的主要来源是访问环境资源，如文件系统、数据库和网络。最常见减少或消除此类延迟的方式是使用隔离（或模拟）框架来模拟对这些资源的访问，如Java应用的jMock和EasyMock，以及.net应用的Moq、NMock和Rhino
    Mocks。
- en: When it comes to Ethereum Dapps, the main source of latency is transaction processing
    (including mining and block creation) and block propagation throughout the Ethereum
    network. As a result, it’s natural to run contract unit tests against a mock network
    such as Ganache, which emulates the infrastructural aspects of the Ethereum platform
    without connecting to it.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Ethereum Dapp时，延迟的主要来源是交易处理（包括挖掘和区块创建）以及区块在整个Ethereum网络中的传播。因此，自然地，我们会在类似Ganache这样的mock网络上对合约进行单元测试，这种网络模拟了Ethereum平台的某些基础设施方面，而没有连接到它。
- en: This means your first test, against `SimpleCoin`’s constructor, must deploy
    `SimpleCoin` on Ganache before performing the functional checks I’ve described
    (of contract ownership and the account balance of the owner). In fact, to ensure
    no interferences occur between tests, each test will redeploy `SimpleCoin` from
    scratch.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的第一个测试，针对`SimpleCoin`的构造函数，必须在Ganache上部署`SimpleCoin`，然后执行我描述过的功能检查（关于合约所有者和所有者账户余额）。实际上，为了确保测试之间没有干扰，每个测试都将从零开始重新部署`SimpleCoin`。
- en: 'Deploying `SimpleCoin` onto Ganache... Hold on—you already did this in [chapter
    8](kindle_split_020.xhtml#ch08)! You can adapt [listing 8.5](kindle_split_020.xhtml#ch08ex05)
    for unit testing. You can keep the script almost unchanged up to the instantiation
    of `SimpleCoinContractFactory`. The only modification is the path of `SimpleCoin.sol`,
    which is now c:\Ethereum\mocha\SimpleCoin. Here’s the script:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 将`SimpleCoin`部署到Ganache上... 等等—你已经在第8章做过这个了！[第8章](kindle_split_020.xhtml#ch08)你可以将[列表8.5](kindle_split_020.xhtml#ch08ex05)用于单元测试。你可以将脚本几乎保持原样，直到`SimpleCoinContractFactory`的实例化。唯一的修改是`SimpleCoin.sol`的路径，现在是c:\Ethereum\mocha\SimpleCoin。以下是脚本：
- en: '[PRE45]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** **The location of simplecoin.sol is now in c:/Ethereum/ mocha/SimpleCoin.**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **simplecoin.sol的位置现在在c:/Ethereum/mocha/SimpleCoin。**'
- en: Now that you’ve taken care of the infrastructural (nonfunctional) part of your
    first test, you can focus on the functional one. Bear in mind, though, that these
    initial lines of the script haven’t deployed `SimpleCoin` yet; they’ve merely
    instantiated the contract factory.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经处理了第一个测试的基础设施（非功能性）部分，可以专注于其功能性部分了。不过，请记住，脚本最初的这几行还没有部署`SimpleCoin`；它们只是实例化了合约工厂。
- en: 'Following the pattern in the mock test from [listing 10.2](#ch10ex02), you
    can start to document the purpose of your first test through Mocha’s `describe()`
    and `it()` statements:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循[列表10.2](#ch10ex02)中mock测试的模式，你可以通过Mocha的`describe()`和`it()`语句开始记录你第一个测试的目的：
- en: '[PRE46]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** **Describes the entire testing suite you’re creating**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **描述你正在创建的整个测试套件**'
- en: '***2*** **Describes your first testing section, focused on SimpleCoin’s constructor**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **描述你的第一个测试部分，关注SimpleCoin的构造函数**'
- en: '***3*** **Describes your first test**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **描述你的第一个测试**'
- en: 'It’s time to write the core of your first test, which will, as I stated earlier,
    check that the contract owner is the same account as the sender of the deployment
    transaction. You can structure the test with an *AAA layout*, which includes the
    following three parts, as also illustrated in [figure 10.1](#ch10fig01):'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写你第一个测试的核心部分了，它将如我之前所述，检查合约所有者是否与部署交易的发送者是同一个账户。你可以用*AAA布局*来结构化测试，包括以下三个部分，也如[图10.1](#ch10fig01)所示：
- en: '*Arrange*—Sets up the input passed to the function under test and instantiates
    objects required for the testing'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Arrange*—为被测试函数设置输入并实例化测试所需的对象'
- en: '*Act*—Calls the function under test'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Act*—调用被测试函数'
- en: '*Assert*—Verifies the test assumptions'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Assert*—验证测试假设'
- en: '[PRE47]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1*** **Inputs to this test are the sender of the deployment transaction
    and the initial supply amount.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **此测试的输入是部署交易的发送者和初始供应量。**'
- en: '***2*** **Triggers the function under test, SimpleCoin’s constructor, through
    contract deployment**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **通过合约部署触发被测试函数，即SimpleCoin的构造函数**'
- en: '***3*** **Following successful deployment, verifies the contract owner is the
    sender of the transaction**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在成功部署后，验证合约所有者是交易发送者**'
- en: '***4*** **Signals to Mocha the completion of the test**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **向Mocha示意测试完成**'
- en: 'Figure 10.1\. The typical AAA structure of a unit test: Arrange (set up test
    input and the object under test); Act (call the function under test); and Assert
    (verify the test expected outcome)'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1 AAA测试单元典型结构：Arrange（设置测试输入和被测试对象）；Act（调用被测试函数）；Assert（验证测试预期结果）
- en: '![](Images/fig10-01.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig10-01.jpg)'
- en: 'You’re now ready to run your first unit test, which is shown in its entirety
    in the following listing. You can place this script in the following file: c:\Ethereum\mocha\SimpleCoin\SimpleCoinTests.js.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在准备好运行你的第一个单元测试，完整的测试代码如下所示。你可以将此脚本放在以下文件中：c:\Ethereum\mocha\SimpleCoin\SimpleCoinTests.js。
- en: Listing 10.4\. SimpleCoinTests.js
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4。SimpleCoinTests.js
- en: '[PRE48]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Before running the script, open a new console and start Ganache:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本之前，打开一个新的控制台并启动Ganache：
- en: '[PRE49]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now go back to the console from which you executed the dummy test earlier and
    run your new test script:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到你之前执行伪测试的控制台，并运行你的新测试脚本：
- en: '[PRE50]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You’ll see output like what’s shown in [figure 10.2](#ch10fig02).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似于[图10.2](#ch10fig02)的输出。
- en: Figure 10.2\. Output of your first Mocha test, showing the name of the test
    suite, the name of the test section, and a description of your individual test.
    The test is passing!
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2。你的第一个Mocha测试的输出，显示测试套件的名称、测试部分的名称以及你个别测试的描述。测试通过！
- en: '![](Images/fig10-02_alt.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig10-02_alt.jpg)'
- en: The test is passing, which means the contract owner is indeed the sender of
    the deployment transaction. Good news! You can move on to the next test.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过，这意味着合同所有者确实是部署交易的发送者。好消息！你可以继续下一个测试。
- en: 'Before leaving the constructor, you should test whether the balance of the
    contract owner is equal to the initial supply fed with the `initialSupply` parameter.
    Add the following `it()` block within the `describe()` section associated with
    the `SimpleCoin` constructor:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开构造函数之前，你应该测试合同所有者的余额是否等于通过`initialSupply`参数提供的初始供应量。在`SimpleCoin`构造函数的`describe()`部分添加以下`it()`块：
- en: '[PRE51]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1*** This is the only line differing from the previous test. It verifies
    whether the balance of the contract owner equals the initial supply.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 这是与之前测试不同的唯一一行。它验证合同所有者的余额是否等于初始供应量。'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why I didn’t add the same assert line to the previous
    test. In general, it’s good practice to keep each unit test focused on one specific
    thing. Given that this test has nothing to do with verifying contract ownership,
    I decided to create a completely separate test. As I mentioned earlier, you also
    should completely isolate every test from other tests to avoid cross-dependencies
    and side effects that might invalidate unrelated tests. That’s why you should
    redeploy `SimpleCoin` at each test—by doing so, you can be confident that the
    test is truly isolated.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我没有在之前的测试中添加同样的断言行。通常，保持每个单元测试专注于一个特定事物是个好习惯。鉴于这个测试与验证合同所有权无关，我决定创建一个完全独立的测试。正如我之前提到的，你也应该将每个测试完全隔离，以避免可能使无关测试无效的交叉依赖和副作用。这就是为什么你应该在每次测试都重新部署`SimpleCoin`的原因——这样做，你可以确信测试是真正隔离的。
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now rerun the test script:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行测试脚本：
- en: '[PRE52]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can see from the output in [figure 10.3](#ch10fig03) that both tests have
    passed. Also, if you look at the Ganache console, you can verify that while running
    this test session, `SimpleCoin` was indeed deployed twice—once for each test,
    as shown in [figure 10.4](#ch10fig04).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图10.3](#ch10fig03)的输出中可以看出，两个测试都通过了。此外，如果你查看Ganache控制台，你可以验证在运行这个测试会话时，`SimpleCoin`确实部署了两次——一次用于每个测试，如图[10.4](#ch10fig04)所示。
- en: Figure 10.3\. Amended test suite, including two constructor tests. Both have
    passed.
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3。包括两个构造函数测试的修订测试套件。两个都通过了。
- en: '![](Images/fig10-03_alt.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig10-03_alt.jpg)'
- en: Figure 10.4\. Ganache output during test execution. `SimpleCoin` is redeployed
    at each test execution.
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4。测试执行期间的Ganache输出。每次测试执行都会重新部署`SimpleCoin`。
- en: '![](Images/fig10-04_alt.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig10-04_alt.jpg)'
- en: 10.3.3\. Testing whether only authorized callers can invoke a function
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3。测试是否只有授权的调用者可以调用一个函数
- en: 'We’ll now move to the set of tests you typically want to write against each
    contract function. If you look at [listing 10.3](#ch10ex03), you’ll notice both
    `mint()` and `freezeAccount()` restrict their execution to the contract owner
    through the `onlyOwner` modifier:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转到通常针对每个合同函数编写的一组测试。如果你查看[列表10.3](#ch10ex03)，你会注意到`mint()`和`freezeAccount()`通过`onlyOwner`修改器限制它们的执行仅限于合同所有者：
- en: '[PRE53]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A test you should write for each of these functions is to verify that an exception
    is thrown if you try to call them from an account that isn’t the contract owner.
    Here’s how you write such a test for `mint()`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些函数，你应该编写的一个测试是验证如果尝试从不是合同所有者的账户调用它们，是否会抛出异常。以下是针对`mint()`编写此类测试的方法：
- en: '[PRE54]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1*** **Sender of the contract transaction (the contract owner)**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **合约交易的发送者（合约所有者）**'
- en: '***2*** **The account calling mint() isn’t the contract owner.**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **调用mint()的账户不是合约所有者。**'
- en: '***3*** **Verifies an exception is thrown when mint() is called, because the
    caller of mint() isn’t the contract owner**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **验证当调用mint()时抛出了异常，因为mint()的调用者不是合约所有者**'
- en: 'As you can see, you verify that an exception is thrown when calling a function
    by wrapping it with the following assert statement:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你通过以下断言语句来验证调用函数时是否抛出异常：
- en: '[PRE55]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You’ll use this technique several times in upcoming sections.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的几节中多次使用这个技术。
- en: 10.3.4\. Testing if input constraints are met
  id: totrans-535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4。测试输入约束是否满足
- en: Even when the caller is authorized to invoke a function, they must feed it valid
    input. You should verify that if they don’t do so, an exception is thrown for
    any breach to function modifiers or require conditions.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调用者被授权调用函数，他们也必须为其提供有效输入。你应该验证，如果他们不这样做，任何违反函数修饰符或require条件的异常都会被抛出。
- en: 'Recall that the `transfer()` function performs input validation through various
    `require` statements before executing the token transfer:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`transfer()`函数在执行代币转移之前通过各种`require`语句进行输入验证：
- en: '[PRE56]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Ideally, you should write a test for each of the `require` statements. I’ll
    show you how to write a test against the second `require` statement:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该为每个`require`语句编写一个测试。我会向你展示如何针对第二个`require`语句编写测试：
- en: '[PRE57]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This constraint prevents the sender from sending more tokens than they own.
    If they try to do so, an exception is thrown. You can verify this is happening
    by using the same `assert.throws` statement you saw earlier:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束防止发送者发送比他们自己拥有的更多的代币。如果他们试图这样做，会抛出异常。你可以通过使用前面看到的相同的`assert.throws`语句来验证这种情况是否发生：
- en: '[PRE58]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1*** **Sets an amount to be transferred that’s higher than the current balance**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置的转让金额高于当前余额**'
- en: '***2*** **Verifies that an exception is thrown**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **验证抛出了异常**'
- en: '***3*** **Expected exception**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **预期的异常**'
- en: The `transfer()` function has two other `require` statements. I encourage you
    to write similar tests for them.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`transfer()`函数还有两个其他的`require`语句。我鼓励你为它们编写类似的测试。'
- en: 10.3.5\. Testing invocation from an authorized account with valid input
  id: totrans-547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.5。从授权账户进行有效输入的调用测试
- en: 'After you write tests performing negative checks so you’re confident that no
    unauthorized accounts or accounts with invalid input can call the function, it’s
    time to write a positive test proving the logic performs successfully when an
    authorized account invokes the function and feeds it with valid input. As an example,
    you could write a new test against the `transfer()` function dealing with a successful
    token transfer. In this case, you must verify that the sender account balance
    has decreased by the transferred amount, whereas the receiving account has increased
    by the same amount:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写进行负检查的测试，这样你就可以确信没有未经授权的账户或账户输入无效时调用函数，是时候编写一个正面的测试，证明当授权账户调用函数并为其提供有效输入时逻辑成功执行了。例如，你可以针对`transfer()`函数编写一个新测试，处理成功的代币转账。在这种情况下，你必须验证发送者账户的余额已经减少了转账金额，而接收者账户的余额已经增加了相同的金额：
- en: '[PRE59]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1*** **Sets amount to be transferred**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置要转让的金额**'
- en: '***2*** **Expected sender and recipient balances after the transfer**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **预期转账后的发送者和接收者余额**'
- en: '***3*** **Actual sender and recipient balances after the transfer**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **转账后的实际发送者和接收者余额**'
- en: '***4*** **Verifies actual sender and recipient balances equal the expected
    ones**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **验证实际发送者和接收者的余额等于预期的余额**'
- en: 'Add the two tests you’ve written against `transfer()` to the test script you
    started to write earlier against the constructor and rerun it:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 将你针对`transfer()`编写的两个测试添加到你之前开始编写的针对构造函数的测试脚本中，然后重新运行它：
- en: '[PRE60]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see in [figure 10.5](#ch10fig05), the test output now shows two
    sections: one for the constructor tests and the other for the `transfer()` tests.
    All tests are passing.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图10.5](#ch10fig05)中看到的，测试输出现在显示了两个部分：一个是为构造函数测试的，另一个是为`transfer()`测试的。所有测试都通过了。
- en: 'Figure 10.5\. Output of the amended test suite also including tests on the
    `transfer()` function. You can now see two sections: one for the constructor tests
    and the other for the `transfer()` tests. All tests are passing.'
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5。修改后的测试套件的输出，包括对`transfer()`函数的测试。现在你可以看到两个部分：一个是为构造函数测试的，另一个是为`transfer()`测试的。所有测试都通过了。
- en: '![](Images/fig10-05_alt.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig10-05_alt.jpg)'
- en: 'As an additional test to perform a positive check, you could write a test against
    the `authorize()` function, which has no modifiers and no input validation:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行阳性检查，您还可以编写一个针对没有修饰符和输入验证的`authorize()`函数的测试：
- en: '[PRE61]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The most obvious test to write is therefore one that verifies that the allowance
    set is the expected one:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最明显的测试是一个验证设置的额度是否符合预期的测试：
- en: '[PRE62]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** **Sets the allowance amount**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置额度数量**'
- en: '***2*** **Authorizes the account to use the specified allowance**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **授权账户使用指定的额度**'
- en: '***3*** **Verifies the allowance allocated to the authorized account is the
    expected one**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **验证授权账户分配的额度是预期的额度**'
- en: 10.3.6\. A little challenge
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.6. 一个有点挑战的小任务
- en: 'Now that we’ve covered all the typical tests, I invite you to refresh your
    memory on the `transferFrom()` function. That function allows an account to transfer
    an amount from another account within an allowance previously authorized by the
    account owner:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有典型的测试，接下来请回顾一下`transferFrom()`函数。该函数允许一个账户在其他账户授权的额度内转移一定数量的代币：
- en: '[PRE63]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Looking at its code, you might want to test at least these four scenarios:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其代码，你可能至少想要测试这四个场景：
- en: The authorized account can’t transfer a number of tokens higher than that owned
    by the authorizer.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权账户不能转移超过授权人的代币数量。
- en: An account can’t transfer tokens from an account that hasn’t authorized any
    allowance to any account.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个账户不能从没有对任何账户授权任何额度的账户转移代币。
- en: An account can’t transfer tokens from an account that hasn’t authorized it any
    allowance.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个账户不能从没有对其授权任何额度的账户转移代币。
- en: An authorized account can transfer an amount within the allowance, the final
    balance of the authorizer has decreased by the amount transferred by the authorized
    account, and the balance of the recipient has increased by the same amount.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个授权账户可以在额度内转移一定数量的代币，授权人的最终余额减少了授权账户转移的代币数量，接受者的余额增加了同样的数量。
- en: You might have noticed these tests are similar to ones you’ve already written,
    so I won’t repeat myself here. But I encourage you to give these tests a shot
    and then compare your tests with mine, which you can find in [listing C.1](kindle_split_032.xhtml#app0C1)
    in [appendix C](kindle_split_032.xhtml#app03).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到这些测试与您已经编写的测试相似，所以我这里不会重复。但我鼓励您尝试这些测试，然后将您的测试与我提供的测试进行比较，您可以在[附录C](kindle_split_032.xhtml#app03)的[列表C.1](kindle_split_032.xhtml#app0C1)中找到我的测试。
- en: 10.3.7\. The full testing suite
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.7. 完整的测试套件
- en: 'You can see all tests, including the ones I’ve skipped, in [listing C.1](kindle_split_032.xhtml#app0C1)
    of [appendix C](kindle_split_032.xhtml#app03). You can also find them in the SimpleCoinTest.js
    file of the provided code. After adding all these tests to SimpleCoinTests.js,
    you can run the whole suite, as follows:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[附录C](kindle_split_032.xhtml#app03)的[列表C.1](kindle_split_032.xhtml#app0C1)中看到所有测试，包括我跳过的那些。您还可以在提供的代码的SimpleCoinTest.js文件中找到它们。在将这些测试添加到SimpleCoinTests.js之后，您可以像下面这样运行整个套件：
- en: '[PRE64]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The output in [figure 10.6](#ch10fig06) shows the tests nicely grouped in sections
    ... and all passing.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在[图10.6](#ch10fig06)中，测试被很好地分组在各个部分中...并且全部通过。
- en: Figure 10.6\. Running the whole test suite. The output shows tests are grouped
    in sections ... and they’re all passing.
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6. 运行整个测试套件。输出显示测试被分组在各个部分中...并且它们都通过了。
- en: '![](Images/fig10-06_alt.jpg)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '| --- | --- | --- |'
- en: This section has given you an idea of the typical tests you might want to write
    against a contract you’re developing. You can find a summary in [table 10.1](#ch10table01).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您提供了一个关于可能想要针对您正在开发的合约编写的典型测试的思路。您可以在[表10.1](#ch10table01)中找到总结。
- en: Table 10.1\. Purpose of the tests presented in this section
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1. 本节介绍的测试目的
- en: '| Function | Test | Purpose |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 测试 | 目的 |'
- en: '| --- | --- | --- |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '![](Images/fig10-06_alt.jpg)'
- en: '| Constructor | Contract owner is sender | Testing contract ownership |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 合约所有者是发送者 | 测试合约所有权 |'
- en: '| Constructor | Owner balance = supply | Testing correct state set from constructor
    parameters |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 所有者余额=供应量 | 测试从构造函数参数设置正确的状态 |'
- en: '| Mint | Can’t mint from nonowner account | Testing if an exception is raised
    when an unauthorized account invokes the function |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 铸币 | 非所有者账户不能铸币 | 测试当非授权账户调用该函数时是否抛出异常 |'
- en: '| Transfer | Can’t transfer more tokens than owned | Testing if an exception
    is raised by invalid input breaching modifiers or require conditions |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 转账 | 不能转移超过拥有的代币 | 测试是否通过无效输入违反修饰符或require条件而抛出异常 |'
- en: '| Transfer | Successful transfer | Testing contract state following successful
    transaction executed from valid account and with valid input |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 转账 | 成功的转账 | 在有效账户且输入有效的情况下执行交易后，测试合约状态 |'
- en: The test suite I’ve presented covers the most obvious test cases, but it’s by
    no means comprehensive. Like programming, unit testing is an art, not an exact
    science. You must always keep in mind the trade-off between coverage (Are all
    the functions of your contracts covered by tests? Are all logic branches covered
    by tests?) and accuracy (Are all boundary conditions of each function tested?)
    of your tests on one side and their cost (for implementation and maintenance)
    on the other side. Ideally, you might want to have maximum coverage and accuracy,
    but you might not have enough time and resources to implement and maintain all
    the necessary tests. In that case, you might want to focus on critical areas,
    especially on functionality for which Ether’s at stake.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我呈现的测试套件涵盖了最明显的测试用例，但绝不是全面的。就像编程一样，单元测试是一门艺术，而不是一门精确的科学。你总是要牢记测试的覆盖率（你的合约的所有功能是否被测试覆盖了？所有逻辑分支是否被测试覆盖了？）和准确度（每个函数的每个边界条件是否被测试了？）之间的权衡，以及它们的成本（实现和维护）。理想情况下，你可能希望有最大的覆盖率和准确度，但你可能没有足够的时间和资源来实现和维护所有必要的测试。在这种情况下，你可能会希望关注关键区域，特别是那些涉及Ether风险的功能。
- en: Summary
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: You can write Ethereum contract unit tests relatively easily with Mocha, a generic
    JavaScript testing framework.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以相对容易地使用Mocha，一个通用的JavaScript测试框架，来编写以太坊合约单元测试。
- en: You can install Mocha quickly with `npm`, the Node.js package manager.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`npm`这个Node.js包管理器快速安装Mocha。
- en: You can describe Mocha unit test packages and groups using `describe()` and
    individual tests using `it()`.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`describe()`来描述Mocha单元测试包和组，使用`it()`来描述个别测试。
- en: Your tests should cover negative checks, verifying expected exceptions are thrown
    in case the function is invoked from an unauthorized account or with invalid input.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试应该涵盖负面检查，验证当函数从一个未授权账户或输入无效时被调用时，期望的异常是否被抛出。
- en: Your tests should cover positive checks, verifying the contract state has been
    successfully modified by the function logic when the function is called from an
    authorized account and with valid input.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试应该涵盖正面检查，验证当函数从一个授权账户且输入有效时被调用，合约状态是否成功通过函数逻辑进行了修改。
- en: You also should write tests against the constructor to verify that the contract
    owner and the contract state are initialized correctly.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也应该针对构造函数编写测试，以验证合约所有者和合约状态是否被正确初始化。
- en: Chapter 11\. Improving the development cycle with Truffle
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章。使用Truffle改善开发周期
- en: '|  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Installing Truffle, a smart-contract framework
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Truffle，一个智能合约框架
- en: Setting up and compiling an Ethereum contract within Truffle
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Truffle内设置和编译以太坊合约
- en: Simplifying contract deployment through Truffle’s migrations
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Truffle的迁移来简化合约部署
- en: Simplifying contract unit testing with Truffle
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Truffle简化合约单元测试
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the previous chapter, you started to integrate unit testing into your development
    environment with Mocha. But you might have noticed that the unit test script didn’t
    look ideal. It has a fairly complex setup, which includes explicit instructions
    on compiling `SimpleCoin` and creating a contract factory. Each test also includes
    an explicit deployment statement that references the contract factory. The main
    drawback is that all this infrastructural code distracts from the main objective
    of unit tests, which is to focus on functional aspects of a contract. Another
    disadvantage is that if you wanted to create a new test suite to cover a different
    contract, you’d have to duplicate all this infrastructural code.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你开始将单元测试集成到你的开发环境中，使用Mocha。但你可能注意到了，单元测试脚本看起来并不理想。它的设置相当复杂，包括编译`SimpleCoin`和创建合约工厂的明确指示。每个测试还包括一个引用合约工厂的明确部署语句。主要缺点是，所有这种基础设施代码使单元测试的主要目标——关注合约的功能方面——变得分散。另一个缺点是，如果你想要创建一个新的测试套件来覆盖不同的合约，你必须复制所有这种基础设施代码。
- en: Wouldn’t it be nice if you had a way to simplify the deployment of a contract?
    This is the main objective of Truffle, an Ethereum contract development framework
    that focuses on streamlining deployment and consequently simplifying unit testing.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个方法来简化合约的部署，那岂不是很好？这就是Truffle的主要目标，它是一个以太坊合约开发框架，专注于简化部署并因此简化单元测试。
- en: 'In this chapter, you’ll set up Truffle, and then you’ll use it to improve the
    compile -> deploy -> test cycle. The main focus will be on learning how to use
    the tool, so, to avoid getting distracted by contract-specific issues, you’ll
    reuse our good old `SimpleCoin` contract yet again. If you’re eager to implement
    something new, please bear with me: in the next chapter you’ll develop a brand
    new Dapp from scratch using Truffle!'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将设置Truffle，然后使用它来改进编译 -> 部署 -> 测试周期。主要关注学习如何使用这个工具，所以，为了避免被合同特定问题分心，您将再次重复使用我们古老的`SimpleCoin`合同。如果您急于实现新功能，请耐心等待：在下一章中，您将使用Truffle从头开始开发一个全新的Dapp！
- en: 11.1\. Setting up Truffle
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 在Truffle中设置Truffle
- en: 'You can install Truffle easily with Node.js `npm`, and then you can start to
    create a project. Install version 4.1.15, which is the one I have used, as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Node.js `npm`轻松安装Truffle，然后开始创建项目。安装我使用的4.1.15版本，如下所示：
- en: '[PRE65]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: In order to run my code smoothly, don’t install Truffle 5.0.0\. My code is written
    against version 4.1.15, and is unlikely to work correctly under version 5.0.0.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我代码顺利运行，请不要安装Truffle 5.0.0。我的代码是针对版本4.1.15编写的，不太可能在版本5.0.0下正确运行。
- en: '|  |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2\. Moving SimpleCoin under Truffle
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 在Truffle中移动SimpleCoin
- en: 'You’ll start with a minimal project, and then you’ll integrate `SimpleCoin`
    in Truffle by walking through the entire development lifecycle, including the
    following steps:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从一个最小项目开始，然后通过整个开发生命周期（包括以下步骤）在Truffle中集成`SimpleCoin`：
- en: Setting up `SimpleCoin` in Truffle
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Truffle中设置`SimpleCoin`
- en: Compiling the contract
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译合同
- en: Deploying the contract
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署合同
- en: Unit testing the contract
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试合同
- en: 11.2.1\. Setting up SimpleCoin in Truffle
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1. 在Truffle中设置SimpleCoin
- en: 'Create a working directory for the `SimpleCoin` Truffle project. I’ve created
    mine as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 为`SimpleCoin` Truffle项目创建一个工作目录。我是这样创建我的目录的：
- en: '[PRE66]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open an OS shell and move to this directory:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个操作系统外壳，并移动到这个目录：
- en: '[PRE67]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now you can initialize the Truffle project:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以初始化Truffle项目：
- en: '[PRE68]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Truffle will create the following directory structure and prepopulate it with
    some files:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle将创建以下目录结构并预先填充一些文件：
- en: '[PRE69]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Table 11.1](#ch11table01) provides a description of each directory.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '[表11.1](#ch11table01)提供了每个目录的描述。'
- en: Table 11.1\. Truffle directory structure
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.1. Truffle目录结构
- en: '| Directory/filename | Description |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| 目录/文件名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| /contracts | Directory for Solidity contract files you want to compile and
    deploy. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| /contracts | 您想要编译和部署的Solidity合同文件目录。|'
- en: '| /contracts/Migrations.sol | Special contract that Truffle uses to deploy
    project contracts. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| /contracts/Migrations.sol | Truffle用于部署项目合同的特殊合同。|'
- en: '| /migrations | JavaScript configuration files to perform *migrations* (more
    on this later). |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| /migrations | 执行*迁移*（稍后详细介绍）的JavaScript配置文件。|'
- en: '| /test | Truffle can automatically test both Solidity contract code and JavaScript
    application code through unit tests placed in this folder. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| /test | Truffle可以通过单元测试自动测试放置在此文件夹中的Solidity合同代码和JavaScript应用程序代码。|'
- en: '| truffle.js | The Truffle project configuration file for Linux or macOS. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| truffle.js | Linux或macOS上的Truffle项目配置文件。|'
- en: '| truffle-config.js | The Truffle project configuration file for Windows. |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| truffle-config.js | Windows上的Truffle项目配置文件。|'
- en: '|  |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you’re running Windows, keep truffle-config.js and remove truffle.js. If
    you’re running on Linux or macOS, you can remove truffle-config.js and use truffle.js.
    In the rest of the chapter, I’ll refer to truffle.js—you’ll understand why shortly.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上运行，请保留truffle-config.js并删除truffle.js。如果您在Linux或macOS上运行，您可以删除truffle-config.js并使用truffle.js。在本书的其余部分，我将提到truffle.js——您很快就会明白为什么。
- en: '|  |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2.2\. Compiling SimpleCoin
  id: totrans-645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2. 编译SimpleCoin
- en: Copy the latest version of `SimpleCoin` from C:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol
    to C:\Ethereum\Truffle\SimpleCoin\Contracts\SimpleCoin.sol. Downgrade the pragma
    solidity instruction of SimpleCoin.sol to 0.4.23 after copying the file, as the
    latest version of Truffle at the time of writing uses solc 0.4.23.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 从C:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol复制最新版本的`SimpleCoin`到C:\Ethereum\Truffle\SimpleCoin\Contracts\SimpleCoin.sol。在将文件复制后，将SimpleCoin.sol中的pragma
    solidity指令降级到0.4.23，因为在撰写本文时，最新的Truffle版本使用的是solc 0.4.23。
- en: You perform contract deployment in Truffle through so-called *migrations*, as
    I’ll explain shortly. You execute these through a `Migrations` contract, shown
    in the following listing, which was auto-generated in the contracts folder when
    you initialized the project with the `truffle init` command.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过所谓的*迁移*在Truffle中进行合约部署，我稍后会解释。您通过以下列表中显示的`Migrations`合约执行这些操作，该合约在您使用`truffle
    init`命令初始化项目时自动生成在合约文件夹中。
- en: Listing 11.1\. contracts/Migrations.sol
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. contracts/Migrations.sol
- en: '[PRE70]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can now kick the compilation
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以启动编译
- en: '[PRE71]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'and you’ll see output similar to this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到与以下类似的输出：
- en: '[PRE72]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After a successful compilation, Truffle has created a new directory relative
    to the project folder, /build/contracts. The folder contains compilation artifacts,
    described in [table 11.2](#ch11table02), that you’ll use during the deployment
    stage.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成功后，Truffle在项目文件夹相对路径下创建了一个新目录，/build/contracts。该目录包含编译产物，如表11.2所述，您将在部署阶段使用。
- en: Table 11.2\. Compilation artifacts
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.2\. 编译产物
- en: '| Artifact | Purpose |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 艺术作品 | 目的 |'
- en: '| --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Migrations.json | ABI interface and bytecode of Migrations.sol |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| Migrations.json | Migrations.sol的ABI接口和字节码 |'
- en: '| SimpleCoin.json | ABI interface and bytecode of SimpleCoin.sol |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| SimpleCoin.json | SimpleCoin.sol的ABI接口和字节码 |'
- en: 11.2.3\. Troubles with Truffle
  id: totrans-660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. Truffle的问题
- en: If you’ve started having issues at this point, it might be because you’re working
    in Windows or have a compiler versioning problem. You’ll need a solution so you
    can complete the work in this chapter. This two-part section provides some advice
    to help you solve such problems.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此阶段开始遇到问题，可能是因为您在Windows中工作，或者有编译器版本问题。您需要一个解决方案，以便在本章中完成工作。本部分提供了一些建议，帮助您解决此类问题。
- en: Truffle on Windows
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Truffle在Windows上
- en: If you’re working in Windows, you might experience issues when running any Truffle
    command. Specifically, if you’re running Truffle compile in a Windows command
    shell, you might get the cryptic Microsoft JScript runtime error shown in [figure
    11.1](#ch11fig01).
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows中工作，当运行任何Truffle命令时可能会遇到问题。特别是，如果您在Windows命令提示符中运行Truffle compile，您可能会遇到图11.1中显示的神秘的Microsoft
    JScript运行时错误。
- en: Figure 11.1\. Error generated when running a Truffle command in Windows
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. 在Windows中运行Truffle命令时生成的错误
- en: '![](Images/fig11-01_alt.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig11-01_alt.jpg)'
- en: 'The error occurs because Windows can’t distinguish correctly between the Truffle.cmd
    command file in the npm folder (typically in C:\Users\YOURNAME\AppData\ Roaming\npm)
    and the truffle.js file in your Truffle project folder. You have four options
    for solving this issue:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为Windows无法正确区分npm文件夹中的Truffle.cmd命令文件（通常位于C:\Users\YOURNAME\AppData\Roaming\npm）和您Truffle项目文件夹中的truffle.js文件。您有四个选项来解决此问题：
- en: Use a configuration file named truffle-config.js instead of truffle.js, as mentioned
    in the earlier setup section. Remove truffle.js from your Truffle project folder.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名为truffle-config.js的配置文件，而不是truffle.js，如早期设置部分所述。将truffle.js从您的Truffle项目文件夹中删除。
- en: If for any reason you want to use a configuration file named truffle.js rather
    than truffle-config.js, use Git Bash rather than the standard command shell.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您出于任何原因想要使用名为truffle.js的配置文件，而不是truffle-config.js，请使用Git Bash而不是标准命令提示符。
- en: Call truffle.cmd explicitly, for example, `truffle.cmd compile`.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式调用truffle.cmd，例如，`truffle.cmd compile`。
- en: Go to the directory where truffle.cmd is and copy it locally with another name,
    for example, truff.cmd. Then run `truff compile` instead of Truffle compile. If
    you decide to use this workaround, keep typing *truff* rather than Truffle for
    the rest of the chapter.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到truffle.cmd所在的目录，并将其复制为另一个名称，例如，truff.cmd。然后运行`truff compile`，而不是Truffle compile。如果您决定使用这个解决方法，请在本章剩余时间里输入*truff*，而不是Truffle。
- en: Troubleshooting Truffle Compile Errors
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决Truffle编译错误
- en: If you get compilation errors, it might be because you’re running an old version
    of the compiler or because Truffle is referencing an old version of the compiler,
    even if you’ve upgraded it recently. Specifically, after executing the `truffle
    compile` command, you might get some compilation error messages due to new constructor
    syntax introduced in solc 0.4.22\. You have two options for fixing the issue.
    The best approach is to uninstall Truffle and reinstall it globally by entering
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到编译错误，可能是因为您正在运行旧版本的编译器，或者即使您最近升级了它，Truffle也在引用旧版本的编译器。具体来说，在执行`truffle
    compile`命令后，您可能会收到一些由于在solc 0.4.22中引入的新构造函数语法而导致的编译错误消息。您有两个选项来解决问题。最佳的方法是卸载Truffle，然后通过输入
- en: '[PRE73]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: followed by
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随
- en: '[PRE74]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now if you re-execute `truffle compile`, you should get at most some warnings
    associated, possibly, with the `Migrations` contract (in the contracts\Migrations.sol
    file). It might still be implemented under an old constructor convention, depending
    on the version of Truffle you’re running. If you’re running Truffle 4.1.15 or
    later, you shouldn’t have any issues; the Migrations.sol file should have been
    autogenerated like in [listing 11.1](#ch11ex01). If you’re running an older version
    and want to get rid of the warnings, replace
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你重新执行`truffle compile`，你应该最多只收到一些与`Migrations`合约相关的警告（在`contracts\Migrations.sol`文件中）。这可能仍然实现在一个旧的构造函数约定中，这取决于你正在运行的Truffle版本。如果你正在运行Truffle
    4.1.15或更高版本，你应该不会有任何问题；`Migrations.sol`文件应该已经被自动生成为如[列表 11.1](#ch11ex01)中所示。如果你正在运行一个较旧的版本并且想要消除警告，请替换
- en: '[PRE75]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: with
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 与
- en: '[PRE76]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you recompile, you should no longer get any warnings:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新编译，你应该不会再收到任何警告：
- en: '[PRE77]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The second way to fix compilation issues, which I’d leave as a last resort,
    is to reinstall solc, but only into the project folder:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 修复编译问题的第二种方法，我会将其作为最后的手段，那就是重新安装solc，但只安装到项目文件夹中：
- en: '[PRE78]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 11.2.4\. Deploying SimpleCoin onto a mock network client through migrations
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.4\. 通过迁移将SimpleCoin部署到模拟网络客户端
- en: A migration is a deployment script. As seen before, migration scripts are in
    the migrations directory. Replace the content of 2_deploy_contracts.js with the
    script shown in the following listing.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是一个部署脚本。如前所见，迁移脚本位于`migrations`目录中。用以下列表中显示的脚本替换2_deploy_contracts.js的内容。
- en: 'Listing 11.2\. 2_deploy_contracts.js: `SimpleCoin''s` migration script'
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 2_deploy_contracts.js：`SimpleCoin`的迁移脚本
- en: '[PRE79]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1*** **artifacts.require is similar to Node.js require, and you have to
    initialize it with the name of a contract (not a contract filename).**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** `artifacts.require`类似于Node.js的`require`，你必须用合约名（而不是合约文件名）来初始化它。'
- en: '***2*** **You have to set the module.exports property to a function that accepts
    a deployer object, which is the component performing deployment tasks.**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 您必须将`module.exports`属性设置为一个接受部署者对象的函数，该对象是执行部署任务的组件。'
- en: '***2*** **SimpleCoin gets deployed with an initial supply of 10,000 tokens.**'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** `SimpleCoin`的初始供应量为10,000个代币。'
- en: 'During the first migration execution, you also have to deploy the `Migrations`
    contract. This contract gets deployed through its own migration script, shown
    in the following listing and contained in this file: C\Ethereum\Truffle\SimpleCoin\migrations\1_initial_migration.js.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迁移执行期间，你还需要部署`Migrations`合约。这个合约通过它自己的迁移脚本部署，如下所示的列表中显示，包含在这个文件中：C\Ethereum\Truffle\SimpleCoin\migrations\1_initial_migration.js。
- en: 'Listing 11.3\. 1_initial_migration.js: `Migrations`’ migration script'
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 1_initial_migration.js：`Migrations`的迁移脚本
- en: '[PRE80]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Once you’ve placed the migration scripts in the migrations directory, open
    a separate OS shell and move to the project folder:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将迁移脚本放置在`migrations`目录中，打开一个单独的操作系统终端，然后移动到项目文件夹：
- en: '[PRE81]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You’ll be deploying `SimpleCoin` onto Ganache, the mock Ethereum client you
    already saw in [chapters 8](kindle_split_020.xhtml#ch08) and [10](kindle_split_023.xhtml#ch10).
    Ganache is part of the Truffle framework. If you haven’t already installed it,
    you can do so through npm, as usual:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`SimpleCoin`部署到Ganache，这是您已经在第[8](kindle_split_020.xhtml#ch08)章和第[10](kindle_split_023.xhtml#ch10)章中见过的模拟Ethereum客户端。Ganache是Truffle框架的一部分。如果您还没有安装它，您可以通过npm像往常一样进行安装：
- en: '[PRE82]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, after the installation is complete, start it up:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在安装完成后，启动它：
- en: '[PRE83]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Make sure truffle.js (or truffle-config.js on Windows) is configured to point
    to Truffle Develop, as shown in the following listing, as opposed to pointing
    to a public test network. Amend its content as shown in the following listing.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`truffle.js`（或在Windows上的`truffle-config.js`）配置为指向Truffle Develop，如以下列表所示，而不是指向公共测试网络。如以下列表所示修改其内容。
- en: 'Listing 11.4\. truffle.js (or truffle-config.js): Truffle pointing to Test
    Develop'
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. truffle.js（或 truffle-config.js）：Truffle 指向 Test Develop
- en: '[PRE84]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Deploying from a specific account**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**从特定账户部署**'
- en: 'By default, your contracts will be deployed under Truffle from accounts[0],
    which is the default transaction sender. If you want the deployment transaction
    to be submitted from another account, you must specify the full address in the
    truffle.js file in the `from` property, as shown here:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的智能合约将由 Truffle 从 accounts[0] 部署，这是默认的交易发送者。如果您希望部署交易从另一个账户提交，您必须在 truffle.js
    文件中的 `from` 属性中指定完整地址，如下所示：
- en: '[PRE85]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1*** **This is Ganache’s accounts[1], as shown on Ganache’s startup screen.**'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这是 Ganache 的 accounts[1]，如 Ganache 启动屏幕上所示。**'
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Go back to the previous console and run
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上一个控制台并运行
- en: '[PRE86]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then you’ll get output like this:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将得到如下输出：
- en: '[PRE87]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This shows that `SimpleCoin` has been deployed successfully on Ganache’s mock
    network. If you prefer to run the mock network client and Truffle commands from
    within the same OS shell, you can use a separate console called Truffle Develop.
    Have a look at the sidebar if you want to learn more. For the rest of the book,
    you’ll keep using two separate consoles: one to run Ganache and the other to launch
    Truffle commands.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 `SimpleCoin` 已在 Ganache 的模拟网络上成功部署。如果您更喜欢在同一个操作系统shell中运行模拟网络客户端和 Truffle
    命令，可以使用一个名为 Truffle Develop 的单独控制台。如果您想了解更多，请查看侧边栏。本书的其余部分，您将使用两个分开的控制台：一个运行 Ganache，另一个启动
    Truffle 命令。
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Executing Truffle commands from Truffle Develop’s console**'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**从 Truffle Develop 控制台执行 Truffle 命令**'
- en: 'You can start Truffle Develop from the Truffle project folder, as follows:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 Truffle 项目文件夹以如下方式启动 Truffle Develop：
- en: '[PRE88]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This will start a mock network client similar to Ganache (and TestRPC), but
    on port 9545, which means, if you have Ganache running, you don’t need to shut
    it down.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个类似于 Ganache（和 TestRPC）的模拟网络客户端，但端口为 9545，这意味着，如果您正在运行 Ganache，您不需要关闭它。
- en: '![](Images/f0325-01_alt.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0325-01_alt.jpg)'
- en: Truffle Develop startup screen
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle Develop 启动屏幕
- en: 'But if you want to use Truffle Develop, you need to change the truffle.js configuration
    to point to port 9545:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想使用 Truffle Develop，需要将 truffle.js 配置更改为指向端口 9545：
- en: '[PRE89]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now you’ll be able to run Truffle commands, such as `migrate`, directly from
    the Truffle Develop console:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够直接从 Truffle Develop 控制台运行 Truffle 命令，例如 `migrate`：
- en: '[PRE90]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You’ll see exactly the same output as before.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到与之前完全相同的输出。
- en: '|  |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2.5\. Deploying SimpleCoin onto a public test or production network
  id: totrans-727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.5\. 将 SimpleCoin 部署到公共测试或生产网络
- en: 'Although in this chapter you’ll be deploying contracts only on Ganache (or
    TestRPC), at some point you might want to deploy on the public test network or
    production network. If so, you must modify your truffle.js (or truffle-config.js)
    file and include configurations for a test network and a live network, as follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本章中您只会将合约部署到 Ganache（或 TestRPC），但迟早您可能会想将其部署到公共测试网络或生产网络。如果是这样，您必须修改您的 truffle.js（或
    truffle-config.js）文件并包括测试网络和实时网络的配置，如下所示：
- en: '[PRE91]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This configuration assumes you’re running a local geth node (the host is pointing
    to localhost), and the default Web 3 provider will be instantiated by Truffle
    as
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置假设您正在运行一个本地的 geth 节点（主机指向 localhost），默认的 Web 3 提供者将由 Truffle 实例化：
- en: '[PRE92]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'But if you decide to use a different provider, for instance an HDWalletProvider
    pointing to a Ropsten Infura network, you must configure it explicitly with the
    provider property:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您决定使用不同的提供者，例如指向 Ropsten Infura 网络的 HDWalletProvider，您必须显式配置提供者属性：
- en: '[PRE93]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Also, bear in mind, when deploying on a public network, you might want to specify
    other settings, such as the gas limit, the gas price, and the account the contract
    should be deployed through. If so, you can add relevant configuration properties
    as described in [table 11.3](#ch11table03), but I invite you to consult the official
    documentation before proceeding further: [http://mng.bz/mmgy](http://mng.bz/mmgy).'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，请注意，在公共网络上部署时，您可能需要指定其他设置，例如燃料限制、燃料价格以及合约应通过哪个账户部署。如果是这样，您可以根据[表 11.3](#ch11table03)
    描述添加相关的配置属性，但我建议您在继续之前咨询官方文档：[http://mng.bz/mmgy](http://mng.bz/mmgy)。
- en: Table 11.3\. The truffle.js configuration properties
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 11.3\. truffle.js 配置属性
- en: '| Property | Purpose |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 用途 |'
- en: '| gas: | Gas limit (default = 4712388) |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| gas: | 燃料限制（默认 = 4712388）|'
- en: '| gasPrice: | Gas price (default = 100,000,000,000 wei) |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| gasPrice: | 燃料价格（默认 = 100,000,000,000 wei）|'
- en: '| from: | Sender address of the deployment transaction (and contract owner)
    |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| 从: | 部署交易的发件人地址（和合约所有者） |'
- en: '| provider: | The default is web3, as explained previously. |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| 提供者: | 默认是web3，如前所解释。 |'
- en: 'Once you’ve configured truffle.js (or truffle-config.js) appropriately, you
    can kick a deployment to the Ropsten network as follows:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你适当地配置了truffle.js（或truffle-config.js），你可以像以下这样将部署踢到Ropsten网络：
- en: '[PRE94]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'And, as you might have guessed, you’d deploy to MAINNET as follows:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，正如你可能已经猜到的，你将像以下这样部署到MAINNET：
- en: '[PRE95]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 11.2.6\. Testing SimpleCoin
  id: totrans-745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.6 测试SimpleCoin
- en: Truffle supports *clean-room testing*, which means that if a contract has been
    deployed on Ganache, its state will get reinitialized at the beginning of each
    test file being processed. If the contract has been deployed on a public network,
    the migrations will get re-executed at the start of each test file being processed,
    effectively redeploying the contract from scratch before the execution of the
    tests. In general, during development it’s preferable to run unit tests against
    Test Develop, as they run up to 90% faster. It’s advisable to run the tests on
    a private network, and ultimately on a public network, in later stages of the
    development cycle to make sure you’ve tested application aspects of communicating
    with a real network.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle支持清洁室测试（clean-room testing），这意味着如果一个合约已经在Ganache上部署，那么在每个测试文件被处理开始时，其状态都将重新初始化。如果合约已经在一个公共网络上部署，那么在每个测试文件被处理开始时，迁移将重新执行，有效地在测试执行之前从头重新部署合约。通常，在开发过程中，针对Test
    Develop运行单元测试更为合适，因为它们可以快达90%。建议在开发的后期阶段运行测试在私有网络上，最终在公共网络上，以确保你已经测试了与真实网络通信的应用方面。
- en: 'It’s possible to write two different classes of tests with Truffle:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Truffle可以编写两类不同的测试：
- en: '*Solidity tests*—Test the contract logic from test contracts'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity测试—从测试合约测试合约逻辑
- en: '*JavaScript tests*—Test the contract from external Web3.js calls, which go
    through the same infrastructure as real calls'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript测试—从外部的Web3.js调用测试合约，这些调用通过与实际调用相同的基础设施进行
- en: You must place all test scripts, whether written in Solidity or JavaScript,
    in the test directory of the Truffle project. We’ll focus almost entirely on JavaScript
    tests, as Solidity tests are meant to test contract-to-contract interaction, which
    is a more advanced topic outside the scope of this book. But I’ll give you some
    of the basics of working with Solidity tests.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须把所有测试脚本，无论是用Solidity还是JavaScript编写的，都放在Truffle项目的测试目录中。我们将几乎完全专注于JavaScript测试，因为Solidity测试是用来测试合约之间的交互，这是一个更高级的课题，超出了本书的范围。但我将给你一些关于使用Solidity测试的基础知识。
- en: 11.2.7\. Writing Solidity tests
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.7 编写Solidity测试
- en: You implement Solidity tests through custom test contracts whose code you have
    to place in .sol files within the project test directory. Solidity tests must
    be able to run against
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过自定义测试合约来实现Solidity测试，其代码你必须放置在项目测试目录中的.sol文件里。Solidity测试必须能够运行针对
- en: the assertion library that Truffle provides
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle提供的断言库
- en: any other assertion library
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他的断言库
- en: Ganache (or TestRPC)
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ganache（或TestRPC）
- en: any Ethereum client (not only geth) and type of network (both private and public)
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以太坊客户端（不仅仅是geth）和网络类型（私有和公共）
- en: 'You structure a Solidity test contract the way TestSimpleCoin.sol does, as
    shown in [listing 11.5](#ch11ex05). You must follow these guidelines and conventions:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 你应当像TestSimpleCoin.sol中那样结构一个Solidity测试合约，正如[列表11.5](#ch11ex05)所展示的那样。你必须遵循这些指南和约定：
- en: You must import an assertion library to check for equality, inequality, and
    emptiness. The default assertion library that Truffle provides is Truffle/Assert.sol.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须导入一个断言库来检查相等性、不等性和空性。Truffle提供的默认断言库是Truffle/Assert.sol。
- en: You must import the Truffle/DeployedAddresses.sol library so the test runner
    can access the addresses of contracts deployed through migrations. The Deployed-Addresses
    library is recompiled each time the test contract is run, to guarantee clean-room
    testing.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须导入Truffle/DeployedAddresses.sol库，这样测试运行器才能访问通过迁移部署的合约的地址。Deployed-Addresses库在每次测试合约运行时都会重新编译，以确保测试环境的清洁。
- en: You must import the contract under test.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须导入正在测试的合约。
- en: The name of a test contract must start with Test (uppercase T) so the test runner
    can identify it easily.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试合约的名字必须以Test（大写的T）开始，这样测试运行器才能容易地识别它。
- en: The name of a test function must start with test (lowercase t).
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数的名字必须以test（小写的t）开始。
- en: A test function must return a Boolean value. Generally, this is returned through
    an assertion function such as `Assert.equal().`
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数必须返回一个布尔值。通常，这个值通过一个断言函数，如`Assert.equal()`返回。
- en: Listing 11.5\. TestSimpleCoin.sol test contract
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.5\. TestSimpleCoin.sol测试合约
- en: '[PRE96]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1*** **Imports assert library**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导入断言库**'
- en: '***2*** **Imports DeployedAddresses contract**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **导入DeployedAddresses合约**'
- en: '***3*** **Imports contract being tested: SimpleCoin**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **导入被测试的合约：SimpleCoin**'
- en: '***4*** **Testing contract**'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **测试合约**'
- en: '***5*** **SimpleCoin instance at the deployed address**'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **SimpleCoin实例在部署地址**'
- en: '***6*** **Verifies test assumptions**'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **验证测试假设**'
- en: 'First, place TestSimpleCoin.sol in the test folder and make sure Test Develop
    (or TestRPC) is still running. (If it’s not running, restart it in a separate
    console.) You can then run Solidity tests by executing this command:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将TestSimpleCoin.sol放在测试文件夹中，并确保Test Develop（或TestRPC）仍在运行。（如果它没有运行，请在另一个控制台中重新启动它。）然后你可以通过执行以下命令来运行Solidity测试：
- en: '[PRE97]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You’ll get output similar to this:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到与这个类似的输出：
- en: '[PRE98]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '|  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Depending on the version of your solc compiler, you might get some warnings,
    especially around code raising events.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的solc编译器版本，你可能会得到一些警告，特别是关于代码引发事件的周围。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As I mentioned earlier, contract-to-contract testing is an advanced topic outside
    of the scope of this book, so I won’t cover Solidity tests further. The next section
    will be dedicated entirely to JavaScript tests under Truffle.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，合约之间的测试是一个超出本书范围的高级主题，所以我不会进一步介绍Solidity测试。下一节将完全致力于Truffle下的JavaScript测试。
- en: 11.2.8\. Writing JavaScript tests
  id: totrans-781
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.8\. 编写JavaScript测试
- en: 'Do you remember the effort you put into writing tests in Mocha? It wasn’t wasted:
    Truffle supports Mocha JavaScript testing, but with deeper integration with Ethereum.
    This means you'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得你花在编写Mocha测试上的努力吗？并没有白费：Truffle支持Mocha JavaScript测试，但与以太坊的集成更深。这意味着你可以
- en: won’t have to decorate your test files with `require` statements for Ethereum
    libraries such as web3.js
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需在您的测试文件中为诸如web3.js之类的以太坊库添加`require`语句
- en: will be able to reference contracts that have been deployed through migrations,
    without having to compile them and deploy them manually
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以隐式地引用通过迁移部署的合约，而无需手动编译和部署它们
- en: will be able to reference accounts implicitly, without having to hardcode Ethereum
    addresses
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以隐式地引用账户，而无需硬编码以太坊地址
- en: will be able to run the tests from within Truffle and integrate them within
    any continuous integration jobs that Truffle coordinates
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在Truffle内部运行测试并将它们集成到Truffle协调的任何持续集成作业中
- en: 'To run in Truffle the JavaScript tests you wrote earlier in Mocha, you’ll have
    to make minor changes, especially if you want to ensure they’re executed in clean-room
    mode:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Truffle中运行你之前在Mocha中编写的JavaScript测试，你需要做一些小的改动，特别是如果你想要确保它们以干净室模式执行：
- en: Replace `describe()` calls with `contract()` calls, which ensures all contracts
    get redeployed onto the Ethereum client and tests are run with a *clean* contract
    state.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`contract()`调用替换`describe()`调用，这确保所有合约都重新部署到以太坊客户端，并以*干净*的合约状态运行测试。
- en: Reference solidity contracts with `artifacts.require()`, as you did earlier
    when writing the migration scripts.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`artifacts.require()`引用solidity合约，就像你之前编写迁移脚本时一样。
- en: Replace the callback section within the asynchronous deployment call you had
    on Mocha tests with a promise chain, where the first promise in the chain is a
    promise of a deployed contract, and the subsequent promises are chained through
    `then()` statements.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一个承诺链替换你之前在Mocha测试中的异步部署调用中的回调部分，承诺链中的第一个承诺是一个已部署合约的承诺，随后的承诺通过`then()`语句链接。
- en: I’ll demonstrate here how to rewrite some of the tests, so you can get a better
    idea of what the guidelines I’ve given mean. I’ll start from the first test against
    `SimpleCoin`’s constructor. For convenience, I’ve repeated the code from the original
    test you wrote in Mocha in the following listing, so you don’t have to flip pages
    back and forth.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里展示如何重写一些测试，以便你可以更好地理解我给出的指导方针意味着什么。我从针对`SimpleCoin`构造器的第一个测试开始。为了方便，我在下面的列表中重复了你在Mocha中原始编写的代码，这样你就不必翻页。
- en: Listing 11.6\. Original Mocha test on the constructor, verifying contract ownership
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.6\. 原始Mocha测试，验证构造器，检查合约所有权
- en: '[PRE99]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Now create a file called testSimpleCoin.js and place it in the test directory.
    Fill it with the code shown in the following listing.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为testSimpleCoin.js的文件，并将其放在test目录中。用以下列表中的代码填充它。
- en: Listing 11.7\. Truffle constructor test verifying contract ownership
  id: totrans-795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.7\. Truffle构造函数测试验证合约所有权
- en: '[PRE100]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1*** **References SimpleCoin, the code under test**'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引用SimpleCoin，待测试的代码**'
- en: '***2*** **Name of the test suite**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **测试套件的名称**'
- en: '***3*** **Name of the test section**'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **测试部分的名称**'
- en: '***4*** **Description of the single test**'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **测试的描述**'
- en: '***5*** **Gets a promise of a SimpleCoin contract instance deployed through
    the migration you set up earlier**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **获得通过之前设置的迁移部署的SimpleCoin合约实例的承诺**'
- en: '***6*** **Chains the promise of a SimpleCoin instance to a new function**'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将SimpleCoin实例的承诺链接到新函数**'
- en: '***7*** **Gets a promise of the owner of the SimpleCoin instance**'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **获得SimpleCoin实例所有者的承诺**'
- en: '***8*** **Chains the promise of the owner of the SimpleCoin instance to a new
    function**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **将SimpleCoin实例所有者的承诺链接到新函数**'
- en: '***9*** **The final function executed in the promise chain performs the test
    assertion.**'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **在承诺链中执行的最后函数执行测试断言。**'
- en: '***10*** **Error message to display in case of test failure**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **测试失败时显示的错误信息**'
- en: '|  |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As I mentioned in the deployment section, by default, contracts are deployed
    under Truffle from `accounts[0]`. That’s why in the test you’re comparing the
    address of the contract owner, `contractOwner.valueOf()`, with `accounts[0]`.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在部署部分所提到的，默认情况下，合约是在Truffle中从`accounts[0]`部署的。这就是为什么在测试中，你要比较合约所有者地址`contractOwner.valueOf()`和`accounts[0]`的原因。
- en: '|  |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve surely noticed a few differences between Mocha and Truffle tests, such
    as those listed in [table 11.4](#ch11table04).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定注意到了Mocha和Truffle测试之间的一些区别，如[表11.4](#ch11table04)中列出的那些。
- en: Table 11.4\. Differences between Mocha and Truffle tests
  id: totrans-812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.4\. Mocha和Truffle测试之间的区别
- en: '| Mocha tests | Truffle tests |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| Mocha测试 | Truffle测试 |'
- en: '| --- | --- |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mocha’s test script starts with a relatively long setup, during which we
    go through all the necessary low-level steps required for deploying SimpleCoin.
    | Truffle’s test has hardly any setup at all and immediately references a deployed
    instance of SimpleCoin (through the migration framework). |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '| Mocha的测试脚本以相对较长的设置开始，在这个过程中，我们完成了部署SimpleCoin所需的所有必要低级步骤。| Truffle的测试几乎没有设置，并且立即引用已部署的SimpleCoin实例（通过迁移框架）。|'
- en: '| Mocha’s test execution is based on a callback associated with the deployment
    of a SimpleCoin instance. | Truffle’s test execution is based on a chain of promises
    starting with a promise of a deployed SimpleCoin instance. |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '| Mocha的测试执行基于与SimpleCoin实例部署相关联的回调。| Truffle的测试执行基于从部署的SimpleCoin实例承诺开始的承诺链。|'
- en: '| Once you get ahold of a SimpleCoin instance (or a promise of it), Mocha’s
    test code seems shorter and to the point. | After getting a SimpleCoin instance,
    Truffle’s code goes through various steps to get ahold of the contract owner for
    subsequently comparing it with the expected one. |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '| 一旦你掌握了SimpleCoin实例（或其承诺），Mocha的测试代码似乎更简洁、更有针对性。| 在获得SimpleCoin实例之后，Truffle的代码通过各种步骤来获取合约所有者，随后将其与预期值进行比较。|'
- en: In summary, thanks to Truffle’s migration framework, tests don’t need much setup
    to access an instance of `SimpleCoin`. On the other hand, after referencing a
    `SimpleCoin` instance, Mocha’s test seems less verbose than Truffle’s.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，得益于Truffle的迁移框架，测试无需进行太多设置即可访问`SimpleCoin`实例。另一方面，在引用`SimpleCoin`实例之后，Mocha的测试似乎比Truffle的测试更简洁。
- en: 'Let’s run the test! When you re-execute the Truffle test command, both Solidity
    and JavaScript tests will be run, and you’ll get output similar to this:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试！当你重新执行Truffle测试命令时，将同时运行Solidity和JavaScript测试，并且你会得到如下输出：
- en: '[PRE101]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can rewrite the constructor test that verifies the owner balance is the
    initial supply. Add the following `it()` block in testSimpleCoin.js:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重写一个验证所有者余额是初始供应的构造函数测试。在testSimpleCoin.js中添加以下`it()`块：
- en: '[PRE102]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '|  |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you might remember, `SimpleCoin`’s migration script (named 2_deploy_contracts.js
    and shown in [listing 11.2](#ch11ex02)) sets the initial supply to 10,000\. That’s
    why the contract owner balance is being compared to 10,000.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会记得，`SimpleCoin`的迁移脚本（名为2_deploy_contracts.js，在[列表11.2](#ch11ex02)中展示）将初始供应设置为10,000。这就是为什么合约所有者余额要与10,000进行比较。
- en: '|  |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Rerun the tests:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试：
- en: '[PRE103]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Improving JavaScript tests with await/async
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用await/async改进JavaScript测试
- en: In the file named testSimpleCoin_ALL_sync.js provided on the book website, you
    can find a full Truffle test suite equivalent to the test suite you wrote earlier
    in Mocha. I encourage you to go through the tests in detail and compare the related
    tests.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书网站上提供的名为testSimpleCoin_ALL_sync.js的文件中，你可以找到一个完整的Truffle测试套件，相当于你之前在Mocha中编写的测试套件。我鼓励你详细查看测试并比较相关测试。
- en: You’ll come to the conclusion that the ideal structure for a test is a sort
    of chimera combining the easy setup of Truffle tests and the simple and direct
    code within Mocha’s callbacks. There is indeed a way to achieve this chimera,
    and it’s through JavaScript’s `async/await` syntax.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得出结论，理想的测试结构是一种类似于混血的生物，它结合了Truffle测试的简单设置和Mocha回调中的简单直接代码。确实有一种方法可以实现这种混血，那就是通过JavaScript的`async/await`语法。
- en: '|  |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript’s `async/await` syntax allows you to perform asynchronous processing
    through syntax that resembles that of synchronous programming—much simpler than
    that of typical asynchronous programming techniques such as callbacks or promise
    chains. If you’re interested in learning more about JavaScript asynchronous coding,
    I recommend *Secrets of the Java-Script Ninja* by John Resig, et al, published
    by Manning.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`async/await`语法允许你通过类似于同步编程的语法执行异步处理——比典型的异步编程技术（如回调或承诺链）简单得多。如果你对学习更多关于JavaScript异步编码感兴趣，我推荐John
    Resig等人出版的《JavaScript忍者秘籍》。
- en: '|  |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: To take advantage of `async/await`, you must be running on Node.js version 8.0
    or higher. I also advise you to install Truffle version 4.0 or higher.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`async/await`，你必须运行在Node.js 8.0或更高版本上。我还建议你安装Truffle 4.0或更高版本。
- en: '|  |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here’s how the first constructor test, which verifies contract ownership, looks
    using `async/await`:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`async/await`的第一个构造函数测试，验证合约所有权的样子：
- en: '[PRE105]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1*** **Gets the deployed instance of SimpleCoin**'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **获取已部署的SimpleCoin实例**'
- en: '***2*** **Gets the contract owner**'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **获取合约所有者**'
- en: '***3*** **Verifies the contract owner is what you expect**'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **验证合约所有者是否符合预期**'
- en: 'As you can see, by replacing the promise chain of the initial test version
    with statements based on `async/await`, the code looks as simple as a plain synchronous
    implementation would look. You’ve achieved exactly what you were looking for:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过将初始测试版本的承诺链替换为基于`async/await`的语句，代码看起来就像一个简单的同步实现一样简单。你正好达到了你想要的效果：
- en: Minimal (zero) `SimpleCoin` contract setup
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小（零）`SimpleCoin`合约设置
- en: Simple test implementation
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单测试实现
- en: 'Place this test in a new file—for example, called testSimpleCoin_asyncawait.js.
    Put it in the test folder and run it as usual (removing testSimpleCoin.js and
    TestSimpleCoin.sol from the test folder before doing so, so they don’t get executed):'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个测试放在一个新文件中——例如，命名为testSimpleCoin_asyncawait.js。将其放在测试文件夹中并像往常一样运行它（在这样做之前，删除测试文件夹中的testSimpleCoin.js和TestSimpleCoin.sol，这样它们就不会被执行）：
- en: '[PRE106]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You will get this output:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到这个输出：
- en: '[PRE107]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: I challenge you to convert the second constructor test, which verifies the owner
    balance is the initial supply, from the earlier version based on a promise chain
    to `async/await` statements. Look away and write your implementation before comparing
    your solution with mine!
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我挑战你将之前版本的第二构造函数测试转换为基于`async/await`的语句，该测试验证所有者余额是否为初始供应。别看，在你和我比较你的解决方案之前写下你的实现！
- en: Have you finished? Does your test look similar to this?
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了吗？你的测试看起来是不是和这个类似？
- en: '[PRE108]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If you’re still unconvinced of the benefits of moving from tests based on promise
    chains to tests based on `async/await`, I’ll show you a more dramatic comparison.
    Here’s the chain-promise-based version of a test on a successful `transfer()`
    operation:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不相信从基于承诺链的测试转移到基于`async/await`的测试的好处，我会给你展示一个更戏剧性的比较。这是一个基于承诺链的测试版本，测试成功的`transfer()`操作：
- en: '[PRE109]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1*** **Gets a promise of a deployed SimpleCoin instance**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **获取部署的SimpleCoin实例的承诺**'
- en: '***2*** **Gets a promise of the SimpleCoin instance after performing the transfer
    operation you’re testing**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **获取在执行转移操作后你正在测试的SimpleCoin实例的承诺**'
- en: '***3*** **Gets a promise of the sender balance**'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **获取发送者余额的承诺**'
- en: '***4*** **Assigns the sender balance to a variable**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将发送者余额分配给一个变量**'
- en: '***5*** **Gets a promise of the recipient balance**'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **获取接收者余额的承诺**'
- en: '***6*** **Assigns the recipient balance to a variable**'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将接收者余额分配给一个变量**'
- en: 'As you can see, having to reference balances through promises before assigning
    them to variables makes the test rather convoluted. Here’s the equivalent `async/await`
    version of this test:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，需要通过承诺在分配变量之前引用余额，使得测试相当复杂。这是这个测试的等效`async/await`版本：
- en: '[PRE110]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Isn’t this clearer? I’m so confident you can understand this version of the
    test without any explanation that I decided I didn’t need to annotate the code
    at all. If you have Node.js 8 (or higher) installed, you should definitely consider
    writing your tests with `async/await` rather than promise chains. I encourage
    you to try and convert all the chain-promise-based Truffle tests you find in the
    testSimpleCoin_ALL_sync.js file to equivalent `async/await` ones.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 这样不是更清晰吗？我对你能不经解释就能理解这个测试版本如此自信，以至于我决定根本不需要注释代码。如果你安装了Node.js 8（或更高版本），你肯定应该考虑使用`async/await`而不是承诺链来编写你的测试。我鼓励你尝试并将testSimpleCoin_ALL_sync.js文件中找到的所有基于链承诺的Truffle测试转换为等效的`async/await`版本。
- en: Summary
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: When writing a Mocha test, you must typically provide fairly complicated initialization
    code at the top of your script to deploy your contract through various steps,
    including solc compilation. Your test is placed in the callback associated with
    the contract deployment call.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Mocha测试时，你通常必须在脚本顶部提供相当复杂的初始化代码，以通过各种步骤（包括solc编译）部署你的合约，这些步骤包括solc编译。你的测试被放置在与合约部署调用相关联的回调中。
- en: Truffle is a contract development environment that simplifies contract compilation,
    deployment, and testing.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle是一个简化合约编译、部署和测试的合约开发环境。
- en: Truffle performs contract deployment through migrations, based on simple configuration.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle通过迁移来进行合约部署，基于简单的配置。
- en: When writing a Truffle test, you don’t need to provide any initialization code
    for contract compilation and deployment, but you must write tests with asynchronous
    code based on a promise chain, which might not be as readable as equivalent Mocha
    tests.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Truffle测试时，你不需要为合约编译和部署提供任何初始化代码，但必须基于承诺链编写异步代码的测试，这可能不如等效的Mocha测试易读。
- en: A way to make Truffle tests much more readable is to write them using `async/`
    `await`. But to do so, you must upgrade to Node.js 8 or higher.
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使Truffle测试更具可读性的一种方法是使用`async/` `await`来编写它们。但这样做，你必须将Node.js升级到8或更高版本。
- en: 'Chapter 12\. Putting it all together: Building a complete voting Dapp'
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章. 综合应用：构建一个完整的投票Dapp
- en: '|  |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Designing and implementing a voting contract showcasing most Solidity features,
    such as modifiers and events
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现一个展示Solidity大部分特性的投票合约，如修改器和事件
- en: Integrating the voting contract in Truffle, for integrated compilation, testing,
    and deployment
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Truffle中集成投票合约，进行一体化编译、测试和部署
- en: Implementing an asynchronous web UI seamlessly connected to the contract through
    the truffle-contract JavaScript library
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个通过truffle-contract JavaScript库无缝连接到合约的异步Web UI
- en: Deploying onto the public test network from Truffle
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Truffle部署到公共测试网络
- en: '|  |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the previous chapter, you started to enjoy the benefits of using Truffle
    to improve the development lifecycle:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你开始享受到使用Truffle改进开发周期的好处：
- en: Contract compilation became as easy as executing a simple `truffle compile`
    command. You didn’t have to instruct the solc compiler explicitly to push its
    output to specific files to be reused later for deployment.
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约编译变得像执行一个简单的`truffle compile`命令一样简单。你不需要明确指示solc编译器将它的输出推送到特定的文件中，以便以后用于部署。
- en: Contract deployment became much easier than you were used to, thanks to Truffle’s
    migrations functionality based on minimalistic configuration. Truffle did all
    the hard work of packaging the compilation output and feeding the contract ABI
    and bytecode to the deployment transaction behind the curtains. No more manual
    copying and pasting of long text!
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得益于Truffle基于最小化配置的迁移功能，合约部署变得比以往任何时候都要简单。Truffle在幕后做了所有艰苦的工作，包括打包编译输出，并将合约ABI和字节码提供给部署交易。不再需要手动复制和粘贴长文本！
- en: Also, testing became much simpler than when you performed it through Mocha.
    You didn’t need complicated initialization to deploy the contract at each test,
    and you could keep testing logic by writing asynchronous JavaScript based on async/await.
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，测试也比你通过Mocha执行时要简单得多。你不需要复杂的初始化来在每次测试中部署合约，并且可以基于async/await编写异步JavaScript来保持测试逻辑。
- en: I decided to introduce Truffle through `SimpleCoin` to focus exclusively on
    the functionality of the tool and avoid being distracted by the presentation of
    new concepts a new contract would have introduced. Also, by having you rewrite
    in Truffle the same `SimpleCoin` unit tests you had written in Mocha, I could
    compare more explicitly the advantages and disadvantages of one framework versus
    the other.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定通过`SimpleCoin`来介绍Truffle，以便专注于工具的功能，避免因介绍新概念而分心。另外，通过让你用Truffle重写之前在Mocha中编写的相同的`SimpleCoin`单元测试，我可以更明确地比较一个框架与另一个框架的优缺点。
- en: 'In this chapter, we’ll go one step further. Now that you’re relatively familiar
    with Truffle, I believe you’re ready to take advantage of this framework to build
    an entirely new Dapp from scratch, including a smart contract, some unit tests,
    and a web UI. We’ll start gently: I’ll give you some background on what functionality
    the voting contract should provide, and I’ll help you design and implement it.
    After you’ve completed the contract, I’ll guide you through the usual steps of
    deploying it within the development environment and unit testing it. Then I’ll
    show how you can simplify the web UI of an Ethereum Dapp by importing the ABI
    from a file generated during Truffle compilation—no more copying and pasting ABI
    and addresses here either!'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再进一步。既然你已经相对熟悉Truffle了，我相信你准备好利用这个框架从零开始构建一个全新的Dapp，包括一个智能合约、一些单元测试和一个Web
    UI。我们会从简单的开始：我会给你一些背景知识，介绍投票合约应提供哪些功能，并帮助你设计和实现它。当你完成合约后，我会引导你通过在开发环境中部署它并进行单元测试的常规步骤。然后我会展示如何通过从Truffle编译过程中生成的文件导入ABI来简化以太坊Dapp的Web
    UI——在这里也不再需要复制和粘贴ABI和地址了！
- en: This chapter is long, but I hope to keep you engaged until the end, especially
    if you’re eager to learn more. After completing this chapter, you’ll know most
    of the tool set you need to develop a Dapp from start to end. Now it’s time to
    start!
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章很长，但我希望你能一直保持兴趣直到最后，尤其是如果你渴望了解更多的话。完成这一章后，你将知道大多数从开始到结束开发Dapp所需的工具。现在开始吧！
- en: 12.1\. Defining the requirements of a voting Dapp
  id: totrans-888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 定义投票Dapp的需求
- en: 'A voting Dapp can be simple or complex, depending on the requirements of the
    elections you wish to support. Voting can be on a small number of preselected
    proposals (or candidates), or on a potentially large number of proposals suggested
    dynamically by the voters themselves. The electorate can be made up of a small
    number of individuals, all known to the organization coordinating the elections,
    or it can include all the residents of a certain administrative area or of an
    entire country. In the latter case, a registration process might be necessary
    to run the election process efficiently and transparently. The outcome might be
    decided by simple majority: the proposal that gets more votes wins. Or it might
    require a qualified majority (or quorum): a proposal is passed only if it gets
    a minimum predefined percentage of votes. The ballot can be secret or open. The
    vote can be delegated to other individuals or kept exclusively direct. This is
    only a subset of the options and variants a voting process can include. With technology,
    the voting process can become even more sophisticated. For example, a vote could
    be split by the voter into fractions, such that each is assigned to a different
    proposal, or it could be split similarly, but with each fraction delegated to
    a different individual.'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 一个投票Dapp可以是简单的，也可以是复杂的，这取决于你希望支持哪些选举的要求。投票可以是对少数预选提案（或候选人）的投票，也可以是对选民自己动态提出的潜在大量提案的投票。选民可以是少数人，全部已知于组织协调选举的组织，或者可以包括某个行政区域内或整个国家的所有居民。在后一种情况下，可能需要一个注册过程，以便高效和透明地运行选举过程。结果可能由简单多数决定：得到更多投票的提案获胜。或者它可能需要一个合格多数（或法定人数）：只有当提案获得预定义的最小百分比的投票时，才能通过。选票可以是秘密的，也可以是公开的。投票可以委托给其他个人，或者保持完全直接。这只是投票过程可以包括的选项和变体的一个子集。随着技术的发展，投票过程可以变得更加复杂。例如，选民可以将他们的投票分成几个部分，每个部分分配给不同的提案，或者可以以类似的方式进行拆分，但每部分委托给不同的人。
- en: 'You might be ambitious and try to design an ultrageneric application that could
    cater to all possibilities. For our purposes, and to keep the length of this chapter
    reasonable, I’ll constraint the voting application to a limited set of requirements:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能雄心勃勃，试图设计一个超通用的应用程序，可以满足所有可能性。为了我们的目的，并且为了使本章的长度合理，我将把投票应用程序的限制在有限的一组要求上：
- en: You’ll write the Voting Dapp within a small organization. Voters, all of whom
    the organization knows, are white-listed through their Ethereum address, can submit
    new proposals during a proposal registration session, and can vote on the proposals
    during the voting session.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将在一个小组织内编写投票Dapp。所有该组织都知道的选民，通过他们的以太坊地址白名单，可以在提案注册会议期间提交新提案，并在投票会议期间对提案进行投票。
- en: The vote isn’t secret; every voter is able to see other people’s votes.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票不是秘密的；每个选民都能够看到其他人的投票。
- en: The winner is determined by simple majority; the proposal that gets more votes
    wins.
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜者由简单多数决定；得到更多投票的提案获胜。
- en: 'As you might remember from [chapter 1](kindle_split_012.xhtml#ch01), even such
    a simple voting Dapp has a major advantage over a centralized one: a Dapp decentralizes
    vote processing and storing and consequently makes tampering much less likely
    than if voting was running through a centralized application.'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能在[第1章](kindle_split_012.xhtml#ch01)中记忆的那样，即使是这样一个简单的投票Dapp也比中心化的应用有一个主要的优势：Dapp去中心化了投票处理和存储，因此使得篡改的可能性比投票运行在中心化应用中要小得多。
- en: '[Figure 12.1](#ch12fig01) shows the workflow of the entire voting process.
    Let’s walk quickly through it:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1显示了整个投票过程的工作流程。让我们快速看一下：
- en: The voting administrator registers a *white list* of voters identified by their
    Ethereum addresses.
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员注册了一个*白名单*，其中包含通过他们的以太坊地址识别的选民。
- en: The voting administrator starts the proposal registration session.
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员开始提案注册会议。
- en: Registered voters are entitled to register their proposals while the registration
    session is active.
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册会议有效期间，注册选民有权注册他们的提案。
- en: The voting administrator ends the proposal registration session.
  id: totrans-899
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员结束提案注册会议。
- en: The voting administrator starts the voting session.
  id: totrans-900
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员开始投票会议。
- en: Registered voters cast their votes for their favorite proposals.
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册选民为他们最喜欢的提案投票。
- en: The voting administrator ends the voting session.
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员结束投票会议。
- en: The voting administrator tallies the votes.
  id: totrans-903
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票管理员计票。
- en: Anyone can check the final details of the winning proposal.
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何人都可以查看获胜提案的最终细节。
- en: Figure 12.1\. The workflow of the voting process. Some steps are performed by
    the administrator, other steps by voters.
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1。投票过程的工作流程。一些步骤由管理员执行，其他步骤由选民执行。
- en: '![](Images/fig12-01_alt.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-01_alt.jpg)'
- en: If you’re eager to develop a more generic voting Dapp, at the end of the chapter
    I’ll give you a few pointers to help you step into cutting-edge e-voting territory.
    For now, though, we’ll stick with the constraints I outlined.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您急于开发一个更通用的投票Dapp，在本章末尾，我会给您一些指导，帮助您进入尖端电子投票领域。不过，现在，我们将坚持我概述的约束条件。
- en: 12.2\. The development plan
  id: totrans-908
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2。开发计划
- en: 'Before you start to get your hands dirty, I’ll give you an idea of all the
    steps you’ll be going through to build your voting Dapp. You can get a more visual
    idea of the development cycle in [figure 12.2](#ch12fig02), but here’s a list
    of the steps:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始动手之前，我会让您了解一下您要经历的构建投票Dapp的所有步骤。您可以在[图12.2](#ch12fig02)中得到一个更直观的开发周期想法，但这里有一个步骤列表：
- en: Create a new Truffle project.
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Truffle项目。
- en: Design and implement `SimpleVoting`, the voting contract, according to the initial
    requirements.
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据初步要求设计和实现`SimpleVoting`，投票合约。
- en: Compile and deploy `SimpleVoting` on Ganache.
  id: totrans-912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ganache上编译并部署`SimpleVoting`。
- en: Write and execute unit tests for `SimpleVoting`.
  id: totrans-913
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SimpleVoting`编写并执行单元测试。
- en: Create a web UI that connects to the voting contract by reading the ABI and
    contract address from Truffle’s output.
  id: totrans-914
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个web UI，通过读取Truffle输出的ABI和合约地址连接到投票合约。
- en: Run the voting workflow through the web UI.
  id: totrans-915
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过web UI运行投票工作流。
- en: Deploy the Dapp onto a public test network.
  id: totrans-916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Dapp部署到公共测试网络。
- en: Figure 12.2\. The Dapp development plan, including all the steps, from creation
    of a Truffle project to final deployment onto a public test network
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2。Dapp开发计划，包括从创建Truffle项目到最终部署到公共测试网络的所有步骤
- en: '![](Images/fig12-02_alt.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-02_alt.jpg)'
- en: 12.3\. Starting the Truffle project
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3。启动Truffle项目
- en: 'Enough talking—it’s time to get started! Create a new directory within your
    Ethereum project folder—C:\Ethereum\truffle\SimpleVoting—then open an OS shell
    and initialize a Truffle project:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 说够了——是时候开始行动了！在你以太坊项目的目录中创建一个新的目录——C:\Ethereum\truffle\SimpleVoting——然后打开一个操作系统外壳，初始化一个Truffle项目：
- en: '[PRE111]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As usual, you should get output like that shown in the screenshot in [figure
    12.3](#ch12fig03).
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你应该得到如图12.3所示的输出。
- en: Figure 12.3\. Truffle project initialization
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.3. Truffle项目初始化
- en: '![](Images/fig12-03_alt.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-03_alt.jpg)'
- en: 'If you’re working on Windows, remember to delete truffle.js; otherwise, delete
    truffle-config.js. Initially, you’ll be deploying on Ganache, as you did in the
    previous chapter, so make sure truffle.js (or truffle-config.js) is configured
    as follows:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Windows，记得删除truffle.js；否则，删除truffle-config.js。最初，你将在Ganache上部署，正如上一章中所做的那样，所以确保truffle.js（或truffle-config.js）按照如下方式配置：
- en: '[PRE112]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now you’re ready to create the voting contract!
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备创建投票合约！
- en: 12.4\. Implementing the voting contract
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 实现投票合约
- en: I believe you could attempt to implement the contract by yourself, based on
    the requirements outlined earlier. Why don’t you give it a go and then come back
    here later?
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你可以根据之前概述的要求自己尝试实现合约。为什么不试试然后稍后回来这里呢？
- en: Are you already back? Read on. Arguably, the most important entities involved
    in an election are the proposal, the voter, and the voting workflow. Let’s look
    at how to model them.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经回来了吗？继续阅读。可以说，参与选举最重要的实体是提案、选民和投票工作流程。让我们看看如何建模它们。
- en: 12.4.1\. Modeling proposal, voter, and workflow
  id: totrans-931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1. 建模提案、选民和工作流程
- en: 'A registered voter creates a proposal and adds it dynamically to the list of
    existing proposals during a proposal registration session. The `Proposal` type
    should expose a (`string`) description that its author provides and the (`uint`)
    number of votes cast against it. You don’t want to capture the author because
    they might want to remain anonymous:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在提案注册会议期间，一个注册选民创建一个提案并将其动态添加到现有提案列表中。`Proposal`类型应该暴露出其作者提供的一个（`string`）描述和（`uint`）对其投票的数量。你不想捕获作者，因为他们可能希望保持匿名：
- en: '[PRE113]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'What data would you like to capture about a voter? How about whether the voter
    has been registered (only white-listed accounts will be allowed to vote), whether
    they’ve already voted (to prevent double voting), and, if they’ve voted, which
    proposal they’ve voted for? Try this:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 你想关于选民捕捉哪些数据？关于选民是否已注册（只允许白名单账户投票）、他们是否已经投票（以防止重复投票）以及如果他们已经投票，他们为哪个提案投票了？试试这个：
- en: '[PRE114]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You can easily represent the voting workflow I described earlier in this section
    with the following enumeration:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下枚举轻松表示我之前在这个部分描述的投票工作流程：
- en: '[PRE115]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 12.4.2\. Contract state
  id: totrans-938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2. 合约状态
- en: 'As for most contracts, you’re interested in assigning a management role to
    the Ethereum address that submits the contract deployment transaction. This will
    become (at construction) the voting administrator:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 至于大多数合约，你感兴趣的是将合约部署交易提交者的以太坊地址分配为管理角色。这将成为（在构建时）投票管理员：
- en: '[PRE116]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Two main processes take place from the start of the election: the proposal
    registration session, during which any registered voter is entitled to submit
    a proposal, and the voting session, which starts immediately afterwards. The voting
    administrator is responsible for starting and ending each session, presumably
    on the basis of an agreed start and end time. You’ll capture the status of the
    voting workflow with this state variable:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 从选举开始，主要有两个过程：提案注册会议，在此期间任何注册选民都有权提交提案，以及紧接着开始的投票会议。投票管理员负责启动和结束每个会议，假设基于商定的开始和结束时间。你将用这个状态变量捕捉投票工作流程的状态：
- en: '[PRE117]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Obviously, the most important state of the contract has to do with voters and
    proposals:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，合约最重要的状态与选民和提案有关：
- en: 'A `Voter` mapping associates the voter address, which is their identifier,
    with the voter object:'
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`Voter`映射将选民地址（它们的标识符）与选民对象关联：
- en: '[PRE118]'
  id: totrans-945
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: A `Proposal` array captures the registered proposals
  id: totrans-946
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`Proposal`数组捕获注册的提案
- en: '[PRE119]'
  id: totrans-947
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The proposal ID’s array index implicitly represents it.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 提案ID的数组索引隐式地表示了它。
- en: 'Once votes have been tallied, you want to capture the ID of the winning proposal:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计票完成，你想捕捉获胜提案的ID：
- en: '[PRE120]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This state variable shouldn’t be exposed directly to the Dapp users because
    its value should be revealed only after votes have been tallied, through getter
    functions.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态变量不应该直接暴露给Dapp用户，因为它的值应该在投票统计后才通过getter函数揭示。
- en: 12.4.3\. Function modifiers
  id: totrans-952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3. 函数修改器
- en: You need the state variables you’ve defined to determine the identity of a function
    caller and the status of the voting workflow. As you know, you can create function
    modifiers to check the conditions under which a function should be called. You
    could create a function modifier to check if the caller is the voting administrator
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要定义的状态变量来确定函数调用者的身份和投票工作流的状态。正如你所知，你可以创建函数修改器来检查函数应该被调用的条件。你可以创建一个函数修改器来检查调用者是否是投票管理员
- en: '[PRE121]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'or they’re a registered voter:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 或者他们是注册选民：
- en: '[PRE122]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You could create other function modifiers to verify whether voters are being
    registered
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建其他函数修改器来验证投票者是否正在被注册
- en: '[PRE123]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'or whether the proposals registration session is active:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 或者提案注册会话是否处于活动状态：
- en: '[PRE124]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Similarly, you can implement modifiers to verify whether the proposals registration
    has ended (`onlyAfterProposalsRegistration`), whether the voting session is active
    (`onlyDuringVotingSession`) or has ended (`onlyAfterVotingSession`), or whether
    vote tallying has already taken place (`onlyAfterVotesTallied`). You’ll find all
    of these modifiers useful for simplifying the logic of the functions you’ll implement
    shortly.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以实现修改器来验证提案注册是否已经结束（`onlyAfterProposalsRegistration`），投票会话是否处于活动状态（`onlyDuringVotingSession`）或已经结束（`onlyAfterVotingSession`），或者投票统计是否已经完成（`onlyAfterVotesTallied`）。你会发现所有这些修改器对于简化你即将实现函数的逻辑都会很有用。
- en: 12.4.4\. Events
  id: totrans-962
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.4. 事件
- en: 'Because blockchain operations take a few seconds to complete from the moment
    they’re triggered, it’s useful from a user point of view to get notified as soon
    as their execution has taken place. Therefore, at the end of each action, the
    voting contract will publish an event that alters the state of the contract. This
    will also happen at every workflow status change so that clients, such as a UI,
    can update their screens accordingly. The contract will publish these events:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链操作从触发到完成需要几秒钟，从用户的角度来看，在执行完成后立即收到通知是有用的。因此，在每个操作结束时，投票合约将发布一个事件，改变合约的状态。这也会在每次工作流状态变更时发生，以便客户端（如UI）可以相应地更新他们的屏幕。合约将发布这些事件：
- en: '[PRE125]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 12.4.5\. Constructor
  id: totrans-965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.5. 构造函数
- en: 'At contract construction, you should identify the sender of the contract transaction
    and make them the voting administrator. You should also set the initial workflow
    status:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在合约构建时，你应该识别出合约交易的发送者并使他们成为投票管理员。你还应该设置初始的工作流状态：
- en: '[PRE126]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 12.4.6\. Functions
  id: totrans-968
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.6. 函数
- en: 'If you look back at the workflow of the voting process in [figure 12.1](#ch12fig01),
    you’ll see that the voting administrator is responsible for registering voters:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾[图12.1](#ch12fig01)中的投票过程工作流，你会看到投票管理员负责注册选民：
- en: '[PRE127]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The voting administrator is also responsible for starting and ending the proposal
    registration session (and, similarly, starting and ending the voting session):'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 投票管理员还负责开始和结束提案注册会话（以及类似地，开始和结束投票会话）：
- en: '[PRE128]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: As you can see, function modifiers you defined earlier have simplified the code
    so much that it has been reduced to only one line and the publishing of a couple
    of events.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你之前定义的函数修改器已经使代码简化到只有一行以及发布几个事件。
- en: 'While the proposal registration session is active, registered voters submit
    proposals with this function:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 当提案注册会话处于活动状态时，注册选民会使用这个函数提交提案：
- en: '[PRE129]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '***1*** **Checks if the caller is a registered user and whether the proposal
    registration session is active**'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查调用者是否是注册用户以及提案注册会话是否处于活动状态**'
- en: '***2*** **Creates the proposal and adds it to the proposals array**'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建提案并将其添加到提案数组中**'
- en: 'Also in this case, function modifiers perform the hard work of checking whether
    the caller is a registered voter and whether the proposal registration session
    is active. The logic of the function itself is minimal: it creates a new proposal
    with the provided description and adds it to the proposals array.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这个案例中，函数修改器执行了检查调用者是否是注册选民以及提案注册会话是否处于活动状态的艰苦工作。函数本身的逻辑是 minimal 的：它使用提供的描述创建一个新的提案并将其添加到提案数组中。
- en: 'Once the voting session has been started, a registered voter can cast their
    vote with this function:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了投票会议，注册选民可以使用这个函数来投票：
- en: '[PRE130]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '***1*** **Checks that the caller is a registered voter and the voting session
    is open**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查调用者是否为注册选民，且投票会议是否开放**'
- en: '***2*** **Checks that the caller hasn’t voted yet**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查调用者是否尚未投票**'
- en: '***3*** **Flags that the caller has voted and records their vote**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **标记调用者已投票并记录其投票**'
- en: '***4*** **Assigns the vote to the chosen proposal. (Note that Ethereum has
    no concurrency issue because transactions are processed sequentially on the miner’s
    EVM when a new block is being created.)**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将投票分配给选定的提案。（注意，以太坊没有并发问题，因为当创建新块时，交易是按顺序在矿工的EVM上处理的。）**'
- en: 'After the administrator has ended the voting session, they can tally the vote
    with the following function, which finds the ID of the winning proposal and assigns
    it to the corresponding state variable you defined earlier:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员结束投票会议之后，他们可以使用以下函数来统计投票，该函数找出获胜提案的ID，并将其分配给之前定义的状态变量：
- en: '[PRE131]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1*** **Verifies the administrator has called the function only after the
    voting session has ended and it hasn’t already been called**'
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **验证管理员在投票会议结束并且尚未调用此函数后才调用该函数**'
- en: '***2*** **Iterates over the proposals to find the one with the higher vote
    count**'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **遍历提案以找到投票数最多的那个**'
- en: '***3*** **Records the array index of the winning proposal so far**'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **记录到目前为止的获胜提案的数组索引**'
- en: '***4*** **Assigns the array index of the winning proposal to the corresponding
    state variable**'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将获胜提案的数组索引分配给相应的状态变量**'
- en: '***5*** **Flags votes that have been tallied**'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **标记已统计的投票**'
- en: '***6*** **Publishes the change of workflow status event**'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **发布工作流状态变更事件**'
- en: 'It’s convenient to create a set of views—read-only functions that return a
    slice of the current contract state—for consumption by UI and other clients. For
    example, during and after the proposal registration session, it would be possible
    to check the number of proposals and their descriptions with these read-only functions:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一组视图——只读函数，返回当前合约状态的一个切片，供UI和其他客户端使用，这是方便的。例如，在提案注册会议期间和之后，可以使用这些只读函数检查提案的数量和它们的描述：
- en: '[PRE132]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'After votes have been tallied, it would be possible to retrieve the final results
    (winning proposal ID, description, and vote count) through the following functions:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 投票统计完成后，可以通过以下函数检索最终结果（获胜提案的ID、描述和投票数）：
- en: '[PRE133]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Anyone should be entitled to check the winning proposal, not only the administrator
    or voters, so no modifiers should be present.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都应该有权查看获胜提案，不仅仅是管理员或选民，因此不应该有任何修改器。
- en: It’s also convenient to write other functions to check the identity of the caller.
    For example, you could write a function that checks whether an address is a registered
    voter
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 还方便编写其他函数来验证调用者的身份。例如，你可以编写一个函数来检查一个地址是否为注册选民
- en: '[PRE134]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'or the administrator:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 或者管理员：
- en: '[PRE135]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'And a view of the current voting workflow status could also be useful:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 当前投票工作流状态的视图也可能很有用：
- en: '[PRE136]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 12.4.7\. The full voting contract
  id: totrans-1004
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.7. 完整的投票合约
- en: You can see the full contract in [listing D.1](kindle_split_033.xhtml#app0D1)
    in [appendix D](kindle_split_033.xhtml#app04). I encourage you to enter it in
    Remix and play with it before placing it under Truffle.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附录D中的[列表D.1](kindle_split_033.xhtml#app0D1)中看到完整的合约。我鼓励你在将其放入Truffle之前，在Remix中输入它并对其进行测试。
- en: 12.5\. Compiling and deploying SimpleVoting
  id: totrans-1006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5. 编译并部署SimpleVoting
- en: 'Place the code in [listing D.1](kindle_split_033.xhtml#app0D1) (from the book
    website) in a file named SimpleVoting.sol in the following folder: C:\Ethereum\truffle\SimpleVoting\contracts.
    Now, go to the migrations folder: C:\Ethereum\truffle\SimpleVoting\migrations.
    Create a new file called 2_deploy_contracts.js and place in it the contents of
    the following listing, which I’ve adapted from the migration configuration you
    wrote earlier for `SimpleCoin`.'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 将网站上的[列表D.1](kindle_split_033.xhtml#app0D1)中的代码放在名为SimpleVoting.sol的文件中，该文件位于以下文件夹：C:\Ethereum\truffle\SimpleVoting\contracts。现在，前往迁移文件夹：C:\Ethereum\truffle\SimpleVoting\migrations。创建一个名为2_deploy_contracts.js的新文件，并将其内容放入以下列表中，该列表是从你之前为`SimpleCoin`编写的迁移配置改编而来的：
- en: 'Listing 12.1\. 2_deploy_contracts.js: migration configuration for SimpleVoting'
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1. 2_deploy_contracts.js：SimpleVoting的迁移配置
- en: '[PRE137]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: You can now kick the compilation
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以启动编译了
- en: '[PRE138]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'and you’ll see output similar to this:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下输出：
- en: '[PRE139]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|  |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re experiencing compilation issues, have a look at [chapter 11](kindle_split_024.xhtml#ch11),
    [section 11.2.3](kindle_split_024.xhtml#ch11lev2sec3), “Troubleshooting truffle
    compile errors.”
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到编译问题，请查看[第11章](kindle_split_024.xhtml#ch11)，[第11.2.3节](kindle_split_024.xhtml#ch11lev2sec3)，“解决truffle编译错误。”
- en: '|  |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'After a successful compilation, start up Ganache in a new OS console:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 成功编译后，在新的操作系统控制台中启动Ganache：
- en: '[PRE140]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Then go back to the OS console you were using to execute Truffle commands and
    perform a migration:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回到您用于执行Truffle命令的操作系统控制台，执行迁移：
- en: '[PRE141]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'You’ll see the following output:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE142]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 12.6\. Writing unit tests
  id: totrans-1024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. 编写单元测试
- en: By now, you should know how to write unit tests in Truffle. Bear in mind, though,
    that `SimpleVoting`’s workflow is more complex than `SimpleCoin`’s, as described
    in [section 12.1](#ch12lev1sec1). For example, actions such as registering a proposal
    or voting can happen only after the administrator has opened the related session,
    so you should aim some of your tests at verifying that these constraints are being
    respected. [Table 12.1](#ch12table01) shows a small sample of what your tests
    should cover.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该知道如何在Truffle中编写单元测试。请注意，`SimpleVoting`的工作流程比`SimpleCoin`的更复杂，如[第12.1节](#ch12lev1sec1)所述。例如，注册提案或投票等操作只能在管理员已开启相关会话后发生，因此您应该确保一些测试旨在验证这些约束是否得到尊重。
    [表 12.1](#ch12table01) 显示了您测试应覆盖的小样本。
- en: Table 12.1\. Sample of unit tests you should cover against `SimpleVoting`
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 12.1\. `SimpleVoting`的单元测试示例
- en: '| Test case |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '| 测试用例 |'
- en: '| --- |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Only the administrator can register voters. |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '| 只有管理员才能注册选民。 |'
- en: '| You aren’t allowed to register the same voter twice. |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
  zh: '| 你不能两次注册同一个选民。 |'
- en: '| Only the administrator can start the proposal registration session. |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| 只有管理员才能开始提案注册会话。 |'
- en: '| Only the administrator can end the proposal registration session, after starting
    it. |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| 只有管理员在开始提案注册会话后才能结束会话。 |'
- en: '| Only a registered voter can submit a proposal. |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| 只有注册选民才能提交提案。 |'
- en: '| A registered voter can submit a proposal only after the administrator has
    started the proposal registration session. |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '| 只有在管理员开始提案注册会话后，注册选民才能提交提案。 |'
- en: '| A registered voter can’t vote before the voting session has started. |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '| 投票会话开始前，注册选民不能投票。 |'
- en: 'Each of these test cases generally requires that you write at least a *negative
    test* that proves an exception is thrown if the underlying conditions aren’t met,
    and a *positive test* that verifies the functionality works as expected when all
    constraints have been met. As an example, if you want to test that “Only the administrator
    can end the proposal registration session, after starting it,” you should write
    these tests (with the code shown in [listing 12.2](#ch12ex02)):'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例中的每一个通常都需要您编写至少一个*负测试*，证明如果基础条件不满足，则会抛出异常，以及一个*正测试*，验证当所有约束都满足时功能是否按预期工作。例如，如果您想测试“只有在开始后，管理员才能结束提案注册会话”，您应该编写这些测试（代码如下所示：[列表
    12.2](#ch12ex02)）：
- en: A negative test that verifies an exception is thrown if a voter other than the
    administrator tries to end the proposal registration session
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负测试：验证如果除管理员以外的选民尝试结束提案注册会话，则会抛出异常。
- en: A negative test that verifies the administrator isn’t allowed to end the proposal
    registration session if it hasn’t started yet
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负测试：验证管理员如果在提案注册会话尚未开始时尝试结束会话，则会抛出异常。
- en: A positive test that verifies the administrator can successfully end the proposal
    registration session after it has started
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正测试：验证管理员在提案注册会话开始后可以成功结束会话。
- en: 'Listing 12.2\. testSimpleVoting.js: testing ending the proposal registration
    session'
  id: totrans-1040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. testSimpleVoting.js：测试结束提案注册会话
- en: '[PRE143]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '***1*** **First negative test**'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **第一个负测试**'
- en: '***2*** **If this line is reached, it means no exception has been thrown, and
    the test should fail.**'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果执行到这行代码，意味着没有异常抛出，测试应该失败。**'
- en: '***3*** **The test passes if the expected exception has been thrown.**'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果预期异常被抛出，测试通过。**'
- en: '***4*** **Second negative test**'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **第二个负测试**'
- en: '***5*** **If this line is reached, it means no exception has been thrown, and
    the test should fail.**'
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **如果执行到这行代码，意味着没有异常抛出，测试应该失败。**'
- en: '***6*** **The test passes if the expected exception has been thrown.**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **如果预期异常被抛出，测试通过。**'
- en: '***7*** **Positive test, verifying successful outcome**'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **正面测试，验证成功结果**'
- en: '***8*** **The test passes if the workflow status changes to the expected value.**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **如果工作流状态更改为期望的值，则测试通过。**'
- en: 'If you want to run these unit tests, copy the code from [listing 12.2](#ch12ex02)
    into a file called testSimpleVoting.js in the test folder: C:\Ethereum\truffle\SimpleVoting\test.
    (I recommend you use the file from the book website.) Then you can execute them
    as usual'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行这些单元测试，将[列表12.2](#ch12ex02)中的代码复制到一个名为testSimpleVoting.js的文件中，该文件位于测试文件夹内：C:\Ethereum\truffle\SimpleVoting\test。我建议你使用来自本书网站的文件。然后，你可以像往常一样执行它们。
- en: '[PRE144]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: and you’ll see familiar-looking output, as shown in the screenshot in [figure
    12.4](#ch12fig04).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到熟悉的输出，如图12.4中的屏幕截图所示。
- en: Figure 12.4\. Output of SimpleVoting unit tests on ending the proposal registration
    session
  id: totrans-1053
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4. SimpleVoting单元测试的输出，结束提案注册会话
- en: '![](Images/fig12-04_alt.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-04_alt.jpg)'
- en: 12.7\. Creating a web UI
  id: totrans-1055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7. 创建网页UI
- en: 'The voting website needs two web pages: one for the voting admin, and one for
    the voters. You’ll create the website by going through these steps:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 投票网站需要两个网页：一个用于投票管理员，一个用于选民。你将通过以下步骤创建网站：
- en: Prepare the dependencies, such as required JavaScript libraries and the smart-contract
    ABI json file.
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备所需的依赖项，例如必要的JavaScript库和智能合约ABI的json文件。
- en: Set up a web server so you can read local JSON files from your web page.
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个网络服务器，以便你可以在网页上读取本地JSON文件。
- en: Write the admin page HTML.
  id: totrans-1059
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写管理员页面HTML。
- en: Write the admin page JavaScript.
  id: totrans-1060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写管理员页面JavaScript。
- en: Write the voter page HTML.
  id: totrans-1061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写选民页面HTML。
- en: Write the voter page JavaScript.
  id: totrans-1062
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写选民页面JavaScript。
- en: Run the admin and voter web pages.
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行管理员和选民网页。
- en: 12.7.1\. Preparing the UI dependencies
  id: totrans-1064
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.1. 准备UI依赖项
- en: 'First of all, open a new OS command shell and create a new directory for the
    voting web UI, say: C:\Ethereum\SimpleVotingWebUI. In case you didn’t install
    Bower globally back in [chapter 8](kindle_split_020.xhtml#ch08), install it locally
    in this directory:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的操作系统命令提示符，并为投票网页创建一个新的目录，比如：C:\Ethereum\SimpleVotingWebUI。以防你在[第8章](kindle_split_020.xhtml#ch08)中没有全局安装Bower，在这个目录中局部安装它：
- en: '[PRE145]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now import the Web3.js and JQuery libraries into the current directory, as
    you did in [chapter 8](kindle_split_020.xhtml#ch08). This time, you’ll also install
    truffle-contract, a library that allows you to import the ABI and contract address
    seamlessly from the output of `truffle compile`:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将Web3.js和JQuery库导入当前目录，就像你在[第8章](kindle_split_020.xhtml#ch08)中做的那样。这次，你还将安装truffle-contract库，这个库可以让你从`truffle
    compile`的输出中无缝导入ABI和合约地址：
- en: '[PRE146]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'As you know, Bower will download these libraries into respective directories
    within the bower_components folder:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Bower会将这些库下载到bower_components文件夹内的相应目录中：
- en: '[PRE147]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Now you’ll be able to reference these local copies of Web3.js, jQuery, and truffle-contract
    from your JavaScript code.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将能够从你的JavaScript代码中引用这些本地副本 of Web3.js，jQuery和truffle-contract。
- en: 'To call the `SimpleVoting` contract from the web UI, you need to reference
    its ABI. Truffle generates this during contract compilation in a file called SimpleVoting.json,
    which is located in this folder: C:\Ethereum\truffle\SimpleVoting\build\contracts.
    Create a folder called contracts within your web UI directory: C:\Ethereum\SimpleVoting-WebUI\contracts.
    Now copy SimpleVoting.json into it.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 要从网页UI调用`SimpleVoting`合约，你需要引用其ABI。Truffle在合约编译期间生成这个文件，名为SimpleVoting.json，位于此文件夹：C:\Ethereum\truffle\SimpleVoting\build\contracts。在你的网页UI目录内创建一个名为contracts的文件夹：C:\Ethereum\SimpleVoting-WebUI\contracts。现在将其复制到该文件夹中。
- en: 'You might remember that when you created `SimpleCoin`’s web UI, you copied
    the ABI manually into the page JavaScript:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，当你创建`SimpleCoin`的网页UI时，你将ABI手动复制到页面JavaScript中：
- en: '[PRE148]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now you’re trying to improve the process of building a web UI, and ideally
    you’d like to import the contract ABI directly from SimpleVoting.json. But web
    browsers don’t allow you to read JSON files from your hard drive, so the following
    JavaScript will fail to execute when loaded directly from your hard drive:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你试图改进构建网页UI的过程，理想情况下，你希望直接从SimpleVoting.json中导入合约ABI。但网络浏览器不允许你从硬盘驱动器读取JSON文件，所以以下JavaScript在直接从你的硬盘驱动器加载时将无法执行：
- en: '[PRE149]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This same JavaScript will work as expected, though, if it’s served to the browser
    through a web server. Bear in mind, Dapp web UIs are served through conventional
    web servers, so you must set one up to prepare for a realistic deployment.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的JavaScript如果通过Web服务器提供给浏览器，也会按预期工作。请注意，Dapp Web UI是通过传统的Web服务器提供的，所以您必须设置一个以准备真实的部署。
- en: '|  |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you make modifications to your contract (for example, you add a new function),
    after recompiling it (with `truffle compile`) and remigrating it (with `truffle
    migrate`), you have to copy SimpleVoting.json again from Truffle’s build\contracts
    folder to your web project contracts folder. If you shut down Ganache, when you
    restart it, the deployed instance of `Simple-Voting` won’t be present, so it’s
    best to force a new clean migration with `truffle migrate --reset` and then copy
    the SimpleVoting.json file across to your web project.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对您的合约进行修改（例如，您添加了一个新函数），在重新编译它（使用`truffle compile`）并重新部署它（使用`truffle migrate`）之后，您必须再次从Truffle的build\contracts文件夹中复制SimpleVoting.json到您的Web项目合约文件夹中。如果您关闭Ganache，当您重新启动它时，`Simple-Voting`的部署实例将不存在，因此最好使用`truffle
    migrate --reset`强制进行新的干净迁移，然后将SimpleVoting.json文件复制到您的Web项目中。
- en: '|  |'
  id: totrans-1081
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.7.2\. Setting up a minimalistic web server with Node.js
  id: totrans-1082
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.2. 使用Node.js设置一个最小化的Web服务器
- en: You can easily set up a simple web server, handling only static pages including
    plain HTML and JavaScript, using Connect and ServerStatic, two Node.js packages,
    as described in the Stack Overflow article “Using Node.js as a simple web server”
    ([http://mng.bz/oNR2](http://mng.bz/oNR2)).
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地使用Connect和ServerStatic这两个Node.js包来设置一个简单的Web服务器，它只处理静态页面，包括纯HTML和JavaScript，如Stack
    Overflow文章“使用Node.js作为简单Web服务器”所述（[http://mng.bz/oNR2](http://mng.bz/oNR2)）。
- en: 'First of all, install them into your web UI directory:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将它们安装到您的Web UI目录中：
- en: '[PRE150]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, create a file called webserver.js with this code in it:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为webserver.js的文件，里面包含以下代码：
- en: '[PRE151]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Finally, start up the website:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动网站：
- en: '[PRE152]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'You should see an initialization message:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个初始化消息：
- en: '[PRE153]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You’ll now be able to browse any HTML page located in the SimpleVotingWebUI
    folder through an HTTP connection to localhost on port 8080\. For example, create
    a dummy page called `test.html` with this markup:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够通过本地主机的8080端口的HTTP连接浏览SimpleVotingWebUI文件夹中的任何HTML页面。例如，创建一个名为`test.html`的伪页面，内容如下：
- en: '[PRE154]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Then access it through your browser: http://localhost:8080/test.html.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过浏览器访问：http://localhost:8080/test.html。
- en: Now that you’ve set up a web server, you’re ready to create the SimpleVoting
    website. You’ll start from the admin page.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置了一个Web服务器，接下来要创建SimpleVoting网站。您将从管理页面开始。
- en: 12.7.3\. Writing the admin page HTML
  id: totrans-1096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.3. 编写管理页面HTML
- en: The admin web page should authenticate the user through an Ethereum address.
    Only the voting administrator address will be allowed to use the page.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 管理网页应通过以太坊地址认证用户。只允许投票管理员地址使用该页面。
- en: '|  |'
  id: totrans-1098
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When running against Ganache, any password will be valid. But when you move
    to a public test network, only the valid password associated with the administrator
    public address will be accepted to execute the contract functionality.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行在Ganache上时，任何密码都将有效。但是当您移动到公共测试网络时，只有与管理员公钥关联的有效密码将被接受以执行合约功能。
- en: '|  |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The voting administrator will use this page to
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 投票管理员将使用此页面来
- en: register voters
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册选民
- en: start and end the proposal registration session
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束提案注册会议
- en: start and end the voting session
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束投票会议
- en: tally the votes
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计票
- en: You can get an idea of the layout of this page from [figure 12.5](#ch12fig05).
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[图12.5](#ch12fig05)中了解到这个页面的布局。
- en: 'Although you can look at the entire HTML of this web page on the book website,
    and I invite you to download and experiment with it (SimpleVotingWebUI folder),
    I’ll highlight the most frequently recurring elements that you’ll find across
    both admin and voter pages:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在本书网站上查看这个网页的整个HTML，并且我鼓励您下载并对其进行实验（SimpleVotingWebUI文件夹），但我将突出显示您在管理页面和选民页面中会发现的最具重复性的元素：
- en: JavaScript include files
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript包含文件
- en: Table row showing current voting workflow status
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前投票工作流程状态的表格行
- en: Administrator address and password fields
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员地址和密码字段
- en: Input fields, such as address for voter registration
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段，如用于选民注册的地址
- en: Buttons triggering smart contract function calls
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发智能合约函数调用的按钮
- en: Feedback message cells, to show error messages that the JavaScript validating
    the input produces or the contract returns
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反馈消息单元格，以显示JavaScript验证输入产生的错误消息或合约返回的消息
- en: Figure 12.5\. The admin web page. The voting administrator will use this page
    to register voters, start and end the proposal registration session, start and
    end the voting session, and tally the votes
  id: totrans-1115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.5。管理网页。投票管理员将使用此页面注册选民、启动和结束提案注册会话、启动和结束投票会话，以及计票选票
- en: '![](Images/fig12-05_alt.jpg)'
  id: totrans-1116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-05_alt.jpg)'
- en: Javascript Includes
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Javascript Includes
- en: 'These are the JavaScript files that the admin.html page references:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是admin.html页面引用的JavaScript文件：
- en: '[PRE155]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: As you can see, the admin page references Web3.js, jQuery, and truffle-contract
    through their respective Bower download folders. For simplicity, and to avoid
    code duplication, I’ve decided to place all the JavaScript needed by the admin
    and voter web pages in a single file called simplevoting.js. I’ll present it to
    you in the next section.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，管理页面引用了Web3.js、jQuery和truffle-contract，通过它们各自的Bower下载文件夹。为了简单起见，避免代码重复，我决定将管理员和选民网页所需的全部JavaScript放在一个名为simplevoting.js的单个文件中。我将在下一节中向您展示它。
- en: Text Displaying Current Workflow Status
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示当前工作流状态的文本
- en: At the top of the page, a row displays the current status of the voting workflow;
    for example, “Registering Voters” or “Proposal Registration Session Open:”
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面顶部，一行显示投票工作流当前的状态；例如，“注册选民”或“提案注册会话开启：”
- en: '[PRE156]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This is useful from two points of view:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这从两个角度来看都是有用的：
- en: It reminds the user which processing step they’re in, so it prevents them from
    attempting incorrect operations.
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提醒用户他们处于哪个处理步骤，因此可以防止他们尝试错误的操作。
- en: From a technical point of view, the workflow description is retrieved from the
    voting contract at page load, so correct rendering confirms the contract is running
    as expected.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从技术角度来看，工作流描述在页面加载时从投票合约中获取，因此正确的渲染确认合约正在按预期运行。
- en: Administrator address and password fields
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理员地址和密码字段
- en: 'The page captures the administrator address and password through input fields:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 页面通过输入字段捕获管理员地址和密码：
- en: '[PRE157]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This input is needed to
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 此输入用于
- en: unlock the administrator account by clicking Unlock Account (If the password
    is correct, the specified account will be unlocked, and the user will be able
    to perform operations on this page for three minutes, before the account gets
    locked again.)
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击“解锁账户”解锁管理员账户（如果密码正确，指定的账户将被解锁，用户可以在三分钟后再次锁定之前在页面上执行操作。）
- en: authenticate the account as the administrator so the user is allowed to access
    the web page functionality
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证账户为管理员，以便用户被允许访问网页功能
- en: attach the address as the sender of the contract function calls associated with
    this web page, which are all restricted to the administrator account, so they
    can get authorized
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地址作为与该网页关联的合约函数调用的发送者，这些调用到管理员账户都是受限制的，这样他们才能得到授权
- en: '|  |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When connecting to Ganache, it isn’t necessary to unlock the administrator account
    to perform operations on the web page, but when you connect to the test network,
    you’ll have to do so.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到Ganache时，无需解锁管理员账户即可在页面上执行操作，但当你连接到测试网络时，你必须这样做。
- en: '|  |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Other input fields
  id: totrans-1138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他输入字段
- en: 'Input fields also capture input specific to the functionality provided by the
    page, such as the registration of voters; for example, the field for the voter
    address:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段还捕获与页面提供的功能相关的输入，例如注册选民；例如，选民地址字段：
- en: '[PRE158]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Buttons triggering smart contract function call
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 触发智能合约函数调用的按钮
- en: 'Some buttons, such as the one associated with the voter registration, trigger
    a Java-Script function (in this case `registerVoter()`), which gathers the associated
    input (in this case the voter address) and includes it in the contract call together
    with the administrator address:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些按钮，如与选民注册相关的按钮，会触发一个JavaScript函数（在这个例子中是`registerVoter()`），它收集相关的输入（在这个例子中是选民地址），并将其与管理员地址一起包含在合约调用中：
- en: '[PRE159]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Other buttons, such as the one that starts the voting session, trigger a JavaScript
    function (`startVotingSession()`) that doesn’t take any input apart from the administrator
    address before creating and submitting the related contract call:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 其他按钮，如启动投票会议的按钮，会触发一个JavaScript函数（`startVotingSession()`），在创建并提交相关合约调用之前，除了管理员地址外不接受任何输入：
- en: '[PRE160]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Feedback message cells
  id: totrans-1146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反馈消息单元格
- en: 'Next to most buttons is a cell to show error or success messages that the JavaScript
    validating the input or the contract call return:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数按钮旁边都有一个单元格，用来显示JavaScript验证输入或合约调用返回的错误或成功消息：
- en: '[PRE161]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: As I mentioned previously, you can find the full HTML of the `admin.html` page
    on the book website. I encourage you to examine the code before running it.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，你可以在书籍网站上找到`admin.html`页面的完整HTML。我鼓励你在运行代码之前检查代码。
- en: 12.7.4\. Writing the admin page JavaScript
  id: totrans-1150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**12.7.4** **编写管理员页面JavaScript**'
- en: 'Before starting this section, I’d like to make it clear I’ll be presenting
    JavaScript code based on asynchronous calls for two reasons:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这一节之前，我想清楚地说明我将介绍基于异步调用的JavaScript代码，原因有两个：
- en: It’s best practice to write asynchronous JavaScript in web applications.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web应用程序中编写异步JavaScript是最佳实践。
- en: If you want to use Web3 providers recommended from a security point of view,
    such as Mist or MetaMask, they only support asynchronous calls to an Ethereum
    contract.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要从安全角度推荐使用Web3提供商，比如Mist或MetaMask，它们只支持对以太坊合约的异步调用。
- en: '|  |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I believe that even if you aren’t familiar with asynchronous JavaScript, you
    should be able to follow this section. But if you’re struggling, I’ve also implemented
    a synchronous version of the code I’ll be presenting, which you can find on the
    book website.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信即使你不太熟悉异步JavaScript，你也应该能够理解这一部分。但是如果你遇到困难，我也实现在这里将要介绍的代码的同步版本，你可以在书籍网站上找到。
- en: '|  |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I’ll present only the JavaScript around the registration of a voter address
    by the administrator. This is an interesting use case because it requires common
    functionality needed by most administrator operations, such as JavaScript code
    that
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 我将只介绍管理员通过注册选民地址的JavaScript。这是一个有趣的用例，因为它需要大多数管理员操作所需的常用功能，比如
- en: connects to the contract on page load
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面加载时连接到合约
- en: displays the voting workflow status on page load
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面加载时显示投票工作流状态
- en: unlocks the administrator account
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁管理员账户
- en: validates user input; for example, checking whether the administrator address
    is valid or whether the operation the administrator is attempting is compatible
    with the current workflow status
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户输入；例如，检查管理员地址是否有效，或者管理员尝试的操作是否与当前工作流状态兼容。
- en: executes a contract transaction
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行合约交易
- en: handles contract events
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理合约事件
- en: Once you’ve understood this use case, you should be able to implement the rest
    of the administrator functionality by yourself. I encourage you to do so and then
    compare your code with mine from the book website. Let’s go step by step.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了这个用例，你应该能够自己实现管理员的其他功能。我鼓励你这样做，然后与你从书籍网站上找到的我提供的代码进行比较。让我们一步一步来。
- en: Connecting to the voting contract
  id: totrans-1166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接到投票合约
- en: The JavaScript code connecting the web page to the voting contract is similar
    to the code you wrote for connecting to `SimpleCoin` back in [chapter 8](kindle_split_020.xhtml#ch08).
    But, thanks to truffle-contract
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 连接网页到投票合约的JavaScript代码与你在[第8章](kindle_split_020.xhtml#ch08)中为连接到`SimpleCoin`编写的代码类似，但多亏了truffle-contract
- en: The contract ABI is read directly from SimpleVoting.json, a file that `truffle
    compile` generates, with no need of hardcoding.
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约ABI直接从`SimpleVoting.json`读取，这是一个`truffle compile`生成的文件，无需硬编码。
- en: 'The contract address isn’t hardcoded anymore, and it’s also read from Simple-Voting.json,
    specifically from its networks dictionary; a new network entry is added every
    time ganache is restarted, whereas the contract address is updated when executing
    `truffle` `migrate`:'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约地址不再硬编码，也从Simple-Voting.json中读取，特别是其网络字典部分；每次ganache重启时，都会添加一个新的网络条目，而合约地址在执行`truffle`
    `migrate`时更新：
- en: '[PRE162]'
  id: totrans-1170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '***1*** **Network entry generated at Ganache restart**'
  id: totrans-1171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **在Ganache重启时生成的网络条目**'
- en: '***2*** **Contract address updated when migrating (deploying) the contract**'
  id: totrans-1172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **在迁移（部署）合约时更新合约地址**'
- en: 'Here’s how the code looks:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE163]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '***1*** **Variable to store a reference to the deployed voting contract instance**'
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **用于存储部署投票合约实例引用的变量**'
- en: '***2*** **Reads SimpleVoting.json**'
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **读取SimpleVoting.json**'
- en: '***3*** **References SimpleVoting through truffle-contract, which imports the
    contract ABI from SimpleVoting.json**'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **通过truffle-contract引用SimpleVoting，从SimpleVoting.json导入合约ABI**'
- en: '***4*** **Sets up Web3 to point to the local Ethereum client (currently Ganache)**'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** **设置Web3指向本地以太坊客户端（目前为Ganache）**'
- en: 'As I mentioned earlier in [section 12.7.1](#ch12lev2sec8), the jQuery instruction
    to read SimpleVoting.json will fail if you try to browse on the admin.html page
    directly from disk, but it will work if you browse through the website you created
    earlier on:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第12.7.1节](#ch12lev2sec8)中提到的，试图直接从磁盘浏览admin.html页面上的jQuery指令读取SimpleVoting.json将会失败，但如果您通过之前创建的网站浏览，它将会工作：
- en: '[PRE164]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Displaying the voting workflow status
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示投票工作流状态
- en: 'The voting workflow status (“Registering Voters,” “Proposals Registration Started,”
    and so on) is displayed at page load and refreshed at each status change with
    this JavaScript function:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 投票工作流状态（“注册选民”、“提案注册开始”等）在页面加载时显示，并在每次状态改变时刷新，使用这个JavaScript函数：
- en: '[PRE165]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '***1*** **References the deployed contract**'
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引用已部署的合约**'
- en: '***2*** **Gets the workflow status ID from the contract**'
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从合约中获取工作流状态ID**'
- en: '***3*** **Determines the related status description**'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **确定相关的状态描述**'
- en: '***4*** **Binds the status description to the HTML table cell where it should
    be displayed**'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将状态描述绑定到应该显示它的HTML表格单元格上**'
- en: As you know, because the contract function `getWorkflowStatus()` is a read-only
    view, its invocation is considered a plain call and doesn’t generate a blockchain
    transaction. As a result, you don’t need to specify the caller and set other transaction
    details, such as the gas limit.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知道的，因为合约函数`getWorkflowStatus()`是一个只读视图，其调用被视为普通调用，不会生成区块链交易。因此，您不需要指定调用者，也不需要设置其他交易细节，如燃料限制。
- en: 'You’ll call the workflow status function in two places. The first one is at
    the end of the code block setting the `SimpleVoting` reference to the instance
    of the voting contract, which happens at page load:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在两个地方调用工作流状态函数。第一个是在代码块设置“SimpleVoting”引用到投票合约实例的末尾，这发生在页面加载时：
- en: '[PRE166]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The other one is in the event handler associated with the `WorkflowStatusEvent`
    event that the voting contract publishes at every status change. We’ll examine
    that later.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是在与“工作流状态事件”相关的事件处理程序中，该事件是投票合约在每次状态改变时发布的。我们稍后研究那个。
- en: Unlocking the administrator account
  id: totrans-1192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解锁管理员账户
- en: 'As you might remember, to invoke any contract function that alters contract
    state and consequently generates a blockchain transaction, you need to unlock
    the account of the caller (who becomes the transaction sender). Before performing
    any state-changing operation on this web page, such as registering a voter or
    starting the voting session by clicking on the corresponding button, you need
    to unlock the administrator account. This unlocking takes place through the following
    function:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的，要调用任何改变合约状态的合约函数，进而生成一个区块链交易，您需要解锁调用者（此时成为交易发送者）的账户。在执行这个网页上的任何改变状态的操作之前，比如通过点击相应按钮注册选民或启动投票会议，您需要解锁管理员账户。这个解锁过程是通过以下函数实现的：
- en: '[PRE167]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '***1*** **Unlocks the account for three minutes**'
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **账户解锁，持续三分钟**'
- en: 'As you might recall, I’ve registered the execution of this function to the
    click event of the Unlock Account button:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能回忆起来的，我已经将这个函数的执行注册到了“解锁账户”按钮的点击事件上：
- en: '[PRE168]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'As a result, you must click this button before performing any state-changing
    operation. But if you prefer, you can get rid of the button and call this function
    just before any contract call that generates a transaction. For example, you could
    place it just before the contract call `instance.registerVoter()` within your
    JavaScript `registerVoter()` function:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您必须在执行任何状态改变操作之前点击这个按钮。但如果您更喜欢，可以移除这个按钮，在生成交易的任何合约调用之前调用这个函数。例如，您可以在您JavaScript的`registerVoter()`函数中的合约调用`instance.registerVoter()`之前放置它：
- en: '[PRE169]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Validating user input
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: 'As for centralized applications, it’s good practice to validate user input
    before passing it to an external function call, to avoid having bad input generate
    an exception. To implement that, the first few lines of your `registerVoter()`
    JavaScript function are dedicated to capturing user input from the HTML and checking
    it:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 至于集中式应用程序，验证用户输入并在将其传递给外部函数调用之前避免不良输入产生异常是一个好习惯。为了实现这一点，您`registerVoter()` JavaScript函数的前几行用于从HTML捕获用户输入并检查它：
- en: '[PRE170]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '***1*** **Gets admin and voter addresses from the HTML**'
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从HTML中获取管理员和选民地址**'
- en: '***2*** **Checks if the specified address belongs to the administrator**'
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查指定的地址是否属于管理员**'
- en: '***3*** **Checks if the specified address belongs to a registered voter**'
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查指定的地址是否属于已注册选民**'
- en: '***4*** **Shows validation error message**'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** **显示验证错误信息**'
- en: 'As you can see, you can call some contract read-only view functions to validate
    the input you’re going to then submit to a transaction-generating function. You
    might also want to validate if the JavaScript `registerVoter()` function is being
    called during the correct workflow step (voter registration) to avoid contract-side
    exceptions you’ll receive if you attempt to register a voter when the proposal
    registration session has already started; for example:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以调用一些合约只读视图函数来验证你随后提交给交易生成函数的输入。你也可能希望验证JavaScript`registerVoter()`函数是否在工作流正确步骤（选民注册）被调用，以避免在尝试在提案注册会话已经启动时注册选民时收到合约端异常：例如：
- en: '[PRE171]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: You’ve performed substantial validation. Now you can call the contract `registerVoter()`
    with more confidence that it won’t throw an exception.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 你进行了大量的验证。现在你可以更有信心地调用合约`registerVoter()`，因为它不会抛出异常。
- en: '|  |'
  id: totrans-1210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder whether a user might be able to hack the Dapp if they can modify
    the JavaScript and bypass the validation. This would be pointless. The purpose
    of JavaScript input validation isn’t to provide a layer of security but to avoid
    unnecessary transaction costs the user will incur when their transaction is reverted
    by contract-side validation code. For example, trying to register a voter from
    a nonadministrator account by bypassing the JavaScript performing the `isAdministrator()`
    check will end in an exception being thrown by the contract-side `onlyAdministrator`
    function modifier.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果用户能够修改JavaScript并绕过验证，他们是否可能黑掉这个Dapp。这是毫无意义的。JavaScript输入验证的目的不是为了提供一个安全层，而是为了避免用户在交易被合约端验证代码撤销时产生不必要的交易费用。例如，尝试通过绕过执行`isAdministrator()`检查的JavaScript来从非管理员账户注册选民，最终会导致合约端的`onlyAdministrator`函数修饰符抛出异常。
- en: '|  |'
  id: totrans-1213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Calling a transaction generating contract function
  id: totrans-1214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用生成交易合约函数
- en: While you’re here, I’ll tell you more about JavaScript code around the execution
    of a contract transaction such as `instance.registerVoter()`. As you know, when
    calling a function that alters contract state, you’re generating a blockchain
    transaction. In this case, you must supply
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 趁你在这里，我会告诉你更多关于围绕合约交易执行的JavaScript代码，比如`instance.registerVoter()`。正如你所知，调用一个改变合约状态的函数，你正在生成一个区块链交易。在这种情况下，你必须提供
- en: the transaction sender
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易发送者
- en: transaction details, such as at least the gas limit
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易详情，如至少气体限制
- en: a callback to handle errors in case of unsuccessful completion, or results in
    case of successful completion
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功完成时回调处理错误，或在成功完成时返回结果
- en: 'You can see all these details in the `registerVoter()` call:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`registerVoter()`调用中看到所有这些细节：
- en: '[PRE172]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '***1*** **References deployed contract**'
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **引用已部署的合约**'
- en: '***2*** **Calls registerVoter function**'
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **调用registerVoter函数**'
- en: '***3*** **Specifies transaction sender and gas limit. (Generally you set it
    to the lowest amount that allows transaction completion consistently, and you
    can find the value during testing.)**'
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **指定交易发送者和气体限制。（通常你将其设置为允许交易顺利完成的最小金额，你可以在测试期间找到该值。）**'
- en: '***4*** **Handles errors from the contract call**'
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** **处理合约调用错误**'
- en: Handling contract events
  id: totrans-1225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理合约事件
- en: Before leaving this section on the JavaScript of the admin page, I’d like to
    show you how to handle workflow status change events that the contract publishes.
    This would allow you to, for example, update the current workflow status description
    at the top of the page and show registration confirmations for each voter that
    the administrator adds.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这个关于管理员页面JavaScript的部分之前，我想向你展示如何处理合约发布的工作流状态变更事件。这将允许你，例如，更新页面顶部的当前工作流状态描述，并显示管理员添加的每个选民的注册确认信息。
- en: 'First of all, you must declare a variable to reference the contract `WorkflowStatusChangeEvent`
    event type:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须声明一个变量来引用合约`WorkflowStatusChangeEvent`事件类型：
- en: '[PRE173]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You instantiate this variable at page load, after having set the reference
    to the contract:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在页面加载时实例化这个变量，在设置合约引用之后：
- en: '[PRE174]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '***1*** **References contract WorkflowStatusChangeEvent event**'
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **引用合约WorkflowStatusChangeEvent事件**'
- en: '***2*** **Registers handler with the contract event**'
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **使用合约事件注册处理器**'
- en: '***3*** **When the event is handled, invoke client-side function to refresh
    UI**'
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **处理事件时，调用客户端函数刷新UI**'
- en: 'As you can see, every time the workflow status changes, the function refreshing
    its description is invoked. The contract event that notifies a voter registration
    confirmation, `VoterRegisteredEvent()`, is handled in exactly the same way, with
    the only difference being that the UI is refreshed inline and not through a client-side
    function:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每次工作流状态改变时，都会调用刷新其描述的函数。合同事件，通知选民注册确认的`VoterRegisteredEvent()`，以完全相同的方式处理，唯一的区别是，UI是内联刷新，而不是通过客户端函数：
- en: '[PRE175]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '***1*** **Refreshes voterRegistrationMessage label**'
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **刷新voterRegistrationMessage标签**'
- en: 12.7.5\. Writing the voter page HTML
  id: totrans-1237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.5. 编写投票页面HTML
- en: 'The voter page, which you can see in [figure 12.6](#ch12fig06), shares many
    elements in common with the admin page. As I said earlier, the main purpose of
    the voter page is to register proposals and to vote on them. It’s worthwhile to
    highlight the proposal table, which is updated dynamically every time a new proposal
    is added by a voter:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图12.6](#ch12fig06)中看到的投票页面与管理员页面有很多共同之处。如我前面所说，投票页面的主要目的是注册提案并对它们进行投票。值得强调的是动态更新的提案表，每次选民添加新提案时，该表都会更新：
- en: '[PRE176]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Figure 12.6\. Screenshot of the voter page
  id: totrans-1240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6. 投票页面截图
- en: '![](Images/fig12-06_alt.jpg)'
  id: totrans-1241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-06_alt.jpg)'
- en: 12.7.6\. Writing the voter page JavaScript
  id: totrans-1242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.6. 编写投票页面JavaScript
- en: 'Let’s see how the proposal table update takes place. If you have a look at
    the `register-Proposal()` function in simplevoting.js, you’ll notice many similarities
    to `registerVoter()` that we examined earlier. The main difference is that the
    event handler associated with the event that the contract fires upon proposal
    registration, `ProposalRegisteredEvent()`, doesn’t only confirm that the registration
    has taken place by refreshing the related HTML label. In addition, it calls a
    function that generates a dynamic HTML table listing of all the proposals added
    so far:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看提案表是如何更新的。如果你查看simplevoting.js中的`register-Proposal()`函数，你会注意到它与我们在早些时候研究的`registerVoter()`有很多相似之处。主要区别是，与合同在提案注册时引发的`ProposalRegisteredEvent()`事件相关联的事件处理程序不仅通过刷新相关HTML标签来确认注册已经完成。此外，它调用一个函数，生成一个动态的HTML表格列表，列出迄今为止所有添加的提案：
- en: '[PRE177]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '***1*** **Refreshes proposal registration confirmation label**'
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **刷新提案注册确认标签**'
- en: '***2*** **Refreshes table listing all proposals registered so far**'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **刷新列出迄今为止所有注册提案的表格**'
- en: 'Here’s how the proposals table is refreshed dynamically:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是提案表动态刷新的方式：
- en: '[PRE178]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 12.7.7\. Running the admin and voter web pages
  id: totrans-1249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.7. 运行管理员和投票网页
- en: Now that you understand the code for both web pages, it’s time to run them.
    I’ll guide you through the entire voting workflow so you’ll see how the application
    works from start to end.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你理解了两个网页的代码，是时候运行它们了。我会引导你完成整个投票工作流，这样你就能看到应用程序从开始到结束是如何工作的。
- en: Preliminaries
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: preliminaries
- en: 'Before starting, make sure Ganache is running in a console. I suggest you start
    it with an instruction to redirect the output to a log file, which will come in
    handy later:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保Ganache在控制台中运行。我建议你用一个指令启动它，将输出重定向到日志文件，这将在后面派上用场：
- en: '[PRE179]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Because you’ve restarted Ganache, you must redeploy `SimpleVoting` (in a separate
    console):'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你重新启动了Ganache，你必须重新部署`SimpleVoting`（在另一个控制台）：
- en: '[PRE180]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Next, recopy SimpleVoting.json from Truffle’s build\contracts folder to the
    website’s contracts folder. Now you can restart the website (in a separate console):'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将SimpleVoting.json从Truffle的build\contracts文件夹复制到网站的contracts文件夹。现在你可以重新启动网站（在另一个控制台）：
- en: '[PRE181]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Registering voters
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册选民
- en: Browse the admin webpage
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览管理员网页
- en: '[PRE182]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: and you’ll see the screen I showed you earlier in [figure 12.5](#ch12fig05).
    You might have noticed that the initial current status is “Registering Voters,”
    as expected, as you can see in [figure 12.7](#ch12fig07).
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我之前给你看的[图12.5](#ch12fig05)中的屏幕。你可能会注意到初始当前状态是“注册选民”，如预期的那样，正如你在[图12.7](#ch12fig07)中看到的：
- en: Figure 12.7\. The initial workflow status shown on the admin web page at startup
  id: totrans-1262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7. 在启动时管理员网页上显示的初始工作流状态
- en: '![](Images/fig12-07_alt.jpg)'
  id: totrans-1263
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-07_alt.jpg)'
- en: 'Unless your truffle.js is configured to run the migrations from a specific
    account, they’ll be executed against `accounts[0]`, which, as you know, will become
    the voting administrator. Because you’re deploying on Ganache, look at the `ganache.log`
    file you’re redirecting the output to:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的truffle.js配置为从特定账户运行迁移，否则它们将对`accounts[0]`执行，你知道，这将成为投票管理员。因为你在Ganache上部署，查看你重定向输出的`ganache.log`文件：
- en: '[PRE183]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Copy the address corresponding to account (0) into the Admin Address text box
    and, because you’re running against Ganache, leave the password field empty, as
    shown in [figure 12.8](#ch12fig08). You can then register the voters’ addresses.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 将与账户（0）对应的地址复制到管理员地址文本框中，因为你正在对Ganache进行操作，所以将密码字段留空，如图12.8所示[#ch12fig08]。然后你可以注册选民地址。
- en: Figure 12.8\. Copying the administrator’s account into the corresponding text
    box
  id: totrans-1267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.8. 将管理员账户复制到相应的文本框中
- en: '![](Images/fig12-08_alt.jpg)'
  id: totrans-1268
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-08_alt.jpg)'
- en: Because shortly you’ll be running some voter functionality, I suggest you register
    (1), (2), (3), ... from Ganache’s startup screen as voters. When registering account
    (1), you enter the corresponding address in the Voter Address text box, as shown
    in [figure 12.9](#ch12fig09).
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 因为很快你将运行一些选民功能，我建议你从Ganache的启动屏幕上以选民的身份注册（1）、（2）、（3）...。在注册账户（1）时，你需要在选民地址文本框中输入相应的地址，如图12.9所示[#ch12fig09]。
- en: Figure 12.9\. Entering the voter address
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.9. 输入选民地址
- en: '![](Images/fig12-09_alt.jpg)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-09_alt.jpg)'
- en: Before submitting the voter registration transaction, you must unlock the admin
    account, so click Unlock Account. You’ll get a confirmation that the account has
    been unlocked. Then click Register. If everything has gone well, you should get
    a confirmation message next to the Register button; otherwise, you’ll get an error
    message.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交选民注册交易之前，你必须解锁管理员账户，所以点击“解锁账户”。你会得到一个账户已解锁的确认信息。然后点击“注册”。如果一切顺利，你应该在“注册”按钮旁边看到一个确认信息；否则，你会看到一个错误信息。
- en: Register a few voters using the other account addresses from Ganache’s log file.
    If you do so within the next three minutes, you don’t need to unlock the administrator
    account again before registering the accounts.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ganache日志文件中的其他账户地址注册几个选民。如果你在接下来的三分钟内这样做，你不需要在注册账户之前再次解锁管理员账户。
- en: '|  |'
  id: totrans-1274
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As I said earlier, when running on Ganache, you don’t need to enter any administrator
    password, and you don’t even need to unlock the corresponding account, as accounts
    are all indefinitely unlocked. But it’s best to get used to the account unlock
    operation for a smoother transition to the public test network later.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 如我前面所说，当在Ganache上运行时，你不需要输入任何管理员密码，甚至不需要解锁相应的账户，因为所有账户都是无限期解锁的。但为了以后更顺利地过渡到公共测试网络，最好习惯账户解锁操作。
- en: '|  |'
  id: totrans-1277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you want to verify that these accounts are indeed registered, you can use
    the Check Registration verification area. For example, to verify that account
    (1) is a registered voter, enter the corresponding address in the Address text
    box and click Check Registration. You should see a confirmation message like the
    one shown in [figure 12.10](#ch12fig10).
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想验证这些账户确实已注册，你可以使用检查注册验证区域。例如，为了验证账户（1）是否是注册选民，请在地址文本框中输入相应的地址并点击检查注册。你应该看到图12.10中显示的类似确认信息。
- en: Figure 12.10\. Checking whether an account has been registered as a voter
  id: totrans-1279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.10. 检查账户是否已注册为选民
- en: '![](Images/fig12-10_alt.jpg)'
  id: totrans-1280
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-10_alt.jpg)'
- en: Before we move to the next workflow step, I suggest you see what happens if
    you try to
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转移到下一个工作流程步骤之前，我建议你看看如果你尝试去
- en: register a voter by specifying in the admin address text box a different account;
    for example, account (4)
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管理员地址文本框中指定一个不同的账户来注册一个选民；例如，账户（4）
- en: perform an operation that shouldn’t happen at this stage; for example, you click
    the Tally votes button
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个在这个阶段不应该发生的操作；例如，你点击“计票”按钮
- en: You should receive corresponding error messages.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到相应的错误信息。
- en: Starting the proposal registration session
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动提案注册会话
- en: Once you’ve registered a few voters, you can start the proposal registration
    session by clicking Start in the related area of the screen. This will call the
    JavaScript `start-Proposals-Registration()` function, which in turn will call
    the `start-Proposals-Registration()` contract function. The contract function
    will raise the `WorkflowStatusChangeEvent` event, which the client-side JavaScript
    `refreshWorkflow-Status()` function that’s in charge of refreshing the workflow
    status label to “Proposals Registration Started” will handle, as you can see in
    [figure 12.11](#ch12fig11).
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你注册了一些选民，可以通过点击屏幕相关区域的“开始”来启动提案注册会话。这将调用JavaScript `start-Proposals-Registration()`函数，该函数又会调用`start-Proposals-Registration()`合约函数。合约函数将引发`WorkflowStatusChangeEvent`事件，负责刷新工作流状态标签到“提案注册开始”的客户端JavaScript
    `refreshWorkflow-Status()`函数将处理该事件，如图[12.11](#ch12fig11)所示。
- en: Figure 12.11\. After you start the proposals registration session, the Current
    Status label will be refreshed with the corresponding status description.
  id: totrans-1287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.11. 当你启动提案注册会话后，当前状态标签将被刷新相应的状态描述。
- en: '![](Images/fig12-11_alt.jpg)'
  id: totrans-1288
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-11_alt.jpg)'
- en: Registering proposals
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册提案
- en: 'At this point, voters are allowed to register proposals. Open the voter web
    page in a separate browser tab: http://localhost:8080/voter.html.'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，选民被允许注册提案。在另一个浏览器标签中打开选民网页：http://localhost:8080/voter.html。
- en: 'You’ll see a screen similar to the one shown in [figure 12.6](#ch12fig06),
    with a small difference: the current status will be “Proposals Registration Started”
    as on the Admin page. This confirms the page is connected correctly to the voting
    contract.'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个类似于图[12.6](#ch12fig06)的屏幕，有一个小区别：当前状态将是“提案注册开始”，如图管理员页面所示。这确认页面正确连接到投票合约。
- en: Now register a proposal under Ganache’s account (1), who is a valid registered
    user. Enter the corresponding address in the Voter Address text box, and leave
    the password blank, as you did for the administrator. Then enter a proposal description,
    for example, “Proposal Zero.” If you want, before clicking Register, you can check
    what happens if you submit a vote at this stage (say against proposal ID = 0).
    You should get an error message.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Ganache账户（1）下注册一个提案，该账户是一个有效的注册用户。在选民地址文本框中输入相应的地址，留密码空白，就像对管理员一样。然后输入一个提案描述，例如，“提案零”。如果你想在点击注册之前，可以检查如果你在这个阶段提交一个反对提案ID
    = 0的投票会发生什么。你应该会收到一个错误信息。
- en: Now click Register. You’ll get a confirmation message next to the button. You’ll
    also see at the top of the screen the proposal you’ve entered together with the
    related ID, returned from the contract, as shown in [figure 12.12](#ch12fig12).
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击注册。你会在按钮旁边得到一个确认信息。你也会在屏幕顶部看到你输入的提案及其相关ID，从合约返回，如图[12.12](#ch12fig12)所示。
- en: Keep registering more proposals, using all the accounts you’ve registered as
    voters. If you want, you can register more than one proposal against the same
    account, as you didn’t set any constraints on this. You can also check what happens
    if you try to register a proposal against the administrator account or against
    some account that you didn’t register as a user.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 继续注册更多提案，使用你注册的所有选民账户。如果你愿意，你可以针对同一个账户注册多个提案，因为你没有对此设置任何限制。你也可以尝试注册一个针对管理员账户或者你没有作为用户注册的某个账户的提案，看看会发生什么。
- en: Figure 12.12\. Registering a new proposal
  id: totrans-1295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.12. 注册新提案
- en: '![](Images/fig12-12_alt.jpg)'
  id: totrans-1296
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-12_alt.jpg)'
- en: Ending the proposal registration session
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结束提案注册会话
- en: After registering a few proposals, you can end the proposal registration session.
    Go back to the admin page and, if the administrator account address is still in
    the related text box, click End in the Proposal Registration Session area. You
    should get a confirmation message next to the button and the new workflow status
    in the Current Status area, as shown in [figure 12.13](#ch12fig13).
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 注册几个提案后，你可以结束提案注册会话。回到管理页面，如果管理员账户地址仍然在相关文本框中，点击提案注册会话区域内的“结束”。你会在按钮旁边和一个新工作流状态在当前状态区域看到一个确认信息，如图[12.13](#ch12fig13)所示。
- en: Figure 12.13\. Ending the proposal registration session
  id: totrans-1299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.13. 结束提案注册会话
- en: '![](Images/fig12-13_alt.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-13_alt.jpg)'
- en: As usual, you can try to attempt actions that aren’t supposed to take place
    at this stage. For example, try ending the voting session.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以尝试进行在这个阶段不应该发生的动作。例如，尝试结束投票会话。
- en: Starting the Voting session
  id: totrans-1302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开始投票会话
- en: Time to start the voting session! Click Start corresponding to the voting session,
    and the Current Status description at the top of the screen will change accordingly
    to “Voting Session Started.”
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 开始投票会话的时刻到了！点击相应的投票会话旁边的开始，屏幕顶部的当前状态描述将相应地更改为“投票会话已开始。”
- en: Voting
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 投票
- en: Go back to the voter’s screen. You’ll see that the status at the top of the
    screen has also changed to “Voting Session Started.” This confirms that it has
    been refreshed by the `WorkflowStatusChangeEvent` event that the contract published
    at the end of the `startVotingSession()` function and the voter’s page JavaScript
    handled. At this point, you’re allowed to vote.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 回到选民屏幕。您会看到屏幕顶部的状态也已更改为“投票会话已开始。”这证实了它已经被`WorkflowStatusChangeEvent`事件刷新，该事件在`startVotingSession()`函数的末尾由合约发布，并且选民页面的JavaScript进行了处理。在此阶段，您允许投票。
- en: Enter the address of one of the voter accounts in the Voter Address text box,
    and then put one of the Proposal IDs you see at the top of the screen in the Proposal
    ID text box. Then click Vote. You’ll see a confirmation message next to the Vote
    button. If you try to vote again, you’ll see an exception from the voting contract
    that’s preventing you from voting twice. Continue by casting various votes from
    the accounts you registered earlier.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 在选民地址文本框中输入一个选民账户的地址，然后在屏幕顶部的提案ID中选择一个，放入提案ID文本框中。然后点击投票。您会在投票按钮旁边看到一个确认信息。如果您再次尝试投票，您将看到投票合约阻止您重复投票的异常。继续通过您之前注册的账户进行各种投票。
- en: Ending the voting session
  id: totrans-1307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结束投票会话
- en: 'After you’ve voted from various registered accounts, you can end the voting
    session the same way you started it: go back to the admin page, move the mouse
    in the Voting Registration area, and click End. As usual, you’ll see a confirmation
    message and a change of state at the top of the screen. If you now try to go back
    to the voter page and cast a vote through a registered account that you didn’t
    use, you’ll be prevented from voting.'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 在您从不同的注册账户中完成投票后，您可以像开始时那样结束投票会话：回到管理页面，将鼠标悬停在投票注册区域，然后点击结束。和往常一样，您会在屏幕顶部看到一个确认信息和状态改变。如果您现在试图回到选民页面，并通过一个您没有使用的注册账户投票，您将无法投票。
- en: Tallying the votes
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 统计选票
- en: 'It’s the moment of truth: time to tally the votes! On the admin page, click
    Tally Votes. Apart from the usual confirmation message and status description
    stage, you’ll see a new table appearing at the bottom of the screen summarizing
    the vote results. The handler of the `WorkflowStatusChangeEvent` event has generated
    this table, with a specific check on the status ID corresponding to votes tallied.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真相大白的时候：是时候统计选票了！在管理页面，点击统计选票。除了常规的确认信息和状态描述阶段，您会在屏幕底部看到一个新的表格出现，总结投票结果。`WorkflowStatusChangeEvent`事件的处理者生成了这个表格，并对投票统计的状态ID进行了特定的检查。
- en: If you flip back to the voter page, you’ll see the same results table at the
    bottom of the screen, as you can verify in [figure 12.14](#ch12fig14). The same
    table appears because both pages were listening to the same event.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到选民页面，您会在屏幕底部看到相同的结果表格，正如您在[图12.14](#ch12fig14)中可以验证的那样。因为两个页面都在监听同一个事件，所以会出现相同的表格。
- en: Figure 12.14\. The voter page after the votes have been tallied
  id: totrans-1312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.14。投票统计后的选民页面
- en: '![](Images/fig12-14_alt.jpg)'
  id: totrans-1313
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig12-14_alt.jpg)'
- en: Congratulations! You’ve designed, implemented, tested, and run a full voting
    Dapp. You should consider this an important achievement. It’s the first time (in
    the book) you’ve built a complete Dapp from scratch, covering all the layers from
    the smart contract to the web UI. You’ve come a long way from [chapter 1](kindle_split_012.xhtml#ch01),
    when you started to learn about new concepts, such as blockchain and Dapp, and
    experimented with a simple embryonic version of SimpleCoin. Now you should have
    a good understanding of smart contracts, how to write them in Solidity, how to
    communicate with them with Web3.js, and how to create a simple web UI to interact
    with them in an easier way. Before leaving the chapter, you’ll deploy the Dapp
    into the public test network and check that everything is still working as expected.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经设计、实现、测试并运行了一个完整的投票 Dapp。你应该认为这是一个重要的成就。这是你在本书中第一次从零开始构建完整的 Dapp，涵盖了从智能合约到
    web UI 的所有层次。从[第 1 章](kindle_split_012.xhtml#ch01)开始，当你开始学习区块链和 Dapp 等新概念，并尝试使用
    SimpleCoin 的简单胚胎版本进行实验，你已经走了一段很长的路。现在你应该对智能合约有了很好的理解，知道如何用 Solidity 编写它们，如何用 Web3.js
    与它们通信，以及如何创建一个简单的 web UI 以更轻松地与它们交互。在离开这一章之前，你将在公共测试网络上部署 Dapp 并检查一切是否如预期工作。
- en: 12.7.8\. Deploying to the public network
  id: totrans-1315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.8. 部署到公共网络
- en: 'Here are the steps you must take to deploy SimpleVoting onto Ropsten, the public
    test network:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将 SimpleVoting 部署到公共测试网络 Ropsten 的步骤：
- en: Stop Ganache.
  id: totrans-1317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止 Ganache。
- en: Start geth, configured to point to Ropsten.
  id: totrans-1318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动配置为指向 Ropsten 的 geth。
- en: Configure Truffle to point to the Ropsten network and deploy from one of your
    Ropsten accounts.
  id: totrans-1319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Truffle 以指向 Ropsten 网络，并从你的一个 Ropsten 账户部署。
- en: Unlock the Ropsten account you’ll use for deployment.
  id: totrans-1320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解锁你将用于部署的 Ropsten 账户。
- en: Perform a Truffle migration to Ropsten.
  id: totrans-1321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 Truffle 迁移到 Ropsten。
- en: Check that the UI still works correctly.
  id: totrans-1322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 UI 是否仍然正确工作。
- en: Stopping Ganache
  id: totrans-1323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 停止 Ganache
- en: 'You should be able to do everything pretty much by yourself but, just in case,
    let me walk through these steps with you. Start with an easy one: press CTRL+C
    or close down the Ganache window.'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够自己完成大部分工作，但以防万一，让我带你一步步完成这些步骤。从简单的一个开始：按下 CTRL+C 或关闭 Ganache 窗口。
- en: Starting geth on Ropsten
  id: totrans-1325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动 Ropsten 上的 geth
- en: 'You’ve done this a couple of times already, but I’ll save you some page flipping.
    You can see in the following code the full command to connect to Ropsten through
    some seed nodes, including the option to perform a fast synchronization, in case
    you haven’t been connected to the test network for a while. Also, I’ve highlighted
    the last two parameters, which open geth’s communication through RPC on port 8545
    and allow cross-origin resource sharing (CORS) so that the JavaScript of your
    web page will be allowed to communicate directly with geth:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经做过几次了，但我可以节省你一些翻页时间。你可以在下面的代码中看到完整的命令，通过一些种子节点连接到 Ropsten，包括执行快速同步的选项，以防你有一段时间没有连接到测试网络。此外，我突出了最后两个参数，它们使
    geth 通过 RPC 在端口 8545 上进行通信，并允许跨源资源共享（CORS），以便你的网页的 JavaScript 可以直接与 geth 通信：
- en: '[PRE184]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '|  |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If your geth client doesn’t seem to synchronize with the public test network,
    attach a console to geth and manually add the Ropsten peers specified on this
    GitHub page: [http://mng.bz/6jAZ](http://mng.bz/6jAZ).'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 geth 客户端似乎没有与公共测试网络同步，将控制台连接到 geth 并手动添加此 GitHub 页面上指定的 Ropsten 对等节点：[http://mng.bz/6jAZ](http://mng.bz/6jAZ)。
- en: '|  |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Configuring Truffle to point to Ropsten
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 Truffle 以指向 Ropsten
- en: 'In the previous chapter, I explained how to point Truffle to a test or live
    network. Modify your truffle.js (or truffle-config.js) file as follows:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我解释了如何让 Truffle 指向测试或主网络。按照以下方式修改你的 truffle.js（或 truffle-config.js）文件：
- en: '[PRE185]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '***1*** **Matches the port open on geth for RPC communication (as noted previously)**'
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **与 geth 打开的用于 RPC 通信的端口相匹配（如前所述）**'
- en: '***2*** **Replace this account with the Ropsten account you want to use to
    deploy.**'
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **用你想要用于部署的 Ropsten 账户替换这个账户。**'
- en: '***3*** **This should be enough gas to deploy SimpleVoting.**'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **这应该足够的燃料来部署 SimpleVoting。**'
- en: Make sure the Ropsten account you choose to deploy SimpleVoting has some (test)
    Ether in it!
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你选择用于部署 SimpleVoting 的 Ropsten 账户里有一些（测试）以太币！
- en: Unlocking the account used for deployment
  id: totrans-1339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解锁用于部署的账户
- en: 'To unlock the Ropsten account you’ve specified for deployment, start by opening
    a new console and attaching it to geth:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 要解锁你为部署指定的 Ropsten 账户，首先打开一个新的控制台并将其连接到 geth：
- en: '[PRE186]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Once the geth JavaScript console has started, unlock the deployer address (for
    300 seconds) as follows:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了 geth JavaScript 控制台，以下方式解锁部署者地址（300 秒内有效）：
- en: '[PRE187]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Performing a Truffle migration to Ropsten
  id: totrans-1344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行一个 Truffle 迁移到 Ropsten
- en: 'To perform a migration on a network other than the development one, you must
    provide it explicitly through the `--network` option (on a separate console):'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 要在除开发网络之外的其他网络上执行迁移，你必须通过 `--network` 选项显式提供它（在一个单独的控制台中）：
- en: '[PRE188]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '|  |'
  id: totrans-1347
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: Warning
  id: totrans-1348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Make sure your geth client is fully synchronized with Ropsten before attempting
    this operation. You can check the latest Ropsten block against [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/)
    and compare it with what you see on your client’s console.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试进行此操作之前，请确保你的 geth 客户端已与 Ropsten 完全同步。你可以通过与 [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/)
    上的最新 Ropsten 区块进行对比，查看客户端控制台显示的内容。
- en: '|  |'
  id: totrans-1350
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: 'If your geth client is actively connected to Ropsten and you’ve configured
    everything correctly, you should see some output confirming that deployment has
    taken place:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 geth 客户端正在积极连接到 Ropsten，并且你已经正确配置了所有内容，你应该会看到一些输出，确认部署已经完成：
- en: '[PRE189]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Checking the UI still works
  id: totrans-1353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查 UI 仍然可以工作
- en: 'If you look back at the first lines of simplevoting.js, the initialization
    looks at a `web3` provider coming from `localhost:8545`. Geth is exposing to RPC
    the same port number that Ganache was previously exposing, so everything should
    still work, right? Let’s find out! First of all, copy the new SimpleVoting.json
    from Truffle’s build\contracts to the website contracts folder. Then try to browse
    on admin.html as you did previously. (Make sure the website is still running;
    otherwise, restart it with: `node webserver.js`.) Type the following:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下 simplevoting.js 的第一行代码，初始化部分查看的是来自 `localhost:8545` 的 `web3` 提供者。Geth
    暴露的 RPC 端口号码与之前 Ganache 暴露的相同，所以一切应该还是照常工作，对吧？我们一起来看看！首先，将 Truffle 构建后的 SimpleVoting.json
    文件复制到网站的 contracts 文件夹中。然后尝试像之前一样浏览 admin.html。（确保网站仍在运行；否则，使用：`node webserver.js`
    重启它。）输入以下内容：
- en: '[PRE190]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Yes! The page loads correctly, and it shows the initial “Registering Voters”
    status as expected. You can now go through the whole workflow, from voters’ registration
    to vote tallying, as you did when running on Ganache. Before doing so, make sure
    the TESTNET admin and voter accounts have enough Ether to perform the related
    operations.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！页面正确加载，并显示了预期的“注册选民”初始状态。现在你可以完成整个工作流程，从选民注册到投票计数，就像在 Ganache 上运行时一样。在这样做之前，确保
    TESTNET 管理员和选民账户有足够的以太币来执行相关操作。
- en: '|  |'
  id: totrans-1357
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: Note
  id: totrans-1358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Bear in mind that when you perform operations on TESTNET, you must unlock the
    related account at each operation. Also, every time you perform an operation,
    from either the admin account or a voter account, you’ll have to wait for the
    related transaction to be mined, so it will take longer (around 15 seconds) to
    receive confirmations.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你在 TESTNET 上进行操作时，你必须在每个操作中解锁相关的账户。另外，无论你是以管理员账户还是选民账户进行操作，你都需要等待相关交易被挖掘，所以确认需要更长的时间（大约
    15 秒）。
- en: '|  |'
  id: totrans-1360
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: '|  |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: Warning
  id: totrans-1362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If your UI seems unresponsive and you don’t get a confirmation that the operation
    you attempted completed, check potential errors on the console of your browser’s
    development tools. For example, on Chrome, you can click F12 and then select Console
    from the top menu. If the issue is related to account unlocking, it might be due
    to changes in Web3 around this area. If that’s the case, you can unlock the administrator
    or the voter account from an attached Geth console, as you’ve seen in previous
    chapters, rather than using the Unlock Account button.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 UI 似乎没有响应，并且你没有收到你所尝试操作完成的确认，请在浏览器的开发工具的控制台中检查可能的错误。例如，在 Chrome 上，你可以点击
    F12 然后从顶部菜单选择控制台。如果问题与账户解锁有关，可能是由于 Web3 在这一领域的更改。如果是这种情况，你可以从附加的 Geth 控制台解锁管理员或选民账户，正如你在前面的章节中看到的那样，而不是使用解锁账户按钮。
- en: '|  |'
  id: totrans-1364
  prefs: []
  type: TYPE_TB
  zh: ├───|
- en: 12.8\. Food for thought
  id: totrans-1365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8. 思考题
- en: 'I hope you’ve found this chapter useful for tying together all you learned
    in the previous chapters. At this point, you should feel confident you can start
    building your own Dapp, and you should be geared up to take on a new challenge.
    If you’re eager to practice your newly acquired skills a little more before moving
    on to the next chapter on advanced topics in contract design and security, I’ve
    prepared for you a little plan you can use as a springboard for improving SimpleVoting.
    I have two sets of improvements in mind:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您觉得这一章对于将您在前几章中学到的所有内容联系起来很有用。至此，您应该感到自信，可以开始构建您自己的Dapp，并且您应该已经准备好迎接新的挑战。如果您渴望在继续学习智能合约设计和安全的先进主题之前，再稍微练习一下您新获得的技能，我已经为您准备了一个小计划，您可以使用它作为改进SimpleVoting的跳板。我考虑了两个改进集：
- en: Technical improvements
  id: totrans-1367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术改进
- en: Functional improvements
  id: totrans-1368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性改进
- en: 12.8.1\. Possible technical improvements
  id: totrans-1369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.1\. 可能的技术改进
- en: 'I designed SimpleVoting with the main objective of presenting the full Ethereum
    Dapp development lifecycle in one shot, so I decided to keep it as simple as possible
    to focus mainly on the big picture. Also, I understand that not all readers have
    the same background and experience in web development and continuous integration,
    so I avoided introducing relatively advanced techniques in either of these areas.
    If you’d like to improve the web UI, there’s room for improvement in various respects,
    including these two:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计SimpleVoting的主要目标是一次性展示完整的Ethereum Dapp开发生命周期，因此我决定尽可能简化它，以便主要关注大局。此外，我理解并非所有读者在网页开发和持续集成方面都有相同的背景和经验，因此我在这两个领域避免了引入相对先进的技术。如果您想要改进网页用户界面，有很多方面可以改进，包括这两个方面：
- en: Using a standard Web3 provider
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的Web3提供商
- en: Automating build and deployment with a web build tool
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网页构建工具自动化构建和部署
- en: Using a standard Web3 provider
  id: totrans-1373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用标准Web3提供商
- en: Your application shouldn’t be served through a plain web browser, but through
    a standard Web3 provider, such as Mist or MetaMask, that provides enhanced security.
    These providers require you to call contract functions asynchronously, though,
    so reimplementing your SimpleVoting.js using asynchronous features would also
    be beneficial for this reason. After you’ve reimplemented your JavaScript code
    accordingly, you can detect a standard provider by replacing this line
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序不应该通过普通的网络浏览器提供服务，而应该通过提供增强安全性的标准Web3提供商（如Mist或MetaMask）提供服务。这些提供商要求您异步调用合约函数，因此，重新实现您的SimpleVoting.js以使用异步特性也将为此目的带来好处。在您相应地重新实现JavaScript代码之后，您可以通过替换这一行来检测标准提供商：
- en: '[PRE191]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'with this:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为：
- en: '[PRE192]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '***1*** **Uses standard provider (such as Metamask or Mist) if available**'
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **如果可用，则使用标准提供商（如MetaMask或Mist）**'
- en: '***2*** **Instantiates default provider if none is available**'
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **如果无可用提供商，则实例化默认提供商**'
- en: How do you supply a standard provider? First, remember to log in. Then, assuming
    you installed the MetaMask browser plugin, as explained in [chapter 3](kindle_split_014.xhtml#ch03),
    make my suggested code change at the top of SimpleVoting.js, and finally browse
    on the admin or voter page. By doing this, the Web3 provider will be set to MetaMask.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何提供一个标准提供商？首先，记得登录。然后，假设您按照第3章中解释的方式安装了MetaMask浏览器插件[chapter 3](kindle_split_014.xhtml#ch03)，在SimpleVoting.js的顶部做出我建议的代码更改，最后在管理或选民页面上浏览。通过这样做，Web3提供商将被设置为MetaMask。
- en: Automating build and deployment with a web build tool
  id: totrans-1381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用网页构建工具自动化构建和部署
- en: If you have experience in using web build tools, you might have found it a bit
    annoying to copy SimpleVoting.json from Truffle’s build\contracts to the web project
    contracts folder every time you made a change. You might be wondering whether
    Truffle supports a build pipeline. It does, and, in fact, you can plug in your
    favorite build tool, such as Webpack or Grunt.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用网页构建工具的经验，您可能会发现每次更改后都要从Truffle的build\contracts中复制SimpleVoting.json到网页项目contracts文件夹中有点烦人。您可能会想知道Truffle是否支持构建管道。它确实支持，实际上，您可以将您喜欢的构建工具（如Webpack或Grunt）插入其中。
- en: The Truffle documentation website also includes a Webpack Truffle Box ([https://truffleframework.com/boxes/webpack](https://truffleframework.com/boxes/webpack)),
    which is a template project developed with Webpack support. You can use it as
    a base to build your Webpack integration, or at least to understand how it works.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle文档网站还包括一个Webpack Truffle Box([https://truffleframework.com/boxes/webpack](https://truffleframework.com/boxes/webpack))，这是一个使用Webpack支持开发的模板项目。您可以使用它作为构建Webpack集成的起点，或者至少了解它是如何工作的。
- en: 12.8.2\. Possible functional improvements
  id: totrans-1384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.2\. 可能的功能性改进
- en: 'The current voting application is intentionally limited from a functional point
    of view. After the admin registers the voters (one by one), voters can register
    (potentially many) proposals and then vote on one of them. The winning proposal
    is decided based on simple majority: the one that gets the most votes is chosen.
    Also, you’re recording the proposal that each voter chooses, so there’s no anonymity.
    Here are some ways you could enrich the voting Dapp functionality:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的投票应用程序在功能上是有意限制的。在管理员注册选民（一个接一个）之后，选民可以注册（可能很多）提案，然后对其中一个进行投票。获胜提案是基于简单多数决定的：得到最多票数的那个提案。此外，你记录了每个选民选择的提案，所以没有匿名性。以下是一些可以丰富投票Dapp功能性的方法：
- en: Allow the admin to register voters in bulk.
  id: totrans-1386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许管理员批量注册选民。
- en: Allow a voter to delegate their vote to another registered voter.
  id: totrans-1387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许选民将他们的投票权委托给另一个已注册选民。
- en: Decide the winning proposal with a qualified majority.
  id: totrans-1388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用合格多数决定获胜提案。
- en: Implement token-based voting.
  id: totrans-1389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于代币的投票。
- en: Implement anonymous voting.
  id: totrans-1390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无记名投票。
- en: Registering voters in bulk
  id: totrans-1391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 批量注册选民
- en: The admin could register voters in a single bulk registration, rather than one
    by one, saving on administrative time and transaction costs. You could implement
    this enhancement with a new function taking in an array of addresses.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以一次性批量注册选民，而不是一个一个注册，节省了行政时间和交易成本。你可以通过一个新函数接收一个地址数组来实现这一改进。
- en: Delegating votes
  id: totrans-1393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 投票委托
- en: A voter could delegate their vote to another registered voter. Then the delegator
    wouldn’t be able to vote, and the person delegated would cast as many votes as
    they’ve been delegated to cast by as many voters.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 选民可以将他们的投票权委托给另一个已注册选民。然后，委托人将无法投票，而被委托人将为众多选民委托的投票数投票。
- en: 'These are some hints on how to start the implementation:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些开始实施时的提示：
- en: 'You could change the voter struct as follows:'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以按照以下方式更改选民结构：
- en: '[PRE193]'
  id: totrans-1397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'You could add a new function so that the caller can delegate their vote to
    another registered voter. This would be similar to `SimpleCoin`’s `authorize`
    function to allocate an allowance to another account:'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以添加一个新函数，以便调用者可以将他们的投票权委托给另一个已注册选民。这将与`SimpleCoin`的`authorize`函数类似，以将允许额度分配给另一个账户：
- en: '[PRE194]'
  id: totrans-1399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The function’s implementation should alter the state of both delegator (`CanVote
    = false`) and delegated (`NumVotes +=1`).
  id: totrans-1400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的实现应该改变委托人（`CanVote = false`）和被委托人（`NumVotes +=1`）的状态。
- en: To check easily whether a voter is still entitled to vote, you could implement
    a `canvote` modifier around the `CanVote` property.
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了轻松检查选民是否仍有投票权，你可以围绕`CanVote`属性实现一个`canvote`修饰符。
- en: Deciding the winning proposal with a qualified majority
  id: totrans-1402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用合格多数决定获胜提案
- en: 'You could introduce the concept of a qualified majority. To win, a proposal
    should reach a predefined quorum: a minimum percentage of the cast votes.'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以引入合格多数的概念。为了获胜，提案应达到预定义的法定人数：投出选票的最小百分比。
- en: 'You’d introduce a new variable defining the quorum, initialized in the constructor:'
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会引入一个新变量来定义法定人数，并在构造函数中初始化：
- en: '[PRE195]'
  id: totrans-1405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: You’d modify the `tallyVotes()` function so the winning proposal would set the
    winner only if the quorum was reached.
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会修改`tallyVotes()`函数，只有在达到法定人数时，获胜的提案才设置获胜者。
- en: Implementing token-based voting
  id: totrans-1407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现基于代币的投票
- en: The current voting Dapp allows a voter account to increment the vote count of
    one of the proposals. This creates strong coupling between the voter and the chosen
    proposal, which can be slightly softened through vote delegation. In addition,
    the delegated voter will assign the entire vote of the delegator to a single proposal.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的投票Dapp允许选民账户增加某个提案的投票数。这创建了选民和所选提案之间的强耦合，可以通过投票委托稍微减轻这种耦合。此外，被委托的选民将为委托人将全部投票权指派给一个提案。
- en: 'An interesting concept that has appeared in the crypto space is that of token-based
    voting. It works like this:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密空间中出现的一个有趣概念是基于代币的投票。它运作方式如下：
- en: Each voter is assigned a voting coin or token, similar to our dear `SimpleCoin`.
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每位选民分配有一个投票币或代币，类似于我们的`SimpleCoin`。
- en: The voter then casts a vote by transferring the voting token to the proposal
    address.
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选民然后通过将投票代币转移至提案地址来投票。
- en: 'Because a vote has to be “spent,” this would prevent double voting. Things
    could get more sophisticated. A voter could, for example, do one of the following:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 因为投票必须要“花费”，这将防止重复投票。事情可能会变得更加复杂。选民可以，例如，执行以下操作之一：
- en: Transfer the voting token entirely or partially to one or many other voters
    through a transfer operation similar to that you’ve seen in `SimpleCoin`. (You
    could look at this as fractional delegation of the original vote.)
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类似于你在`SimpleCoin`中看到的转账操作，将投票代币全部或部分转让给一个或多个其他选民。（你可以将这看作是原始投票的分数委托。）
- en: Vote for one or many proposals, by assigning them specific fractions of the
    initial token.
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分配特定分数的初始代币来为一个或多个提案投票。
- en: You could build a token-based voting Dapp by implementing a voting token (along
    the lines of `SimpleCoin`) and then integrating it into the voting contract in
    the same way you integrated the crowdsale token in the crowdsale contract.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现一个投票代币（类似于`SimpleCoin`）并将其与投票合约相同的方式整合到一起，来构建一个基于代币的投票Dapp，然后就像在众售合约中整合众售代币一样。
- en: Anonymous voting
  id: totrans-1416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 匿名投票
- en: As you might remember, you’re recording the proposal ID that each voter chooses
    in the `votedProposalId` property of the voter struct. If you think you could
    implement anonymous voting by not recording the proposal chosen by the voter and
    by incrementing its vote count, you’re wrong. As you know, votes are cast through
    transactions, which are all recorded in the blockchain and can be inspected, so
    it would be easy to find out who voted for which proposal.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，你在每个选民的结构对象的`votedProposalId`属性中记录了每个选民选择的提案ID。如果你认为可以通过不记录选民选择的提案并增加其投票数来实施匿名投票，那你是对的。正如你所知，投票是通过交易进行的，所有交易都记录在区块链上，可以进行检查，所以很容易找出谁为哪个提案投票。
- en: Anonymizing voting is possible, but it’s complicated because there’s no out-of-the-box
    functionality for anonymizing transactions. This is a complex topic based on advanced
    cryptographic concepts such as *zero-knowledge proof*, which you might have heard
    associated with popular cryptocurrencies such as Zcoin, Zcash, and Monero.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名投票是可能的，但很复杂，因为没有现成的交易匿名功能。这是一个基于先进密码学概念如*零知识证明*的复杂主题，你可能听说过与流行的加密货币如Zcoin，Zcash和Monero有关。
- en: Some researchers at Newcastle University, UK, have implemented an Ethereum anonymous
    voting Dapp based on a protocol called Open Vote Network. They’ve made both their
    paper and their code publicly available on GitHub,^([[1](#ch12fn01)]) together
    with a video tutorial and many academic references on the topic. I recommend you
    review this material!
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 英国纽卡斯尔大学的一些研究人员基于名为Open Vote Network的协议实现了一个以太坊匿名投票Dapp。他们将自己的论文和代码公开发布在GitHub上，^([[1](#ch12fn01)])，并附有视频教程和许多关于该主题的学术参考文献。我建议你复习这些材料！
- en: ¹
  id: totrans-1420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Open Vote Network” on GitHub at [http://mng.bz/nQze](http://mng.bz/nQze)
    for more information.
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看GitHub上的“Open Vote Network”[http://mng.bz/nQze](http://mng.bz/nQze)获取更多信息。
- en: Summary
  id: totrans-1423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The SimpleVoting Dapp smart contract shows an effective implementation of predefined
    requirements, based on events and modifiers.
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleVoting` Dapp智能合约有效地实现了预定义的要求，基于事件和修改器。'
- en: You can build a web UI based on truffle-contract, a JavaScript library that
    easily connects a web page to a contract that has been previously deployed using
    Truffle.
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以基于truffle-contract构建一个网络UI，这是一个易于将网页连接到使用Truffle previously deployed的合约的JavaScript库。
- en: The truffle-contract library reads the contract ABI and address from a JSON
    file generated during Truffle contract compilation.
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truffle-contract`库从Truffle合约编译过程中生成的JSON文件中读取合约ABI和地址。'
- en: To read the contract ABI and address from a JSON file, you must render a web
    page through a web server. You can set up a minimal web server through Connect
    and ServerStatic, two Node.js packages.
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从JSON文件中读取合约ABI和地址，你必须通过一个网络服务器呈现一个网页。你可以通过两个Node.js包Connect和ServerStatic设置一个最小的网络服务器。
- en: Once you’ve implemented a Dapp, unit tested it, deployed it, and run it successfully
    against Ganache, a mock Ethereum client, you can deploy it on a public test network.
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你实现了一个Dapp，对其进行了单元测试，部署了它，并在Ganache，一个模拟以太坊客户端上成功运行了它，你就可以在公共测试网络上部署它。
