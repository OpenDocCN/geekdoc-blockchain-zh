- en: Part 3\.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of [part 3](#part03) as the core of the book. After learning all
    the foundation content in the previous parts, you’re ready to transition to real-world
    Ethereum. In [chapter 9](kindle_split_022.xhtml#ch09), you’ll become familiar
    with the wider ecosystem, which includes, among other elements, the Ethereum Name
    Service (ENS); decentralized storage networks, such as IPFS and Swarm; and oracle
    and other development frameworks. Then you’ll start to use professional development
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: In [chapter 10](kindle_split_023.xhtml#ch10), you’ll learn how to test smart
    contracts with the JavaScript Mocha framework, and in [chapter 11](kindle_split_024.xhtml#ch11),
    you’ll improve the development cycle with the Truffle framework, which will allow
    you to easily compile, test, and deploy your contracts. Finally, in [chapter 12](kindle_split_025.xhtml#ch12),
    you’ll put everything together by building an end-to-end voting Dapp from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing this part, you’ll have achieved a major milestone: you’ll
    understand how Ethereum works, inside and out, and will be aware of most of its
    ecosystem. If you’re eager to build your own Dapp, though, I strongly encourage
    you to keep reading so you can learn the more advanced concepts in [part 4](kindle_split_026.xhtml#part04).'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9\. The Ethereum ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: A bird’s-eye view of the full Ethereum ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized address resolution with ENS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized content storage on Swarm and IPFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External data access through oracles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapp frameworks and IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In previous chapters, you learned about the main components of the Ethereum
    platform and how to implement and deploy a decentralized application using simple
    tools such as the Remix IDE and the geth console. You then improved the efficiency
    of the development cycle by partially automating the deployment with Node.js.
    You made further efficiency improvements by deploying and running your smart contracts
    on a private network and, ultimately, on Ganache, where you progressively reduced
    and almost eliminated the impact of infrastructural aspects of the Ethereum platform
    on the run and test cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The tool set you’ve used so far has been pretty basic, but it has helped you
    understand every step of the build and deployment process of a smart contract.
    You’ve also learned about every step of the lifecycle of a transaction, from its
    creation, through a Web3 call, to its propagation to the network, to its mining,
    and ultimately to its persistence on the blockchain. Although you might have found
    these tools helpful and effective for getting started quickly and for learning
    various concepts in detail, if you decide to develop Ethereum applications on
    a regular basis, you’d use a different tool set.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives you an overview of the wider Ethereum ecosystem, both from
    a platform point of view and from a development tool set point of view. You’ll
    learn about additional components of the Ethereum platform and alternative IDEs
    and frameworks that will allow you to develop and deploy Dapps with less effort.
    But before we start to explore the full Ethereum ecosystem, I’ll recap the current
    view of the platform and the development tool set.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1\. The core components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 9.1](#ch09fig01) summarizes all you know so far about the Ethereum
    platform and the development toolset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1\. Core components of the Ethereum platform you’ve learned so far:
    geth, Ethereum wallet, MetaMask, Ganache, Remix, solc, and Web3.js'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although you’ve installed the Go Ethereum client (geth) and the Ethereum wallet,
    you’re aware you could have installed alternative clients, such as cpp-ethereum
    (eth), Parity, Ethereum(J), or pyethapp. Most of these come with a related wallet.
    You also could have decided to connect to an external MetaMask node (in fact,
    an Infura node, as you’ll see later) with MetaMask or to a mock node with Ganache.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve developed your smart contracts in Solidity using Remix (Browser Solidity).
    When needed, you’ve moved the code to text files and compiled them with the solc
    compiler. In theory, you could have implemented smart contracts in other EVM languages,
    such as Serpent or LLL, but currently Solidity is widely regarded as the most
    reliable and secure language. Time will tell if Serpent makes a comeback or new
    alternatives such as Viper start to gather momentum.
  prefs: []
  type: TYPE_NORMAL
- en: You interacted with the network, including your deployed contracts, in Web3.js,
    initially through the interactive geth console. Then you moved to Node.js for
    better extensibility and automation.
  prefs: []
  type: TYPE_NORMAL
- en: Web3.js is a JavaScript-specific high-level API that wraps the low-level JSON-RPC
    API. Other high-level APIs are available that target other languages, such as
    web3.j (for Java), NETEthereum (for .NET), and Ethereum.ruby (for ruby).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2\. A bird’s-eye view of the full ecosystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 9.2](#ch09fig02) provides a full view of the current Ethereum ecosystem,
    where you can see an additional set of development IDEs and frameworks, such as
    Truffle, aimed at improving the development experience. UI frameworks such as
    meteor and Angular aren’t Ethereum-specific, but they’re widely adopted to build
    modern Dapp UIs. Also, generic testing frameworks such as Mocha and Jasmine are
    becoming a common feature of Dapp development environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see additional infrastructural elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ethereum Name Service (ENS)*—This is a smart contract for the decentralized
    resolution of human-readable names, such as `roberto.manning.eth`, into Ethereum
    addresses, such as `0x829bd824b016326a401d083b33d092293333a830`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Swarm and IPFS*—These are two competing networks for decentralized storage
    of content that Ethereum blockchain transactions can then reference through hash
    IDs (or friendly names resolved into hashes by ENS). Swarm comes directly under
    the Ethereum umbrella and is Ethereum-aware; IPFS is a general technology-agnostic
    protocol that provides similar functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oracle frameworks*—These are smart contract frameworks (such as Oraclize)
    for accessing real-world data in a way that guarantees data authenticity and consistent
    processing of such data throughout the entire Ethereum network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Whisper*—This is a network for decentralized messaging that provides Ethereum
    smart contracts with asynchronous peer-to-peer communication, with resilience
    and privacy as main features. The Whisper API allows contracts to send messages
    with various degrees of security and privacy, from plain text and fully traceable
    to encrypted and virtually untraceable (so-called *dark messages*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 9.2\. Full view of the current Ethereum ecosystem, showing the items
    we haven’t yet covered in bold
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-02_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Infura nodes*—This is a set of Ethereum nodes that are hosted by Infura, a
    service owned by ConsenSys (the company also behind Truffle). Infura provides
    clients as a cloud service, with built-in security and privacy features. As for
    conventional cloud providers, Infura allows startups and independent developers
    to build Ethereum applications professionally without having to buy physical servers.
    MetaMask connects to these nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few sections will examine in detail ENS, Swarm, IPFS, and oracle frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Whisper falls in the realm of message-oriented protocols. This is an advanced
    topic, so I won’t cover it further. But if you have experience in message-oriented
    applications and are eager to learn more, I encourage you to look at the Whisper
    documentation on the Ethereum wiki on GitHub ([http://mng.bz/nQP4](http://mng.bz/nQP4)
    and [https://github.com/ethereum/wiki/wiki/Whisper](https://github.com/ethereum/wiki/wiki/Whisper)).
  prefs: []
  type: TYPE_NORMAL
- en: From a conceptual point of view, Infura nodes work exactly like other full Ethereum
    nodes. Bear in mind, though, that Infura clients support a subset of the JSON-RPC
    standard, so you should check their technical documentation if you’re interested
    in exploring them further.
  prefs: []
  type: TYPE_NORMAL
- en: Before closing this chapter, I’ll briefly present the main development tools
    for building Dapps. When I move on to the next chapter, I’ll focus on Truffle,
    the main smart contract development IDE, which I’ll cover in detail through hands-on
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3\. Decentralized address resolution with ENS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethereum Name Service, also known as ENS, manages decentralized address
    resolution, offering a decentralized and secure way to reference resource addresses,
    such as account and contract addresses, through human-readable domain names. An
    Ethereum domain name is, as for internet domain names, a hierarchical dot-separated
    name. Each part of the domain name (delimited by dots) is called a label. Labels
    include the *root domain* at the right, for example eth, followed by the *domain
    name* at its immediate left, followed by child *subdomains*, moving further to
    the left, as illustrated in [figure 9.3](#ch09fig03).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3\. The structure of an ENS name. You can see the root domain, eth,
    at the far right, followed by the domain name at its left, and nested child subdomains
    moving from right to left.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, you could send Ether to `roberto.manning.eth` (which is a subdomain
    of eth) rather than to `0xe6f8d18d692eeb02c3321bb9a33542903073ba92`, or you could
    reference a contract with `simplecoin.eth` rather than with its original deployment
    address: `0x3bcfb560e66094ca39616c98a3b685098d2e7766`, as illustrated in [figure
    9.4](#ch09fig04). ENS also allows you to reference other resources, such as Swarm
    and IPFS content hashes (which we’ll meet later in the next section), through
    friendly names.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4\. ENS resolves names into external (user) addresses, contract addresses,
    and Swarm content hashes. You can’t tell from the domain name itself if it’s mapped
    to an address or a Swarm hash. As you’ll see later, a domain name must be mapped
    explicitly to a specific name resolver for either an address or a Swarm hash (or
    some other resource identifier).
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'ENS is encapsulated as a smart contract, and because its logic and state are
    stored on the blockchain, and therefore decentralized across the Ethereum network,
    it’s considered inherently more secure than a centralized service such as the
    internet Domain Name Service (DNS). Another advantage of ENS is that it’s decentralized
    not only from an infrastructural point of view, but also from a governance point
    of view: domain names aren’t managed by a central authority, but they can be registered
    directly by the interested parties through registrars. A registrar is a smart
    contract that manages a specific root domain, such as eth. Domains are assigned
    to the winners of open auctions executed on the related registrar contract, and
    they also become the owners of the child subdomains.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1\. ENS design
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ENS system is structured as three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Registrar*—This is a contract that manages domain ownership. You must claim
    a domain name through the registrar and associate it with one of your accounts
    before you can register specific full domain names associated with it. Specific
    registrars handle each root domain, such as .eth, which is the root domain for
    names associated with Ethereum mainnet addresses, or .swarm, which is the root
    domain for names associated with swarm content hashes. Note that you must perform
    the ownership of domain names pointing to TESTNET Ethereum addresses through a
    test registrar that manages the .test root domain. This is a separate registrar
    from the one managing the .eth root domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resolvers*—These are smart contracts that implement a common ABI interface
    specified in Ethereum Improvement Proposal (EIP) 137, which you can consult here:
    [http://eips.ethereum.org/EIPS/eip-137](http://eips.ethereum.org/EIPS/eip-137).
    A resolver translates a domain name into a resource identifier. Each resolver
    is specific to one resource type. For example, there’s a resolver for Ethereum
    addresses (called public resolver), another resolver for IPFS content hashes,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Registry*—This is, in a nutshell, a map between domain (or subdomain) names
    and domain name resolvers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The simple design of the ENS registry, shown in [figure 9.5](#ch09fig05), makes
    it easily extensible, so you can reference custom resolvers implementing address
    translation rules of any complexity. Also, it can support a new resource type
    in the future without needing any modification and redeployment of the registry:
    a domain name for a new resource type will point to a new resolver. [Figure 9.6](#ch09fig06)
    shows the domain name resolution process.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5\. The ENS registry design. The ENS registry contract is a map between
    resource types and related domain resolver contracts. In the future, it can support
    a new resource type by pointing a domain name (associated with the new resource
    type) to a new resolver. Domain ownership is registered through a specific registrar.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6\. The domain name resolution process: 1\. you query the Registry
    to identify the correct resolver; 2\. you request the relevant resolver to translate
    the domain name into an address.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in [figure 9.6](#ch09fig06), a domain name is resolved in a
    two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: You query the Registry to identify the correct resolver associated with the
    domain name you want to resolve, and the Registry returns the contract address
    of the relevant resolver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You request the relevant resolver to translate the domain name into a resource
    identifier, such as an Ethereum address or a Swarm hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every mapping record stored on the registry contains the information shown in
    [table 9.1](#ch09table01).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1\. ENS registry mapping record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Field | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Domain name | For performance and privacy reasons, a hash of the domain name,
    called Namehash, is used rather than the domain name itself. Read the sidebar
    if you want to know more about this. | 0x98d934feea78b34... (Namehash of Roberto.manning.eth)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Domain owner | The address of the external (user) account or contract account
    owning the domain name | 0xcEcEaA8edc0830C... |'
  prefs: []
  type: TYPE_TB
- en: '| Domain name resolver | The address of the resolver contract able to resolve
    the domain name for the related resource type | 0x455abc566... (public resolver
    address) |'
  prefs: []
  type: TYPE_TB
- en: '| Time to live | This specifies how long the mapping record should be kept
    on the registry. It can be indefinite or a specified duration. | 6778676878 (expiry
    date as UNIX epoch) |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Namehash**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For performance reasons and for the privacy of the domain owners, ENS works
    against a 32-byte hash of the domain name rather than its plain string representation.
    This hash is determined through a recursive algorithm called *Namehash*, which,
    if applied, for example, to `roberto.manning.eth`, works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Split the full domain name into labels, delimited by the dots; order them from
    the last to the first; and add an empty label as a first item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pick the first item. Because it’s empty, determine the associated namehash
    by setting it to 32 ‘0’ bytes. The namehash corresponding to an increasing part
    of the full domain name is called *node*. So far, here’s what you have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pick the second label (`''eth''`) and determine its associated label hash by
    applying the `keccak256` hashing function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the node associated with the second label by hashing the concatenation
    of the previous node with the current label hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pick the third item `('manning')` and repeat steps 3 and 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the fourth item `('roberto')` and repeat steps 3 and 4. Finally, the namehash
    of `roberto.manning.eth` is
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can get an idea of the output taken by the Namehash algorithm to hash `roberto`
    `.manning.eth` in the table. **Namehash algorithm steps to hash Roberto.manning.eth**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Step | Label | labelHash | keccak256 (node+labelHash) | Node |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | '''' | N/A | N/A | 0x000000000000... |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | ''eth'' | 0x4f5b812789fc... | keccak256 (0x0000... 0x4f5b812789f...)
    | 0x93cdeb708b7... |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 | ''manning'' | 0x4b2455c1404... | keccak256 (0x93cde... 4b2455c...) |
    0x03ae0f9c3e92... |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 | ''roberto'' | 0x6002ea314e6 | keccak256 (0x03e0... 6002ea3...) | 0x5fd962d5ca4599b3b6
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Here’s a JavaScript implementation of the process from Nick Johnson’s ENS utility
    library `ensutils.js` (see next section for more details), which you can run in
    the geth console or in the Node.js console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '***1*** Node corresponding to empty label '' '''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** Splits the full domain name into its constituent labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** Gets current label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** Calculates label hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** Concatenates previous node with current label hash (removes ''0x''
    from label hash) and calculates current node using hex encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** Returns final node as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `web3.sha3()` function creates a keccak256 hash. It doesn’t follow the SHA-3
    standard, as the name would suggest.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 9.3.2\. Registering a domain name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Enough theory! Let’s see how to register a domain name on the ENS instance running
    on the Ropsten testnet from the geth console.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, download the ENS JavaScript utility library from here: [http://mng.bz/vN9r](http://mng.bz/vN9r).
    Place this JavaScript file in a folder, for example, C:\ethereum\ens.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although useful for learning ENS, the ENS JavaScript utility libraries ensutils.js
    and ensutils-testnet.js aren’t meant to be used to build a production Dapp.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Now, from an OS shell, start up geth against TESTNET, as you’ve done several
    times before. (Remember to use the `--bootnodes` option if peer nodes aren’t located
    quickly, as you did at the start of [chapter 8](kindle_split_020.xhtml#ch08).)
    Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Geth will start synchronizing, as expected. From a separate command shell,
    start an interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then import the ENS utility library on the interactive geth console you’ve
    attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Registering a domain on the TESTNET network means registering it on the `.test`
    root domain rather than on `.eth`, which is associated with MAINNET, the public
    production network. This means you must use the test registrar.
  prefs: []
  type: TYPE_NORMAL
- en: The domain name I’ll be registering is `roberto.manning.test`. Pick a similar
    three-label domain name and adapt the instructions that I’m about to give you,
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Domain Ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First of all, I have to check if anyone else already owns the `manning` domain.
    If someone does, I won’t be able to register my full domain name (`roberto.manning.test`);
    I’d have to ask the current owner to do it for me.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can check if the `manning` domain is free on the test registrar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Check the value of `domainExpiryDate` (by entering it at the prompt). If it’s
    earlier than today, the domain is free; otherwise, you must choose another domain
    and repeat the check.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might be wondering what happens in the unlikely event that ownership of
    '`manning`' hasn’t been registered yet but another name with the same `web.sha3()`
    hash has been registered. If this happens, you won’t be able to register '`manning`'
    because it would appear to the registrar as already taken.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Registering Domain Ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After checking that the account is free, you can claim it by registering it
    through the test registrar against one of your TESTNET accounts; for example,
    `eth.accounts[0]`. (Make sure `accounts[0]` has enough Ether to execute the transaction
    by checking, as usual: `eth.getBalance(eth.accounts[0]);` also, replace your `accounts[0]`
    password.) Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the value of `tx1`, and then check that the related transaction has been
    mined by going to Ropsten etherscan: [https://ropsten.etherscan.io](https://ropsten.etherscan.io).
    Note that registering domain ownership on MAINNET is a more complex process. (See
    [https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/) for
    more details.)'
  prefs: []
  type: TYPE_NORMAL
- en: Registering the domain name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the domain ownership transaction has been mined, it’s time to set up the
    domain name mapping configuration you saw in [table 9.1](#ch09table01). You already
    set some of the configuration (the domain account owner) by registering the domain
    ownership through the registrar. Now you have to configure the resolver and the
    target address that the domain name will be mapped to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can map your domain name to the public resolver (which, as you know, maps
    a domain name to a given Ethereum address) through the ENS registry as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Check on Ropsten etherscan if `tx2` has been mined, then configure the public
    resolver to point your domain name to the target address (for example, your test
    `accounts[1]`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Registering the Subdomain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Registering the ownership of a subdomain is slightly different from registering
    the ownership of a domain, as you don’t perform it through the registrar, but
    through the ENS registry. Assign the ownership of the subdomain `Roberto.manning`
    to `accounts[2]`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The account running the transaction must be the owner of the `''manning.test''`
    domain: `accounts[0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Using `accounts[2]`, the owner of the `''roberto.manning.test''` subdomain,
    you can now map it to the public resolver as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can configure the public resolver to point your domain name to
    the target address (for example, your test `accounts[3]`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 9.3.3\. Resolving a domain name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Resolving a domain name into an address is straightforward. Resolve `''manning.test''`
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and you can verify this is your `accounts[1]` address, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a shortcut to resolve the domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you’re interested in learning more about ENS—for example, to claim an .eth
    domain name in MAINNET through a commit-reveal bid—I encourage you to consult
    the official documentation written by Nick Johnson, the creator of ENS. You can
    find it at [https://docs.ens.domains/en/latest/](https://docs.ens.domains/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 9.4\. Decentralized content storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common use case for decentralized applications is to store a sequence of
    documents proving, for example, the provenance of goods traded through the applications.
    A typical example is diamonds, which traditionally are accompanied by paper certificates
    showing that they come from legitimate mines and traders. For more complex supply
    chains, such as in the field of international trade finance ([https://en.wikipedia.org/wiki/Trade_finance](https://en.wikipedia.org/wiki/Trade_finance)),
    which involves multiple parties, such as a supplier, the bank of the supplier,
    a shipping company, an end client, and their bank, the paperwork might be more
    voluminous. Storing the equivalent electronic documentation directly on the blockchain
    would work but wouldn’t be ideal for a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The electronic documentation would bloat transactions referencing it, which
    would be processed more slowly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bigger transactions require more gas to process and are therefore more expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative solution would be to store the electronic documentation on an
    off-blockchain database and include in the transaction only a cryptographic hash
    of each of the documents, to prove their content. This solution isn’t perfect,
    though, because the off-blockchain database would be a centralized resource not
    easily accessible by the Ethereum nodes. Even if the decentralized application
    could access the database where the documentation was stored, having this centralized
    repository would be contrary to the spirit of decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: An ideal solution instead would be based on a decentralized storage repository.
    This is exactly what the Swarm platform, which is partially associated with Ethereum,
    aims to provide. Another valid alternative would be to use the existing IPFS distributed
    storage network. Let’s explore these two options.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.1\. Swarm overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Swarm is a content distribution platform whose main objective is to provide
    decentralized and redundant storage to Ethereum Dapps. It focuses specifically
    on holding and exposing smart contract data and code, as well as blockchain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage is decentralized in Swarm through a P2P network that makes it resistant
    to distributed denial of service (DDoS) attacks and censorship, and that provides
    fault tolerance and guarantees zero downtime because it has no single point of
    failure. The architecture of the P2P Swarm network, shown in [figure 9.7](#ch09fig07),
    is similar to that of the Ethereum network: each node runs a Swarm client that
    manages local storage and communicates with its peer nodes through a common standard
    protocol called *bzz*. Currently, only one client implementation is available,
    written in the Go language, and it’s included in the Geth & Tools package you
    can download from the Go Ethereum website. The main difference with the Ethereum
    network is that all Ethereum nodes have the same copy of the blockchain database,
    whereas each Swarm node contains a different set of data, also illustrated in
    [figure 9.7](#ch09fig07).'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7\. Architectural diagram of a Swarm network. The Swarm network, made
    of nodes each running a Swarm client, is similar to the Ethereum network, in which
    every node runs an Ethereum client. Contrary to Ethereum nodes, which all have
    the same copy of the blockchain data, each Swarm node contains a different set
    of data.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Swarm node is linked to an Ethereum account known as a *swarm base account*.
    The (keccak 256-bit) hash of the address of the swarm base account determines
    the *swarm base address*, which is the address of a Swarm node within the Swarm
    network. A Swarm network is associated with a specific Ethereum network. For example,
    the main production Swarm network is associated with MAINNET, and a Swarm network
    is associated with the Ropsten Ethereum network. Because Swarm is part of the
    Ethereum technology stack, it makes full use of other components of the ecosystem,
    such as ENS.
  prefs: []
  type: TYPE_NORMAL
- en: When content is uploaded to Swarm, it’s broken down into 4 KB *chunks* that
    get scattered throughout the Swarm network. The upload process is illustrated
    in [figure 9.8](#ch09fig08).
  prefs: []
  type: TYPE_NORMAL
- en: 'It involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller uploads the content, typically a file, to the distributed preimage
    archive (DPA), which is the storage and retrieval gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DPA calls a component called *chunker*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chunker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: chops the content up into 4 KB pieces called chunks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: calculates cryptographic hashes of its chunks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The hashes of the chunks (or blocks) are placed in a chunks-index document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the chunks-index document is bigger than 4 KB, it’s chopped up into chunks
    whose hashes are then placed into a further document. This process goes on until
    the chunks are organized into a tree structure with a root index document at the
    top, followed by a layer of index chunks in the middle and the content chunks
    at the bottom, as illustrated in [figure 9.9](#ch09fig09). This data structure
    is a Merkle tree, the same data structure a blockchain database uses to link its
    blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.8\. The Swarm upload process: 1\. the caller uploads a file to the
    distributed preimage archive gateway; 2\. the DPA sends the file to a chunker;
    3\. the chunker chops the file into 4 KB chunks and calculates a hash for each
    one; 4\. the chunk hashes are placed in a chunk-index document; 5\. the chunkindex
    document is chunked and reorganized in a Merkle tree structure, whose root hash
    is called root key; 6\. the chunker stores each chunk onto the netStore against
    its hash; 7\. the netStore distributes 4 KB chunks across the Swarm network; 8\.
    the chunker returns the root key to the DPA; 9\. finally, the DPA returns the
    root key to the caller.'
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-08_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The chunker stores each chunk on the netStore against its hash key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The netStore is an implementation of a *distributed hash table* (DHT) across
    the Swarm network, so chunks are stored on many Swarm nodes. Because the key of
    this distributed hash table is a cryptographic hash key, which is a representation
    of the underlying content, this way of storing data is also known as *content
    addressable storage* (CAS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chunker returns the hash key of the root index document, known as *root
    key*, and hands it back to the DPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DPA finally returns the root key to the caller. This will later be used
    to download the original file from Swarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.9\. Chunk and chunk-index Merkle tree structure. The document at the
    top contains the hashes of chunks of the initial chunk-index document (containing
    the hashes of all 4 KB chunks). The intermediate layer is made of chunks of the
    initial chunk-index document. The layer at the bottom contains the 4 KB chunks
    of the original file.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The download process goes through a similar workflow, but in reverse order,
    as shown in [figure 9.10](#ch09fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: A caller hands a root key to the DPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DPA calls the chunker, and it supplies the root key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chunker retrieves the root chunk associated with the root key from the netStore,
    then walks the tree until it has retrieved all the chunks from the Swarm network.
    While chunks are flowing from their netStore location (the specific Swarm node
    they’re stored on) to the chunker, they get cached into each Swarm node they go
    through, so often if the same content is requested, subsequent downloads will
    be faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chunker reconstructs the file from the chunks and returns it to the DPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DPA returns the requested file to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From an operational point of view, the sustainability of the Swarm platform
    is based on monetary incentives aimed at encouraging and rewarding participants
    who provide the underlying storage resources. Storage is traded between participants
    who require it and those who provide it, so it tends to be allocated efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10\. The Swarm download process: 1\. a caller hands a root key to
    the DPA; 2\. the DPA calls the chunker, and it supplies the root key; 3\. the
    chunker retrieves the root chunk associated with the root key from the netStore,
    then walks the tree until it has retrieved all the chunks from the Swarm network;
    4\. the chunker reconstructs the file from the chunks and returns it to the DPA;
    5\. the DPA returns the requested file to the caller.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 9.4.2\. Uploading and downloading content to and from Swarm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, I’ll show you how to upload content to Swarm, get its root
    key, and then download it back from Swarm using the root key.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Swarm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first step you have to take is to download the Swarm client, swarm.exe,
    from the Go Ethereum website. If you downloaded geth from the Geth & Tools archive
    (or installer) link, you should already have swarm.exe in the same folder you’re
    running geth from. Otherwise, go back to the Go Ethereum website and download
    the Geth & Tools 1.8.12 package, which I believe is the latest archive still containing
    swarm.exe. Unzip it and copy swarm.exe into the same folder where you’ve placed
    geth.exe. In my case, I’ve placed it here: C:\Program Files\geth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start up geth against TESTNET. (Remember to use the `--bootnodes` option
    if peer nodes aren’t located quickly, as you did at the start of [chapter 8](kindle_split_020.xhtml#ch08).)
    Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Geth will start synchronizing, as expected. From a separate command shell,
    start an interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from the interactive console, get the address of your testnet `accounts[1]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll run the Swarm client under this account by opening a new OS console
    and executing the following command from the folder where you placed the swarm
    executable (replacing your Ethereum testnet folder accordingly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 9.2](#ch09table02) explains the options I’ve used to start up the Swarm
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.2\. Options used to start up the Swarm client
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Option | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| --datadir | Specifies the datadir path related to the environment to use—in
    our case, TESTNET (Ropsten) |'
  prefs: []
  type: TYPE_TB
- en: '| --bzzaccount | Specifies the Ethereum account to use—in our case, TESTNET
    accounts[1] |'
  prefs: []
  type: TYPE_TB
- en: As you can see in [figure 9.11](#ch09fig11), you’ll be asked to unlock `accounts[1]`
    by providing its password. Enter the password, as requested, and the client will
    start up with output similar to that in the screenshot in [figure 9.12](#ch09fig12).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11\. Unlocking the Ethereum account you’re using to start up the Swarm
    client
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It might take a few minutes before your Swarm client synchronizes with a number
    of peers (by default up to a maximum of 25). Output similar to the following indicates
    capable peers have been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Figure 9.12\. Swarm start-up output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Uploading Content
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you’re connected to the Swarm network, you can upload some sample
    text onto the network. Open a new OS console and submit this HTTP request to your
    Swarm client through curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll immediately get a response showing the root key associated with the
    submitted content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Downloading Content
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To get the content back from Swarm, you can now submit a new request that includes
    the root key you obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, you’ll get back the text you submitted earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The official documentation is an excellent resource to learn more about Swarm
    and to try out more advanced features: [http://mng.bz/4OBv](http://mng.bz/4OBv).
    But you also should be aware that the Swarm initiative has been criticized by
    some members of the decentralized web community for duplicating the effort of
    IPFS, a project with similar objectives but with a more general purpose. The following
    section explains IPFS and the reason for the controversy.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.3\. IPFS overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IPFS stands for InterPlanetary File System and, as you might guess from its
    name, is a hypermedia distribution protocol whose objective is to support a decentralized
    way of storing and sharing files. With Swarm, storage is distributed over a P2P
    network, which you can consider a distributed file system. The IPFS way of storing
    files provides the same benefits as the Swarm network, such as zero downtime and
    resistance to DDoS attacks and censorship.
  prefs: []
  type: TYPE_NORMAL
- en: Files aren’t stored in their entirety in a single network location; they’re
    broken down into *blocks*, which are then transformed into IPFS objects and scattered
    across the network. An IPFS object is a simple structure containing two properties
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'where a Link object has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each IPFS object is referenced by its hash.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the IPFS object associated with a small file that’s decomposed
    into a single file block is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.1\. IPFS object associated with a file containing a single block
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **There are no links to other IPFS objects because the file is made
    of a single block.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is unstructured binary data contained in the file (up to a max
    of 256 KB).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of the IPFS object associated with a large file, bigger than 256
    KB and broken down into multiple blocks, is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.2\. IPFS object of a file larger than 256 KB, split into various blocks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This file has been split into multiple blocks of 256 KB, each corresponding
    to an item in the Links list.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Block name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Block hash**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Block size (256 KB)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each block referenced in the Links array is represented by a document like that
    shown in [listing 9.1](#ch09ex01). The workflow followed by an IPFS client for
    uploading a file on IPFS is illustrated in [figure 9.13](#ch09fig13).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the steps of the upload workflow in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A user uploads a file to an IPFS node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPFS node breaks the file down into blocks of a certain size (typically
    256 KB).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An IPFS object is created for each file block. This looks like the one shown
    in [listing 9.1](#ch09ex01). A cryptographic hash is calculated for each IPFS
    object and associated with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An IPFS object is created for the file. This contains links to IPFS objects
    associated with all the file blocks and looks like the IPFS object shown in [listing
    9.2](#ch09ex02). A cryptographic hash is calculated for this IPFS object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.13\. The IPFS upload process: 1\. a user uploads a file to an IPFS
    node; 2\. the IPFS node breaks down the file into 256 KB blocks; 3\. an IPFS object
    is created for each file block; 4\. an IPFS object is created for the file, and
    it contains links to IPFS objects associated with all the file blocks; 5\. each
    block is stored at a different network location, and an index holding a map between
    block hashes and corresponding network locations is maintained on each node.'
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-13_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Each block is stored at a different network location, and an index holding a
    map between block hashes and corresponding network locations is maintained on
    each node. You might have realized content is referenced by its own cryptographic
    hash key, as in the case of the Swarm platform, so you can also consider IPFS
    to be content addressable storage (CAS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that content is referenced by its hash, this design is focused on managing
    efficiently immutable files. For example, only one copy of a document has to exist
    in the network because its hash must point only to one network location, so duplication
    is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: But IPFS is also capable of managing mutable documents by tracking their changes
    through versioning. When a file changes, only its amended blocks need to be hashed,
    stored on the network, and indexed, and the unaffected blocks will be reused.
    The workflow of the download process is shown in [figure 9.14](#ch09fig14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps of the workflow in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14\. The IPFS file download process: 1\. IPFS is queried for a file
    associated with a certain IPFS file object hash key; 2\. the IPFS client requests
    the file object from the corresponding IPFS node; 3\. the requested node returns
    the IPFS file object; 4\. the IPFS client scans each link on the Links property
    of the IPFS file object; 5\. each requested IPFS node returns the corresponding
    IPFS block object; 6\. the original file is recomposed on the IPFS node serving
    the request, and it’s returned to the caller.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A user queries IPFS for a file associated with a certain IPFS file object hash
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPFS client retrieves the network location of the IPFS file object associated
    with the provided hash key by looking it up on the local IPFS index, and then
    it requests the file object from the corresponding IPFS node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The requested node returns the IPFS file object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPFS client scans each link on the Links property of the IPFS file object.
    For each link, it retrieves the network location associated with the IPFS object
    key from the local index and then uses the network location to retrieve the corresponding
    IPFS block object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each requested IPFS node returns the corresponding IPFS block object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original file is recomposed on the IPFS node serving the request, and it’s
    returned to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contrary to Swarm, IPFS gives no direct incentives to its P2P participants for
    contributing to the network’s file storage resources, and it relies on FileCoin,
    a separate but related initiative based on the Bitcoin blockchain, to reward active
    participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about IPFS, download the client and give it a go
    at [https://ipfs.io/docs/getting-started/](https://ipfs.io/docs/getting-started/).
    I recommend you also have a look at the Git book *The Decentralized Web Primer*,
    which has various tutorials on how to install an IPFS client and how to interact
    with the network and examine IPFS objects through common operations such as uploading
    and then downloading a file: [http://mng.bz/QQxQ](http://mng.bz/QQxQ). (Click
    the green Read button to access the content.)'
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.4\. Swarm vs. IPFS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, do you think Swarm is duplicating the effort of IPFS, as some
    members of the decentralized web have argued? Now that you know about both decentralized
    content management infrastructures, you can probably judge for yourself whether
    the Swarm initiative has been worthwhile. [Table 9.3](#ch09table03), which summarizes
    the main features of both platforms, might help you answer the question.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.3\. Comparison of Swarm vs. IPFS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Feature | Swarm | IPFS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Storage architecture | Decentralized | Decentralized |'
  prefs: []
  type: TYPE_TB
- en: '| Network architecture | P2P | P2P |'
  prefs: []
  type: TYPE_TB
- en: '| Content Accessible Storage | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Block/chunk size | 4 KB | 256 KB |'
  prefs: []
  type: TYPE_TB
- en: '| Native integration with Ethereum | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Incentive strategy | Built-in | External (through FileCoin) |'
  prefs: []
  type: TYPE_TB
- en: 'Fans of the Swarm platform argue that its smaller chunk size, which allows
    much lower transmission latency, and its deeper integration with Ethereum are
    by themselves two key reasons for the existence of Swarm. You can find further
    analysis of the difference between Swarm and IPFS online on various forums, such
    as Ethereum stack exchange: [http://mng.bz/Xg0p](http://mng.bz/Xg0p).'
  prefs: []
  type: TYPE_NORMAL
- en: 9.5\. Accessing external data through oracles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conventional web applications consume a variety of external services, typically
    by performing REST API calls or invoking legacy web services. You might be surprised
    to hear that this isn’t possible in the Dapp world. By design, Ethereum contracts
    can’t access external sources. This is to avoid two main set of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Trust issues*—Participants might be wary about the authenticity of the data
    and its potential manipulation before making it into the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Technical issues*—The data provider might struggle to serve thousands of simultaneous
    requests coming from the Ethereum network, therefore compromising the block creation
    and validation process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do you get external data into your smart contract so you can work around
    the restrictions that the Ethereum infrastructure imposes and be confident about
    the data’s authenticity? You do it through oracles. An *oracle* is, in short,
    a bridge between the blockchain network and the outside world. It takes care of
    fetching the queried data from external data providers, and then it returns it
    to the requesting contract together with a *proof of authenticity*. Having the
    process arranged that way, you can see an oracle as a middleman that merely plays
    a facilitating role. Although it’s a point of centralization, the requesting contract
    doesn’t need to trust the oracle because the oracle can’t modify the data it’s
    returning without invalidating it against the proof of authenticity (which the
    end user can verify). [Figure 9.15](#ch09fig15) shows the main components that
    are part of a typical oracle-based data-feeding solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A contract*—This executes a query to retrieve some data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An oracle*—This connects the contract to the relevant data provider by resolving
    the query and fetching the data from the data provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 9.15\. An oracle is a bridge between the blockchain network and the outside
    world. It takes care of fetching the requested data from external data providers
    and returns it to the requesting contract with a proof of authenticity.
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-15_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*A set of data sources*—These might include REST APIs, legacy web services,
    online random generators, or online calculators, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TLSNotary*—This service generates cryptographic proofs of online data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IPFS store*—This is where data returned together gets stored with proof of
    authenticity for later off-blockchain verification, if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.5.1\. Feeding oracles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use two main strategies for feeding an oracle so consumers can trust
    its data:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Independent participants can feed an oracle.* In this case, the oracle aggregates
    the original data coming from the different participants through a consensus model,
    and then it feeds the data to the consumer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A single data provider can feed an oracle.* In this case, the oracle supplies
    the consumer a copy of the original data, accompanied with a proof of authenticity
    of that data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Oracle Fed by Independent Participants
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When independent participants feed an oracle, the approved data set is generated
    on a consensus basis, for example by averaging numeric values or selecting the
    most frequent non-numeric values. This way of feeding data, which happens in a
    decentralized fashion and is subject to a consensus, seems to naturally fit the
    spirit of decentralized applications. But it has various drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: A high number of feeders might be necessary to generate a reliable data set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The oracle provider relies on feeders constantly keeping up with new data requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the data feeders might expect to get paid regardless of the quality of their
    data. This might prove expensive for the oracle provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle Fed by the Provider from a Single Data Source
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When a single source feeds an oracle, it demonstrates that the exposed data
    is genuine and untampered with by returning it to a client together with a proof
    of authenticity document. Services such as TLSNotary can generate the document,
    and it’s based on various technologies, such as auditable virtual machines and
    trusted execution environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oraclize offers one of the most popular frameworks for feeding smart contracts
    from a single source. This solution has two main advantages with respect to oracles
    fed by multiple participants:'
  prefs: []
  type: TYPE_NORMAL
- en: Dapp developers and users don’t need to trust Oraclize, as they can verify the
    truthfulness of the data independently against the proof of authenticity, both
    on-chain from within contract code and off-chain through web verification tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data providers don’t need to implement new ways of distributing data, on top
    of their current web services or web APIs, to feed decentralized applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enough talking! I’ll now show you how to build your first oracle consumer contract.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2\. Building a data-aware contract with Oraclize
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to hook a contract into Oraclize, you have to
  prefs: []
  type: TYPE_NORMAL
- en: import a Solidity file named oraclizeAPI.sol, available from the Oraclize GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inherit your contract from a base contract called usingOraclize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your contract, as illustrated in the sample oracle shown in [listing 9.3](#ch09ex03)
    (which comes from the Oraclize documentation), should contain
  prefs: []
  type: TYPE_NORMAL
- en: one or more *state variables* holding the latest value of a copy of the external
    data being requested; in this example, ETHXBT (the Ether to Bitcoin exchange rate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an `update()` function that an end user can invoke to refresh the local copy
    of the external data through a request to Oraclize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a callback function named `__callback`, which is invoked from the result transaction
    that Oraclize produces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 9.3\. Contract providing ETHXBT rate from the Kraken exchange through
    Oraclize
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Imports the Oraclize client code from their GitHub repository**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Inherits from the base contract usingOraclize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **State variable holding the external data: exchange rate for Ether
    to Bitcoin from Kraken**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Event logging whether the data query has been sent to Oraclize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Event logging whether Oraclize has returned the requested data**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Contract constructor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Specifies that the data requested should be accompanied by TLSNotary
    proof and that the proof should get stored on IPFS**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Sets the ETHXBT state variable when the contract is created**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **Callback invoked by Oraclize when returning the requested data to
    the contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***10*** **Updates the ETHXBT state with the value that Oraclize returned**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***11*** **Logs the requested data that Oraclize has returned**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***12*** **Triggers a new update so that the contract keeps refreshing ETHXBT
    continuously**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***13*** **Triggers the update of ETHXBT, which can be invoked by an end user
    or internally, as mentioned previously**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***14*** **Checks if the contract has enough Ether to fund the data request
    to Oraclize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***15*** **Data request query to Oraclize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oraclize Data Request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Look closely at the data request to the Oraclize engine within the update method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The data request is performed by calling the `oraclize_query()` function, inherited
    from the `usingOraclize` base contract, with a set of parameters, as shown in
    [figure 9.16](#ch09fig16):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Request delay*—Number of seconds that should be waited before retrieving the
    data (can also be an absolute timestamp in the future)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data source type*—Oraclize supports various data sources types, but we’ll
    focus mainly on the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*—Website or HTTP API endpoint'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IPFS*—Identifier of an IPFS file (content hash)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query*—This is a single parameter or an array of parameters whose values depend
    on the data source type. For example, for requests of type URL, if you supply
    only one parameter (the URL of the data source), the call is assumed to be an
    HTTP GET request. If you supply two parameters, the second is assumed to be the
    body of an HTTP POST request. For a request of type IPFS, the only parameter that
    you should supply is the IPFS content hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 9.16\. `oraclize_query()` parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig09-16_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in [figure 9.16](#ch09fig16), results are extracted from the
    query through a result parser, which depends on the nature of the data source
    being called. [Table 9.4](#ch09table04) summarizes the supported parsers.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.4\. Oraclize query result parsers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Parser type | Parser identifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| JSON parser | json | Converts results to a JSON object, which you can extract
    specific properties from |'
  prefs: []
  type: TYPE_TB
- en: '| XML parser | xml | Typically parses legacy web service results |'
  prefs: []
  type: TYPE_TB
- en: '| HTML parser | html | Useful for HTML scraping |'
  prefs: []
  type: TYPE_TB
- en: '| Binary helper | binary | Can extract items from binary results with slice(offset,
    length) |'
  prefs: []
  type: TYPE_TB
- en: Results Callback Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you’ve learned how to perform a data request, we’ll look at how the
    Oraclize engine responds with the results. As you saw in [figure 9.15](#ch09fig15),
    when processing a request, the Oraclize engine grabs the results from the relevant
    data source, and then it creates a result transaction, which it sends back to
    the Ethereum network. This transaction is also known as an *Oraclize callback
    transaction*, because during its execution, it calls back the oracle contract
    performing the request on its `__callback` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `__callback` function from the result transaction, the value
    of the ETHXBT state variable is updated. You can then use it in the rest of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.3\. Running the data-aware contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to run the data-aware contract from [listing 9.3](#ch09ex03), you
    need the Oraclize Remix plugin, which directly references the oraclizeAPI.sol
    file, including using the Oraclize contract from GitHub: http://mng.bz/y1ry.'
  prefs: []
  type: TYPE_NORMAL
- en: A dialog box will appear, warning that “Remix is going to load the extension
    “Oraclize” located at https://remix-plugin.oraclize.it. Are you sure to load this
    external extension?” Click OK.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to try out the KrakenPriceTicker.sol, which you can find already
    set up within the Gist menu on the left side of the screen (Gist > KrakenPriceTicker).
    Before running it
  prefs: []
  type: TYPE_NORMAL
- en: check and make sure the compiler version is set to 0.4.24+commit.e67f0147 in
    the Solidity Version panel (on the Settings tab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: check and make sure the Environment is set to JavaScript VM (on the Run tab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After having done so, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Run tab and click Deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the KrakenPriceTicker drop-down in the bottom Deployed Contracts panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Update. (If you want to emulate the behavior of a contract call, you could
    also set the Value field at the top of the screen, for example to 20 Finney, but
    within Remix, this isn’t necessary.) At this point, the value of ETHXBT gets updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the ETHXBT button to check the value of the exchange rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 9.6\. Dapp frameworks and IDEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Four categories of tools can improve the Dapp development cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Development IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web UI frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.6.1\. Development IDEs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Development IDEs and development frameworks are tools that help you speed up
    the development cycle. Although IDEs and development frameworks offer similar
    functionality, the former are slightly more focused on code editing and compilation,
    whereas the latter offer powerful deployment capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For a few months, Ethereum Studio appeared to be the de facto IDE for developing
    Ethereum Dapps, because it provided good code editing capabilities coupled with
    Web3 integration and smooth contract deployment functionality. But then ether.camp,
    the company behind it, stopped supporting it. As a result, developers are advised
    to instead use generic code editing tools, such as Sublime, Atom, Visual Studio
    Code, Vi, and Emacs, configured with the related Solidity plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6.2\. Development frameworks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The objective of Ethereum development frameworks is to streamline the development
    cycle and allow developers to focus on writing code rather than spending most
    of their time compiling it, redeploying it, and retesting it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various third-party smart contract frameworks have appeared since the launch
    of the Ethereum platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapp (formerly known as Dapple)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Truffle is probably the most advanced Ethereum development framework, and it
    focuses mainly on simplifying the building, testing, packaging, and deployment
    of Solidity contracts. It’s distributed as a Node.js package and provides a REPL
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle’s key selling point is migration—the way this framework manages the
    scripting and configuration of contract deployment. This is the framework you’ll
    use in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Populus
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Populus is functionally similar to Truffle in that it’s designed to simplify
    the compile-test-deploy cycle by working on smart contract projects organized
    with a specific folder structure. It provides configuration management that allows
    you to progress smoothly throughout development from an in-memory blockchain such
    as Ganache, to a private internal network, and finally to a public one. The peculiarity
    of Populus with respect to other frameworks is that it allows a developer to script
    unit tests or deployment instructions in python.
  prefs: []
  type: TYPE_NORMAL
- en: Embark
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Embark aims to be a platform-agnostic Dapp framework to simplify the development
    and deployment of any decentralized application. This framework simplifies the
    management of multicontract Dapps, and you can configure it to automatically deploy
    a contract when a code change is detected. It allows decentralized storage through
    the IPFS protocol (and Swarm) and decentralized messaging through the Whisper
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Dapp
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Dapp framework is geared mainly toward the Linux world and is distributed
    through the Nix Package manager. The emphasis of this framework is on contract
    packaging under the Ethereum Smart Contract Packaging Specification ([https://github.com/ethereum/EIPs/issues/190](https://github.com/ethereum/EIPs/issues/190))
    and contract code storage decentralization through the IPFS protocol, which we
    examined in [section 9.4](#ch09lev1sec4). Dapp also provides a unit testing facility
    through ethrun and ds-test.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which development framework to adopt might be difficult, as all of
    them offer similar compile-test-deploy functionality, although delivered in slightly
    different ways. It might sound obvious, but the best way to determine which one
    suits your needs best is to try out all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Given the bias of the Ethereum platform toward JavaScript, it’s natural that
    several generic JavaScript frameworks have become a common feature of the Ethereum
    ecosystem. Let’s see why you should consider including JavaScript testing and
    UI frameworks in your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6.3\. Testing frameworks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a generic JavaScript testing framework, as opposed to the unit testing
    functionality that a main development framework (such as Truffle or embark) offers,
    provides
  prefs: []
  type: TYPE_NORMAL
- en: more advanced unit testing capabilities, for example, support for async calls,
    exit status values for continuous integration systems, timeout handling, meta-generation
    of test cases, and more extensibility around the use of assert libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'better system testing automation: you can automate tests involving end-to-end
    interaction through a private or public test network, and they can handle timeouts,
    retries, and other use cases around communication with the contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two most popular JavaScript unit testing frameworks used for developing
    decentralized applications are Mocha and Jasmine, and you’ll be using Mocha in
    the next few chapters. Let’s now move on to the web UI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6.4\. Web UI frameworks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the UI is an important element of a Dapp, because it connects the end
    user with the backend smart contracts, the Ethereum platform doesn’t yet fully
    support any technology to develop the presentation layer of an Ethereum application.
    Because you can include and reference web3.js on the JavaScript of a plain html5
    web page, it’s natural to think that an easy way of exposing a Dapp is through
    web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Given the abundance of excellent JavaScript UI frameworks, it’s hard to recommend
    any one framework in particular. But it’s worth mentioning that frameworks such
    as Meteor, Angular, Vue, and, more recently, React are getting increasing traction
    in the Ethereum community. As far as we’re concerned, we’ll stick to minimalistic
    solutions based on plain HTML and JavaScript, but feel free to embellish the UI
    code with the framework of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous chapters introduced a restricted view of the Ethereum ecosystem,
    limited to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Core infrastructural components*—The Go Ethereum (geth) client, the Ethereum
    wallet, MetaMask, and Ganache'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Core development tools*—Solidity (the EVM smart contract language), Remix
    (the online Solidity IDE), solc (the solidity compiler), JSON-RPC (the low-level
    Ethereum client API), Web3.js (a high-level Ethereum client API written in JavaScript),
    Node.js (not Ethereum-specific JavaScript runtime)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum ecosystem includes a wider set of infrastructural components, such
    as ENS (for decentralized name resolution to addresses), Swarm and IPFS (for decentralized
    content storage), Whisper (for decentralized messaging), oracles (for importing
    data from public web-based data providers), and Infura (for managed Ethereum nodes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum Name Service, also known as ENS, offers a decentralized and secure
    way to reference resource addresses, such as account and contract addresses, through
    human-readable domain names. It has objectives similar to the internet DNS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing relatively big content on the blockchain isn’t recommended because it’s
    clumsy and expensive. A better solution is to use decentralized storage systems,
    such as Swarm and IPFS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm is based on the Ethereum technology stack and is Ethereum network-aware,
    and it’s often the preferred solution for storing content off-chain that can be
    referenced on the Ethereum blockchain through cryptographic hash-based identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPFS is a technology-agnostic protocol for content storage and offers a more
    widely known and tested solution, at the expense of inferior performance and looser
    Ethereum integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracles, such as Oraclize, allow smart contracts to import data from outside
    the Ethereum network and accompany it with a proof of authenticity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum ecosystem also includes a wider set of development tools, such
    as Truffle, the main smart contract framework; generic JavaScript testing frameworks,
    such as Mocha and Jasmine; and JavaScript web UI frameworks, such as Angular,
    ReactJS, and Meteor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 10\. Unit testing contracts with Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up Mocha, a JavaScript unit testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing `SimpleCoin` with Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests performing negative checks, verifying expected exceptions are
    thrown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests performing positive checks, verifying logic is executed successfully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In previous chapters, you learned how to develop an Ethereum Dapp by using simple
    tools that the platform offers. You were able, with some effort, to build an end-to-end
    Dapp, including a simple web UI and a smart contract layer (including libraries)
    and to deploy it to the public test network. You wrote Solidity and Web3.js code
    through Remix or even through plain text editors and launched simple deployment
    scripts manually, initially on the geth console and later on Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Although this way of developing a Dapp is acceptable while learning, it isn’t
    efficient when you start to dedicate more time to developing decentralized applications,
    especially if you do it professionally. As you learned in the chapter dedicated
    to the Ethereum ecosystem, various third-party development tools are available
    to improve code editing to help you unit test your contracts and speed up the
    development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll present Mocha, a JavaScript unit testing framework that
    will allow you to easily automate unit tests for your contracts. In the next chapter,
    you’ll learn how to set up Truffle, through which you’ll automate build and deployment
    of your Dapps. Finally, you’ll also incorporate Mocha tests within Truffle, making
    it your fully integrated development environment.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn Mocha by writing a unit test suite for `SimpleCoin`. Before you
    start, I’ll show you briefly how to install the framework and set up the working
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1\. Installing Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mocha is executed through Node.js, so you have to install it using `npm`. Because
    you’ll be writing tests for various smart contracts, it’s best to install it globally.
    (You might have to Run it as an Administrator, depending on your security configuration.)
    Here’s how to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! The next step is to prepare a working directory for your `SimpleCoin`
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2\. Setting up SimpleCoin in Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should place tests against an Ethereum smart contract in a working directory
    configured for Node.js and set up with Ethereum packages such as Web3 and Ganache.
    Create a working directory for the `SimpleCoin` unit tests you’re going to write.
    I’ve created mine as C:\Ethereum\mocha\SimpleCoin.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a package.json configuration file for Node.js in this folder and
    set the test script to Mocha, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1\. package.json
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also create it interactively by opening an OS shell, moving to the working
    directory you’ve created, and running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the directory and configuration file created, you can quickly
    try out how Mocha executes tests. Create a dummyTests.js file containing the example
    test shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.2\. dummyTests.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Imports the default assert library**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Names the test suite**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Names the functionality being tested**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Describes the specific test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Actual test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can run this test file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And you’ll get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, the assert library referenced at the top of the test
    script is the default assert library that the framework provides. If you want,
    you can install and then reference any of the following assert frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: Should.js ([https://shouldjs.github.io/](https://shouldjs.github.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expect.js ([https://github.com/Automattic/expect.js/](https://github.com/Automattic/expect.js/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai.js ([www.chaijs.com/](http://www.chaijs.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better-assert ([https://github.com/tj/better-assert](https://github.com/tj/better-assert))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexpected ([https://github.com/unexpectedjs/unexpected](https://github.com/unexpectedjs/unexpected))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The testing working directory is almost ready. Before you can use it for testing
    smart contracts, you must install the following node packages: solc, Web3, and
    Ganache. If you haven’t installed them globally already, you can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can install these packages only in the testing folder as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 10.3\. Writing unit tests for SimpleCoin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’re all set up to write some tests against `SimpleCoin`. Now I can show
    you how to unit test a solidity contract in Mocha. This isn’t meant to be a tutorial
    on unit testing, though, and I’ll assume you have basic knowledge of or experience
    in unit testing. If you don’t know anything about unit testing but wish to learn
    more on the topic, I can recommend two excellent books that will give you a solid
    foundation: *Effective Unit Testing* by Lasse Koskela and *The Art of Unit Testing*
    by Michael Feathers and Robert C. Martin, both published by Manning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be creating tests against the functionality offered by the extended
    version of `SimpleCoin` you implemented back in [chapter 5](kindle_split_017.xhtml#ch05).
    I’ve repeated it in the next listing for your convenience, and you can place it
    in the following file: c:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.3\. SimpleCoin.sol, latest code from [chapter 5](kindle_split_017.xhtml#ch05)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 10.3.1\. The testing plan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unit testing a Solidity contract means verifying that all the public methods
    the contract exposes, including the contract constructor, behave as expected,
    with both valid and invalid input. First, I’ll help you verify that the constructor
    initializes the contract as expected. You’ll do so by correctly setting the contract
    owner value and the initial state according to the account used to execute the
    deployment transaction and the values fed to the constructor parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I’ll show you a set of tests for the typical negative and positive checks
    you want to perform against any contract function. By *positive* checks, I mean
    those verifying successful logic execution: a contract function invoked by an
    authorized user and fed with valid input within the constraints defined by all
    modifiers decorating the function and acceptable to the function logic executes
    successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By *negative* checks I mean those verifying expected exceptions are thrown
    for an unauthorized caller or invalid input:'
  prefs: []
  type: TYPE_NORMAL
- en: A contract function that is restricted to certain callers through a modifier
    throws an expected exception if the caller isn’t authorized to invoke it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract function that receives input that doesn’t meet other constraints
    defined by additional modifiers or `require` conditions throws an expected exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re familiar with these types of tests, you’ll be able to write tests
    against any contract function. You can start by testing `SimpleCoin`’s constructor.
    While we look into that, I’ll also give you a general idea of how to initialize
    and structure your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2\. Unit testing the constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you know, testing a piece of code means executing the code under test and
    then verifying assumptions about what should have happened. You execute the code
    of the contract constructor only during its deployment, so your test must deploy
    `SimpleCoin` and then verify that the construction was executed correctly, specifically
    by checking the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The contract owner is the same account as the sender of the deployment transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The token balance of the contract owner is the same as the initial supply amount
    being fed to the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests must generally run as quickly as possible, because you’re likely
    to execute them many times through your development cycle. In the case of enterprise
    applications, the main source of latency comes from accessing environmental resources,
    such as the file system, databases, and network. The most common way of reducing
    or eliminating such latency is to emulate access to these resources with isolation
    (or mocking) frameworks, such as jMock and EasyMock for Java applications and
    Moq, NMock, and Rhino Mocks for .net applications.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Ethereum Dapps, the main source of latency is transaction processing
    (including mining and block creation) and block propagation throughout the Ethereum
    network. As a result, it’s natural to run contract unit tests against a mock network
    such as Ganache, which emulates the infrastructural aspects of the Ethereum platform
    without connecting to it.
  prefs: []
  type: TYPE_NORMAL
- en: This means your first test, against `SimpleCoin`’s constructor, must deploy
    `SimpleCoin` on Ganache before performing the functional checks I’ve described
    (of contract ownership and the account balance of the owner). In fact, to ensure
    no interferences occur between tests, each test will redeploy `SimpleCoin` from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying `SimpleCoin` onto Ganache... Hold on—you already did this in [chapter
    8](kindle_split_020.xhtml#ch08)! You can adapt [listing 8.5](kindle_split_020.xhtml#ch08ex05)
    for unit testing. You can keep the script almost unchanged up to the instantiation
    of `SimpleCoinContractFactory`. The only modification is the path of `SimpleCoin.sol`,
    which is now c:\Ethereum\mocha\SimpleCoin. Here’s the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The location of simplecoin.sol is now in c:/Ethereum/ mocha/SimpleCoin.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve taken care of the infrastructural (nonfunctional) part of your
    first test, you can focus on the functional one. Bear in mind, though, that these
    initial lines of the script haven’t deployed `SimpleCoin` yet; they’ve merely
    instantiated the contract factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the pattern in the mock test from [listing 10.2](#ch10ex02), you
    can start to document the purpose of your first test through Mocha’s `describe()`
    and `it()` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Describes the entire testing suite you’re creating**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Describes your first testing section, focused on SimpleCoin’s constructor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Describes your first test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s time to write the core of your first test, which will, as I stated earlier,
    check that the contract owner is the same account as the sender of the deployment
    transaction. You can structure the test with an *AAA layout*, which includes the
    following three parts, as also illustrated in [figure 10.1](#ch10fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrange*—Sets up the input passed to the function under test and instantiates
    objects required for the testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Act*—Calls the function under test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assert*—Verifies the test assumptions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Inputs to this test are the sender of the deployment transaction
    and the initial supply amount.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Triggers the function under test, SimpleCoin’s constructor, through
    contract deployment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Following successful deployment, verifies the contract owner is the
    sender of the transaction**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Signals to Mocha the completion of the test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 10.1\. The typical AAA structure of a unit test: Arrange (set up test
    input and the object under test); Act (call the function under test); and Assert
    (verify the test expected outcome)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You’re now ready to run your first unit test, which is shown in its entirety
    in the following listing. You can place this script in the following file: c:\Ethereum\mocha\SimpleCoin\SimpleCoinTests.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.4\. SimpleCoinTests.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the script, open a new console and start Ganache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go back to the console from which you executed the dummy test earlier and
    run your new test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see output like what’s shown in [figure 10.2](#ch10fig02).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2\. Output of your first Mocha test, showing the name of the test
    suite, the name of the test section, and a description of your individual test.
    The test is passing!
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The test is passing, which means the contract owner is indeed the sender of
    the deployment transaction. Good news! You can move on to the next test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before leaving the constructor, you should test whether the balance of the
    contract owner is equal to the initial supply fed with the `initialSupply` parameter.
    Add the following `it()` block within the `describe()` section associated with
    the `SimpleCoin` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** This is the only line differing from the previous test. It verifies
    whether the balance of the contract owner equals the initial supply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might be wondering why I didn’t add the same assert line to the previous
    test. In general, it’s good practice to keep each unit test focused on one specific
    thing. Given that this test has nothing to do with verifying contract ownership,
    I decided to create a completely separate test. As I mentioned earlier, you also
    should completely isolate every test from other tests to avoid cross-dependencies
    and side effects that might invalidate unrelated tests. That’s why you should
    redeploy `SimpleCoin` at each test—by doing so, you can be confident that the
    test is truly isolated.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Now rerun the test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output in [figure 10.3](#ch10fig03) that both tests have
    passed. Also, if you look at the Ganache console, you can verify that while running
    this test session, `SimpleCoin` was indeed deployed twice—once for each test,
    as shown in [figure 10.4](#ch10fig04).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3\. Amended test suite, including two constructor tests. Both have
    passed.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4\. Ganache output during test execution. `SimpleCoin` is redeployed
    at each test execution.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 10.3.3\. Testing whether only authorized callers can invoke a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll now move to the set of tests you typically want to write against each
    contract function. If you look at [listing 10.3](#ch10ex03), you’ll notice both
    `mint()` and `freezeAccount()` restrict their execution to the contract owner
    through the `onlyOwner` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A test you should write for each of these functions is to verify that an exception
    is thrown if you try to call them from an account that isn’t the contract owner.
    Here’s how you write such a test for `mint()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sender of the contract transaction (the contract owner)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The account calling mint() isn’t the contract owner.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Verifies an exception is thrown when mint() is called, because the
    caller of mint() isn’t the contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, you verify that an exception is thrown when calling a function
    by wrapping it with the following assert statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You’ll use this technique several times in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4\. Testing if input constraints are met
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even when the caller is authorized to invoke a function, they must feed it valid
    input. You should verify that if they don’t do so, an exception is thrown for
    any breach to function modifiers or require conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the `transfer()` function performs input validation through various
    `require` statements before executing the token transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, you should write a test for each of the `require` statements. I’ll
    show you how to write a test against the second `require` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This constraint prevents the sender from sending more tokens than they own.
    If they try to do so, an exception is thrown. You can verify this is happening
    by using the same `assert.throws` statement you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sets an amount to be transferred that’s higher than the current balance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Verifies that an exception is thrown**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Expected exception**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `transfer()` function has two other `require` statements. I encourage you
    to write similar tests for them.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5\. Testing invocation from an authorized account with valid input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After you write tests performing negative checks so you’re confident that no
    unauthorized accounts or accounts with invalid input can call the function, it’s
    time to write a positive test proving the logic performs successfully when an
    authorized account invokes the function and feeds it with valid input. As an example,
    you could write a new test against the `transfer()` function dealing with a successful
    token transfer. In this case, you must verify that the sender account balance
    has decreased by the transferred amount, whereas the receiving account has increased
    by the same amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sets amount to be transferred**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Expected sender and recipient balances after the transfer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Actual sender and recipient balances after the transfer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Verifies actual sender and recipient balances equal the expected
    ones**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the two tests you’ve written against `transfer()` to the test script you
    started to write earlier against the constructor and rerun it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in [figure 10.5](#ch10fig05), the test output now shows two
    sections: one for the constructor tests and the other for the `transfer()` tests.
    All tests are passing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5\. Output of the amended test suite also including tests on the
    `transfer()` function. You can now see two sections: one for the constructor tests
    and the other for the `transfer()` tests. All tests are passing.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As an additional test to perform a positive check, you could write a test against
    the `authorize()` function, which has no modifiers and no input validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The most obvious test to write is therefore one that verifies that the allowance
    set is the expected one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sets the allowance amount**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Authorizes the account to use the specified allowance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Verifies the allowance allocated to the authorized account is the
    expected one**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.3.6\. A little challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve covered all the typical tests, I invite you to refresh your
    memory on the `transferFrom()` function. That function allows an account to transfer
    an amount from another account within an allowance previously authorized by the
    account owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at its code, you might want to test at least these four scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The authorized account can’t transfer a number of tokens higher than that owned
    by the authorizer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account can’t transfer tokens from an account that hasn’t authorized any
    allowance to any account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account can’t transfer tokens from an account that hasn’t authorized it any
    allowance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An authorized account can transfer an amount within the allowance, the final
    balance of the authorizer has decreased by the amount transferred by the authorized
    account, and the balance of the recipient has increased by the same amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have noticed these tests are similar to ones you’ve already written,
    so I won’t repeat myself here. But I encourage you to give these tests a shot
    and then compare your tests with mine, which you can find in [listing C.1](kindle_split_032.xhtml#app0C1)
    in [appendix C](kindle_split_032.xhtml#app03).
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.7\. The full testing suite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can see all tests, including the ones I’ve skipped, in [listing C.1](kindle_split_032.xhtml#app0C1)
    of [appendix C](kindle_split_032.xhtml#app03). You can also find them in the SimpleCoinTest.js
    file of the provided code. After adding all these tests to SimpleCoinTests.js,
    you can run the whole suite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output in [figure 10.6](#ch10fig06) shows the tests nicely grouped in sections
    ... and all passing.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6\. Running the whole test suite. The output shows tests are grouped
    in sections ... and they’re all passing.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig10-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This section has given you an idea of the typical tests you might want to write
    against a contract you’re developing. You can find a summary in [table 10.1](#ch10table01).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1\. Purpose of the tests presented in this section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Function | Test | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | Contract owner is sender | Testing contract ownership |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | Owner balance = supply | Testing correct state set from constructor
    parameters |'
  prefs: []
  type: TYPE_TB
- en: '| Mint | Can’t mint from nonowner account | Testing if an exception is raised
    when an unauthorized account invokes the function |'
  prefs: []
  type: TYPE_TB
- en: '| Transfer | Can’t transfer more tokens than owned | Testing if an exception
    is raised by invalid input breaching modifiers or require conditions |'
  prefs: []
  type: TYPE_TB
- en: '| Transfer | Successful transfer | Testing contract state following successful
    transaction executed from valid account and with valid input |'
  prefs: []
  type: TYPE_TB
- en: The test suite I’ve presented covers the most obvious test cases, but it’s by
    no means comprehensive. Like programming, unit testing is an art, not an exact
    science. You must always keep in mind the trade-off between coverage (Are all
    the functions of your contracts covered by tests? Are all logic branches covered
    by tests?) and accuracy (Are all boundary conditions of each function tested?)
    of your tests on one side and their cost (for implementation and maintenance)
    on the other side. Ideally, you might want to have maximum coverage and accuracy,
    but you might not have enough time and resources to implement and maintain all
    the necessary tests. In that case, you might want to focus on critical areas,
    especially on functionality for which Ether’s at stake.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can write Ethereum contract unit tests relatively easily with Mocha, a generic
    JavaScript testing framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install Mocha quickly with `npm`, the Node.js package manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can describe Mocha unit test packages and groups using `describe()` and
    individual tests using `it()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your tests should cover negative checks, verifying expected exceptions are thrown
    in case the function is invoked from an unauthorized account or with invalid input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your tests should cover positive checks, verifying the contract state has been
    successfully modified by the function logic when the function is called from an
    authorized account and with valid input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also should write tests against the constructor to verify that the contract
    owner and the contract state are initialized correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 11\. Improving the development cycle with Truffle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Truffle, a smart-contract framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and compiling an Ethereum contract within Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying contract deployment through Truffle’s migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying contract unit testing with Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In the previous chapter, you started to integrate unit testing into your development
    environment with Mocha. But you might have noticed that the unit test script didn’t
    look ideal. It has a fairly complex setup, which includes explicit instructions
    on compiling `SimpleCoin` and creating a contract factory. Each test also includes
    an explicit deployment statement that references the contract factory. The main
    drawback is that all this infrastructural code distracts from the main objective
    of unit tests, which is to focus on functional aspects of a contract. Another
    disadvantage is that if you wanted to create a new test suite to cover a different
    contract, you’d have to duplicate all this infrastructural code.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn’t it be nice if you had a way to simplify the deployment of a contract?
    This is the main objective of Truffle, an Ethereum contract development framework
    that focuses on streamlining deployment and consequently simplifying unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll set up Truffle, and then you’ll use it to improve the
    compile -> deploy -> test cycle. The main focus will be on learning how to use
    the tool, so, to avoid getting distracted by contract-specific issues, you’ll
    reuse our good old `SimpleCoin` contract yet again. If you’re eager to implement
    something new, please bear with me: in the next chapter you’ll develop a brand
    new Dapp from scratch using Truffle!'
  prefs: []
  type: TYPE_NORMAL
- en: 11.1\. Setting up Truffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can install Truffle easily with Node.js `npm`, and then you can start to
    create a project. Install version 4.1.15, which is the one I have used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order to run my code smoothly, don’t install Truffle 5.0.0\. My code is written
    against version 4.1.15, and is unlikely to work correctly under version 5.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 11.2\. Moving SimpleCoin under Truffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll start with a minimal project, and then you’ll integrate `SimpleCoin`
    in Truffle by walking through the entire development lifecycle, including the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up `SimpleCoin` in Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling the contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing the contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.1\. Setting up SimpleCoin in Truffle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create a working directory for the `SimpleCoin` Truffle project. I’ve created
    mine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Open an OS shell and move to this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can initialize the Truffle project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Truffle will create the following directory structure and prepopulate it with
    some files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 11.1](#ch11table01) provides a description of each directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.1\. Truffle directory structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Directory/filename | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| /contracts | Directory for Solidity contract files you want to compile and
    deploy. |'
  prefs: []
  type: TYPE_TB
- en: '| /contracts/Migrations.sol | Special contract that Truffle uses to deploy
    project contracts. |'
  prefs: []
  type: TYPE_TB
- en: '| /migrations | JavaScript configuration files to perform *migrations* (more
    on this later). |'
  prefs: []
  type: TYPE_TB
- en: '| /test | Truffle can automatically test both Solidity contract code and JavaScript
    application code through unit tests placed in this folder. |'
  prefs: []
  type: TYPE_TB
- en: '| truffle.js | The Truffle project configuration file for Linux or macOS. |'
  prefs: []
  type: TYPE_TB
- en: '| truffle-config.js | The Truffle project configuration file for Windows. |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re running Windows, keep truffle-config.js and remove truffle.js. If
    you’re running on Linux or macOS, you can remove truffle-config.js and use truffle.js.
    In the rest of the chapter, I’ll refer to truffle.js—you’ll understand why shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 11.2.2\. Compiling SimpleCoin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy the latest version of `SimpleCoin` from C:\Ethereum\mocha\SimpleCoin\SimpleCoin.sol
    to C:\Ethereum\Truffle\SimpleCoin\Contracts\SimpleCoin.sol. Downgrade the pragma
    solidity instruction of SimpleCoin.sol to 0.4.23 after copying the file, as the
    latest version of Truffle at the time of writing uses solc 0.4.23.
  prefs: []
  type: TYPE_NORMAL
- en: You perform contract deployment in Truffle through so-called *migrations*, as
    I’ll explain shortly. You execute these through a `Migrations` contract, shown
    in the following listing, which was auto-generated in the contracts folder when
    you initialized the project with the `truffle init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11.1\. contracts/Migrations.sol
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You can now kick the compilation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'and you’ll see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After a successful compilation, Truffle has created a new directory relative
    to the project folder, /build/contracts. The folder contains compilation artifacts,
    described in [table 11.2](#ch11table02), that you’ll use during the deployment
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.2\. Compilation artifacts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Artifact | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Migrations.json | ABI interface and bytecode of Migrations.sol |'
  prefs: []
  type: TYPE_TB
- en: '| SimpleCoin.json | ABI interface and bytecode of SimpleCoin.sol |'
  prefs: []
  type: TYPE_TB
- en: 11.2.3\. Troubles with Truffle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve started having issues at this point, it might be because you’re working
    in Windows or have a compiler versioning problem. You’ll need a solution so you
    can complete the work in this chapter. This two-part section provides some advice
    to help you solve such problems.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle on Windows
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re working in Windows, you might experience issues when running any Truffle
    command. Specifically, if you’re running Truffle compile in a Windows command
    shell, you might get the cryptic Microsoft JScript runtime error shown in [figure
    11.1](#ch11fig01).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1\. Error generated when running a Truffle command in Windows
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig11-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The error occurs because Windows can’t distinguish correctly between the Truffle.cmd
    command file in the npm folder (typically in C:\Users\YOURNAME\AppData\ Roaming\npm)
    and the truffle.js file in your Truffle project folder. You have four options
    for solving this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a configuration file named truffle-config.js instead of truffle.js, as mentioned
    in the earlier setup section. Remove truffle.js from your Truffle project folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If for any reason you want to use a configuration file named truffle.js rather
    than truffle-config.js, use Git Bash rather than the standard command shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call truffle.cmd explicitly, for example, `truffle.cmd compile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to the directory where truffle.cmd is and copy it locally with another name,
    for example, truff.cmd. Then run `truff compile` instead of Truffle compile. If
    you decide to use this workaround, keep typing *truff* rather than Truffle for
    the rest of the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting Truffle Compile Errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you get compilation errors, it might be because you’re running an old version
    of the compiler or because Truffle is referencing an old version of the compiler,
    even if you’ve upgraded it recently. Specifically, after executing the `truffle
    compile` command, you might get some compilation error messages due to new constructor
    syntax introduced in solc 0.4.22\. You have two options for fixing the issue.
    The best approach is to uninstall Truffle and reinstall it globally by entering
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: followed by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now if you re-execute `truffle compile`, you should get at most some warnings
    associated, possibly, with the `Migrations` contract (in the contracts\Migrations.sol
    file). It might still be implemented under an old constructor convention, depending
    on the version of Truffle you’re running. If you’re running Truffle 4.1.15 or
    later, you shouldn’t have any issues; the Migrations.sol file should have been
    autogenerated like in [listing 11.1](#ch11ex01). If you’re running an older version
    and want to get rid of the warnings, replace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recompile, you should no longer get any warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to fix compilation issues, which I’d leave as a last resort,
    is to reinstall solc, but only into the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.4\. Deploying SimpleCoin onto a mock network client through migrations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A migration is a deployment script. As seen before, migration scripts are in
    the migrations directory. Replace the content of 2_deploy_contracts.js with the
    script shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.2\. 2_deploy_contracts.js: `SimpleCoin''s` migration script'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **artifacts.require is similar to Node.js require, and you have to
    initialize it with the name of a contract (not a contract filename).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **You have to set the module.exports property to a function that accepts
    a deployer object, which is the component performing deployment tasks.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **SimpleCoin gets deployed with an initial supply of 10,000 tokens.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the first migration execution, you also have to deploy the `Migrations`
    contract. This contract gets deployed through its own migration script, shown
    in the following listing and contained in this file: C\Ethereum\Truffle\SimpleCoin\migrations\1_initial_migration.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.3\. 1_initial_migration.js: `Migrations`’ migration script'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve placed the migration scripts in the migrations directory, open
    a separate OS shell and move to the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll be deploying `SimpleCoin` onto Ganache, the mock Ethereum client you
    already saw in [chapters 8](kindle_split_020.xhtml#ch08) and [10](kindle_split_023.xhtml#ch10).
    Ganache is part of the Truffle framework. If you haven’t already installed it,
    you can do so through npm, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after the installation is complete, start it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Make sure truffle.js (or truffle-config.js on Windows) is configured to point
    to Truffle Develop, as shown in the following listing, as opposed to pointing
    to a public test network. Amend its content as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.4\. truffle.js (or truffle-config.js): Truffle pointing to Test
    Develop'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Deploying from a specific account**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, your contracts will be deployed under Truffle from accounts[0],
    which is the default transaction sender. If you want the deployment transaction
    to be submitted from another account, you must specify the full address in the
    truffle.js file in the `from` property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This is Ganache’s accounts[1], as shown on Ganache’s startup screen.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Go back to the previous console and run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you’ll get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that `SimpleCoin` has been deployed successfully on Ganache’s mock
    network. If you prefer to run the mock network client and Truffle commands from
    within the same OS shell, you can use a separate console called Truffle Develop.
    Have a look at the sidebar if you want to learn more. For the rest of the book,
    you’ll keep using two separate consoles: one to run Ganache and the other to launch
    Truffle commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Executing Truffle commands from Truffle Develop’s console**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start Truffle Develop from the Truffle project folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This will start a mock network client similar to Ganache (and TestRPC), but
    on port 9545, which means, if you have Ganache running, you don’t need to shut
    it down.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0325-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Truffle Develop startup screen
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you want to use Truffle Develop, you need to change the truffle.js configuration
    to point to port 9545:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’ll be able to run Truffle commands, such as `migrate`, directly from
    the Truffle Develop console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see exactly the same output as before.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 11.2.5\. Deploying SimpleCoin onto a public test or production network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although in this chapter you’ll be deploying contracts only on Ganache (or
    TestRPC), at some point you might want to deploy on the public test network or
    production network. If so, you must modify your truffle.js (or truffle-config.js)
    file and include configurations for a test network and a live network, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This configuration assumes you’re running a local geth node (the host is pointing
    to localhost), and the default Web 3 provider will be instantiated by Truffle
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you decide to use a different provider, for instance an HDWalletProvider
    pointing to a Ropsten Infura network, you must configure it explicitly with the
    provider property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, bear in mind, when deploying on a public network, you might want to specify
    other settings, such as the gas limit, the gas price, and the account the contract
    should be deployed through. If so, you can add relevant configuration properties
    as described in [table 11.3](#ch11table03), but I invite you to consult the official
    documentation before proceeding further: [http://mng.bz/mmgy](http://mng.bz/mmgy).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.3\. The truffle.js configuration properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Property | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| gas: | Gas limit (default = 4712388) |'
  prefs: []
  type: TYPE_TB
- en: '| gasPrice: | Gas price (default = 100,000,000,000 wei) |'
  prefs: []
  type: TYPE_TB
- en: '| from: | Sender address of the deployment transaction (and contract owner)
    |'
  prefs: []
  type: TYPE_TB
- en: '| provider: | The default is web3, as explained previously. |'
  prefs: []
  type: TYPE_TB
- en: 'Once you’ve configured truffle.js (or truffle-config.js) appropriately, you
    can kick a deployment to the Ropsten network as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as you might have guessed, you’d deploy to MAINNET as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.6\. Testing SimpleCoin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Truffle supports *clean-room testing*, which means that if a contract has been
    deployed on Ganache, its state will get reinitialized at the beginning of each
    test file being processed. If the contract has been deployed on a public network,
    the migrations will get re-executed at the start of each test file being processed,
    effectively redeploying the contract from scratch before the execution of the
    tests. In general, during development it’s preferable to run unit tests against
    Test Develop, as they run up to 90% faster. It’s advisable to run the tests on
    a private network, and ultimately on a public network, in later stages of the
    development cycle to make sure you’ve tested application aspects of communicating
    with a real network.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to write two different classes of tests with Truffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Solidity tests*—Test the contract logic from test contracts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript tests*—Test the contract from external Web3.js calls, which go
    through the same infrastructure as real calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must place all test scripts, whether written in Solidity or JavaScript,
    in the test directory of the Truffle project. We’ll focus almost entirely on JavaScript
    tests, as Solidity tests are meant to test contract-to-contract interaction, which
    is a more advanced topic outside the scope of this book. But I’ll give you some
    of the basics of working with Solidity tests.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.7\. Writing Solidity tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You implement Solidity tests through custom test contracts whose code you have
    to place in .sol files within the project test directory. Solidity tests must
    be able to run against
  prefs: []
  type: TYPE_NORMAL
- en: the assertion library that Truffle provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any other assertion library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache (or TestRPC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any Ethereum client (not only geth) and type of network (both private and public)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You structure a Solidity test contract the way TestSimpleCoin.sol does, as
    shown in [listing 11.5](#ch11ex05). You must follow these guidelines and conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: You must import an assertion library to check for equality, inequality, and
    emptiness. The default assertion library that Truffle provides is Truffle/Assert.sol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must import the Truffle/DeployedAddresses.sol library so the test runner
    can access the addresses of contracts deployed through migrations. The Deployed-Addresses
    library is recompiled each time the test contract is run, to guarantee clean-room
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must import the contract under test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a test contract must start with Test (uppercase T) so the test runner
    can identify it easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a test function must start with test (lowercase t).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test function must return a Boolean value. Generally, this is returned through
    an assertion function such as `Assert.equal().`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 11.5\. TestSimpleCoin.sol test contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Imports assert library**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Imports DeployedAddresses contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Imports contract being tested: SimpleCoin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Testing contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **SimpleCoin instance at the deployed address**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Verifies test assumptions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, place TestSimpleCoin.sol in the test folder and make sure Test Develop
    (or TestRPC) is still running. (If it’s not running, restart it in a separate
    console.) You can then run Solidity tests by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depending on the version of your solc compiler, you might get some warnings,
    especially around code raising events.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: As I mentioned earlier, contract-to-contract testing is an advanced topic outside
    of the scope of this book, so I won’t cover Solidity tests further. The next section
    will be dedicated entirely to JavaScript tests under Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.8\. Writing JavaScript tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Do you remember the effort you put into writing tests in Mocha? It wasn’t wasted:
    Truffle supports Mocha JavaScript testing, but with deeper integration with Ethereum.
    This means you'
  prefs: []
  type: TYPE_NORMAL
- en: won’t have to decorate your test files with `require` statements for Ethereum
    libraries such as web3.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: will be able to reference contracts that have been deployed through migrations,
    without having to compile them and deploy them manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: will be able to reference accounts implicitly, without having to hardcode Ethereum
    addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: will be able to run the tests from within Truffle and integrate them within
    any continuous integration jobs that Truffle coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run in Truffle the JavaScript tests you wrote earlier in Mocha, you’ll have
    to make minor changes, especially if you want to ensure they’re executed in clean-room
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace `describe()` calls with `contract()` calls, which ensures all contracts
    get redeployed onto the Ethereum client and tests are run with a *clean* contract
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference solidity contracts with `artifacts.require()`, as you did earlier
    when writing the migration scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the callback section within the asynchronous deployment call you had
    on Mocha tests with a promise chain, where the first promise in the chain is a
    promise of a deployed contract, and the subsequent promises are chained through
    `then()` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll demonstrate here how to rewrite some of the tests, so you can get a better
    idea of what the guidelines I’ve given mean. I’ll start from the first test against
    `SimpleCoin`’s constructor. For convenience, I’ve repeated the code from the original
    test you wrote in Mocha in the following listing, so you don’t have to flip pages
    back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11.6\. Original Mocha test on the constructor, verifying contract ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Now create a file called testSimpleCoin.js and place it in the test directory.
    Fill it with the code shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11.7\. Truffle constructor test verifying contract ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References SimpleCoin, the code under test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Name of the test suite**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Name of the test section**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Description of the single test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Gets a promise of a SimpleCoin contract instance deployed through
    the migration you set up earlier**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Chains the promise of a SimpleCoin instance to a new function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Gets a promise of the owner of the SimpleCoin instance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Chains the promise of the owner of the SimpleCoin instance to a new
    function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **The final function executed in the promise chain performs the test
    assertion.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***10*** **Error message to display in case of test failure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I mentioned in the deployment section, by default, contracts are deployed
    under Truffle from `accounts[0]`. That’s why in the test you’re comparing the
    address of the contract owner, `contractOwner.valueOf()`, with `accounts[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: You’ve surely noticed a few differences between Mocha and Truffle tests, such
    as those listed in [table 11.4](#ch11table04).
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.4\. Differences between Mocha and Truffle tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Mocha tests | Truffle tests |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mocha’s test script starts with a relatively long setup, during which we
    go through all the necessary low-level steps required for deploying SimpleCoin.
    | Truffle’s test has hardly any setup at all and immediately references a deployed
    instance of SimpleCoin (through the migration framework). |'
  prefs: []
  type: TYPE_TB
- en: '| Mocha’s test execution is based on a callback associated with the deployment
    of a SimpleCoin instance. | Truffle’s test execution is based on a chain of promises
    starting with a promise of a deployed SimpleCoin instance. |'
  prefs: []
  type: TYPE_TB
- en: '| Once you get ahold of a SimpleCoin instance (or a promise of it), Mocha’s
    test code seems shorter and to the point. | After getting a SimpleCoin instance,
    Truffle’s code goes through various steps to get ahold of the contract owner for
    subsequently comparing it with the expected one. |'
  prefs: []
  type: TYPE_TB
- en: In summary, thanks to Truffle’s migration framework, tests don’t need much setup
    to access an instance of `SimpleCoin`. On the other hand, after referencing a
    `SimpleCoin` instance, Mocha’s test seems less verbose than Truffle’s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the test! When you re-execute the Truffle test command, both Solidity
    and JavaScript tests will be run, and you’ll get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'You can rewrite the constructor test that verifies the owner balance is the
    initial supply. Add the following `it()` block in testSimpleCoin.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you might remember, `SimpleCoin`’s migration script (named 2_deploy_contracts.js
    and shown in [listing 11.2](#ch11ex02)) sets the initial supply to 10,000\. That’s
    why the contract owner balance is being compared to 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Rerun the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Improving JavaScript tests with await/async
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the file named testSimpleCoin_ALL_sync.js provided on the book website, you
    can find a full Truffle test suite equivalent to the test suite you wrote earlier
    in Mocha. I encourage you to go through the tests in detail and compare the related
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll come to the conclusion that the ideal structure for a test is a sort
    of chimera combining the easy setup of Truffle tests and the simple and direct
    code within Mocha’s callbacks. There is indeed a way to achieve this chimera,
    and it’s through JavaScript’s `async/await` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: JavaScript’s `async/await` syntax allows you to perform asynchronous processing
    through syntax that resembles that of synchronous programming—much simpler than
    that of typical asynchronous programming techniques such as callbacks or promise
    chains. If you’re interested in learning more about JavaScript asynchronous coding,
    I recommend *Secrets of the Java-Script Ninja* by John Resig, et al, published
    by Manning.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To take advantage of `async/await`, you must be running on Node.js version 8.0
    or higher. I also advise you to install Truffle version 4.0 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s how the first constructor test, which verifies contract ownership, looks
    using `async/await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Gets the deployed instance of SimpleCoin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Gets the contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Verifies the contract owner is what you expect**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, by replacing the promise chain of the initial test version
    with statements based on `async/await`, the code looks as simple as a plain synchronous
    implementation would look. You’ve achieved exactly what you were looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal (zero) `SimpleCoin` contract setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple test implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Place this test in a new file—for example, called testSimpleCoin_asyncawait.js.
    Put it in the test folder and run it as usual (removing testSimpleCoin.js and
    TestSimpleCoin.sol from the test folder before doing so, so they don’t get executed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: I challenge you to convert the second constructor test, which verifies the owner
    balance is the initial supply, from the earlier version based on a promise chain
    to `async/await` statements. Look away and write your implementation before comparing
    your solution with mine!
  prefs: []
  type: TYPE_NORMAL
- en: Have you finished? Does your test look similar to this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re still unconvinced of the benefits of moving from tests based on promise
    chains to tests based on `async/await`, I’ll show you a more dramatic comparison.
    Here’s the chain-promise-based version of a test on a successful `transfer()`
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Gets a promise of a deployed SimpleCoin instance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Gets a promise of the SimpleCoin instance after performing the transfer
    operation you’re testing**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Gets a promise of the sender balance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Assigns the sender balance to a variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Gets a promise of the recipient balance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Assigns the recipient balance to a variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, having to reference balances through promises before assigning
    them to variables makes the test rather convoluted. Here’s the equivalent `async/await`
    version of this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t this clearer? I’m so confident you can understand this version of the
    test without any explanation that I decided I didn’t need to annotate the code
    at all. If you have Node.js 8 (or higher) installed, you should definitely consider
    writing your tests with `async/await` rather than promise chains. I encourage
    you to try and convert all the chain-promise-based Truffle tests you find in the
    testSimpleCoin_ALL_sync.js file to equivalent `async/await` ones.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing a Mocha test, you must typically provide fairly complicated initialization
    code at the top of your script to deploy your contract through various steps,
    including solc compilation. Your test is placed in the callback associated with
    the contract deployment call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle is a contract development environment that simplifies contract compilation,
    deployment, and testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle performs contract deployment through migrations, based on simple configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing a Truffle test, you don’t need to provide any initialization code
    for contract compilation and deployment, but you must write tests with asynchronous
    code based on a promise chain, which might not be as readable as equivalent Mocha
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to make Truffle tests much more readable is to write them using `async/`
    `await`. But to do so, you must upgrade to Node.js 8 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 12\. Putting it all together: Building a complete voting Dapp'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Designing and implementing a voting contract showcasing most Solidity features,
    such as modifiers and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the voting contract in Truffle, for integrated compilation, testing,
    and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an asynchronous web UI seamlessly connected to the contract through
    the truffle-contract JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying onto the public test network from Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'In the previous chapter, you started to enjoy the benefits of using Truffle
    to improve the development lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Contract compilation became as easy as executing a simple `truffle compile`
    command. You didn’t have to instruct the solc compiler explicitly to push its
    output to specific files to be reused later for deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract deployment became much easier than you were used to, thanks to Truffle’s
    migrations functionality based on minimalistic configuration. Truffle did all
    the hard work of packaging the compilation output and feeding the contract ABI
    and bytecode to the deployment transaction behind the curtains. No more manual
    copying and pasting of long text!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, testing became much simpler than when you performed it through Mocha.
    You didn’t need complicated initialization to deploy the contract at each test,
    and you could keep testing logic by writing asynchronous JavaScript based on async/await.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I decided to introduce Truffle through `SimpleCoin` to focus exclusively on
    the functionality of the tool and avoid being distracted by the presentation of
    new concepts a new contract would have introduced. Also, by having you rewrite
    in Truffle the same `SimpleCoin` unit tests you had written in Mocha, I could
    compare more explicitly the advantages and disadvantages of one framework versus
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll go one step further. Now that you’re relatively familiar
    with Truffle, I believe you’re ready to take advantage of this framework to build
    an entirely new Dapp from scratch, including a smart contract, some unit tests,
    and a web UI. We’ll start gently: I’ll give you some background on what functionality
    the voting contract should provide, and I’ll help you design and implement it.
    After you’ve completed the contract, I’ll guide you through the usual steps of
    deploying it within the development environment and unit testing it. Then I’ll
    show how you can simplify the web UI of an Ethereum Dapp by importing the ABI
    from a file generated during Truffle compilation—no more copying and pasting ABI
    and addresses here either!'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is long, but I hope to keep you engaged until the end, especially
    if you’re eager to learn more. After completing this chapter, you’ll know most
    of the tool set you need to develop a Dapp from start to end. Now it’s time to
    start!
  prefs: []
  type: TYPE_NORMAL
- en: 12.1\. Defining the requirements of a voting Dapp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A voting Dapp can be simple or complex, depending on the requirements of the
    elections you wish to support. Voting can be on a small number of preselected
    proposals (or candidates), or on a potentially large number of proposals suggested
    dynamically by the voters themselves. The electorate can be made up of a small
    number of individuals, all known to the organization coordinating the elections,
    or it can include all the residents of a certain administrative area or of an
    entire country. In the latter case, a registration process might be necessary
    to run the election process efficiently and transparently. The outcome might be
    decided by simple majority: the proposal that gets more votes wins. Or it might
    require a qualified majority (or quorum): a proposal is passed only if it gets
    a minimum predefined percentage of votes. The ballot can be secret or open. The
    vote can be delegated to other individuals or kept exclusively direct. This is
    only a subset of the options and variants a voting process can include. With technology,
    the voting process can become even more sophisticated. For example, a vote could
    be split by the voter into fractions, such that each is assigned to a different
    proposal, or it could be split similarly, but with each fraction delegated to
    a different individual.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be ambitious and try to design an ultrageneric application that could
    cater to all possibilities. For our purposes, and to keep the length of this chapter
    reasonable, I’ll constraint the voting application to a limited set of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll write the Voting Dapp within a small organization. Voters, all of whom
    the organization knows, are white-listed through their Ethereum address, can submit
    new proposals during a proposal registration session, and can vote on the proposals
    during the voting session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vote isn’t secret; every voter is able to see other people’s votes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winner is determined by simple majority; the proposal that gets more votes
    wins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you might remember from [chapter 1](kindle_split_012.xhtml#ch01), even such
    a simple voting Dapp has a major advantage over a centralized one: a Dapp decentralizes
    vote processing and storing and consequently makes tampering much less likely
    than if voting was running through a centralized application.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12.1](#ch12fig01) shows the workflow of the entire voting process.
    Let’s walk quickly through it:'
  prefs: []
  type: TYPE_NORMAL
- en: The voting administrator registers a *white list* of voters identified by their
    Ethereum addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voting administrator starts the proposal registration session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registered voters are entitled to register their proposals while the registration
    session is active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voting administrator ends the proposal registration session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voting administrator starts the voting session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registered voters cast their votes for their favorite proposals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voting administrator ends the voting session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voting administrator tallies the votes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anyone can check the final details of the winning proposal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.1\. The workflow of the voting process. Some steps are performed by
    the administrator, other steps by voters.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’re eager to develop a more generic voting Dapp, at the end of the chapter
    I’ll give you a few pointers to help you step into cutting-edge e-voting territory.
    For now, though, we’ll stick with the constraints I outlined.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2\. The development plan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start to get your hands dirty, I’ll give you an idea of all the
    steps you’ll be going through to build your voting Dapp. You can get a more visual
    idea of the development cycle in [figure 12.2](#ch12fig02), but here’s a list
    of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Truffle project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and implement `SimpleVoting`, the voting contract, according to the initial
    requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and deploy `SimpleVoting` on Ganache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write and execute unit tests for `SimpleVoting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a web UI that connects to the voting contract by reading the ABI and
    contract address from Truffle’s output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the voting workflow through the web UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Dapp onto a public test network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.2\. The Dapp development plan, including all the steps, from creation
    of a Truffle project to final deployment onto a public test network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 12.3\. Starting the Truffle project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enough talking—it’s time to get started! Create a new directory within your
    Ethereum project folder—C:\Ethereum\truffle\SimpleVoting—then open an OS shell
    and initialize a Truffle project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you should get output like that shown in the screenshot in [figure
    12.3](#ch12fig03).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3\. Truffle project initialization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you’re working on Windows, remember to delete truffle.js; otherwise, delete
    truffle-config.js. Initially, you’ll be deploying on Ganache, as you did in the
    previous chapter, so make sure truffle.js (or truffle-config.js) is configured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Now you’re ready to create the voting contract!
  prefs: []
  type: TYPE_NORMAL
- en: 12.4\. Implementing the voting contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I believe you could attempt to implement the contract by yourself, based on
    the requirements outlined earlier. Why don’t you give it a go and then come back
    here later?
  prefs: []
  type: TYPE_NORMAL
- en: Are you already back? Read on. Arguably, the most important entities involved
    in an election are the proposal, the voter, and the voting workflow. Let’s look
    at how to model them.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1\. Modeling proposal, voter, and workflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A registered voter creates a proposal and adds it dynamically to the list of
    existing proposals during a proposal registration session. The `Proposal` type
    should expose a (`string`) description that its author provides and the (`uint`)
    number of votes cast against it. You don’t want to capture the author because
    they might want to remain anonymous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'What data would you like to capture about a voter? How about whether the voter
    has been registered (only white-listed accounts will be allowed to vote), whether
    they’ve already voted (to prevent double voting), and, if they’ve voted, which
    proposal they’ve voted for? Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily represent the voting workflow I described earlier in this section
    with the following enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.2\. Contract state
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As for most contracts, you’re interested in assigning a management role to
    the Ethereum address that submits the contract deployment transaction. This will
    become (at construction) the voting administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Two main processes take place from the start of the election: the proposal
    registration session, during which any registered voter is entitled to submit
    a proposal, and the voting session, which starts immediately afterwards. The voting
    administrator is responsible for starting and ending each session, presumably
    on the basis of an agreed start and end time. You’ll capture the status of the
    voting workflow with this state variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the most important state of the contract has to do with voters and
    proposals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Voter` mapping associates the voter address, which is their identifier,
    with the voter object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `Proposal` array captures the registered proposals
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The proposal ID’s array index implicitly represents it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once votes have been tallied, you want to capture the ID of the winning proposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This state variable shouldn’t be exposed directly to the Dapp users because
    its value should be revealed only after votes have been tallied, through getter
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3\. Function modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You need the state variables you’ve defined to determine the identity of a function
    caller and the status of the voting workflow. As you know, you can create function
    modifiers to check the conditions under which a function should be called. You
    could create a function modifier to check if the caller is the voting administrator
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'or they’re a registered voter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: You could create other function modifiers to verify whether voters are being
    registered
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'or whether the proposals registration session is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can implement modifiers to verify whether the proposals registration
    has ended (`onlyAfterProposalsRegistration`), whether the voting session is active
    (`onlyDuringVotingSession`) or has ended (`onlyAfterVotingSession`), or whether
    vote tallying has already taken place (`onlyAfterVotesTallied`). You’ll find all
    of these modifiers useful for simplifying the logic of the functions you’ll implement
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4\. Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because blockchain operations take a few seconds to complete from the moment
    they’re triggered, it’s useful from a user point of view to get notified as soon
    as their execution has taken place. Therefore, at the end of each action, the
    voting contract will publish an event that alters the state of the contract. This
    will also happen at every workflow status change so that clients, such as a UI,
    can update their screens accordingly. The contract will publish these events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.5\. Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At contract construction, you should identify the sender of the contract transaction
    and make them the voting administrator. You should also set the initial workflow
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.6\. Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you look back at the workflow of the voting process in [figure 12.1](#ch12fig01),
    you’ll see that the voting administrator is responsible for registering voters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The voting administrator is also responsible for starting and ending the proposal
    registration session (and, similarly, starting and ending the voting session):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, function modifiers you defined earlier have simplified the code
    so much that it has been reduced to only one line and the publishing of a couple
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the proposal registration session is active, registered voters submit
    proposals with this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Checks if the caller is a registered user and whether the proposal
    registration session is active**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Creates the proposal and adds it to the proposals array**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also in this case, function modifiers perform the hard work of checking whether
    the caller is a registered voter and whether the proposal registration session
    is active. The logic of the function itself is minimal: it creates a new proposal
    with the provided description and adds it to the proposals array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the voting session has been started, a registered voter can cast their
    vote with this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Checks that the caller is a registered voter and the voting session
    is open**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks that the caller hasn’t voted yet**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Flags that the caller has voted and records their vote**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Assigns the vote to the chosen proposal. (Note that Ethereum has
    no concurrency issue because transactions are processed sequentially on the miner’s
    EVM when a new block is being created.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the administrator has ended the voting session, they can tally the vote
    with the following function, which finds the ID of the winning proposal and assigns
    it to the corresponding state variable you defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Verifies the administrator has called the function only after the
    voting session has ended and it hasn’t already been called**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Iterates over the proposals to find the one with the higher vote
    count**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Records the array index of the winning proposal so far**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Assigns the array index of the winning proposal to the corresponding
    state variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Flags votes that have been tallied**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Publishes the change of workflow status event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s convenient to create a set of views—read-only functions that return a
    slice of the current contract state—for consumption by UI and other clients. For
    example, during and after the proposal registration session, it would be possible
    to check the number of proposals and their descriptions with these read-only functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'After votes have been tallied, it would be possible to retrieve the final results
    (winning proposal ID, description, and vote count) through the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Anyone should be entitled to check the winning proposal, not only the administrator
    or voters, so no modifiers should be present.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also convenient to write other functions to check the identity of the caller.
    For example, you could write a function that checks whether an address is a registered
    voter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'or the administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'And a view of the current voting workflow status could also be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.7\. The full voting contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can see the full contract in [listing D.1](kindle_split_033.xhtml#app0D1)
    in [appendix D](kindle_split_033.xhtml#app04). I encourage you to enter it in
    Remix and play with it before placing it under Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5\. Compiling and deploying SimpleVoting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Place the code in [listing D.1](kindle_split_033.xhtml#app0D1) (from the book
    website) in a file named SimpleVoting.sol in the following folder: C:\Ethereum\truffle\SimpleVoting\contracts.
    Now, go to the migrations folder: C:\Ethereum\truffle\SimpleVoting\migrations.
    Create a new file called 2_deploy_contracts.js and place in it the contents of
    the following listing, which I’ve adapted from the migration configuration you
    wrote earlier for `SimpleCoin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.1\. 2_deploy_contracts.js: migration configuration for SimpleVoting'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: You can now kick the compilation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'and you’ll see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re experiencing compilation issues, have a look at [chapter 11](kindle_split_024.xhtml#ch11),
    [section 11.2.3](kindle_split_024.xhtml#ch11lev2sec3), “Troubleshooting truffle
    compile errors.”
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'After a successful compilation, start up Ganache in a new OS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Then go back to the OS console you were using to execute Truffle commands and
    perform a migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 12.6\. Writing unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you should know how to write unit tests in Truffle. Bear in mind, though,
    that `SimpleVoting`’s workflow is more complex than `SimpleCoin`’s, as described
    in [section 12.1](#ch12lev1sec1). For example, actions such as registering a proposal
    or voting can happen only after the administrator has opened the related session,
    so you should aim some of your tests at verifying that these constraints are being
    respected. [Table 12.1](#ch12table01) shows a small sample of what your tests
    should cover.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12.1\. Sample of unit tests you should cover against `SimpleVoting`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Test case |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Only the administrator can register voters. |'
  prefs: []
  type: TYPE_TB
- en: '| You aren’t allowed to register the same voter twice. |'
  prefs: []
  type: TYPE_TB
- en: '| Only the administrator can start the proposal registration session. |'
  prefs: []
  type: TYPE_TB
- en: '| Only the administrator can end the proposal registration session, after starting
    it. |'
  prefs: []
  type: TYPE_TB
- en: '| Only a registered voter can submit a proposal. |'
  prefs: []
  type: TYPE_TB
- en: '| A registered voter can submit a proposal only after the administrator has
    started the proposal registration session. |'
  prefs: []
  type: TYPE_TB
- en: '| A registered voter can’t vote before the voting session has started. |'
  prefs: []
  type: TYPE_TB
- en: 'Each of these test cases generally requires that you write at least a *negative
    test* that proves an exception is thrown if the underlying conditions aren’t met,
    and a *positive test* that verifies the functionality works as expected when all
    constraints have been met. As an example, if you want to test that “Only the administrator
    can end the proposal registration session, after starting it,” you should write
    these tests (with the code shown in [listing 12.2](#ch12ex02)):'
  prefs: []
  type: TYPE_NORMAL
- en: A negative test that verifies an exception is thrown if a voter other than the
    administrator tries to end the proposal registration session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative test that verifies the administrator isn’t allowed to end the proposal
    registration session if it hasn’t started yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive test that verifies the administrator can successfully end the proposal
    registration session after it has started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listing 12.2\. testSimpleVoting.js: testing ending the proposal registration
    session'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **First negative test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **If this line is reached, it means no exception has been thrown, and
    the test should fail.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The test passes if the expected exception has been thrown.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Second negative test**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **If this line is reached, it means no exception has been thrown, and
    the test should fail.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **The test passes if the expected exception has been thrown.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Positive test, verifying successful outcome**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **The test passes if the workflow status changes to the expected value.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to run these unit tests, copy the code from [listing 12.2](#ch12ex02)
    into a file called testSimpleVoting.js in the test folder: C:\Ethereum\truffle\SimpleVoting\test.
    (I recommend you use the file from the book website.) Then you can execute them
    as usual'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see familiar-looking output, as shown in the screenshot in [figure
    12.4](#ch12fig04).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4\. Output of SimpleVoting unit tests on ending the proposal registration
    session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 12.7\. Creating a web UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The voting website needs two web pages: one for the voting admin, and one for
    the voters. You’ll create the website by going through these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the dependencies, such as required JavaScript libraries and the smart-contract
    ABI json file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a web server so you can read local JSON files from your web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the admin page HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the admin page JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the voter page HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the voter page JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the admin and voter web pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 12.7.1\. Preparing the UI dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First of all, open a new OS command shell and create a new directory for the
    voting web UI, say: C:\Ethereum\SimpleVotingWebUI. In case you didn’t install
    Bower globally back in [chapter 8](kindle_split_020.xhtml#ch08), install it locally
    in this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Now import the Web3.js and JQuery libraries into the current directory, as
    you did in [chapter 8](kindle_split_020.xhtml#ch08). This time, you’ll also install
    truffle-contract, a library that allows you to import the ABI and contract address
    seamlessly from the output of `truffle compile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'As you know, Bower will download these libraries into respective directories
    within the bower_components folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ll be able to reference these local copies of Web3.js, jQuery, and truffle-contract
    from your JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the `SimpleVoting` contract from the web UI, you need to reference
    its ABI. Truffle generates this during contract compilation in a file called SimpleVoting.json,
    which is located in this folder: C:\Ethereum\truffle\SimpleVoting\build\contracts.
    Create a folder called contracts within your web UI directory: C:\Ethereum\SimpleVoting-WebUI\contracts.
    Now copy SimpleVoting.json into it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember that when you created `SimpleCoin`’s web UI, you copied
    the ABI manually into the page JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re trying to improve the process of building a web UI, and ideally
    you’d like to import the contract ABI directly from SimpleVoting.json. But web
    browsers don’t allow you to read JSON files from your hard drive, so the following
    JavaScript will fail to execute when loaded directly from your hard drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This same JavaScript will work as expected, though, if it’s served to the browser
    through a web server. Bear in mind, Dapp web UIs are served through conventional
    web servers, so you must set one up to prepare for a realistic deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you make modifications to your contract (for example, you add a new function),
    after recompiling it (with `truffle compile`) and remigrating it (with `truffle
    migrate`), you have to copy SimpleVoting.json again from Truffle’s build\contracts
    folder to your web project contracts folder. If you shut down Ganache, when you
    restart it, the deployed instance of `Simple-Voting` won’t be present, so it’s
    best to force a new clean migration with `truffle migrate --reset` and then copy
    the SimpleVoting.json file across to your web project.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 12.7.2\. Setting up a minimalistic web server with Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can easily set up a simple web server, handling only static pages including
    plain HTML and JavaScript, using Connect and ServerStatic, two Node.js packages,
    as described in the Stack Overflow article “Using Node.js as a simple web server”
    ([http://mng.bz/oNR2](http://mng.bz/oNR2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, install them into your web UI directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a file called webserver.js with this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start up the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an initialization message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll now be able to browse any HTML page located in the SimpleVotingWebUI
    folder through an HTTP connection to localhost on port 8080\. For example, create
    a dummy page called `test.html` with this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Then access it through your browser: http://localhost:8080/test.html.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve set up a web server, you’re ready to create the SimpleVoting
    website. You’ll start from the admin page.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.3\. Writing the admin page HTML
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The admin web page should authenticate the user through an Ethereum address.
    Only the voting administrator address will be allowed to use the page.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When running against Ganache, any password will be valid. But when you move
    to a public test network, only the valid password associated with the administrator
    public address will be accepted to execute the contract functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The voting administrator will use this page to
  prefs: []
  type: TYPE_NORMAL
- en: register voters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: start and end the proposal registration session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: start and end the voting session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tally the votes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get an idea of the layout of this page from [figure 12.5](#ch12fig05).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can look at the entire HTML of this web page on the book website,
    and I invite you to download and experiment with it (SimpleVotingWebUI folder),
    I’ll highlight the most frequently recurring elements that you’ll find across
    both admin and voter pages:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript include files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table row showing current voting workflow status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrator address and password fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input fields, such as address for voter registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons triggering smart contract function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feedback message cells, to show error messages that the JavaScript validating
    the input produces or the contract returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 12.5\. The admin web page. The voting administrator will use this page
    to register voters, start and end the proposal registration session, start and
    end the voting session, and tally the votes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Javascript Includes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These are the JavaScript files that the admin.html page references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the admin page references Web3.js, jQuery, and truffle-contract
    through their respective Bower download folders. For simplicity, and to avoid
    code duplication, I’ve decided to place all the JavaScript needed by the admin
    and voter web pages in a single file called simplevoting.js. I’ll present it to
    you in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Text Displaying Current Workflow Status
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the top of the page, a row displays the current status of the voting workflow;
    for example, “Registering Voters” or “Proposal Registration Session Open:”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful from two points of view:'
  prefs: []
  type: TYPE_NORMAL
- en: It reminds the user which processing step they’re in, so it prevents them from
    attempting incorrect operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a technical point of view, the workflow description is retrieved from the
    voting contract at page load, so correct rendering confirms the contract is running
    as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrator address and password fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The page captures the administrator address and password through input fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This input is needed to
  prefs: []
  type: TYPE_NORMAL
- en: unlock the administrator account by clicking Unlock Account (If the password
    is correct, the specified account will be unlocked, and the user will be able
    to perform operations on this page for three minutes, before the account gets
    locked again.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: authenticate the account as the administrator so the user is allowed to access
    the web page functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: attach the address as the sender of the contract function calls associated with
    this web page, which are all restricted to the administrator account, so they
    can get authorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When connecting to Ganache, it isn’t necessary to unlock the administrator account
    to perform operations on the web page, but when you connect to the test network,
    you’ll have to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Other input fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Input fields also capture input specific to the functionality provided by the
    page, such as the registration of voters; for example, the field for the voter
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Buttons triggering smart contract function call
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some buttons, such as the one associated with the voter registration, trigger
    a Java-Script function (in this case `registerVoter()`), which gathers the associated
    input (in this case the voter address) and includes it in the contract call together
    with the administrator address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Other buttons, such as the one that starts the voting session, trigger a JavaScript
    function (`startVotingSession()`) that doesn’t take any input apart from the administrator
    address before creating and submitting the related contract call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Feedback message cells
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Next to most buttons is a cell to show error or success messages that the JavaScript
    validating the input or the contract call return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned previously, you can find the full HTML of the `admin.html` page
    on the book website. I encourage you to examine the code before running it.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.4\. Writing the admin page JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before starting this section, I’d like to make it clear I’ll be presenting
    JavaScript code based on asynchronous calls for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s best practice to write asynchronous JavaScript in web applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use Web3 providers recommended from a security point of view,
    such as Mist or MetaMask, they only support asynchronous calls to an Ethereum
    contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I believe that even if you aren’t familiar with asynchronous JavaScript, you
    should be able to follow this section. But if you’re struggling, I’ve also implemented
    a synchronous version of the code I’ll be presenting, which you can find on the
    book website.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: I’ll present only the JavaScript around the registration of a voter address
    by the administrator. This is an interesting use case because it requires common
    functionality needed by most administrator operations, such as JavaScript code
    that
  prefs: []
  type: TYPE_NORMAL
- en: connects to the contract on page load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: displays the voting workflow status on page load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unlocks the administrator account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: validates user input; for example, checking whether the administrator address
    is valid or whether the operation the administrator is attempting is compatible
    with the current workflow status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: executes a contract transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: handles contract events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve understood this use case, you should be able to implement the rest
    of the administrator functionality by yourself. I encourage you to do so and then
    compare your code with mine from the book website. Let’s go step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the voting contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The JavaScript code connecting the web page to the voting contract is similar
    to the code you wrote for connecting to `SimpleCoin` back in [chapter 8](kindle_split_020.xhtml#ch08).
    But, thanks to truffle-contract
  prefs: []
  type: TYPE_NORMAL
- en: The contract ABI is read directly from SimpleVoting.json, a file that `truffle
    compile` generates, with no need of hardcoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The contract address isn’t hardcoded anymore, and it’s also read from Simple-Voting.json,
    specifically from its networks dictionary; a new network entry is added every
    time ganache is restarted, whereas the contract address is updated when executing
    `truffle` `migrate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '***1*** **Network entry generated at Ganache restart**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Contract address updated when migrating (deploying) the contract**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Variable to store a reference to the deployed voting contract instance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Reads SimpleVoting.json**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **References SimpleVoting through truffle-contract, which imports the
    contract ABI from SimpleVoting.json**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Sets up Web3 to point to the local Ethereum client (currently Ganache)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I mentioned earlier in [section 12.7.1](#ch12lev2sec8), the jQuery instruction
    to read SimpleVoting.json will fail if you try to browse on the admin.html page
    directly from disk, but it will work if you browse through the website you created
    earlier on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the voting workflow status
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The voting workflow status (“Registering Voters,” “Proposals Registration Started,”
    and so on) is displayed at page load and refreshed at each status change with
    this JavaScript function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References the deployed contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Gets the workflow status ID from the contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Determines the related status description**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Binds the status description to the HTML table cell where it should
    be displayed**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you know, because the contract function `getWorkflowStatus()` is a read-only
    view, its invocation is considered a plain call and doesn’t generate a blockchain
    transaction. As a result, you don’t need to specify the caller and set other transaction
    details, such as the gas limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll call the workflow status function in two places. The first one is at
    the end of the code block setting the `SimpleVoting` reference to the instance
    of the voting contract, which happens at page load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The other one is in the event handler associated with the `WorkflowStatusEvent`
    event that the voting contract publishes at every status change. We’ll examine
    that later.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the administrator account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As you might remember, to invoke any contract function that alters contract
    state and consequently generates a blockchain transaction, you need to unlock
    the account of the caller (who becomes the transaction sender). Before performing
    any state-changing operation on this web page, such as registering a voter or
    starting the voting session by clicking on the corresponding button, you need
    to unlock the administrator account. This unlocking takes place through the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Unlocks the account for three minutes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you might recall, I’ve registered the execution of this function to the
    click event of the Unlock Account button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you must click this button before performing any state-changing
    operation. But if you prefer, you can get rid of the button and call this function
    just before any contract call that generates a transaction. For example, you could
    place it just before the contract call `instance.registerVoter()` within your
    JavaScript `registerVoter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Validating user input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As for centralized applications, it’s good practice to validate user input
    before passing it to an external function call, to avoid having bad input generate
    an exception. To implement that, the first few lines of your `registerVoter()`
    JavaScript function are dedicated to capturing user input from the HTML and checking
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Gets admin and voter addresses from the HTML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks if the specified address belongs to the administrator**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks if the specified address belongs to a registered voter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Shows validation error message**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, you can call some contract read-only view functions to validate
    the input you’re going to then submit to a transaction-generating function. You
    might also want to validate if the JavaScript `registerVoter()` function is being
    called during the correct workflow step (voter registration) to avoid contract-side
    exceptions you’ll receive if you attempt to register a voter when the proposal
    registration session has already started; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: You’ve performed substantial validation. Now you can call the contract `registerVoter()`
    with more confidence that it won’t throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might wonder whether a user might be able to hack the Dapp if they can modify
    the JavaScript and bypass the validation. This would be pointless. The purpose
    of JavaScript input validation isn’t to provide a layer of security but to avoid
    unnecessary transaction costs the user will incur when their transaction is reverted
    by contract-side validation code. For example, trying to register a voter from
    a nonadministrator account by bypassing the JavaScript performing the `isAdministrator()`
    check will end in an exception being thrown by the contract-side `onlyAdministrator`
    function modifier.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Calling a transaction generating contract function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While you’re here, I’ll tell you more about JavaScript code around the execution
    of a contract transaction such as `instance.registerVoter()`. As you know, when
    calling a function that alters contract state, you’re generating a blockchain
    transaction. In this case, you must supply
  prefs: []
  type: TYPE_NORMAL
- en: the transaction sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transaction details, such as at least the gas limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a callback to handle errors in case of unsuccessful completion, or results in
    case of successful completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see all these details in the `registerVoter()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References deployed contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Calls registerVoter function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Specifies transaction sender and gas limit. (Generally you set it
    to the lowest amount that allows transaction completion consistently, and you
    can find the value during testing.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Handles errors from the contract call**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling contract events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before leaving this section on the JavaScript of the admin page, I’d like to
    show you how to handle workflow status change events that the contract publishes.
    This would allow you to, for example, update the current workflow status description
    at the top of the page and show registration confirmations for each voter that
    the administrator adds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you must declare a variable to reference the contract `WorkflowStatusChangeEvent`
    event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'You instantiate this variable at page load, after having set the reference
    to the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References contract WorkflowStatusChangeEvent event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Registers handler with the contract event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **When the event is handled, invoke client-side function to refresh
    UI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, every time the workflow status changes, the function refreshing
    its description is invoked. The contract event that notifies a voter registration
    confirmation, `VoterRegisteredEvent()`, is handled in exactly the same way, with
    the only difference being that the UI is refreshed inline and not through a client-side
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Refreshes voterRegistrationMessage label**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.5\. Writing the voter page HTML
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The voter page, which you can see in [figure 12.6](#ch12fig06), shares many
    elements in common with the admin page. As I said earlier, the main purpose of
    the voter page is to register proposals and to vote on them. It’s worthwhile to
    highlight the proposal table, which is updated dynamically every time a new proposal
    is added by a voter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Figure 12.6\. Screenshot of the voter page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 12.7.6\. Writing the voter page JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see how the proposal table update takes place. If you have a look at
    the `register-Proposal()` function in simplevoting.js, you’ll notice many similarities
    to `registerVoter()` that we examined earlier. The main difference is that the
    event handler associated with the event that the contract fires upon proposal
    registration, `ProposalRegisteredEvent()`, doesn’t only confirm that the registration
    has taken place by refreshing the related HTML label. In addition, it calls a
    function that generates a dynamic HTML table listing of all the proposals added
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Refreshes proposal registration confirmation label**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Refreshes table listing all proposals registered so far**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the proposals table is refreshed dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 12.7.7\. Running the admin and voter web pages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you understand the code for both web pages, it’s time to run them.
    I’ll guide you through the entire voting workflow so you’ll see how the application
    works from start to end.
  prefs: []
  type: TYPE_NORMAL
- en: Preliminaries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before starting, make sure Ganache is running in a console. I suggest you start
    it with an instruction to redirect the output to a log file, which will come in
    handy later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you’ve restarted Ganache, you must redeploy `SimpleVoting` (in a separate
    console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, recopy SimpleVoting.json from Truffle’s build\contracts folder to the
    website’s contracts folder. Now you can restart the website (in a separate console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Registering voters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Browse the admin webpage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see the screen I showed you earlier in [figure 12.5](#ch12fig05).
    You might have noticed that the initial current status is “Registering Voters,”
    as expected, as you can see in [figure 12.7](#ch12fig07).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7\. The initial workflow status shown on the admin web page at startup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unless your truffle.js is configured to run the migrations from a specific
    account, they’ll be executed against `accounts[0]`, which, as you know, will become
    the voting administrator. Because you’re deploying on Ganache, look at the `ganache.log`
    file you’re redirecting the output to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Copy the address corresponding to account (0) into the Admin Address text box
    and, because you’re running against Ganache, leave the password field empty, as
    shown in [figure 12.8](#ch12fig08). You can then register the voters’ addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8\. Copying the administrator’s account into the corresponding text
    box
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because shortly you’ll be running some voter functionality, I suggest you register
    (1), (2), (3), ... from Ganache’s startup screen as voters. When registering account
    (1), you enter the corresponding address in the Voter Address text box, as shown
    in [figure 12.9](#ch12fig09).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9\. Entering the voter address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before submitting the voter registration transaction, you must unlock the admin
    account, so click Unlock Account. You’ll get a confirmation that the account has
    been unlocked. Then click Register. If everything has gone well, you should get
    a confirmation message next to the Register button; otherwise, you’ll get an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Register a few voters using the other account addresses from Ganache’s log file.
    If you do so within the next three minutes, you don’t need to unlock the administrator
    account again before registering the accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I said earlier, when running on Ganache, you don’t need to enter any administrator
    password, and you don’t even need to unlock the corresponding account, as accounts
    are all indefinitely unlocked. But it’s best to get used to the account unlock
    operation for a smoother transition to the public test network later.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: If you want to verify that these accounts are indeed registered, you can use
    the Check Registration verification area. For example, to verify that account
    (1) is a registered voter, enter the corresponding address in the Address text
    box and click Check Registration. You should see a confirmation message like the
    one shown in [figure 12.10](#ch12fig10).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10\. Checking whether an account has been registered as a voter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we move to the next workflow step, I suggest you see what happens if
    you try to
  prefs: []
  type: TYPE_NORMAL
- en: register a voter by specifying in the admin address text box a different account;
    for example, account (4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: perform an operation that shouldn’t happen at this stage; for example, you click
    the Tally votes button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should receive corresponding error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the proposal registration session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you’ve registered a few voters, you can start the proposal registration
    session by clicking Start in the related area of the screen. This will call the
    JavaScript `start-Proposals-Registration()` function, which in turn will call
    the `start-Proposals-Registration()` contract function. The contract function
    will raise the `WorkflowStatusChangeEvent` event, which the client-side JavaScript
    `refreshWorkflow-Status()` function that’s in charge of refreshing the workflow
    status label to “Proposals Registration Started” will handle, as you can see in
    [figure 12.11](#ch12fig11).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11\. After you start the proposals registration session, the Current
    Status label will be refreshed with the corresponding status description.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Registering proposals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, voters are allowed to register proposals. Open the voter web
    page in a separate browser tab: http://localhost:8080/voter.html.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see a screen similar to the one shown in [figure 12.6](#ch12fig06),
    with a small difference: the current status will be “Proposals Registration Started”
    as on the Admin page. This confirms the page is connected correctly to the voting
    contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Now register a proposal under Ganache’s account (1), who is a valid registered
    user. Enter the corresponding address in the Voter Address text box, and leave
    the password blank, as you did for the administrator. Then enter a proposal description,
    for example, “Proposal Zero.” If you want, before clicking Register, you can check
    what happens if you submit a vote at this stage (say against proposal ID = 0).
    You should get an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Now click Register. You’ll get a confirmation message next to the button. You’ll
    also see at the top of the screen the proposal you’ve entered together with the
    related ID, returned from the contract, as shown in [figure 12.12](#ch12fig12).
  prefs: []
  type: TYPE_NORMAL
- en: Keep registering more proposals, using all the accounts you’ve registered as
    voters. If you want, you can register more than one proposal against the same
    account, as you didn’t set any constraints on this. You can also check what happens
    if you try to register a proposal against the administrator account or against
    some account that you didn’t register as a user.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12\. Registering a new proposal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ending the proposal registration session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After registering a few proposals, you can end the proposal registration session.
    Go back to the admin page and, if the administrator account address is still in
    the related text box, click End in the Proposal Registration Session area. You
    should get a confirmation message next to the button and the new workflow status
    in the Current Status area, as shown in [figure 12.13](#ch12fig13).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13\. Ending the proposal registration session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-13_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As usual, you can try to attempt actions that aren’t supposed to take place
    at this stage. For example, try ending the voting session.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Voting session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Time to start the voting session! Click Start corresponding to the voting session,
    and the Current Status description at the top of the screen will change accordingly
    to “Voting Session Started.”
  prefs: []
  type: TYPE_NORMAL
- en: Voting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Go back to the voter’s screen. You’ll see that the status at the top of the
    screen has also changed to “Voting Session Started.” This confirms that it has
    been refreshed by the `WorkflowStatusChangeEvent` event that the contract published
    at the end of the `startVotingSession()` function and the voter’s page JavaScript
    handled. At this point, you’re allowed to vote.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the address of one of the voter accounts in the Voter Address text box,
    and then put one of the Proposal IDs you see at the top of the screen in the Proposal
    ID text box. Then click Vote. You’ll see a confirmation message next to the Vote
    button. If you try to vote again, you’ll see an exception from the voting contract
    that’s preventing you from voting twice. Continue by casting various votes from
    the accounts you registered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the voting session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After you’ve voted from various registered accounts, you can end the voting
    session the same way you started it: go back to the admin page, move the mouse
    in the Voting Registration area, and click End. As usual, you’ll see a confirmation
    message and a change of state at the top of the screen. If you now try to go back
    to the voter page and cast a vote through a registered account that you didn’t
    use, you’ll be prevented from voting.'
  prefs: []
  type: TYPE_NORMAL
- en: Tallying the votes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s the moment of truth: time to tally the votes! On the admin page, click
    Tally Votes. Apart from the usual confirmation message and status description
    stage, you’ll see a new table appearing at the bottom of the screen summarizing
    the vote results. The handler of the `WorkflowStatusChangeEvent` event has generated
    this table, with a specific check on the status ID corresponding to votes tallied.'
  prefs: []
  type: TYPE_NORMAL
- en: If you flip back to the voter page, you’ll see the same results table at the
    bottom of the screen, as you can verify in [figure 12.14](#ch12fig14). The same
    table appears because both pages were listening to the same event.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14\. The voter page after the votes have been tallied
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig12-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve designed, implemented, tested, and run a full voting
    Dapp. You should consider this an important achievement. It’s the first time (in
    the book) you’ve built a complete Dapp from scratch, covering all the layers from
    the smart contract to the web UI. You’ve come a long way from [chapter 1](kindle_split_012.xhtml#ch01),
    when you started to learn about new concepts, such as blockchain and Dapp, and
    experimented with a simple embryonic version of SimpleCoin. Now you should have
    a good understanding of smart contracts, how to write them in Solidity, how to
    communicate with them with Web3.js, and how to create a simple web UI to interact
    with them in an easier way. Before leaving the chapter, you’ll deploy the Dapp
    into the public test network and check that everything is still working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.8\. Deploying to the public network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are the steps you must take to deploy SimpleVoting onto Ropsten, the public
    test network:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop Ganache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start geth, configured to point to Ropsten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Truffle to point to the Ropsten network and deploy from one of your
    Ropsten accounts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlock the Ropsten account you’ll use for deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a Truffle migration to Ropsten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the UI still works correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stopping Ganache
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You should be able to do everything pretty much by yourself but, just in case,
    let me walk through these steps with you. Start with an easy one: press CTRL+C
    or close down the Ganache window.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting geth on Ropsten
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You’ve done this a couple of times already, but I’ll save you some page flipping.
    You can see in the following code the full command to connect to Ropsten through
    some seed nodes, including the option to perform a fast synchronization, in case
    you haven’t been connected to the test network for a while. Also, I’ve highlighted
    the last two parameters, which open geth’s communication through RPC on port 8545
    and allow cross-origin resource sharing (CORS) so that the JavaScript of your
    web page will be allowed to communicate directly with geth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If your geth client doesn’t seem to synchronize with the public test network,
    attach a console to geth and manually add the Ropsten peers specified on this
    GitHub page: [http://mng.bz/6jAZ](http://mng.bz/6jAZ).'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Configuring Truffle to point to Ropsten
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the previous chapter, I explained how to point Truffle to a test or live
    network. Modify your truffle.js (or truffle-config.js) file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Matches the port open on geth for RPC communication (as noted previously)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Replace this account with the Ropsten account you want to use to
    deploy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **This should be enough gas to deploy SimpleVoting.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the Ropsten account you choose to deploy SimpleVoting has some (test)
    Ether in it!
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the account used for deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To unlock the Ropsten account you’ve specified for deployment, start by opening
    a new console and attaching it to geth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the geth JavaScript console has started, unlock the deployer address (for
    300 seconds) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Performing a Truffle migration to Ropsten
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To perform a migration on a network other than the development one, you must
    provide it explicitly through the `--network` option (on a separate console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Make sure your geth client is fully synchronized with Ropsten before attempting
    this operation. You can check the latest Ropsten block against [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/)
    and compare it with what you see on your client’s console.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'If your geth client is actively connected to Ropsten and you’ve configured
    everything correctly, you should see some output confirming that deployment has
    taken place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Checking the UI still works
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you look back at the first lines of simplevoting.js, the initialization
    looks at a `web3` provider coming from `localhost:8545`. Geth is exposing to RPC
    the same port number that Ganache was previously exposing, so everything should
    still work, right? Let’s find out! First of all, copy the new SimpleVoting.json
    from Truffle’s build\contracts to the website contracts folder. Then try to browse
    on admin.html as you did previously. (Make sure the website is still running;
    otherwise, restart it with: `node webserver.js`.) Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Yes! The page loads correctly, and it shows the initial “Registering Voters”
    status as expected. You can now go through the whole workflow, from voters’ registration
    to vote tallying, as you did when running on Ganache. Before doing so, make sure
    the TESTNET admin and voter accounts have enough Ether to perform the related
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Bear in mind that when you perform operations on TESTNET, you must unlock the
    related account at each operation. Also, every time you perform an operation,
    from either the admin account or a voter account, you’ll have to wait for the
    related transaction to be mined, so it will take longer (around 15 seconds) to
    receive confirmations.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your UI seems unresponsive and you don’t get a confirmation that the operation
    you attempted completed, check potential errors on the console of your browser’s
    development tools. For example, on Chrome, you can click F12 and then select Console
    from the top menu. If the issue is related to account unlocking, it might be due
    to changes in Web3 around this area. If that’s the case, you can unlock the administrator
    or the voter account from an attached Geth console, as you’ve seen in previous
    chapters, rather than using the Unlock Account button.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 12.8\. Food for thought
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I hope you’ve found this chapter useful for tying together all you learned
    in the previous chapters. At this point, you should feel confident you can start
    building your own Dapp, and you should be geared up to take on a new challenge.
    If you’re eager to practice your newly acquired skills a little more before moving
    on to the next chapter on advanced topics in contract design and security, I’ve
    prepared for you a little plan you can use as a springboard for improving SimpleVoting.
    I have two sets of improvements in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.8.1\. Possible technical improvements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I designed SimpleVoting with the main objective of presenting the full Ethereum
    Dapp development lifecycle in one shot, so I decided to keep it as simple as possible
    to focus mainly on the big picture. Also, I understand that not all readers have
    the same background and experience in web development and continuous integration,
    so I avoided introducing relatively advanced techniques in either of these areas.
    If you’d like to improve the web UI, there’s room for improvement in various respects,
    including these two:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a standard Web3 provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating build and deployment with a web build tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a standard Web3 provider
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Your application shouldn’t be served through a plain web browser, but through
    a standard Web3 provider, such as Mist or MetaMask, that provides enhanced security.
    These providers require you to call contract functions asynchronously, though,
    so reimplementing your SimpleVoting.js using asynchronous features would also
    be beneficial for this reason. After you’ve reimplemented your JavaScript code
    accordingly, you can detect a standard provider by replacing this line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Uses standard provider (such as Metamask or Mist) if available**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Instantiates default provider if none is available**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you supply a standard provider? First, remember to log in. Then, assuming
    you installed the MetaMask browser plugin, as explained in [chapter 3](kindle_split_014.xhtml#ch03),
    make my suggested code change at the top of SimpleVoting.js, and finally browse
    on the admin or voter page. By doing this, the Web3 provider will be set to MetaMask.
  prefs: []
  type: TYPE_NORMAL
- en: Automating build and deployment with a web build tool
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you have experience in using web build tools, you might have found it a bit
    annoying to copy SimpleVoting.json from Truffle’s build\contracts to the web project
    contracts folder every time you made a change. You might be wondering whether
    Truffle supports a build pipeline. It does, and, in fact, you can plug in your
    favorite build tool, such as Webpack or Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: The Truffle documentation website also includes a Webpack Truffle Box ([https://truffleframework.com/boxes/webpack](https://truffleframework.com/boxes/webpack)),
    which is a template project developed with Webpack support. You can use it as
    a base to build your Webpack integration, or at least to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.2\. Possible functional improvements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The current voting application is intentionally limited from a functional point
    of view. After the admin registers the voters (one by one), voters can register
    (potentially many) proposals and then vote on one of them. The winning proposal
    is decided based on simple majority: the one that gets the most votes is chosen.
    Also, you’re recording the proposal that each voter chooses, so there’s no anonymity.
    Here are some ways you could enrich the voting Dapp functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the admin to register voters in bulk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow a voter to delegate their vote to another registered voter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide the winning proposal with a qualified majority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement token-based voting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement anonymous voting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering voters in bulk
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The admin could register voters in a single bulk registration, rather than one
    by one, saving on administrative time and transaction costs. You could implement
    this enhancement with a new function taking in an array of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Delegating votes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A voter could delegate their vote to another registered voter. Then the delegator
    wouldn’t be able to vote, and the person delegated would cast as many votes as
    they’ve been delegated to cast by as many voters.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some hints on how to start the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could change the voter struct as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You could add a new function so that the caller can delegate their vote to
    another registered voter. This would be similar to `SimpleCoin`’s `authorize`
    function to allocate an allowance to another account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function’s implementation should alter the state of both delegator (`CanVote
    = false`) and delegated (`NumVotes +=1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check easily whether a voter is still entitled to vote, you could implement
    a `canvote` modifier around the `CanVote` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding the winning proposal with a qualified majority
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You could introduce the concept of a qualified majority. To win, a proposal
    should reach a predefined quorum: a minimum percentage of the cast votes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’d introduce a new variable defining the quorum, initialized in the constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’d modify the `tallyVotes()` function so the winning proposal would set the
    winner only if the quorum was reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing token-based voting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The current voting Dapp allows a voter account to increment the vote count of
    one of the proposals. This creates strong coupling between the voter and the chosen
    proposal, which can be slightly softened through vote delegation. In addition,
    the delegated voter will assign the entire vote of the delegator to a single proposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting concept that has appeared in the crypto space is that of token-based
    voting. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Each voter is assigned a voting coin or token, similar to our dear `SimpleCoin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The voter then casts a vote by transferring the voting token to the proposal
    address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because a vote has to be “spent,” this would prevent double voting. Things
    could get more sophisticated. A voter could, for example, do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Transfer the voting token entirely or partially to one or many other voters
    through a transfer operation similar to that you’ve seen in `SimpleCoin`. (You
    could look at this as fractional delegation of the original vote.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vote for one or many proposals, by assigning them specific fractions of the
    initial token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could build a token-based voting Dapp by implementing a voting token (along
    the lines of `SimpleCoin`) and then integrating it into the voting contract in
    the same way you integrated the crowdsale token in the crowdsale contract.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous voting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you might remember, you’re recording the proposal ID that each voter chooses
    in the `votedProposalId` property of the voter struct. If you think you could
    implement anonymous voting by not recording the proposal chosen by the voter and
    by incrementing its vote count, you’re wrong. As you know, votes are cast through
    transactions, which are all recorded in the blockchain and can be inspected, so
    it would be easy to find out who voted for which proposal.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymizing voting is possible, but it’s complicated because there’s no out-of-the-box
    functionality for anonymizing transactions. This is a complex topic based on advanced
    cryptographic concepts such as *zero-knowledge proof*, which you might have heard
    associated with popular cryptocurrencies such as Zcoin, Zcash, and Monero.
  prefs: []
  type: TYPE_NORMAL
- en: Some researchers at Newcastle University, UK, have implemented an Ethereum anonymous
    voting Dapp based on a protocol called Open Vote Network. They’ve made both their
    paper and their code publicly available on GitHub,^([[1](#ch12fn01)]) together
    with a video tutorial and many academic references on the topic. I recommend you
    review this material!
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Open Vote Network” on GitHub at [http://mng.bz/nQze](http://mng.bz/nQze)
    for more information.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SimpleVoting Dapp smart contract shows an effective implementation of predefined
    requirements, based on events and modifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build a web UI based on truffle-contract, a JavaScript library that
    easily connects a web page to a contract that has been previously deployed using
    Truffle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The truffle-contract library reads the contract ABI and address from a JSON
    file generated during Truffle contract compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read the contract ABI and address from a JSON file, you must render a web
    page through a web server. You can set up a minimal web server through Connect
    and ServerStatic, two Node.js packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve implemented a Dapp, unit tested it, deployed it, and run it successfully
    against Ganache, a mock Ethereum client, you can deploy it on a public test network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
