# 1 分布式账本技术

分布式账本技术（DLTs） enable an innovative special form of electronic data processing and its memorizing. As the main part, a distributed ledger is a decentralized database that allows all the members of a concerned network to read and write data in it. Unlike centralized databases, no central instance allowing data writing and reading is needed here. Instead of having a centralized control, any network member can add data anytime, after which a process of data actualization follows. Each network member is provided with the newest up-to-date state of a database.

随着 DLT 降低信任成本，革新个人、公司和政府之间的交易，并将成功的欺诈、错误可能性降到最低，以及减少依赖纸张的流程，它们被认为是未来的进步技术。它们在各个方面对社会产生重要影响，特别是在物联网（IoT）的基本技术之一——机器对机器（M2M）通信方面。除了提供安全性、隐私性和去中心化操作外，DLT 还代表现在和未来可靠的、自主的、可信赖的 IoT 平台。

DLT 遵循一种新的跨多个账本（数据存储）的数据记录、共享和同步方法。分布式账本（DL）是一个由大型网络中的每个节点（或参与者）独立创建、维护和更新的数据库。分布式账本的所有记录通过网络中节点之间的共识共享和同步。这个过程不依赖任何中央权威。因此，每个网络节点都拥有与其他节点相同的账本副本。每次账本需要用新记录更新时，节点之间达成共识就会在所有节点上获得相同的副本。这种同步过程非常快，因此节点账本的变化会在几秒钟（或许几分钟）内复制到其他节点的账本中。

加密签名用于保护账本内容的访问，因此所有 DL 数据都是准确和安全的。在许多情况下，为了成功进行网络攻击，攻击者必须同时针对大多数 DL 副本。此外，如果一个或几个副本被损坏，整个系统将不会受到影响。

任何节点都可以创建一个数据块来更新实际的账本。然后，信息（创建的块）在网络中广播，之后其他节点通过共识机制验证其有效性，即预定义的验证方法。社区（即网络节点的有效多数）验证新块后，每个节点，即参与者，将其添加到其账本副本中。

关于共识机制，有几种类型，比如工作量证明（PoW）、权益证明（PoS）、空间证明（PoSpace）等。PoW 可以是解决一个数学问题或谜题，或者是通过适当哈希函数的迭代执行找到的合适哈希值。

通过 PoS 实现的共识是一个过程，只有拥有足够高权益的参与者，即富有的成员，才能验证新块。他们在他们的账户上有许多具体 DL 的本地代币（加密货币）。PoS 概念基于这样一个想法，即如果每个人都能执行块验证，网络中的信任度（以及代币的价值）就会降低，这进而增加了验证非法块的可能性。因此，唯一保持系统信任的方式是将块验证留给可能会因不负责任行为而损失很多钱的成员。关于能源消耗，PoS 比 PoW 更快、更有效（但不如 PoW 那样经过验证）。

在 PoSpace 概念中，矿工计算机硬盘上可用的空间（内存）是用于采矿的资源（而不是 PoW 中使用的计算能力）。它也被称为容量证明（PoC）。与 PoW 相比，这个概念也节省时间和能源。PoSpace 是防止垃圾邮件和预防 DDoS 攻击的好解决方案。它也可能有助于防止采矿权力在矿池中的集中。

DL 有两种类型：公共和私有，这取决于他们依赖的对等网络（P2P）。基于某些实体的控制，还有两种类型的 DL：无需许可和需要许可。在无需许可的 DL 中，网络的每个节点都托管着完整且最新的账本副本。账本更新的每一个新块（添加新块）都通过网络中的所有节点进行传播，然后集体通过遵守共识机制来验证新块。接受验证后，新块将添加到每个节点的账本副本中。这样保证了网络中的数据一致性。这意味着无需许可的 DL 是完全民主的，没有中心控制，前提是每个参与者都遵循预定义的规则。然而，在需要许可的 DL 中，一个中心实体授予节点访问网络和修改账本的权限。同时，中心实体还可以验证尝试访问网络的参与者的身份。

由于有许多 DLT 应用促进了自动驾驶，本章将考虑基本的 DLT 架构及其特性，以及这些技术在自动驾驶车辆概念中的几个用例。

本文剩余部分将考虑三种基本的 DLT 架构来比较 DLT 特征：链或列表、有向无环图（DAG）作为纠缠、以及 DAG 作为树。链或列表的典型代表是区块链，它是比特币（BTC）的基础，比特币是最古老和最广泛使用的加密货币，由 2008 年的中本聪发明 [1]. DAG 是一个没有有向循环的有限有向图，由许多有限顶点和边组成。每条边都是从一个顶点指向另一个顶点，但没有反向循环。纠缠是有向无环图的基础，是 IOTA 的基础，IOTA 是与 BTC 的主要竞争对手之一，特别是在机器对机器通信领域。IOTA 于 2015 年由 David Sonstebo，Serguei Ivancheglo，Dominik Schiener 和 Serguei Popov [2] 创立，自 2017 年以来正式作为 IOTA 基金会运作。DAG 作为树的架构是最新型的 DLT，是所谓的哈希图的基础。哈希图是一种记录了关于谁与谁闲聊以及顺序的数据结构。美国教授 Leemon Baird 在 2016 年发明了哈希图 [3]。

## 1.1 数字货币 – 加密货币

DLTs 在金融领域被广泛应用，作为加密货币或加密货币。如今，全世界正见证加密货币真正的淘金热。许多涉及所谓轻松赚钱业务的人了解加密货币是如何运作的。然而，其他人提出了一个简单的问题：“如何可能从无中赚取真正的钱？”有人开玩笑地将加密货币与一些现代物理学家的假设相比较，即整个宇宙来自无。所以，如果这对宇宙适用，为什么不能应用于加密货币呢？

这些是最常被问到的问题：“整个系统是如何仍然运作的？”，“这是一种欺诈吗？”，“它会持续多久？”，“在没有最高权威保证的情况下，人们为什么相信数字货币？”，“整个事情以及与之相关的狂热只是基于人类贪婪的众多经济泡沫之一，随着机制的增长而不可避免地最终崩溃？”等等。

然而，许多金融专家预测加密货币的美好未来和 DLTs 的进一步发展。他们表示，这将使众多服务如绝对信任、安全和透明度成为可能，为拥有高水平的正义、没有犯罪和腐败的社会指明方向，即许多乌托邦主义者仅能梦想的社会。

让我们回忆一些关于货币的事实：人类最早的经济交易是以某种物质（比如铜、银或金）的碎片形式进行的，这些物质本身就有价值。例如，黄金（现在仍然）是一种贵金属，因为它具有多种应用的特性。因此，人们（现在仍然）认为黄金的价值可以兑换成其他商品，即用于交易，同时意识到它可以被制成有用或美丽而珍贵的物品。这里的关键词是信任，即对被称为硬币或货币的物品价值的信仰。

对硬币的这种信仰可能会（在历史上的很多次）因为铸造含有其他价值较低的材料（往往未知）的硬币而受到威胁，从而使不公平的交易和欺诈行为变得可能。自然演化的一个步骤是确保一个社区中每种使用的货币都等于其标称价值。只有少数强大的中央权力机构才能获得这种保证（例如，皇帝、国王、政府和社区统治者等其他社区领导者）。保证机制是基于货币生产的垄断、权威的力量和声誉以及采取的措施（使用当时先进的技术）使普通人难以伪造货币。如果上述条件在一定程度上得到满足，可以说社区中存在一种非正式的协议，即某种货币可用于交易。在这里应该记住与真实货币相关的关键词是中央权威和其声誉。

货币是一个动态的分类，其价值可能因许多因素（例如，通货膨胀）而有很大变化。并非总是需要所有条件才能对货币价值达成普遍共识。在某些地方的历史上，曾有一些特定情况，那里没有中央权力机构保证货币的价值。然而，由于自然中发现的事物或物品的独特性或稀有性，交易手段的信任仍然得以实现，例如熊爪或贝壳。

一个有趣的例子是在一些偏远的太平洋岛屿上，使用巨大的不可移动的圣石作为货币。每次部落成员之间的交易后，这些石头就会易手。每块石头的所有权都在上面刻有类似账本的文字（文字显示与今天的账本有相似之处）。

将加密货币与纸币货币并行讨论并区分是有用的。单就其本身而言，一张纸几乎没有任何价值。然而，银行券，这些纸片有着确定的价值，因为一个国家的中央银行，发行它们的权威机构，通过其资产或黄金储备，甚至通过它们国家的声誉，对这些银行券进行担保，即每张银行券都可以兑换一定价值的黄金或其他物品。每张银行券应该代表银行在金库中保存的一定量的黄金，从最初开始就是这样。但是众所周知，很长一段时间内，许多货币（包括美元、英镑和欧元）都没有黄金支持——它们被称为法定货币。尽管事实如此，这些货币在其市场上（或多或少）还是同时具有价值。对一种货币的信任通常取决于该国经济的实力、声誉和其他许多因素。加密货币与法定货币价值的相似之处在于，它们的价值都是基于对系统的信任，而维持这种信任的机制则不同。

近年来出现了另一种新现象：许多国家不再使用纸币和硬币。现在，广泛采用塑料或虚拟货币（通过借记卡、信用卡和设备），而真实货币则没有更多的物质代表。然而，它作为信息存储在持有客户账户的银行的计算机系统中。从他们那里，银行以他们的声誉（作为公认的权威）保证，存储在账户状态上的客户信息是真实的。

考虑到以上暴露的所有事实，我们可以认为加密货币并不那么奇怪。甚至更多——它们可能看起来是货币故事中的下一个自然演变步骤。

## 1.2 区块链

区块链是一个可靠的交易注册（或账本）系统，包含了截至目前为止的所有交易。它是一个庞大且持续增长的文件，由一系列称为区块（或交易区块）的记录组成，每个区块列表中的区块都通过密码学与前一个和后一个区块链接（即链式链接）（见图 1.1）。关键条件是，除了交易数据外，每个区块都有一个包含前一个区块头部的密码学散列值的头部，一个与交易相关的时间戳，以及六个其他字段（如果涉及到比特币区块链 1；（见图 1.2）。

![](img/b_9783110681130-001_fig_001.jpg)

图 1.1：BTC 区块链——线性拓扑。

![](img/b_9783110681130-001_fig_002.jpg)

图 1.2：BTC 区块链中一个区块的结构及其与下一个区块的连接。

假设一个比特币区块链（仅是使用区块链技术的众多加密货币中的一种）记录了人们所做的一切比特币交易。换句话说，区块链就是一个具有精确可靠数据的金融账本，包含社区成员之间自始至终的所有货币交易（比特币交易）。或者更简单地说——区块链是一个可靠的交易注册表（账本），包含了直至此刻的所有交易。这是一个庞大且持续增长的文件。例如，一个比特币区块链（每种加密货币都有自己的区块链，就像比特币一样），现在，有几百 GB 的大小，并记录了人们之间的所有比特币交易。

整个系统的关键点是，没有人能删除或修改这些交易，这也是区块链成为热门话题的主要原因。它提供了记录数据的绝对持久性和可靠性，因此，没有黑客能进入这个区块链数据库，更改例如约翰·史密斯拥有 20 个比特币的事实。比特币具有这样的属性，是由两个最重要的因素实现的：

1.  去中心化

1.  与区块链结构紧密相关的交易验证算法

去中心化的概念是在全球许多计算机中存储所有交易（区块链）时实现的，其中每台计算机（称为节点）都包含一个完整的区块链文件（与其他任何节点的区块链文件应该相同）。与集中式银行系统不同，在集中式银行系统中，每家银行在其服务器上保留客户的交易数据（得到很好的保护和备份），存储区块链的节点属于世界各地的普通人，他们自愿参与这个分布式账本（DL）。这里既没有中央权威机构，也没有中央注册机构来保存数据。拥有节点计算机的人们彼此独立，只不过他们的计算机托管了维护区块链的节点。节点总是通过节点间通信协议连接，从而创建一个全球点对点（P2P）网络。然而，这个网络就像运行在互联网上的任何其他 P2P 网络一样。

每个节点硬盘上都保存着区块链文件的副本。此外，一些节点（矿工）还可以验证世界上任何两个人之间的最新交易（例如，比特币交易）。此外，还有许多其他计算机只有交易验证功能。它们也被称为矿工，尽管它们不是节点。

让我们以以下示例为例：A 想要向 B 发送 100 欧元（以比特币计）：起初，A 的计算机（或智能手机）向网络中的所有矿工宣布 A 想要将 100 欧元发送给 B。此刻，这被称为无效交易，且尚未记录在注册表中。

矿工接下来要做的第一件事是检查 A 是否拥有足够的资金（至少 100 欧元，还要有一些备用金）。现在，矿工通过遍历整个区块链，查看 A 所进行过的所有交易，并计算是否有足够的资金可用。由于没有账户状态这样的分类，A 所拥有的资金总是基于 A 到那一刻所进行过的所有交易再次计算。这是一个非常有益的特性，使区块链更加安全。如果有人想操纵另一个人的账户，他们必须改变过去的交易，这是不可能的。

完成了（相对容易）的第一步，也就是确认 A 的偿付能力之后，第二步，也是更难的一步，紧随其后。在那里，矿工彼此竞争：胜者是第一个成功嵌入新交易的人；也就是说，把它附加到区块链的末尾。

到目前为止，只提到了一个特定的交易（A 和 B 之间的交易），作为唯一需要验证并添加到区块链的交易。实际上，要附加到 BTC 区块链末尾的区块平均包含来自世界各地的 1,500 笔交易，这些交易是在十分钟内积累的。一般来说，对于不同类型的区块链（除了 BTC 区块链），新块出现的频率是不同的，所以有些区块链上甚至每五秒钟就会出现一个交易区块。

每个区块的交易数据（BTC 区块链）包括最新的有效交易，从而限制了区块的大小为 1MB（尽管在使用隔离见证协议升级（[4]）从 2017 年 8 月起，区块限制已扩展到 4MB，但出于实际考虑）。交易中的参与者身份在交易前使用他们的私钥进行加密。区块中的所有交易都通过一种被称为哈希树或默克尔树（[5）的加密方案进行哈希。哈希的 256 位长结果，即默克尔树的根，也放入区块头部。

区块之间的链接使区块链实际上变得不可破解，因为每个区块都包含前一个区块头的哈希值。关键在于名为 nonce（一次使用的数字）的 32 位区块头字段，其值是全球所有矿工每十分钟尝试猜测的，以便在区块链上添加一个新块（如果成功，则获得奖励）。一旦新的区块被添加到区块链上，那个区块的所有交易都被认为是验证过的，矿工们会立即开始为下一个交易区块寻找新的 nonce。第一个验证这些交易的矿工（猜测前一个区块的 nonce 的正确值）会获得奖励。在 BTC 区块链上，奖励由两部分组成——第一部分是交易费，由刚刚验证的区块中的货币交易发送者以 BTC 支付，第二部分是从无中产生的特定数量的新的 BTC。

什么是正确的 nonce 值？并没有这样一个值，也就是说，没有预先设定的具体值。更具体地说，算法被设计成，要实现的目标是将区块链上最后一个已验证区块头的哈希值调整得足够小，也就是要小于或等于给定的数字（目标）。这实际上意味着这个哈希值，即要放入下一个（即最新的）区块头的值，以几个零开头。通过逐次增加 nonce 的值并计算新的哈希（完整的区块头）来调整哈希值。每次新的 nonce 计算一次新的哈希。当当前计算的哈希满足给定条件时，过程停止。

了解加密哈希函数的特性（在 BTC 的情况下，使用 SHA-256 算法，即哈希值为 256 位长），很明显，猜测具有给定前导零的哈希的概率极其小（在一次尝试中）。如果目标（对于给定的难度级别）是计算一个哈希值，例如，前 72 位为零（或十六进制表示：hash = 00000000 00000000 00xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx），假设哈希值均匀分布，一次尝试成功的概率将是 2^(-72) = 1/4,722,000,000,000,000,000,000。由于概率如此之小，对于专门的挖矿计算机（例如，每秒处理能力为 16 Thash/s）来说，单纯找到 nonce 和哈希的获胜组合需要的时间可能超过九年，粗略估计！然而，平均而言，每十分钟就会在区块链上添加一个新块。这是如何实现的呢？

答案在于全世界矿工计算机联合起来的巨大处理能力。确切的 BTC 矿工人数难以确定，因为它总是在变化，呈现增长趋势。当它们不挖 BTC 时，许多矿工还用他们的计算机去挖其他加密货币，少数矿工则是偶尔挖矿，例如，在矿工的计算机不用于玩游戏的时间间隔。最终，矿工的确切人数并不重要，因为他们的计算机处理能力不同。另一方面，这全取决于矿工投资硬件的意愿，以及所有电力等费用。

如今，大量的矿工聚集在挖矿池中，因为他们意识到单独挖矿是没有利润的，因为区块的验证过程会花费太长时间。挖矿池是矿工的联合团体，能够获得更频繁验证交易块等优势。池中的矿工根据他们对池贡献的挖矿能力分享成功验证的奖励。除此之外，大多数 BTC 挖矿都是在大型的、有恒温调节的数据中心和仓库中使用 Application Specific Integrated Circuits (ASICs) 进行的，这些地方电力成本低。这些仓库的拥有者将处理资源租给矿工。

随着全球挖矿力量的日益增长，预计区块验证的频率也会增长，BTC 的发行速度也会加快。但是这些还没有发生，这是因为应用的算法被称为难度（Difficulty），它调整了解决验证问题的难度级别。该算法使平均区块验证频率几乎保持恒定。大约每 10 分钟在区块链上添加一个新块，更精确地说——在两周内，应该在区块链上添加 2016 个块。每两周，根据总挖矿力量和交易数量的统计，算法会改变区块头字段名为难度目标（Difficulty target）的值（见图 1.2）。

32 位难度目标字段的价值（稍微复杂一点）对应于找到哈希的难度，足够小以满足区块验证的条件。前面提到过，验证区块中写的哈希值必须小于或等于一个给定值，称为目标值（在图 1.3 中称为 X）。还定义了一个参考值，称为难度 1 目标（difficulty_1_target），用来表示 256 位数字，其中前 32 位为零，接下来 16 位为 1，其余为零，或者用十六进制表示：

<math alttext="" altimg="../graphic/b_9783110681130-001_ineq_001.png"><mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mo>=</mo></mtd><mtd><mn>00000000</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0000</mn><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>

![](img/b_9783110681130-001_fig_003.jpg)

图 1.3：在 BTC 区块链末尾添加新块。

(1.1)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_001.png"><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mrow><msub><mi>f</mi><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub></mrow><mo>×</mo><msub><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></mrow><mo>×</mo><mrow><msup><mn>2</mn><mrow><mn>2

一个名为难度（Difficulty）的参数定义为：

(1.2)<math alttext="Difficulty=difficulty_1_target∕target_value" altimg="../graphic/b_9783110681130-001_eq_002.png"><mrow><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mo>=</mo><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mrow><mo>/</mo></mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></math>

因此，它显示了找到一个哈希值低于当前目标值比找到一个哈希值低于`difficulty_1_target`更为困难多少倍。难度是一个浮点值，在区块头的难度目标字段中，它由目标值的小数点和指数表示，其中前 8 位是指数。剩下的 24 位是尾数。例如，如果目标值（用十六进制表示）是“17**2*f*4*f*7*b***”，则应使用以下预定义公式来计算哈希的目标值：

目标值 \( target_value = 2^{28} \cdot 17^{-3} \cdot hex(2f4f7b) = 0x... \)

（1.3）\( 00000000 00000000 00 2f4f7b00000000 00000000 \)

利用（1）和（2），我们可以得到难度 \( Difficulty \)（十进制）的结果：

（1.4）\( D_i ffciul ty = 5,949,437,371,609 \) ，约等于 \( 5.95 \times 10^{12} \) 或 \( 5.95 \times 2^{32} \) 的 \( 0.53 \) 倍。

可以通过难度 \( Difficulty \) 计算目标值 hash 的前导二进制零的数量：

（1.5）\( \text{Number of leading zeros} = \log_2(Difficulty) + 32 \)

在这个例子中，结果是 74.44。这也可以从（3）中目标值 \( target_value \) 的十六进制表示看出，前 18 个字节（4 位块）表示 72 个二进制零，下一个字节 \( 2[(hex)] = 0010[(bin)] \) 又增加了两个零，总共给出了 74 个前导零。

假设我们想要确保每 10 分钟验证一个区块。在这种情况下，Difficulty 应相对于整个比特币网络的计算能力进行调整，以便能够实现目标，即找到一个散列值低于或等于目标值所需的目标平均时间是十分钟。每秒的散列操作次数（称为散列功率或散列率）可以从 Difficulty 以下方式导出和计算：

（1.6）\[Hash_rate=\frac{N(Difficulty)}{10min}\]

其中{*N*(Difficulty)}是在给定 Difficulty 下找到一个有效散列的期望尝试次数：

（1.7）\[N(Difficulty)=\frac{2^{256}}{targe_t\_value}\]

通过结合（2）、（6）和（7），我们得到：

（1.8）\[H_a\]sh\[a\]rt\[e\]=\frac{1}{10m i n} \cdot \frac{2^{256}}{d i f f i c u l t y_{1_t a r g e t}}=\frac{1}{600s} \cdot \frac{2^{256} \cdot 2^{224}}{D i f f i c u l t y} \cdot D i f f i c u l t y=\frac{D i f f i c u l t y \cdot 2^{32}}{600s}

例如，如果难度为 5.95 T，使用(1.8)，哈希率为 42,587,731,567,771,900,000 哈希/秒，即 42.6 每秒艾哈希（42.6 EH/s）。在相同的难度下，一台具有 16 TH/s 处理能力的计算机应该需要大约 50 年的时间来找到一个解决方案（时间=600 秒×42.6EH/s / 16TH/s）。

这个巨大的难度使得找到一个特定沙粒比找到一个成功哈希更容易。由于适当的哈希能力，矿池大约十分钟内可以找到一个解决方案。然而，缺点是（电）能源消耗巨大。目前，全世界比特币矿工的总耗电量等于一个发达国家的能源消耗。所以，一个逻辑问题出现了：这为什么是必要的？为什么挖矿算法是这样设计的，即人为添加的计算难度？

### 1.2.1 工作量证明的概念

对于之前问题的答案以及新比特币是如何发行的，可以在应用的概念——工作量证明（PoW）中找到。PoW 概念用于维护区块链（DL）的一致性、强大且不可破解，这些都是创建整个系统信任度以及社区关于加密货币真实价值共识的关键因素。

工作量证明的概念并不新鲜。它已用于具有客户端-服务器机制的计算机网络中，作为阻止服务拒绝（DoS）攻击和其他滥用行为（如垃圾邮件）的措施。PoW 的主要特性是其非对称性——客户端相对于服务器轻松检查结果的相对艰辛工作。在比特币区块链的情况下，成功矿工（即矿池）找到有效 nonce-哈希对的非常困难工作的结果很容易被其他矿工确认。

已经提到过，比特币的信任度也促进了区块链的去中心化。让我们回想一下，比特币区块链作为一个交易块的 DL，是通过节点实现的，即连接到比特币 P2P 网络的计算机。比特币全节点是运行着比特币核心客户端并拥有完整区块链的计算机。交易是将从发送者的比特币钱包（即地址）发送到收款人比特币钱包的比特币发送过程。货币发送者向网络广播交易。全节点验证交易，并通过广播消息跨网络将它们传递给其他节点。在这个去中心化的基础设施（P2P 网络）中，一组矿工收集交易记录，验证每个交易是否正确签名且与之前的交易不冲突。他们还检查发送者（其身份隐藏在地址后面）不会移动比地址中包含的比特币更多的比特币（通过整个区块链）并执行其他功能。

每个矿工独立收集有效的交易并将它们汇总到一个候选区块中。然后，矿工通过 PoW（即寻找一个有效散列的过程，如第 1.2 节所述）尝试解决他的候选区块。成功解决一个候选区块的第一位矿工将他的解决方案广播到网络（包括其他矿工），以添加到区块链上。在此关键之处是，只有当超过 50%的矿工表示它已经被正确解决时，新的区块才会被添加到区块链上。在表示之前，矿工需要在已解决的区块上进行计算，将他们的结果与广播的解决方案进行比较。两个不同的候选区块可能会在大约同一时间被解决。在这种情况下，两个解决方案将通过网络传播（这种情况被称为区块链分叉）。然而，最终只会胜出一个，即，它将被添加到区块链上（大多数矿工首先接受的）。与此同时，另一个已解决的区块（孤儿）将变得无效，并且来自这个区块的交易（未包含在胜出区块中的）将等待下一轮，被收集并在一些即将到来的候选区块中被验证。决定两个解决方案中将胜出的是在大约 10 分钟后，下一个区块首次（在网络的某个地方）添加到胜出的区块之上时。然后，新添加的区块将被广播为解决方案（其中包含之前的胜出区块在区块链中）。社区会迅速接受它，假设在那一刻只有一个解决方案被提出，这是最常见的情况。

收到候选区块已被解决的的消息后，矿工应仅验证解决方案的正确性，因为解决方案已知。然而，尽管只有当至少 50%的矿工验证通过后，才能将解决后的区块添加到区块链上，但矿工们并不需要进行验证。矿工首先决定是应该在开始下一个区块之前等待验证该区块，还是假设前一个区块是正确的立即开始解决下一个区块。做出这种假设的好处是，不会有时间浪费在验证上，这能增加大约 10%的利润。因此，许多大型矿池跳过这一验证过程，仅仅使用新追加的区块链，立即开始工作在下一个区块上。

通过涉及 PoW 和超过一半参与者的共识过程，所谓的不可信真相得以实现。不可信真相是一个表示社区就某事达成共识（在这里，是对 BTC 的信任）的术语，从而没有人信任任何人。尽管如此，正因为这种普遍的不信任，所有参与者都受到一套规则（或像 PoW 这样的机制）的约束。最终，每个人都对某些共同利益的事物充满信心。

在这种情况下，比特币（BTC）区块链就像一个巨大且可靠的的数据结构，这正是因为其成长需要大量的计算工作。这项工作（由于普遍的不信任）必须通过工作量证明（PoW）并由大部分矿工验证。如果有人试图篡改（即伪造）之前的某些交易，仅仅为了改变某人数字钱包的状态，他必须创建区块链的一个新的一致版本（其中一个区块被改变）。它必须通过矿工社区的验证过程。在区块链内改变一个区块（只能通过创建一个包含相同前驱块的新块来实现）需要重新生成所有后续区块，并重新执行它们包含的所有工作。由于伪造者必须独立完成大量的工作，这实际上是不可能的。在目标区块之后的区块链中区块越多，创建某种篡改目标块的区块链版本就越困难。正是这样，一个内置不信任真相机制的去中心化系统获得了只有某些集中的货币机构，例如，各国的中央银行才享有的货币权威声誉。此外，BTC 已经成为一个不受任何政府或中央权威控制的全球货币系统。

除了去中心化和 PoW 机制之外，BTC 可持续发展和价值的理由还在于货币政策，即 BTC 发行政策。这是全球矿工队伍进行交易验证工作的主要激励因素。尽管现在看来，每 10 分钟，新的 BTC 数量就会在解决块的过程不断出现，但 BTC 仍然没有通货膨胀的特性——也就是说，BTC 的总量由其设计决定，这就是为什么它常被称为数字黄金。

BTC 是 2009 年互联网上推出的最古老和最知名的数字货币。现在，它的总金额不能超过 2100 万（精确地说：20,999,999.9769 BTC）。最初，解决区块的奖励是 50 BTC，区块链中打开区块的难度是 1，即散列值只有 8 个前导二进制零。如前所述，解决区块的难度每 2016 个区块调整一次，即大约每 14 天，根据矿工的总计算能力。BTC 区块奖励每 210,000 个区块减半。目前，奖励是 6.25 BTC，上一次从 12.5 BTC 减半是在 2020 年 5 月 27 日的第 630,000 个区块。许多矿工可能会在那之后离开，因为他们的利润减少了，但另一方面，随着矿工权力的减少，难度也会相应降低。因此，挖掘每个新的 BTC 所需的电力将减少。

最后，让我们指出，到 2032 年，当奖励降至 1 BTC 以下时，几乎所有的 BTC 都将被挖出，矿工（如果还有人留下的话）的唯一激励将是交易费用。但毕竟，不可能对 BTC 的未来和生存有精确的预测。

### 1.2.2 BTC 的漏洞和问题处理

甚至在 BTC 之前，就有尝试创造可持续的数字货币。所有尝试都失败了，因为缺乏可靠机制成功防止交易被复制并两次花费（即实现）的场景。好在 BTC 通过 PoW 和区块链概念成功解决了这个双重支付问题，每个交易都有时间戳。

如果使用相同的私钥（欺诈性货币发送者的）发送到不同接收地址的两个交易（其中一个是有欺骗性的）进入网络，就会出现双重支付问题。当这两个交易通过网络传播时，网络的一部分将接受一个交易，另一部分则接受另一个。BTC 区块链固有的防御机制是，只有矿工首先在任何两个网络方解决到下一个区块的交易将被验证。另一个将被拒绝为无效。BTC 通过时间顺序、时间戳的交易账本，即通过区块链，实现这种确认机制，从而成功处理双重支付问题。

BTC 中另一个融入的突破是使用 PoW 作为解决一类称为拜占庭将军问题的失败概率解决方案[6]，这是将军问题的泛化版本。可以说，BTC P2P 网络作为分布式系统是拜占庭容错（BFT）。

拜占庭将军问题可以用一句话概括，即更多将军（每个都有自己的军队）必须就即将到来的战斗中对被包围的敌人发起攻击的时间达成共识。如果他们不同时一起攻击，也就是说，如果一些将军发布了攻击命令而其他将军没有，敌人将克服已经发起攻击的军队，获得战略优势，并最终赢得战斗。将军们通过信使相互沟通，也就是说，每位将军都将收到的消息转发给最近的几个将军，这取决于他们在地形上的空间位置。最初的含有攻击时间信息的消息是从总将军发送给最近的几个将军，然后转发给其他人。如果一些将军（叛徒）改变了收到的消息并将带有不同攻击时间的消息转发给其他将军，就会发生问题。这将导致攻击不同步，最终在战斗中失败。由于忠诚的将军不知道可能的叛徒是谁，他们必须创建一个通信协议和决策规则。这些必须确保在某些将军收到了两个或更多带有不同攻击时间的消息的情况下，只有正确的消息被所有人接受，而错误的消息被拒绝。文献[7]表明，只有当叛徒将军的数量不超过所有将军的三分之一时，才能解决这个问题。

当讨论分布式系统中的拜占庭将军问题（比如比特币 P2P 网络）时，这个问题涉及到系统中的腐败组件表现出阻止其他系统组件之间达成一致（即共识）的症状（i.e.,共识）。这种一致性对于系统的正确运行是必需的。拜占庭错误假设任何导致组件向系统的不同部分呈现不同症状的错误。拜占庭容错（BFT）系统如果腐败组件不多，即最多只有一 third 的组件出现故障，就能实现其正确功能。BFT 系统通常包括 PoW 作为对抗腐败组件提供虚假信息机制。

如果我们想将拜占庭将军问题翻译成比特币环境中的情景，我们可以设想一个已解决候选区块的情况。找到解决方案后，矿工将区块添加到区块链（比如说第*n*个区块）中，并将其广播给其他节点。然后，其他节点用添加的第*n*个区块检查收到的区块链。完成这一步并确认 nonce 后，每个矿工都将这个新块添加到其区块链复制品的顶部。当其他矿工在大约每 10 分钟继续添加一个已解决的区块（即区块*n*+1、*n*+2、…）到区块*n*的顶部时，这个区块就固化了。区块链顶部的最后一个区块通常是不稳定的，但是一旦它上面有更多的区块，它就被认为更加有保障。由于每个新块都难以添加（因为需要工作量证明 PoW），所以在区块链中的一个区块在添加大约一个小时后就被认为是安全的，也就是说，在其后面添加了六个区块后。这就是为什么大多数加密货币交易所和其他接受比特币的服务通常会等待所谓的六区块确认。

区块链中最后添加的区块被认为是不可靠的，因为当时很可能（但并不经常发生）另一个矿工能找到另一个解决方案，从而在区块链中引起分叉。在这种情况下，区块链被分成两条竞争性路径。BTC 区块链的分叉经常出现，到目前为止，每当在一个区块链的这两条路径上添加一个额外的区块（幸运的是首先延伸的那条路径）时，每个分叉都会迅速解决。与此同时，整个网络放弃另一条路径（孤儿路径）的区块，因为胜出的路径包含了更多的 PoW。假设如果一个分叉未能解决，两条竞争性的区块链历史将会共存，从而损害整个系统。

理论上，如果几个矿工或一个矿池在添加新块时没有遵循普遍接受的规定，拜占庭将军问题可能会出现——即，一个极其强大的攻击者可能会通过增加足够的哈希算力并超越网络的整体哈希算力（所谓的“51%攻击”）[8]] 来嘲讽 BTC 社区。攻击者可能会尝试推行他们版本的区块链，也就是，发起分叉，以使区块链中的最后几个（尚未固定的）区块被其他区块替换（在区块链的新分支中）。这些区块可能包含虚假交易，使常规区块链分支的交易无效（导致双重花费）或以其他方式损坏区块链。只有当攻击者的区块链版本包含比常规版本更多的 PoW 时，攻击者的区块链版本才会通过网络传播并被其他矿工社区接受。这只有在攻击者拥有解决连续六个区块的计算能力（即比其他矿工快）时才可能发生。在给定时间内发生此类事件的可能性几乎达到 100%，因为攻击者的哈希算力接近整个挖矿能力的 50%[9]。2014 年，同一个矿池连续解决了六个区块，该矿池集中了整个矿工社区超过 40%的哈希算力。但是，然后，该矿池的一些矿工自愿移至其他矿池，试图防止不良后果。

攻击者可能在一个灰色情境中拥有显著的哈希算力（大约在 30%到 50%之间），在这种情况下，网络上可能存在区块链的两个或更多不同版本。因此，这可能导致 BTC 的崩溃。但是，由于引入了 PoW，同一个实体连续解决六个区块的概率被大幅降低，因此这种情况不会发生。此外，有人可能会认为，即使概率已经降低，攻击者仍会有足够的时间最终崩溃系统。然而，实际上这是不可能的，仅因为攻击者增加的哈希算力。这是因为，由于整体计算能力的提高，涉及的 PoW 的难度也会增加（在最多两周之后）。因此，攻击者的哈希算力仍然不足以实现其目的。所以，可以说 BTC 区块链是一个 BFT 系统。

至今 BTC 的市场价值已经达到了几个高峰。另一方面，这种价值的增加激励了许多攻击者尝试黑掉或操纵 BTC 系统，类似的情况也出现在少数其他加密货币上。在许多网络攻击类型中，两种可能会中断 BTC 网络的运行——分区攻击和延迟攻击。这两种攻击都利用了边界网关协议（BGP）的一些弱点——不要与拜占庭将军问题混淆，这是一个在互联网上由路由器广泛使用的路由协议。

由于 BTC 网络高度集中，从互联网协议路由的角度来看，即三个最大的 Tier-1 互联网提供商可以拦截 BTC 网络中超过 60%的连接[10]。除了这一点，超过 60%的 BTC 节点都集中在五个国家，美国为首，拥有约四分之一的所有节点。另一方面，挖矿能力集中在只有一个国家——中国的挖矿池控制着大约 80%的总哈希能力。最大的五个挖矿池位于中国，挖掘约 70%的所有新 BTC[11]。因此，挖矿能力集中在单一国家是 BTC 社区目前面临的最大问题之一。

分区攻击的前提条件是将一组受害者节点从 BTC 网络中隔离，其中攻击者故意取消针对被攻击节点的互联网流量。这样，攻击者将 BTC 网络分为两部分（一部分较大，一部分较小），它们之间没有通信。结果，这两个网络部分都解决了区块，然后在每个部分内广播已解决的区块。当攻击者停止攻击并重新建立这些部分之间的通信时，所有在较小部分（具有较少的挖矿能力）挖出的区块都将被丢弃，以及所有交易和矿工的收入也将被丢弃。

延迟攻击有效地减缓了区块向受害者的传播速度。主要目标是让受害节点几乎 20 分钟内无法获取新区块的信息。与分区攻击不同，在这种攻击中，受害者的连接被切断，攻击者在受害节点和其对等节点之间进行中间人攻击，修改从受害者发送的 BTC 消息。由于这种操纵，受害者节点（即矿工）从请求的答案中得到不同的信息，也就是说，它得到了它没有询问的——即在网络的某个地方挖出新区块后，新区块的散列值被宣布并通过网络传播，通过其对等节点以及通过拦截受害者和其对等节点之间通信的攻击者到达受害者节点。然后，通过相同的通道（与对等节点的 TCP 连接），受害者请求与接收到的散列值匹配的已解决区块。然而，攻击者将这个请求改为对等节点（以受害者的名义）请求另一个（即更早的）散列值匹配的已解决区块。之后，受害者的对等节点将请求的旧区块发送给受害者，收到后，受害者忽略这个区块（因为过时），但仍等待 20 分钟重复请求。最终，受害者从同一对等节点收到正确的区块（同时与对等节点的 TCP 连接仍然有效）。当受害者最终得到请求的区块时，已经太晚了，因为一个新的区块（很可能）已经被解决并添加到区块链中。这样，受害者浪费了自己的计算力和时间，而不是解决下一个区块。潜在的利润也会丢失。

可以采用多种措施来对抗或预防分区攻击和延迟攻击。这些措施可能包括矿池的多重接入[10]（以防止延迟攻击）、互联网服务提供商采用的各种过滤技术（对抗分区攻击）、BGP 流量监控或在适当的路由器上升级 BGP 协议（带安全补丁）。

比特币系统的不同实体可能会出现多种威胁，如果处理不当，可能会导致问题。不详细说明，我们只需列举其中一些：数字钱包的盗窃漏洞、Sybil 攻击[12]（通过创建节点的伪身份）、拒绝服务（DoS）攻击、能源消耗、追踪币的历史（将身份与地址连接）、受害节点上的时钟漂移（时间劫持）、区块链中的非法内容等等。

### 1.2.3 替代平台和基于区块链的加密货币

在前几节中，重点关注了 BTC 作为最古老和最突出的加密货币。此外，它还作为一个合适的例子来解释区块链概念和机制，如去中心化交易（DL）、工作量证明（PoW）、社区共识、无需信任的真相，或者激励机制。

BTC 的成功为许多替代加密货币（山寨币）铺平了道路。在成百上千的山寨币中，许多是基于与 BTC 相同的框架，也就是说，它们也包含 P2P 网络、区块链以及一种 PoW 来验证网络上的交易。另一方面，山寨币之间以及与 BTC 在许多方面都有所不同——比如在 PoW 算法、程序变化、不同的挖矿能量消耗方式，或为提高用户匿名性所做的改进。在 BTC 之后，新出现的替代加密货币的主要目标是取代 BTC，或者至少重复它的成功。许多山寨币旨在解决 BTC 所认为的限制和缺点，并力求取得一些竞争优势。

截至目前，已经有超过 1500 种山寨币在互联网上被创建并推出，新的山寨币随时可能出现。然而，许多较早的加密货币已不再在市场上流通。目前，市值最大的几种山寨币包括以太坊（ETH）、卡尔达诺（ADA）、瑞波币（XRP）、莱特币（LTC）、门罗币（ZEC）、达世币（DASH）和门罗币（XMR）。

LTC，常被称为 BTC 的银，在功能上与 BTC 非常相似。主要区别在于平均解块时间需要 150 秒（比 BTC 的 10 分钟短四倍），可挖矿的硬币总数（8400 万 LTC 与 2100 万 BTC），以及所采用的工作量证明（PoW）算法——LTC 运行一个脚本。这个顺序函数还涉及 SHA-256 [13]哈希计算，但比 BTC 的哈希计算（称为双哈希或哈希哈希算法）要求更多的内存。

以太坊（ETH）稍微具体一些，因为它不是一个数字货币——它不是用来在线支付商品和服务的，而是作为推动以太坊区块链的激励机制。换句话说，ETH 是以太坊网络的本地数字货币（代币），基于此，以太坊区块链被设计用来支持使用智能合约的各种去中心化应用（参见第二部分）。在公共以太坊网络的挖矿过程中，大约每 12-15 秒，一个新的区块被验证，奖励是 5 ETH。PoW 算法（称为 ethash）比 BTC 的算法需要更多的内存。而且，为了运行各种 DApps，还需要通用计算硬件（如 CPU），所以专门用于 BTC 挖矿的昂贵 ASIC 芯片，不适用于以太坊挖矿。

以太坊分布式账本技术（DLT）是第二代区块链系统的先驱。与比特币（BTC）不同，以太坊支持智能合约和去中心化应用。长期以来，以太坊一直是分布式应用（DApps）选择 DL 平台的可行选择。之前的可行替代方案要么不够成熟，要么其分布式账本生态系统存在不足（见第 2.7.1 节）。以太坊技术已在大规模的公共网络中实施，并且拥有重要的加密货币市场市值。此外，以太坊生态系统（见第 2.7.1.1 节）提供了高效的社区支持、开发工具和库。在以太坊客户端中，对工作量证明（PoW）共识的替代方案早已得到支持，并且可以在私有或联盟网络中使用。2021 年，以太坊基金会也明确标识了从公共网络中的 PoW 共识迁移到权益证明（PoS）的清晰路径。因此，以太坊技术始终是大多数先进 DApp 设计的一个选项。出于相同的原因，本书中许多例子都涉及到以太坊网络、节点和应用。

尽管如此，其他可行的 DLT 和生态系统正在涌现。其中一些在第 2.7.1 节中介绍。它们可能在某些方法上与以太坊不同，但它们与分布式账本网络、性能、去中心化应用和安全等常见原则（在第二部分和第三部分中介绍）有很多共同之处。

## 1.3 IOTA 项目——纠缠

物联网（IoT）随着预期部署数十亿个物联网设备（很快）而成为现实。其中许多将涉及不同类型的货币交易和微支付。因此，出现了一种需要提供一个能够有效支持大量交易的平台的需求。这种支持应该比现有区块链平台能够提供的要好得多。为物联网提供关键支持的解决方案由 IOTA 项目提供[14]。这是一种与区块链显著不同的新的分布式账本技术。IOTA 基于一种特定的有向无环图（DAG）结构，称为纠缠。

IOTA 项目始于 2015 年，旨在为未来的数十亿物联网设备提供更适合的加密货币支付（交易）方式，并为许多其他应用提供一个可靠的平台，这些应用可能包括设备间的机器对机器（M2M）通信。因此，IOTA 协议的实施必须具有成本低廉、速度快和可扩展的特点，这是开发网络而不是使用已经成熟的区块链技术的关键解释。物联网的快速增长显著增加了物联网设备之间的微支付需求。起初，BTC 被认为可以解决微支付的需求。然而，有两个原因使其并不适合。第一个原因是相对较高的费用，因为随着微支付的进行，交易中的金额减少，而另一个原因是参与者角色不明确。在 BTC 社会中，一些矿工验证交易，“正常用户”发行交易；因此，矿工也可能是发行者。这种模糊性使得潜在冲突的概率保持高位，冲突解决浪费了每个人的资源。

与 BTC 或以太坊等其他基于区块链的系统相比，IOTA 的主要区别在于，IOTA 的分布式账本技术不包含矿工、交易区块、以 IOTA 代币支付的交易费或奖励，也没有复杂的工作量证明（PoW）。相反，当一个参与者广播一个交易时，首先要做的就是验证，即批准两个（随机选择的）前一个交易并执行少量 PoW。作为奖励，该交易被允许附着在这两个前一个交易之后。之后，被附着的交易（称为提示）等待另一个参与者的新交易批准，然后该新交易又等待其后的批准。这种传递式验证系统使得金融奖励变得 unnecessary。

此外，整个加密货币的总数（即 IOTA 代币或简称 IOTAs）已经在网络的起点（即创世纪时刻）创建完毕，并分发给了项目创始人。在参与者（创始人及新参与者）之间的不同交易中，IOTA 代币会易手。IOTA 代币的最小单位为一件代币（与 BTC 不同，它不可分割），而创世纪时刻创建的总数为 (3³³−1)/2 ≈ 2.779 × 10¹⁵ IOTAs。

正如前面所提到的，梅尔叉（Merkle）是一种 DAG（有向无环图），其中的每个点代表一个单独的交易（而不是交易区块），而箭头则代表批准。在表示梅尔叉的图中，每个交易指向其批准的两个之前的交易（所谓的父交易）。为了说明，图中的批准（箭头）方向与时间线的方向相反(图 1.4)。一个交易可以直接（由直接指向它的交易）或间接（由可能间接指向它的所有后续交易，跟随图中的箭头）获得多次批准。

![](img/b_9783110681130-001_fig_004.jpg)

图 1.4：梅尔叉的图表示法。

梅尔叉中的第一个交易被称为创世纪。所有的 IOTA 都是在创世纪中创建的，并且再也没有新的机制来创建新的 IOTA。梅尔叉中的所有交易直接或间接地批准创世纪。

当一个交易被大量新交易批准后，它就成为了实际上不可能被改变的一部分共识。梅尔叉的一致性是通过每个交易必须完成的小型工作量证明（PoW）计算来实现的，这使得攻击者在达成共识后 fork 或 spam 梅尔叉变得非常困难。有效的交易的共识是通过应用随机游走蒙特卡洛（RWMC）算法来实现的[15]。这个算法与新交易选择两个父交易来批准的方式有关。该算法实际上引导交易走向尽可能年轻父母的尖端（尚未批准的交易）。然而，选择懒惰尖端（直接批准一些较旧交易，这些交易已经被过去的一些早期交易验证过）是有可能的（但概率很小）。

在当前时刻从实际尖端集合中选择一个尖端（也可以选择一个懒惰尖端）的机制是基于从创世纪向纠缠末端（沿着时间线）的随机游走，即向尖端。当达到一个特定的尖端（即，被选中）时，游走停止。再次执行一次游走，以便首先选择两个尖端进行验证。如果选定的尖端成功验证（即，检查不一致性），它们成为新交易的父母交易（实际上，直接批准其父母）。在纠缠中交易的累积权重是后来所有交易的总数，同时，这些交易直接或间接地（更准确地说，这个总数还会额外增加 1）。在游走过程中，在每个分叉点，将被选择的分支是引导向下一个子交易的分支，并且具有最大的累积权重。尽管如此，在游走中会引入一定量的随机性，即在每个分叉点，具有最大累积重量的交易可能不会总是包含在路径中。可以说，游走被引导向最重的分支。随着新交易的产生，纠缠被迫在具有最重交易（就累积权重而言）的方向上最快增长。相比之下，附加到最轻分支上的交易是孤儿化的，即，它们最有可能永远不会成为共识的一部分（因为任何新交易批准它们的概率很小）。纠缠的增长让人联想到一棵树在某一方向上的强制生长（例如，树在该方向上接收最多的光线），而在其他方向上的生长也是可能的，但显著减少。

到目前为止给出的描述中，纠缠内部的交易由所有或大多数尖端间接批准（~ 95%的尖端）。因此，它们被认为是可靠的，并预计将永远存在于纠缠中，即，就其作为账本一部分的不可变性达成共识。交易的累积权重是在其之后执行的 PoW 量，它以与区块链中区块通过后续块的 PoW 确保一致性和不可变性相同的方式，确保交易的 consistency and immutability。交易的累积权重越大，表明交易越可靠。当纠缠中的交易达到足够的累积权重时，它安全地包含在共识中。这相当于声称，如果交易由大多数尖端（主要间接）验证，则该交易成为共识的一部分。

基于区块链的系统和 IOTA/tangle 平台的一个共同特征是，IOTA 网络也是一个节点的 P2P 网络（即用户、实体和参与者）。但是与 BTC 等系统不同，节点是实体，设计上既验证也发布交易，因为在一个节点发布交易之前，必须批准其他节点发布的两个早期交易。此外，每个节点都有动力在网络上传播来自其他节点的交易，尽管该节点可能没有其他新交易需要发布。我们需要避免在 IOTA P2P 网络中的节点和 tangle 中的网站之间的术语混淆。网站是在 tangle 图表示中由节点发布的交易。此外，tangle（作为 DL 的代表）是存储由节点发布的一组网站的交易账本。

至于时间问题，可以说 IOTA 网络是异步的，其中某个节点可以在任何时刻发布交易，并且在网络传播后，它会在不同的时间实例到达不同的节点。这意味着在任何其他节点发布其交易的时刻，它并不操作 tangle 的实际状态，而是操作几秒钟前的状态。因此，在运行提示选择算法时，节点不知道那些在此刻之后不久会被告知的隐藏提示。每个节点保持（即刷新）其 tangle 的版本。一般来说，不同节点上的版本并不相同。不同的节点在任何时刻可能看到（或多或少）不同的交易集。然而，这些差异最多只与隐藏提示、最新提示和最近验证的交易有关。相比之下，作为共识的一部分，较旧的交易对于大多数节点来说是共同的（即相同的）。

节点并不总是包含账本的最新版本，也不总是将其接收到的更新（新的接收到的提示）转发给网络中的邻居（对等节点）。节点有可能会在较早的账本状态下验证两个父交易（当节点可能离线工作且不总是连接到互联网时）（此时节点会选择验证两个父交易）。验证后，节点通过网络广播其新交易（附加到已验证的父交易上）。由于节点不批准任何新交易，因此它并不帮助社区。

另一方面，这种懒惰行为会被协议在两个方面惩罚。首先，发行的交易可能会被网络的其余部分认为是懒惰的尖端，因为其他活跃节点有更新的 tangle 版本。因为懒惰的尖端很可能会变成孤儿节点，所以这种交易不太可能成为共识的一部分。节点有动力保持他们的账本版本尽可能新鲜。其次，节点有直接的动力去分享来自其他节点的交易，因为这样做可以增加他们验证最近发行的交易的几率。当验证成功，他们的累计权重也会增加，这增加了成为共识一部分的机会。然而，即使在一个节点没有发行交易的情况下，它也有动力传播其他节点的交易。根据协议，迫使节点传播交易机制是每个节点计算从每个对等节点接收的新交易的数量。如果一个节点不分享新交易，它将被它的对等节点抛弃。所以，下次节点有交易要发行时，它将无法做到。

有了上述描述的激励机制，且不包含任何交易费用，网络延迟降低——这是物联网应用中期望的功能（以太坊和其他区块链则不然）。因为 tangle 支持物联网，并且速度快、可扩展，所以被看作是一个良好的物联网支撑。与区块链不同，tangle 不假设交易区块，所以每秒的交易次数以千计，也就是说，远高于比特币区块链。另外，tangle 的设计本身就是可扩展的，因为创建的交易越多，验证和确认的交易也就越多。

发行交易的参与者通过解决可能存在的冲突也为 tangle 的安全性做出贡献——具体来说，在验证两个父交易时，一个节点检查已验证的交易是否冲突。一个交易可能与其他交易（即 tangle 历史）以不同方式冲突。例如，一个实体（一个人或物联网设备）在交易中购买一些商品或服务，并将 IOTA 代币发送给另一个实体（卖家），可能从 tangle 中的所有先前交易（从创世纪事件开始）中计算出一个负余额。负余额可能是早期交易之间的冲突结果。另外，即使账户状态为正，一个不诚实的实体也可能在短时间内向不同的卖家发行两笔不同的交易（双重花费问题），导致两个冲突的交易。因为没有冲突预防机制，tangle 可能暂时包含一对冲突的交易。

当一个节点为其子交易选择两个顶点时，它首先必须验证这些顶点。验证一个顶点包括检查顶点的签名和它的算力证明，以及确保顶点与其验证路径中的任何交易不冲突，即与这个顶点直接和间接引用（即验证）的交易。假设节点发现所选顶点存在冲突。节点放弃该顶点并选择另一个，而之前选定的顶点将被遗忘。这样，节点直接解决冲突。如果节点发现所选顶点验证路径中的任何两个交易之间存在冲突，情况也是如此。在这种情况下，冲突被认为是以间接方式解决的。如果一个节点发布的新交易间接批准了冲突交易，那么它就有风险，其他节点不会批准其新交易。

另一种情况是，当一个节点选择两个顶点，其中第一个顶点的验证路径包含与第二个选定顶点验证路径中的交易冲突的交易时，网络通过解决冲突进行自我净化。在这种情况下，两个冲突交易都不属于这两个顶点验证路径的交集。在这种情况下，节点看不到冲突。因此，节点通过将交易附加到选定的顶点间接批准了这两个冲突交易。此外，可能还有几个新的交易附加到它而看不到冲突。

然而，新的交易最终会选择一个包含两个冲突交易的验证路径的顶点。然后，冲突将被注册并通过对该顶点的放弃来解决。与该顶点直接或间接验证的几个先前交易也将变成孤儿交易。这些孤儿交易只包含冲突交易中的一个（以及批准它的几个后续交易）。相比之下，包含第二个冲突交易（具有更高累积权重）的分支将存活下来。因此，冲突得到解决，只留下两个冲突交易中的一个在账本中。几个无辜的交易，因为它们没有处于检测冲突的位置而批准了另一个冲突交易，将作为附带损害变成孤儿交易。然而，很可能，它们会被参与这些交易的卖方（收款方）节点捡起并重新发布。

正如已经指出的，在创世事件中就开始出现了一个混乱的局面，那时最初的交易开始分配一个预定义的 IOTA 代币总量。随着 tangle 的增长和交易总数的增加，账本的大小也在不断增大，这对于物联网应用来说可能是一个问题。为了减小 tangle 的大小，IOTA 基金会时不时地从全网络中抓取快照。一个快照包含了所有用户账户的状态（钱包余额），但它不包含交易历史，也就是说，所有之前的交易都被抹去了。这样的快照代表了一个 tangle 的新创世状态（就像一个新的开始），不同之处在于到那一刻，2.779×10¹⁵个代币已经被分配给了所有现有的用户。

目前，IOTA 网络还没有完全发展起来，用户数量远远超过了 tangle 最初设计的用户数量。结果，社区的总体计算能力（哈希率）仍然相对较低。因此，当前的 tangle 容易受到双重支付攻击，如果攻击者拥有超过总网络哈希率的三分之一，这种攻击是可能的。为了防止这类攻击和出于安全考虑，IOTA 用户（自愿且暂时）通过所谓的协调员应用不同的共识机制。这种机制假设 IOTA 基金会每两分钟发布一个里程碑交易。所有直接或间接由里程碑交易批准的交易立即被认为是共识的一部分（即，具有 100%的确认信心）。将来，当 IOTA 网络达到足够的计算能力时，协调员将不再必要，也就是说，IOTA 基金会将关闭它，让 tangle 完全自主地发展。

tangle 的一个特殊特征是所有的处理和软件计算都是在三进制逻辑中进行的，更确切地说，是在平衡三进制逻辑中进行的。与二进制计算不同，在那里一个二进制数字（位）可以有两个值（0 和 1），平衡三进制中的一个数字，称为 Tritt，可以是-1、0 或+1。由三个 Tritts 组成的一个词称为 Tryte（与字节相对应），它可以有 3³=27 种不同的状态（值）。Tryte 状态中的每一个在 IOTA 中用一个大写字母“A”、“B”、“C”…、“X”、“Y”、“Z”和数字“9”作为符号表示（在平衡三进制逻辑中，符号“9”代表值+1）。

计算机理论定义了一个用于衡量假设计算机效率的量，即基数*R*的基数经济，是*R*和该基数下的数字数量的乘积。从理论上讲，基数*e*=2.71（即欧拉数，自然对数的基数）在存储信息方面是最有效的。然而，对于实际的计算机来说，基数*R*=3 是最佳选择，因为这是最接近*e*的整数。此外，平衡三进制在允许以相同方式编码正负数方面比正三进制（也称为香草三进制，其中数字可以具有值 0、1 和 2）具有优势。在 2 的补码中不存在负数的二进制表示，因此需要无符号 Tritt。此外，它还有其他优点，例如，更简单的真值表用于数字加法、减法、乘法和除法。

涉及三进制计算在 IOTA 中的理由也基于这一领域的研究所得，即三进制和量子计算被视为不久的将来。三进制计算机（除了一些实验性的）并不存在。因此，整个三进制逻辑（包括计算加密哈希函数，如 SHA-3）在 IOTA 中是由传统的二进制计算机模拟和运行的。

### 1.3.1 IOTA 捆绑包

如我们之前已经解释过的，一个新交易的第一个步骤是选择两个端点（使用随机游走）来被那个交易批准。然而，真正的实现稍微有点复杂，因为通常，一个公共交易是通过所谓的几个单独交易组成的捆绑包发行的（图 1.5），其中每个交易都有与其内部字段“捆绑哈希”相同的值。换句话说，对于从一方到另一方的每个 IOTA 的实际转移，相应的软件客户端发行的不仅仅是 一个交易，而是一系列*N*个与该转移相关的单独交易（这些交易从*N*-1 到 0 反向索引）。捆绑包中的所有交易共同根据特定方案批准所选的两个端点（这将在接下来的章节中解释）。

![](img/b_9783110681130-001_fig_005.jpg)

图 1.5：在纠缠中交易的捆绑 - 一个包含六个交易的捆绑包的例子。

第一次随机游走后选择的最尖端被称为树干尖端。另一个尖端是在第二次随机游走后选择的，被称为分支尖端。束中的第一个个人交易（索引为*N* – 1）批准，即，同时指向树干尖端和分支尖端，而剩下的*N* – 1 个个人交易（索引从*N* – 2 到 0）都一起指向树干尖端。除了树干尖端之外，这些*N* – 1 个交易中的每一个都通过内部字段树干交易（其中包含束中前一个交易的哈希值）批准束中的前一个交易（索引高一个），见图 1.6。这意味着树干交易字段中的值等于束中前一个交易的交易哈希字段的值。相比之下，分支交易字段的值等于树干尖端的哈希（写入交易哈希字段中的树干尖端）。如前所述，束中的第一个交易批准了两个选定的尖端，但方式略有不同——现在它的树干交易字段指向树干尖端，而分支交易字段指向分支尖端。

![](img/b_9783110681130-001_fig_006.jpg)

图 1.6：在网络中交易的束绑方式。

最后，每个尖端都属于其束的一部分，作为束中最后的（未批准的）个人交易，因为随机游走算法只选择那些尚未批准的交易（束中的每个早期交易已经被最后一个交易，即尖端所批准）。

在 IOTA 束中有三种个人交易类型：输入、输出和元交易。交易类型取决于内部字段中数值的符号，Value，它表示将通过个人交易添加（通过这个交易）到由字段 Address 指定的账户中的 IOTA 代币（IOTAs）的数量。因此，输入交易中的 Value 字段是一个负数，这意味着给定的地址被收取了指定数量的 IOTAs。由于输出交易中的数值为正，因此它将 IOTAs 添加到给定的地址，而元交易是中性的，因为其中写入的值等于 0。元交易通常用作输入交易的扩展，通常具有输入交易签名的尾部部分。

让我们以下面的例子来解释：如果客户端 A 想要进行一笔购买并转账，比如将 700 个 IOTA 转给客户端 B，A 端的钱包软件将会创建一组输入、输出交易（可能还会有元交易），这些交易需要集成到 tangle 中。这样，要么这个交易包内的所有交易都会被 IOTA 网络中的节点接受，要么一个也不接受。在创建交易包的过程中，首先准备一个输出交易，在交易地址字段中包含 B 客户端的地址*b*，在交易价值字段中填写正数 700。这个交易被分配索引 0（这个交易作为*N*个交易交易包的起始交易，但会在*N*个交易包一起发布时最后发出）。

接下来，准备输入和元交易。如果客户端 A 有三个地址（即三个账户）*a*[1]、*a*[2]和*a*[3]，由相同的私钥种子生成，分别在其账户状态下有 200、600 和 350 个 IOTA，那么这三个相应的输入交易将在索引、地址和价值字段中填写以下值：{1, *a*[1], –200}、{3, *a*[2], –600}和{5, *a*[3], –350}。因为输入交易需要包含默认安全级别为二的地址的交易签名，所以每个输入交易后面都添加一个元交易以携带前一个输入交易的第二部分签名。这三个元交易将有以下索引、地址和价值：{2, *a*[1], 0}、{4, *a*[2], 0}和{6, *a*[3], 0}。

准备一个作为最后交易的输出交易以平衡转账（所谓的剩余交易）。因为客户端 A 通过三个输入交易花费了 200+600+350=1,150 个代币，而客户端 B 通过第一个输出交易收到了 700 个代币，因此创建一个新的输出交易，将 1,150-700=450 个代币返给客户端 A。这个交易有索引 7（在交易包中最大），价值 450（正数），地址为*a*[4]（由与客户端 A 的*a*[1]、*a*[2]、*a*[3]地址相同的种子创建）。

最后，给定示例中的完整交易包包含了八个单独的交易，其包含的{“Index”, “Address”, “Value”}三元组如下：{0, *b*, 700}, {1, *a*[1], –200}, {2, *a*[1], 0}, {3, *a*[2], –600}, {4, *a*[2], 0}, {5, *a*[3], –350}, {6, *a*[3], 0}, 和 {7, *a*[4], 450}。在此示例中，第一个和最后一个交易属于输出类型，而中间的交易属于输入或元类型。通常，交易包中的交易总数是没有限制的，但实际上，在给定的网络约束和 PoW 难度限制下，不鼓励发行包含超过 30 笔交易的交易包。两个客户端之间（令牌发送者和接收者）进行转账的一个典型交易包由四个交易组成：一个输出（给接收者），一个输入（来自发送者），一个元交易，以及一个平衡交易。

## 1.4 哈希图

由比特币的发展至今所引领，区块链技术在分布式账本领域取得了重大突破，并除了加密货币（这只是其中之一，但最受欢迎）之外，为创建众多去中心化应用开辟了机会。基于 DAG 的几个分布式账本系统也应运而生，旨在开发具有最佳可能和最理想特性的新技术。然而，这些特性往往是相互对立的。因此，现有的系统如比特币、以太坊或 IOTA/Tangle 只是基于它们实现水平的权衡。一个理想的分布式账本技术（DLT）应该当然具备以下属性：不可变性、低延迟、安全性、可扩展性、低计算难度、DDoS 抵抗性，以及网络带宽要求的谦逊。此外，这样一个系统不应当需要任何昂贵的服务器。它应当是公平、快速、便宜，并具有拜占庭容错性。最后，它应当具备在绝对不可信的事实情况下达成共识的能力，即，执行社区的规则，即使没有人信任任何人。满足所有这些要求的良好的候选者是一个名为 hashgraph 的分布式账本平台。

Hashgraph [3] 是一种新的基于 DAG 的共识机制，它是区块链的替代方案。简单来说，DAG 是一个没有任意两个元素之间循环的有限有向图。在图论中，图是由一个点集（顶点、元素、方块）组成，其中任何两个点都可以有关系，即，通过一条线（边、弧）连接。有向图意味着每两个点之间的线是单向的，即，有箭头。因此，DAG 可以被认为是通过箭头连接的有限点集，这样在任何点 X 出发，沿着箭头的序列最终不可能循环回到 X，即，不存在有向循环。DAG 可以有一个树形拓扑（作为一个特例），但通常，DAG 没有规则的拓扑。区块链可以被认为是具有点（区块）链式连接的最简单的 DAG，即，每个点（除了第一个和最后一个）有一个前驱（父节点）和一个后继（子节点）。

hashgraph 的图表示与 IOTA/tangle 相似：两者都有 DAG 的拓扑，其中每个元素（事件，即站点）恰好有两个直接前驱（父节点）。然而，这仅是他们唯一的相似之处。可以得出结论，hashgraph 的 DAG 表示了一个社区（人口）成员之间的所有通信（所谓的八卦）的历史。

Hashgraph 运行一个八卦协议，简要描述如下：在 hashgraph 的 P2P 网络节点中，在任何时刻，每个节点 X（人口成员，参与者）都可以与它的随机选择的邻居 Y（对等体）同步，其中 X 向 Y 发送一个同步消息，包含有关新交易的信息，关于人口节点之间的先前同步消息（八卦），或两者都有。因此，节点 X 发送它迄今为止所知道的一切以及节点 Y 不知道的，即 X 发送除 X 确信 Y 已经了解的信息以外的所有信息给 Y。

当一个节点接收到一个同步消息时，它会创建一个称为事件的数据结构。通常，事件包含（作为有效载荷）从节点的客户端（即用户，数字钱包）学习到的最新交易，以及节点声称接收到同步的时刻的时间戳。从节点 X 到节点 Y 的同步消息包含 X 已知而 Y 未知的所有事件（即，X 认为它们对 Y 是未知的）。另一方面，节点 Y 只提取直到那一刻的未知事件（因为节点 Y 可能已经从其他节点的同步中学习到了一些接收的事件，而节点 X 不知道）。节点 Y 使用新信息更新其 hashgraph 账本的副本，作为人口中所有事件和同步的整体视图，从开始。

在图形表示中，例如，当节点 A 从节点 B 接收到一条八卦（同步）信息时，这个八卦事件在图中显示为节点 A 列中的一个圆圈（顶点），并有两条线（边）向下延伸至节点 A 和 B 立即之前的八卦事件 (图 1.7)。哈希图 diagram（如图 1.7c 中的那个）仅用于其展示和解释，也就是说，在任何地方都没有实际存储的图形。

![](img/b_9783110681130-001_fig_007.jpg)

图 1.7：哈希图结构。

对于交易分享，每个节点在其软件中运行两个无尽的并行程序循环。它在第一个循环中异步接收和收集其客户端（钱包）和其他节点（从而创建事件）的同步消息。在第二个程序循环中，节点偶尔向其邻近节点发送同步信息。这种八卦传播的过程，即分享现有和创建新事件，应该在每个节点收集到最初创建或接收的每条信息（所有交易）时停止，即当对所有交易及其发生时间线达成共识时。然而，由于不断有新交易出现，这个过程实际上从未停止，因为总有新的事情可以八卦。与此同时，节点持续地对之前的事件达成共识并且速度快。实际上，在任何时刻，每个节点都可以看到几乎与其他节点看到的相同的图片（即所有事件的历史）。相比之下，节点之间对整体八卦历史的看法差异仅与最新事件（可能几秒钟内最旧）有关。

知道同步消息包含关于事件交易的信息，以及关于事件本身的信息，因此可以说哈希图表示关于交易的八卦，以及关于八卦的八卦。这是重要的，因为从一个节点的八卦历史，节点可以推断出其他节点知道哪些信息，以及哪些不知道。

让我们简洁地结论，hashgraph 是一个混合数据结构——哈希和图的组合，它记录了谁向谁八卦以及顺序。Hashgraph 不需要任何 PoW（所以没有挖掘），因为达成共识依赖于一个称为虚拟投票的程序。与区块链不同，在区块链中，交易数据存储在块中，而 hashgraph 以事件的形式存储数据，所以可以将事件理解为交易容器，尽管事件可能是空的。在 hashgraph 中，一个事件及其包含的所有交易几乎立即成为每个节点上的账本副本的一部分。当节点八卦这个事件以及所有其他节点听说它时，就会执行这个操作。此外，在几秒钟内，每个节点将能够以 100%的确定性了解事件在 hashgraph 历史中的位置，并且每个节点都知道其他每个节点也知道这一点（这更为重要）。

此外，与 BTC 区块链不同，在 BTC 区块链中，一个块及其为解决它而投入的整个 PoW 有时可能会被浪费（例如，在区块链分叉的情况下，当两个候选块几乎同时被解决后，只有一个块幸存），在 hashgraph 中，没有任何事件会被牺牲，所以 hashgraph 的效率也是 100%。最后，hashgraph 是一个拜占庭容错系统，其中 BFT 属性是绝对的，即，数学上得到证明（稍后讨论这个案例）。

图 1.7a 显示了一个由网络中五名成员（参与者，节点）组成的 hashgraph 的开始，从 A 到 E 命名。随着时间的推移，当创建新事件时，hashgraph 向上增长。图 1.7a 底部的小灰圈代表每个成员在开始时创建的事件。每个成员创建的每个新事件都将添加到属于该成员的垂直线上的最后一个事件上方。

事件是一种小的数据结构，它可以包含零个或多个交易。每个事件下面都有两个父事件（除非是开始事件）：一个称为自父事件，另一个称为他父事件。一条垂直线连接事件和它的自父事件（因为同一个节点创建了两者，所以它们位于同一列），而一条斜线连接事件与其他父事件（由另一个节点稍早创建）。除了交易字段（如果存在的话）外，事件的数据结构中还有三个额外的字段：两个字段包含两个父事件的哈希值以及事件创建时间的时间戳字段(图 1.7b)。

创建事件的节点还会为该事件签名。当节点将事件传播给其他节点时，签名会与传播的事件一起发送。整个 hashgraph 结构因为每个事件都包含其父事件的哈希值——也就是说，在接收到每个同步消息并创建新事件后，节点可以穿过 hashgraph 从起始（或稍后的）事件/s 开始，自行计算其他父事件及其哈希值。这样，节点可以检查其他父事件（及其以下事件）的正确性并验证它，它肯定会这么做。在接收到同步消息后，只有经过验证的事件才会包含在节点的 hashgraph 副本中。此外，hashgraph 的 P2P 网络中的节点使用 TLS 加密协议（在 TCP 之上）相互通信，这进一步保护了同步消息的交换。

图 1.7c（#b_9783110681130-001_fig_007）显示了一个 hashgraph（五个节点/参与者）的例子，其中可以查看到谁传播了哪些事件以及传播的顺序。例如，参与者（节点）C 首先传播（发送同步）事件 C1 给参与者 A，在收到 C1 后，A 创建事件 A2。节点 A 在其文件系统中保存事件 C1 和 A2 以及可能包含的交易。事件 A2 作为有效载荷只包含新交易（如果在此期间收集到任何交易）以及事件创建的时间戳和父事件 A1 和 C1 的哈希值作为开销。然后，参与者 E 传播事件 E1 给 D，之后参与者 D 创建事件 D2。在下一步中，A 与 B 同步，因此 A 将他所知道的一切（事件 A1 和 C1）传播给 B，B 随后创建事件 B2。图 1.7c（#b_9783110681130-001_fig_007）的传播如下进行：

+   SYNC (B→E): B 传播事件 B2、B1、A2、A1 和 C1；节点 E 创建事件 E2。

+   SYNC (D→C): D 传播事件 D2、D1 和 E1；节点 C 创建事件 C2。

+   SYNC (C→A): C 传播事件 C2、D2、D1 和 E1（C 没有发送 C1，因为 C 知道 A 在前一次 C→A 同步中已经了解了 C1）；节点 A 创建事件 A3。

+   SYNC (C→B): C 传播事件 C2、C1、D2、D1 和 E1（此刻，C 不知道 B 已经在 A→B 同步中了解了 C1，因为节点 C 还不知道那次同步，所以事件 C1 没有被从这个传播中排除）；从这一刻起，节点 B 知道了所有起始事件 A1-E1；节点 B 创建事件 B3。

+   SYNC (B→E): B 传播事件 B3、C2、D2 和 D1（现在，B 知道 E 已经了解了 B2、B1、A2、A1 和 C1，所以这些事件不再被传播，E1 也没有被传播，因为它是由 E 创建的）；从这一刻起，节点 E 知道了所有起始事件 A1-E1；节点 E 创建事件 E3。

+   SYNC (B→A): B 传播事件 B2、B1、C2、D2、D1 和 E1（此时，B 不知道 A 已经了解到 C2，所以 C2 没有被排除在传播之外；另一方面，B 知道 A 知道 C1，所以 C1 不需要传播）；从这一刻起，节点 C 知道了所有起始事件 A1–E1；节点 A 创建事件 A4

+   SYNC (E→C): E 传播事件 E2、B3、B2、B1、A2 和 A1（现在 E 通过 B3 看到了 C2。因此，E 知道 C 知道 D2、D1 和 E1，所以这些事件不需要再传播）；从这一刻起，节点 C 知道了所有起始事件 A1–E1；节点 C 创建事件 C3

+   SYNC (A→D): A 传播事件 A4、A3、A2、A1、B3、B2、B1、C2 和 C1；最后，从这一刻起，节点 D 知道了所有起始事件 A1–E1；节点 D 创建事件 D3

这个过程非常快，所以社区中的每个节点都能在很短的时间内（约一秒）了解到所有起始事件（A1–E1）及其交易。同样的情况也适用于后来出现的任何新交易/事件。在每一刻，所有节点都能对从开始到实际时刻的交易和事件的存在达成完全共识。然而，对于 hashgraph 应用（加密货币、智能合约、文件存储），为了抵抗双重支付、拜占庭将军问题、Sybil 攻击和其他类型的滥用，这种共识是不够的。社区还必须就所有事件的时间顺序达成共识，为此，使用了虚拟投票共识算法。

虚拟投票是一种投票过程，在这个过程中，节点社区共同民主地建立对交易顺序的共识，即对交易的时间戳。之所以称为虚拟，是因为节点没有通过互联网发送它们的投票（关于著名见证人的是/否决定，稍后解释）。相反，每个节点根据它对其他节点所知道的信息来计算其他节点会发送的投票。共识时间戳的交易代表了网络成员（节点）中的大多数（超过 50%）首次了解到该交易的时刻。交易的共识时间戳是根据每个节点首次接收到包含给定交易的事件（通过传播）的时刻所选择的时间戳集合中的中位数来确定的。换句话说，节点首次接收到包含给定交易传播时，事件中写入的时间戳被视为集合中时间戳的元素，集合的中位数被宣布为交易的共识时间戳。

然而，默认情况下，每个节点都不能委托其事件，即事件的 时间戳成为所提及的时间戳集合的一个元素。要获得这个允许，每个节点必须稍后创建一个被选为著名见证人的事件，即作为这样一个事件，hashgraph 显示大多数节点在它创建后相对较短的时间内已经了解的事件。总的来说，虚拟投票是确定哪些节点可以委托（以及哪些节点不可以）计算事件的中位数（即共识）时间戳的拜占庭共识机制。

在成员（节点）群体中，任何聚集超过节点总数三分之二的任何团体都代表了所谓的超多数（而对于简单多数，只需要超过 50% 的节点）。超多数这个词也可以指事件，即一轮的见证人（下面解释），在这种情况下，它代表一个至少有 2/3 见证人的团体。

如果在 hashgraph 图中，任何两个事件 X 和 Y 之间至少有一条路径，它直接连接它们或通过其他事件（例如，假设 X 比 Y 旧），那么就说 Y 看到 X，事件 X 是事件 Y 的祖先，即，Y 是 X 的后代。如果 X 和 Y 仅通过一条包含事件 Z 和 W 的路径连接，那么就说 Y 通过 Z 和 W 看到 X。通常，Y 可以通过更多的路径看到 X，每条路径都可以包括更多的事件，从而不同的路径可能部分重叠（即，可能具有共同的事件）。X 和 Y 之间所有路径所属事件的并集代表 Y 通过哪些事件看到 X 的集合。如果大多数节点创建这样一个事件集合，那么就说 Y 强烈地看到 X。

哈希图被划分为称为轮次的事件部分（参见图 1.8）。它从轮次 1 开始，每个节点起始的事件被称为轮次 1 的见证者。随着哈希图的增长，一个事件会在某一时刻出现，它强烈地看到轮次 1 的大部分见证者。轮次 2 从那一刻开始，而这个事件变成了轮次 2 的见证者。轮次的划分基于一个规则，每个下一个轮次都从最后一个轮次中强烈看到大多数见证者的第一个事件开始（这个事件不必看到上一个轮次的所有见证者）。这个事件成为下一个轮次的第一个见证者。每个节点在一轮中最多可能创建一个见证者，这意味着一些节点在这一轮中可能没有创建见证者。另外，当一个事件首次被传播到一个节点时，该节点可以立即计算出事件的轮次，即事件所属的轮次的序列号。事件的轮次计算如下：如果事件强烈地看到轮次*r*的大部分见证者，其中*r*是事件父母的轮次创建中的最大值，那么事件的轮次创建为*r*+1；否则，事件的轮次创建为*r*。

![](img/b_9783110681130-001_fig_008.jpg)

图 1.8：强烈看到示例及轮次划分说明。

下一步是用来确定给定轮次中的哪些见证者将被（虚拟地）选为著名见证者。每个轮次的见证者都有可能成为著名见证者，如果满足某些条件的话。来自轮次*n*的第*i*个见证者 W*[n,i]*是否会变得著名，取决于来自上层轮次*n*+1 和*n*+2 的见证者（在大多数情况下）。首先，来自轮次*n*+1 的每个见证者 W*[n ]*[+1]*[,j]*投下他的虚拟票，即，如果他能看到 W*[n,i]*（这里强烈看到不是强制性的）或者在相反的情况下投下“否”票。接下来，这些投票由来自轮次*n*+2 的见证者进行计数。

因此，来自轮次*n*+2 的见证者 W*[n ]*[+2]*[,k]*只考虑（即收集）来自轮次*n*+1 的见证者的投票，他自己强烈地看到这些见证者。来自其他未强烈地被 W*[n ]*[+2]*[,k]*看到的轮次*n*+1 的见证者（如果存在的话）的投票不予考虑。如果收集的“是”票数大于或等于节点总数的 2/3（即超级多数），则认为见证者 W*[n,i]*是著名的。

对每一轮*n*的见证节点执行相同的虚拟投票程序，最终会形成一组第*n*轮的著名见证节点，其声誉最终由来自第*n*+2 轮的一个见证节点决定，即由一个计算第*n*+1 轮见证节点投票的见证节点。数学上已经证明，如果第*n*+2 轮的任何其他见证节点计算第*n*+1 轮见证节点的投票，都会得到第*n*轮著名见证节点选举的相同结果。

那些创建了第*n*轮著名见证节点的节点被赋予了决定某些事件（即交易）的共识时间戳的权限（从第*n*轮的-1 轮开始）。更准确地说，第*n*轮著名见证节点的创建节点有资格确定第*n*-1 轮所有著名见证节点看到的事件的共识时间戳。如果一个事件被第*n*轮的所有著名见证节点看到，那么这个事件在第*n*轮被社区节点接收，即它具有轮次接收*n*。例如，要确定第*n*-1 轮事件的共识时间戳，X*[n]*[–1]，具有轮次接收*n*，这个特权群体（第*n*轮著名见证节点的创建节点）中的每个节点 A*[i]*首先选择一个事件，Y*[i]，*当它第一次接收到关于给定事件 X*[n]*[–1]的八卦时创建的（经常会发生 Y*[i]*就是那个节点创建的第*n*轮著名见证）。接下来，事件 Y*[i]*的时间戳被委托为事件 X*[n]*[–1]的共识时间戳的候选之一。最后，所有合格（即特权）节点委托的候选时间戳被排序成一个从最古老的一个开始的时间戳数组，数组中间的时间戳（中位数）被宣布为事件 X*[n]*[–1]的共识时间戳。如果数组中有两个中间时间戳（即候选人数是偶数），则选择后者。

获取事件 X*[n]*[–1]的时间戳共识（见图 1.9），对于每一轮从*n *– 1 开始的拥有*n *轮接收的事件都重复进行，而其他*n *– 1 轮的事件则等待被来自*n *+ 1（或更高）轮的所有著名见证人看到。随着时间戳图的增长，事件的时间戳共识，属于*n*, *n *+ 1, *n *+ 2, …（分别具有*n *+ 1, *n *+ 2, *n *+ 3 …的轮接收）由在上轮见证人上遵循相同的虚拟投票程序来确定。这样，事件的时间戳共识（以及包含的事件交易）实际上在经过两轮后开始确定，即在给定事件创建后仅几秒钟。事件存在的共识甚至更快达成。当然，虚拟投票过程可能会在选举*n*轮著名见证人时遇到平局。来自*n *+ 3 轮（甚至更高轮）的见证人被用来解决投票平局。这无疑延长了达到时间戳共识的时间，即*n *– 1 轮事件的时间顺序共识，但即便如此，整个过程仍然非常快。

![](img/b_9783110681130-001_fig_009.jpg)

图 1.9：寻找著名见证人和事件共识顺序的过程说明。

在确定了一轮中所有事件的时间戳共识后，它们的时间顺序共识自动实现，这是整个过程的目标。事件的时间戳共识被分配给它们包含的交易，因此交易顺序的共识也被确定。交易的共识时间戳是公平的，因为它反映了大多数节点接收到该交易的时刻，因为这个时间戳无法被恶意节点篡改或显著改变。在某些恶意节点试图延迟或阻止交易并因此将其排除在八卦之外的情况下，由于八卦协议的随机性，交易将绕过这个障碍。

整个分成多个轮次、选举知名见证人等想法可能会显得过于复杂。但这并不是问题，因为实现 hashgraph 的节点软件并不需要任何特殊硬件——它只需要一台平均的个人电脑，配备有通用 CPU 即可。它需要一个有足够带宽的互联网连接，以每秒下载和上传给定数量的交易，并在 hashgraph 的 P2P 网络中与其他节点交换同步。因此，两个节点之间的八卦数据量最小。如前所述，在同步消息中，节点只发送它认为对其邻居节点未知的事件。此外，有些事件在发送时没有事件父节点哈希（当发送节点可以推断出接收节点可以计算出那些哈希值时）。另外，hashgraph 的虚拟投票算法不需要任何额外的带宽。作为一个值得注意的参考，每个节点的快速家庭互联网连接（每个节点）将有足够的速度来支持与整个 VISA 卡网络相同的每秒交易数量。hashgraph 速度的另一个指标是来自全球八个地区分布的 32 台计算机（节点）的网络测试结果。具体来说，当这个网络运行在每秒 50,000 笔交易时，交易的 时间顺序共识 在 3 秒内达成。如果整个网络集中在一个地区，达成共识所需的时间为 0.75 秒。同样，同样数量的计算机（在全球八个地区分布）可以提供信用卡所需的表现——延迟在 7 秒内处理多达 200,000 笔交易每秒。

所描述的虚拟投票概念还有其他优势。最重要的一个是 hashgraph 的 BFT 属性，在 BFT 定义的严格意义上实现（并且有数学证明），与区块链或 tangle 技术中 BFT 只是作为一种可能性实现不同。具体来说，hashgraph 的诚实成员将能够正确地运行给定的应用程序（例如，加密货币），即使欺诈成员/节点的数量非常接近整个人口的三分之一。hashgraph 的 BFT 属性是实施规则（即拜占庭协议）在虚拟投票中的直接结果。需要强烈可见性和超级多数的节点和见证人。

第二个优点是所有投票过程和获取共识时间戳都是由每个节点虚拟且独立完成的。每个成员/节点都是自己干一切事情，就像它独自一个在荒岛上，并且不需要与任何人（除了常规八卦）进行额外的交流。除了减少了对互联网带宽的需求外，这种方法的优点还包括了实现和验证交易的加速速度。具体来说，如果想要获得 BFT 属性的替代共识算法，当然应该运行单独的拜占庭协议，包括所有成员之间的大量通信。因此，如果目标是确定所有事件的时间共识顺序，那么两个节点之间的每一次单独通信都会包含几个是/否问题（两个方向都有），每个问题都具有这样的形式：“事件 X 是否在事件 Y 之前发生？”然而，由于节点之间通过互联网通信的延迟，以及可能由于其复杂性，这种算法将非常缓慢。

通过应用虚拟投票算法，仅对见证人运行拜占庭协议，从而通过少数问题（例如：“这个见证人是否著名？”）选择出著名的见证人。这种方式避免了事件时间排序（通过执行某种排序算法）的过程。如前所述，一旦找到共识时间戳，事件的时间顺序（自动）就确定了，这是由创建著名见证人的节点委派的候选时间戳的中值。

在之前的段落中，实现基于 hashgraph 的应用程序的一些因素是它应该快速、便宜、能够容忍拜占庭错误、抵抗双重花费和 DDoS 攻击，并且对带宽的需求适中。hashgraph 的其他一些期望的特征与其组织结构有关，该结构旨在实现这些特征。目前，Hashgraph 是一个处于开发阶段的项目。它由 Hedera Hashgraph, LLC 领导——这家公司还为此项目提供了一个公共账本平台。前面提到，DL 可以是无需许可或需要许可的，这取决于中心实体是否授权节点访问网络。此外，还提到，基于使用的 P2P 网络，DL 网络可以是私有的或公共的。Hedera hashgraph 平台旨在是公共的，并具有无需许可（即开放）的共识和需要许可（关闭）的治理。

封闭式治理模型基于这样一个理念：平台将由来自全球不同行业和地区、品牌声望极高的最多 39 家知名组织和企业组成的理事会进行治理。Hedera Hashgraph 理事会（HHC）是一个治理机构，旨在支持基于 hashgraph 共识算法的稳定和去中心化公共账本基础设施的发展。HHC 将遵循规则，确保不会由单一成员或少数成员控制整个机构。代表理事会的当选治理委员会将制定理事会成员政策，然后规范网络规则和代币发行，批准平台代码库的更改。治理规则弘扬去中心化的理念，防止在平台中就交易顺序达成共识的过程中权力集中。这样的治理模型还将消除分账风险，保证代码库的完整性，并提供对受保护核心的开放访问。受保护的核心意味着 hashgraph 共识算法并非免费许可。具体来说，算法中的知识产权由 Swirlds, Inc.（由算法的发明人创立的公司）持有。同时，HHC 从 Swirlds 获得许可，将其用于 Hedera 公共 DL 平台。另一方面，使用 Hedera hashgraph 平台或编写使用平台服务的软件，既不需要许可也不需要 Hedera 的批准。相比之下，建立在平台上的应用程序可以是开源的或专有的。

分布式账本平台广泛采用所必需的特性是信任和稳定性。Hedera 的治理模型（及其治理规则）以及实施的强大安全机制正是创建信任的稳定去中心化平台的关键因素。除此之外，HHC 的政策和结构旨在确保 Hedera DL 平台原生加密货币的广泛和公平分配，并确保网络节点的全面应用。因此，节点将通过专门设计的激励模型，为维护 Hashgraph 平台的服务获得补偿。同时，新的节点（即新的节点运营商）将能够加入网络。

Hedera 引入的整个支付（激励）和费用系统与 BTC（或其他山寨币）的激励机制有显著不同，在 BTC 中，客户（即数字钱包）为每个验证的交易支付费用。与此同时，如果节点成功解决 PoW 任务，它们通过挖矿赚钱。如前所述，Hashgraph 不是基于 PoW，因此没有激励节点进行交易验证的挖矿。相反，Hedera hashgraph 的支付模型基于三种向节点或由客户支付给 Hedera 的费用，以及两种 Hedera 支付给节点或治理成员的支付方式：

+   节点费 – 客户为此费用向节点支付，以获取节点提供的服务。假设客户想要将加密货币从他的账户转移到另一个账户。在这种情况下，他联系一个节点，该节点代表客户将交易提交给网络（即节点将其放入创建的下一个事件中，并将其八卦给邻居节点，通过 hashgraph 共识机制达成共识）。节点费不是预先确定的，而是由节点和客户之间协商确定的。

+   服务费 – 客户向 Hedera 支付此费用，以获取平台提供的服务。该费用基于所提供的服务（交易、文件存储或智能合约）和服务量（例如，在文件存储的情况下，服务费用取决于存储文件的数量和大小）计算。

+   网络费 – 通过这笔费用，客户补偿节点因网络费用，即因八卦客户交易、在内存中临时存储交易以及计算包含交易的事件的时间戳共识而产生的费用。每笔交易的费用包括固定部分和可变部分，后者取决于交易的字节数。网络费支付给节点，然后节点将其转交给 Hedera。

+   激励支付 – 为了激励节点维护 Hashgraph，Hedera 每天向节点支付一次费用。这笔钱来自 Hedera 从服务和网络费用中收取的金额。支付给节点的金额与节点拥有的股份成比例，但要想获得支付，节点必须全天在线并保持活跃（例如，可能在 24 小时内，节点至少贡献了一个事件，占至少 90% 的轮次）

+   股息支付 – Hedera 可能会定期向治理成员支付这些费用，作为对他们参与治理工作的奖励。

通过开放（无需许可）共识和封闭（需要许可）治理的结合，Hedera hashgraph 平台旨在建立比完全封闭系统更多的公众信任，这是加密货币实现全球接受的关键因素。开放共识模型假设一个过程，其中节点加入网络，并通过之前解释的方式达到交易时间戳共识，即交易的共识时间顺序。为了确保透明度，这个过程允许匿名个人加入网络作为节点运营商。另一方面，它为 Hashgraph 的各种滥用打开了大门。这些包括 Sybil 攻击或者由少数不诚实成员集中共识权力的情况，他们可能会利用他们的权力不适当地修改账本，伪造加密货币，或影响交易共识顺序等。尽管如此，这些威胁可以通过设计一个鼓励出现拥有成千上万节点的去中心化网络的共识模型来防止。在 hashgraph 虚拟投票算法中，加权投票抑制了节点群体的阴谋和 Sybil 攻击。

本节开头描述的虚拟投票算法假设 hashgraph 中所有相关节点投票是平等的。Hedera 在算法中引入了一个修改以消除冲突——即根据节点股份来加权节点的投票。换句话说，每个节点对其拥有的每个赫达拉本地加密货币币（Hedera native cryptocurrency）投一票，因此节点对共识过程的影响与其所拥有的加密货币数量成比例。这种共识被称为权益证明（PoS），其想法在第一节中解释。当一个节点加入网络时，它必须声明它可以控制的账户，而这些账户中的加密货币数量用作在 hashgraph 虚拟投票算法中加权节点投票的股份。如前所述，每个节点每天都会从 Hedera 那里获得收益（作为节点的服务）——收益与其股份成比例，因此节点的股份实际上是在赚取利息。

虚拟投票算法中的投票加权相对容易实现——它可以通过简单地重新定义多数、超级多数和中间值的概念来完成。不再是社区中节点的至少 2/3，超级多数现在代表了一组节点，这些节点的总赌注至少占社区所有节点账户中总金额的 2/3。同样，多数也被重新定义，现在意味着总赌注超过 50%。事件时间戳集合 S 中的时间戳的中位数现在变成了加权中位数，可以认为是新扩大集合*S[enlarged]*的中位数值，其中每个来自 S 的时间戳*t[i]*在*S[enlarged]*中由*n[i]*个自己相同的副本表示，假设*n[i]*等于创建具有时间戳*t[i]*的事件的节点的赌注。

新的超级多数意义隐含地改变了 Hashgraph 中强视图事件的定义。结合新的中位数意义（即加权中位数），它影响了共识交易的顺序，使得更富有（因此更受信任）的节点比一些有虚假意图的新节点组更有力量达成共识。

除了 Hashgraph 中整合的描述机制，例如旨在激励节点运营商参与的费用和支付模型，或者用于抑制 Sybil 攻击和其他恶意行为的 PoS 模型，Hedera 引入了所谓的分片架构以确保平台未来的可扩展性，这对于公共非许可账本的成功也是必要的。这种架构来自于治理与共识的分离。由于预计网络会随着时间的推移扩展到数百万个节点（所有节点都在分布式共识上投票），分片架构实现了平台的持续去中心化。

在其初始阶段，Hedera 网络肯定会有相对较少的节点属于单个分片（分区、组）。随着网络中节点数量的预期增加，节点将随机分组到不同的分片。负责分配节点到分片的实体称为主分片，它每天随机将新节点分配到不同的分片。同时，主分片将一些节点在分片之间移动，以确保分片中的加密货币赌注总额足够大，且分片中的任何节点都不拥有大量该金额。分片中的所有节点就他们从客户那里收集并相互传播的交易建立共识，也就是说，他们共享相同的客户账户状态，这是整个账本状态的一个子集。

分片之间并非相互隔离——偶尔，分片中的任何成员都能向另一个分片中的随机成员发送消息。每个分片都维护着向其他所有分片发送的消息队列。假设分片*α*中的节点 A 的客户端，*C[a]*想要向分片*β*中的节点 B 的客户端，*C[b]*发送一些加密货币。这笔交易首先由节点 A 向分片*α*中的节点传播。在分片*α*中达到顺序共识后，客户端*C[a]*的账户状态会减去要发送的金额。

同时，也会创建一个跨分片消息，并放入分片*β*的消息队列中。随后，在某个时刻，分片*α*中的某个节点，X，会检查那个队列，看到不为空时，X 会将这个跨分片消息（包含交易*C[a]*→*C[b]*）与其他消息（如果有其他分片*α*到*β*的交易）发送给分片*β*中的一个随机节点，Y。当 Y 收到那列表中的消息时，它会创建一个包含收到的所有交易的事件，并通过八卦方式将此事件提交给分片*β*中的节点。当分片*β*中的交易*C[a]*→*C[b]*达到共识（且如果分配的跨分片消息的序列号正确）时，该交易的影响将在*β*中的所有节点上应用，并且*C[b]*的账户余额会增加发送的金额。

从上面描述的（并且简化的）分片之间通信的例子可以看出，分片架构的积极效果在网络节点数量非常大的情况下尤为明显。如果没有分片，整个网络节点之间的八卦次数会多得多，共识和交易延迟会更长，节点的账本文件会大得多。分片上的分离最小化了网络中的八卦消息总量，因为每个交易只在与该交易相关的分片中进行八卦。

霍德拉哈希图平台由三层组成：互联网层、哈希图共识层和服务层。互联网层为节点提供基本的通信基础设施，也就是为连接到 P2P 网络的计算机提供服务，这些计算机通过 TCP/IP 连接进行通信，并应用 TLS 加密。哈希图共识层代表描述的过程，其中节点从他们的客户端那里获取交易。他们通过八卦协议将它们分享到整个网络，并运行哈希图共识算法以及时达成交易顺序的共识。然后，每个节点在其共享状态（客户端账户）的副本上应用交易的效应，即修改与其他节点给定分片的相同副本。

服务层提供了三种初始服务，依赖于下面两层：

+   加密货币

+   文件存储

+   智能合约

通过提供这些服务，Hedera 旨在实现类似于以太坊网络之一的想法，其中其原生加密货币（ETH）主要用于作为激励工具来推动以太坊区块链，主要设计用来支持各种去中心化应用（例如，以智能合约为形式）。Hedera 还使用其原生加密货币通过其支付模型激励节点（作为节点）。然而，与以太坊不同，这并不是 Hedera 加密货币的唯一（即主要）角色，因为服务客户端之间交易的处理也很重要。在 Hedera 平台上开发去中心化应用的开发者将使用其初始服务，并通过服务费以 Hedera 代币（原生加密货币）支付。由于 Hedera 采用了非常快速的哈希图共识算法，Hedera 加密货币预计也将具有高交易率。这导致网络费用低，使小额、微交易变得可行。因此，Hedera 加密货币也应该适用于物联网（IoT）应用。

Hedera 代币还用作 Hedera 质押模型中虚拟投票机制的权重手段——如前所述。相比之下，权益证明（PoS）有助于网络安全，例如，抑制 Sybil 攻击。在这方面，代币应作为激励因素，促使负责使用和治理 Hedera 平台。Hedera 计划发行的加密货币总量为 500 亿代币；因此，代币的发行时间表在开始时会非常缓慢。在第一年，预计代币的分配情况是，大约 65% 的总代币将由 Hedera 财政部持有，其余由可信节点持有，即由 Hedera 管理、员工、投资者、开发者和 Swirlds, Inc. 托管的节点。因此，只有总量的 10% 应该通过交易在客户端之间流通，并且预计这个数量会缓慢增加。具体来说，流通中的代币数量不应超过初始发行后至少五年内的 33% 的阈值。这些预防措施的目标是防止攻击者（或攻击者群体），拥有代币的三分之一，可能破坏网络（因为在 Hedera 的 PoS 模型中，当至少持有代币总量的三分之二的节点验证后，交易才会最终确定）。

使用 Hedera 的第二个初始服务——文件存储，用户将能够在 Hedera hashgraph 平台上可靠且透明地存储去中心化文件或文件的指针。这意味着每个添加的文件的副本都会存储在每一个节点上，实现 100%的可用性，并且对文件确切内容达成共识。共识是以与交易相同的方式达成的，即通过使用 hashgraph 共识算法。hashgraph 中的相关事件现在包含另一种数据类型（代替交易）。由于分片中的每个节点都持有文件的同一份副本，即使有一个或几个节点损坏或服务中断，文件也不会丢失。只有拥有特定授权的实体才能从平台上删除存储的文件。去中心化应用可以利用这项服务来实现不同类型的注册表（如土地所有权注册表、房产标题注册表、动产资产登记册等）。

Hedera 的第三个初始服务——智能合约，是通过在 hashgraph 事件中包含简短的计算机程序（即代码）而不是交易来实现的。这些用 Solidity 编程语言编写的程序的执行保证在所有（诚实的）节点上一旦事件达成共识就立即进行。其执行方式与交易的效力保证应用于相关客户端在每节点账本副本中的账户状态相同，此刻社区验证交易并在交易上达成时间戳共识。智能合约服务允许开发者在 Hedera 平台上轻松构建广泛类型的去中心化应用。智能合约实际上开启了人与人、组织、实体等之间签订合同的可能性，并确保（以 100%的自信）每个签署合同的条款都将被精确地、在约定的确切时刻执行（即在程序代码中编写）。目前，可以在 Hedera 平台上运行用 Solidity 编写的的大型代码库（尽管 Solidity 编程语言最初是为了在以太坊平台上执行智能合约而开发的）。关于智能合约和去中心化应用的更多信息在 2.4 节中介绍。

现在很清楚，hashgraph 技术包含了克服当今加密货币与现实世界之间差距所需的所有特征。hashgraph 的发明者旨在创建一个可以由达成共识、按照预定义规则行事的成员共享的当前网络空间。这个空间将是独立的，不会对成员产生负面影响（基于垄断）或大型科技公司可能面临的安全问题，后者需要托管大量机密数据。在测试阶段，Hedera 网络内将有一定数量的节点，之后由 HHC 成员运行的信任节点将加入网络。在下一阶段，将逐渐包括其他参与者，直到允许任何准备托管节点的成员加入，前提是他们满足带宽、计算力和存储所需的技术要求。在最后阶段，预计 Hedera 网络将拥有全球数百万个节点，其中许多将由希望保持匿名的普通人运行。
