- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_9](https://doi.org/10.1007/978-1-4842-7480-4_9)
  prefs: []
  type: TYPE_NORMAL
- en: 9. Real-Time Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: A distributed real-time system (DRTS) is made up of self-contained computing
    nodes that are linked together by a real-time network. These nodes work together
    to achieve a common goal within predetermined time limits. For a variety of reasons,
    distributed real-time systems are required.
  prefs: []
  type: TYPE_NORMAL
- en: Any real-time computer control system must be able to measure the time between
    events in real time and react to a stimulus in a predetermined real-time interval.
    This chapter discusses some of the implications of including this real-time metric
    in real-time distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: The term “real-time system” refers to a system that is subjected to real-time
    constraints, i.e., the response must be guaranteed within a certain time restriction,
    or the system must satisfy a specific deadline. Examples include flight control
    systems, real-time monitoring systems, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Understanding Real-Time Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real-time systems with timing constraints are characterized as either hard or
    soft. *Hard real-time systems* are incapable of missing a deadline. The implications
    of missing the deadline might be disastrous. If tardiness increases, the utility
    of a hard real-time system’s result declines abruptly, and it may even become
    negative. Tardiness refers to how late a real-time system does a task in comparison
    to its deadline. One example of a hard real-time system is a flight controller
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Soft real-time systems* *,* on the other hand, can occasionally miss deadlines
    with a low enough chance to be acceptable. There are no negative consequences
    to missing the deadline. With increasing delay, the utility of a soft real-time
    system’s result rapidly reduces. Telephone switches are an example of a soft real-time
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Real-Time System Reference Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three components characterize this reference model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** **workload model** **:** This identifies the applications that the system
    supports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** **resource model** **:** This describes the resources that the program
    has access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms:** They describe how the software application will use resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Real-time system terms include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Job:** A tiny task that can be assigned to a processor and may or may not
    necessitate the use of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task:** A collection of related jobs that work together to offer system functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** **work’s release time job** **:** The point at which the job is ready
    to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job execution time** **:** This is the time it takes for a job to complete
    its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job deadline** **:** This is the deadline by which a job must be completed.
    There are two types of deadlines: absolute and relative deadlines. (A job’s **relative
    deadline** is the maximum permissible response time. A job’s **absolute deadline**
    is the sum of its relative deadline and its release time.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job response time** **:** This is the time from when the time a job is released
    to the time it is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active resources** **:** Another name for processors, these are required
    for the successful completion of a task. In order to execute and progress toward
    completion, a job requires one or more processors. Computers and transmission
    links are two examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passive resources** **:** During the execution of a job, a resource may or
    may not be required. Memory and mutex are two examples. Also called resources.
    If two resources may be used interchangeably, they are identical; otherwise, they
    are heterogeneous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure [9-1](#Fig1) depicts the key distinctions between hard and soft real-time
    systems. Hard real-time systems have response time requirements of milliseconds
    or less, which if not reached, can result in disaster. Soft real-time systems,
    on the other hand, have higher and less rigorous reaction times. Peak-load performance
    in a harsh real-time system must be expected and not breach specified deadlines.
    A degraded function at a rarely occurring peak load can be accepted in a soft
    real-time system. In all circumstances, a hard real-time system must remain synchronized
    with the state of the environment.![../images/520777_1_En_9_Chapter/520777_1_En_9_Fig1_HTML.jpg](../images/520777_1_En_9_Chapter/520777_1_En_9_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9-1
  prefs: []
  type: TYPE_NORMAL
- en: Hard real-time versus soft real-time systems
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 Fail-Safe vs. Fail-Operational Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there is a good state in the environment that can be reached in the event
    of a system failure, the system is considered fail-safe. One example is a train
    signaling system.
  prefs: []
  type: TYPE_NORMAL
- en: High error-detection coverage is required in a fail-safe application. The application’s
    failure safety is a feature. A system must be fail-operational if the application
    does not provide for the identification of a safe state, and such systems, such
    as a flight control systems on airplanes, must remain operational in the event
    of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Guaranteed Timeliness vs. Best Effort Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if there is a malfunction, the computer system must deliver a minimal level
    of service.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 RT System Categorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the basis of the requirements from the outside, consider these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Soft real-time vs. hard real-time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail-safe vs. fail-operational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeliness guaranteed vs. best effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adequacy of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time triggered vs. event triggered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the temporal accuracy can be proved by analytical reasoning (within the stipulated
    load- and fault-hypotheses), a system implementation guarantees assured timeliness.
    If such an intellectual case for temporal correctness cannot be presented, a system
    implementation is best effort.
  prefs: []
  type: TYPE_NORMAL
- en: Even within the defined load- and fault assumptions, the temporal validation
    of best effort systems relies on probabilistic considerations. Guaranteed timeliness
    should be the foundation of hard real-time systems.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1 Resource Adequacy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A system’s processing resources must be capable of managing the stated peak
    load and fault scenario if it is to deliver assured timeliness. There have been
    several applications in the past where resource adequacy was thought to be prohibitively
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Because hardware costs are falling, implementing resource-appropriate designs
    is becoming more cost-effective. In challenging real-time applications, resource-adequate
    designs are the only option.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2 Predictability in Rare Event Situations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A rare event is a significant occurrence that seldomly occurs throughout the
    course of a system’s lifespan, such as a burst pipe in a nuclear reactor. A uncommon
    event can result in a slew of associated service requests (e.g., an alarm shower).
  prefs: []
  type: TYPE_NORMAL
- en: The value of a system in a number of applications is dependent on predictable
    performance in uncommon event scenarios, such as a flight control system. Workload
    testing, in most circumstances, will not address the uncommon occurrence scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.3 The State and Event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_9_Chapter/520777_1_En_9_Fig2_HTML.jpg](../images/520777_1_En_9_Chapter/520777_1_En_9_Fig2_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2
  prefs: []
  type: TYPE_NORMAL
- en: State event
  prefs: []
  type: TYPE_NORMAL
- en: A *state* is a condition that lasts a specific amount of time in real time,
    such as a part of the timeline. An instantaneous occurrence is referred to as
    an *event*. See Figure [9-2](#Fig2).
  prefs: []
  type: TYPE_NORMAL
- en: State information describes the characteristics of states at the observation
    site (itself an event). The change in the qualities of the states immediately
    before and after the occurrence of the event, as well as an estimate of the moment
    in time when the event occurred, is provided by event information.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.4 Time Triggered vs. Event Triggered Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control signals in a real-time system are said to be event triggered (ET)
    if they are obtained purely from the occurrence of events, such as the completion
    of a task, the reception of a message, or the incidence of an external interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: A real-time system is time triggered (TT) if the control indicators, such as
    message sending and receiving, are generated purely from the development of a
    (global) notion of time.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Temporal Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For real-time systems, the data pieces that the operator sees must be accurate
    in terms of time. The greatest real-time gap between a stimulus and a reaction
    must be determined and limited. Even though it’s a rare occurrence, the temporal
    behavior should also be predictable. See Figure [9-3](#Fig3).![../images/520777_1_En_9_Chapter/520777_1_En_9_Fig3_HTML.jpg](../images/520777_1_En_9_Chapter/520777_1_En_9_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9-3
  prefs: []
  type: TYPE_NORMAL
- en: Temporal parameters associated with real-time data
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Classification of the Scheduling Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 9.5.1 Hard Real-Time and Soft Real-Time Scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In hard RT systems  , the deadline of critical tasks must be guaranteed in advance
    in all possible ways and with anticipatable scenarios. This requires careful design
    of the system resources. If you are designing a soft real-time system instead,
    you can accept a low-cost scheduler design.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Dynamic and Static Schedulers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A scheduler is called dynamic (online) if it bases its running decisions on
    the basis of current requests. Dynamic schedulers  are therefore flexible and
    adapt with the evolution of the system. A scheduler is called static (pre-runtime)
    if decisions are made before its scheduler is running and cannot be changed. This
    requires a profound and complete knowledge of the task to be performed (maximum
    execution time, priorities, mutual exclusion constraints, deadlines, etc.). Such
    a scheduler has a low cost in phase execution precisely because no decision calculations
    are made.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.3 Scheduler With/Without Preemption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In schedulers with preemption, a task can be interrupted following the request
    of a higher priority task. However, the preemption is authorized if some assertions
    are not violated (see mutual exclusion). In non-preemptive schedulers, tasks are
    not interrupted until their completion.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.4 Static Scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In static scheduling  , the order of execution of tasks is calculated offline.
    Static scheduling is typical in time-triggered applications and with periodic
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.5 Dynamic Scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic schedulers  determine which task is to be executed when an event arrives,
    based on the current state of the system. The various dynamic scheduling algorithms
    differ according to the assumptions that are made.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.6 Independent Task Scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This category assumes that the tasks do not have any dependencies (e.g. mutual
    exclusion).
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “A distributed real-time system (DRTS) is made up of self-contained computational
    nodes linked by a real-time network.” Is this statement correct or incorrect?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.Which of the following describes a hard real-time system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can miss its deadline on a regular basis with a low possibility.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can miss its deadline from time to time, with a reasonable chance of doing so.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can occasionally miss its deadline due to some unacceptably low probability,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can miss its deadline from time to time, but with a low probability.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.Which of the following statements is correct for *state*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A state is a condition that lasts for a certain amount of time in real time.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A state is a condition that lasts for a non-real time span.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A state is a condition that does not last for a period of time.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A state is an unpredictably changing condition that lasts for a period of time.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.Which of the following statements about an *event* is correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An event is a happening that occurs in a particular state.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An event is a one-time non-occurrence.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An event is a one-time occurrence.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.Three pieces define a reference model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Workload model
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource model
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Algorithm
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Is this statement correct or incorrect?
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Review Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Correct. A distributed real-time system (DRTS) is made up of self-contained
    computational nodes linked by a real-time network and consists of autonomous computing
    nodes connected by a real-time network. The nodes in such a system cooperate to
    achieve a common goal within specified deadlines.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: D, Can miss its deadline from time to time, but with a low probability.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: A, A *state* is a condition that lasts for a certain amount of time
    in real time.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: C, An *event* is a one-time occurrence.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Correct. The main parts of the RT system model are the workload model,
    the resource model, and algorithms.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 9.8 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explained the time management of distributed systems. In addition,
    soft real-time and hard real-time systems were discussed, which illustrate the
    reference models. In order to implement a distributed system, it is necessary
    to understand this time management system. Scheduling algorithms are also an important
    concept of distributed systems, so the next chapter explains dynamic and static
    scheduling algorithms in the distributed system.
  prefs: []
  type: TYPE_NORMAL
