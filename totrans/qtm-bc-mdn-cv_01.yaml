- en: '© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022A.
    Kumar et al. (eds.)Quantum and Blockchain for Modern Computing Systems: Vision
    and AdvancementsLecture Notes on Data Engineering and Communications Technologies133[https://doi.org/10.1007/978-3-031-04613-1_1](https://doi.org/10.1007/978-3-031-04613-1_1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum Technologies I: Information, Communication, and Computation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emilio Peláez^([1](#Aff5) [ ](#ContactOfAuthor1)), Minh Pham^([1](#Aff5) [ ](#ContactOfAuthor2))
    and U. Shrikant^([2](#Aff6) [ ](#ContactOfAuthor3))(1)The University of Chicago,
    Chicago, IL, USA(2)The Institute of Mathematical Sciences, Chennai, IndiaEmilio Peláez (Corresponding
    author)Email: [epelaez@uchicago.edu](mailto:epelaez@uchicago.edu)Minh PhamEmail:
    [mpham26@uchicago.edu](mailto:mpham26@uchicago.edu)U. ShrikantEmail: [shrikantu@imsc.res.in](mailto:shrikantu@imsc.res.in)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduce some of the notions of quantum information science
    including aspects of information, information security, entanglement states, quantum
    gates, teleportation, direct secure communication, quantum secret sharing, quantum
    noise, quantum operations, quantum error correction, quantum circuits and quantum
    Toffoli gate. Most of these aspects are of importance in quantum enhanced technologies
    including quantum blockchain. The objective of this chapter is to introduce the
    basic notions of quantum information science aspects with its real-time need and
    usage, including some notes on how the above mentioned concepts and tools might
    be helpful in quantum blockchain technology. The chapter is organized into three
    major sections as follows. Starting from postulates of quantum mechanics, which
    set the basic rules of the theory which drastically deviates from the classical
    mechanics. Then we introduce, in Sect. [1](#Sec1) the basic notions of quantum
    information (QI) science as described in the abstract. Section [2](#Sec20) is
    dedicated to multiple controlled Toffoli gate, which may find its application
    in may areas of quantum computing and also in quantum blockchain. Section [3](#Sec39)
    is dedicated to certain aspects of quantum error correction, a scheme to protect
    qubits (units of quantum information) from environmental noise, which helps develop
    fault-tolerant quantum technologies. In Conclusion section, we note how the content
    in this chapter might be relevant to quantum blockchain technology. A table of
    symbols is given in Appendix.
  prefs: []
  type: TYPE_NORMAL
- en: 1 Quantum Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantum information (QI) science [[1](#CR1)] is now attracting scientists from
    different disciplines. Last decade has been intense for QI science, in theory
    and even in experiments. There have been announcements by various companies and
    academia about achieving the so-called “quantum supremacy”, a term coined by John
    Preskill. On the one hand, a quantum computer is purported to outperform any existing
    classical (digital) one, which is still a debated topic today. However, there
    are instances of true quantum supremacy that challenges any classical algorithm
    even in theory. On the other hand, unconditional security provided by quantum
    cryptography holds enormous promise for future quantum technologies and secure
    communication. Not to mention, very long distance and also satellite based quantum
    key distribution have been achieved. Currently, we are living in the Noisy Intermediate
    Scale Quantum (NISQ) era [[2](#CR2)] where NISQ devices are already in use for
    academic and industrial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: It pertinent to point out that quantum information finds its utility in foundations
    of physics, such as condensed matter theory, statistical mechanics, thermodynamics,
    black hole information paradox, foundations of quantum theory, and approaches
    to solving the long-standing puzzle of finding a quantum theory of gravity including
    string theory through AdS/CFT correspondence, to name a few. It provides a universal
    language to study theories without having to worry about what physical system
    one is using. For example, a quantum state (in discrete variable setting) is a
    density operator whether we are talking in terms of non-relativistic or relativistic
    quantum theory. The wonder about quantum theory is that it finds enormous applications
    in QI science, yet remains mysterious at the foundational level.
  prefs: []
  type: TYPE_NORMAL
- en: However, the aim and scope of this section of the chapter is restricted to introduce
    the basic notions of QI science. The reader is expected to have basic knowledge
    in quantum mechanics and linear algebra, and some basics of probability theory.
    We do not hope to cover all the topics in this section but only basics of QI that
    finds application in quantum blockchain technology. Quick instances of application
    to quantum cryptography and communication will be mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Postulates of Quantum Mechanics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we will take density matrix approach to quantum mechanics since it provides
    the most generic language for QI theory.
  prefs: []
  type: TYPE_NORMAL
- en: '**States and operators**. A quantum state is given by a vector in a Hilbert
    space. A state is is more generally represented by a density matrix with the properties
    that it is hermitian: ![$$\rho = \rho ^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq1.png),
    has unit trace: Tr![$$(\rho ) =1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq2.png),
    and is positive semi-definite: ![$$\rho \ge 0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq3.png).
    Since every hermitian operator has a spectral decomposition, the state can be
    written as ![$$\rho = \sum _i \lambda _i \left| {e_i} \right\rangle \left\langle
    {e_i} \right| $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq4.png).
    Here, ![$$ \left| {e_i} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq5.png)
    are the eigenvectors of ![$$\rho $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq6.png)
    with the corresponding eigenvalues ![$$\lambda _i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq7.png),
    with the requirement that ![$$\sum _i \lambda _i = 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq8.png)
    and ![$$0 \le \lambda _i \le 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq9.png).
    All *observables* are necessarily Hermitian operators and hence possess real eigenvalues.
    This is in conformity with what one sees in real experiments. An average of an
    observable is given by ![$$\langle O \rangle = \text {Tr}(O \rho )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq10.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mixed states* are those for which ![$$\text {Tr}(\rho ^2) &lt; 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq11.png)
    and *pure states* are those for which ![$$\text {Tr}(\rho ^2) = 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq12.png).
    We will later see that under a noisy evolution, a pure state is transformed into
    a mixed state, hence the density matrix formalism provides the most generic language
    for QI and the theories that are statistical in nature.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamics**. Quantum dynamics is given by a unitary matrix which takes a quantum
    state to a quantum state: ![$$\rho ^\prime = U \rho U^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq13.png),
    where ![$$U = \text {exp}\{- i H t / \hbar \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq14.png)
    is the unitary matrix with *H* being the Hamiltonian which is the generator of
    translation in time. The dynamics are unitary and reversible only for a closed
    system and a unitary operator maps orthogonal states to orthogonal states. We
    shall later see that for a more general (such as noisy) evolution, the dynamics
    need not be unitary and reversible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Measurement and Probabilities**. A measurement in quantum mechanics is given
    by the set of measurement operators ![$$\{M_i\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq15.png)
    satisfying ![$$\sum _i M^\dagger M \le \mathbbm {1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq16.png).
    The probability of obtaining an outcome *i* and the updated state after measurement,
    respectively, are given by![$$\begin{aligned} p(i) = \text {Tr}[M_i \rho M_i^\dagger
    ] \quad ; \quad \rho \rightarrow \rho ^\prime = \frac{M_i \rho M_i^\dagger }{p(i)}.
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ1.png)(1)The
    theory of measurements in quantum mechanics involves two types: projective operator
    measure (PVM) and positive operator valued measure (POVM). In fact, measurement
    is an *irreversible* process through which one learns the state of the system.
    Once measured, the state irreversibly *collapses* to a one of the basis states
    in which the measured state in expanded into. What quantum theory predicts is
    the probability of getting a particular basis state which is revealed only after
    measurement. Quantum measurement indeed acts as a bridge between quantum and classical
    worlds. Once measured, collapsing the quantum state, quantum information reduces
    to classical information!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite systems**. A multipartite state is given by the tensor product
    of individual parts. For example, a generic two qubit state may be given by ![$$
    \left| {\psi } \right\rangle ^{AB} = \sum _{i,j} p_{ij} \left| {\phi _i} \right\rangle
    \otimes \left| {\phi _j} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq17.png),
    where ![$$\otimes $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq18.png)
    represents the tensor product. A multipartite state is said to be *separable*
    if it can be written as a tensor product of individual parts. However, quantum
    mechanics allows for states that cannot be written as a tensor product of marginal
    states, and the particles represented by such a non-separable joint state are
    said to be quantum correlated. Examples will be introduced in subsequent sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Classical and Quantum Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classical and quantum information are *fundamentally* different [[1](#CR1),
    [3](#CR3)]. The basic unit of classical information is a *bit* such as a logical/physical
    0 or a 1\. Quantum information talks of information in terms of a “quantum bit”,
    *qubit* which is a quantum *superposition* of two states: ![$$ \left| {\text {qubit}}
    \right\rangle = \frac{1}{\sqrt{2}}( \left| {0} \right\rangle + \left| {1} \right\rangle
    )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq19.png), where
    ![$$ \left| {0} \right\rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix} $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq20.png)
    and ![$$ \left| {1} \right\rangle = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq21.png).
    These matrices may be thought of as corresponding to the orthogonal states of
    a two-level quantum system such as polarization degrees of a photon or spin degrees
    of an electron. In fact, these degrees of freedom define what type of quantum
    system we are talking about, and to be more precise the dimension determines the
    type of the system. In this subsection we will define some of the main measures
    of information, classical and quantum. And further mention some of the uses of
    these definitions in quantum information science.'
  prefs: []
  type: TYPE_NORMAL
- en: In 1948, Shannon [[4](#CR4)] gave an abstract theory of information which revolutionized
    the field of information science. Given a binary sequence of bits, which occur
    with some probability ![$$p_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq22.png),
    then the information contained in the signal is simply ![$$I = - \sum _i \log
    p_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq23.png). This
    tells us that the less probable an event is the more information it contains!
    Generally, such an abstract theory is able to provide a language for information
    processing which doesn’t depend on what physical systems are being used. It is
    now well known that *information is physical* in the sense that, quoting Landauer
    [[5](#CR5)], “information is not an abstract entity but exists only through a
    physical representation”, and hence limited by laws of physics.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, classical information is represented generally by binary bits
    0 and 1\. Classical computation follows the Boolean algebra. We shall not dwell
    much on classical computation here and we will focus on the ingredients that are
    useful in quantum communication and cryptography. Classical communication is done
    by encoding these bits into physical systems and sent down a communication channel.
    Most commonly used form of communication is using electromagnetic waves while
    the communication channel being free air or an optical fiber cable.
  prefs: []
  type: TYPE_NORMAL
- en: In classical information theory [[4](#CR4), [6](#CR6)], information in a signal
    is encoded as classical bits corresponding to events which occur with certain
    probability. Consider a random variable ![$$A \in \{a_1,a_2...\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq24.png),
    called the source with symbols ![$$a_1,a_2... $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq25.png)
    and so on, which occur with probability ![$$p_1,p_2...$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq26.png)
    and so on, respectively. Then the *Shannon entropy* (SE), which quantifies information
    in *A*, given as the negative average of the logarithm of the probability:![$$\begin{aligned}
    H(A) = - \sum _a p(A=a) \log (p(A=a)). \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ2.png)(2)Here,
    *H*(*A*) is SE and ![$$p(A=a)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq27.png)
    is the probability with which the random variable *A* takes the random value *a*.
    The logarithm is always taken to be base 2, unless otherwise stated. Based on
    the above definition, one can go on defining various measures of information originating
    from more than one source, say the random variables *A* and *B*. *Conditional
    entropy* (CE) quantifies the amount of information gained by measuring *A* when
    that of *Y* is known:![$$\begin{aligned} H(A \vert B) = - \sum _{a,b} p(a \vert
    b) \log [p(a \vert b)]. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ3.png)(3)*Joint
    entropy* (JE) of *A* and *B* is given by the information gained from measuring
    both *A* and *B*:![$$\begin{aligned} H(A,B) = - \sum _{a,b} p(a,b) \log [p(a,b)]
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ4.png)(4)where
    *p*(*a*, *b*) is the joint probability distribution of *A* and *B*. JE actually
    measures total uncertainty about *A*, *B*. In fact, CE and JE are related by the
    expression ![$$H(A,B) = H(A) + H(A \vert B)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq28.png).
    And Shannon entropy has the sub-additivity property given by ![$$H(A,B) \le H(A)+
    H(B)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq29.png),
    with the inequality holding when *A* and *B* are dependent and equality holding
    when they are independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a quantum state can be thought of as a compendium of probabilities, by
    simply replacing probability distribution with the density matrix, one can write
    down the *von Neumann entropy*: ![$$S = - \text {Tr}(\rho \log \rho )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq30.png).
    Since every Hermitian operator is a normal operator, it can be given a spectral
    decomposition (![$$\rho = \sum _i p_i \left| {i} \right\rangle \left\langle {i}
    \right| $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq31.png))
    and hence von Neumann entropy reduces to Shannon entropy ([2](#Equ2)) in the basis
    ![$$\{ \left| {i} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq32.png),
    which are the eigenvectors of ![$$\rho $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq33.png),
    and ![$$p_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq34.png)
    are the eigenvalues of the operator ![$$\rho $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq35.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum version of every definition of the classical entropy measures can be
    obtained by replacing the classical probability distribution (![$$p_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq36.png))
    with the density matrix (![$$\rho $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq37.png))
    and summation ![$$\sum _i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq38.png)
    with Trace operation. For example, conditional entropy is ![$$S(\rho _A\vert \rho
    _B) = S(\rho _{AB}) - S(\rho _A)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq39.png),
    where ![$$S(\rho _A) = - \text {Tr}(\rho _A \log \rho _A)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq40.png)
    and ![$$S(\rho _{AB}) = - \text {Tr}\rho _{AB} \log \rho _{AB}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq41.png),
    is the joint entropy of *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Distance Measures and Fidelity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A common question in classical information theory is to ask how close any two
    probability distributions are and how well can one tell them apart. A distance
    measure tells how much two probability distributions differ. In classical information
    theory, one learns about Kolmogorov distance [[1](#CR1)]: given two probability
    distributions *p* and *q*, the distance between them is given by ![$$d(p,q) =
    \frac{1}{2}\sum _i \vert p_i-q_i \vert $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq42.png).
    Whereas in quantum information theory, a number of equivalent distance measures
    are defined. For example, trace distance between any two quantum states ![$$\rho
    _1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq43.png) and
    ![$$\rho _2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq44.png)
    is defined as![$$\begin{aligned} D(\rho _1, \rho _2 ) = \frac{1}{2}\Vert (\rho
    _1-\rho _2) \Vert _1 \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ5.png)(5)where
    ![$$\Vert A \Vert _1 = \sqrt{A^\dagger A}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq45.png)
    is the ![$$L_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq46.png)
    norm or trace norm of an operator A. Trace distance in fact gives a maximum bound
    on how much information one can reliably send down a quantum channel while the
    distance is taken between the states ![$$\Phi [\rho ]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq47.png)
    and ![$$\rho $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq48.png),
    where ![$$\Phi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq49.png)
    is the quantum channel.^([1](#Fn1))One can also define a measure to quantify how
    close two states are which is given by the fidelity: ![$$F = \text {Tr}(\rho _1
    \rho _2) $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq50.png).
    Fidelity has other useful forms such as the one due to R Josza:![$$\begin{aligned}
    F = (\text {Tr}\sqrt{\sqrt{\rho _2} \rho _1 \sqrt{\rho _2}})^2\. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ6.png)(6)Uhlmann’s
    theorem for fidelity states that given a *purification* ![$$ \left| {\phi _{\rho
    _1}} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq51.png)
    of the a state ![$$\rho _1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq52.png)![$$\begin{aligned}
    \left| {\phi _{\rho _1}} \right\rangle = \sum _{i=1}^{k} \sqrt{p_i} \left| {i}
    \right\rangle \otimes \left| {i} \right\rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ7.png)(7)where
    ![$$\{ \left| {i} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq53.png)
    are the orthonormal basis in ![$$\mathcal {H}^k$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq54.png),
    then the fidelity![$$\begin{aligned} F(\rho _1,\rho _2) = \underset{{ \left| {\phi
    _{\rho _1}} \right\rangle }}{\text {max}}\; | \langle \phi _{\rho _1} \vert \phi
    _{\rho _2} \rangle |^2 \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ8.png)(8)quantifies
    the maximum overlap between purifications. Interestingly, trace distance ([5](#Equ5))
    is an upper bound of the fidelity:![$$\begin{aligned} F(\rho _1,\rho _2) \le 1
    - \frac{1}{4}\Vert \rho _1 - \rho _2 \Vert ^2\. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ9.png)(9)Another
    well-known distance measure is Bures distance: ![$$\mathcal {B} = \sqrt{2-2\sqrt{F(\rho
    _1,\rho _2)}}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq55.png),
    where ![$$F(\rho _1,\rho _2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq56.png)
    is the fidelity given in Eq. ([6](#Equ6)).'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2 Entangled States
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quantum entanglement [[7](#CR7)] is a type of spatial correlation between quantum
    systems that can not be created with classical resources. It finds applications
    in many areas of quantum information science, specifically quantum communication
    and cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a spatially quantum-correlated state is an entangled (Bell) state:![$$\begin{aligned}
    \left| {\phi } \right\rangle _{ij} = \frac{1}{\sqrt{2}}( \left| {0j} \right\rangle
    + (-1)^i) \left| {1\bar{j}} \right\rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ10.png)(10)Here,
    when ![$$ \left| {j} \right\rangle = \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq57.png),
    ![$$ \left| {\bar{j}} \right\rangle = \left| {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq58.png).
    The above four Bell states ![$$ \left| {\phi } \right\rangle _{ij}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq59.png)
    are orthonormal and form the so-called Bell basis ![$$\{ \left| {\phi } \right\rangle
    _{00}, \left| {\phi } \right\rangle _{01}, \left| {\phi } \right\rangle _{10},
    \left| {\phi } \right\rangle _{11}\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq60.png).
    However, there are other special class of *mixed* entangled states such as Werner
    state: a convex mixture of the four Bell states given in ([10](#Equ10))![$$\begin{aligned}
    \left| {\Psi } \right\rangle ^\mathrm{\small Werner} = f \left| {\phi } \right\rangle
    _{00} + \frac{1}{3}(1 - f) ( \left| {\phi } \right\rangle _{01} + \left| {\phi
    } \right\rangle _{10} + \left| {\phi } \right\rangle _{11} ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ11.png)(11)which
    is entangled only for ![$$ \frac{2}{3} \le f \le 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq61.png).
    This shows that a superposition of maximally entangled states need not be maximally
    entangled.Even today, multi-particle entanglement theory is not fully developed.
    However, there are a class of states, called GHZ^([2](#Fn2)) states, which find
    applications in quantum information science. A multi-*qubit* GHZ state given by
    [[8](#CR8)]![$$\begin{aligned} \left| {GHZ} \right\rangle = \frac{1}{\sqrt{2}}(
    \left| {000 \cdots 0} \right\rangle + \left| {111 \cdots 1} \right\rangle ). \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ12.png)(12)Here,
    the notion ![$$ \left| {000 \cdots 0} \right\rangle \equiv \left| {0} \right\rangle
    \otimes \left| {0} \right\rangle \otimes \left| {0} \right\rangle \otimes \cdots
    \otimes \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq62.png).
    Another class of multipartite entangled state, that finds numerous applications,
    is the *W* state. A simple 3-qubit *W* state is given by [[9](#CR9)]![$$\begin{aligned}
    \left| {W} \right\rangle = \frac{1}{\sqrt{2}}( \left| {001} \right\rangle + \left|
    {010} \right\rangle + \left| {100} \right\rangle ), \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ13.png)(13)GHZ
    and W states can be generalized for arbitrary higher (finite) dimensional systems,
    which we omit in this section for simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement need not necessarily be between only discrete variables. One can
    even create *hybrid* states of particles that are entangled between their continuous
    and discrete degrees of freedom. Entangled states, which were of theoretical interest,
    are now being exploited as resources in quantum computing [[10](#CR10)]. Another
    class of states are the *hyper*-entangled states [[11](#CR11), [12](#CR12)] in
    which two particles are entangled in more than one discrete degrees of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 Mutual Information, Holevo Bound and Information Security
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let *A* and *B* be two systems with corresponding quantum states ![$$\rho _A$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq63.png)
    and ![$$\rho _B$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq64.png),
    respectively. Quantum mutual information quantifies the amount of information
    common to both systems. Moreover, it is the measure of correlations between the
    two system states. It is given by [[1](#CR1)]![$$\begin{aligned} I(A:B) = S(A)
    + S(B) - S(A,B) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ14.png)(14)where
    *S*(*A* : *B*) is the joint entropy. Now suppose Alice wants to send information
    to Bob via general mixtures ![$$\rho _i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq65.png)
    prepared with probabilities ![$$p_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq66.png).
    This situation can occur when Alice sends pure states ![$$ \left| {\psi } \right\rangle
    _i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq67.png) down
    a *noisy* quantum channel, due to which the pure state becomes a mixed state.
    The total message is given by ![$$\rho = \sum _i p_i \rho _i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq68.png).
    Given that, how much information Bob can decode on his side? The amount of *classical*
    information he can extract is bounded by![$$\begin{aligned} I(A:B) \le S(\rho
    ) - \sum _i p_i S(\rho _i). \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ15.png)(15)The
    right hand side is called Holevo information or the ![$$\chi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq69.png)
    quantity. The amount of classical information that can be encoded in, and hence
    extracted from, a quantum system is upper bounded by ![$$\chi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq70.png)
    quantity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In quantum cryptography and communication, a protocol is provably secure if
    the mutual information between the legitimate parties *I*(*A* : *B*) is greater
    than that between Alice and the eavesdropper, Eve, i.e., ![$$I(A:B) &gt; I(A:E)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq71.png)
    which leads to positive secure key rate: ![$$\kappa = I(A:B) - I(A:E) &gt; 0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq72.png).
    However, this kind of security is in general true only for individual attacks,
    where Eve attacks the particle at every round of communication. More generally,
    Eve can adopt a strategy where she chooses to attack all the particles at the
    end, which is called the collective attack. In such a case the secure key rate
    is given by ![$$\kappa = I(A:B) - \chi (E)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq73.png),
    where ![$$\chi (E)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq74.png)
    is the Holevo information learned by Eve.'
  prefs: []
  type: TYPE_NORMAL
- en: The above definition of information security of quantum key distribution based
    on mutual information is not “composable”. It is in the sense that it is valid
    if one is restricted to only one cryptosystem. When more than one cryptosytems
    are used, one needs a composable definition. However, for many general purposes,
    it suffices to use the above definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.4 The No-Cloning Theorem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No cloning theorem states that given a quantum state ![$$ \left| {\psi } \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq75.png), there
    is no unitary operator such that ![$$U \left| {\phi } \right\rangle \rightarrow
    \left| {\phi } \right\rangle \left| {\phi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq76.png).
    The proof the theorem ultimately stems from the linearity of quantum mechanics.
    Let us assume that there exists a unitary *U* which clones the state ![$$ \left|
    {\phi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq77.png)
    such that ![$$U \left| {\psi } \right\rangle = \left| {\phi } \right\rangle \otimes
    \left| {\phi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq78.png).
    If ![$$ \left| {\phi _1} \right\rangle = \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq79.png),
    then ![$$U \left| {0} \right\rangle = \left| {0} \right\rangle \left| {0} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq80.png). However,
    if the state is *unknown* i.e., an arbitrary superposition ![$$ \left| {\phi }
    \right\rangle =\alpha \left| {\phi _1} \right\rangle + \beta \left| {\phi _2}
    \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq81.png),
    then due to linearity the copying machine should output ![$$ U \left| {\phi }
    \right\rangle = |\alpha |^2 \left| {\phi _1\phi _1} \right\rangle + |\beta |^2
    \left| {\phi _2\phi _2} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq82.png)
    which is not the same as![$$\begin{aligned} \left| {\psi } \right\rangle \otimes
    \left| {\psi } \right\rangle&amp;=(\alpha \left| {\phi _1} \right\rangle + \beta
    \left| {\phi _2} \right\rangle ) \otimes (\alpha \left| {\phi _1} \right\rangle
    + \beta \left| {\phi _2} \right\rangle ) \nonumber \\&amp;= |\alpha |^2 \left|
    {\phi _1\phi _1} \right\rangle + |\beta |^2 \left| {\phi _2\phi _2} \right\rangle
    + \alpha ^* \beta \left| {\phi _1\phi _2} \right\rangle + \beta ^* \alpha \left|
    {\phi _2\phi _1} \right\rangle . \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ16.png)(16)In
    other words, no cloning theorem states that an *unknown* quantum state cannot
    be cloned perfectly. Once measured, it collapses into a classical state which
    then can be obviously cloned. No cloning theorem also says that a pair of non-orthogonal
    states can’t be copied with perfect fidelity since they can’t be reliably distinguished
    in a measurement. Let ![$$\psi _1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq83.png)
    and ![$$\psi _2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq84.png)
    be two orthogonal states. Then ![$$U \left| {\psi _1} \right\rangle = \left| {\psi
    _1} \right\rangle \otimes \left| {\psi _1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq85.png)
    and ![$$U \left| {\psi _2} \right\rangle = \left| {\psi _2} \right\rangle \otimes
    \left| {\psi _2} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq86.png).
    Now, the overlap between the two states before and after cloning should be equal
    i.e. ![$$\langle \psi _1 \vert \psi _2 \rangle = (\langle \psi _1 \vert \psi _2
    \rangle )^2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq87.png)
    which is possible only when either both states are same, or both are orthogonal.
    For example, when ![$$ \left| {\psi _1} \right\rangle = \left| {+} \right\rangle
    = \frac{1}{\sqrt{2}}( \left| {0} \right\rangle + \left| {1} \right\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq88.png)
    and ![$$ \left| {\psi _2} \right\rangle = \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq89.png),
    these two states cannot be cloned with perfect fidelity because they are not orthogonal
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: No cloning has important and fundamental implications in quantum cryptography
    [[13](#CR13)]. An eavesdropper won’t be able to copy a quantum state without producing
    detectable disturbance, which then can be detected by the legitimate parties who
    wish to communicate secretly. More the disturbance one creates during a measurement
    process, the more information one will be able to gather about the quantum system
    being disturbed. This is at the heart of cryptographic security. The more an eavesdropper
    gets information by her measurements, the more she disturbs the system, hence
    gets caught in the process. However, there are necessary conditions that the communicating
    parties need to ensure for such a situation. For example, they need to randomly
    switch their basis with which they encode information in the system, and a classical
    public channel (assumed to be authentic) through which they share their basis
    information rather than measurement outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.5 Quantum Gates and Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In quantum computing, circuit formalism is most often preferred. One can realize
    a task by performing quantum gates on qubits. One of the important aspect to compare
    between classical and quantum computing is the notion of a universal gate set
    [[1](#CR1)]. In classical theory of computation, a set of AND and NOT gate together
    suffice to form a universal set. Interestingly, a Toffoli gate alone is sufficient
    for universality, and so is the Fredkin gate. Quite generally, a logic gate is
    a function ![$$f: \{0,1\}^i \rightarrow \{0,1\}^j$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq90.png),
    with *i* inputs and *j* outputs. For example, an exclusive-OR gate is given by
    2-input-1-output map: ![$$XOR: \{x,y\} \rightarrow x \oplus y$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq91.png),
    where ![$$\oplus $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq92.png)
    represents addition modulo 2.'
  prefs: []
  type: TYPE_NORMAL
- en: A quantum circuit is made of gates which transform an input state to an output
    state, and of wires that carry the quantum information via quantum states. Wires
    carry the bits around in space and time. A simplest set of quantum gates are the
    qubit gates. In fact, a set of all single qubit gates and a single two qubit gate
    suffice to form a universal set. It means that any qubit quantum gate as well
    as qubit circuit can be realized with the combination of these gates. Suppose
    a qubit quantum gate has *k* inputs and outputs, then the matrix, representing
    the gate, will be of ![$$2^k$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq93.png)
    degree. A two-qubit gate will be ![$$2^k = 4$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq94.png),
    i.e., a ![$$4 \times 4$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq95.png)
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-qubit gates An important group of transformations in quantum information
    is the Pauli group with operators![$$\begin{aligned} \sigma _1 = X = \begin{pmatrix}
    0 &amp;{} 1 \\ 1 &amp;{} 0 \end{pmatrix},\sigma _2 = Y = \begin{pmatrix} 0 &amp;{}
    -i \\ i &amp;{} 0 \end{pmatrix},\sigma _3 = Z = \begin{pmatrix} 1 &amp;{} 0 \\
    0 &amp;{} -1 \end{pmatrix} \; \text {and} \;\sigma _0 = \mathbbm {1} = \begin{pmatrix}
    1 &amp;{} 0 \\ 0 &amp;{} 1 \end{pmatrix}, \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ17.png)(17)which
    generate the dynamics of a two-level system, which can be realized on a Bloch
    sphere. Pauli operators are the generators of rotation in 2D Hilbert space. For
    example, rotation about an arbitrary direction ![$$\hat{n}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq96.png),
    the unitary matrix is given by ![$$R_{\hat{n}}(\theta ) = \exp \big (-i \theta
    \frac{\hbar }{2} (\mathbf {\sigma } \cdot \hat{n}) \big )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq97.png),
    where ![$$\mathbf {\sigma } = a_1 \sigma _1 + a_2 \sigma _2 + a_3 \sigma _3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq98.png)
    is the Pauli operator vector. An equal superposition of *X* and *Y* gives us a
    crucial transformation known as the Hadamard gate![$$\begin{aligned} H = \frac{1}{\sqrt{2}}(X+Z)
    = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 &amp;{} 1 \\ 1 &amp;{} -1 \end{pmatrix}.
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ18.png)(18)Complex
    phases play a central role in quantum dynamics. It is pertinent to introduce a
    phase gate:![$$\begin{aligned} P = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 &amp;{}
    0 \\ 0 &amp;{} e^{i \theta } \end{pmatrix}, \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ19.png)(19)where
    ![$$\theta \in \{0, 2\pi \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq99.png)
    value of which determines a particular action on the qubit. For example, one of
    the famous gate is the so-called ![$$\frac{\pi }{8}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq100.png)
    gate: ![$$T = \begin{pmatrix} 1 &amp;{} 0 \\ 0 &amp;{} e^{\frac{i \pi }{4}} \end{pmatrix}
    = e^{\frac{i \pi }{8}} \begin{pmatrix} e^{-\frac{i \pi }{8}} &amp;{} 0 \\ 0 &amp;{}
    e^{\frac{i \pi }{8}} \end{pmatrix}.$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq101.png)
    Note that for ![$$\theta = \pi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq102.png)
    one recovers the Z gate, which is nothing but a phase-flip.Two-qubit gates It
    is important in quantum information and computation to exploit quantum resources
    such as entanglement. Two qubit gates are used to manipulate two-qubit states,
    entangled or otherwise. A generic controlled-unitary qubit gate is given by![$$\begin{aligned}
    C_U = \left| {0} \right\rangle \left\langle {0} \right| \otimes \mathbbm {1}_2
    + \left| {1} \right\rangle \left\langle {1} \right| \otimes U \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ20.png)(20)which
    says that if the state of the control qubit is ![$$ \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq103.png),
    then do nothing ; and if it is ![$$ \left| {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq104.png),
    then apply the unitary *U*. For ![$$U = X$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq105.png),
    we get a controlled-NOT (CNOT) gate. Similarly, one can construct C-Y and C-Z
    gates.CNOT gate finds many interesting applications. Note that the CNOT gate is
    an entangling operation, which finds its use in going from computational basis
    ![$$\{ \left| {0} \right\rangle , \left| {1} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq106.png)
    to Bell basis ![$$\{ \left| {\phi } \right\rangle _{00}, \left| {\phi } \right\rangle
    _{01}, \left| {\phi } \right\rangle _{10}, \left| {\phi } \right\rangle _{11}\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq107.png).
    For example, in the Bell state measurement, as shown in the below quantum circuit
    Fig. [1](#Fig1), a Hadamard gate is applied on the first qubit, followed by a
    CNOT gate and then both qubits are measured in computational basis with measurement
    operators ![$$M_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq108.png)
    satisfying ![$$\sum _i M_i = \mathbbm {1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq109.png).
    Note, however, that it is not necessary to use CNOT for Bell state measurement.![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig1_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Bell state measurement [[1](#CR1)]. The initial states are chosen to be ![$$
    \left| {0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq110.png)
    for simplicity
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.6 Quantum Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Quantum systems are fragile since they are inevitably subject to ubiquitous
    environmental interactions. In reality, there is no such thing as perfectly closed
    quantum system, the system is alway *open* [[14](#CR14)]. When quantum system
    interacts with the environment, it loses its coherence, hence undergoes *decoherence*.
    That is, when a system is completely decohered, the off-diagonal terms (also called
    the coherences) in the density matrix vanish. Moreover, it may also lose its energy
    undergoing *dissipation*. Open system quantum mechanics now follows different
    set of axioms: (1) states are density matrices, (2) measurements are POVMS and
    (3) dynamics is fixed by a completely positive (CP) trace preserving (TP) map.
    The density matrix captures both pure and mixed state representations, POVMs are
    convex combination of PVMs and the dynamics is no more unitary but linear and
    CP, thus representing a physically valid evolution. That is, a not CP evolution
    is unphysical in the sense that corresponding dynamical map outputs a negative
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum technologies face the challenge of reducing errors due to noise and
    the aim and purpose of quantum error-correcting codes is to facilitate the functioning
    of a fault tolerant quantum computer which is robust against environmental hazards
    and faulty device induced errors. Studying decoherence is an important aspect
    of quantum information since any quantum computer must satisfy the so-called DiVincenzo
    criteria; one of them being the *long decoherence time* for qubit evolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose a qubit is interacting with an environment. Its evolution is governed
    by a master equation famously known as Gorini-Kossakowski-Lindblad-Sudarshan (GKSL)
    equation [[15](#CR15), [16](#CR16)], which is obtained assuming the so-called
    Born-Markov approximation. An equivalent representation, useful in quantum information
    science, is the operator-sum (KSMR)^([3](#Fn3)) representation [[17](#CR17), [18](#CR18)]
    of a CPTP map (a quantum channel):![$$\begin{aligned} \Phi [\rho ] = \sum _i K_i
    \rho K_i^\dagger \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ21.png)(21)where
    ![$$K_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq111.png)
    are called the KSMR operators [[1](#CR1)], satisfying ![$$\sum _i K^\dagger K
    = \mathbbm {1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq112.png),
    which can be obtained by tracing out the environmental degrees of freedom from
    the global unitary that generates system-environment evolution: ![$$\Phi [\rho
    ] = \text {Tr}\{U(\rho \otimes \rho _{\text {env}})U^\dagger \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq113.png).
    For simplicity, let us assume that the initial environmental state is ![$$\rho
    _{\text {env}} = \left| {0} \right\rangle \left\langle {0} \right| $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq114.png)
    and ![$$\{ \left| {e_i} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq115.png)
    are the environmental degrees of freedom, then ![$$K_i = \langle e_i \vert U \vert
    0 \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq116.png).
    KSMR operators representation is a powerful way of essentially capturing the noisy
    evolution of the qubit. We must remember that decoherence is basis dependent.
    That is, for example, what is decoherence in ![$$\{ \left| {0} \right\rangle ,
    \left| {1} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq117.png)
    is not decoherence in ![$$\{ \left| {-} \right\rangle , \left| {+} \right\rangle
    \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq118.png) basis!
    This has implications to how one develops errors correcting codes.Simple examples
    of errors that are commonly found for qubits are the bit-flip, phase-flip and
    bit-phase-flip errors. And others include depolarizing, amplitude damping and
    generalized amplitude damping errors. A class of qubit errors is known as Pauli
    errors that involve only Pauli group hence the name, These errors occur without
    dissipation that is they induce only decoherence. A qubit flip error can be written
    as![$$\begin{aligned} \Phi _i[\rho ] = (1-p) \rho + p U_i \rho U_i^\dagger \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ22.png)(22)where
    ![$$U_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq119.png)
    represents the a Pauli operator depending on which error occurs with probability
    *p*, e.g., ![$$U_{i=1,2,3} = \sigma _1,\sigma _2,\sigma _3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq120.png)
    for bit-flip, bit-phase-flip and phase-flip errors, respectively. There may be
    situations where more than one or all of the qubit errors occur. Another important
    qubit error is given by the depolarizing channel![$$\begin{aligned} \Phi ^\mathrm{\small
    depol}[\rho ] = (1-p) \rho + \frac{p}{3} \sum _{i=1}^{3} \sigma _i \rho \sigma
    _i^\dagger \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ23.png)(23)Another
    type of quantum channel is amplitude damping which captures dissipation or relaxation
    process. In this case, a particle not only lose coherence, but also population
    (or energy) while it relaxes or damps. It is given by the channel ![$$\Phi ^\mathrm{\small
    AD}[\rho ] = \sum _i A_i \rho A_i^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq121.png)
    with KSMR operators![$$\begin{aligned} A_1 = \frac{1}{2} \bigg ( \begin{array}{cc}
    1 &amp;{} 0 \\ 0 &amp;{} \sqrt{1- \lambda } \end{array}\bigg ) \quad \quad A_2
    = \frac{1}{2} \bigg ( \begin{array}{cc} 0 &amp;{} \sqrt{\lambda } \\ 0 &amp;{}
    0 \end{array}\bigg ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ24.png)(24)where
    ![$$\lambda $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq122.png)
    is called the damping factor, determined by the type of process. More will be
    talked about quantum error correction later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.7 Choi-Jamiolkowski Isomorphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the central tools of quantum information theory is the Choi-Jamiolkowski
    (CJ) isomorphism [[19](#CR19)]. It is mainly used to exploit the channel-state
    duality. Namely, any CPTP map (a channel) can be used to transform a state which
    will be isomorphic to the map. And the CJ matrix [[19](#CR19)] or B matrix^([4](#Fn4))
    [[18](#CR18)] is given by![$$\begin{aligned} \mathcal {\xi } = (\Phi \otimes \mathbbm
    {1})[ \left| {\psi ^+} \right\rangle \left\langle {\psi ^+} \right| ] \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ25.png)(25)where
    ![$$ \left| {\psi ^+} \right\rangle = \frac{1}{\sqrt{2}}( \left| {00} \right\rangle
    + \left| {11} \right\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq123.png)
    is a maximally entangled state in the computational basis. If the state ([25](#Equ25))
    is negative, then ![$$\Phi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq124.png)
    is a not-completely positive (NCP) map. Nevertheless, such a map will output a
    valid quantum state for single qubit space, it doesn’t do so in an extended Hilbert
    space; that is when it is acting on a part of the Bell state. This result follows
    from the Stinespring dilation theorem. Historically, Eq. ([25](#Equ25)) (now known
    as Sudarshan B matrix) was first demonstrated in the seminal work of Sudarshan,
    Rao and Mathews [[18](#CR18)], which was later independently discovered by Choi
    and Jamiolkowski. One should note that while it is possible to transform a dynamical
    map or a physical process to a state, the converse is necessarily not possible.
    One of the applications of a NCP map is to *witness* entanglement in a state—a
    method known as the Positive Partial Transpose (PPT) criterion [[7](#CR7)]: Given
    a bipartite state, if a partial transpose map acting on one half of the state
    renders the CJ matrix negative, then the state is entangled. We shall later see
    one of the applications of quantum operations applied to study open quantum system
    evolution.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Quantum Information Science—Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we will discuss some of the major applications of quantum information science
    namely teleportation, superdense coding and entanglement swapping that are not
    possible classically. It means that there exist no resources in the classical
    world with which one can reproduce the rather counter-intuitive effects applied
    to transmitting and manipulating information using quantum systems. In this subsection,
    our main motivation will be to explain how quantum entanglement plays the role
    of a resource in quantum communication and quantum technologies in general. We
    will also mention about the peaceful coexistence of quantum mechanics with the
    theory of special relativity in the sense that there will be no faster-than-speed-of-light
    communication involved when performing quantum information processing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 Superdense Coding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How does one send information using quantum particles? Quantum particles possess
    degrees of freedom in which information can be encoded. In fact, a particular
    degree of freedom, say polarization of a photon, can be used as a qubit. That
    is our quantum system which we manipulate in the lab. Now, bits of information
    can be encoded in the polarization of a photon and sent down a quantum channel.
    How many bits can Alice send to Bob with a single particle? With an isolated uncorrelated
    photon, she can send a single classical bit of information. Suppose, Alice and
    Bob share a maximally entangled pair of particles, then Alice can send two bits
    of information on a single qubit. This is known as superdense coding. Given an
    initial Bell state![$$\begin{aligned} \left| {\phi } \right\rangle _{00} = \frac{1}{\sqrt{2}}(
    \left| {00} \right\rangle + \left| {11} \right\rangle ), \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ26.png)(26)if
    Alice wants to send bits 00, she does nothing to her particles and send it to
    Bob. If Alice locally applies a ![$$\sigma _x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq125.png)
    gate, then the state transforms as![$$\begin{aligned} (\sigma _x \otimes \mathbbm
    {1}) \left| {\phi } \right\rangle _{00} = \frac{1}{\sqrt{2}}( \left| {10} \right\rangle
    + \left| {01} \right\rangle ) = \left| {\phi } \right\rangle _{01}. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ27.png)(27)Similarly,
    if she locally applies ![$$i\sigma _y$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq126.png)
    and ![$$\sigma _z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq127.png)
    gates, she transforms the state, respectively, as![$$\begin{aligned} (i\sigma
    _y \otimes \mathbbm {1}) \left| {\phi } \right\rangle _{00}= \frac{1}{\sqrt{2}}(
    \left| {01} \right\rangle - \left| {10} \right\rangle ) = \left| {\phi } \right\rangle
    _{11}, \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ28.png)(28)![$$\begin{aligned}
    (\sigma _z \otimes \mathbbm {1}) \left| {\phi } \right\rangle _{00}= \frac{1}{\sqrt{2}}(
    \left| {00} \right\rangle - \left| {11} \right\rangle ) = \left| {\phi } \right\rangle
    _{10}. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ29.png)(29)When
    Bob receives the qubit, he makes Bell measurements to find out one of the Bell
    states ![$$\{ \left| {\phi } \right\rangle _{00}, \left| {\phi } \right\rangle
    _{01}, \left| {\phi } \right\rangle _{10}, \left| {\phi } \right\rangle _{11}\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq128.png)
    corresponding to the bits ![$$\{00, 01,10,11\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq129.png)
    that Alice wanted to send him.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 Quantum Teleportation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Quantum teleportation is one of the striking features of quantum mechanics
    which allows communicating an unknown qubit using entanglement. The protocol goes
    as follows. Suppose that Alice wants to send an unknown quantum state ![$$ \left|
    {\psi } \right\rangle = \alpha \left| {0} \right\rangle + \beta \left| {1} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq130.png) to Bob,
    who is space-like separated from her i.e., light or information takes finite time
    to reach. Alice and Bob pre-share an entangled pair of qubits, an EPR-Bell state,
    say, ![$$ \left| {\phi } \right\rangle _{00} = \frac{1}{\sqrt{2}}( \left| {00}
    \right\rangle + \left| {11} \right\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq131.png).
    Now the initial total state of all the parities is:![$$\begin{aligned} \left|
    {\Psi } \right\rangle _\mathrm{\small initial}&amp;= \left| {\psi } \right\rangle
    \otimes \left| {\phi } \right\rangle _{00} \nonumber \\&amp;= (\alpha \left| {0}
    \right\rangle + \beta \left| {1} \right\rangle )\frac{1}{\sqrt{2}}( \left| {00}
    \right\rangle + \left| {11} \right\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ30.png)(30)Alice
    *entangles* her part of the EPR-Bell pair with the unkown state ![$$ \left| {\psi
    } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq132.png)
    to be teleported i.e., she performs a CNOT gate ![$$C_N = \left| {0} \right\rangle
    \left\langle {0} \right| \otimes \mathbbm {1}_2 + \left| {1} \right\rangle \left\langle
    {1} \right| \otimes \sigma _x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq133.png)
    on her pair. Subsequently, she performs a Hadamard gate ![$$ H = \frac{1}{\sqrt{2}}
    \bigg ( \begin{array}{cc} 1 &amp;{} 1 \\ 1 &amp;{} -1 \end{array}\bigg )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq134.png)
    on the *first* qubit. Here, ![$$\mathbbm {1}_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq135.png)
    and ![$$\sigma _x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq136.png)
    are qubit identity and Pauli-X operators. After all of this, simple algebra gives
    the resulting total state:![$$\begin{aligned} \left| {\tilde{\Psi }} \right\rangle&amp;=
    \frac{\alpha }{2}( \left| {0} \right\rangle + \left| {1} \right\rangle )( \left|
    {00} \right\rangle + \left| {11} \right\rangle ) + \frac{\beta }{2} ( \left| {0}
    \right\rangle - \left| {1} \right\rangle )( \left| {10} \right\rangle + \left|
    {01} \right\rangle ) \nonumber \\&amp;= \frac{1}{2}[ \left| {00} \right\rangle
    (\alpha \left| {0} \right\rangle +\beta \left| {1} \right\rangle ) + \left| {01}
    \right\rangle (\alpha \left| {1} \right\rangle +\beta \left| {0} \right\rangle
    ) + \left| {10} \right\rangle (\alpha \left| {0} \right\rangle -\beta \left| {1}
    \right\rangle ) + \left| {11} \right\rangle (\alpha \left| {1} \right\rangle -\beta
    \left| {0} \right\rangle )]. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ31.png)(31)As
    before, Alice possesses her first two qubits of the state ![$$ \left| {\tilde{\Psi
    }} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq137.png)
    and Bob the third one. Now comes the magical part of quantum teleportation. Alice
    now measures her pair of qubits in the computational basis ![$$\{ \left| {0} \right\rangle
    , \left| {1} \right\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq138.png),^([5](#Fn5))
    which *teleports* the unknown state ![$$ \left| {\psi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq139.png)
    to Bob *instantaneously*! If Bob makes a measurement on his qubit now, then he
    has ![$$\frac{1}{4}^\mathrm{\small th}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq140.png)
    probability of getting either of the 4 states ![$$\{(\alpha \left| {0} \right\rangle
    \pm \beta \left| {1} \right\rangle ), (\alpha \left| {1} \right\rangle \pm \beta
    \left| {0} \right\rangle )\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq141.png)
    depending on which Bell basis Alice finds her pair to be in. For example, if she
    finds her pair’s state to be ![$$ \left| {01} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq142.png)
    then the state teleported to Bob is ![$$(\alpha \left| {1} \right\rangle + \beta
    \left| {0} \right\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq143.png).
    Alice now communicates her basis information, for which she has to send 2 bits
    of information over a classical channel. This part of communication is restricted
    by special relativity: she can’t send her information faster than speed of light.
    Therefore, unless Alice tells Bob her basis information, Bob never recovers the
    state ![$$ \left| {\psi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq144.png)
    which Alice actually wanted to send him! The final stage of the protocol is that
    based on Alice’s basis information, Bob does a corresponding Pauli operation to
    transform the state to the actual state ![$$ \left| {\psi } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq145.png)
    Alice wanted to send. That is, if Alice’s finds her pair to be in ![$$ \left|
    {10} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq146.png),
    the Bob performs a ![$$\sigma _z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq147.png)
    to recover the state. Therefore, they *must* use classical communication to achieve
    teleportation!'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, no-cloning theorem and no-faster-than-speed-of-light transfer
    of information are related. If Bob can make a large copies of his particle, then
    he can make a measurement on each of them, and the basis which returns the same
    result is the basis Alice would have encoded in. But again, copying an unknown
    state is prohibited by no-cloning! Therefore, Bob can never recover his state
    without Alice’s classical message.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum teleportation finds enormous applications in quantum technologies. One
    of the immediate application is in quantun internet—a quantum network to exchange
    quantum states between the nodes with distributed entanglement. Another application
    is in teleportation based quantum computing. In fact, teleportation has been achieved
    for very long distances, about 143 km long [[20](#CR20)], and also using satellite
    based quantum entangled particles achieving 1,400 km distance [[21](#CR21)]. Such
    practical, long distance teleportation will be key to a global quantum internet.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.3 Entanglement Swapping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Yet another type of process which doesn’t have a classical analog is entanglement
    swapping which finds its use in quantum network based communication. Here, we
    briefly explain it below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, for two quantum particles to be entangled, they must have interacted
    sometime in the past through some physical process. Entanglement swapping is a
    technique of exploiting quantum measurement and entanglement itself to entangle
    two particles that have never interacted before! Suppose, ![$$\{a,b\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq148.png)
    and ![$$\{c,d\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq149.png)
    are pairs of particles with Alice and Bob, respectively. *a* is entangled with
    *b*; and *c* is entangled with *d*. Now, *a* and *c* have never interacted in
    the past. Question is: Can ![$$\{a,c\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq150.png)
    get entangled? The answer turns out to be yes, and this is one of the spooky phenomena
    allowed by quantum mechanics! It goes as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose Alice has an entangled pair ![$$ \left| {\phi } \right\rangle _{ab}
    = \frac{1}{\sqrt{2}}( \left| {00} \right\rangle _{ab}+ \left| {11} \right\rangle
    _{ab})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq151.png).
    Similarly, Bob has ![$$ \left| {\phi } \right\rangle _{cd} = \frac{1}{\sqrt{2}}(
    \left| {00} \right\rangle _{cd}+ \left| {11} \right\rangle _{cd})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq152.png).
    So the initial state is:![$$\begin{aligned} \left| {\psi } \right\rangle _\mathrm{\small
    initial} = \left| {\phi } \right\rangle _{ab} \otimes \left| {\phi } \right\rangle
    _{cd}. \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ32.png)(32)Now,
    this initial state is sent to a third party Charlie who does a Bell-state measurement
    on ![$$\{b,d\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq153.png),
    as explained previously, and as a result ![$$\{a,c\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq154.png)
    get entangled! This shows one of the spooky features of measurement and entanglement
    in quantum physics. Note that entanglement swapping has been realized experimentally
    [[22](#CR22), [23](#CR23)].
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.4 Quantum Cryptography and Communication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ever since Bennett and Brassard proposed the famous BB84 quantum key distribution
    protocol in 1984, there has been an intense research toward developing more secure
    communication protocols for more than 3 decades now. And that has been achieved
    to a significant extent. Still there appears to be much more to be achieved at
    theoretical and experimental frontiers. Specifically, there is a challenge of
    building a *scaleable* quantum secure communication system and quantum computing
    machines, that will outperform the existing classical information processing systems.
    Nevertheless, there are also efforts being put to develop classical encryption
    algorithms that will provide post-quantum cryptographic security, meaning that
    they will provide security against a threat from attacks by a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the striking application of entanglement is in secure *direct* quantum
    communication protocol. Here, it is pertinent to briefly explain one such protocol,
    fist introduced in 2002 by Bostrom and Felbinger [[24](#CR24)]:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob has a pair of photons entangled in polarization degree, say, ![$$ \left|
    {\phi ^+_{ht}} \right\rangle = \frac{1}{\sqrt{2}} ( \left| {01} \right\rangle
    + \left| {10} \right\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq155.png)
    one of which he keeps with himself (home photon in the state ![$$\rho _h$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq156.png))
    and the other (travel photon in the state ![$$\rho _t$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq157.png))
    he sends to Alice who is at a long distance from him.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once Alice receives the qubit, she does either an identity or Pauli-Z operation
    on it, each with probability ![$$\frac{1}{2}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq158.png)
    and sends it back to Bob.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After receiving the travel qubit back, Bob does a Bell state measurement on
    them, and finds his pair of particles either in ![$$ \left| {\phi ^+} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq159.png) or ![$$
    \left| {\phi ^-} \right\rangle = (\mathbbm {1} \otimes \sigma _z)[ \left| {\phi
    ^+} \right\rangle ]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq160.png),
    depending whether Alice wants to send him 0 or 1, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Bob finds the pair to be anti-correlated, then they abort the protocol. If
    he finds his particles to be in either of the Bell states ![$$ \left| {\phi ^\pm
    } \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq161.png)
    then the protocol is repeated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, if an eavesdropper tries to measure the flying qubit, all she finds is
    perfectly random outcomes, since the reduced density matrix ![$$\rho _t = \text
    {Tr}_h( \left| {\phi ^+_{ht}} \right\rangle \left\langle {\phi ^+_{ht}} \right|
    )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq162.png) of
    a *maximally* entangled state ![$$\rho ^{AB}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq163.png)
    is a maximal mixture i.e., ![$$\rho _t=\frac{I}{2}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq164.png).
    Note that Alice and Bob never used a classical channel to communicate the basis
    information and the information transmitted was direct and deterministic. Here,
    we immediately see the advantage of using an entanglement for the security of
    QKD as well as direction quantum communication. However, Wojcik [[25](#CR25)]
    introduced a clever attack on this protocol using which the eavesdropper could
    get as much information as Alice and Bob will have at the end. Thence, the security
    check was extended to analyzing channel losses induced due to eavesdropping. The
    reader is referred to Refs. [[25](#CR25), [26](#CR26)] for further study.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol has a disadvantage that it is quasi-secure when it is used for
    direct communication but comes with an advantage of being fully secure when used
    for a key distribution. Moreover, all two-way protocols suffer from the point
    of view of resources needed for an extra round of sending the particle down a
    quantum channel. Some of the one-way QKD protocols, couterfactual or otherwise,
    will be introduced in a later section. Surprisingly, in a counterfactual key distribution
    protocol, Alice and Bob can choose to generate a secret key for which the particle
    actually doesn’t travel through the quantum channel (interferometric arm, in this
    case) with certain probability! This interesting feature for secure QKD will be
    discussed in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.5 Quantum Secret Sharing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The idea of sharing a secret among untrusted individuals is a very relevant
    problem. A brief introduction is given [as in Ref. [[27](#CR27)] and the reference
    therein] below [see Fig. [2](#Fig2)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An individual (Alice) has to share a secret among two or more untrusted parties
    (Bob, Charlie, Dave,...) so that no single party can decode it, but at least half
    of them must come together to do so.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.g., key ![$$K \equiv 11010 \Longleftrightarrow b (= 10001) + c (= 01001)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq165.png)
    is shared b/w Bob and Charlie. Thus *b* and *c* are shares for the key. Knowing
    only one of them, no information of *K* obtainable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.Secret *S* is to be divided between *n* parties such that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$$\ge k$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq166.png)
    parties necessary and enough number to reconstruct *S*.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$$k-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq167.png)
    parties get zero info.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a polynomial of degree ![$$k-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq168.png)
    (over a prime # field), at least *k* points are required. Each share is the triple
    (*x*, *f*(*x*), *P*).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example: quadratic polynomial ![$$f(x) = a_0 + a_1x + a_2x^2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq169.png)
    where ![$$a_0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq170.png)
    is the secret (a prime number). We share (*x*, *f*(*x*)) for *n* number of parties,
    then at least three parties must come together to get ![$$a_0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq171.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: A schematic of a secret sharing protocol for the case of a key shared with three
    untrusted parties
  prefs: []
  type: TYPE_NORMAL
- en: Quantum secret sharing schemes offer security based on no-go theorems in quantum
    mechanics, unlike computational hardness of a problem, as in classical counterpart.
    A simple protocol is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Four parties ![$$\{A,B,C,D,E\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq172.png):
    collection of sets that can reconstruct secret: ![$$\mathcal {G} = \{\{A,B,C\}
    , \{C,D\}, \{A,B,E\}\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq173.png).
    Here ![$$\mathcal {G}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq174.png)
    is the access structure [[27](#CR27)].'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Quantum case: no-cloning theorem ![$$\Rightarrow $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq175.png)
    no two disjoint elements in ![$$\mathcal {G}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq176.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classical keys + QKD solves the eavesdropping problem; thus QSS best motivated
    for **quantum** secrets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let us suppose a GHZ triplet is shared between three parties, Alice, Bob and
    Charlie in the state [[28](#CR28)]![$$\begin{aligned} \left| {\psi } \right\rangle
    = \frac{1}{\sqrt{2}} ( \left| {000} \right\rangle + \left| {111} \right\rangle
    ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ33.png)(33)Alice
    and Bob choose randomly to measure their particle in either X or Y direction,
    which can give eigenvalues of ![$$\pm 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq177.png),
    represented by ![$$\pm \mathrm{X}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq178.png)
    or ![$$\pm \mathrm{Y}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq179.png).
    Writing GHZ state in XY bases, we construct the Table [1](#Tab1) [[29](#CR29)].Table
    1
  prefs: []
  type: TYPE_NORMAL
- en: A table representing the Pauli bases in which the particle in measured
  prefs: []
  type: TYPE_NORMAL
- en: '|   | + X | – X | + Y | – Y |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| + X | ![$$ \left&#124; {0} \right\rangle + \left&#124; {1} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq180.png) | ![$$
    \left&#124; {0} \right\rangle - \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq181.png)
    | ![$$ \left&#124; {0} \right\rangle - i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq182.png)
    | ![$$ \left&#124; {0} \right\rangle + i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq183.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| – Y | ![$$ \left&#124; {0} \right\rangle - \left&#124; {1} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq184.png) | ![$$
    \left&#124; {0} \right\rangle + \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq185.png)
    | ![$$ \left&#124; {0} \right\rangle + i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq186.png)
    | ![$$ \left&#124; {0} \right\rangle - i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq187.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| + Y | ![$$ \left&#124; {0} \right\rangle - i \left&#124; {1} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq188.png) | ![$$
    \left&#124; {0} \right\rangle + i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq189.png)
    | ![$$ \left&#124; {0} \right\rangle - \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq190.png)
    | ![$$ \left&#124; {0} \right\rangle + \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq191.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| – Y | ![$$ \left&#124; {0} \right\rangle + i \left&#124; {1} \right\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq192.png) | ![$$
    \left&#124; {0} \right\rangle - i \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq193.png)
    | ![$$ \left&#124; {0} \right\rangle + \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq194.png)
    | ![$$ \left&#124; {0} \right\rangle - \left&#124; {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq195.png)
    |'
  prefs: []
  type: TYPE_TB
- en: 1.3.6 Open Quantum System Dynamics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Quantum operations provide a clean method to represent and study open quantum
    system dynamics—Markovian and non-Markovian [[30](#CR30), [31](#CR31)]. In realistic
    situations, most of the open system dynamics are non-Markovian (NM) as Born-Markov
    approximation may not hold. Recently there have been enormous efforts to study
    NM dynamics from an information theoretic viewpoint. For example, the first simple
    method of detecting and quantifying non-Markovianity (NM-ity) was proposed by
    Breuer-Laine-Piilo (BLP) [[32](#CR32)] which exploits that fact that trace distance
    (TD) ([5](#Equ5)) is a monotone under a Markovian CPTP map ![$$\Phi (t)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq196.png):
    ![$$D(\Phi (t)[\rho _1],\Phi (t)[\rho _2]) \le D(\rho _1, \rho _2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq197.png),
    where *D* is TD and ![$$\rho _1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq198.png)
    and ![$$\rho _2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq199.png)
    are two orthogonal initial states. This means that as the initial orthogonal states
    become more and more indistinguishable as time evolves. This has been interpreted
    as quantum information-loss to the environment. Crucial observation is that under
    a NM channel this monotonicity will be broken, in the sense that the information
    lost to the environment flows back to the system. Hence, the non-monotonous regions
    can be used to quantify NM-ity. The BLP measure is given by ![$$N_\mathrm{\small
    BLP} = \int _{\sigma &gt; 0} \sigma (\Phi , \rho _1,\rho _2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq200.png)
    where ![$$\sigma = \frac{dD}{dt}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq201.png).
    Another method of detecting and quantifying NM-ity is due to Rivas-Huelga-Plenio
    (RHP) [[33](#CR33)] based on the divisibility of the channel. Given a CPTP map
    ![$$\Phi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq202.png),
    it can be decomposed into a concatenation of intermediate maps for, say, simple
    3 instances: ![$$\Phi (t_2,t_0) = \Phi (t_2,t_1)\Phi (t_1,t_0)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq203.png).
    If the CJ matrix ([25](#Equ25)) of the intermediate map ![$$\Phi (t_2,t_1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq204.png)
    is negative (i.e., if the intermediate map is not a channel), then the CPTP map
    ![$$\Phi (t_2,t_0)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq205.png)
    is CP-*indivisible* and termed NM according to RHP. And the NM-ity is quantified
    as ![$$N_\mathrm{\small RHP} = \int _{0}^{\infty } g(t)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq206.png),
    where ![$$g(t) = \lim _{\epsilon \rightarrow 0^+} \frac{\Vert \xi (\Phi , \epsilon
    ) \Vert _1 - 1}{\epsilon }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq207.png),
    where ![$$\epsilon $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq208.png)
    is infinitesimal time and ![$$\xi (\Phi , \epsilon )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq209.png)
    represents the CJ matrix of the map in the infinitesimal time limit. Note that
    both BLP and RHP measures need not be normalized, and suitable normalization can
    be used to fit them in the range 0 to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than the above two, there have been a number of approaches to quantify
    NM-ity—based on fidelity [[34](#CR34)], capacity of channel [[35](#CR35)], causality
    measure [[36](#CR36)], interferometric power, accessible information and many
    more. However, there are in-equivalences. When multiple decoherence channels are
    involved in a process, then BLP and RHP need not be equivalent. But for a qubit
    dynamics involving a single decoherence channel they are known to be equivalent.
    Another interesting and intriguing way NM-ity may arise is through convex combination
    of Markovian channels. In the case of unital channels,^([6](#Fn6)) it is known
    that the space of Pauli Markovian (CP-divisible) channels is not convex [[37](#CR37)–[39](#CR39)].
    If one takes a convex combination of two Pauli semigroups, the resulting channel
    is non-Markovian in the sense that it is CP-indivisible. Moreover, it can be eternally
    non-Markovian according RHP measure in the sense that it is CP-indivisible from
    time ![$$t=0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq212.png)
    and remains so forever. However, such a channel is still Markovian according to
    BLP measure [[40](#CR40)]. This is one striking example where witnesses and measures
    of non-Markovianity are shown to be in-equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum NM-ity has been claimed to play, under some special circumstances, a
    useful role in quantum information processing tasks. For example, the quantum
    channel capacity can be improved as the non-Markovianity is increased due to detuning
    [[35](#CR35)] in a damped Jaynes-Cummings model. Similarly, efficiency of heat
    engines is argued to increase, and NM-ity also helps increase the quantum battery
    efficiency [[41](#CR41)]. We will mention next how deliberately added NM noise
    can provide security against an attack on entanglement based QKD protocol. All
    these advantages may be attributed to certain peculiar nature of quantum noise
    and to the information back-flow due to non-Markovian nature open system evolution
    [[42](#CR42)].
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.7 Counter-Intuitive Nature of Quantum Noise
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is generally accepted that quantum noise is detrimental to quantum information
    processing tasks. This need not be always true. Information processing tasks are
    affected by environmental noise hence the communication done by the parties is
    assumed to be through a noisy quantum communication channel. As noted earlier,
    an eavesdropper can be thought of noise in the final data that Alice and Bob gather
    after running the key exchange protocol. Interestingly, *deliberately* adding
    some *classical* noise to the measurement data can in fact boost the secure key
    rate [[43](#CR43)]. Later works show that deliberately adding *quantum* noise
    before final measurement by Bob, can add to the advantage of legitimate parties
    over an eavesdropper [[44](#CR44), [45](#CR45)]. This is in the sense that the
    mutual information between Alice and Bob becomes more compared to the information
    gathered by Eve. These advantages produced by deliberately adding quantum noise
    may be specific to protocols and the attack strategies of eavesdropping [[42](#CR42)].
    Here, we see that quantum noise plays a counter-intuitive role in quantum cryptography.
    One may call such a noise as “trusted”. Similar results have been presented in
    the case of continuous variable QKD as well [[46](#CR46)]. However, the way trusted
    noise is defined differs from that of in discrete variable QKD.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting area where quantum noise plays such a role is quantum transport
    in photosynthetic complexes [[47](#CR47)]. These complexes can be thought of as
    quantum networks on which an exciton is transferred. There are arguments and experimental
    evidences that long-lived coherences are present in green sulfur bacteria [[48](#CR48)].
    So, it is natural ask if Nature is exploiting quantum effects, such as the long-lived
    coherences, for efficient transfer of exciton energy in quantum transport [[49](#CR49),
    [50](#CR50)]. It turns out that quantum noise, such dephasing, may be assisting
    such transport to be achieved with efficiency as high as 99%! [[51](#CR51)]. It
    is rather counter-intuitive of Nature to exploit noise rather than quantum nature,
    such as coherence for efficient energy transfer. However, the entire reason for
    such a highly efficient quantum transport remains an active research area to date,
    spurring lively debates among quantum physicists and chemists alike [[49](#CR49),
    [50](#CR50)].
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Quantum Block Chains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A blockchain is a decentralized ledger, with no central authority looking after
    all the transactions and exchange of information occurring in the ledger. There
    is a lack of trust inside such an exchanging system but these are tackled by hashing,
    timestamp, and consensus algorithms. These are some of the aspects that make blockchain
    reliable. However, quantum computers can pose a threat to blockchain technology
    since its security depends on cryptography based on one-way hashing. Prime examples
    include the cryptocurrencies such as etherium, bitcoin, ripple, etc. Therefore,
    the development of quantum analogue of blockchain is in order.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum blockchain technology is an active area of research and is open to newer,
    faster approaches. The need for a blockchain inherently built using quantum properties
    is due to the recent developments in quantum technologies such as quantum computing
    and few algorithms. In a gist, the quantum blockchain uses the property of temporal
    entanglement of Bell states and GHZ states to form the chain and network of the
    quantum blockchain. That is, a single unit of the temporal GHZ state acts as a
    time-stamp whose information security provides the analog of security provided
    by one-way hashing in classical blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Quite a lot of the technicalities have been simplified here but there is a lot
    more than meets the eye on blockchain and quantum blockchain which will be, which
    will be noted in conclusions and further discussed in detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Multiple Controlled Toffoli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The quantum computing paradigm was first theorized in the 1980s with the quantum
    Turing machine by Benioff [[52](#CR52)]. Over the last 40 years, there have been
    many significant breakthroughs in quantum algorithms that help consolidate the
    quantum computing model. Some of the most notable innovations include Shor’s factoring
    algorithm, Grover’s search algorithm, and most recently, the variational quantum
    eigensolver. These algorithms take advantage of the unique properties of quantum
    systems, such as superposition, interference, and entanglement, to provide non-trivial
    speed up to classical problems.
  prefs: []
  type: TYPE_NORMAL
- en: The “black box” oracle is one similarity that quantum algorithms share. This
    type of oracle encodes information about the system of interest and uses controlled
    operations between different qubits in the quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: The multiple-controlled Toffoli gate is one such controlled operation that is
    of interest to quantum computing scientists. When acting on two qubits, it is
    the reversible analogs of the classical XOR gate. And on three qubits, it is the
    quantum analog of the AND gate. This chapter summarizes different constructions
    of the multiple-controlled Toffoli gate. We will also introduce a small yet novel
    improvement to one of these constructions. In the end, we will provide a shortlist
    of the most efficient implementations when minimizing CNOT count.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section gives a brief review of some circuit identities that will be useful
    for understanding the constructions later on.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Rotation Gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The three single-qubit rotation gates ![$$R_x, R_y, R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq213.png)
    rotate the state-vector by an angle of ![$$\theta $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq214.png)
    radians around the *x*, *y*, and *z* axis, respectively. When ![$$\theta = \pi
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq215.png), these
    rotation gates take on special forms called the Pauli matrices denoted *X*, *Y*, *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: The ![$$R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq216.png)
    gate has a special form called the phase gate, denoted *P*, which differs from
    ![$$R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq217.png)
    by a global phase. The relationship between these two gates is given by![$$\begin{aligned}
    P(\theta ) = e^{i\frac{\theta }{2}} R_z(\theta ) = \begin{pmatrix} 1 &amp;{} 0
    \\ 0 &amp;{} e^{i\theta }\end{pmatrix} \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ34.png)(34)
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2 Hadamard Identities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Hadamard gates transform rotations in the *z* basis to that in the *x* basis
    and vice versa.![$$\begin{aligned} HR_z(\theta )H&amp;= R_x(\theta ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ35.png)(35)![$$\begin{aligned}
    HR_x(\theta )H&amp;= R_z(\theta ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ36.png)(36)When
    ![$$\theta = \pi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq218.png),
    we have the special case![$$\begin{aligned} HZH = X \quad \text {and} \quad HXH
    = Z \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ37.png)(37)
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.3 Controlled Gates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest controlled operation is the CNOT gate, lesser-known as the Feynman
    gate. This gate acts on a control bit ![$$ \left| {q_0} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq219.png)
    and target bit ![$$ \left| {q_1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq220.png).
    When both of the inputs are in the *z* basis states, CNOT performs a bit-flip
    on the target bit if the control bit is ![$$ \left| {1} \right\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq221.png).
    In other words,![$$\begin{aligned} \mathrm {CNOT} \left| {q_0 q_1} \right\rangle
    = {\left\{ \begin{array}{ll} \left| {q_0 q_1} \right\rangle \text { if } q_0 =
    0 \\ \left| {q_0 \overline{q_1} } \right\rangle \text { if } q_0 = 1\end{array}\right.
    } \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ38.png)(38)We
    represent the CNOT gate on a circuit with a dot on the control bit. We draw a
    line connecting it with an XOR circle on the target bit, as illustrated by Fig.
    [3](#Fig3). The CNOT gate shown above has the unitary matrix![$$\begin{aligned}
    \text {CNOT} = \begin{pmatrix} 1&amp;{}0&amp;{}0&amp;{}0 \\ 0&amp;{}1&amp;{}0&amp;{}0
    \\ 0&amp;{}0&amp;{}0&amp;{}1 \\ 0&amp;{}0&amp;{}1&amp;{}0 \end{pmatrix} = \begin{pmatrix}
    \begin{array}{c | c} I &amp;{} 0 \\ \hline 0 &amp;{} X \end{array} \end{pmatrix}\end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ39.png)(39)![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: Action of CNOT gate
  prefs: []
  type: TYPE_NORMAL
- en: We now generalize this to any two-qubit controlled unitary operation. When the
    control bit is ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq222.png)
    the operator applied to the target bit is a one-qubit unitary ![$$U= \begin{pmatrix}
    a&amp;{}b \\ c&amp;{}d \end{pmatrix}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq223.png).![$$\begin{aligned}
    CU \left| {q_0 q_1} \right\rangle = {\left\{ \begin{array}{ll} \left| {q_0} \right\rangle
    \left| {q_1} \right\rangle &amp;{}\text { if } q_0 = 0 \\ \left| {q_0} \right\rangle
    U \left| { q_1} \right\rangle &amp;{}\text { if } q_0 = 1 \end{array}\right. }
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ40.png)(40)Again,
    when both input bits are in the basis states, we devise a shorthand notation for
    representing the controlled operation as matrix power ![$$I\otimes U^{k}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq224.png),
    where *k* is the computational basis value of the control bit. We draw such a
    gate by replacing the XOR operation for an arbitrary *U*, as Fig. [4](#Fig4) shows.
    The unitary matrix is similar to that of Eq. [39](#Equ39); now with the ![$$(2
    \times 2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq225.png)
    matrix *U* in the bottom right quadrant.![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: Action of CU gate
  prefs: []
  type: TYPE_NORMAL
- en: '![$$\begin{aligned} CU = \begin{pmatrix} 1&amp;{}0&amp;{}0&amp;{}0 \\ 0&amp;{}1&amp;{}0&amp;{}0
    \\ 0&amp;{}0&amp;{}a&amp;{}b \\ 0&amp;{}0&amp;{}c&amp;{}d \end{pmatrix} = \begin{pmatrix}
    \begin{array}{c | c} I &amp;{} 0 \\ \hline 0 &amp;{} U \end{array} \end{pmatrix}\end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ41.png)(41)Lemma
    1'
  prefs: []
  type: TYPE_NORMAL
- en: A controlled-unitary gate can be decomposed into two CNOTs and single qubit
    gates.
  prefs: []
  type: TYPE_NORMAL
- en: ProofAny single-qubit unitary matrix, also called *U*(2) matrices, can be represented
    as orthogonal pairs of rotations on the Bloch sphere. First, we define three rotation
    angles along two different axes. By Lemma 4.1 in [[53](#CR53)],![$$\begin{aligned}
    U = e^{i\delta } \cdot R_z(\alpha ) \cdot R_y(\theta ) \cdot R_z(\beta ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ42.png)(42)In
    addition, the general ![$$2 \times 2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq226.png)
    unitary matrix can also be written under the form ![$$U = e^{i\delta }A \cdot
    X \cdot B \cdot X \cdot C $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq227.png),
    where ![$$A\cdot B \cdot C = I$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq228.png).
    To show this, set
  prefs: []
  type: TYPE_NORMAL
- en: '![$$A = R_z(\alpha ) \cdot R_y(\frac{\theta }{2})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq229.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![$$B = R_y(-\frac{\theta }{2})\cdot R_z(-\frac{\alpha + \beta }{2})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq230.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![$$C = R_z(\frac{\beta - \alpha }{2})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq231.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now to turn this into a controlled-unitary operation, we place *A*, *B*, *C*
    intercalated with the targets of two CNOT gates. If the control input is ![$$|0\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq232.png), then
    we have ![$$A\cdot B \cdot C = I$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq233.png)
    on the target, which has no effect on the input. If the control input is 1, then
    we get ![$$A \cdot X \cdot B \cdot X \cdot C $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq234.png)
    on the target. This behaviors amounts of that of CNOT gates. Note that we are
    still missing a controlled-global phase operation of ![$$e^{i\delta }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq235.png).
    We solve this by adding a phase gate ![$$P(\delta )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq236.png)
    anywhere on the control qubit. We now have a decomposition scheme for a CU gates
    into CNOT and single-qubit gates (Fig. [5](#Fig5)).   ![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq237.png)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig5_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 5
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition of arbitrary controlled-unitary gate
  prefs: []
  type: TYPE_NORMAL
- en: We will now shift our attention to controlled operations with more control bits.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The controlled operation CU(*n*) performs a non-trivial transformation on an
    *n*-qubit subset of a quantum circuit and uses ![$$n-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq238.png)
    control bits along with 1 target bit. For convenience, we will refer to all permutations
    of the target bit as shown in Fig. [6](#Fig6) as CU(4).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 6
  prefs: []
  type: TYPE_NORMAL
- en: These 4 gates are all referred to CU(4)
  prefs: []
  type: TYPE_NORMAL
- en: To discuss the complexity of different decomposition techniques, we represent
    an instance of a gate as a scalar which denotes its CNOT count. We then categorize
    these gates into different sets depending on their construction. Conveniently,
    we can also define these sets as sequences parameterized by *n*, the number of
    qubits that the gate acts on. We also look at other circuit resources, such as
    the use of ancilla or the introduction of non-trivial relative phases. In the
    end, we outline the most efficient construction for any given circuit size and
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the chapter, we will be focusing on the construction of CX(n),
    but note that the methods presented can be used to construct any unitary CU(*n*)
    gates.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We outline some definitions of the matrix representations of the CX(*n*) and
    its relative-phase cousin, the RCX(*n*). We also define some identities which
    help us to manipulate these gates.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 1The permutation of the CX(*n*) gate whose target is the lowest bit
    has the unitary matrix representation.![$$\begin{aligned} \text {CX}(n) = \text
    {diag} \bigg \{ 1, 1, 1, ..., \begin{pmatrix} 0&amp;{}1 \\ 1&amp;{}0\end{pmatrix}
    \bigg \} \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ43.png)(43)When
    acting on an *n*-bit system, the action of ![$$\text {CX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq239.png)
    is given by![$$\begin{aligned} \text {CX}(n) \left| {x_1, x_2, ..., x_n} \right\rangle
    = \left| {x_1, x_2, ... x_{n-1}} \right\rangle X^{\prod ^{n-1}_{i = 1} x_i} \left|
    {x_n} \right\rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ44.png)(44)Definition
    2Given a unitary matrix *U*, its relative phase version is a unitary matrix *V*
    such that ![$$|u_{i,j}|=|v_{i,j}|$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq240.png)
    for all *i*, *j*, which implies that the magnitude of all elements of *U* and
    *V* is equal. Using this definition we can define the RCX(*n*) gate, the relative
    phase version of the ![$$\text {CX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq241.png)
    gate, as![$$\begin{aligned} \text {RCX}(n) = \text {diag} \bigg \{ z_0, z_1, ...,
    z_{2^{n}-3}, \begin{pmatrix} 0&amp;{}z_{2^{n}-2} \\ z_{2^{n}-1}&amp;{}0\end{pmatrix}
    \bigg \} \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ45.png)(45)where
    ![$$z_j = e^{i\theta _j}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq242.png).
    By [[54](#CR54)], we can express the RCX(*n*) as the matrix product of ![$$\text
    {CX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq243.png)
    and a diagonal phased matrix *D*(*n*).![$$\begin{aligned} \text {RCX}(n) = D(n)
    \cdot \text {CX}(n) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ46.png)(46)where
    ![$$D(n) = \text {diag} \bigg \{ z_0, z_1, ..., z_{2^n - 1} \bigg \}, \text {
    with } z_j = e^{i\theta _j}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq244.png).Definition
    3The inverse of a ![$$\text {RCX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq245.png)
    gate is also a ![$$\text {RCX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq246.png)
    gate. This identity is very powerful because it allows us to reverse the presence
    of any relative phase when using ![$$\text {RCX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq247.png)
    in our constructions. We are also using, without proof, the identity ![$$\text
    {CX}(n) = \text {CX}^{-1}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq248.png).![$$\begin{aligned}
    \text {RCX}^{-1}(n)&amp;= \big [ D(n) \cdot \text {CX}(n) \big ] ^{-1} \nonumber
    \\&amp;= \text {CX}^{-1}(n) \cdot D(n)^{-1} \nonumber \\&amp;= \text {CX}(n) \cdot
    D^{-1}(n) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ47.png)(47)where
    ![$$D^{-1}(n) = \text {diag} \bigg \{ \overline{z}_0, \overline{z}_1, ..., \overline{z}_{2^n
    - 1} \bigg \}, \text { with } \overline{z}_j = e^{-i\theta _j}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq249.png).Definition
    4An arbitrary ![$$m+n+p$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq250.png)
    qubit oracle ![$$U_f$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq251.png)
    nested between RCX(*n*) and its inverse RCX![$$^{-1}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq252.png)
    satisfies the identity![$$\begin{aligned}{}[I^m \otimes \text {RCX}(n) \otimes
    I^p] \cdot U_f \cdot [I^m \otimes \text {RCX}^{-1}(n) \otimes I^p] = [I^m \otimes
    \text {CX}(n) \otimes I^p] \cdot U_f \cdot [I^m \otimes \text {CX}(n) \otimes
    I^p] \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ48.png)(48)![](../images/516210_1_En_1_Chapter/516210_1_En_1_Equ85_HTML.png)![$$\begin{aligned}{}[I^m
    \otimes D(n) \otimes I^p] \cdot U_f \cdot [I^m \otimes D^{-1}(n) \otimes I^p]
    = U_f \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ49.png)(49)We
    define the oracle ![$$U_f$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq253.png)
    such that it transforms the *p*-qubits based on the values of the *n*-qubits above
    it.ProofVisually, we have the following circuit. Expand RCX(*n*) and RCX![$$^{-1}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq254.png)
    into its phased and non-phased components, and cancel the two exterior CX(*n*)
    gates from both sides, we get (see Figs. [7](#Fig7), [8](#Fig8) and [9](#Fig9)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 7
  prefs: []
  type: TYPE_NORMAL
- en: Identity in Eq. [4](#Equ4)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig8_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 8
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Definition 3
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig9_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 9
  prefs: []
  type: TYPE_NORMAL
- en: Since ![$$U_f$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq255.png)
    does not affect the top ![$$m+n$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq256.png)
    qubits, the two diagonal matrices commute with it and cancels with each other
  prefs: []
  type: TYPE_NORMAL
- en: '![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq257.png)'
  prefs: []
  type: TYPE_IMG
- en: 2.4 Sleator-Weinfurter Construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest case of the ![$$\text {CX}(n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq258.png)
    gate is the Toffoli gate. We begin by showing the Sleator-Weinfurter construction
    [[55](#CR55)] (see Fig. [10](#Fig10)). Where ![$$V^2 = X$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq259.png).
    With ![$$X = e^{i\frac{\pi }{2}} R_x(\pi )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq260.png),
    we can derive that ![$$V = \sqrt{X} = e^{i\frac{\pi }{4}} R_x(\frac{\pi }{2})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq261.png).
    Using the identities from Eq. [35](#Equ35), we get![$$\begin{aligned} e^{i\frac{\pi
    }{4}} R_x\bigg (\frac{\pi }{2}\bigg )&amp;= e^{i\frac{\pi }{4}} H \cdot R_z\bigg
    (\frac{\pi }{2}\bigg ) \cdot H \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ50.png)(50)![$$\begin{aligned}&amp;=
    H \cdot S \cdot H \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ51.png)(51)![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10
  prefs: []
  type: TYPE_NORMAL
- en: Sleator-Weinfurter construction
  prefs: []
  type: TYPE_NORMAL
- en: Now, we substitute *H* and *P* gates in for *V* and ![$$V^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq262.png).
    Looking strictly at the target wire, we see the all the interior *H* gates cancel
    out, leaving only two *H* on the outside. This is a common method for building
    CX(*n*) gates, where we first build the CZ(*n*) gate, then surround *H* gates
    on both sides of the target bit to form CX(*n*). To analyze the action of this
    circuit, we look at the operations applied on the target bit based on the inputs
    ![$$x_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq263.png)
    and ![$$x_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq264.png)
    (see Fig. [11](#Fig11)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 11
  prefs: []
  type: TYPE_NORMAL
- en: Sleator-Weinfurter construction with controlled-phase gates
  prefs: []
  type: TYPE_NORMAL
- en: '![$$\begin{aligned} HSH \text { iff } x_1 = 1 \quad&amp;(10) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ52.png)(52)![$$\begin{aligned}
    HS^\dagger H \text { iff } x_1 \oplus x_2 = 1 \quad&amp;(11) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ53.png)(53)![$$\begin{aligned}
    HSH \text { iff } x_2 = 1 \quad&amp;(01) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ54.png)(54)Overall,
    the gate applied on the target bit is ![$$X^k$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq265.png),
    where![$$\begin{aligned} k = x_1 + x_2 - (x_1 \oplus x_2) = 2\cdot (x_1 \wedge
    x_2) = 2 \cdot (x_1 \cdot x_2) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ55.png)(55)This
    is consistent with the definition of the CX(*n*) gate in Eq. [43](#Equ43). By
    Fig. [4](#Fig4), each controlled-phase gate, called CP, decomposes into 2 CNOT
    gates. In total, this construction uses ![$$3\cdot 2 + 2 = 8$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq266.png)
    CNOT gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Optimal CNOT Toffoli Circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimal construction of the Toffoli gate uses 6 CNOT gates. To derive this
    construction, we first outline some useful lemmata.
  prefs: []
  type: TYPE_NORMAL
- en: Lemma 2
  prefs: []
  type: TYPE_NORMAL
- en: Phase gates, such as ![$$R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq267.png),
    commute with the control of the CNOT.
  prefs: []
  type: TYPE_NORMAL
- en: Proof
  prefs: []
  type: TYPE_NORMAL
- en: Observe that neither the phase gates nor the control of the CNOT affects the
    bit-value of the input. This also works for *P* gates since they are equivalent
    to ![$$R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq268.png)
    up to a global phase.    ![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq269.png)
  prefs: []
  type: TYPE_NORMAL
- en: Lemma 3
  prefs: []
  type: TYPE_NORMAL
- en: X-axis rotations gates, such as ![$$R_x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq270.png),
    commute with the target of the CNOT.
  prefs: []
  type: TYPE_NORMAL
- en: ProofDepending on the value of the input on the control bit, there are two possible
    actions for the the target bit, *I* or *X*. The first case is obvious,![$$\begin{aligned}
    I R_x(\theta ) = R_x(\theta ) I = R_x\end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ56.png)(56)The
    second case relies on the fact that ![$$R_x(\pi )= iX$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq271.png).![$$\begin{aligned}
    X R_x(\theta )&amp;= -i R_x(\pi ) R_x(\theta ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ57.png)(57)![$$\begin{aligned}&amp;=R_x(\theta
    ) \big ( -iR_x(\pi ) \big ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ58.png)(58)![$$\begin{aligned}&amp;=R_x(\theta
    ) X \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ59.png)(59)And
    thus, we showed that both *I* and *X* are ![$$R_x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq272.png)
    rotations.    ![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq273.png)Lemma
    4
  prefs: []
  type: TYPE_NORMAL
- en: Phase gates commute with Ising coupling gate ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq274.png).
  prefs: []
  type: TYPE_NORMAL
- en: ProofIsing coupling gates ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq275.png)
    have the parametrization![$$\begin{aligned} R_{zz}(\theta )= \exp \big ( -i\frac{\theta
    }{2} Z\otimes Z\big ) = \begin{pmatrix} R_z(\theta ) &amp;{} 0 \\ 0 &amp;{} R_z(-\theta
    ) \end{pmatrix} \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ60.png)(60)Observe
    that it is a diagonal matrix. We have two choices for placing our phase gate,
    ![$$I \otimes R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq276.png)
    and ![$$R_z \otimes I$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq277.png).
    As an exercise, show that both of these are diagonal matrices. Since diagonal
    matrices commute, we have that ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq278.png)
    and ![$$I \otimes R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq279.png)
    (likewise ![$$R_z \otimes I$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq280.png))
    commute.    ![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq281.png)We
    re-express Lemma [4](#FPar12) in terms of quantum circuits. First, we show the
    decomposition of the Ising ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq282.png)
    gate as into CNOTs and ![$$R_z$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq283.png)
    gates. Note that this decomposition emphasizes the symmetric nature of the ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq284.png)
    gate. If our phase gates were on the top qubit, it simply commutes through to
    the other side by Lemma [2](#FPar8). We now rephrase Lemma [4](#FPar12) as a circuit
    identities (see Fig. [12](#Fig12)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12
  prefs: []
  type: TYPE_NORMAL
- en: Ising ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq285.png)
    as quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: Lemma 5
  prefs: []
  type: TYPE_NORMAL
- en: (Lemma [4](#FPar12) as circuit identities) Phase gates commute with two CNOTs
    with another phase gates between them (see Fig. [13](#Fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig13_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 13
  prefs: []
  type: TYPE_NORMAL
- en: Ising ![$$R_{zz}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq286.png)
    as quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: Lemma 6
  prefs: []
  type: TYPE_NORMAL
- en: These two circuit equivalences are true (see Figs. [14](#Fig14) and [15](#Fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig14_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 14
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying CNOT cascade
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig15_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 15
  prefs: []
  type: TYPE_NORMAL
- en: CNOT mirror identity
  prefs: []
  type: TYPE_NORMAL
- en: Proof
  prefs: []
  type: TYPE_NORMAL
- en: By verifying all eight bases input/output pairs for each equivalence.    ![$$\square
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq287.png)
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 7
  prefs: []
  type: TYPE_NORMAL
- en: The optimal construction of the Toffoli gate uses 6 CNOT gates
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will only prove that such construction is possible. To prove its optimality
    in terms of CNOT gates, see [[56](#CR56)].
  prefs: []
  type: TYPE_NORMAL
- en: Proof
  prefs: []
  type: TYPE_NORMAL
- en: We begin by expanding all the controlled-phase gates of Fig. [11](#Fig11) into
    CNOT and phase gates using Lemma [1](#FPar1). Then, we use Lemma [2](#FPar8),
    [3](#FPar10), [4](#FPar12) (more specifically the decomposition in Fig. [12](#Fig12)),
    to shuffle the gates around and Lemma [6](#FPar15) to cancel redundant CNOT gates.
    As an exercise, we leave the details to the reader. In the end, we have the optimal
    construction shown in Fig. [16](#Fig16).    ![$$\square $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq288.png)
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Recursive Relative Phase Toffoli
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We take a detour from the normal CX(*n*) construction and discuss RCX(*n*) construction.
    Recall that this is equivalent to CX(*n*) except for the possibility of relative
    phase whenever its matrix elements are non-zero ([45](#Equ45)). We will look at
    a recursive construction proposed by Minh Pham and Emilio Peláez.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.1 Construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We outline a recursive scheme to construct RCX(*n*) gates. We start with three
    base cases: CNOT, RCX(3), and RCX(4).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that ![$$\cong $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq289.png)
    means that the circuit on the right is a relative phase version of the circuit
    on the left. In the final decomposition and gate counting, we consider the circuit
    on the right (see Fig. [17](#Fig17)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig16_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 16
  prefs: []
  type: TYPE_NORMAL
- en: Optimal construction of the Toffoli gate
  prefs: []
  type: TYPE_NORMAL
- en: Notice how RCX(4) (Fig. [18](#Fig18)) has 3 CNOT pairs. One has a control bit
    on qubit *a*, the other on qubit *b*, and yet another on qubit *c*. We can build
    RCX(5) by first extending the CNOT of qubit *a* to a CX(3). Then, we can replace
    the normal CX(3) with the RCX(3) base case shown in Fig. [17](#Fig17). Similarly
    for RCX(6), and RCX(7), we can extend the CNOT pairs into CX(3), and replace these
    with RCX(3). For RCX(8), RCX(9), and RCX(10), we repeat the same process as above,
    however this time extend the CNOT pairs into CX(4), and replace these with RCX(4).
    In general, for an arbitrary RCX(*n*) where ![$$n&gt;4$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq290.png),
    the construction looks as follows (Figs. [19](#Fig19) and [20](#Fig20)).
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with the structure of RCX(4)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the *a* qubit CNOT pairs to form CX(![$${\lceil \frac{n-1}{3} \rceil
    }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq291.png)),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the *b* qubit CNOT pairs to CX(![$${\lfloor \frac{n-1}{3} \rfloor }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq292.png))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the *c* qubit CNOT pairs to CX(![$${n-1- \lceil \frac{n-1}{3} \rceil
    - \lfloor \frac{n-1}{3} \rfloor }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq293.png)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, decompose each of the last three gates using the same process as outlined
    by step 1–3\. We repeat steps 1–5 until all the gates decompose to the gates in
    the base cases. At the end, we replace these gates with their corresponding relative-phased
    gates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig17_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 17
  prefs: []
  type: TYPE_NORMAL
- en: RCX(3) uses 3 CNOT gates and 4 phase gates
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig18_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 18
  prefs: []
  type: TYPE_NORMAL
- en: RCX(4) uses 6 CNOT gates and 8 phase gates
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig19_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 19
  prefs: []
  type: TYPE_NORMAL
- en: RCX(5) from RCX(4)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig20_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 20
  prefs: []
  type: TYPE_NORMAL
- en: Replacing normal CX(3) with RCX(3)
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.2 CNOT Count and Applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we go from RCX![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq294.png)
    to RCX(*n*), we replace two RCX![$$(\lceil \frac{n-1}{3}\rceil -1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq295.png)
    with two RCX![$$(\lceil \frac{n-1}{3} \rceil )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq296.png)
    gates. The cost of any RCX(*n*) then, where ![$$n \ge 5 $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq297.png),
    is given by the relation![$$\begin{aligned} \text {RCX}(n) = \text {RCX}(n-1)
    + 2\cdot \text {RCX}\bigg (\lceil \frac{n-1}{3}\rceil \bigg ) - 2\cdot \text {RCX}\big
    (\lceil \frac{n-1}{3}\rceil -1 \big ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ61.png)(61)Asymptotically,
    this relation grows by ![$$\Theta (n^{\log _6{3}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq298.png)
    CNOTs.The applications for RCX gates are given by Eq. [4](#Equ4), whenever RCX
    and RCX![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq299.png)
    are used concurrently. For example, we will encounter the following configuration
    when we discuss the quadratic construction by Barenco et al. [[53](#CR53)] (Fig.
    [27](#Fig27)). The replacement of the CX gates by the RCX gates here will significantly
    decrease the number of CNOT used (see Fig. [21](#Fig21)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig21_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 21
  prefs: []
  type: TYPE_NORMAL
- en: Application of RCX(*n*) gates
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 V-Chain Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can construct CX(*n*) gates using a linear number of CNOTs if we allow for
    the possibility of ancilla bits. Whenever necessary, we denote the number of ancillae
    used/allowed with a superscript next to the gate. We will discuss the V-Chain
    decomposition by Maslov [[54](#CR54)], which is an improvement upon Lemma 7.2
    of Barenco et al. [[53](#CR53)]. We can improve this technique further by introducing
    the RCX gates discussed in the previous section. This technique builds the CX(*n*)
    gates using ![$${\lceil {\frac{n-6}{2}}\rceil }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq300.png)
    borrowed bits. These bits required that the ancilla qubits are returned to the
    original state after computation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From now, we refer to the set of qubits that our gate acts on in square brackets,
    with the last element being the target bit. The top-most qubit is indexed 1, and
    the rest are in ascending order going down the circuit. For ![$$n \ge 8$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq301.png),
    the construction is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with a circuit of size ![$$m = n + \lceil \frac{n-6}{2}\rceil $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq302.png).
    The top ![$$n-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq303.png)
    bits are controls. The next ![$$\lceil \frac{n-6}{2}\rceil $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq304.png)
    bits are ancillary. The bottom bit is the target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first gate is CX(![$$3) [n-1, m-1, m]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq305.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *n* is odd, place CX(![$$3)[n-2, m-2, m-1]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq306.png).
    Else, skip this step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When ![$$n &gt; 8$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq307.png),
    for each *k* in ![$$\lfloor \frac{n-8}{2} \rfloor , ..., 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq308.png),
    place CX(![$$4) [2k+5, 2k+6, n+k-1, n+k] $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq309.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is CX(7) [1, 2, 3, 4, 5, 6, *n*].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When ![$$n &gt; 8$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq310.png),
    for each *k* in ![$$1,..., \lfloor \frac{n-8}{2} \rfloor $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq311.png),
    place CX(![$$4) [2k+5, 2k+6, n+k-1, n+k]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq312.png)
    (reverse ordering of step 4).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *n* is odd, place CX(![$$3)[n-2, m-2, m-1]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq313.png).
    Else, skip this step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next gate is CX(![$$3) [n-1, m-1, m]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq314.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement step 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement step 4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '11.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is CX(7) [1, 2, 3, 4, 5, 6, *n*].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '12.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement step 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '13.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement step 7.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will explain the motivation behind this construction with an example for
    ![$$n = 11$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq315.png)
    shown by Fig. [22](#Fig22). In this example, there are 10 control bits, labeled
    *A* to *J*, and 3 ancilla bits, labeled ![$$a_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq316.png)
    to ![$$a_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq317.png).
    The left mountain (steps 2–8) accumulates the product of the control bits into
    the target. This is done iteratively by storing part of the product in the ancilla
    bits. First, ![$$a_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq318.png)
    stores ![$$a_1 \oplus ABCDEF$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq319.png).
    Then ![$$a_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq320.png)
    stores ![$$a_2 \oplus ABCDEFGH$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq321.png).
    After that ![$$a_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq322.png)
    stores ![$$a_3 \oplus ABCDEFGHI$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq323.png).
    Finally, the target *t* becomes ![$$t \oplus ABCDEFGHIJ$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq324.png).
    However, recall that we must return the ancilla to its original state. The right
    mountain (steps 9–13) achieves this by adding (modulo 2) the same product as the
    first mountain to each ancilla bit. Since ![$$(x \oplus y) \oplus y = x$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq325.png),
    we successfully restore the original values of the ancilla bits. The key in the
    efficient construction of the V-chain is replacing all CX gates with RCX gates.
    We introduce four gates that are less expensive to implement in the context of
    this construction, three of which come from Maslov [[54](#CR54)].![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig22_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22
  prefs: []
  type: TYPE_NORMAL
- en: V-chain construction of CX(11)
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$${\textbf {SRTS}}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq326.png).
    This is partial Toffoli in Fig. [16](#Fig16). When used with its inverse SRTS![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq327.png),
    we can cancel out 2 CNOTs. In total, it contains 4 CNOT gates. We substitute the
    SRTS in step 2 and SRTS![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq328.png)
    in step 8.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$${\textbf {RTS}}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq329.png).
    When RCX(3) is used with RCX![$${}^{-1}(3)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq330.png),
    we can cancel out a whole CNOT gate. The result is RTS. The circuit contains 2
    CNOT gates. We substitute RTS in step 3 and RTS![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq331.png)
    in step 7.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$${\textbf {RT4S}}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq332.png).
    This is the remainder of the RCX(4) circuit after cancellation with its inverse.
    The implementation uses 4 CNOTs. We substitute RT4S in step 4 and RT4S![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq333.png)
    in step 6.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![$${\textbf {RT7L}}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq334.png).
    This circuit is equivalent to RCX(7). However, we will call it RT7L to be consistent
    with the original literature. RT7L is composed of 18 CNOTs. We substitute RT7L
    in step 5 and RT7L![$${}^{-1}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq335.png)
    in step 11 (see Figs. [23](#Fig23), [24](#Fig24), [25](#Fig25), [26](#Fig26) and
    [27](#Fig27)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig23_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 23
  prefs: []
  type: TYPE_NORMAL
- en: 'SRTS circuit: 4 CNOTs'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig24_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 24
  prefs: []
  type: TYPE_NORMAL
- en: 'RTS circuit: 2 CNOTs'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig25_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 25
  prefs: []
  type: TYPE_NORMAL
- en: 'RT4S circuit: 4 CNOTs'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig26_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 26
  prefs: []
  type: TYPE_NORMAL
- en: 'RT7L circuit: 18 CNOTs'
  prefs: []
  type: TYPE_NORMAL
- en: To create the inverse of any of the gates above, we flip the order of the gate
    operation and inverse their phase. Substituting the above gates into the circuit
    leads to the construction of CX(*n*) with ![$$\lceil \frac{n-6}{2} \rceil $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq336.png)
    ancillae, an improvement from the ![$$\lceil \frac{n-3}{2} \rceil $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq337.png)
    used in the original paper [[54](#CR54)].![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig27_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 27
  prefs: []
  type: TYPE_NORMAL
- en: Substitution example of CX(11)
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2 CNOT Count
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We start with ![$$n = 8$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq338.png),
    which requires 2 RT7L and 2 SRTS gates, for a total of 44 CNOTs. For larger values
    of *n*, we either add 4 RTS gates to build ![$$n+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq339.png)
    or 4 RT4S gates to build ![$$n+2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq340.png).
    Both increases the CNOT count by 8 per qubit. Thus, our construction of CX(*n*)
    uses ![$$8n-20$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq341.png)
    CNOT gates.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Quadratic Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This decomposition scheme comes from Barenco et al. [[53](#CR53)]. In a way,
    it is an extension of the structure in Fig. [11](#Fig11), where the CX(1) and
    CS(1) gates turn into CX![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq342.png)
    and CS![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq343.png)
    gates.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.1 Construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we will describe the construction of the CX(*n*) gates. For an arbitrary
    CX(*n*) gate, we can decompose it into 2 CX![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq344.png),
    CS , CS![$${}^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq345.png)
    and CS![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq346.png).
    Note that we do not count the two Hadamards because they are single-qubit gates,
    which many metric considers trivial.![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig28_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 28
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: CX(5)'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can further decompose CS![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq347.png)
    into 2 CX![$$(n-2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq348.png),
    CT , CT![$${}^\dagger $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq349.png)
    and CT![$$(n-2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq350.png)
    (see Figs. [28](#Fig28) and [29](#Fig29)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig29_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 29
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: CS(4)'
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the number in brackets refers to the angle of the controlled-phase
    gates whenever it has the parameters ![$$\theta $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq351.png)
    inside. If not, the value inside will refer to the number of qubits the gate in
    question acts on. In general, for an arbitrary CP![$${}_\theta (n)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq352.png)
    gate, we can decompose it into 2 CX![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq353.png),
    CP![$$({\frac{\theta }{2}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq354.png)
    , CP![$${}^\dagger ({\frac{\theta }{2}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq355.png)
    and CP![$${}_{\frac{\theta }{2}}(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq356.png).
    We repeat this process for CP![$${}_{\frac{\theta }{2}}(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq357.png)
    until we hit the base case CP![$$({\frac{\theta }{2^{n-2}}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq358.png).
    We show an example of this decomposition below for CX(5) (see Fig. [30](#Fig30)).![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig30_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 30
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: full decomposition of CX(5)'
  prefs: []
  type: TYPE_NORMAL
- en: where the angle ![$$\theta $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq359.png)
    enclosed in the square box denotes the phase gate ![$$P(\theta )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq360.png).
  prefs: []
  type: TYPE_NORMAL
- en: What’s left to do is to decompose all the CP and CX(*m*) gates inside our circuit.
    We outlined CP decomposition in Lemma [1](#FPar1) As for CX(*m*) gates, there
    are a few methods for doing this. The simplest way is to replace all the CX(*m*)
    gates with the RCX (*m*) gates described in Sect. [2.5](#Sec28). This substitution
    is optimal for ![$$n \le 21$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq361.png).
    Past this point, we can use the technique of Maslov [[54](#CR54)] if we have enough
    ancilla bits. More specifically, for an arbitrary CX(*n*), we can implement RCX(*m*)
    as described in Sect. [2.7](#Sec32) whenever ![$$m + \lceil \frac{m-6}{2} \rceil
    \le n$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq362.png).
    If this is not the case, we can use the construction of [[57](#CR57)]. This method
    also builds RCX with the CNOT count growing linearly with the number of qubits.
    The technicality of this construction is outside the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.2 CNOT Count
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the construction is recursive, we can define a simple recursion relation
    for the CNOT count.![$$\begin{aligned} \text {CX}(n) = 2 \text {CX}(n-1) + \text
    {CP}(n-1) + 2\text {CP}(2) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ62.png)(62)This
    equation follows from observation of Fig. [28](#Fig28). The asymptotic behavior
    of this expression depends on our choice of CX![$$(n-1)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq363.png).
    If we use a linear construction then we have![$$\begin{aligned} \text {CX}(n)
    = \text {CP}(n-1) + \Theta (n) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ63.png)(63)which
    implies that CX![$$(n) \in \Theta (n^2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq364.png).
    On the other hand, if we use the ![$$\Theta (n^{\log _3{6}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq365.png)
    construction of Eq. [61](#Equ61), then our complexity is super-quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We summarized in the table below the various constructions that we have presented.
    For each technique, we give details on whether the construction results in relative-phased
    matrices, and whether ancilla bits are required. We also describe the growth of
    the number of CNOT gates each construction uses as the number of qubits increases
    (see Table [2](#Tab2)).Table 2
  prefs: []
  type: TYPE_NORMAL
- en: Summary of the constructions presented
  prefs: []
  type: TYPE_NORMAL
- en: '| Construction | Relative phase | # ancillae | # CNOT |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Recursive relative phase | Yes | N / A | ![$$\Theta (n^{log_3{6}})$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq366.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| V-chain | No | ![$$\lceil \frac{n-6}{2} \rceil $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq367.png)
    | ![$$8n-20$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq368.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Quadratic | No | N / A | ![$$\ge \Theta (n^2)$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq369.png)
    |'
  prefs: []
  type: TYPE_TB
- en: 3 Quantum Error Correction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantum error correction (QEC) is an essential and very active part of quantum
    computing. It is used to mitigate the error present in quantum information due
    to noise and decoherence. QEC plays an important part in the development of quantum
    information science since, once we are in the appropriate technology era, it will
    help us develop quantum software resistant to noise, decoherence and faulty operations,
    such as gates, state preparation, and measurement. This means that even if quantum
    hardware is sensible to noise, there will be a point in the future where we can
    add error detecting and correcting codes in specific parts of our circuits to
    get reliable results despite the faulty nature of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any quantum computation model based on the circuit representation (e.g., superconducting
    qubits and trapped ions) will require error correction [[58](#CR58)]. This is
    due to the nature of qubits: they are difficult to isolate from the environment
    and therefore external noise can easily disturb their quantum state. We will discuss
    some of the factors that can introduce noise in Sect. [3.1](#Sec40). If this disturbance
    goes uncorrected, it will lead to erroneous calculations and therefore wrong outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: From our previous knowledge of classical computation, it may be our first instinct
    to assume that the classical error correcting theory can be easily adapted to
    quantum computation. However, this is not possible since qubits can experience
    more types of errors than a simple bit flip (we will explore this in Sect. [3.2](#Sec41)).
    Therefore, we can’t just use the techniques from classical computing briefly described
    in Sect. [3.3](#Sec42), but we need to come up with new techniques that work within
    the realm of quantum computation. This is the topic of Sect. [3.4](#Sec43), onwards.
    Finally, we put everything together and talk about more useful (and complicated)
    error correcting codes in Sect. [3.8](#Sec47).
  prefs: []
  type: TYPE_NORMAL
- en: For recent developments in the field, look at [[59](#CR59)]. In this paper the
    authors use a ten qubit ion trap quantum computer to encode a single logical qubit
    using a [[7, 1, 3]] code (this bracket notation is explained later in this section).
    They are also able to prepare a logical ![$$T|+\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq370.png)
    magic state with a sufficiently low error rate for magic state distillation [[60](#CR60)]
    and implementing non-Clifford gates. These achievements are essential steps towards
    fault-tolerant universal quantum computation for large scale purposes well beyond
    the NISQ era [[61](#CR61)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Noise Origin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error in quantum computation can introduced by faulty operations. Some of these
    are gates, initial state preparation, and final measurement. Another very common
    source for error in quantum computations is the interactions of qubits with the
    environment. Since there is no technology that allows us to fully isolate a single
    quantum system (in this case, qubit), there is some degree of interaction of the
    qubit with the outside world. This interaction can change the state of the qubit
    in the middle of a computation and therefore mess up the rest of it.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of qubits also gives rise to something which we call phenomena we
    refer to as relaxation and dephasing. Relaxation of a qubit is related to how
    long it takes to decay from ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq371.png)
    to ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq372.png)
    due to “natural” causes, i.e., not intended by the circuit. Dephasing of a qubit
    is very similar, but for phases. It has a relation with the time it takes a qubit
    to gain some unintended phase information. In 2000, DiVincenzo introduced three
    criteria to achieve a physical implementation of quantum computation [[62](#CR62)].
    The third criterion says that decoherence times should be much longer than gate
    operation time, meaning that the qubits must go through all the gates in a circuit
    before dephasing and relaxation kick in.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring this concept could take us into a whole different discussion than
    the intended in this section. So, instead of focusing on realizing qubits with
    longer decoherence times by improving the hardware available, we will focus on
    what types of errors can these (and other factors) introduce in our computation
    and how to detect and correct them from the software side.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Error Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In classical computing, the only type of error present is the bit flip: ![$$0
    \xrightarrow {} 1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq373.png)
    and the inverse ![$$1 \xrightarrow {} 0$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq374.png).
    This is a fairly simple error to detect and correct, since the chance of it happening
    in classical hardware is slim thanks to decades of hardware development and its
    detection and correction is easy thanks to the software available today. However,
    in quantum computing, the bit flip is not as uncommon. As discussed earlier, one
    reason for this type of error is relaxation time. As of 2019 [[63](#CR63)], relaxation
    time for IBM’s computers were around 50 microseconds, meaning that bit flip errors
    happen a lot. Although relaxation time refers to going from the excited (![$$|1\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq375.png)) state
    to the ground (![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq376.png))
    state, the inverse bit flip can also happen. The ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq377.png)
    to ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq378.png)
    bit flip is definitely more uncommon, but it still can happen due to faulty gates
    or other noise; therefore, we need to consider it when developing error correcting
    codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, bit flips aren’t the only type of errors when talking about quantum
    computation. Remember that quantum states introduce something called phase, which
    is a number of the form ![$$e^{i \theta }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq379.png)
    multiplying some part of the statevector. For example, consider the state ![$$|+\rangle
    = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq380.png).
    A phase error of ![$$e^{i \pi }$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq381.png)
    can be introduced to the second factor, leaving us with ![$$\frac{1}{\sqrt{2}}(|0\rangle
    + e^{i \pi }|1\rangle ) = \frac{1}{\sqrt{2}}(|0\rangle -|1\rangle )=|-\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq382.png). Thus,
    a phase error has changed our state from ![$$|+\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq383.png)
    to ![$$|-\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq384.png),
    which can have important effects in the rest of the computation. Therefore, we
    also need to consider this type of error, which turns out to be something difficult
    since with classical computation we are accustomed to only encountering the simple
    bit flip.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the bit flip and phase errors introduced, we can combine them and think
    about them as a single type of error: the rotation error. This error can be thought
    of as making the state move from one point in the Bloch sphere to another. Describing
    errors like this makes one difficulty we didn’t discuss earlier obvious. There
    are an infinite amount of errors a qubit is subject to, just as there are an infinite
    amount of points in the surface of the Bloch sphere. Fortunately, thanks to Knill
    and Laflamme [[64](#CR64)], we know that correcting for a finite set of errors
    is a sufficient condition to allows us to correct any error of the infinite set.
    Getting back in track, to describe the rotation error more mathematically, first
    consider the general state of a qubit:![$$\begin{aligned} |\psi \rangle = \cos
    \frac{\theta }{2}|0\rangle + e^{i \phi } \sin \frac{\theta }{2}|1\rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ64.png)(64)Now
    consider the operator *E* which represents the rotation error. As discussed, this
    error is a combination of both the bit flip and phase error. Something important
    to note here is that, although we just talked about the ![$$|0\rangle \xrightarrow
    []{} |1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq385.png)
    and ![$$|1\rangle \xrightarrow []{} |0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq386.png)
    transitions, the bit flip can be generalized to any change of the parameter ![$$\theta
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq387.png) in Eq.
    ([64](#Equ64)). In other words, the bit error (we’re now ommiting “flip” since
    it isn’t a complete flip always) changes the amount of ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq388.png)
    and ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq389.png)
    in the state. And the phase error can be characterized similarly as a change of
    ![$$\phi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq390.png)
    in the same equation. Considering this, *E* depends on the parameters ![$$\delta
    \theta $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq391.png)
    and ![$$\delta \phi $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq392.png)
    and its effect is described as![$$\begin{aligned} E(\delta \theta , \delta \phi
    ): \cos \frac{\theta }{2}|0\rangle + e^{i \phi } \sin \frac{\theta }{2}|1\rangle
    \xrightarrow {} \cos \frac{\theta + \delta \theta }{2}|0\rangle + e^{i (\phi +
    \delta \phi )} \sin \frac{\theta + \delta \theta }{2}|1\rangle . \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ65.png)(65)At
    first glance, it is not quite obvious how to correct for an error like this. We
    will not dive into that just yet, but we will make a simplification of Eq. ([65](#Equ65))
    that will help us out later on. Since we know *E* is a combination of a phase
    and flip error, it makes sense to write it as some linear combination of the *X*
    and *Z* gates because the former performs a bit flip and the latter adds a ![$$-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq393.png)
    phase to ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq394.png).
    We also need to consider the case in which no error is introduced, i.e., the identity
    gate, and the case of *XZ* for completeness sake (reaching every point with every
    possible in the Bloch sphere). Therefore, we can write *E* as![$$\begin{aligned}
    E = \alpha _1I + \alpha _2 X + \alpha _3 Z + \alpha _4 XZ . \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ66.png)(66)Going
    back some paragraphs to the point that correcting a finite set of errors is sufficient
    to correct any possible error, we can use Eq. ([66](#Equ66)) to see that this
    set is spanned by the Pauli set ![$$\{I, X, Z, XZ\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq395.png).
    As you can see, we’re ended up with what we started with: we have an error described
    by *X* and one by *Z*, and correcting these and any linear combination of them
    will allow us to correct for any error. So, why bother going through all the math?
    Well, having a mathematical description of the errors like in Eq. ([66](#Equ66))
    we will encounter always help gain a better understanding of what we are dealing
    with, and will be useful later on when we derive the error correcting codes.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Classical Error Correction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have described the general error we will encounter in quantum computation,
    now we want to see how to correct it. First, let’s take a step back to the techniques
    used in classical computing and try to bring them to quantum computing. We will
    see that these techniques are not efficient or applicable in the quantum case
    and, even worse, don’t take into account the whole spectrum of errors. Let’s start
    with the latter. It’s easy to see why classical error correcting codes don’t take
    into account the errors described by *E*: the notion of phase simply doesn’t exist
    in classical computation. So, without going too deep, we already know classical
    codes won’t work. However, there are other interesting characteristics that make
    classical codes not applicable to the quantum case.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to briefly describe how classical error correcting codes work.
    There are codes much more sophisticated that the one we’re going to describe,
    but all of them encounter the same difficulty, so a simple example will get the
    point across. This example is the repetition code. This relies on using repetition
    to encode information. In other words, it uses more than one bit to represent
    one single bit of information. The specific example we are going to explore uses
    3 bits to encode one bit of information through something called the three-bit
    encoding. Which simply consists of repeating the same bit 3 times. More mathematically,
    this encoding maps the set of raw bits ![$$\{0, 1\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq396.png)
    to a set of logical codewords ![$$\mathcal {C} = \{000, 111\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq397.png).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the first step of the repetition code is to encode the raw binary information
    into logical codewords. This also implies that a bitstring of *n* bits will take
    3*n* bits using this error correcting code. We will not worry about this here
    since we are considering classical computation, in which the amount of transistors
    in a device is sufficient to use this costly representation. Another implication
    from this first step is that we are able to copy bits of information as we please.
    As you may already imagine, this is a big restriction when going into quantum
    computing; we will discuss this further later on.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have encoded our information, we can go ahead and do whatever we need
    to do with it. Send it to someone at the other side of the world, run a very complex
    algorithm with our data as input, etcetera. The important thing is that, at one
    point, we will need to decode the data. Doing this is quite simple, we go through
    each 3 bit-long bitstring and perform the inverse mapping as the encoding. However,
    there can be some error in the process between encoding and decoding, and some
    of the bitstrings may have had some bit flips. What are the possible bitstrings
    resulting from an error? Well, simply anything that is not in ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq398.png),
    which is the set ![$$\mathcal {E} = \{001, 010, 011, 100, 101, 110\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq399.png).
    If we read that a bitstring is in ![$$\mathcal {E}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq400.png),
    we will know there has been an error. Since we also know these errors are very
    rare, we will assume the best case that only one bit flip occurred. Which leads
    us to decoding the bitstrings in ![$$\mathcal {E}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq401.png)
    to ![$$\{ 0, 1\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq402.png)
    depending on which one is present the most (two times) in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct decoding we just described depends on an assumption about the low
    frequency of bit flip errors. This doesn’t guarantee that this will always work.
    Specifically, there are two cases (which you probably already figured out) in
    which bit flip errors will lead us to decoding the wrong raw bit: (1) two bit
    flips that lead us to assuming the wrong original raw bit and (2) three bit flips
    that make the error go unnoticed. Case (1) is very rare, but it can happen and
    will lead us to a wrong interpretation of our data. Case (2) is even worse, although
    also much more rare, as it will not only lead us to a wrong decoding, but also
    leaves no evidence of the error as it is a mapping from ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq403.png)
    to itself.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the repetition code is not perfect. There are some cases in
    which errors will slip through it. Therefore, we need a way to express the characteristics
    of the error correcting code so we can compare different codes and decide which
    one is best in each situation. To do this, let’s first define the notion of distance
    of a code. We define the distance of a code (denoted *d*) as the number of errors
    needed to map one element of ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq404.png)
    to another of the same set. In other words, the number of errors needed to make
    the evidence of any error disappear. As we talked about in the last paragraph,
    in our case ![$$d=3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq405.png).
    More mathematically and in the general case, we define the distance as![$$\begin{aligned}
    d = 2t+1, \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ67.png)(67)where
    *t* is the number of errors the scheme can correct. In our case, ![$$t=1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq406.png)
    as we can only correct the bit flip.
  prefs: []
  type: TYPE_NORMAL
- en: Using the notion of distance, we can introduce the [*n*, *k*, *d*] notation.
    The last number is the distance we just introduced, *n* is the length of the codewords
    (the elements of the set ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq407.png)),
    and *k* is the number of bits of information encoded in each codeword (the length
    of the raw bitsrings before the encoding step). Using this notation, the 3-bit
    classical repetition code we just described is a [3, 1, 3] code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 From Classical to Quantum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a good idea of how classical error correction codes work, we can turn
    our mind back to quantum computation. Let’s say we want to use the [3, 1, 3] code
    we just described to correct *X* errors in a quantum computation. One difficulty,
    briefly mentioned in last section, immediately arises: how are we going to perform
    the mapping of the raw qubits to the set of codewords? The mapping we want to
    do is as follows:![$$\begin{aligned} |\psi \rangle \xrightarrow []{encoding} |\psi
    \rangle \otimes |\psi \rangle \otimes |\psi \rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ68.png)(68)For
    the case of no superposition, the encoding can be reduced to ![$$\{|0\rangle ,
    |1\rangle \}\xrightarrow []{}\{|000\rangle , |111\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq408.png).
    Which is quite easy to perform: we can simply use two *CNOT* gates. Therefore,
    for a state ![$$|a\rangle \in \{|0\rangle , |1\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq409.png),
    the encoding would look as follows:![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig31_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 31
  prefs: []
  type: TYPE_NORMAL
- en: Three qubit encoding assuming no superposition in state ![$$|a\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq410.png)
  prefs: []
  type: TYPE_NORMAL
- en: However, a problem shows up when we want to encode an arbitrary single-qubit
    state ![$$|\psi \rangle = \alpha |0\rangle + \beta |1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq411.png).
    Due to the no-cloning theorem, we know that there is no unitary operation that
    allows us to create an identical copy of the state ![$$|\psi \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq412.png)
    [[65](#CR65)]. Sending ![$$|\psi \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq413.png)
    through the circuit in Fig. [31](#Fig31) would output the state ![$$\alpha |000\rangle
    + \beta |111\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq414.png).
    Which, although it may appear as the correct output of the mapping in Eq. ([68](#Equ68)),
    is not what we want. The correct mapping would output the state![$$\begin{aligned}
    |\psi \rangle \otimes |\psi \rangle \otimes |\psi \rangle&amp;= (\alpha |0\rangle
    + \beta |1\rangle ) \otimes (\alpha |0\rangle + \beta |1\rangle ) \otimes (\alpha
    |0\rangle + \beta |1\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ69.png)(69)![$$\begin{aligned}&amp;=
    (\alpha ^2|00\rangle + \alpha \beta |01\rangle + \beta \alpha |10\rangle + \beta
    ^2|11\rangle ) \otimes (\alpha |0\rangle + \beta |1\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ70.png)(70)![$$\begin{aligned}&amp;=
    \alpha ^3|000\rangle + \alpha ^2\beta (|010\rangle + |100\rangle + |001\rangle
    ) + \beta ^2\alpha (|110\rangle + |011\rangle + |101\rangle ) + \beta ^3|111\rangle
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ71.png)(71)Which,
    clearly, is not even close from what we got with Fig. [31](#Fig31). And we are
    guaranteed by the no-cloning theorem that there is no circuit that allows us to
    perform the correct encoding for an arbitrary state. Therefore, we can discard
    the possibility of using the repetition code we described on Sect. [3.3](#Sec42)
    for the quantum case right away.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Detecting Bit Flip Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we cannot add redundancy in the way the classical repetition code requires
    (![$$|\psi \rangle \xrightarrow []{} |\psi \psi \psi \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq415.png)),
    we can use the *CNOT* gate to add a different type of redundancy, which we have
    already seen in Eq. ([71](#Equ71)). The redundancy introduced by the *CNOT* gate
    differs in that it makes the qubits entangle with each other. More specifically
    a *CNOT* gate with ![$$|\psi \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq416.png)
    as the control and ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq417.png)
    as the target performs the following transformation:![$$\begin{aligned} |\psi
    \rangle |0\rangle = (\alpha |0\rangle + \beta |1\rangle ) |0\rangle = \alpha |00\rangle
    + \beta |10\rangle \xrightarrow []{CNOT} \alpha |00\rangle + \beta |11\rangle
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ72.png)(72)Clearly,
    this equation doesn’t equate the tensor product of ![$$|\psi \rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq418.png)
    with itself, but it is a way of adding useful redundancy nonetheless. The extension
    of this encoder follows the *CNOT* pattern in Fig. [31](#Fig31), which can be
    extended to any number *n* of redundant qubits. Now, we’re going to look at just
    one redundant qubit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with the classical error correcting code, we can define a set
    of logical codewords (referred to as the codespace) ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq419.png)
    spanned by ![$$\{|0\rangle _L=|00\rangle , |1\rangle _L=|11\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq420.png),
    where the subscript *L* stands for logical. Since we are now considering two qubits,
    the space they live in is a four-dimensional Hilbert space ![$$\mathcal {H}^4$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq421.png)
    spanned by the computational basis states ![$$\{|00\rangle , |01\rangle , |10\rangle
    , |11\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq422.png).
    This means that ![$$\mathcal {C} \subset \mathcal {H}^4$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq423.png),
    which leaves another subspace ![$$\mathcal {F}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq424.png)
    which we will call the error subspace and is spanned by ![$$\{|01\rangle , |10\rangle
    \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq425.png). Thus,
    we can see that ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq426.png)
    and ![$$\mathcal {F}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq427.png)
    are orthogonal, which allows us to distinguish between them without disrupting
    the information encoded. This is done via the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the circuit step by step. Note that the first two qubits already
    start with the logical state ![$$|\psi \rangle _L = \alpha |00\rangle + \beta
    |11\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq428.png),
    which is prepared beforehand. In the first step, there is a unitary *E* that acts
    on the two code qubits. These unitary can correspond to one of the following operations:
    ![$$X_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq429.png),
    ![$$X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq430.png),
    ![$$X_2X_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq431.png),
    or *I*. Which mean there was a bit flip on the first qubit, a bit flip on qubit
    two, on both, or no error at all, respectively. As you can see, we are only concerned
    about bit flip errors right now.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 may be a little bit harder to understand at first. But let’s see what
    is the effect of applying the operator ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq432.png)
    to ![$$|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq433.png).![$$\begin{aligned}
    Z_1Z_2(\alpha |00\rangle + \beta |11\rangle ) = Z_1(\alpha |00\rangle - \beta
    |11\rangle ) = \alpha |00\rangle + \beta |11\rangle = (+1)|\psi \rangle _L \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ73.png)(73)This
    means that ![$$|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq434.png)
    is an eigenvector of ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq435.png)
    with eigenvalue ![$$+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq436.png).
    Since the two-qubit logical state remains unchanged when this operator is applied
    to it, it is said that ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq437.png)
    stabilizes it. What happens when the same operator is applied to a state with
    a single bit flip, i.e., not in ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq438.png)?
    Let’s consider the state ![$$X_1|\psi \rangle _L = \alpha |01\rangle + \beta |10\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq439.png).![$$\begin{aligned}
    Z_1Z_2(\alpha |01\rangle + \beta |10\rangle ) = Z_1( - \alpha |01\rangle + \beta
    |10\rangle ) = -\alpha |01\rangle - \beta |10\rangle = (-1)X_1|\psi \rangle _L
    \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ74.png)(74)As
    you can see, ![$$X_1|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq440.png)
    is an eigenvector of ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq441.png)
    with eigenvalue ![$$-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq442.png).
    You can easily verify that the same is true for ![$$X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq443.png).
    But, just as in the classical code case, we face a problem when ![$$E=X_1X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq444.png).
    This operator takes the original logical state to another state still in the codespace
    ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq445.png),
    and therefore it has an eigenvalue of ![$$+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq446.png)
    with respect to ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq447.png).
    Summing up, states in ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq448.png)
    have an eigenvalue of ![$$+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq449.png)
    and states in ![$$\mathcal {F}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq450.png)
    have an eigenvalue of ![$$-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq451.png).
    How do we extract this information?
  prefs: []
  type: TYPE_NORMAL
- en: That is exactly what the second step does. The third qubit is used as ancillary
    to measure the result of applying the ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq452.png)
    stabilizer. The ancilla qubit is first set to ![$$H|0\rangle = \frac{1}{\sqrt{2}}(|0\rangle
    + |1\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq453.png),
    After that, a controlled ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq454.png)
    is applied. Since we know the state in the first two qubits is an eigenstate of
    ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq455.png)
    and therefore the only effect on those qubits will be the addition of the eigenvalue,
    the significant effect of this gate will be on the ancilla qubit through phase
    kickback. If the eigenvalue is ![$$-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq456.png),
    the ancilla will turn into ![$$\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle )$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq457.png).
    If it is ![$$+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq458.png),
    the ancilla will remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: The second Hadamard gate on the ancillary qubit takes it to ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq459.png)
    if the logical state is in ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq460.png),
    and ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq461.png)
    if the logical state is in ![$$\mathcal {F}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq462.png).
    And this is what is finally measured. This process is called syndrome extraction
    and, as you can see, tells us whether there was an error on the logical qubits
    or not. However, it cannot distinguish between ![$$X_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq463.png)
    and ![$$X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq464.png),
    and it treats ![$$X_1X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq465.png)
    as no error (the code has distance 2 in respect to bit flip errors). Therefore,
    this code just detects the erorr, but isn’t able to correct for it.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Correcting Bit Flip Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Correcting requires a bit more effort. First of all, we will add another redundant
    qubit. So, the encoder will turn out to be the circuit depicted in Fig. [31](#Fig31),
    which as we’ve already seen performs the encoding ![$$(\alpha |0\rangle + \beta
    |1\rangle )|00\rangle \xrightarrow []{} \alpha |000\rangle + \beta |111\rangle
    $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq466.png). Unlike
    the two qubit code, we are now working with an eight-dimensional Hilbert space.
    We can divide this space into four subspaces, each spanned by two basis states.
    The first one we are going to define is the codespace, which is ![$$\mathcal {C}
    = \text {span}\{|000\rangle , |111\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq467.png).
    Now, we define another 3 subspaces, which correspond to the possible errors.![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig32_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 32
  prefs: []
  type: TYPE_NORMAL
- en: Two qubit bit flip detection circuit
  prefs: []
  type: TYPE_NORMAL
- en: We will consider the error gate to be ![$$E=\{X_1, X_2, X_3\}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq468.png),
    and each possibility will give rise to one error subspace. For ![$$X_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq469.png)
    we have ![$$\mathcal {F}_1=\text {span}\{|100\rangle , |011\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq470.png),
    for ![$$X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq471.png)
    we have ![$$\mathcal {F}_2=\text {span}\{|010\rangle , |101\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq472.png),
    and for ![$$X_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq473.png)
    we have ![$$\mathcal {F}_3=\text {span}\{|001\rangle , |110\rangle \}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq474.png).
    This gives us the general equation ![$$E_i|\psi \rangle _L \in \mathcal {F}_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq475.png).
    With this in mind, we can lay out the circuit for the three-qubit error correcting
    code.![](../images/516210_1_En_1_Chapter/516210_1_En_1_Fig33_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 33
  prefs: []
  type: TYPE_NORMAL
- en: Three-qubit error detection code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the circuit in Fig. [33](#Fig33) works very similarly to the
    two-qubit version in Fig. [32](#Fig32). The first step applies the gate *E*, which
    possibly contains an error. After this, in step 2, two syndrome measurements are
    performed. To see what are the results of the syndrome measurements, let’s analyze
    how these work. As we saw in the previous section, the measurement outcome of
    the ancilla qubit is ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq476.png)
    if there was a single qubit error and ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq477.png)
    otherwise. Generalizing this idea, for a two-qubit syndrome measurement, the output
    will be ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq478.png)
    when the qubits take on different bits and ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq479.png)
    otherwise. So, considering ![$$|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq480.png)
    to be ![$$\alpha |abc\rangle + \beta |\bar{a} \bar{b} \bar{c}\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq481.png).
    The first syndrome measurement will outcome in ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq482.png)
    if ![$$a=b$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq483.png)
    and ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq484.png)
    if ![$$a \not =b$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq485.png).
    Likewise, the second syndrome measurement will give ![$$|0\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq486.png)
    if ![$$b=c$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq487.png)
    and ![$$|1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq488.png)
    if ![$$b \not = c$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq489.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using that last statement, we can figure out the syndrome measurements for
    the following error gates:![$$\begin{aligned} E = I_1I_2I_3: 00 \qquad E = I_1I_2X_3:
    01&amp;\qquad E = X_1I_2I_3: 10 \qquad E = I_1X_2I_3: 11 \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ75.png)(75)![$$\begin{aligned}
    E = X_1X_2X_3: 00 \qquad E = X_1X_2I_3: 01&amp;\qquad E = I_1X_2X_3: 10 \qquad
    E = X_1I_2X_3: 11 \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ76.png)(76)You
    can see at immediate relation between these measurements and the three error subpsaces
    ![$$\mathcal {F}_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq490.png)
    we defined earlier. States in ![$$\mathcal {F}_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq491.png)
    result in a syndrome measurement of 10, ![$$\mathcal {F}_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq492.png)
    has a measurement of 11, and ![$$\mathcal {F}_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq493.png)
    has 01\. After measurement of the ancillary qubits, we can simply apply the ![$$X_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq494.png)
    operator corresponding to the ![$$\mathcal {F}_i$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq495.png)
    subspace to correct for the detected error.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this code allows us to determine which error took place with the
    caveat of assigning the same syndrome for two different errors. This situation
    is similar to the one presented in the classical error correcting code. Take for
    example that the error is ![$$X_1X_2I_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq496.png).
    The syndrome measurement will tell us the state is in ![$$\mathcal {F}_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq497.png),
    and therefore we would apply a ![$$X_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq498.png)
    to correct for it. But this would be wrong, since the real error was two *X* gates
    in the first two qubits. However, we need to satisfy ourselves with this for the
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, two bit flips to the same logical state is way less common than
    a single bit flip, so, we will correct accurately most of the time. And the error
    detection code isn’t applied just once throughout the computation, but many times
    to detect and correct errors before they get too big and hard to detect. Therefore,
    depending on the hardware we are working on, we can apply the code enough often
    enough to make it hard for two bit flips to appear in a single logical state.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of this code being able to detect and correct bit flip errors with
    high accuracy, it is not perfect. To see this, let’s look at its code distance.
    Just as the classical three-bit repetition code, it takes three bit flips to take
    a state on ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq499.png)
    to another state in the same subspace. Basing off this, we would say that the
    code outlined above has a quantum distance of 3\. However, that would be assuming
    that only *X* errors are possible. But, as we talked about in Sect. [3.2](#Sec41),
    there are phase errors also, which are characterized by the *Z* operator. By applying
    *Z* to a single qubit in the state ![$$|\psi \rangle _L = \alpha |0\rangle _L
    + \beta |1\rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq500.png)
    and sending it through the circuit in Fig. [33](#Fig33), you can see the code
    doesn’t detect this error.
  prefs: []
  type: TYPE_NORMAL
- en: You can also notice this by observing that both ![$$\alpha |0\rangle _L + \beta
    |1\rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq501.png)
    and ![$$\alpha |0\rangle _L - \beta |1\rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq502.png)
    are in ![$$\mathcal {C}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq503.png).
    Therefore, the three-qubit code is not able to detect single qubit *Z* errors.
    This leads us to say that the code described in this section has a quantum distance
    of 1, as it only takes one error to take a state in the codespace to another in
    the same space. Thus, we still need to figure out how to correct for phase errors.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Three-Qubit Code for Phase Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going from correcting bit flips to correcting phase errors is not a very difficult
    task. We can simply take the code we designed in the previous section and make
    a few changes. We will just worry about the mathematical side of the code right
    now, not the actual circuit implementation, but rest assured it is as easy as
    the for bit flip correction. First, the encoder. We will define the codespace
    to be ![$$\mathcal {C} = \text {span}\{|0\rangle _L=|+++\rangle , |1\rangle _L
    = |---\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq504.png).
    Thus, for a single-qubit general state ![$$|\psi \rangle = \alpha |0\rangle +
    \beta |1\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq505.png),
    this encoding would give the state ![$$|\psi \rangle _L = \alpha |+++\rangle +
    \beta |---\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq506.png).
    With this in mind, we can go ahead and define the stabilizer measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Since we used ![$$Z_1Z_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq507.png)
    and ![$$Z_2Z_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq508.png)
    for bit flip errors, it is intuitive to think we have to use ![$$X_1X_2$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq509.png)
    and ![$$X_2X_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq510.png)
    for phase errors. To see that these two operators stabilize the logical state
    ![$$|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq511.png),
    you can first expand ![$$|+++\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq512.png)
    as follows:![$$\begin{aligned} \frac{1}{\sqrt{8}}(|000\rangle + |001\rangle +
    |010\rangle + |011\rangle + |100\rangle + |101\rangle + |110\rangle + |111\rangle
    ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ77.png)(77)And
    similarly for ![$$|---\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq513.png):![$$\begin{aligned}
    \frac{1}{\sqrt{8}}(|000\rangle - |001\rangle - |010\rangle + |011\rangle - |100\rangle
    + |101\rangle + |110\rangle - |111\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ78.png)(78)You
    can put together these two equations to get the general state of the logical qubit
    ![$$|\psi \rangle _L$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq514.png),
    which as you may have already guess is a bit lengthy to write. Nevertheless, you
    can do this and apply the two stabilizer gates to verify that they leave the state
    unchanged with an eigenvalue of ![$$+1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq515.png)
    when there is no error and ![$$-1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq516.png)
    when there is a phase error.For the sake of completeness, we will show this in
    the Hadamard basis. To understand the derivation, remember that ![$$Z|+\rangle
    = |-\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq517.png)
    and the other way around, and ![$$X|+\rangle = |+\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq518.png)
    and ![$$X|-\rangle = (-1)|-\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq519.png).
    So, for the logical state with no error introduced, we get the following equation:![$$\begin{aligned}
    X_1X_2(\alpha |+++\rangle + \beta |---\rangle )&amp;= X_1(\alpha |+++\rangle -
    \beta |---\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ79.png)(79)![$$\begin{aligned}&amp;=
    \alpha |+++\rangle + \beta |---\rangle = (+1)|\psi \rangle _L \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ80.png)(80)Doing
    the same for ![$$X_2X_3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq520.png)
    yields identical results. Now, let’s see an example where ![$$E=Z_1$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq521.png)
    so the logical qubits are in the state ![$$Z_1|\psi \rangle _L = \alpha |-++\rangle
    + \beta |+--\rangle $$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq522.png)![$$\begin{aligned}
    X_1X_2(\alpha |-++\rangle + \beta |+--\rangle )&amp;= X_1(\alpha |-++\rangle -
    \beta |+--\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ81.png)(81)![$$\begin{aligned}&amp;=
    -\alpha |-++\rangle - \beta |+--\rangle = (-1)Z_1|\psi \rangle \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ82.png)(82)As
    you can see, the syndrome extraction works just as in the bit flip case. Getting
    all the possible syndrome measurements and assigning them to a correcting gate,
    we got ourselves a phase error correcting code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 General Error Correcting Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen how to correct both bit flips and phase errors by themselves, but
    we still need to put these two circuits together to correct any given error (rotation
    in the Bloch sphere). Doing this is out of the scope of this section, but it isn’t
    too hard. An example of such correcting code is Shor’s [[9, 1, 3]] (double brackets
    are generally used to distinguish from classical codes, which use single brackets)
    code [[66](#CR66)]. This code uses the codes we defined in the last two section
    to create a single 9-qubit error correction code with a distance of 3\. To do
    this, it defines its codespace as spanned by the following two logical states:![$$\begin{aligned}
    |0\rangle _L&amp;= \frac{1}{\sqrt{8}}(|000\rangle + |111\rangle )(|000\rangle
    + |111\rangle )(|000\rangle + |111\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ83.png)(83)![$$\begin{aligned}
    |1\rangle _L&amp;= \frac{1}{\sqrt{8}}(|000\rangle - |111\rangle )(|000\rangle
    - |111\rangle )(|000\rangle - |111\rangle ) \end{aligned}$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_Equ84.png)(84)Then,
    the stabilizers are defined as ![$$Z_1Z_2, Z_2Z_3, \dots , Z_8Z_9$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq523.png)
    and ![$$X_1X_2, X_2X_3, \dots , X_8X_9$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq524.png).
    This gives us a unique syndrome measurement for each of the single qubit *X* errors,
    which in turns allows us to easily correct for them. For each single qubit *Z*
    errors we do not get a unique syndrome measurement, but this is not a problem
    since the errors for which we get the same measurement can be corrected with the
    same operator. This is why Shor’s code has the ideal distance of 3.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this distance ideal? Codes with distance ![$$d\ge 3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq525.png)
    allow for detection and accurate correction of errors, while codes with ![$$d&lt;3$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq526.png)
    only allow for error detection (they don’t specify in which qubit the error was
    introduced). Shor’s code isn’t the only implementation of an error correcting
    code that can correct any error. A rigorous description and construction of ![$$[[n,
    k, d\ge 3]$$](../images/516210_1_En_1_Chapter/516210_1_En_1_Chapter_TeX_IEq527.png)
    codes can be found in Sects. 4.1–4.2 and 4.4–4.5 of [[58](#CR58)]. Furthermore,
    quantum error correction is a very active research field where different ways
    of designing correcting codes are being actively pursued. One such example is
    the surface code, of which you can read more about in [[67](#CR67)] and [[68](#CR68)].
  prefs: []
  type: TYPE_NORMAL
- en: 4 Conclusions and Notes on Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we have introduced the concepts of quantum information, entanglement,
    quantum gates, superdense coding, teleportation, entanglement swapping, entanglement-based
    quantum key distribution, and quantum secret sharing. In quantum blockchain, teleportation
    is important when double-spending must be prevented. That is, once the quantum
    state is sent, a person can not retain the coin that is spent. Blockchain can
    be in fact translated into quantum circuit formalism, hence the reader in introduced
    to simple qubit gates and how a universal quantum circuits can be constructed
    from them. For example, a quantum analogue of Byzantine agreement can be constructed,
    replacing its classical counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Any quantum communication or transaction will be done via a network. Quantum
    systems are fragile to environmental noise. We have introduced the notion of quantum
    noise, which induced Markov or non-Markov evolution of the system interacting
    with the noise. It is possible that in a quantum network, including blockchain
    technology can make use of the information back-flow in non-Markovian dynamics.
    Interestingly, noise is not always a bad new. With sufficient control in a laboratory,
    the legitimate parties can add extra quantum noise to the system to gain a counter-intuitive
    advantage in security against hacking.
  prefs: []
  type: TYPE_NORMAL
- en: The multiple controlled Toffoli is a versatile class of gates that find uses
    in many applications of cryptography and blockchain. In the future, it is very
    probable that quantum computers will break the elliptic curve signature scheme
    using Shor’s algorithm for computing discrete logarithms [[69](#CR69)]. In addition,
    quantum computers offer quadratic speed up using Grover’s algorithm when doing
    blockchain proof-of-work (PoW) [[70](#CR70)]. However, the optimized clock speed
    of current hardware used for PoW, along with the much slower projected gate speeds
    for current quantum architectures, essentially nullifies all of the above advantages.
    In both these examples, Toffoli gates (in the form of an oracle) account for the
    majority of the resources used [[71](#CR71)]. Thus, there is a real desire to
    optimize these expensive components as much as possible for quantum computers
    to provide any tangible advantage.
  prefs: []
  type: TYPE_NORMAL
- en: As for the far future, many of the proposed quantum blockchain protocols [[72](#CR72),
    [73](#CR73)] operate under the central assumption of fault-tolerant computation.
    Hence, by the nature of reversible computing, multiple controlled operations will
    undoubtedly play an essential role in any error correction scheme that would be
    implemented on such devices.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum blockchains of practical use will require a large amount of qubits and
    gates in order to be effective. In order for it to achieve advantages over its
    classical counterpart, a quantum blockchain needs to be both fast and accurate.
    Quantum error correction is a crucial part on improving the latter factor. Codes
    with small codeword length and sufficiently large code distance are needed to
    accurately detect and correct errors in the circuits used in a quantum blockchain.
    This has to be achieved at the same time that efficiency is taken in mind, as
    we don’t want the circuit complexity of the correcting code to get as large or
    even larger than that of the original circuit. If these criteria are met, then
    quantum blockchains (and all other applications of quantum information) will be
    greatly benefited and we could see a rapid advancement on their real-world use.
  prefs: []
  type: TYPE_NORMAL
- en: Current blockchain technologies based on classical information principles are
    under threat due to rise of quantum computing. Efforts are being put to develop
    (classical) post-quantum crypto-secure protocol that will be secure under an attack
    by quantum computers. However, it is a good idea to develop quantum blockchain
    technology which is safe against quantum attacks. Quantum cryptography has been
    developed to a great extent and is already being put to initial uses in academia
    and industries alike. In a similar fashion, quantum blockchain will emerge as
    a new decentralized, encrypted ledger technology that will rely on the principles
    of quantum mechanics. And possibly, a future technology which will integrate classical
    and quantum principles and techniques to develop much more safer blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs: []
  type: TYPE_NORMAL
- en: US thanks R. Srikanth for reviewing the draft and Vinod N. Rao for helpful discussion
    on quantum secret sharing. US also thanks C. M. Chandrashekar for the encouragement.
  prefs: []
  type: TYPE_NORMAL
- en: Author Contributions
  prefs: []
  type: TYPE_NORMAL
- en: US contributed the Sect. [1](#Sec1) on quantum information. MP contributed the
    Sect. [2](#Sec20) on multiple controlled Toffoli gate, and EP contributed the
    Sect. [3](#Sec39) on quantum error correction.
  prefs: []
  type: TYPE_NORMAL
