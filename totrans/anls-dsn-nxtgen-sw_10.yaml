- en: © Springer Nature Switzerland AG 2020A. M. LangerAnalysis and Design of Next-Generation
    Software Architectures[https://doi.org/10.1007/978-3-030-36899-9_10](https://doi.org/10.1007/978-3-030-36899-9_10)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Springer Nature Switzerland AG 2020 A.M.兰格下一代软件架构的分析与设计[https://doi.org/10.1007/978-3-030-36899-9_10](https://doi.org/10.1007/978-3-030-36899-9_10)
- en: 10. Transforming Legacy Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 转换传统系统
- en: 'Arthur M. Langer^([1](#Aff2) [ ](#ContactOfAuthor2))(1)Center for Technology
    Management, Columbia University, New York, NY, USAArthur M. LangerEmail: [al261@columbia.edu](mailto:al261@columbia.edu)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阿瑟·M·兰格（1）哥伦比亚大学技术管理中心，纽约，纽约，美国。 阿瑟·M·兰格电子邮件：[al261@columbia.edu](mailto:al261@columbia.edu)
- en: 10.1 Introduction
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 介绍
- en: 'A Legacy system is an existing application system in operation. While this
    is an accurate definition, there is a perception that legacy systems are old and
    antiquated applications operating on mainframe computers. Indeed, Brodie and Stonebraker
    ([1995](#CR1)) state that, “a legacy information system is any information system
    that significantly resists modification and evolution” (p. 3). They define typical
    legacy systems as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 传统系统是指正在运行的现有应用系统。虽然这是一个准确的定义，但有一种看法认为传统系统是在大型机上运行的老旧的、过时的应用程序。实际上，布罗迪和斯通布雷克（1995年）指出，“传统信息系统是任何显著抵制修改和演进的信息系统”（第3页）。他们将典型的传统系统定义为：
- en: Large application with millions of lines of code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型应用程序有数百万行的代码。
- en: Usually more than 10 years old.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常超过10年的历史。
- en: Written in legacy languages like COBOL .
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用COBOL等传统语言编写。
- en: They are built around a legacy database service (such as IBM’s IMS) and some
    do not use a database management system. Instead they use older flat-file systems
    such as ISAM and VSAM .
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们围绕着传统数据库服务构建（如IBM的IMS），有些不使用数据库管理系统。而是使用较旧的平面文件系统，如ISAM和VSAM。
- en: The applications are very autonomous. Legacy applications tend to operate independently
    from other applications, which means that there is very limited interface among
    application programs. When interfaces among applications are available, they are
    usually based on export and import models of data and these interfaces lack data
    consistency.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序非常自主。传统应用程序倾向于独立运行，这意味着应用程序之间的接口非常有限。当应用程序之间存在接口时，它们通常基于数据的导出和导入模型，这些接口缺乏数据一致性。
- en: While many legacy systems do fit these scenarios, many do not. Those that do
    not can; however, be considered legacies under my original definition, that is,
    any application in operation. What this simply means is that there are what I
    call “generations” of legacy systems that can exist in any organization. Thus,
    the definitions of what constitutes a legacy system are much broader than Brodie
    and Stonebraker’s descriptions. The more important issue to address is the relationship
    of legacy systems with packaged software systems especially with the explosion
    of independent APIs from the evolving IoT devices, blockchain products and Cloud
    computing. Packaged software systems that are typically supported by third-party
    vendors encompass both internal and external applications. Thus, existing internal
    production systems, including third-party outsourced products, must be part of
    any application strategy. Furthermore, there are many legacy systems that perform
    external functions as well, albeit not in directly in an internet interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多传统系统符合这些场景，但也有许多不符合的。那些不符合的可以被认为是传统系统，根据我的原始定义，即任何正在运行的应用程序。这意味着在任何组织中都可能存在我所谓的“代际”传统系统。因此，对于传统系统构成的定义要比布罗迪和斯通布雷克的描述宽泛得多。更重要的问题是解决传统系统与封装软件系统的关系，特别是随着独立API从不断发展的物联网设备、区块链产品和云计算的爆炸式增长。通常由第三方供应商支持的封装软件系统涵盖内部和外部应用程序。因此，现有的内部生产系统，包括第三方外包产品，必须成为任何应用程序战略的一部分。此外，还有许多传统系统也执行外部功能，尽管不直接在互联网界面中执行。
- en: This chapter defines the type of legacy systems that exist and provides guidelines
    on how to approach their integration with packaged software applications and transformation
    in into the new architectures that support IoT. The project manager or analyst
    must determine whether a legacy system should be replaced, enhanced, or remain
    as is. This chapter also provides the procedures for dealing with each of these
    three choices and its effect on the overall architecture of the decision whether
    to make or buy a system. However, overall this chapter suggests that all traditional
    legacy at some point need to redeveloped to support mobility and maximized cyber
    protection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Types of Legacy Systems
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The types of legacy systems tend to mirror the life cycle of software development.
    Software development is usually defined within a framework called “generations.”
    Most professionals agree that there are five generations of programming languages:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*First*-*Generation*: the first generation was known as machine language. Machine
    language is considered a low-level language because there it uses binary symbols
    to communicate instructions to the hardware. These binary symbols form a one-to-one
    relationship between a machine language command and a machine activity, that is,
    one machine language command performs one machine instruction. It is rare that
    any legacy systems have first-generation software.'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Second*-*Generation* : this generation was comprised of assembler programming
    languages. Assembler languages are proprietary software that translates a higher-level
    coding scheme into more than one machine language instruction. Therefore, it was
    necessary to design an assembler, which would translate the symbolic codes into
    machine instructions. Mainframe shops still may have a considerable amount of
    assembly code that exists, particularly with applications that perform intricate
    algorithms and calculations.'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Third*-*Generation* : these languages continued the growth of high-level symbolic
    languages that had translators into machine code. Examples of third-generation
    languages are COBOL , FORTRAN, BASIC, RPG, and C. These languages use more English-like
    commands and have a higher ratio of machine language produced from one instruction.
    Third-generation languages tend to be more specialized. For example, FORTRAN is
    better suited for mathematical and scientific calculations. Therefore, many insurance
    companies have FORTRAN because of the high concentration on actuarial mathematic
    calculations. COBOL , on the other hand, was designed as the business language
    and has special features to allow it to manipulate file and database information.
    There are more COBOL applications that exist than any other programming language.
    Most mainframe legacy systems still have COBOL applications. RPG is yet another
    specialized language that were designed for use on IBM’s mid-range machines. These
    machines include the System 36, System 38, and AS/400 computers.'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Fourth*-*Generation* (*4GL*): these programming languages are less procedural
    than third-generation languages. In addition, the symbols are more English-like
    and emphasize more about desired output results than how the programming statements
    need to be written. As a result of this feature, many less technical programmers
    have learned how to program using 4GLs. The most powerful features of 4GLs include
    query of databases , code-generation, and graphic screen generation abilities.
    Such languages include Visual Basic, C ++, Visual Basic, Powerbuilder, Delphi,
    and many others. Furthermore, 4GL languages also include what is known as *query
    languages* because they contain English-like questions that are used to directly
    produce results by directly accessing relational databases . The most popular
    4GL query language is Structured Query Language (SQL ).'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Fifth*-*Generation*: these programming languages combine what is known as
    rule-based code generation, component management, and visual programming techniques.
    The rule-based code generation became popular in the late 1980s with the creation
    of artificial intelligence software. This software uses an approach called knowledge-based
    programming, which means that the developer does not tell the computer how to
    solve problems, but rather the problem (Stair and Reynolds [1999](#CR2)). The
    program figures out how to solve the problem. While knowledge-based programming
    has become popular in specialized applications, such as in the medical industry,
    it has not been as popular in business.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most legacy applications will either be third- or fourth-generation language
    systems, therefore, analysts need to have a process and methodology to determine
    how to transform and re-architect these applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Third-Generation Language Legacy System Integration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously discussed, most third-generation language legacy systems were
    developed using COBOL . COBOL was developed to provide a method of forcing programmers
    to self-document their code so that other programmers could maintain it. Unfortunately,
    COBOL requires what is known as a File Description Table (FD). The FD defines
    the record layout for every file used by the COBOL program. In other words, every
    file is described within the program and must match the format of the actual physical
    data file. This means that any change to a file structure must be synchronized
    with every COBOL program that uses that data file. Thus, COBOL is somewhat eclectic:
    there is no real separation of the data description and the program logic. In
    COBOL programs then, a change in data format could necessitate a change in the
    program code. That is why COBOL programs suffer from large degrees of coupling
    of code. Coupling is defined as the reliance of one piece of the code on another.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: COBOL programs may or may not use a relational database as its source of data.
    I earlier defined two other common formats called ISAM and VSAM , which are flat-file
    formats, meaning that all data elements are contained in one record as opposed
    to multiple files as is the case in the relational database model. However, many
    COBOL legacy systems have been converted to work with relational databases such
    as IBM’s DB2\. In this situation the FD tables interface with the database’s file
    manager so that the two entities can communicate with each other. Figure [10.1](#Fig1)
    depicts the interface between program and database .![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig1_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig1_HTML.png)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: COBOL程序可能使用关系数据库或者不使用关系数据库作为其数据源。我之前定义了另外两种常见的格式，称为ISAM和VSAM，它们是平面文件格式，这意味着所有数据元素都包含在一个记录中，而不像关系数据库模型中那样包含在多个文件中。然而，许多COBOL遗留系统已被转换为与诸如IBM的DB2等关系数据库一起工作。在这种情况下，FD表与数据库的文件管理器进行接口，以便这两个实体可以相互通信。图 [10.1](#Fig1) 描述了程序与数据库之间的接口。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig1_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig1_HTML.png)
- en: Fig. 10.1
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1
- en: COBOL file description interface with database manager
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: COBOL文件描述与数据库管理器进行接口
- en: Notwithstanding whether the COBOL legacy is using a database interface or flat-files
    the analyst needs to determine whether to replace the application, enhance it,
    or leave it as is.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论COBOL遗留系统是否使用数据库接口或平面文件，分析人员都需要确定是替换应用程序，增强它还是保持原样。
- en: 10.4 Replacing Third-Generation Legacy Systems
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 替换第三代遗留系统
- en: 'When replacing third-generation legacies, analysts must focus on both the data
    and processes . Because of the age of these systems, it is likely that there will
    be little documentation available, and the amount available will most likely be
    outdated. Indeed, the lack of proper documentation is the major reason why legacy
    systems are slow to be replaced: rewriting code without documentation can be an
    overwhelming and time-consuming task. Unfortunately, all things must eventually
    be replaced. Delaying replacement leads to legacy systems that keep businesses
    from remaining competitive. The following sections provide a step-by-step approach
    to COBOL -based legacies.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 替换第三代遗留系统时，分析人员必须同时关注数据和流程。由于这些系统的年龄，可能会很少有文档可用，并且可用文档的数量很可能已经过时。事实上，缺乏适当的文档是遗留系统被替换的主要原因：在没有文档的情况下重写代码可能是一个艰巨且耗时的任务。不幸的是，所有事物最终都必须被替换。延迟替换会导致遗留系统使企业无法保持竞争力。以下各节提供了一种基于COBOL的遗留系统的逐步方法。
- en: 10.5 Approaches to Logic Reconstruction
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 逻辑重构的方法
- en: 'The best way to reconstruct the logic in COBOL applications is to separate
    the data from the processes . This can be accomplished by creating data flow diagrams
    (DFD) for each program. Having a DFD will result in defining all of the inputs
    and outputs of the application. This is accomplished by following the tasks below:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重建COBOL应用程序中的逻辑的最佳方法是将数据与流程分离。这可以通过为每个程序创建数据流图（DFD）来实现。拥有DFD将导致定义应用程序的所有输入和输出。通过以下任务实现：
- en: 1.Print the source code (actual COBOL written code) from each application. Each
    application will contain a “FD” section that defines all of the inputs and outputs
    of the program. These will represent the data stores of the data flow diagrams
    (Fig. [10.2](#Fig2)).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig2_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig2_HTML.png)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.打印每个应用程序的源代码（实际的COBOL编写的代码）。每个应用程序都包含一个定义程序的所有输入和输出的“FD”部分。这些将代表数据流图的数据存储（图 [10.2](#Fig2)）。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig2_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig2_HTML.png)
- en: Fig. 10.2
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2
- en: COBOL file description tables
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: COBOL文件描述表
- en: '2.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: DFDs should be decomposed so that they are at the functional primitive level
    (one-in and one-out, preferred). This provides functional decomposition for the
    old application and sets the framing for how it will be decomposed into an object-oriented
    solution.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DFD应该被分解，以便它们处于功能原语级别（一进一出，首选）。这为旧应用提供了功能分解，并为将其分解为面向对象解决方案奠定了框架。
- en: '3.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: By reviewing the code, write the process specifications for each functional
    primitive .
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过审查代码，为每个功能原语编写过程规范。
- en: '4.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Follow the steps as outlined in Chap. [3](480347_1_En_3_Chapter.xhtml) to determine
    which functional primitive DFDs become methods of a particular class .
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照第 [3](480347_1_En_3_Chapter.xhtml) 章概述的步骤来确定哪些功能原始 DFD 成为特定类别的方法。
- en: '5.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Capture all of the data elements or attributes required by each functional primitive
    DFD. These attributes are added to the data dictionary (DD).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 捕获每个功能原始 DFD 所需的所有数据元素或属性。这些属性将添加到数据字典（DD）中。
- en: '6.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Take each major data store and create an entity . Do normalization and Logic
    Data Modeling in accordance with the procedures in Chap. [4](480347_1_En_4_Chapter.xhtml),
    combining these elements with the packaged software system as appropriate.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对每个主要数据存储进行实体化处理。根据第 [4](480347_1_En_4_Chapter.xhtml) 章的流程进行规范化和逻辑数据建模，并根据需要将这些元素与打包软件系统结合起来。
- en: '7.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Data stores that represent reports should be compared against sample outputs.
    These reports will need to be redeveloped using a report-writer such as Crystal’s
    report writer or a data warehouse product.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示报告的数据存储应与样本输出进行比较。这些报告需要使用报告编写器（如 Crystal 的报告编写器或数据仓库产品）重新开发。
- en: '8.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: Examine all existing data files and/or databases in the legacy system . Compare
    these elements against those discovered during the logic reconstruction. In third-generation
    products there will be many data elements or fields that are redundant or used
    as logic “flags.” Logic flags consists of fields used to store a value that depicts
    a certain state of the data. For example, suppose a record has been updated by
    a particular program. One method of knowing that this occurred is to have the
    application program set a certain field with a code that identifies that it has
    been updated. This method would not be necessary in a relational database product
    because file managers automatically keep logs on the last time a record has been
    updated. This example illustrates how different third-generation legacy technology
    differs from more contemporary technologies.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查遗留系统中的所有现有数据文件和/或数据库。将这些元素与逻辑重构期间发现的元素进行比较。在第三代产品中，将有许多冗余的数据元素或字段，或用作逻辑“标志”的字段。逻辑标志包括用于存储表示数据特定状态的值的字段。例如，假设记录已由特定程序更新。知道发生这种情况的一种方法是让应用程序设置一个特定的字段，并使用标识已更新的代码。在关系数据库产品中，这种方法不是必要的，因为文件管理器会自动记录上次记录被更新的时间。此示例说明了第三代遗留技术与更现代技术之间的差异。
- en: There is no question that replacing third-generation legacies is time-consuming.
    However, the procedures outlined above will prove to be accurate and effective.
    In many situations, users will decide that it makes sense to re-examine their
    legacy processes , especially when the decision has been made to rewrite applications
    for integration with IoT and blockchain systems. We call this business process
    reengineering . Business process reengineering is therefore synonymous with enhancing
    the legacy system .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，替换第三代遗留系统是耗时的。然而，上述程序将证明是准确和有效的。在许多情况下，用户将决定重新审视其遗留流程，特别是在决定重新编写应用程序以与物联网和区块链系统集成时。我们称之为业务流程再造。因此，业务流程再造与增强遗留系统是同义词。
- en: 10.6 Enhancing Third-Generation Legacy Systems
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 增强第三代遗留系统
- en: Business process reengineering (BPR) is one of the more popular methodologies
    used to enhance third-generation applications. A more formal definition of BPR
    is “a requirement to study fundamental business processes , independent of organization
    units and information systems support, to determine if the underlying business
    processes can be significantly streamlined and improved.”^([1](#Fn1)) BPR is not
    just rebuilding the existing applications for the sake of applying new technology
    to older systems, but also an event that allows for the application of new procedures
    designed around the Object-Oriented systems paradigm. In this scenario, however,
    BPR is used to enhance existing applications without rewriting them in another
    generation language. Instead, the analyst needs to make changes to the system
    that will make it function more like an object component even though it is written
    in a third-generation language. In order to accomplish this task, it is necessary
    for the analyst to create the essential components of the legacy operation. Essential
    components represent the core business requirements of a unit. Another way of
    defining core business requirements is to view essential components as the reasons
    why the unit exists—what does it do—and for what reasons. For example, Fig. [10.3](#Fig3)
    depicts the essential components of a bank.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig3_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig3_HTML.png)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 业务流程再造（BPR）是用于增强第三代应用程序的较流行的方法之一。 BPR的更正式定义是“研究基本业务流程的要求，独立于组织单位和信息系统支持，以确定是否可以显着简化和改进基础业务流程。”^([1](#Fn1))
    BPR不仅仅是为了将新技术应用于旧系统而重新构建现有应用程序，而且是一个允许应用围绕面向对象系统范式设计的新程序的事件。然而，在这种情况下，BPR用于增强现有应用程序，而无需用另一种语言重写它们。相反，分析人员需要对系统进行更改，使其更像对象组件，即使它是用第三代语言编写的也是如此。为了完成这项任务，分析人员需要创建遗留操作的基本组件。基本组件代表一个单位的核心业务需求。定义核心业务需求的另一种方法是将基本组件视为单位存在的原因——它是做什么的——以及出于什么原因。例如，图[10.3](#Fig3)描述了银行的基本组件。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig3_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig3_HTML.png)
- en: Fig. 10.3
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3
- en: Essential components of a bank
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 银行的基本组成部分
- en: Once the essential components have been created then the legacy applications
    need to be placed in the appropriate component so that it can be linked with its
    related packaged software applications or decomposed into primitive APIs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了基本组件，那么遗留应用程序就需要放置在适当的组件中，以便将其与相关的打包软件应用程序链接，或将其分解为原始API。
- en: The first step to applying successful BPR to legacy applications is to develop
    an approach to defining the existing system and extracting its data elements and
    applications. Once again, this is similar to the process described above when
    replacing third-generation legacy applications in that the data needs to be captured
    into the data repository and the applications need to be defined and compared
    to a new model based on essential components .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将成功的业务流程再造（BPR）应用于遗留应用程序的第一步是制定一种定义现有系统并提取其数据元素和应用程序的方法。再次强调，这与上述替换第三代遗留应用程序的过程类似，其中需要将数据捕获到数据存储库中，并定义应用程序，并将其与基于基本组件的新模型进行比较。
- en: 10.7 Data Element Enhancements
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 数据元素增强
- en: The analyst will need to design conversion programs that will access the data
    files that are not in relational database format and place them in a data repository
    . The ultimate focus is to replace all of the existing data files in the legacy
    with relational databases that can be linked with packaged software databases
    . This methodology differs from replacing legacies. In replacement engineering,
    data files are integrated directly into a packaged software system. This means
    that the legacy data will often be used to enhance the packaged software databases
    or integrated with various cloud database products. However, the process of enhancing
    legacy systems means that the legacy data will remain separate but converted into
    the relational or object database model. For legacies that already have relational
    databases , there is no restructuring required beyond setting up links with the
    packaged software database . Figure [10.4](#Fig4) reflects the difference between
    replacing legacy data and enhancing it. Notwithstanding these steps, once these
    data elements are determined, the analyst should follow the steps to consider
    what elements should be considered for replication on IoT and blockchain architectures.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig4_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig4_HTML.png)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.4
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Replacing versus enhancing legacy data
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting difference between the two approaches is that enhanced legacies
    will likely have intentional data redundancy. This means that the same element
    may indeed exist in multiple databases ; necessary for the new distributed systems
    supported by IoT and blockchain . Duplicate elements may take on different formats.
    The most obvious is where a data element has alias’, meaning that an element has
    many different names, but the same attributes. Another type is the same element
    name, but with different attributes. The third type, and the most challenging,
    is the duplicate elements that have different names and different attributes.
    While duplicate data elements may exist in enhanced legacy applications that are
    integrated with the packaged software product, it is still important to identify
    duplicate data relationships. This can be accomplished by documenting data relationships
    in a CASE tool and in the database’s physical data dictionary where aliases can
    exist.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 10.7.1 Application Enhancements
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BPR typically involves a methodology called Business Area Analysis (BAA). The
    purpose of BAA is to:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: establish the various legacy business areas that will be linked with new architectures
    and/or packaged software systems.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: re-engineer the new and old requirements of each business area.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: develop requirements that provide an OO perspective of each legacy business
    area, meaning that there is no need to map its requirements to the existing physical
    organization structure.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: define the links that create relationships among all the legacy business areas
    and the packaged software business areas.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义创建所有遗留业务领域和包装软件业务领域之间关系的链接。
- en: This is accomplished by mapping business areas to specific essential component
    . Applications designed for the packaged software system must also be mapped to
    an essential component . Once this has occurred, the legacy applications and packaged
    software applications must be designed to share common processes and databases
    as shown in Fig. [10.5](#Fig5).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig5_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig5_HTML.png)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将业务领域映射到特定的基本组件来实现的。为包装软件系统设计的应用程序也必须映射到一个基本组件。一旦发生了这种情况，遗留应用程序和包装软件应用程序必须被设计成共享常见的流程和数据库，如图 [10.5](#Fig5)所示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig5_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig5_HTML.png)
- en: Fig. 10.5
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5
- en: BPR legacy modeling using essential components
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本组件对 BPR 遗留建模
- en: 'Once the legacy and packaged software applications have been placed in their
    appropriate essential component they will need to be linked, that is communicate
    with each other to complete the integration of the internal IoT and external systems.
    Linking occurs in two ways: parameter messaging and database . Parameter messaging
    requires that the legacy programs be modified to receive data in the form of parameters.
    This allows the application system to deliver information directly to the legacy
    program. Conversely, the legacy program may need to return information back to
    the packaged software system. Therefore, legacy applications need to be enhanced
    so they can actually format and send a data message to the packaged software system.
    A database interface is essentially the same concept except that it occurs differently.
    Instead of the application sending the data directly to another program, it forwards
    it as a record in a database file. The legacy program that returns the data also
    needs to be modified to forward messages to a likely cloud database .'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将遗留和包装软件应用程序放置在适当的基本组件中，它们将需要被链接，也就是彼此通信以完成内部 IoT 和外部系统的集成。链接有两种方式：参数消息和数据库。参数消息要求修改遗留程序以接收参数形式的数据。这允许应用系统直接向遗留程序传递信息。相反，遗留程序可能需要将信息返回给包装软件系统。因此，遗留应用程序需要被增强，以便它们实际上可以格式化并发送数据消息到包装软件系统。数据库接口本质上是相同的概念，只是它的发生方式不同。与应用程序将数据直接发送到另一个程序不同，它将其作为数据库文件中的记录转发。返回数据的遗留程序还需要被修改，以将消息转发到可能的云数据库。
- en: There are advantages and disadvantages of using either method. First, parameters
    use little overhead and are easy to program. They do not provide reusable data,
    that is, once a message has been received it is no longer available to another
    program. Parameters are also limited in size. Databases , on the other hand, allow
    programs to send the information to multiple destinations because it can be read
    many times. Unfortunately, it is difficult to control what applications or queries
    can access the data, which does raise questions about how secure the data is.
    Furthermore, applications must remember to delete a record in the database if
    it is no longer required. Figure [10.6](#Fig6) reflects the two methods of transferring
    data between legacy systems and packaged software applications.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig6_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig6_HTML.png)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任一方法都有优点和缺点。首先，参数使用的开销很小，编程容易。它们不提供可重用的数据，也就是说，一旦收到消息，它就不再对另一个程序可用。参数的大小也受限制。另一方面，数据库允许程序将信息发送到多个目的地，因为它可以被多次读取。不幸的是，很难控制哪些应用程序或查询可以访问数据，这确实引发了关于数据安全性的问题。此外，如果不再需要记录，应用程序必须记住在数据库中删除记录。图 [10.6](#Fig6)反映了在遗留系统和包装软件应用程序之间传输数据的两种方法。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig6_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig6_HTML.png)
- en: Fig. 10.6
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6
- en: Linking data between legacy and packaged software systems
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗留和包装软件系统之间链接数据
- en: 'Once the legacy and the new applications have all been mapped to the essential
    components , analysts can use a CRUD diagram to assist them in reconciling whether
    all of the data and processes have been found. The importance of the CRUD diagram
    is that it ensures:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将遗留应用和新应用都映射到基本组件，分析师就可以使用 CRUD 图来帮助他们协调是否已经找到所有的数据和流程。CRUD 图的重要性在于它确保：
- en: that an essential component has complete control over its data,
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重要组件完全控制其数据，
- en: that all of the entities are accessible by at least one process , and
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有实体至少被一个进程访问，并且
- en: that processes are accessing data (Fig. [10.7](#Fig7)).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig7_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig7_HTML.png)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程正在访问数据（见图 [10.7](#Fig7)）。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig7_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig7_HTML.png)
- en: Fig. 10.7
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.7
- en: Sample CRUD diagram
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例 CRUD 图
- en: While CRUD is not 100% accurate, it certainly uncovers potential problems as
    shown above. Even if BPR is not used, the CRUD diagram is an excellent tool to
    use to determine the processes and data needed for an essential component or an
    object. Once the CRUD diagram is finalized, the objects and classes would then
    be created as shown in Fig. [10.8](#Fig8); some of these objects are still in
    the form of a third-generation COBOL program while others might be in an API-based
    packaged software format. It is important to note; however, the “U” and the “D”
    are not allowed in a blockchain application, because ledger systems do not allow
    modification of existing transactions!![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig8_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig8_HTML.png)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 不是 100% 准确，但它确实揭示了可能存在的问题，如上所示。即使不使用 BPR，CRUD 图也是一个用于确定重要组件或对象所需的过程和数据的优秀工具。一旦
    CRUD 图完成，对象和类将如图 [10.8](#Fig8) 所示创建；其中一些对象仍以第三代 COBOL 程序的形式存在，而另一些可能以基于 API 的打包软件格式存在。然而，重要的是要注意，“U”
    和 “D” 在区块链应用中是不允许的，因为账本系统不允许修改现有交易！[../images/480347_1_En_10_Chapter/480347_1_En_10_Fig8_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig8_HTML.png)
- en: Fig. 10.8
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8
- en: Essential component object diagrams
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要组件对象图
- en: 10.8 “Leaving As Is”—Third-Generation Legacy Systems
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8“按原样离开”——第三代遗留系统
- en: Moving to an object-oriented and API paradigm from a third-generation product
    like COBOL may not be feasible. The language design of third-generation procedural
    programs may result in conceptual gaps between procedural and object-oriented
    philosophies. For example, distributed object-oriented programs require more detailed
    technical infrastructure knowledge and graphics manipulation then was required
    in older legacy systems . Native object-oriented features such as inheritance,
    polymorphism, and encapsulation do not apply in traditional third-generation procedural
    design. It is difficult, if not impossible to introduce new object concepts and
    philosophies during a direct COBOL to JAVA API migration. If the translation is
    attempted without significant restructuring (as discussed earlier in this chapter)
    then the resulting product will likely contain slower code that is more difficult
    to maintain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从类似 COBOL 这样的第三代产品转向面向对象和 API 范式可能并不可行。第三代过程化程序的语言设计可能导致过程式和面向对象哲学之间的概念差距。例如，分布式面向对象程序需要比旧的传统系统更详细的技术基础知识和图形处理。原生的面向对象特性，比如继承、多态和封装，在传统的第三代过程化设计中不适用。在直接将
    COBOL 转换为 JAVA API 时，很难，甚至不可能引入新的对象概念和哲学，如果不进行重大重构（正如本章前面讨论的）。如果尝试翻译而不进行重大重组（如本章前所述），则结果产品可能包含更难维护的较慢的代码。
- en: There can also be a cultural divide that occurs. Veteran COBOL programmers and
    newer JAVA API developers do not understand each other’s technologies. This scenario
    will often create bias during any conversion effort. Furthermore, COBOL programmers
    learning new technology can present them with self-specified threats to their
    cultural status. Furthermore, COBOL and RPG applications have benefited from more
    lengthy testing, debugging, and overall refinement than newer programming generations.
    While JAVA is more dynamic, it is less stable, and the procedure of debugging
    and fixing problems are very different than for COBOL or RPG. Therefore, the analyst
    will leave the legacy “as is,” and create only packaged software links for passing
    information that is required between the two systems. While this is similar to
    the “linking” proposed for enhancing legacy systems , it is different because
    legacy programs are not enhanced, except for the external links needed to pass
    information. This is graphically shown in Fig. [10.9](#Fig9).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig9_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig9_HTML.png)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在文化分歧。老练的 COBOL 程序员和新手 JAVA API 开发人员互相不理解对方的技术。这种情况往往会在任何转换工作中产生偏见。此外，COBOL
    程序员学习新技术可能会对他们的文化地位构成自我认定的威胁。此外，COBOL 和 RPG 应用程序经过了比较新的编程世代更长时间的测试、调试和整体改进。虽然
    JAVA 更具动态性，但它不太稳定，调试和解决问题的程序与 COBOL 或 RPG 完全不同。因此，分析人员将保持遗留系统的“原样”，仅创建必要的打包软件链接以传递所需的信息。虽然这与提升遗留系统所提出的“链接”类似，但不同之处在于，除了传递信息所需的外部链接外，遗留程序不会得到增强。这在图 [10.9](#Fig9)
    中以图形方式显示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig9_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig9_HTML.png)
- en: Fig. 10.9
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9
- en: “As Is” legacy links
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “原样”遗留链接
- en: Using parameters or databases to link connecting information is still relevant,
    but analysts must be cognizant that legacy data formats will not be changed. This
    means that the legacy applications will continue to use their original file formats.
    Another concept used to describe “links” is called “bridges.” The word suggests
    that the link serves to connect a gap between the packaged software system and
    the legacy applications. Bridging can also imply temporary link. Very often “as
    is” can be seen as a temporary condition because legacy conversions cannot occur
    all at once, so it is typically planned in phases. However, while parts of the
    system are being converted, some portions may need temporary bridges until it
    is time to actually enhance them. One can visualize this as a temporary “road
    block” or detour that occurs when there is construction on a highway.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数或数据库来连接信息仍然是相关的，但分析人员必须意识到遗留数据格式不会改变。这意味着遗留应用程序将继续使用其原始文件格式。用于描述“链接”的另一个概念称为“桥梁”。这个词表明，链接用于连接打包软件系统和遗留应用程序之间的差距。桥接也可以暗示临时链接。很多时候，“原样”可以被视为一个临时条件，因为遗留转换不能一次性完成，因此通常是分阶段计划的。但是，在系统的部分部分被转换的同时，一些部分可能需要临时桥梁，直到实际增强它们的时候。人们可以将其视为临时的“路障”或绕行路线，当高速公路上有施工时会发生这种情况。
- en: 10.9 Fourth-Generation Language Legacy System Integration
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9 第四代语言遗留系统集成
- en: Integrating fourth-generation legacy systems with packaged software technology
    is much easier than third-generation languages. The reasons are two-fold. First,
    most fourth-generation implementations are already using a relational database
    , so conversion of data to the packaged software system is less complex. Second,
    fourth-generation language applications typically use SQL -based code, so conversion
    to an object-oriented system is also less involved.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将第四代遗留系统与打包软件技术集成要比第三代语言容易得多。原因有两个。首先，大多数第四代实现已经在使用关系数据库，因此将数据转换到打包软件系统的复杂度较低。其次，第四代语言应用通常使用基于
    SQL 的代码，因此转换为面向对象的系统也较少涉及。
- en: 10.10 Replacing Fourth-Generation Legacy Systems
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10 替换第四代遗留系统
- en: As stated above, replacement of fourth-generation language systems is less complex
    than third-generation languages with respect to the packaged software conversion.
    As with any system replacement, separating data and process is the suggested approach.
    Fortunately, in fourth-generation language systems, process and data are likely
    to already be separate, because of the nature of its architecture. Specifically,
    fourth-generation languages typically use relational databases , which architecturally
    separate data and process . Therefore, replacing the legacy is more about examining
    the existing processes and determining where the applications need to be reengineered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，与打包软件转换相关的第四代语言系统的替换比第三代语言更不复杂。与任何系统替换一样，分离数据和过程是建议的方法。幸运的是，在第四代语言系统中，由于其架构的性质，过程和数据可能已经分开。具体而言，第四代语言通常使用关系数据库，其在架构上分离数据和过程。因此，替换遗留系统更多地涉及检查现有流程，并确定应该对应用程序进行重新工程设计的位置。
- en: 10.11 Approaches to Logic Reconstruction
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.11 逻辑重构方法
- en: The best approach to logic analysis is to print out the source code of the programs.
    If the source is written in SQL , then the analyst should search for all SELECT
    statements. SQL SELECT FROM statements define the databases that the program is
    using as shown in Fig. [10.10](#Fig10).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig10_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig10_HTML.png)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对逻辑分析的最佳方法是打印出程序的源代码。如果源代码是用SQL编写的，则分析师应搜索所有SELECT语句。SQL SELECT FROM语句定义程序正在使用的数据库，如图[10.10](#Fig10)所示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig10_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig10_HTML.png)
- en: Fig. 10.10
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10
- en: SELECT statements in a fourth-generation language application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第四代语言应用程序中的SELECT语句
- en: 'As in third-generation languages logic reconstruction, the analyst should produce
    a DFD for every program as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第三代语言逻辑重构一样，分析师应该为每个程序生成一个DFD，如下所示：
- en: '1.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: SELECT statements define all inputs and outputs that a program uses. Each SELECT
    statement file will be represented by a DFD data store. Reviewing the logic of
    the application program will reveal whether the data is being created, read, updated,
    or deleted (CRUD ).
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SELECT语句定义程序使用的所有输入和输出。每个SELECT语句文件将由一个DFD数据存储表示。审查应用程序的逻辑将揭示数据是被创建、读取、更新还是删除（CRUD）。
- en: '2.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: DFD’s should be decomposed to the functional primitive level so that the framework
    to an object-oriented system is established.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DFD应分解到功能原始级别，以建立面向对象的系统框架。
- en: 3.For each DFD copy the relevant SQL code, making modifications where necessary
    to provide more object-oriented functionality to the program. This means that
    the decomposition of the code will likely require that some new logic be added
    to transform it to a method. This is shown in Fig. [10.11](#Fig11).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig11_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig11_HTML.png)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.对于每个DFD，复制相关的SQL代码，根据需要进行修改，以向程序提供更多面向对象的功能。这意味着代码的分解可能需要添加一些新的逻辑来将其转换为方法。如图[10.11](#Fig11)所示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig11_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig11_HTML.png)
- en: Fig. 10.11
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.11
- en: SQL code transition to object method
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL代码过渡到对象方法
- en: '4.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Examine existing system objects and determine if functional primitive DFDs belong
    to an existing class as a new method, or whether it truly represents a new object
    in the packaged software system.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查现有系统对象，确定功能原始DFD是否属于现有类作为新方法，还是真正表示打包软件系统中的新对象。
- en: '5.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Capture all of the data elements required by the new methods and add them to
    their respective object. Ensure that the packaged software DD is updated appropriately.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 捕获新方法所需的所有数据元素，并将它们添加到各自的对象中。确保打包软件DD得到适当更新。
- en: '6.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Determine whether any new objects need to become a reusable component in the
    TP monitor (middleware), a reusable component in the client application, or as
    a stored procedure at the database level.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定是否有任何新对象需要成为TP监视器（中间件）中的可重用组件，客户端应用程序中的可重用组件，或者作为数据库级别的存储过程。
- en: '7.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Examine the legacy databases and do logic data modeling to place the entities
    in third-normal form (3NF).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查遗留数据库并进行逻辑数据建模，将实体放置在第三正规形式（3NF）中。
- en: '8.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: Combine and integrate data elements with packaged software databases , ensuring
    that each data field from the legacy system is properly matched with packaged
    software data elements . New elements must be added to the appropriate entity
    or require that new entities be created for them.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将数据元素与打包软件数据库结合并整合，确保遗留系统中的每个数据字段与打包软件数据元素正确匹配。新元素必须添加到适当的实体中，或者需要为它们创建新的实体。
- en: '9.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9.'
- en: Link new entities with existing models using third-normal form referential integrity
    rules.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用第三范式参照完整性规则将新实体与现有模型关联起来。
- en: 10.Determine which data elements are redundant, such as calculations. These
    data elements will be removed; however, logic to their calculations may need to
    be added as a method as shown in Fig. [10.12](#Fig12).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig12_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig12_HTML.png)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10.确定哪些数据元素是多余的，例如计算。这些数据元素将被删除；然而，可能需要为它们的计算添加逻辑，如图 [10.12](#Fig12)所示的方法。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig12_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig12_HTML.png)
- en: Fig. 10.12
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.12
- en: Transition of redundant data elements to process specifications
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将多余的数据元素转换为处理规范。
- en: 10.12 Enhancing Fourth-Generation Legacy Systems
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.12 加强第四代遗留系统
- en: Enhancing fourth-generation language legacy systems is really the process of
    converting it to an object-oriented client/server system. BPR (Business Process
    Reengineering ) is also used on fourth-generation language legacy systems to accomplish
    this transition. The process , as one might expect, is much easier than for third-generation
    languages; however, the process of determining essential components is the same
    in both type of systems. Once essential components are established, the existing
    applications need to be decomposed and realigned as appropriate. This is accomplished
    by using BAA, as it was used for third-generation legacy applications. The fact
    that fourth-generation languages are less procedural than third-generation languages
    greatly assists this transition. Fourth-generation language systems, by simply
    looking at the SQL SELECT statements can identify which data files are used by
    the application. Using logic modularity rules, an analyst can establish cohesive
    classes based on applications that use the same data. This can be accomplished
    without using DFDs, although reengineering using DFDs is always a more thorough
    method for analysts to follow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 加强第四代语言遗留系统实际上是将其转换为面向对象的客户端/服务器系统。 BPR（业务流程再造）也用于第四代语言遗留系统以完成这一过渡。正如人们可能期望的那样，与第三代语言相比，该过程要容易得多；但是，确定必要组件的过程在两种类型的系统中是相同的。一旦建立了必要的组件，就需要将现有应用程序进行分解和重新对齐。这是通过使用BAA来实现的，就像它用于第三代遗留应用程序一样。第四代语言比第三代语言少程序化的事实极大地促进了这一过渡。通过简单查看SQL
    SELECT语句，第四代语言系统可以确定应用程序使用哪些数据文件。使用逻辑模块化规则，分析人员可以根据使用相同数据的应用程序建立凝聚的类。这可以在不使用DFD的情况下完成，尽管使用DFD进行重新工程始终是分析人员遵循的更彻底的方法。
- en: Linkage of fourth-generation language legacy and packaged software applications
    needs to be accomplished after application reengineering is completed. As with
    third-generation language systems, this can either be accomplished using a data
    parameter or the creation of a special database . However, with fourth-generation
    languages it is likely that application integration will occur using databases
    , since both systems use them in their native architectures. An analyst will most
    likely find that application communication with fourth-generation languages will
    not always require separate databases to be designed solely for the purpose of
    system linkage. The more attractive solution to integration is to identify the
    data elements that are common between the two systems so it can be shared in a
    central database available to all applications as shown in Fig. [10.13](#Fig13).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig13_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig13_HTML.png)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第四代语言遗留和打包软件应用程序的链接需要在应用程序重构完成后完成。与第三代语言系统一样，这可以通过使用数据参数或创建专用数据库来完成。但是，使用第四代语言时，应用集成可能会使用数据库，因为这两个系统都在其本地架构中使用它们。分析人员很可能会发现，与第四代语言的应用通信并不总是需要专门设计用于系统链接目的的独立数据库。集成的更有吸引力的解决方案是识别两个系统之间共同的数据元素，以便在一个中央数据库中共享，该数据库对所有应用程序都可用，如图所示。
    [10.13](#Fig13)。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig13_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig13_HTML.png)
- en: Fig. 10.13
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13
- en: Fourth-generation language legacy shared database architecture
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第四代语言遗留共享数据库架构
- en: The use of CRUD in fourth-generation languages is used less, but is certainly
    applicable and should be implemented by the analyst if he/she feels that the code
    is too procedural. In other words, the code architecture resembles third-generation
    as opposed to fourth-generation .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四代语言中使用CRUD的情况较少，但肯定适用，并且如果分析人员认为代码过于程序化，应该实施。换句话说，代码架构类似于第三代而不是第四代。
- en: 10.13 “Leaving As Is”—Fourth-Generation Legacy Systems
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.13 “保持不变”—第四代遗留系统
- en: The process of limiting integration to just the sharing of data is similar to
    the design architecture that I used for third-generation language systems. Indeed,
    the architecture of linking separate and distinct software systems can only be
    accomplished by sharing common data. Once again, this data can be shared either
    using a data parameter or data file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 限制集成仅限于数据共享的过程类似于我用于第三代语言系统的设计架构。实际上，将单独且不同的软件系统链接的架构只能通过共享公共数据来实现。再次强调，这些数据可以使用数据参数或数据文件共享。
- en: Because many fourth-generation language systems utilize the same architecture
    as a packaged software system (three-tier client/server using Windows NTor UNIX/LINUX),
    it is sometimes advantageous to make use of certain operating system level communication
    facilities. For example, UNIX allows applications to pass data using an operating
    system facility called a “pipe.” A pipe resembles a parameter, in that it allows
    an application to pass a message or data to another application without creating
    an actual new data structure, like a database . Furthermore, a pipe uses an access
    method called “FIFO” (first-in, first-out), which is the same access criteria
    used by parameters. FIFO also requires that once the data is read, it cannot be
    read again. The major advantage of using a pipe is that the message/data can be
    stored long after the application that created the message has terminated in memory.
    Thus, linkage of information among IoT, packaged software, and fourth-generation
    language applications can be accomplished in RAM at execution time, which is called
    “intra-application communication.” This capability reduces overhead as well as
    the need for separate modules to be designed that would just handle data communication
    as shown in Fig. [10.14](#Fig14).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig14_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig14_HTML.png)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多第四代语言系统利用与打包软件系统相同的架构（使用 Windows NT 或 UNIX/LINUX 的三层客户端/服务器），有时候利用某些操作系统级通信设施是有利的。例如，UNIX
    允许应用程序使用称为“管道”的操作系统设施传递数据。管道类似于参数，它允许一个应用程序向另一个应用程序传递消息或数据，而不创建实际的新数据结构，例如数据库。此外，管道使用一种称为“FIFO”（先进先出）的访问方法，这是参数使用的相同访问标准。FIFO
    还要求一旦数据被读取，就不能再次读取。使用管道的主要优点是消息/数据可以在创建消息的应用程序终止后长时间存储在内存中。因此，信息在 IoT、打包软件和第四代语言应用程序之间的链接可以在执行时通过
    RAM 完成，这称为“应用内通信”。这种能力减少了开销，以及设计需要处理数据通信的单独模块的需求，如图 [10.14](#Fig14) 所示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig14_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig14_HTML.png)
- en: Fig. 10.14
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14
- en: Intra-application communication using a UNIX pipe
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UNIX 管道进行应用内通信
- en: '10.14 Hybrid Methods: The Gateway Approach'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.14 混合方法：网关方法
- en: 'Thus far in this chapter I have focused on the interface between a specific
    type of legacy and IoT, blockchain and/or packaged software systems. Each type
    was defined with respect to its “generation” type. In reality, however, legacy
    systems are not that self-defined. Many large organizations have “legacy layers,”
    meaning that multiple generations exist throughout the enterprise. In this case
    , attempting to integrate each generation with a central packaged software system
    is difficult and time consuming. Indeed, migrating and integrating legacy systems
    is difficult enough. In these complex models, another method used for migration
    of legacy applications is a “hybrid” approach called “Gateway .” The gateway approach
    means that there will be a software module that mediates requests between the
    packaged software system and the legacy applications. In many ways, a gateway
    performs similar tasks as a TP system. Thus, the gateway acts as a broker between
    applications. Specifically, gateways :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我已经专注于特定类型的遗留系统与物联网、区块链和/或打包软件系统之间的接口。每种类型都是根据其“代”类型定义的。然而，在现实中，遗留系统并不是那么自我定义的。许多大型组织都有“遗留层”，这意味着整个企业存在多代。在这种情况下，试图将每一代与一个中央打包软件系统集成在一起是困难且耗时的。事实上，迁移和集成遗留系统已经足够困难了。在这些复杂的模型中，用于迁移遗留应用程序的另一种方法是一种名为“混合”的方法，称为“网关”。网关方法意味着将有一个软件模块在打包软件系统和遗留应用程序之间进行请求中介。在许多方面，网关执行类似于
    TP 系统的任务。因此，网关充当应用程序之间的代理。具体来说，网关：
- en: Separate yet integrate components from different generation languages. It allows
    for the linkages among multiple generation language systems.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同代语言的组件分离但整合在一起。它允许多个代语言系统之间的链接。
- en: Translates requests and data between multiple components.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个组件之间转换请求和数据。
- en: Coordinates between multiple components to ensure update consistency. This means
    that the gateway will ensure that redundant data elements are synchronized.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调多个组件以确保更新一致性。这意味着网关将确保冗余数据元素同步。
- en: Typical gateway architectures would be designed as shown in Fig. [10.15](#Fig15).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig15_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig15_HTML.png)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的网关架构设计如图 [10.15](#Fig15) 所示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig15_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig15_HTML.png)
- en: Fig. 10.15
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15
- en: Gateway architecture for legacy integration
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 传统集成的网关架构
- en: The most beneficial role of the gateway is that it allows for the phasing of
    legacy components. The infrastructure provides for an incremental approach to
    conversion by establishing a consistent update process for both data and applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网关最有益的作用是允许对传统组件进行分阶段处理。基础设施通过为数据和应用程序建立一致的更新流程，提供了逐步转换的方法。
- en: 10.15 Incremental Application Integration
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.15 增量应用集成
- en: A gateway establishes a transparency for graphical user interfaces (GUI), character-based
    interfaces, and automated interfaces (batch updates) to appear the same to the
    packaged software system. Hence, the gateway insulates the legacy system so that
    its interface with the packaged software systems seems seamless. This is accomplished
    through an interface that translates requests for process functions and routes
    them to their appropriate application, regardless of the generation of the software
    and its particular phase in the packaged software migration. Figure [10.16](#Fig16)
    depicts the process functions of the gateway system.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig16_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig16_HTML.png)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 网关为图形用户界面（GUI）、基于字符的界面和自动化接口（批量更新）建立了透明度，使其对打包软件系统看起来是相同的。因此，网关使传统系统与打包软件系统的接口看起来是无缝的。这通过一个接口来实现，该接口将对流程功能的请求进行转换，并将其路由到相应的应用程序，而不管软件的生成和其在打包软件迁移中的特定阶段如何。图 [10.16](#Fig16)
    描述了网关系统的流程功能。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig16_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig16_HTML.png)
- en: Fig. 10.16
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16
- en: Application functions of legacy gateway s
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 传统网关的应用功能
- en: The most salient benefit of the gateway approach is its consistency with the
    object-oriented paradigm and the concept of application reusability. Specifically,
    it allows any module to behave “like” a reusable component notwithstanding its
    technical design. Under this architectural philosophy, a particular program, let’s
    say, a third-generation language system, may eventually be replaced and placed
    into the gateway , with temporary bridges built until the overall migration is
    completed. This procedure also supports a more “global” view of the enterprise
    as opposed to just focusing on a particular subsystem. Figure [10.17](#Fig17)
    depicts the concept of process integration using the gateway architecture.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig17_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig17_HTML.png)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 网关方法最显著的好处是与面向对象范式和应用程序可重用性概念的一致性。具体来说，它允许任何模块表现出“像”可重用组件一样的行为，尽管其技术设计不同。在这种架构哲学下，一个特定的程序，比如说，一个第三代语言系统，最终可能会被替换并放入网关中，直到整体迁移完成为止会建立临时桥梁。这一过程还支持对企业的更“全局”的视图，而不仅仅关注于特定子系统。图 [10.17](#Fig17)
    描绘了使用网关架构进行流程集成的概念。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig17_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig17_HTML.png)
- en: Fig. 10.17
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17
- en: Process integration and migration using gateway architecture
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网关架构进行流程集成和迁移
- en: 10.16 Incremental Data Integration
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.16 增量数据集成
- en: Incremental data integration focuses on the challenge of keeping multiple sets
    of data coordinated throughout a packaged software system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 增量数据集成关注于如何在打包软件系统中保持多组数据的协调。
- en: The two primary issues relating to data integration focus on queries and updates.
    Queries involve the access of complete information about a dataset (collection
    of related data elements ) across multiple systems. Much of the query challenges
    can be addressed by using a data warehouse or data mining architecture. The gateway
    would serve as the infrastructure that would determine how many copies of the
    data exist and its location.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据集成相关的两个主要问题集中在查询和更新上。查询涉及跨多个系统访问有关数据集（相关数据元素的集合）的完整信息。使用数据仓库或数据挖掘架构可以解决许多查询挑战。网关将作为基础设施，确定数据的副本数量及其位置。
- en: 'The more difficult and more important concept of data integration is the ability
    of the gateway to coordinate multiple updates across databases and flat-file systems.
    This means that the changing of a data element in one component would “trigger”
    an automatic update to the other components. There are four scenarios that could
    exist regarding the different definitions of data elements :'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集成的更困难和更重要的概念是网关协调多个数据库和平面文件系统的更新能力。这意味着在一个组件中更改数据元素将“触发”对其他组件的自动更新。关于数据元素不同定义存在的四种情况：
- en: '1.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The data elements in each system have the same name. This at least allows analysts
    to identify how many copies of the element exist in the system.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个系统中的数据元素具有相同的名称。这至少允许分析员确定系统中存在多少个元素副本。
- en: '2.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The data elements do not match-up by name. This requires that the analyst design
    a “mapping” algorithm that tracks the corresponding name of each alias.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据元素名称不匹配。这要求分析员设计一个“映射”算法，跟踪每个别名的对应名称。
- en: 3.Data elements match by name but not by attribute. In this case the analyst
    must propagate updates to the data element by tracking the different attribute
    definitions it has across systems. These differences can vary dramatically. The
    most obvious is element length. If the length of the data element is shorter than
    the one that has been updated then there is the problem of field truncation. This
    means that either the beginning value of ending value of the string will be lost
    when the value is propagated to the system with the shorter length definition.
    On the other hand, if the target is longer, then the process must populate either
    the beginning or end of the string so that the element has a complete value. This
    is graphically depicted in Fig. [10.18](#Fig18).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig18_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig18_HTML.png)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.数据元素通过名称匹配，但不通过属性匹配。在这种情况下，分析员必须通过跟踪不同系统中的属性定义来传播数据元素的更新。这些差异可能会变化很大。最明显的是元素长度。如果数据元素的长度比已更新的长度短，则会出现字段截断的问题。这意味着当值传播到具有较短长度定义的系统时，字符串的起始值或结束值将丢失。另一方面，如果目标长度较长，则进程必须填充字符串的开头或结尾，以便元素具有完整的值。这在图 [10.18](#Fig18)中以图形方式表示。![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig18_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig18_HTML.png)
- en: Fig. 10.18
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.18
- en: Propagating data elements with different field lengths
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传播具有不同字段长度的数据元素
- en: Furthermore, the same data element might have different data types, meaning
    that one is alphanumeric and the other numeric. In this case , analysts need to
    know that certain values (e.g., a leading zero) will not be stored in the same
    way depending on its data type classification.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，相同的数据元素可能具有不同的数据类型，这意味着一个是字母数字，另一个是数字。在这种情况下，分析员需要知道某些值（例如，前导零）将根据其数据类型分类方式存储不同。
- en: 4.There is not a one-to-one relationship among data elements . This suggests
    that a data element in one system may be based on the results of a calculation
    (a derived data element ). This would require a more in-depth analysis and mapping
    often solved by creating a stored-procedure that replicates the business rule
    to calculate the data element’s value. So in this case there might be simple copies
    of the element moved from one system to another, as well as one data element value
    that needs to first be calculated and then propagated across multiple systems.
    For example, if the data element “Total-Amount” is entered in one system but calculated
    as Quantity times Price in another, the propagation of the values is very complex.
    First, the analyst must know whether the calculated value is performed first before
    the resultant value, in this case , Total-Amount is reentered in another system.
    If this is true, then the propagation is much easier; once the calculation is
    made then the result is copied to the “entered” element. The converse is much
    more complex. If the Total-Amount was entered, but the values of Quantity and
    Price were not, then it would be very difficult to propagate until both Quantity
    and Price were entered. The example is further complicated if adjustments are
    made to the Quantity, Price, or Total-Amount. For any change, the systems would
    need to automatically be “triggered” to recalculate the values to ensure they
    are in synchronization. Figure [10.19](#Fig19) graphically shows this process
    .![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig19_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig19_HTML.png)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fig. 10.19
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Propagation of calculated data elements
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 10.17 Converting Legacy Character-Based Screens
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be naïve to assume that most legacy systems do not have character-based
    screens. Character-based screens are those that do not make use of the GUI . While
    most character-based screens in existence emanate from third-generation language
    mainframe implementations there are also many early fourth-generation language
    systems that preceded the GUI paradigm. Unfortunately, character-based screens
    often do not map easily to its GUI counterparts. The analyst must be especially
    careful not to attempt to simply duplicate the screens in the legacy software.
    Figure [10.20](#Fig20) shows a typical character-based legacy screen. Note that
    there can be up to four Contract/PO’s as shown in the upper right-hand corner.
    The user is required to enter each Contract/PO on a separate screen.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig20_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig20_HTML.png)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.20
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Character-based user screen
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the replacement GUI screen in Fig. [10.21](#Fig21) takes
    advantage of the view bar that allows for scrolling in a window. Therefore, the
    GUI version requires only one physical screen, as opposed to four.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig21_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig21_HTML.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.21
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Transformed character-based to GUI screen
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 10.18 The Challenge with Encoded Legacy Screen Values
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most legacy character-based screens, a common practice was used to create
    codes that represented another, more meaningful data value. For example, numeric
    codes (1, 2, 3, 4, etc.) might be used to represent product colors such as blue,
    green, dark red, etc. Legacy applications used codes because they reduced the
    number of characters needed to type in the value on a screen. The technology to
    implement common GUI features such as drop-down menus and pop-up windows were
    not available. Indeed, many people used codes just from habit, or had to use them
    in order to implement computer systems. When transitioning to a GUI system, especially
    on the Web, it is wise to phase-out any data elements that are in an encoded form
    unless the codes are user-defined and are meaningful within the industry or business
    area. This essentially means that certain codes, like State (NY, CT, CA, etc.)
    are industry standards that are required by the business, as opposed to those
    created to aid in the implementation of software—like color codes. In the later
    case , the color name itself is unique and would be stored in an entity with just
    its descriptive name, as opposed to a code, which then identifies the actual description.
    Figure [10.22](#Fig22) shows the character-based and GUI screen transition.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig22_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig22_HTML.png)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.22
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Encoded value GUI screen transition
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Changing character-based screens that contain encoded values has a trickle-down
    effect on the data dictionary and then on logic data modeling . First, the elimination
    of a coded value inevitably deletes a data element from the data dictionary. Second,
    codes are often key attributes, which become primary keys of entities. The elimination
    of the code, therefore, will eliminate the primary key of the entity . The new
    primary-key will likely be the element name. These changes must then be made to
    the entity relational diagram (ERD) and placed in production (see Fig. [10.23](#Fig23)).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig23_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig23_HTML.png)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.23
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Transition to encoded databases
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Third, the elimination of codes affects previous stored-procedures that use
    queries against the coded vales. Therefore, analysts must be sure to reengineer
    all queries that use the codes. This transition will add tremendous value since
    encoded elements typically add unnecessary overhead and time delays to queries.
    Finally, the elimination of encoded values will free up considerable space and
    index overhead. This will result in an increase in performance of the legacy system
    .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 10.19 Legacy Migration Methodology
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, all legacy systems inevitably must reach the end of their
    original life cycle. Therefore, notwithstanding whether certain components will
    remain “as is” or enhanced, eventually IT management must plan for migration to
    another system. The issue that this section addresses is how to establish a migration
    life cycle that takes into consideration an incremental approach to replacement
    of various legacy components within an enterprise computer system. The previous
    sections provided a framework of what can be done with legacy systems and their
    integration with other systems. This section provides a step-by-step template
    of procedures to follow that can assist the analysts on the schedule of legacy
    migration including temporary and permanent integration. This approach is an incremental
    one, so analysts can use it as a checklist of the progression they have made in
    the legacy migration life cycle. In all there are 12 steps as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze the existing legacy systems .
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompose legacy systems to determine schedules of migration and linkage strategies.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design “As Is” links.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design legacy enhancements.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design legacy replacements.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and integrate new databases .
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine new infrastructure and environment, including gateways .
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement enhancements.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement links.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate legacy databases .
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '11.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate replacement legacy applications.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '12.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incrementally cutover to new systems.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above steps are graphically depicted in Fig. [10.24](#Fig24).![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig24_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig24_HTML.png)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.24
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Legacy migration life cycle
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are two streams of steps, that is, steps 3–5 and 8–10 that
    can occur in parallel. These steps encompass the three types of legacy migration
    choices that can be made: replacement, enhancement, and “as is.” While this life
    cycle seems simple, in reality it is a significant challenge for most migrations
    to plan, manage, and modify these steps and their interactions. Indeed, creating
    a migration plan and adequately coordinating the incremental and parallel steps
    is a difficult project. The subsequent sections will provide more details for
    each of these 12 steps.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Analyze the Existing Legacy Systems'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is obviously important that analysts fully understand all of the existing
    legacy components that exist in the system. The objective is to provide the requirements
    of each system and how it relates to the system. Analysts must remember that little
    to no documentation will be available to fully represent the architecture of the
    legacy system . However, analysts should compile as much information that is available
    including but not limited to:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，分析人员完全理解系统中存在的所有现有遗留组件非常重要。目标是提供每个系统的要求以及它与系统的关系。分析人员必须记住，几乎没有文档可用于充分表示遗留系统的架构。然而，分析人员应尽可能收集尽可能多的信息，包括但不限于：
- en: User and programming documentation
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和编程文档
- en: Existing users, software developers and managers
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有用户、软件开发人员和管理人员
- en: Required inputs and outputs and known services of the legacy system
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗留系统的所需输入和输出以及已知服务
- en: Any historical perspective on the history of the system itself.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于系统本身历史的任何历史视角。
- en: Regardless of what existing information and documentation is available, certain
    aspects of reverse engineering must be used. Various CASE (Computer Aided Software
    Engineering) tools should be used that allows analysts to create a repository
    of data and certain levels of code analysis, particularly for third-generation
    language migrations. The analyst should create DFDs and PFDs for process analysis,
    and logic data modeling (LDM) and entity relational diagramming (ERD) for representation
    of the data. The analyst should also determine which legacy components are decomposable
    and non-decomposable. Inevitably, regardless of whether the decision is to replace
    immediately, enhance, or leave “as is,” ultimately little of the existing code
    will survive the ultimate migration of a legacy system (Brodie and Stonebraker
    [1995](#CR1)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 无论现有信息和文档如何，都必须使用逆向工程的某些方面。应该使用各种 CASE（计算机辅助软件工程）工具，允许分析人员创建数据存储库和某些级别的代码分析，特别是针对第三代语言迁移。分析人员应为过程分析创建
    DFDs 和 PFDs，为数据表示创建逻辑数据建模（LDM）和实体关系图（ERD）。分析人员还应确定哪些遗留组件是可分解的，哪些是不可分解的。无论最终决定是立即替换、增强还是保持“原样”，最终遗留系统的迁移将使现有代码几乎无一幸免（Brodie
    和 Stonebraker [1995](#CR1)）。
- en: 'Step 2: Decompose Legacy Systems to Determine Schedules of Migration and Linkage
    Strategies'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步：分解遗留系统以确定迁移时间表和链接策略
- en: The gradual migration of legacy systems is easiest accomplished when analysts
    utilize decomposition engineering. Previous chapters have outlined the process
    of functional decomposition , which is based on the breaking down of a system
    into its functional components. Decomposition , which results in components also
    allows for reusability of code. Since the fundamental premises of a package system
    are reusability, the process of decomposition is a mandatory part of the life
    cycle of any legacy migration. Thus, analysts should decompose all DFDs to functional
    primitives . Process analysis continues with the writing of process specifications
    for each functional primitive . These functional primitives will either be rewritten
    from the existing code or documentation or recreated from analyzing the functionality
    of the program. Analysts need to remove all dependency logic that links modules
    from the legacy code because it represents coupling among the programs. Module
    dependencies can typically be identified by finding *procedure calls* from within
    the legacy code. Ultimately, each of these process specifications will become
    methods. Eventually all methods will be mapped to classes and identify the attributes
    that each class needs. While this sounds simple, there will be a number of processes
    for which decomposition will be problematic. This will typically occur for legacy
    code that is too eclectic and needs to simply be reengineered. In these cases
    , analysts may want to interview users to understand the functionality that is
    required, as opposed to relying solely on the written legacy code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: From a data perspective, entity relational diagrams (ERD) need to undergo normalization
    . Remember that the DD and ERD produced in Step 1 is a mirror of the existing
    system, which most likely will not be in third-normal form. Thus this step will
    result in the propagation of new entities and even new data elements . Furthermore,
    data redundancies will be discovered as well as derived elements that should be
    removed from the logic model. However, while these steps are taking place, analysts
    need to be cognizant that the process of normalization represents the total new
    blueprint of how the data should have been originally engineered. The actual removal
    of elements or reconstruction of the physical database needs to be a phased-plan
    in accordance with the overall legacy migration effort. Thus Step 2 provides the
    decomposed framework, but not the schedule of implementation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Finally, analysts must always be aware of the challenges of decomposition ,
    particularly over-decomposition , meaning that too many classes have been formed
    that will ultimately hurt system performance. There needs to be a mix of decomposed
    levels, which will serve as the basis of the new migration architecture.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Design “As Is” Links'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This step involves determining and designing what components will remain untouched
    except for linkages that are necessary with other package software components.
    These modules are determined not to be part of the initial migration plans; however,
    they need to function *within* the packaged software system infrastructure and
    are therefore part of its architecture. Part of the decision needs to include
    how data will be migrated into the packaged software framework. In most cases
    , “as is” components continue to use their legacy data sources. Consideration
    must be given to how legacy data will be communicated to other components in the
    packaged software system. Analysts need to consider either a parameter-based communication
    system, or a centrally shared database repository as outlined earlier.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Design Legacy Enhancements'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This step determines which modules will be enhanced. BPR (business process reengineering
    ) will be used to design new features and functions in each business area. Analysts
    should identify essential components and determine what changes need to be employed
    to make the existing system behave more like an object-oriented system. Common
    processes and databases also need to be mapped so that shared resources can be
    designed between legacy and packaged software systems. New linkages will also
    be needed and the analyst must determine whether to use parameters or databases
    , or both to implement the communication among application systems.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: User screens may also need to be updated as necessary, especially to remove
    encoded values or moving certain character-based screens to GUI. Many of the enhancements
    to a legacy application are implemented based on the analysis performed in Step
    1\. Any modifications will need to eventually operate on newer platforms once
    the total migration of legacy systems is completed. Analysts need to be cognizant
    that additional requirements mean increasing risk, which should be avoided when
    possible. However, during enhancement consideration it is almost impossible to
    ignore new requirements. Therefore, analysts need to focus on risk assessment
    as part of the life cycle of legacy migration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Design Legacy Replacements.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analysts must focus on how to reconstruct logic in a later generation of software
    architecture. Therefore, it is important to understand the differences in generation
    language design. This chapter provided two types of legacy software systems: third-
    and fourth-generation languages. Third-generation languages were depicted as being
    more procedural and more difficult to convert.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Analysts must design the target applications so they will operate in accordance
    with the business rules and processes that will be supported in the new systems
    environment. Because of this integration, most replacement legacy migrations require
    significant reengineering activities. These activities necessitate the inclusion
    of new business rules that may have evolved since the legacy system was placed
    in production. Furthermore, new business rules can be created simply by the requirement
    of being an packaged software system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Another important component of legacy migration is screen design. When replacing
    legacy systems , analysts must view the migration as assimilation, that is, the
    old system is becoming part of the new one. As a result, all existing packaged
    software screens need to be reviewed so that designers can determine whether they
    need to be modified to adopt some of the legacy functionality. This is not to
    suggest that all of the legacy systems screens will be absorbed into the existing
    packaged software system. Rather, there will be a combination of new and absorbed
    functionality added to the target environment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Design and Integrate New Databases'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From an enterprise perspective, analysts must gather all of the permutations
    of legacy systems that exist and seek to provide a plan on how to integrate the
    data into one source. For “as is” solutions, legacy data files will most likely
    remain separate from the packaged software system until the complete legacy is
    migrated. However, the process of enhancing and replacing legacy data should have
    the objective of creating one central database source that will serve the entire
    packaged software enterprise system. Indeed, a central data source reduces data
    redundancy and significantly increases data integrity .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The process of data integration can only be accomplished by “combining user
    views” which is the process of matching up the multiple data element definitions
    that overlap and identifying data redundancies and alternative definitions. This
    can only be completed by creating a repository of data elements and by representing
    the data graphically using an ERD. Once each system is represented in this fashion
    then the analyst must perform logic data modeling as prescribed in Chap. [9](480347_1_En_9_Chapter.xhtml).
    The result will be the creation of one central database system cluster that can
    provide the type of integration necessary for successful packaged software implementations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: While this is the goal for all analysts, the road to successful implementation
    is challenging. First, the process of normalization will require that some data
    elements be deleted (e.g., encoded values) while others will need to be added.
    Second, full data integration cannot be attained until all replacement screens
    are complete. Third, applications must be redesigned so that the centrality of
    the data source is assumed to exist. Since this process may be very time-consuming,
    it may not be feasible to attempt a full database migration at one time. Therefore,
    the legacy data may need to be logically partitioned to facilitate incremental
    database migration. Thus, there will be legacy data subsets that are created to
    remain independent of the central database until some later migration phase is
    deemed feasible. Of course, this strategy requires the design of temporary “bridges”
    that allows the entire packaged software system to appear cohesive to users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor in planning data migration is to determine how much
    is really known about the legacy data itself. The less knowledge available, the
    longer the period where legacy data and packaged software data need to run separately
    and in parallel.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: Determine New Infrastructure and Environment, including Gateway s'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to the migration of any system, the necessary hardware and software infrastructure
    must be planned and installed. A common error in legacy migration is not factoring
    the time and effort to provide this infrastructure. Furthermore, this process
    , which may create a new network environment, needs to determine the placement
    of software in a three-tier client/server platform. This means that further decomposition
    may be required of all processes , especially object classes . You may recall
    in Chap. [8](480347_1_En_8_Chapter.xhtml) that classes may undergo further decomposition
    depending on the need to distribute application across the network.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor is performance. In many instances it is difficult for
    network engineers to predict performance in large application system environments.
    It may be necessary to plan for several benchmarks in performance early in the
    design phase. Benchmarking is the process of setting up an environment that replicates
    a production network so that modifications can be made, if necessary, to the design
    of the system to increase performance.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Another decision that must be made at this juncture is whether a gateway infrastructure
    will be created to mediate legacy layers. This decision, of course is highly dependent
    on the migration life cycle; the more legacy layers that will be phased in over
    time, the higher the chances that a gateway processor for data and applications
    will be necessary. The decision to go with a gateway is significant, not only
    from the perspective of software design, but network infrastructure as well. Constructing
    a gateway can be very costly. It involves writing the system from scratch or tailoring
    a commercial product to meet the migration requirements. It is also costly because
    of the amount of additional hardware necessary to optimize the performance of
    the gateway servers. However, the benefits of a gateway are real, as it could
    provide a dependable structure to slowly migrate all components in the new systems
    environment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 8: Implement Enhancements'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This step requires a schedule of when legacy enhancements will be implemented
    and become part of the production system. Many analysts suggest that the simplest
    modules go into production first so that any unexpected problems can be dealt
    with quickly and efficiently. Furthermore, simple modules tend to have small consequences
    should there be a problem in processing or performance. There are some other aspects
    of coordination, however. For example enhancements that feed off of the same data
    or use the same subsystems should obviously be implemented at one time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Another factor in the decision of which enhanced components go first relates
    to the affects it has on other subsystems. This means that the priority may indeed
    be influenced by what other systems need or are dependent upon from other systems.
    Another issue could be the nature of the legacy links. Should a link be very complex
    or dependent on other subsystem enhancements, its schedule could be affected.
    Finally, the nature of the enhancements has much to do with the decision as opposed
    to just the application’s complexity. There may be simple enhancements that are
    crucial for the packaged software system and vice versa.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 9: Implement Links'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I alluded to in Step 8, the determination of legacy links greatly affects
    the scheduling of the migration cycle. Once the determination is made in Step
    8, the related legacy links must be put in place. This could also mean that the
    gateway , if designed, must also be in operation since many links might be filtered
    through the gateway infrastructure. So, the implementation of legacy links relates
    to both hardware and software. Notwithstanding whether a gateway is in place,
    database links often require separate servers. In many cases because these “servers”
    interface with the internet , there is a need to install firewalls to ensure security
    protection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: From a software perspective, legacy links can almost be treated like conversion
    programs. There needs to be substantial testing done to ensure they work properly.
    Once legacy links are in production, like data conversions, they tend to keep
    working. It is also important to ensure that legacy links are documented. Indeed,
    any link will eventually be changed based on the incremental migration schedule.
    Remember that most legacy links are accomplished by building temporary “bridges.”
    The concept of temporary can be dangerous, in that many of these links, over time,
    tend to be more permanent. That is, their temporary life can sometimes extend
    beyond the predicted life of a permanent component. The message here should be
    that legacy links, while they are a temporary solution, should be designed under
    the same intensity and adherence to quality as any other software development
    component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 10: Migrate Legacy Databases'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The migration of data is so complex that it should be handled as a separate
    and distinct step in the migration life cycle. Data affects everything in the
    system, and often if it is not migrated properly it can cause immense problems.
    First, the analyst must decide on the phasing of data based on the schedule of
    application migration. Hopefully, the process of data migration should be done
    in parallel to Steps 8 and 9.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The most challenging aspect of data migration is the physical steps in the process
    . Migrating new entities and schema changes are complex. For example, changes
    to databases require that the tables be “dropped” meaning that they are taken
    off-line. Data dictionaries need to be updated, and changes to stored procedures
    and triggers are extremely time-consuming. Most problematic is the process f quality
    assurance . While some testing can be done in a controlled environment, most of
    the final testing must be done once the system is actually in production. Therefore,
    the coordination with users to test the system early is critical. Furthermore,
    there must be back-up procedures in case the database migration does not work
    properly. This means that there is an alternate fail-safe plan to reinstall the
    old system should major problems arise. Finally, a programming team should be
    ready to deal with any problems that arise that do not warrant reinstalling the
    old version. This might include the discovery of application “bugs” that can be
    fixed within a reasonable period and are not deemed critical to operations (which
    means there is usually a “work-around” for the problem). Analysts must understand
    that this process must be followed each time a new database migration takes place!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Database migration is even more complex when there is a gateway . The reason
    is that the gateway , from an incremental perspective, contains more and more
    database responsibilities each time there is a migration. Therefore, for every
    migration, the amount of data that can be potentially affected grows larger. In
    addition, the number of data that becomes integrated usually grows exponentially,
    so the planning and conversion process becomes a critical path to successful migration
    life cycles. Since the migration of legacy databases becomes so much more difficult
    as the project progresses, the end of the life cycle becomes even more challenging
    to reach. That is why many migrations have never been completed!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 11: Migrate Replacement Legacy Applications'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the database migration is completed, then the remainder of the legacy applications
    can be migrated to the new system. These applications are usually the replacement
    components, which have been reengineered in the object-oriented paradigm. These
    programs, then, have been designed to operate against the target databases with
    the new functionality required for the packaged software system. Since replacement
    applications usually do not create links, there is typically little effect on
    gateway operations. What is more challenging is the quality assurance process
    . Users need to be aware that the code is relatively new and will contain problems
    regardless of the amount of pre-production testing that has been performed. In
    any event, programmers, database administrators, and quality assurance personnel
    should be on-call for weeks after system cutover.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 12: Incrementally Cutover to New Systems'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As discussed above, testing and application turnover are two areas that frequently
    are overlooked. Because projects typically run over budget and schedule, the final
    procedures like testing and verification are usually shortened. The results of
    this decision can be devastating to successful legacy migrations. Because of the
    size and complexity of many packaged software systems, to go “cold turkey” is
    unrealistic and irresponsible. Therefore, an analyst should consider providing
    test scenarios that provide more confidence that the system is ready to be cutover.
    This approach is called “acceptance testing” and requires that users be involved
    in the determination of what tests must be performed before the system is ready
    to go live. Thus, acceptance test plans can be defined as the set of tests that
    if passed will establish that the software can be used in production. Acceptance
    tests need to be established early in the product life cycle and should begin
    during the analysis phase. It is only logical then that the development of acceptance
    test plans should involve analysts. As with requirements development, the analyst
    must participate with the user community. Only users can make the final decision
    about the content and scope of the test plans. The design and development of acceptance
    test plans should not be confused with the testing phase of the software development
    life cycle.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Another perspective on acceptance testing is that it becomes a formal checklist
    that defines the minimal criteria for incrementally migrating systems. However,
    one must work with the understanding that no new product will ever be fault-free.
    The permutations of testing everything would make the timetable for completion
    unacceptable and cost prohibitive. Therefore, the acceptance test plan is a strategy
    to get the most important components tested completely enough for production.
    Figure [10.25](#Fig25) represents a sample acceptance test plan.![../images/480347_1_En_10_Chapter/480347_1_En_10_Fig25_HTML.png](../images/480347_1_En_10_Chapter/480347_1_En_10_Fig25_HTML.png)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10.25
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance test plan
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 10.20 Problems and Exercises
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Legacy? Explain.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the Five generation languages. What increases with each generation?
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Essential Components?
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Object-Oriented paradigm mean?
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Object Orientation relate to Business Area Analysis?
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Legacy Link?
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the notion of Logic Reconstruction.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a UNIX pipe?
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how Legacy Integration operates through Gateway Architecture.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Propagation?
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '11.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the essential differences between character-based screens and GUI?
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '12.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an encoded value?
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '13.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the relationship between an object and an API?
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '14.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the restrictions of CRUD in blockchain architecture? Why is this difference
    so important in a ledger-based system?
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
