- en: Solidity smart contract supports calling another smart contract. If two
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity智能合约支持调用另一个智能合约。如果两个
- en: smart contracts call each other’s function, there is a possibility that the
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约调用彼此的函数，有可能会导致
- en: call might enter into a loop and consume all the funds as shown in the
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 调用可能会进入一个循环，并消耗所有资金，如所示
- en: 'following example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例：
- en: '// security_callee.sol:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`// security_callee.sol:`'
- en: '*pragma solidity 0.8.0;*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity 0.8.0;`'
- en: '*contract Bob {*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract Bob {`'
- en: '*function ping(address c) public{*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`function ping(address c) public{`'
- en: '*//do something*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`//做些什么`'
- en: '*return;*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '*}*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '279'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '279'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 用Solidity编程智能合约
- en: '*contract Mallory {*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract Mallory {`'
- en: '*fallback() external{*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`fallback() external{`'
- en: '*Bob(msg.sender).ping(address(this));*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bob(msg.sender).ping(address(this));`'
- en: '*}*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: // security_caller.sol
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`// security_caller.sol`'
- en: '*contract Bob {*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract Bob {`'
- en: '*bool sent = false;*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool sent = false;`'
- en: '*function ping(address c) external {*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`function ping(address c) external {`'
- en: '*if (!sent) {*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (!sent) {`'
- en: '*c.call{value:2}("");*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`c.call{value:2}("");`'
- en: '*sent = true;*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sent = true;`'
- en: '*}}}*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`}}}`'
- en: The preceding example shows that a cross smart contract call might
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子显示了一个跨智能合约调用可能会
- en: enter into a loop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个循环。
- en: In this example, security_callee.sol and security_caller.sol are both
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，security_callee.sol和security_caller.sol都是
- en: deployed to the blockchain. The contract Bob in security_caller.sol invokes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到区块链上。在security_caller.sol中的Bob合约调用了
- en: a function called ping and an input from an external program. The ping
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为ping的函数和一个来自外部程序的输入。ping
- en: function then calls another smart contract with the Mallory contract
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用另一个智能合约，与Mallory合约一起
- en: address. Mallory contract has a fallback function that will take in the ping
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: address。Mallory合约有一个回退函数，将接收ping
- en: function call from Bob contract. In Mallory contract, the Bob contract is
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Bob合约的函数调用。在Mallory合约中，Bob合约是
- en: also called, hence causing a loop where Bob calls the fallback function in
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为，因此导致了一个循环，在这个循环中Bob调用了回退函数在
- en: Mallory while Mallory calls Bob’s ping function. Each step in the call will
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Mallory同时Mallory调用Bob的ping函数。每一步调用都会
- en: cause a value of 2 wei to be sent to the Mallory contract.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 导致2个 Wei 的值被发送到Mallory合约。
- en: '**Data Type and Data Vulnerabilities**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型和数据漏洞**'
- en: '**Vulnerability: Variable Value Overflow or Underflow**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：变量值溢出或下溢**'
- en: This happens when arithmetic operations cause the new value of a
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当算术运算导致一个变量的新的值时
- en: variable to exceed the maximum value or fall below the minimum value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量超过最大值或降至最小值。
- en: '280'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '280'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 用Solidity编程智能合约
- en: uint256 const PRICE_PER_TOKEN = 2;
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: uint256 const PRICE_PER_TOKEN = 2;
- en: function
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: function
- en: buy(uint256 numTokens) public payable {
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`buy(uint256 numTokens) public payable {`'
- en: require(msg.value == numTokens * PRICE_PER_TOKEN);
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`require(msg.value == numTokens * PRICE_PER_TOKEN);`'
- en: balanceOf[msg.sender] += numTokens;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: balanceOf[msg.sender] += numTokens;
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: To fix this vulnerability, check the value range. If possible, use the
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个漏洞，检查值范围。如果可能的话，使用
- en: SafeMath library in which the boundaries of arithmetic operations are
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在SafeMath库中，算术运算的边界被
- en: checked.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查。
- en: '**Vulnerability: Shadowing State Variables**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：遮蔽状态变量**'
- en: For a smart contract, there are state variables and function-specific
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于智能合约，有状态变量和特定于函数的
- en: variables. The state variables can be referred to in each function as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。状态变量可以在每个函数中引用。
- en: If a variable name is defined as both state variable and function variable,
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量名被定义为状态变量和函数变量，
- en: then the one defined in the function will have priority and shadow the one
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义在函数中的那个将优先并遮蔽那个
- en: defined as state variable. Therefore, it is important to check the context
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为状态变量。因此，检查上下文
- en: and scope of the variables in a function. The following smart contract
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中变量的作用域。以下智能合约
- en: 'shows how state variables are shadowed in the functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了状态变量如何在函数中被遮蔽：
- en: '*pragma solidity 0.8.0;*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity 0.8.0;`'
- en: '*contract ShadowingVariables {*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract ShadowingVariables {`'
- en: '*uint n = 2;*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint n = 2;`'
- en: '*address public x = 0x1f2D3A67B8E96039bbAc84eB4bC0913C0c16778c;*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`address public x = 0x1f2D3A67B8E96039bbAc84eB4bC0913C0c16778c;`'
- en: '*function test_shadow1() public view returns (uint n) {*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`function test_shadow1() public view returns (uint n) {`'
- en: '*return n; // Will return 0*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`return n; // 将返回0`'
- en: '*}*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*function test_shadow2() public view returns (address x) {*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`function test_shadow2() public view returns (address x) {`'
- en: '281'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '281'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 用Solidity编程智能合约
- en: '*address x = 0x1111111111111111111111111111111111111111;*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`address x = 0x1111111111111111111111111111111111111111;`'
- en: '*return x; // Will return*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`return x; // 将返回`'
- en: '*0x1111111111111111111111111111111111111111;*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x1111111111111111111111111111111111111111;`'
- en: '*}*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*function test_shadow3() public view returns*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`function test_shadow3() public view returns`'
- en: '*(address x) {*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`(address x) {`'
- en: '*return x; // Will return*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`return x; // 将返回`'
- en: '*0x0000000000000000000000000000000000000000*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x0000000000000000000000000000000000000000;`'
- en: '*}*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: In the smart contract, state variables of uint n and address x are
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约中，uint n 和 address x 的状态变量是
- en: declared. The test_shadow1 function declared n as a return variable. It will
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的同一个变量名。测试_shadow1 函数将 n 声明为返回变量。它将
- en: return 0, and it is not assigned value and will take default 0\.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0，并且没有赋值，将采用默认的 0。
- en: The second function, test_shadow2, redefine address x and assigns a
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数 test_shadow2 重新定义了地址 x 并赋值为
- en: new address 0x1111111111111111111111111111111111111111 and will
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 新的地址 0x1111111111111111111111111111111111111111 并将
- en: return this address.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 返回这个地址。
- en: The third function, test_shadow3, redeclared address x but does not
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数 test_shadow3 重新声明了地址 x 但没有
- en: assign the address value. It will therefore return the default address value
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值地址值。因此它将返回默认地址值
- en: of 0x0000000000000000000000000000000000000000\.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为 0x0000000000000000000000000000000000000000。
- en: It is very important to look at the same variable names appearing in
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要关注在
- en: different contexts and make sure correct values are associated with the
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的上下文，并确保正确地与值相关联
- en: variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。
- en: '**Vulnerability: Authorization Through tx.origin**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：通过 tx.origin 进行授权**'
- en: Solidity smart contracts can use tx.origin as a global variable to refer to
    the
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 智能合约可以使用 `tx.origin` 作为全局变量来指代
- en: original sender of the transaction. Since a user or a smart contract can call
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的原始发送者。由于一个用户或一个智能合约可以调用
- en: a smart contract function that might be malicious, it is not a good practice
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能恶意的一个智能合约函数，这不是一个好的做法
- en: to use tx.origin for authentication. Instead, msg.sender should be used for
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `tx.origin` 进行认证。相反，应该使用 `msg.sender` 进行
- en: authentication as this is always the true address of the smart contract that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 认证，因为这是始终是智能合约的真实地址
- en: '282'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '282'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章用 Solidity 编程智能合约
- en: calls another smart contract. For example, in the following programming,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 调用另一个智能合约。例如，在以下编程中，
- en: tx.origin is used to check if the sender is the owner of the smart contract.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx.origin` 用于检查发送者是否为智能合约的所有者。'
- en: This might have vulnerability as the tx.origin account might call a
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能存在漏洞，因为 `tx.origin` 账户可能会调用
- en: malicious smart contract and then call this sendTo function to bypass the
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意智能合约，然后调用这个 sendTo 函数来绕过
- en: required check to send the fund to a receiver specified by the hacker.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 进行必要的检查，将资金发送给黑客指定的接收者。
- en: '*pragma solidity 0.4.24;*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity 0.4.24;`'
- en: '*contract MyContract {*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract MyContract {`'
- en: '*address owner;*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`address owner;`'
- en: '*function MyContract() public {*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`function MyContract() public {`'
- en: '*owner = msg.sender;*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner = msg.sender;`'
- en: '*}*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*function sendTo(address receiver, uint amount) public {*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`function sendTo(address receiver, uint amount) public {`'
- en: '*require(tx.origin == owner); // This should be changed*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`require(tx.origin == owner); // 这应该被修改`'
- en: '*to tx.sender*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`to tx.sender`'
- en: '*receiver.transfer(amount);*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiver.transfer(amount);`'
- en: '*}*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '**Vulnerability: Using Block Values to Represent Time**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：使用块值表示时间**'
- en: Some smart contracts will need to handle operations such as asset locking
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些智能合约需要处理诸如资产锁定
- en: or release that has dependency on time. Solidity has some special global
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或发布具有时间依赖性的合约。Solidity 有一些特殊的全局
- en: variables such as block.timestamp and block.number that can be used
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用诸如块时间戳的变量
- en: to represent or infer elapsed time. However, since the block mining is
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 来表示或推导出经过的时间。然而，由于区块挖掘是不
- en: not accurate and can be manipulated by miners, it is not recommended
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不准确并且可以被矿工操纵，因此不推荐
- en: to use the block parameters as time stamps for functions that have time
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用块参数作为具有时间
- en: dependencies. Sometimes, it would be good to use time information from
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系。有时，使用来自
- en: an Oracle implementation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Oracle 实现。
- en: '283'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '283'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章用 Solidity 编程智能合约
- en: '**Vulnerability: Writing to Arbitrary Storage Locations**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：向任意存储位置写入**'
- en: Ethereum EVM stores data in persistent locations for each account
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum EVM 为每个账户存储在持久的位置中的数据
- en: or smart contract address. It is important to protect the data storage
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者智能合约地址。保护数据存储非常重要
- en: location from malicious overwrites. Although Solidity does not support
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 防止恶意覆盖。尽管 Solidity 不支持
- en: location pointers, there is still a possibility for writing data to wrong
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 位置指针，仍然有可能将数据写入错误
- en: addresses. For example, in a dynamic array, if the array length is not
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。例如，在动态数组中，如果数组长度不是
- en: set properly, the out-of-bound index will not be detected and cause the
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确，越界索引将不会被检测到并导致
- en: out-of-bound write to be valid. For example, in the following example,
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使任意写入有效。例如，在以下示例中，
- en: a dynamic length array bonusRecord is defined. The PopBonus
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态长度数组 bonusRecord 被定义。PopBonus
- en: function pops up one item at a time and decrements the length of the
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数一次弹出一个项目，并递减数组的长度
- en: bonusRecord array. However, since “require(0 <= bonusRecord.length)”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: bonusRecord 数组。然而，由于“require(0 <= bonusRecord.length)”
- en: does not block length in 0 case, the next line of code “bonusRecord.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不阻止长度为0的情况，下一行代码“bonusRecord.
- en: length--” will cause an underflow, making the bonusRecord length to be
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: length--” 将导致下溢，使得 bonusRecord 长度变为
- en: '11579208923731619542357098500868790785326998466564'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '11579208923731619542357098500868790785326998466564'
- en: 0564039457584007913129639935\.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 0564039457584007913129639935\.
- en: And since the array length is so large, the array index can be any
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组长度如此之大，数组索引可以是任何
- en: 'number, and the value can be written to arbitrary storage locations:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 数字，并且可以将值写入任意的存储位置：
- en: uint[] private bonusRecord;
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: uint[] 私有 bonusRecord;
- en: address private owner;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 地址私有 owner;
- en: function PushBonus(uint c) public {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 PushBonus(uint c) 公开
- en: bonusRecord.push(c);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: bonusRecord.push(c);
- en: '}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: function PopBonus() public {
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 PopBonus() 公开
- en: require(0 <= bonusRecord.length);
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: require(0 <= bonusRecord.length);
- en: // This is a bug. Once the length is zero, it should
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: // 这是一个错误。一旦长度为零，它应该
- en: not allow the PopBonus operation
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许PopBonus操作
- en: bonusRecord.length--;
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: bonusRecord.length--;
- en: '}'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '284'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '284'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: function UpdateBonusRecordAt(uint idx, uint c) public
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 UpdateBonusRecordAt(uint idx, uint c) 公开
- en: returns (uint){
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 (uint){
- en: require(idx < bonusRecord.length);
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: require(idx < bonusRecord.length);
- en: bonusRecord[idx] = c;
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: bonusRecord[idx] = c;
- en: return bonusRecord.length;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 bonusRecord.length;
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: To fix the preceding arbitrary write issue, simply change “require(0 <=
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前面的任意写入问题，只需将“require(0 <=
- en: bonusRecord.length)” to “require(0 < bonusRecord.length)”.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: bonusRecord.length)”更改为“require(0 < bonusRecord.length)”。
- en: '**Vulnerability: Unused Variables**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：未使用的变量**'
- en: It is quite common for developers to have variables declared but not used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常声明变量但未使用是相当常见的。
- en: In Solidity, all computations and storage consume gas for the transactions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，所有计算和存储交易都会消耗燃料。
- en: Therefore, it is best practice to remove all functions and variables that are
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最佳实践是删除所有未使用的函数和变量
- en: defined but not used for the deployed smart contracts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定义但未在部署的智能合约中使用。
- en: '**Compiler Vulnerabilities**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器漏洞**'
- en: '**Outdated Compilers**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**过时的编译器**'
- en: Compiler version compatibility is a complex issue. Solidity allows a
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器版本兼容性是一个复杂的问题。Solidity允许一个
- en: smart contract to be declared as applied to a single version of compiler,
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约应声明适用于编译器的单个版本，
- en: or a range of compilers. Although it is recommended to use the latest
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或一系列编译器。尽管建议使用最新
- en: compilers, there is a challenge of compatibility with older versions of
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器，挑战在于与旧版本的
- en: libraries. Sometimes, libraries were written by third parties, or in the
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 库。有时，库是由第三方编写的，或者在
- en: public domain, rewriting them to the latest version is not easy. Developers
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 公共领域，将它们重写为最新版本并不容易。开发者
- en: should look at both the compilation errors and warnings to ensure that the
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应该检查编译错误和警告，以确保
- en: versions are compatible.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 版本之间是兼容的。
- en: '285'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '285'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Randomness Vulnerability**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机性漏洞**'
- en: '**Vulnerability: Weak Randomness from**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：从**'
- en: '**Blockchain Attributes**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链属性**'
- en: Smart contracts do not communicate with external programs directly and
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约不直接与外部程序通信，
- en: do not have a good source of random number generators. Sometimes, in
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 没有良好的随机数生成器来源。有时，在
- en: applications such as gaming or lottery, there is a need for using random
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如游戏或彩票等应用需要使用随机数。
- en: numbers. Developers need to know that some blockchain attributes are
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数字。开发者需要知道一些区块链属性是
- en: not as random as what they seem to be. For example, Ethereum miners
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不像它们看起来那么随机。例如，以太坊矿工
- en: might manipulate block.timestamp or blockhash by controlling block
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会通过控制块地址
- en: generation time or packaging different transactions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成时间或打包不同交易。
- en: For applications that require a high degree of randomness, it is
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: recommended to use external randomness generators and Oracle to bring
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: the randomness to smart contracts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature Vulnerability**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Signature Manipulation**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, smart contracts implement cryptographic functions to verify
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: signed messages and perform transfer operations accordingly. To ensure
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: security, the smart contract functions need to ensure that the signed
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: messages are authentic and the message cannot be replayed. When using
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: a message, a private key and a message are supplied as input to create a
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: signature. One important thing to note is that the signature is not unique.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A hacker can manipulate (r,s,v) parameters to create a different yet valid
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: signature for the same private key and message. Hence, signature or hash
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: cannot be used as a unique identifier of a message transaction. Otherwise,
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: hackers can take advantage of this by creating different valid signatures to
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: replay previously signed messages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following msgid is not unique and should not be used
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'as an identifier for the signed message:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '286'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 msgid = keccak256(abi.encodePacked(getTransferHash(_to,*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*_value, _gasPrice, _nonce), _signature));*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*require(!signatureUsed[msgid]);*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Here, msgid is supported to be unique for the same message signed by
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: a private key. However, since _signature is not unique, msgid can be made
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: different, and the same signed message can be replayed multiple times to
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: trigger other actions that might involve asset transfer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, simply remove _signature in the hashing function
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: to make the msgid to be unique to block the replay of the message.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 msgid = keccak256(abi.encodePacked(getTransferHash(_to,*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*_value, _gasPrice, _nonce)));*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*require(!signatureUsed[msgid]);*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**Module Summary**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Security is the most essential component for smart contract development.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: To ensure security, there should be a security framework in place, and
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: developers should also focus on details for each line of code. There will be
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: more discussion of security in Chapter [8\.](https://doi.org/10.1007/978-1-4842-8164-2_8)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 5: Tools, Test, and Debug**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [1](https://doi.org/10.1007/978-1-4842-8164-2_1), we discussed basic
    tools such as setting up a smart contract development environment by using Truffle
    and Remix to compile and
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: deploy smart contracts. In this module, we continue to introduce useful
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: tools such as smart contract visualization tools, security scanning tools,
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: and gas estimation tools. We also discuss how to test and debug smart
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: contract programs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '287'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-299_1.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Tools**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**MythX: A Security Scanning Tool**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: MythX is a security scanning tool that is released as a fee-based service of
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: mythx.io, or a CLI package, or a plug-in for other tools.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Here, we explain how to use MythX as a plug-in for Remix. To use
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Remix, follow the instructions in Chapt[er 6](https://doi.org/10.1007/978-1-4842-8164-2_6)
    and launch your application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix中，请按照第6章的说明操作[章6](https://doi.org/10.1007/978-1-4842-8164-2_6)并启动您的应用程序。
- en: To enable MythX, simply click the Plugin Manager icon to bring up
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用MythX，只需点击插件管理器图标以打开
- en: the manager. Type “mythx” in the search box and you can see MYTHX
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器。在搜索框中输入“mythx”，你可以看到MYTHX
- en: SECURITY VERIFICATION plug-in. Click the Activate button to activate
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 安全验证插件。点击激活按钮来激活
- en: this plug-in (Figur[e 7-6).](#p299)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件（图[7-6)。](#p299)
- en: '***Figure 7-6\.** Activation of MythX security scanning tool in Remix*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-6.* 在Remix中激活MythX安全扫描工具*'
- en: '288'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '288'
- en: '![](index-300_1.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](index-300_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: Once the MYTHX SECURITY VERIFICATION is activated, it needs
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活MYTHX安全验证，它需要
- en: to communicate with the MythX cloud service to perform the scanning.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与MythX云服务通信以执行扫描。
- en: Developers need to apply for an API key from mythx.io website and enter
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要从mythx.io网站申请一个API密钥并输入
- en: the API token information in the plug-in setting (Figure [7-7](#p300)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件设置中输入API令牌信息（图[7-7](#p300)）。
- en: '***Figure 7-7\.** Sign in needed to use MythX APIs*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-7.* 使用MythX API需要登录*'
- en: MythX security scanning also provides a plug-in for Truffle tool and
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: MythX安全扫描还为Truffle工具提供了一个插件
- en: an extension for Visual Studio vscode IDE tool. One thing to note is that
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个适用于Visual Studio Code集成开发环境（IDE）的工具扩展。需要注意的是
- en: MythX security verification is a fee-based service. Developers need to pay
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: MythX安全验证是一项收费服务。开发者需要支付
- en: a subscription fee for the security scanning service.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为安全扫描服务支付订阅费用。
- en: '289'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '289'
- en: '![](index-301_1.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](index-301_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Solidity Static Analysis: A Security Plug-in for Remix**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity静态分析：Remix的安全插件**'
- en: Unlike MythX, which charges a subscription fee for security scanning,
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与MythX不同，后者为安全扫描收取订阅费用，
- en: Solidity Static Analysis (SSA) plug-in for Remix is free and also provides
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Remix的Solidity静态分析（SSA）插件是免费的，并提供
- en: basic features for static code scanning. To enable SSA, simply open the
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的静态代码扫描功能。要启用SSA，只需打开
- en: Plugin Manager and type in Solidity Static Analysis and click the Activate
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 插件管理器并在搜索框中输入Solidity静态分析，然后单击激活
- en: button to activate it (Figur[e 7-8).](#p301)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮激活它（图[7-8)。](#p301)
- en: '***Figure 7-8\.** Using Solidity Static Analysis for security scan in Remix*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-8.* 在Remix中使用Solidity静态分析进行安全扫描*'
- en: Once the plug-in is activated, click its icon on the plug-in panel and
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 激活插件后，点击插件面板上的其图标并且
- en: it will start to analyze the active Solidity program on the Remix screen.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 它将开始分析Remix屏幕上活动的Solidity程序。
- en: SSA not only scans source code for security vulnerabilities, it also perform
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: SSA不仅扫描源代码中的安全漏洞，还执行
- en: checks on the gas consumption, ERC (Ethereum Request for Comment),
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 检查燃料消耗、ERC（以太坊请求评论）、
- en: and some miscellaneous analysis (Figure [7-9](#p302)). Developers can filter
    what categories to analyze and show.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些杂项分析（图[7-9](#p302)）。开发者可以过滤要分析的类别并显示。
- en: '290'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '290'
- en: '![](index-302_1.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](index-302_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '***Figure 7-9\.** Running Solidity Static Analysis scan*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-9.* 运行Solidity静态分析扫描*'
- en: '291'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '291'
- en: '![](index-303_1.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](index-303_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: Although Static Analysis tools are very helpful to catch some obvious
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态分析工具对于捕捉一些明显的
- en: vulnerabilities, they should not replace more complex security audits and
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞，它们不应该取代更复杂的安全审计和
- en: penetration tests, especially for smart contracts that handle asset transfers.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试，特别是对于处理资产转移的智能合约。
- en: '**Solidity to UML: Smart Contract Visualization Tool**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity to UML：智能合约可视化工具**'
- en: Solidity is an object-oriented programming language that is easy to
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种面向对象的编程语言，易于
- en: understand. Sometimes, when there are many functions and smart
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 理解。有时，当有许多函数和智能
- en: contracts for a dApp project, it becomes challenging to make sense of
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个dApp项目，合约变得难以理解
- en: the workflow of smart contracts. In this case, it would be good to convert
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的工作流程。在这种情况下，转换
- en: Solidity code to Unified Modeling Language (UML) to visualize the
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将Solidity代码转换为统一建模语言（UML）以可视化
- en: relationship of smart contracts and functions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约及其函数之间的关系。
- en: '**Solidity to UML for Remix**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity to UML for Remix**'
- en: There are several tools to convert Solidity to UML. Remix provides a plug-
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个工具将Solidity转换为UML。Remix提供了一个插-
- en: in for this as well. Simply activate the Solidity UML and launch the plug-in
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为此也提供。只需激活Solidity UML并启动插件
- en: to convert the Solidity code to UML diagram (Figure [7-10).](#p303)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以将Solidity代码转换为UML图（图[7-10]).（#p303）
- en: '***Figure 7-10\.** Plugin for Solidity to UML conversion*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-10.** Solidity到UML转换插件*'
- en: '292'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '292'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: Once Solidity 2 UML plug-in is activated, it can be used to parse
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了Solidity 2 UML插件，它就可以用来解析
- en: Solidity smart contracts and generate UML diagrams.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity智能合约并生成UML图。
- en: '**Solidity to UML Stand-Alone Tools**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity到UML的独立工具**'
- en: Besides Remix plug-in, there are also nodejs package or CLI package that
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Remix插件，还有nodejs包或CLI包
- en: can be used to generate UML diagram.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来生成UML图。*
- en: For example, sol2uml package is a versatile tool to generate UML
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，sol2uml包是一个生成UML
- en: from smart contract source code; it can also fetch UML for smart contract
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从智能合约源代码；它还可以获取智能合约的UML*
- en: deployed to Ethereum blockchain.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到以太坊区块链。
- en: To install sol2uml, simply type the following command by using node
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装sol2uml，只需通过使用node
- en: 'package manager (npm):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器（npm）：
- en: npm install sol2uml --only=production
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: npm install sol2uml --only=production
- en: Once sol2uml is installed, it can be run with various parameters as
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了sol2uml，它可以通过各种参数运行
- en: 'shown in the following help menu:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下帮助菜单中显示：
- en: '*$ sol2uml -h*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: $ sol2uml -h*
- en: '*Usage: sol2uml <fileFolderAddress> [options]*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '使用: sol2uml <文件文件夹地址> [选项]*'
- en: '*Generates UML diagrams from Solidity source code.*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从Solidity源代码生成UML图.*
- en: '*If no file, folder or address is passed as the first*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个*
- en: '*argument, the working folder is used.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 参数没有文件、文件夹或地址传递，则使用工作文件夹.*
- en: '*When a folder is used, all *.sol files are found in that*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用文件夹时，在该*
- en: '*folder and all subfolders.*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹和所有子文件夹.*
- en: '*If an Ethereum address with a 0x prefix is passed, the*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了一个带有0x前缀的以太坊地址，那么*
- en: '*verified source code from Etherscan will be used.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Etherscan的验证源代码将被使用.*
- en: '*Options:*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 选项：*
- en: '*-v, --verbose run with debugging statements*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: -v, --verbose 带有调试语句运行*
- en: '*-f, --outputFormat <value> output file format: svg, png,*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: -f, --outputFormat <值> 输出文件格式：svg, png,*
- en: '*dot or all (default: "svg")*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: dot 或 all（默认："svg"）*
- en: '*-o, --outputFileName <value> output file name*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: -o, --outputFileName <值> 输出文件名*
- en: '293'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '293'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '*-d, --depthLimit <depth> number of sub folders that*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: -d, --depthLimit <深度> 子文件夹的数量*
- en: '*will be recursively searched*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归搜索*
- en: '*for Solidity files. Default*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为Solidity文件。默认*
- en: '*-1 is unlimited (default: -1)*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: -1 不限制（默认：-1）*
- en: '*-n, --network <network> mainnet, ropsten, kovan,*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: -n, --network <网络> mainnet, ropsten, kovan,*
- en: '*rinkeby or goerli (default:*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: rinkeby 或 goerli（默认：*
- en: '*"mainnet")*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '"mainnet")*'
- en: '*-k, --etherscanApiKey <key> Etherscan API Key*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: -k, --etherscanApiKey <键> Etherscan API 键*
- en: '*-c, --clusterFolders Cluster contracts into*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: -c, --clusterFolders 将合同聚集到*
- en: '*source folders*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件夹中找到所有*.sol文件*
- en: '*-h, --help output usage information*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: -h, --help 输出使用信息*
- en: To generate UML diagram for smart contracts in a local directory, type
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地目录中为智能合约生成UML图，请输入
- en: 'the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令：*
- en: sol2uml ./contracts
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: sol2uml ./contracts
- en: Here, ./contracts is the directory location for smart contract files.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，./contracts是智能合约文件的目录位置。
- en: sol2uml can also fetch UML files for smart contracts deployed to
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: sol2uml还可以获取部署到
- en: Ethereum blockchain. For example, to get a UML for a particular address
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链。例如，为了获取一个特定地址的UML
- en: 'in the Ropsten blockchain, run the following command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ropsten区块链中，运行以下命令：
- en: sol2uml smartcontract_address -n ropsten
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: sol2uml smartcontract_address -n ropsten
- en: Here, smartcontract_address is the address of the smart contract that
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，smartcontract_address是智能合约的地址，
- en: has been deployed to Ethereum blockchain. “-n ropsten” means that this is
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 已部署到以太坊区块链。"-n ropsten"意味着这是
- en: for smart contracts in the Ropsten blockchain.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为Ropsten区块链中的智能合约。*
- en: To understand a UML diagram, we use part of a smart contract for
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解UML图，我们使用智能合约的一部分*
- en: 'USDT ERC20 token. This UML diagram as shown in Figur[e 7-11 c](#p306)an be
    fetched by typing the following address in a browser URL:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: USDT ERC20代币。如图7-11c所示，这个UML图可以通过在浏览器URL中输入以下地址来获取：
- en: '[https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee52](https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee523a2206206994597C13D831ec7)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee52](https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee523a2206206994597C13D831ec7)'
- en: '[3a2206206994597C13D831ec7](https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee523a2206206994597C13D831ec7)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[3a2206206994597C13D831ec7](https://etherscan.io/viewsvg?t=1&a=0xdAC17F958D2ee523a2206206994597C13D831ec7)'
- en: '294'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 部分包含变量名、函数名和参数列表。
- en: '![](index-306_1.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: 继承抽象智能合约的智能合约需要实现这些函数
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '***Figure 7-11\.** UML diagram for USDT ERC20 token*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-11。USDT ERC20代币的UML图*'
- en: In this diagram, each box represents a smart contract class, an
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 程序来包装智能合约以执行自动测试。
- en: interface, or a library.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接口，或一个库。
- en: There are multiple sections for each box. The top bar is the smart
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '294'
- en: contract name. Then each scope of variables and functions are grouped
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 合约名称。然后每个变量和函数的作用域被分组
- en: into their respective sections such as internal, public, and external. Each
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们分别放入内部、公共和外部等相应的部分。每个
- en: section contains a list of variable names, function names, and parameters.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Solidity单元测试，首先点击插件图标以打开
- en: Lines with arrows are drawn between boxes to represent entity
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![](index-308_1.jpg)'
- en: relationships. If smart contract A uses smart contract B, meaning that B
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 关系。如果智能合约A使用智能合约B，意味着B
- en: is a parent of A, then a directed line is drawn from B to A. If entity A is
    an
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 是A的父级，那么从B到A画一条有向线。如果实体A是一个
- en: abstract smart contract or an interface, then a dash line instead of a solid
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: line is drawn.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 画一条线。
- en: In Solidity, an abstract class is a special smart contract in which
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，抽象类是一个特殊的智能合约，其中
- en: functions are defined but not implemented. The contract that uses or
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 合约。
- en: inherits an abstract smart contract will need to implement those functions
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，每个框代表一个智能合约类，一个
- en: defined. Also interfaces are special smart contracts in which only function
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个没有参数的函数中定义参数。
- en: names are defined. There are no variables declared in interfaces.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被定义但没有实现。使用或
- en: '295'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '295'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: Besides interfaces, smart contracts can also define and call library
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接口，智能合约还可以定义和调用库
- en: functions. Libraries in Solidity are defined with the “library” keyword
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 函数。Solidity中的库是用“library”关键词定义的
- en: and have functions that can be called by other smart contracts. Library is
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个Remix插件。
- en: stateless and cannot have state variables.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的无状态合约不能有状态变量。
- en: '**Solidity Test**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity测试**'
- en: '**Solidity Unit Testing: A Remix Plug-in for Testing**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity单元测试：一个Remix插件用于测试**'
- en: '[https://remix- ide.readthedocs.io/en/latest/unittesting.html](https://remix-ide.readthedocs.io/en/latest/unittesting.html)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://remix- ide.readthedocs.io/en/latest/unittesting.html](https://remix-ide.readthedocs.io/en/latest/unittesting.html)'
- en: Solidity has a good set of tools to provide unit tests or automatic
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity有一套很好的工具来提供单元测试或自动
- en: tests. When source smart contracts are written, developers can write test
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 测试。当源智能合约被编写时，开发者可以编写测试
- en: programs to wrap around the smart contract to perform automatic tests.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 定义。接口也是特殊的智能合约，其中只定义函数
- en: Tools such as Remix and Truffle all have test suites to help writing and
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 像Remix和Truffle这样的工具都有测试套件来帮助编写和
- en: executing test programs. In the following, we mention Solidity Unit Test as
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试程序。在下面，我们提到Solidity单元测试作为
- en: a Remix plug-in.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继承了一个抽象智能合约或一个接口，那么用虚线代替实线
- en: To activate Solidity Unit Testing plug-in, simply click at the Plugin
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Solidity单元测试插件，只需点击插件
- en: Manager panel and type in Solidity Unit Testing to search. Then click the
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 管理面板并在Solidity单元测试中输入搜索。然后点击该
- en: 'Activate button to activate the plug-in as shown in Figure [7-12](#p308):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 激活按钮以激活如图7-12所示的插件：
- en: '296'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '296'
- en: '![](index-308_1.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: 每个框有多个部分。上面一行是智能
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-12。Solidity单元测试插件*'
- en: '***Figure 7-12\.** Plugin for Solidity unit testing*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 用箭头的线 drawn between 方框来表示实体
- en: One thing to note is that test files in Solidity Unit Test plug-in will not
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Solidity单元测试插件中的测试文件不会
- en: support functions with parameters. For smart contracts with parameters,
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 支持带参数的函数。对于带参数的智能合约，
- en: there should be a wrapper test file that will call the functions with
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个包装测试文件，将调用带
- en: parameters from another function that does not have parameters.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中没有声明变量。
- en: To run Solidity Unit Testing, first, click at the plug-in icon to bring up
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![](index-306_1.png)'
- en: the unit testing panel. Then choose a directory to store the test suite files.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试面板。然后选择一个目录来存储测试套件文件。
- en: In the following screenshot, a directory of unit_test is chosen for the test
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: files. Then developers need to generate a test file for the source smart
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: contracts (Figur[e 7-13](#p309)).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '297'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-309_1.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-13\.** Generation of Solidity unit test file*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: To generate a test file for a source file, first, open the source smart
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: contract and make it active in the file view panel. Then select the directory
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: where the test file will reside. Click the “Generate” button to generate a test
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: file in the specified directory for the file that is opened in the view panel.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Once a test suite file is generated, it is automatically opened in the file
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: view panel. This test suite will have the basic code template for testing the
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: source contract. It has code segments of test library import, target source
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: files import, and testing function stubs. Developers can then initialize a
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: target smart contract and simulate the function calls for the smart contract
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: and then use the built-in logical checking function to assert the test results.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following code shows how to write unit test code to
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: test if the global variables and local variables are the same. The source
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: code is very simple. Variable x is declared as a global variable at the
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: beginning of the code. And then x is also declared as a local variable in the
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: function of localVariable.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '298'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity >=0.4.22 <0.9.0;*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '*contract VariableScope {*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '*address public x = 0x1f2D3A67B8E96039bbAc84eB4bC0913C0c16778c;*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '*function localVariable() public view returns (address x) {*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '*address x = 0x1111111111111111111111111111111111111111;*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '*return x; // Will return*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '*0x1111111111111111111111111111111111111111;*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '*function globalVariable() public view returns (address) {*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '*return x; // Will return*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '*0x1f2D3A67B8E96039bbAc84eB4bC0913C0c16778c;*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The unit test is to check if the variable x is the same at the global scope
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: and local scope. To test this, the following test suite is generated and
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'modified:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity >=0.4.22 <0.9.0;*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '*// This import is automatically injected by Remix*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '*import "remix_tests.sol";*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '*// This import is required to use custom transaction context*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '*// Although it may fail compilation in ''Solidity*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '*Compiler'' plugin*'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '*// But it will work fine in ''Solidity Unit Testing'' plugin*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '*import "remix_accounts.sol";*'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '*import "../variable_scope.sol";*'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '299'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '*// File name has to end with ''_test.sol'', this file can contain*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '*more than one testSuite contracts*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '*contract testSuite {*'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '*VariableScope vs;*'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '*/// ''beforeAll'' runs before all other tests*'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '*/// More special functions are: ''beforeEach'', ''beforeAll'',*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '*''afterEach'' & ''afterAll''*'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '*function beforeAll() public {*'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '*// <instantiate contract>*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '*vs = new VariableScope();*'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '*// Assert.equal(uint(1), uint(1), "1 should be*'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '*equal to 1");*'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '*function checkNotEqual() public {*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '*// Use ''Assert'' methods: https://remix-ide.readthedocs.io/*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert` 方法的使用：https://remix-ide.readthedocs.io/'
- en: '*en/latest/assert_library.html*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*en/latest/assert_library.html*'
- en: '*address x1 = vs.x.address;*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '*address x1 = vs.x.address;*'
- en: '*address x2 = vs.localVariable();*'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*address x2 = vs.localVariable();*'
- en: '*Assert.notEqual(x1, x2, "variables are supposed to be*'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*Assert.notEqual(x1, x2, "variables are supposed to be*'
- en: '*not equal");*'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '*not equal");*'
- en: '*}*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '*}*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: In the test suite code, source file is imported, and VariableScope
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件代码中，源文件被导入，变量作用域
- en: smart contract vs is instantiated. Then checkNotEqual() function is
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约 vs 被实例化。然后检查NotEqual()函数是否
- en: called to generate a local and global variable x in the vs and then make a
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 调用以在 vs 中生成一个本地和全局变量 x，然后进行
- en: comparison.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 比较。
- en: The test suite is run in Remix and shows that it passes the Unit
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件在 Remix 中运行，并显示它通过了单元
- en: Test (Figure [7-14), me](#p312)aning that the global variable and local variable
    are indeed different even though they have the same name.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 测试（图 [7-14），我](#p312)的意思是全局变量和局部变量确实是不同的，尽管它们有相同的名称。
- en: '300'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '300'
- en: '![](index-312_1.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](index-312_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 使用 Solidity 编程智能合约
- en: '***Figure 7-14\.** Unit test run example*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-14. 单元测试运行示例***'
- en: Using the Remix Solidity Unit Testing plug-in, it is very easy to write
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Remix Solidity 单元测试插件，编写
- en: scripts to test smart contracts.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本以测试智能合约。
- en: It is important to note that test files in Solidity Unit Test plug-in will not
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Solidity 单元测试插件中的测试文件不会
- en: support functions with parameters. For smart contracts with parameters,
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 支持带参数的函数。对于带有参数的智能合约，
- en: there should be a wrapper test file that will call the functions with
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个包装测试文件，将用
- en: parameters from another function that does not have parameters.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个没有参数的函数中传递参数。
- en: Besides the Remix plug-in for unit testing, Truffle also has good unit
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于单元测试的 Remix 插件外，Truffle 还提供了良好的单元
- en: test modules that support manual and automatic testing. The workflow
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 支持手动和自动测试的测试模块。工作流程
- en: and functionality are similar to the Remix plug-in.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 功能与 Remix 插件相似。
- en: '**Solidity Debug**'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity 调试**'
- en: Sometimes, Solidity smart contracts might encounter issues during
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Solidity 智能合约在
- en: executions. It would be good to step through the execution of each source
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 执行。最好逐行执行每个源文件
- en: code and analyze various debugging information such as call stacks and
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 内联代码（如调用堆栈和存储）进行分析。
- en: local variable values. Solidity does have some debugging tools that can
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 获取局部变量值。Solidity 确实有一些调试工具可以
- en: help with this. Here, we introduce the Debugger plug-in for Remix.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 提供帮助。在此，我们介绍了 Remix 的调试器插件。
- en: '301'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '301'
- en: '![](index-313_1.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![](index-313_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 使用 Solidity 编程智能合约
- en: '**Enable the Debugger**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用调试器**'
- en: To enable Remix debugger, simply open the Plugin Manager and type in
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Remix 调试器，只需打开插件管理器并输入
- en: debugger in the search box and enable this plug-in (Figure [7-15).](#p313)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器在搜索框中输入并启用此插件（图 [7-15）。](#p313)
- en: '***Figure 7-15\.** Enabling debugger plugin in in Remix*'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-15. 在 Remix 中启用调试器插件***'
- en: '**Launch the Debugger**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动调试器**'
- en: Once the debugger is enabled, a bug-like icon will show up in the plug-
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 启用调试器后，插件栏中会显示一个类似错误的图标
- en: in panel. To debug a Solidity program, developers need to compile a
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在面板中。要调试 Solidity 程序，开发人员需要编译一个
- en: contract source code, deploy the smart contract to a local EVM, and then
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 合约源代码，将智能合约部署到本地 EVM，然后
- en: create a transaction to get a transaction hash. After that, developers can
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个事务以获取事务哈希。之后，开发人员可以
- en: enter the transaction ID to the debugger configuration panel and start the
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 将交易 ID 输入到调试器配置面板并开始调试
- en: 'debugging process (Figure [7-16](#p314)):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '调试过程（图 [7-16](#p314)):'
- en: '302'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '302'
- en: '![](index-314_1.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](index-314_1.jpg)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 使用 Solidity 编程智能合约
- en: '***Figure 7-16\.** Launching Solidity debugger*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-16. 启动 Solidity 调试器***'
- en: '**Debug the Smart Contract**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试智能合约**'
- en: When the debugger is started, a debugging window as shown in the
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器启动时，将显示如图所示的调试窗口
- en: following will pop up, and developers can step through the code to see the
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将弹出，开发人员可以逐行浏览代码以查看
- en: execution of each line of code. Debugger supports steps functions such as
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 每行代码的执行。调试器支持步骤功能，如
- en: step into, step over, and step into breaking point.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 单步进入、单步跳过和单步进入断点。
- en: The debugger shows all the EVM execution context, storage, and
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器显示了所有的 EVM 执行上下文、存储和
- en: calling stack information including function stacks, Solidity locals, Solidity
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: state, step details, stack, memory, storage, call stack, call data, global
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: variables, return value, and full storage changes. Some of the information
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: might not be available, but the debugger generally gives a good amount of
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: bytecode execution information (Figur[e 7-17).](#p315)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '303'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-315_1.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-17\.** Stepping through a debugging program*'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is not obvious with the debugger is how to add a
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: breakpoint for the debugger. To add the breakpoint, simply open the
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: source code in the edit window and click at the line number (not the
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '304'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-316_1.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: source code itself). A blue dot will show up beside the line number to
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: indicate that a breaking point is inserted to that line (Figure [7-18).](#p316)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-18\.** Adding a breaking point in the source code*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Although the debugger is a great tool to debug a Solidity program, we
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: find that when debugging a more complex smart contract, there is still
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: some information that cannot be seen in the debugging windows. It is
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: a good practice to modularize smart contracts to simplify unit tests and
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: debugging.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 6: Client Considerations**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [6](https://doi.org/10.1007/978-1-4842-8164-2_6), and previous modules
    of Chapter [7, w](https://doi.org/10.1007/978-1-4842-8164-2_7)e discussed how
    to program Solidity smart contracts and deploy them to blockchains. Once
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts are deployed to a blockchain, they are accessible publicly
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: and will never be removed or altered once the blocks are finalized. Smart
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: contracts are bytecodes that are not user-friendly. To interact with dApps,
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: clients need to be developed to facilitate user interaction with smart
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '305'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-317_1.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: contracts. The clients for dApps can be web browsers, mobile application,
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: desktop application, or command-line interface (CLI). In this module, we
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: will discuss the pros and cons of these clients and also give examples for
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: building a dApp client.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of dApp clients**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: dApp clients can be in a graphic user interface (GUI) format or command-
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: line interface (CLI) format. The GUI format can be web-based app, mobile
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: app, or desktop app that requires user inputs and operations as shown in
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: the following figure. CLI formats are normally for automatically scripting
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: to perform testing or for application programming interfaces. In the
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: following diagram (Figure [7-19), w](#p317)e describe different kinds of clients.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-19\.** Types of clients for decentralized applications*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '306'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Client**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Browser client is the most basic user experience for a decentralized
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: application. Users are directly introduced to a website to use the dApp.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: For example, to access CryptoKitty dApp, users just need to point their
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: web browser t[o www.cryptokitty.com](http://www.cryptokitty.com). As shown in
    the client topology diagram, the browser needs a web extension/plug-in to connect
    to an
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览器[到www.cryptokitty.com](http://www.cryptokitty.com)。如图所示，浏览器需要一个网页扩展/插件来连接到
- en: Ethereum node through RPC protocol. The most common web extension
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RPC协议与以太坊节点交互。最常用的网页扩展
- en: is MetaMask. MetaMask serves as a crypto wallet for web applications.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 是MetaMask。MetaMask作为Web应用程序的加密钱包。
- en: To design a web application with a crypto account interaction,
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个具有加密账户交互的Web应用程序，
- en: developers need to develop web pages that connect to MetaMask or
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要开发与MetaMask连接的网页。
- en: other wallets. When a user connects to a URL through a browser, the
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他钱包连接的方法。当用户通过浏览器连接到一个URL时，
- en: browser script will check if MetaMask is installed and prompt users
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器脚本将检查MetaMask是否已安装并提示用户
- en: to install it if not found. This is normally called “Connecting Wallet.”
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不找到，就需要安装它。这通常被称为“连接钱包”。
- en: Normally, JavaScript scripts are written to use the Web3 library to connect
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JavaScript脚本是为了使用Web3库来连接
- en: to Ethereum nodes. We will have a detailed coding example later in
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊节点交互。我们稍后会有一个详细的编程示例。
- en: this module.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块。
- en: One of the challenges of browser-based dApp is the security of wallet.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器基于的dApp的一个挑战是钱包的安全性。
- en: Since browsers are prone to hacker attack, it is possible that MetaMask
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器容易受到黑客攻击，MetaMask可能也会受到影响。
- en: storage and private keys might be hacked in some browsers. It is
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些浏览器中，存储和私钥可能会被黑客攻击。
- en: recommended that when storing large amounts of crypto assets, hardware
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 建议当存储大量的加密资产时，使用硬件
- en: wallets should be used. MetaMask does support connecting to hardware
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用钱包。MetaMask支持与硬件钱包的连接。
- en: wallets to sign transactions to ensure safety of the wallet.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包需要签名交易以确保钱包的安全。
- en: '**Mobile Clients**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动客户端**'
- en: Mobile apps can also be developed to interact with smart contracts in
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序也可以开发与智能合约交互的
- en: the Ethereum blockchain. Since mobile apps normally do not have a
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊区块链交互。由于移动应用程序通常没有
- en: large footprint, they rely on API or RPC to communicate with blockchain
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的存储需求，它们依赖于API或RPC与区块链
- en: nodes. Similar to web wallet, mobile wallet does not have hardware grade
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 节点。与网页钱包类似，移动钱包没有硬件级别的
- en: security, and it should not be used to store large amounts of crypto assets.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性，并且不应该用来存储大量的加密资产。
- en: '307'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '307'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 用Solidity编程智能合约
- en: '**Desktop Client**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**桌面客户端**'
- en: Both web client and mobile client need to connect to external nodes to
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 网页客户端和移动客户端都需要连接到外部节点以
- en: interact with the Ethereum blockchain. Desktop clients have enough
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊区块链交互。桌面客户端有足够的
- en: storage and computing power and might be able to run an Ethereum node
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和计算能力，并且可能能够运行一个以太坊节点
- en: by itself. This means the desktop client might carry its own RPC server and
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 本身。这意味着桌面客户端可能携带自己的RPC服务器和
- en: does not have dependency on third-party RPC nodes. One disadvantage is
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖于第三方RPC节点。一个缺点是
- en: that desktop apps need installation and need to have a desktop to run the
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序需要安装并且需要有桌面才能运行
- en: application.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序。
- en: '**CLI Client**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLI客户端**'
- en: CLI client is to use a command-line interface to run the scripts that
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: CLI客户端使用命令行界面运行脚本
- en: interact with Ethereum blockchain. This is typically done in unit tests or
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊区块链交互。这通常在单元测试中完成，
- en: automatic scripting of projects. CLI is handy for those who like to use text-
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目进行自动脚本化。CLI对于喜欢使用文本的
- en: based typing rather than GUI-based browsing.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 基于打字而不是基于GUI的浏览。
- en: Each client has its own pros and cons, and we have seen that web
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端都有它自己的优点和缺点，我们已经看到了Web
- en: clients are becoming more and more popular. In the following, we provide
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端越来越受欢迎。在下面，我们提供了
- en: a use case for designing web pages for a deployed smart contract.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计用于部署智能合约的网页的应用案例。
- en: '**Web Client Example for Interacting**'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**与智能合约交互的网页客户端示例**'
- en: '**with Smart Contract**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有智能合约**'
- en: In this example, we demonstrate how to write a web page to interact with
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了如何编写一个与以太坊区块链交互的网页。
- en: a deployed smart contract. To make the demo an end-to-end experience,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 一个部署的智能合约。为了使演示成为一个端到端的体验，
- en: we do the following to deploy the smart contract to the development
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做以下事情来将智能合约部署到开发
- en: environment.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 环境。
- en: '**Step 1: Create an Ethereum development blockchain**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一步：创建一个以太坊开发区块链**'
- en: An Ethereum development blockchain is created by downloading geth
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 通过下载geth创建以太坊开发区块链。
- en: 'application and running the following commands:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中运行以下命令：
- en: '308'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '308'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: ./geth --datadir test-chain-dir --http --dev --http.corsdomain
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ./geth --datadir test-chain-dir --http --dev --http.corsdomain
- en: '"https://remix.ethereum.org,http://remix.ethereum.org"'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '"https://remix.ethereum.org,http://remix.ethereum.org"'
- en: This command creates a private development blockchain and allows
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个私有的开发区块链，并允许
- en: Remix development tools to interact with it. The data storage is located in
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 开发工具可以与之交互。数据存储位于
- en: test-chain-dir, and a development account will be generated by default.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: test-chain-dir，默认会生成一个开发账户。
- en: The location of the keystore of this account is located in the test-chain-dir/
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 该账户的 keystore 位于 test-chain-dir/
- en: keystore directory. This address and keystore can be used to manage the
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: keystore 目录。此地址和 keystore 可用于管理
- en: account.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 账户。
- en: For more details, refer t[o http://geth.ethereum.org/docs/getting-](http://geth.ethereum.org/docs/getting-started/dev-mode)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请参阅 [http://geth.ethereum.org/docs/getting-](http://geth.ethereum.org/docs/getting-started/dev-mode)
- en: '[started/dev- mode](http://geth.ethereum.org/docs/getting-started/dev-mode).
    Use geth attach <IPC_LOCATION> to attach to the node and use eth.sendTransaction
    to send from coinbase to the target'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '[started/dev- mode](http://geth.ethereum.org/docs/getting-started/dev-mode).
    使用 geth attach <IPC_LOCATION> 连接到节点并使用 eth.sendTransaction 从 coinbase 发送到目标'
- en: account.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 账户。
- en: Once the development blockchain is started, the next step is to
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: Once the development blockchain is started, the next step is to
- en: deploy a smart contract to it. Here, we develop a smart contract with two
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中部署智能合约。在这里，我们开发了一个带有两个
- en: 'functions: storeMessage and retrieve.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 存储消息和检索。
- en: '// SPDX-License-Identifier: GPL-3.0'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '// SPDX-License-Identifier: GPL-3.0'
- en: pragma solidity >=0.7.0 <0.9.0;
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: pragma solidity >=0.7.0 <0.9.0;
- en: /**
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: /**
- en: '* @title MessageStorage'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '* @title MessageStorage'
- en: '* @dev Store & retrieve value in a variable'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '* @dev 在变量中存储和检索值'
- en: '*/'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: contract MessageStorage {
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 合同 MessageStorage {
- en: string message;
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 message;
- en: /**
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: /**
- en: '* @dev Store value in variable'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '* @dev 在变量中存储值'
- en: '* @param messageInput value to store'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '* @param messageInput 要存储的值'
- en: '*/'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: '309'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '309'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: function storeMessage(string memory messageInput) public {
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 storeMessage(string memory messageInput) 公开 {
- en: message = messageInput;
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: message = messageInput;
- en: '}'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: /**
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: /**
- en: '* @dev Return value'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '* @dev 返回值'
- en: '* @return value of ''message'''
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '* @return ''message''的值'
- en: '*/'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: function retrieve() public view returns (string memory){
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 retrieve() 公开查看返回 (string memory){
- en: return message;
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 message;
- en: '}'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**Step 2: Compile and deploy the smart contract**'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：编译并部署智能合约**'
- en: '**to the development blockchain**'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**到开发区块链**'
- en: Once the smart contract is written, use Remix or Truffle to compile it.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约编写完成，使用 Remix 或 Truffle 进行编译。
- en: To use Remix, simply go t[o http://remix.ethereum.org and cr](http://remix.ethereum.org/)eate
    a file for the preceding smart contract. Upon a successful compilation, an
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Remix，只需前往 [http://remix.ethereum.org](http://remix.ethereum.org/) 并创建一个先前智能合约的文件。在成功编译后，一个
- en: Application Bytecode Interface (ABI) file and bytecode file are generated.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序字节码接口（ABI）文件和字节码文件将被生成。
- en: The bytecode file will be deployed to the blockchain. The ABI will be used
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码文件将部署到区块链上。ABI 将被用来
- en: for dApp clients to interact with the smart contract. The ABI will need to
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 dApp 客户端与智能合约交互。ABI 需要
- en: be copied by clicking at the ABI button and saved to client code. In the
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击 ABI 按钮复制并保存到客户端代码中。在
- en: example, the following ABI file describes the format of the functions and
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 ABI 文件描述了函数的格式和
- en: 'variables defined in the smart contract:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约中定义的变量的智能合约：
- en: '['
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '{'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"inputs": [],'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '"inputs": [],'
- en: '"name": "retrieve",'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "retrieve",'
- en: '310'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '310'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '"outputs": ['
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '"outputs": ['
- en: '{'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"internalType": "string",'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '"internalType": "string",'
- en: '"name": "",'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "",'
- en: '"type": "string"'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "string"'
- en: '}'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '],'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"stateMutability": "view",'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '"stateMutability": "view",'
- en: '"type": "function"'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "function"'
- en: '},'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"inputs": ['
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '"inputs": ['
- en: '{'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"internalType": "string",'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '"internalType": "string",'
- en: '"name": "messageInput",'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "messageInput",'
- en: '"type": "string"'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "string"'
- en: '}'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '],'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"name": "storeMessage",'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "storeMessage",'
- en: '"outputs": [],'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '"outputs": [],'
- en: '"stateMutability": "nonpayable",'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '"stateMutability": "nonpayable",'
- en: '"type": "function"'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "function"'
- en: '}'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '])'
- en: '**Step 3: Deploy the smart contract**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3：部署智能合约**'
- en: Once the smart contract is compiled, go to deploy panel and deploy to the
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约编译完成，前往部署面板并部署到
- en: development blockchain (Figure [7-20):](#p323)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 开发区块链（图 [7-20）：](#p323)
- en: '311'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '311'
- en: '![](index-323_1.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: ！[](index-323_1.jpg)
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-20\.** Remix smart contract deployment panel*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '312'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: Here, Environment should specify Web3 provider and point to
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[http://127.0.0.1:8545](http://127.0.0.1:8545/), which is the endpoint of the
    development chain.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Once the smart contract is deployed successfully, a smart contract
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'address will be returned as shown in the bottom of the screen:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '0x16d29C0A07dcDBe6e1097257Ee39DEe18136d672'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Developers can copy this smart contract address for the web browser
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: to interact with.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Write web client to interact**'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '**with the smart contract**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: For a web client to interact with a smart contract, several parameters are
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'needed, including the following:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '**An** **RPC endpoint** **of the blockchain** – This is'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: the entry to the blockchain. In this example, it
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: is [http://127.0.0.1:8545](http://127.0.0.1:8545/). Web wallets such as
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask will need to connect to the blockchain
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: through this RPC endpoint.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '**ABI for the smart contract** – This is created when'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: the smart contract is compiled.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart contract address** – This address is returned'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: after a successful deployment of the smart contract.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we have an HTML/JavaScript page to show the UI for
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: interacting with the smart contract. The HTML portion shows the layout
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: of the buttons. The JavaScript portion shows the scripting code to interact
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: with the smart contract.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: The following shows the web UI of the HTML/script code (Figur[e 7-21](#p325)).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of the GUI, there are three buttons that allow users to
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: connect to a wallet and get the wallet address, to set a message to write to
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '313'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-325_1.png)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, and then a button to retrieve the message. The top right is a
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: pop-up of MetaMask that allows users to sign transactions to interact with
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: blockchain.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-21\.** Example of a user interface to interact with smart*'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '*contract*'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'A code snippet for the three HTML buttons is shown below:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: “Connect Wallet” button will trigger enableEthereumButton and get
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: the wallet account address.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '*<DIV class="container">*'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '*<H1 class="display-4">Message Storage</H1>*'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '*<P>Click connect to wallet</P>*'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '*<P><BUTTON class=*'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '314'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '*"btn btn-secondary enableEthereumButton">Connect Wallet*'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '*</BUTTON><BR>*'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '*Wallet Address:<span class="showAccount"></span></P>*'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '*</DIV>*'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: “Set Message” button will trigger the setMessage() function in the
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '*<P>Enter a string for the message</P>*'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '*<DIV class="cluegene">*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '*<LABEL for="cluegene"><B>Message to set</B></LABEL>*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '*<INPUT type="text" class="ignore-form-control" id=*'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '*"cluegene" placeholder="" value="[My_Message]"*'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '*size="20"*'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '*required="">*'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '*</DIV>*'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '*<P><A class="btn btn-secondary" onclick="setMessage()"*'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '*role="button">Set Message</A></P>*'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '“Retrieve Message” button will trigger the getMessage() function:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="row" id="getmessagerow">
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="col-lg-6 text-center">
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: <H2>Get Message From Blockchain</H2>
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: <P>Click to retrieve message</P>
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: <P><A class="btn btn-secondary" onclick="getMessage()"
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: role="button">Retrieve Message</A></P>
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: <DIV id="GetMessageValue"></DIV>
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: The three functions are implemented in JavaScript code.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: For getting the address of the wallet, an eth_requestAccounts request
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: is sent as an Ethereum request to fetch the accounts enabled by the
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '315'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '**async function getAccount() {**'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '**const accounts = await ethereum.request({ method:**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '**''eth_requestAccounts'' });**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '**const account = accounts[0];**'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '**account0 = account;**'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '**showAccount.innerHTML = account;**'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: 'For setting the message, the following workflow is coded:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: • The setMessage function first checks if the MetaMask
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: is installed. If it is installed, get the account associated
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: with the MetaMask.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: • JavaScript code creates a smart contract object with the
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: specified contract address and ABI information. The
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: ABI can be in a separate file to be imported.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: • Package data for the transaction. This step takes the
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: message to be set from the input field and package with
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: embedded encodeABI() function.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: • Send the transaction with the sendTransaction function.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '*function setMessage() {*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '*if (!ethEnabled()) {*'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '*alert("Please install an Ethereum-compatible browser or*'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '*extension like MetaMask to use this dApp!");*'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '*web3.eth.getAccounts(function(err, accounts) {*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '*var myContract = new web3.eth.Contract(messagestorage_abi,*'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '*messagestorage_contract.toLowerCase());*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '*var gene = $(''.cluegene input'').val();*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '*var auctionData = myContract.methods.storeMessage(gene).*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '*encodeABI();*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '316'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '*var tx_genescience = web3.eth.sendTransaction({*'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '*from: accounts[0].toLowerCase(),*'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '*to: messagestorage_contract.toLowerCase(),*'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '*data: auctionData*'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '*}, function(err, transactionHash) {*'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '*document.getElementById("SetMessageValue").innerHTML =*'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '*"setMessage tx:" + transactionHash;*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '*})*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '*})*'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the setMessage function, the getMessage function also
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: creates a smart contract object and a call retrieve function in the smart
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: contract. Since getMessage is a function that does not write to blockchain,
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: a call() function is called directly. This call() function does not need
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask to sign the transaction and does not cost gas fee.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: function getMessage() {
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: if (!ethEnabled()) {
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: alert("Please install an Ethereum-compatible browser or
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: extension like MetaMask to use this dApp!");
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: var myContract = new web3.eth.Contract(messagestorage_abi,
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: messagestorage_contract.toLowerCase());
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: var tx_getmessage = myContract.methods.retrieve().
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: call(function(err, result) {
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: document.getElementById("GetMessageValue").innerHTML =
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '"message retrieved:" + result;'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '317'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we describe Solidity programming with examples, syntax,
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: data structure, functions, events, client applications, security, test, debug,
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构、函数、事件、客户端应用程序、安全、测试、调试、
- en: and deployment. This should lay down a good foundation for basic Solidity
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 部署。这应该为基本的Solidity
- en: programming for decentralized applications.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 为去中心化应用编程。
- en: '318'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '318'
- en: '**CHAPTER 8**'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章**'
- en: '**Security**'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**'
- en: '**Considerations**'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: '**Introduction**'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '**引言**'
- en: We went through many aspects of Solidity smart contract programming
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细介绍了Solidity智能合约编程的许多方面
- en: already in previous chapters. We covered Solidity programming syntax,
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中已经介绍过。我们介绍了Solidity编程语法，
- en: using Remix or Truffle to compile source code, and deploying bytecode
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Remix或Truffle编译源代码，并部署字节码
- en: to an embedded EVM or development blockchain. We also mentioned
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 到嵌入式EVM或开发区块链。我们还提到了
- en: the token economy and token design such as choosing fungible or
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 代币经济和代币设计，如选择同质化或
- en: nonfungible tokens and using the tokens to represent assets and elements
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 非同质化代币，并使用代币代表资产和元素
- en: for business use cases.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于商业用例。
- en: On the storage and communication side, we talked about the
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储和通信方面，我们讨论了
- en: importance of Ethereum blockchain state and event concepts as well as
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链状态和事件概念的重要性以及
- en: different networks such as mainnet, Rinkeby testnet, and Ropsten testnet.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的网络，如主网、Rinkeby测试网和Ropsten测试网。
- en: On the architecture side, we talked about building end-to-end
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构方面，我们讨论了构建端到端
- en: solutions with building blockchain nodes to connect to the Ethereum
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 构建区块链节点以连接以太坊
- en: blockchain, deploying smart contracts, developing web clients or mobile
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链、部署智能合约、开发Web客户端或移动
- en: apps, and using Web3 to connect clients with blockchains.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 应用，并使用Web3将客户端与区块链连接。
- en: In this chapter, we are going to cover Ethereum blockchain and smart
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以太坊区块链和智能
- en: contract security. Security is one of the most critical aspects of software
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 合约安全。安全性是软件最重要的方面之一
- en: development. It plays an even larger role in the Ethereum blockchain for
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 开发。它在以太坊区块链中扮演了更大的角色
- en: 'the reasons shown below in Figure [8-1](#p331):'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 下面图[8-1](#p331)中显示的原因：
- en: © Weijia Zhang and Tej Anand 2022
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: ©张伟佳，安丹 2022
- en: '319'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '319'
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 张伟佳，安丹，*区块链与以太坊智能合约解决方案开发*
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_8](https://doi.org/10.1007/978-1-4842-8164-2_8#DOI)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doi.org/10.1007/978-1-4842-8164-2_8](https://doi.org/10.1007/978-1-4842-8164-2_8#DOI)'
- en: '![](index-331_1.jpg)'
  id: totrans-885
  prefs: []
  type: TYPE_IMG
  zh: '![](index-331_1.jpg)'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '***Figure 8-1\.** Complexity of blockchain security as compared to*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '***图8-1。** 区块链安全复杂性与*'
- en: '*conventional IT security*'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统IT安全**'
- en: • **Decentralized nature of blockchain** – Any code
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: • **区块链的去中心化特性** – 任何代码
- en: written and deployed to the blockchain is going to run
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并部署到区块链的代码将运行
- en: in thousands of machines. Anybody can access and run
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在数千台机器中。任何人都可以访问和运行
- en: blockchain code.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链代码。
- en: • **Constraints of patches and upgradability** – Due to the
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: • **修补和可升级性的限制** – 由于
- en: immutability of blockchains, smart contracts deployed
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的不变性，智能合约部署
- en: to blockchains cannot be modified. This increases the
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 无法修改。这增加了
- en: difficulty for upgrading decentralized applications.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 升级去中心化应用的难度。
- en: When security flaws are detected in blockchain
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 当在区块链中检测到安全漏洞时
- en: applications, the cost of patching the applications
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 应用成本，修补应用
- en: is high, and sometimes, a fork of the blockchain
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 很高，有时，区块链的分叉
- en: is needed.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 是必需的。
- en: • **Trustless and permissionless environment** – For
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: • **无信任和无需许可的环境** – 对于
- en: public blockchains, both the client nodes and
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 公共区块链，客户端节点和
- en: decentralized applications are open to global
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用对全球
- en: participants. There is no centralized authority to check
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 检查
- en: the qualifications of participants. There is no security
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者的资格。没有安全保障
- en: perimeter to block bad players from participating.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止不良玩家参与。
- en: • **Privacy and anonymous nature of blockchain**
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: • **区块链的隐私和匿名特性**
- en: –Blockchain users can remain anonymous. Smart
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: – 区块链用户可以保持匿名。智能
- en: contract functions do not have a way to check the
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 合约函数没有检查
- en: profile of the users. Hackers can carry out blockchain
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 用户概况。黑客可以实施区块链
- en: attacks, get the assets, and remain unidentified.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击，获取资产，并保持匿名。
- en: '320'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '320'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: • **High value impact on business** – Smart contracts
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: • **对业务的高价值影响** – 智能合约
- en: normally have a small footprint. Bigger projects might
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 通常规模较小。更大的项目可能会
- en: have over thousands of lines of code, while others may
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过数千行代码，而其他项目可能
- en: only have a few hundred. Smart contracts manage
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 只有几百行。智能合约管理
- en: high value crypto assets, and each attack might bring
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 高价值的加密货币资产，每次攻击都可能带来
- en: catastrophic results to the decentralized application.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 对去中心化应用造成灾难性的结果。
- en: Some decentralized applications have suffered huge
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 一些去中心化应用遭受了巨大的
- en: losses due to simple errors in smart contracts.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约中的简单错误造成的损失。
- en: Several smart contract breaches have been found in the past. We can
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 过去发现了几起智能合约被黑事件。我们可以
- en: classify these security issues as functional security holes and attackable
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些安全问题归类为功能安全漏洞和可攻击的
- en: security holes. Functional security holes are obvious code errors and can
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞。功能安全漏洞是明显的代码错误，可以
- en: cause loss of funds with normal transactions and by bona fide users. The
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 正常交易和善意用户造成资金损失。设置
- en: functional security holes for smart contract contain the following.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的功能安全漏洞包括以下内容。
- en: '**Functional Security Holes**'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能安全漏洞**'
- en: '**in Smart Contracts**'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**在智能合约中**'
- en: '**Fund Deadlock**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**资金死锁**'
- en: This is a security hole where a smart contract can take in fund transfer
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全漏洞，智能合约可以接收资金转移
- en: but will lock the funds in a smart contract indefinitely. For example, a
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 但会将资金在智能合约中无限期地锁定。例如，一个
- en: smart contract can implement a receive function to take in funds but not
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以实现一个接收函数来接收资金，但不
- en: to implement functions for send or transfer. In this case, funds sent to the
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 实现发送或转账的功能。在这种情况下，发送到
- en: smart contract will be owned by the smart contract, but there is no way
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约将由智能合约拥有，但没有方式
- en: to transfer funds out. Similar to a blackhole, this is a case that takes in
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于黑洞，这是一个吸收
- en: everything with nothing going out.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 一无所获。
- en: '321'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '321'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '**Fund Leakage**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**资金泄漏**'
- en: This is a functional security hole that can cause leak of funds by an
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以通过智能合约导致资金流失的功能安全漏洞。
- en: unprivileged user. This is normally due to a lack of access rights and
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 未授权用户。这通常是由于访问权限不足和
- en: privilege checking. For example, a security hole can be caused by a
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 特权检查。例如，一个安全漏洞可能由一个
- en: function that has fund transfer capabilities but is declared public without
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 具有资金转移能力的公共声明函数。
- en: authenticating the user’s ownership of the fund. In Solidity smart contract
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户对资金的所有权。在Solidity智能合约中，
- en: programming, there are several places where the security can be enforced,
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有几个地方可以加强安全措施，
- en: including setting the scope of a function to be public or private, setting
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 包括将函数的作用域设置为公共或私有，设置
- en: the ownership access rights, and using require and assert to make sure
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者访问权限，并使用require和assert确保
- en: access conditions are met before proceeding to the next line of code for
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一行代码之前，必须满足访问条件。
- en: execution. When a token is minted or transferred, the smart contract
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 执行。当铸造或转移代币时，智能合约
- en: needs to make sure the caller of the function is the owner, or administrator,
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 需要确保函数的调用者是所有者或管理员，
- en: and an authorized user for the function. It is very important to define
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 和函数的授权用户。定义
- en: roles in smart contracts, and each role will have limited access rights. In
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约中的角色，每个角色都将拥有有限的访问权限。在
- en: CryptoKitty’s example, there are four roles defined including owner of
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 以CryptoKitty为例，定义了四个角色，包括所有者、
- en: smart contract, CEO of the project, COO, and CFO. For the mint function,
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约，项目CEO，COO和CFO。对于铸币功能，
- en: the smart contract defines the mint right to COO. You have to be a
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约定义了COO的铸币权。你必须是
- en: COO of this project to mint an NFT token. There is also a pause/unpause
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: COO有权铸造NFT代币。还有一个暂停/恢复
- en: function to handle emergency situations by halting the execution of
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 通过停止执行来处理紧急情况的功能。
- en: smart contracts, and this right is given to the CEO. The CFO can do other
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约，这个权利赋予了CEO。CFO可以执行其他
- en: things related to auctions. The owner of the smart contract is also a critical
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 与拍卖相关的事情。智能合约的所有者也是这个项目的一个关键
- en: role. Normally, whoever deploys a smart contract to the blockchain is
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 角色。通常，无论谁将智能合约部署到区块链上，
- en: the owner of the smart contract by default. This owner can then transfer
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的所有者默认。这个所有者可以然后将
- en: the ownership to another user, or to a smart contract address, or even
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有权转让给另一用户，或智能合约地址，甚至
- en: renounce the ownership. Because the owner of a smart contract has the
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃所有权。因为智能合约的所有者具有
- en: highest access privilege, it is very important to protect the private keys for
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 最高访问权限，保护私钥非常重要
- en: the owner account.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 合约所有者账户。
- en: '322'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '322'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '**Disabled Smart Contract**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disabled Smart Contract`'
- en: This is another functional security hole where a nonprivileged user
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个功能安全漏洞，其中非特权用户
- en: can call a function to kill the smart contract. This is another thing that
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用一个函数来杀死智能合约。这是另一件
- en: needs to be watched. In a smart contract, there might be a function that
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注。在智能合约中，可能有一个函数，
- en: can be executed to disable the whole smart contract by clearing the
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 可以执行以清除
- en: states, storage, and settings. If this function is incidentally called, it will
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 状态、存储和设置。如果这个函数被偶然调用，它会
- en: completely ruin the smart contract.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 完全破坏智能合约。
- en: '**Orphan Smart Contract**'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orphan Smart Contract`'
- en: When a smart contract is deployed, the account that sends the deployment
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 当智能合约部署时，发送部署
- en: transaction is the owner, and it has high privilege administration rights to
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是所有者，并且它对
- en: the smart contract. Sometimes, to increase the degree of decentralization,
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约。有时，为了增加去中心化程度，
- en: the owner might transfer the ownership to another owner account, a smart
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者可能会将所有权转让给另一个所有者账户，一个智能
- en: contract, or denounce the ownership. Once ownership of a smart contract is
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 合约，或放弃所有权。一旦智能合约的所有权被
- en: transferred or denounced after the deployment, the original owner does not
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后转让或放弃，原所有者无法
- en: have the right to administer the smart contract anymore. It is thus important
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 不再有权管理智能合约。因此，非常重要
- en: to come up with a smart contract ownership plan during the design
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计过程中提出智能合约所有权计划
- en: process. Once the smart contract is deployed and ownership transferred or
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 过程。一旦智能合约部署并转让或
- en: denounced, there is no way to pause or upgrade the smart contracts when
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃后，当
- en: an emergency situation arises in the decentralized applications.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 在去中心化应用中出现紧急情况。
- en: '**Attackable Security Holes in Smart**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attackable Security Holes in Smart`'
- en: '**Contracts**'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contracts`'
- en: This kind of security breach is caused by users with malicious intent.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全漏洞是由恶意用户引起的。
- en: It is less obvious than functional security holes and very difficult to be
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性安全漏洞不那么明显，非常难以被
- en: discovered. Hackers will normally need to construct artificial transactions
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 被发现。黑客通常需要构建人工交易
- en: and carry out multiple steps of attacks. The attackers also remain
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 并执行多步骤攻击。攻击者还保持
- en: anonymous and have methods to transfer the funds. These kinds of
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名且具有转让资金的方法。这类
- en: '323'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '323'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: breaches can also include attacking blockchain nodes and Web3 clients
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞也可能包括攻击区块链节点和Web3客户端
- en: and environments outside the smart contracts. Other breaches have also
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约之外的操作和环境。其他安全漏洞也包括
- en: 'happened with hackers doing the following: (1) calling faulty internal'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 与黑客做以下事情有关： （1）调用错误的内部
- en: functions with malicious transactions; (2) changing outside parameters
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 具有恶意交易的函数；（2）更改外部参数
- en: and conditions for a function call; (3) changing whitelist addresses and
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 以及函数调用的条件；（3）更改白名单地址和
- en: names; and (4) attacking Oracle. The following are some examples of
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 名称；以及（4）攻击Oracle。以下是一些
- en: 'attackable security holes:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 可攻击的安全漏洞：
- en: 'Example 1: Pay bill to arbitrary accounts'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1：向任意账户支付账单
- en: 'The following is a code snippet with a security hole:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有安全漏洞的代码片段：
- en: '*pragma solidity ^0.8.6;*'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity ^0.8.6;`'
- en: '*contract PayIssue {*'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract PayIssue {`'
- en: '*function payBill ( address payable recipient, uint256 x_amount*'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '`function payBill ( address payable recipient, uint256 x_amount`'
- en: '*) public payable {*'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '`} public payable {`'
- en: '*recipient.transfer(x_amount);*'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipient.transfer(x_amount);`'
- en: '*}*'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: In the preceding code, there is a function called payBill(address
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个名为payBill(address
- en: payable recipient, uint256 x_amount) public payable.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 可支付收款人，uint256 x_amount) public payable。
- en: This payBill function when called will simply transfer “x_amount”
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此payBill函数时，它将简单地转让“x_amount”
- en: of Ether to the recipient address specified in the function. This function
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币发送到函数中指定的收款地址。这个函数
- en: is payable, which allows the funds to transfer to a receiver. Payable is a
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: new keyword in Solidity to specify whether a function or an address can
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: transfer or receive funds.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: One main functional security error with this smart contract is that
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: it does not check the privilege of the users calling the function. As this
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: function is public and payable, anyone can call this function and transfer
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: funds to an arbitrary address they specify. In fact, users can call this smart
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '324'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: contract to deprive all the funds owned by the smart contract and send
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: them to the hackers address. A simple error in function access scope can
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: cause loss of assets and destroy an otherwise promising project.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: No guarding of kill or selfdestruct function'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: There was a security incident in which a “kill” function is coded in
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: a smart contract but does not have privilege checking and eventually
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: caused 300 million in loss of funds. In a community Telegram chat group,
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: a transaction hash is posted. The message sender claimed to be a newbie
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: in Ethereum but had just sent a transaction to call a kill function in a
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: smart contract. Because the kill function does not check user privilege, the
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: function call was executed and effectively reset the storage of the smart
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: contract and destroyed the smart contract. The funds locked by this smart
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: contract are 300 million, and there is no way to recover it once the kill
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: function is executed.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Functions such as kill, destroy, selfdestruct, or renounce are highly
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: privileged operations that have the potential to invalidate a smart contract.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: It is critical to implement thorough checks on the calling parameters to
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: ensure there is no security risk when these functions are executed.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Security Practices for Smart Contracts**'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we described functional and attackable security holes
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: and some examples. As shown in Figure [8-2](#p337), we are now switching to
    the discussion of good security practices for designing smart contracts and
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: writing code.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '325'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-337_1.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-2\.** Best practice of blockchain security*'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '**Have a Security Risk Mitigation Plan**'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum and any public blockchains are open and permissionless
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: systems where bad players have the same access to the smart contracts as
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: good players. It is essential to have a mindset that there could be bugs and
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: security holes in the smart contract, and some mitigation plans should
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: be prepared. For example, in the smart contract of CryptoKitty, there is
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: a pause function implemented, and only the CEO can pause or unpause
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: the smart contract. If there is a security hack of smart contracts, the CEO
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: can send a transaction to call the pause function and halt the minting and
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: auction of CryptoKitties.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is important to consider the trade-off between
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: decentralization and upgradability. Blockchains are supposed to be
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: immutable, and therefore, the smart contracts by default should be
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: unalterable. On the other hand, there is no way to write Solidity code that
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 不可更改的。另一方面，编写Solidity代码的方式
- en: is free of bugs or vulnerabilities. A better practice is to classify the smart
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 没有bug或漏洞。一个更好的做法是将智能合约进行分类
- en: contracts into two classes – one is stable and cannot be updated, while
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 将智能合约分为两类——一类是稳定的且不可更新，而
- en: '326'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '326'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: the other is dynamic and can be upgraded by privileged administrators.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是动态的，可以通过特权管理员进行升级。
- en: The smart contracts that are called by Web3 clients can be proxy smart
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Web3客户端调用的智能合约可以是代理智能合约。
- en: contracts that are not upgradable and have a fixed address, while the other
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 不可升级且具有固定地址的合约，而另一种
- en: contracts that are called by the proxy smart contract can be upgraded.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代理智能合约调用的合约可以进行升级。
- en: Once a smart contract is upgraded due to bug fixes, the address of the
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约因修复bug而升级，其地址
- en: newly deployed smart contract is updated in the proxy smart contract, and
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 新部署的智能合约在代理智能合约中进行更新，并且
- en: there is no need to change the Web3 clients.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要更改Web3客户端。
- en: '**Checking Both Main Source Code and Libraries**'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查主源代码和库**'
- en: Not only can security vulnerabilities happen in the code you write, but also
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅你编写的代码中可能存在安全漏洞，而且
- en: they can exist in the libraries imported to your smart contract. The library’s
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以存在于导入到你的智能合约中的库中。库的
- en: code might also be written in different versions of Solidity and hence
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 代码也可能在不同版本的Solidity中编写，从而
- en: increase the complexities of integration and security risk. For example,
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了集成和安全风险的复杂性。例如，
- en: some of the libraries are written in Solidity version 0.4, while the main
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库是用Solidity 0.4版本编写的，而主
- en: smart contracts that you are working on might be in version 0.8\. Solidity
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在工作的智能合约可能是0.8版本。Solidity
- en: version 0.4 does not support certain security features, and modifications
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 0.4版本不支持某些安全特性，因此需要进行修改
- en: are needed to integrate the libraries. This in turn increases vulnerabilities
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 需要集成库。这反过来增加了漏洞
- en: for the whole smart contract. Therefore, it is important to have compatible
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 整个智能合约的兼容性。因此，拥有兼容性
- en: versions of main code and libraries, and the security review, audit, and test
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码和库的不同版本，以及安全审查、审计和测试
- en: should include library code as well.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 还应包括库代码。
- en: '**Put a Cap to the Max Funds**'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**设定资金上限**'
- en: Due to the complexity of smart contracts, sometimes, it is good to set a
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约的复杂性，有时设定一个
- en: maximum amount of asset values a smart contract function can handle. A
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约函数能够处理的最大资产价值量。A
- en: smart contract can have a global cap, and each function with asset transfer
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以有一个全局上限，每个带有资产转移功能的
- en: capability will compare the amount of assets to be transferred with the
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 能力将比较待转移的资产量与
- en: cap. If it exceeds the cap, the function will not execute the transfer. This
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 上限。如果超出上限，该功能将不会执行转账。这个
- en: provides an additional safety guard to prevent asset loss. In fact, the ERC20
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 为防止资产损失提供了额外的安全防护。实际上，ERC20
- en: smart contracts have an “approve” function to set the maximum amount of
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约有一个“批准”函数来设置资产的最大
- en: funds that can be transferred by a user calling a transfer function.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 用户调用转账函数可以转移的资金。
- en: '327'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '327'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: Because total values of cryptocurrency processed by smart contracts
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约处理的加密货币总价值
- en: are growing exponentially, projects such as Uniswap and Compound
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 以指数级增长，像Uniswap和Compound这样的项目
- en: have billions of dollars of assets managed by smart contracts. If there is
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十亿美元的资产由智能合约管理。如果存在
- en: a security breach with the smart contract code, the impact is huge. It is
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果智能合约代码中有安全漏洞，影响巨大。它是
- en: always a good practice to have a design to put a threshold on the amount
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 设定一个阈值始终是一个好习惯，以
- en: of funds that can be impacted if there is a security breach.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现安全漏洞，可能受到影响的风险基金。
- en: '**Make Your Smart Contract Open Source**'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '**让你的智能合约开源**'
- en: '**and Leverage the Community Effort to Harden**'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用社区力量加强安全**'
- en: '**the Security**'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**'
- en: Smart contracts are used to power the DeFi world where there are no
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约用于推动DeFi世界，其中没有
- en: central authorities and big IT teams to bring trust and security to the
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 中央权威机构和大型IT团队为智能合约带来信任和安全。
- en: platform. It is therefore important for the project community to play a
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 平台。因此，项目社区发挥重要作用是
- en: critical role in hardening the smart contracts. Unlike legacy financial
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 在加强智能合约方面发挥关键作用。与传统金融
- en: applications where software vendors use their engineering resources
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 软件供应商使用他们的工程资源
- en: and services to ensure security and quality, smart contracts are normally
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 以及服务以确保安全和质量，智能合约通常是
- en: open sourced so that the community and users can review the codes to
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 开源，以便社区和用户可以审查代码
- en: make sure that the business logics are accurately encapsulated in the
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保业务逻辑准确地封装在
- en: source code. Community developers are encouraged to review the source
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码。社区开发者被鼓励审查源
- en: code, and big bounties are provided for experts who are able to find any
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码，并为能够找到任何
- en: functional, cosmetic, or security defects. Smart contracts are also deployed
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性、美容性或安全性缺陷。智能合约也进行了部署
- en: to testnets first with alpha and beta releases, and communities are
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在测试网上进行alpha和beta测试，社区
- en: requested to find defects and rewarded with bug bounties. Because dApps
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 要求查找缺陷并奖励漏洞赏金。因为dApps
- en: powered with smart contracts are normally projects that can issue tokens,
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 由智能合约驱动的项目通常是能够发行代币的项目
- en: sometimes, community developers are rewarded with project tokens
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，社区开发者会被奖励项目代币
- en: when they find security issues or defects. Healthy and growing projects
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在发现安全问题或缺陷时。健康和发展的项目
- en: that manage billions of dollars of crypto assets always have enthusiastic
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数十亿美元加密资产的项目总是有热情
- en: community developers who work hard to improve the security of smart
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 社区开发者努力提高智能合约的安全性
- en: contracts.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 合约。
- en: '328'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '328'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '**Yes, There Are Blockchain Security Whitehats**'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，存在区块链安全的白帽子
- en: Sometimes, smart contracts get hacked with different endings. It happened
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，智能合约会被黑客攻击，结局各不相同。有时
- en: several times that “hackers” did not have intention to steal the fund, but
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: “黑客”没有盗窃资金的意图，但
- en: rather to teach a lesson to the project team. So if a security breach does
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 而是给项目团队一个教训。所以如果发生安全漏洞
- en: happen, it is important to watch where the funds get moved to. Hackers
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，关注资金流向很重要。黑客
- en: who have intention to use the stolen funds will normally transfer the fund
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 有意使用被盗资金的通常会转移资金
- en: to a “mixer” to hide the identity and remove the traceability of the fund.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 到“混合器”隐藏身份，消除资金的可追踪性。
- en: Whitehat hackers will just move the fund to a security location, tell the
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 白帽黑客会将资金转移到一个安全的位置，告诉
- en: project team about the security breach, let the project team fix issues, and
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 项目团队关于安全漏洞，让项目团队修复问题，然后
- en: then move the fund back. So if a security breach does happen, don’t panic;
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果发生安全漏洞，不要恐慌；
- en: the result might not be as bad as it looks.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能没有看起来那么糟糕。
- en: '**Have Smart Contract Audited**'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能合约要进行审计**'
- en: Smart contracts auditing is a good practice to harden security. A security
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约审计是加强安全性的良好实践。一项安全
- en: audit is a practice to hire an external professional company to evaluate and
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 审计是聘请外部专业公司评估和
- en: review token economy, smart contracts design, and code implementation.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 审查代币经济、智能合约设计、代码实现。
- en: Auditors use automatic security scanning tools and manual penetration
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 审计师使用自动安全扫描工具和手动渗透
- en: testing to produce a thorough report of the smart contracts. The security
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试以产生对智能合约的彻底报告。该安全
- en: scan of smart contracts can reveal static security errors in syntax and
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描智能合约可以揭示语法中的静态安全错误
- en: programming styles. More in-depth review of smart contracts will require
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 编程风格。对智能合约的更深入审查将需要
- en: experts to go through each smart contract in UML diagrams and figure out
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 专家通过UML图例逐个审查智能合约并找出
- en: the relationship between functions and inspect potential vulnerabilities.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数之间的关系并检查潜在漏洞。
- en: Sometimes, meetings are held by the project team and audit team to go
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，项目团队和审计团队会举行会议
- en: through the smart contract design to figure out if the end-to-end flow has
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能合约设计来确定端到端流程是否
- en: security issues. Any issues found are labelled with severity levels, and
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题。发现的任何问题都应标明严重等级，并
- en: critical issues will need to be fixed in order for the product to be released.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题需要修复，以便产品发布。
- en: A security audit can not only improve security of smart contracts from
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 安全审计不仅可以提高智能合约的安全性
- en: catastrophic failure, it is also required when the project team later decides
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: to work with other partners or wants to license their smart contracts to
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '329'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: other companies. Security audits have been a growing business in the
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: blockchain industry, and there are often backlogs with audit requests.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: Expedited audit normally requires much higher fees; therefore, security
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: audit time should be built into the project release schedule.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '**Readable Smart Contract Logic**'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that smart contracts have high VLC (value per line of
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: code). It is extremely important to make sure smart contract logic is
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: straightforward and easy to read. If you read smart contract codes of good
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: projects, you will probably find out that often there are more comments
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: than source code itself. The comments are there to help readers to
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: review and make sense of the source code. If you strip the code out of the
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: Solidity file, you will find that the comments are actually good design and
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: documentation for the smart contract functions. Good smart contracts are
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: written and documented in a way that both technical and business experts
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: can read it and get a good picture of the business logic.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularize the Smart Contract**'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is an object-oriented programming (OOP) language where you
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: can use hierarchy, inheritance, and polymorphy mechanisms to define
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: classes and functions similar to Java and JavaScript. A good practice
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: of modularizing smart contracts is to mimic the real-world scenarios
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: and build the smart contracts as the components of the corresponding
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: business logic.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '330'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Well-Tested Libraries**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Relevant to modularization, using well-tested libraries is another way
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: to increase security. Since the majority of smart contracts are open
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: source, there are many handy and secure libraries that have been built
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: and available for use. For example, OpenZeppelin provides a good set of
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: libraries such as SafeMath, ERC20, and ERC721, while Oraclable provides
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: Oracle libraries to use.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: Well-established library code normally has better boundary checking
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: for their smart contract functions. For example, SafeMath libraries
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: have checks on the arithmetic data type ranges and division checks for
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: denominators equal to zero case. Using library code from a well-tested
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: project decreases the uncertainty of the main code.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a Good Random Number Generator**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: In gaming applications, sometimes, smart contracts use a Random
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: Number Generator (RNG) to generate a random number to pick a winner
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: from a group of users. RNG is also used to enhance security by grouping
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: actors randomly to prevent collusion. It is generally not a good idea to
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: roll out your own RNG without a sound mathematical validation and
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: thorough testing of the degree of randomness in RNG. For example,
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: using the hash value of a blockchain block might seem to be random for
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: some applications. However, if the smart contract of the dApp is handling
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: large-scale and high-value gaming similar to Powerball, the randomness
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Powerball的大型和高价值游戏，随机性
- en: of blockchain hash is attack prone. A block producer can add or remove
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链散列是攻击易发的。区块生产者可以添加或删除
- en: transactions in a proposed blockchain block and provide a manipulated
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 在拟议的区块链区块中处理交易并提供操纵的
- en: hash. At this time, there is not a perfect RNG onchain, and full randomness
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 散列。此时，链上没有完美的RNG，完全随机性
- en: has to be introduced through offchain computing and brought into
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 需要通过离链计算引入并带入
- en: blockchain by using Oracle.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Oracle来实现区块链。
- en: '331'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '331'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '**Review Gas Consumption in Security Context**'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '**在安全环境中审视气体消耗**'
- en: Gas usage and fees are designed as a way to compensate miners and increase
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 气体使用和费用是为了补偿矿工和增加
- en: the cost of deliberate attack on the Ethereum network. In a smart contract
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 对以太坊网络的故意攻击成本。在智能合约中
- en: transaction, each function and storage will consume gas, and the gas cost is
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 每笔交易，每个函数和存储都会消耗气体，并且气体成本是
- en: paid by the user who sends the transactions to the smart contract. There are
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 由发送交易到智能合约的用户支付。有一些
- en: several security factors to consider when dealing with gas consumptions in
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理气体消耗时需要考虑几个安全因素，
- en: smart contracts. In a dApp application, if a proxy is used to send transactions
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约。在dApp应用程序中，如果使用代理发送交易
- en: for users, then it is important to review the functions to see if the gas
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，重要的是要审查函数，以查看气体的
- en: consumption is a fixed value and if there is a potential for the function to
    get
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 气体消耗是一个固定值，如果函数有可能
- en: into an infinite or large loop and deprive the Ether of the sender’s account.
    In
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个无限或大型循环，剥夺发送者的以太币账户。在
- en: general, smart contracts should be designed and written in a way to minimize
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，智能合约应该以最小化
- en: gas consumption. To achieve these, special attention should be given to avoid
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 气体消耗。为了实现这些目标，应特别注意避免
- en: while-loops for long operations, large dynamic arrays for data storage, and
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间操作的while-loop，大量动态数组用于数据存储，以及
- en: complex function calls across smart contracts. When writing smart contracts,
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约之间的复杂函数调用。在编写智能合约时，
- en: there are some gas estimate tools to help check the usage of gas in the code.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些气体估算工具可以帮助检查代码中的气体使用情况。
- en: There is also a gas consumption table published by the Ethereum Foundation
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊基金会还发布了一份气体消耗表
- en: as a guide to optimize gas performance for smart contracts.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为优化智能合约气体性能的指南。
- en: '**Wisely Use Blockchain**'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '**明智地使用区块链**'
- en: Some people have misconceptions that blockchain can solve all
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人误以为区块链可以解决所有
- en: problems that conventional IT technologies cannot solve today. To some
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 传统IT技术无法解决的问题。对一些人来说
- en: extent, blockchains do solve challenging problems such as consensus,
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，区块链确实解决了诸如共识等挑战性问题，
- en: decentralization, permissionless, and token economy. However, today,
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化、无需许可和代币经济。然而，今天，
- en: there are still many drawbacks for blockchain technology. For example,
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术仍然存在许多缺点。例如，
- en: when a smart contract is executed, it runs on thousands of machines
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 当智能合约执行时，它将在数千台机器上运行
- en: simultaneously. In fact, the Bitcoin blockchain has over 20,000 mining
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 同时。实际上，比特币区块链拥有超过20,000个采矿
- en: nodes, and Ethereum has thousands of nodes. All Ethereum nodes will
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，以太坊有数千个节点。所有以太坊节点将
- en: have the same deployed smart contract and will run smart contracts to
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同部署的智能合约，并将运行智能合约来
- en: process the transactions. With this scale of redundancy in the blockchain,
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 处理交易。在区块链中，这种冗余的规模
- en: it drastically decreases overall performance and increases risks when
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 大大降低了整体性能并增加了风险，
- en: something actually goes wrong.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实际发生故障，该怎么办。
- en: '332'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '332'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: So from a security point of view, in a dApp architecture and design,
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从安全角度来看，在dApp架构和设计中，
- en: it is a better practice to use blockchain for the system that requires
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用区块链来处理需要
- en: decentralization, multiparty consensus, immutability, and transparency.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化、多方共识、不可变性和透明性。
- en: For components such as UI (User Interface), dynamic content storage,
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UI（用户界面）等组件和动态内容存储，
- en: temporary data, and heavy computations, these can be done offchain.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 临时数据和繁重的计算，这些可以离链完成。
- en: Take the example of CryptoKitty; the minting, gene generation, and
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 以CryptoKitty为例；铸造、基因生成和
- en: management of kitty auctions are done onchain, while the UI and
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 管理猫拍卖是在链上完成的，而UI和
- en: rendering of kitty are done offchain. Well-balanced onchain and
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 猫的渲染是在链下完成的。平衡的链上和
- en: offchain components of decentralized applications increase usability,
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用的离线组件增加了可用性，
- en: upgradability, performance, and security.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 可升级性，性能和安全性。
- en: '**Stay on Top of Security Breaches and Patches**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注安全漏洞和补丁**'
- en: Blockchain is far away from a stabilized state, and security breaches
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链离稳定状态还远，而且安全漏洞
- en: happen quite often. So it is helpful to subscribe to blockchain security
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发生。因此，订阅区块链安全
- en: news alerts and evaluate any hacks that might impact your projects.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅区块链安全
- en: Blockchain hacks always get to the headline of the media. In the Ethereum
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链攻击总是出现在媒体头条。在以太坊
- en: community, workaround, security vulnerabilities are discussed and shared
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 社区，绕过，安全漏洞被讨论和分享
- en: quite timely. It is important to have action plans if the security breaches
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 非常及时。如果出现安全漏洞，制定行动计划很重要
- en: impact your smart contracts deployed in the production network.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 影响您在生产网络上部署的智能合约。
- en: It is also best practice to upgrade the smart contract code to the
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践也是升级智能合约代码到
- en: latest version of Solidity as soon as possible. This is easy to say but is very
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽快升级到Solidity的最新版本。这是说起来容易，但实际上
- en: difficult to actually do. Once the smart contracts are deployed, they cannot
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上做起来非常困难。一旦智能合约被部署，它们无法
- en: be patched due to immutability of blockchain. An upgrade will require
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链的不可变性，需要打补丁。升级将需要
- en: abandoning the old smart contract and deploying a brand new one. Also
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃旧的智能合约并部署全新的一个。另外
- en: there are various versions of Solidity programs coexisting in smart contract
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约中存在各种版本的Solidity程序
- en: libraries and production codes. There are incompatibilities among
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 库和生产代码。在它们之间存在不兼容
- en: different versions of Solidity compilers. Before deploying a smart contract,
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的Solidity编译器版本。在部署智能合约之前，
- en: it is best to upgrade all source code for both main smart contracts and
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 最好升级主智能合约和
- en: libraries to the latest version.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 库更新到最新版本。
- en: '333'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '333'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: Also there are some good security analysis and visualization tools
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些好的安全分析和可视化工具
- en: that can be used to help developers write secure smart contracts. Security
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 可以帮助开发者编写安全的智能合约。安全性
- en: scanning tools can help developers to spot static security vulnerabilities
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以利用静态安全漏洞的扫描工具
- en: and follow good security coding practice. Visualization tools help
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 并遵循良好的安全编码实践。可视化工具帮助
- en: developers and reviewers to see the whole picture of the smart contracts
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者和审查员查看智能合约的全貌
- en: and analyze potential attacking points from hackers.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 从黑客那里分析潜在的攻击点。
- en: '**Blockchain Specific Security Tips**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链特定安全提示**'
- en: For programmers who used to develop stand-alone applications or web
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过去开发独立应用程序或网络
- en: services, it should be noted that blockchains have some special properties
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，区块链有一些特殊属性
- en: and pitfalls to watch and avoid.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免的陷阱。
- en: When doing cross smart contract function calls, the calling function
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行跨智能合约函数调用时，调用函数
- en: will take in the address of another smart contract and call the bytecode of
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 将传入另一个智能合约的地址并调用该智能合约的字节码
- en: a target function. Sometimes, that target function might contain malicious
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数。有时，该目标函数可能包含恶意
- en: codes and alter the control flow of the calling function. It is very important
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并更改调用函数的控制流。非常重要
- en: to inspect the source code of the target smart contract to ensure it is free
    of
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 检查目标智能合约的源代码，确保它没有
- en: security vulnerability. If the address of the target smart contract is passed
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞。如果目标智能合约的地址被传递
- en: in from outside, it is vital to ensure that only privileged users can pass in
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部传入，确保只有特权用户可以传入
- en: the target address.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 目标地址。
- en: Ethereum blockchains are public, decentralized, and permissionless. If
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum区块链是公开的，去中心化的，无需许可的。如果
- en: there is any function in a smart contract that is declared as public, anybody
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约中声明为公共的任何函数，任何人
- en: in any part of the world can call that function and pass in arbitrary
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上任何地方的人都可以调用那个函数并传入任意
- en: parameters. So it is important to double-check the scope of function and
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。因此，确保函数范围和
- en: have parameter check for all permutations that might cause security
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: breach. Public functions in smart contracts are globally public and can be
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: called in any order with any data. Therefore, it is extremely important to
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'check the following attributes for a smart contract function:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: • **Scope of function** – Declare whether it is public or
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: private, or view.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '334'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: • **Scope of access** – Check who can call the function,
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: maybe only owner, or only a predefined user role.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: • **Parameter permutation** – Check parameter range of
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: data. Check validity of inputs.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain’s intrinsic security has some constraints. When
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: a variable is declared in a smart contract, it can be a private variable.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: However, a private variable is really not private as the Ethereum Virtual
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: Machine (EVM) installed on blockchain nodes can reveal it. To ensure
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: privacy of data in smart contracts, the data should be encrypted before
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: sending to blockchain and then decrypted after receiving from the
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: blockchain. Because of the transparency of public blockchain, onchain
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: data encryption and decryption are not secure in smart contracts. The
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: execution steps and internal data are viewable with an EVM with debugger
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: enabled. The encryption and decryption should be performed through
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: offchain computing.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: For decentralized applications that need to use time sequence in
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: computing, it is important to know that timestamps in blockchain are
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: not accurate because miners can manipulate the block time by delaying
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: or accelerating block computation and proposal. It is not a good practice
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: to use block timestamp to check for sequencing execution and ordering
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: transaction steps. The timestamp of blockchain or transactions should not
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: be used as a unique identifier for multiple events as there is no guarantee
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: of block timestamp collision within the range of seconds.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: Security needs to be considered in all life cycles of smart contract
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: development, from conceptions, requirements, token design, architecture,
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: to implementation and operations. One important security factor to
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: consider is safe-guarding private keys in the deployment process. Crypto
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: assets are stored in accounts, and each account is represented by a private
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: and public keypair. Private keys are used to sign transactions to send assets
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: from one user to another. Whoever has the private key of an account owns
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: the asset of that account. When deploying a smart contract to a blockchain,
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '335'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: there needs to be a user who sends the deployment transaction to the
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: blockchain. To sign a transaction, the user needs to unlock the account
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: with its private key. If an account is unlocked in a blockchain, its private
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: key is open and can be stolen by a spoofer. This has happened many times
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: in the cryptoworld.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: There are several secure ways to deploy smart contracts. For example,
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: users can use a hardware wallet or use an offline wallet for the deployment.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the private keys are kept in separate devices, and only
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，私钥都保存在单独的设备上，只有
- en: signed transactions are copied to the online system to be sent out to the
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 签署的交易复制到在线系统，发送给
- en: blockchain. Since a private key will never leave a dedicated device without
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。由于私钥永远不会离开专用设备，
- en: network communication, it is completely secure unless the device is
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信，除非设备被
- en: physically tempered.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 物理上的 tempering。
- en: '**Security Impact of Quantum Computing**'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算对安全的影响**
- en: The security impact of quantum computing has been a major concern of
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的安全影响一直是
- en: the blockchain community. People worry if the supremacy of quantum
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的统治地位
- en: computing will nullify blockchain advantages and bring cryptocurrency
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 计算将使区块链优势化为乌有，并给加密货币
- en: value to zero. Quantum computing is a revolutionary technology that
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 值变为零。量子计算是一种革命性技术，
- en: takes advantage of quantum physics’ amazing principles and phenomena
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 利用量子物理学惊人的原理和现象
- en: such as superposition, entanglement, and measurement uncertainty. In
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 如超position、纠缠和测量不确定性。在
- en: quantum computing, a qubit is used to represent the “0” and “1” state of
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算中，一个量子位用来表示“0”和“1”的状态
- en: a quantum system, similar to bits in conventional computing. Multiple
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 量子系统，类似于传统计算中的位。多个
- en: qubits can be built into a register to become a compute and storage unit
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 量子位可以构建到寄存器中，成为计算和存储单元
- en: for quantum computing. Quantum computing provides much higher
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算。量子计算提供了更高的
- en: computing power and is going to impact blockchain in the following areas.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力，并将对区块链以下领域产生影响。
- en: The hashing algorithm of sha-256 or sha-3 will no longer be valid. A
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于shab-256或shab-3的哈希算法将不再有效。一个
- en: hashing algorithm is a one-way function that takes in an input string and
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希算法是一种单向函数，输入一个输入字符串并
- en: produces a fixed length output string. One important requirement for
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 生成固定长度的输出字符串。对于
- en: hashing is that different inputs should generate different outputs. Also,
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的不同输入应该产生不同的输出。此外，
- en: '336'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '336'
- en: '![](index-348_1.jpg)'
  id: totrans-1366
  prefs: []
  type: TYPE_IMG
  zh: '![](index-348_1.jpg)'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 第八章 安全考虑
- en: there should not exist a way to reversely compute an input from its hash
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该存在一种从其哈希反向计算输入的方法
- en: value. With quantum computing, these rules will be broken, and any
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 值。有了量子计算，这些规则将被打破，任何
- en: system that relies on hashing such as SHA256 will need to be overhauled.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于哈希的系统，如SHA256，需要彻底改动。
- en: The asymmetric public key–private key signature algorithm such as
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称公钥-私钥签名算法，如
- en: ECDSA or DSA that uses elliptic curve cryptography will no longer be
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用椭圆曲线密码学的ECDSA或DSA将不再有效
- en: secure. Quantum computing can compute private keys from public keys or
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 安全。量子计算可以从公钥计算私钥或
- en: break a signed message from a private key.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 从私钥签署的消息中break。
- en: The impact of quantum computing on cryptography will in turn
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算对密码学的影响反过来
- en: impact the security of blockchain in areas as shown in Figure [8-3](#p348).
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 影响区块链安全的领域，如图8-3所示。
- en: '***Figure 8-3\.** Impact of quantum computing on blockchain security*'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3。量子计算对区块链安全的影响*
- en: The fundamental immutability of blockchain will be impacted. Blocks
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的基本不可变性将受到影响。区块
- en: in blockchains are uniquely identified by their block hashes. If hashes
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的每个区块都通过其区块哈希唯一标识。如果哈希
- en: are no longer secure and can be manipulated with quantum computing,
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 不再安全，可以利用量子计算进行操作，
- en: then blockchain can be altered with data changed inside but still keeps its
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后区块链可以被修改，内部数据改变但仍然保持其
- en: hashes on the chain.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 链上的哈希。
- en: The crypto assets are no longer secure because the private keys that
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币不再安全，因为私钥可能
- en: control asset accounts can be hacked with a quantum computer.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 控制资产账户可以用量子计算机hack。
- en: The P2P network layer communication will no longer be secure.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点网络层通信将不再安全。
- en: Ethereum uses secp255k1 for nodeKey and nodeId generation. As
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用secp255k1生成nodeKey和nodeId。随着
- en: secp256k1 will no longer be secure, the client node identification and
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: secp256k1将不再安全，客户端节点标识和
- en: communication mechanism will need to be changed.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 通信机制需要改变。
- en: The smart contract of Ethereum blockchain is no longer valid because
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的智能合约将不再有效，因为
- en: the owner of the smart contract can be hacked as well.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的所有者也可能被hack。
- en: All transactions signed with private keys with ECDSA and SECP256 are
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 所有使用ECDSA和SECP256私钥签署的交易
- en: no longer valid, and new algorithms will need to be used.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 不再有效，需要使用新的算法。
- en: '337'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '337'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: Even the proof-of-work (POW) consensus will be impacted. The POW
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是工作量证明（POW）共识也会受到影响。POW
- en: is based on computing a matching hash to validate a miner who proposes
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 基于计算匹配散列来验证提出
- en: a block. With quantum computing, the computation is so fast, and those
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块。有了量子计算，计算速度如此之快，那些
- en: with quantum computing power will build the longest chain, hence
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 具有量子计算能力将建立最长链，因此
- en: breaking the 51% computing power role.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 突破51%计算能力角色。
- en: To mitigate quantum computing supremacy, there are several key
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解量子计算优势，有几个关键
- en: items to consider.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑事项。
- en: Firstly, Ethereum 2 is moving from POW to POS (proof of stake). This
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以太坊2正在从POW转移到POS（权益证明）。这个
- en: will mitigate the impact of quantum computing on consensus.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻量子计算对共识的影响。
- en: Secondly, there are quantum-resistant signature schemes developed
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，已经开发出量子抗扰签名方案
- en: already, including Lamport, XMSS, and SPHINCS.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 已经包括Lamport、XMSS和SPHINCS。
- en: Thirdly, the security compact of quantum computing is not just
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，量子计算的安全性不仅仅是
- en: on blockchain, it is on all cryptography and network computing. The
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链上，是所有密码学和网络计算。
- en: quantum solutions worked out in the general field can be ported to
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 量子解决方案在通用领域制定，可以移植到
- en: blockchain.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: Fourthly, the solution for the impact of quantum computing on
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，缓解量子计算对
- en: blockchain security might go beyond the technology side of blockchain.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链安全可能超出区块链技术方面。
- en: There might be some legal regulations to prohibit using quantum
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些法律规定禁止使用量子
- en: computing power to hack information and blockchain systems. Similar
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力来破解信息和区块链系统。类似
- en: to the nuclear nonproliferation policy, there might be some restriction on
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 到核不扩散政策，可能会有一些限制
- en: quantum devices released to the public domain.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 量子设备发布到公共领域。
- en: It is very important to follow the development of quantum computing
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循量子计算的发展非常重要
- en: and stay on top of the mitigation plans and get ready to make critical
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 关注缓解计划并在准备做出关键
- en: decisions. With IBM on the way to release 1000 qubit devices and Google
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 决策。随着IBM即将发布1000个量子位设备，谷歌
- en: making the leap jump on quantum computing, it is inevitable that
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算上迈出飞跃，不可避免地
- en: computing will challenge and threaten the security of blockchain. It is
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 计算将挑战和威胁区块链的安全。这是
- en: highly recommended to learn about quantum computing technology
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议学习量子计算技术
- en: and get ready to accept quantum-resistant technology for Ethereum
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 准备接受对以太坊的量子抗扰技术
- en: blockchain.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: '338'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '338'
- en: Chapter 8 SeCurity ConSiderationS
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 安全考虑
- en: '**Summary**'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In summary, we just cannot overemphasize the importance of security
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们强调安全的重要性
- en: in blockchains. Security breaches and bad things have happened in the
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链中。安全漏洞和坏事在
- en: past, are happening now, and will happen in the future. So when you write
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，现在正在发生，将来也会发生。所以当你写
- en: Solidity smart contracts, make sure the security procedures are followed;
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Solidity智能合约的安全程序遵循；
- en: always go above and beyond to let the community test the smart contracts
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 总是超越让社区测试智能合约
- en: out before rolling them out to the blockchain mainnet.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 在将它们推出到区块链主网之前。
- en: '339'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '339'
- en: '**CHAPTER 9**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章**'
- en: '**Layer 2 and**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2层和**'
- en: '**Ethereum 2**'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊2.0**'
- en: '**Problem with Ethereum Mainnet**'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊主网问题**'
- en: The Ethereum mainnet is designed as a public blockchain rather than an
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊主网被设计成公共区块链，而不是
- en: Enterprise platform; hence, it lacks privacy, performance, scaling, and
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 企业平台；因此，它缺乏隐私、性能、可扩展性和
- en: permissioning capacities.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 许可能力。
- en: With regard to privacy, Ethereum mainnet stores all data in a
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隐私，以太坊主网将所有数据存储在一个
- en: permissionless fashion, and everyone has access to the data. All sensitive
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 无需许可的方式，每个人都有访问数据的权限。所有敏感
- en: data will need to be encrypted before being sent to the blockchain,
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在发送到区块链之前需要加密，
- en: and transactions need to be obfuscated through smart contracts. Some
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 和交易需要通过智能合约进行模糊处理。有些
- en: institutes and states will not allow certain categories of data to be
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 机构和州不会允许某些类别的数据
- en: published to the public blockchain. Thus, the use of the public mainnet is
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 发布到公共区块链。因此，公共主网的使用
- en: limited to storing hashes or URLs of data resources. The original data are
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: stored in private blockchains or nodes, and verified through public chains
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: and channels.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: For performance and scalability, Ethereum mainnet has already
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: hit a bottleneck. The release of CryptoKitties has caused congestion in
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: the Ethereum blockchain. Transaction fees have reached over $100 per
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: transaction and hence limit feasible transactions to high-value and
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: low- frequency applications. In order to speed up transactions, sometimes,
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: © Weijia Zhang and Tej Anand 2022
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: '341'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_9](https://doi.org/10.1007/978-1-4842-8164-2_9#DOI)'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-352_1.jpg)'
  id: totrans-1459
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: users have to set high gas prices to increase the chance for their
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: transactions to be included by miners to their proposed blocks.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: For permissioning, public blockchains are designed as permissionless,
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: but there are use cases where applications do want to have access control
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: due to security and regulation considerations. The “public” nature of
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet deters some uses such as certificate issuance and
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: personnel database.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: To solve the issues in Ethereum mainnet, many Ethereum
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: Improvement Proposals and solutions have been proposed, including
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 and Ethereum 2\. In this chapter, we discuss new scalability
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: technologies for Ethereum, including layer 2 and Ethereum 2\. The
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: following illustration (Figur[e 9-1) sho](#p352)ws the classification of scalability
    solutions of Ethereum, and they are explained in detail in their respective
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: sections.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-1\.** Overview of scalability solutions for Ethereum*'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchain*'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '342'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer 2 Technology**'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2 is a suite of technologies to improve the performance and
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: scalability of Ethereum layer 1 mainnet by moving the computing and
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: storage of transactions from onchain to offchain through smart contracts.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: Onchain transactions require running EVM on all nodes and storing
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: all states on Ethereum blockchain, hence decreasing performance and
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: scalability. The mechanism for the layer 2 solution is to move some of the
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: transactions off the main chain and only record the vital information on
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: the mainnet to ensure security and transparency. One major difference
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: between layer 2 and Ethereum 2 is that layer 2 uses smart contracts to
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: connect offchain resources to the mainnet and thus does not require
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: the mainnet blockchain to have a hard fork. Layer 2 solutions can be
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: implemented by third-party projects using the existing Ethereum mainnet.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: There are several L2 mechanisms that are available, including state
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: channel, plasma, and rollup; each has its own unique features.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum State Channel**'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: State channel is one of the layer 2 solutions that allow two or more
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: participants to send transactions among themselves offline and only
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: send the beginning and final transactions of the state channel cycle to
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: the mainnet blockchain. This way, mainnet is used as an escrow and
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: auditing platform for the trusted channel between two or multiple parties.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: For example, a state channel can be built as a proof of authority (POA)
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: or Byzantine Fault Tolerance private blockchain that is permissioned
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: for the participants only. To make it simpler, the private blockchain
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: can be replaced with a smart wallet that can connect with other wallets
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: and record the transactions among them. Participants use the private
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: blockchain or smart wallet as a state channel to do fast and low cost
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: transactions.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '343'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-354_1.png)'
  id: totrans-1507
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate a use case of a state channel, we use a payment system of
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: a construction company in which the builder needs to record contracting
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: employees earning on daily bases and pay them on a monthly basis. If the
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: daily transactions are recorded on the blockchain, that would increase
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: transaction fees dramatically as the cost for gas fees could reach $100 per
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: transaction. Using the state channel, the owner of the company can pay
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: daily transactions with the state channel and only pay employees the lump
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: sum each month. This will save the cost at roughly 1/30 of the original cost.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: The topology and workflow of a state channel is shown in the following
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 'diagram (Figure [9-2](#p354)):'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-2\.** Topology and workflow of state channel solutions*'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the schema of a state channel that has
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: 'the following components:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: • State channel smart contract is deployed to the
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: mainnet.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: This smart contract is multisigned, and not a single user can alter or
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: delete the smart contract.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '344'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: The state channel smart contract can accept deposits for users and
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: create a state channel for a group of users. The depositor needs to specify
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: the participants’ account addresses.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: The state channel smart contract also has functions to (a) process
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: multisign signatures and distribute funds to participants and (b) process
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: audit requests from any of the participants by accepting evidence sent by
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: any participants.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: • Each user can have a state channel wallet (SC wallet).
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: The wallet can interact among participants by sending transactions,
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: requesting receipts, or multisigning a transaction for the main chain. The
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: wallet also has storage to store local copies of the transaction history and
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: receipts.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow is as follows:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: • A payer uses a crypto wallet to deposit ether assets
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: to the state channel smart contract and specify the
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: payees’ accounts who will receive payments.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: • The smart contract creates a record and returns a
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: deposit record with balance and payee addresses.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: The payee addresses are also recorded by the smart
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: contract to process claims or audit requests.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: • The payer gets the deposit receipt and starts sending
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: payments through offchain signed transaction to
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: payees. For each transaction, the state channel wallet
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: will update the account balance offchain and have
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: signed receipt for both sender and receiver. These
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: transactions are offchain and hence have a low
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: transaction fee or even no fee.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '345'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: • Once the operation of the state channel is completed,
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: the offchain transactions will need to be transferred
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: to the mainnet, and each participant’s balance will
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: need to be updated. Each participant will check the
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: local copy of their transaction receipt and sign the exit
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: state channel transaction. Once the exit transaction
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: is multisigned by all parties, it is sent to the mainnet
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: state channel smart contract for processing. The
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: mainnet smart contract will verify the information
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: and then distribute the deposited funds to respective
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: participants.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: • If any of the participants does not sign the transaction,
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: the other participants can send a transaction to call the
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: smart contract’s claim or audit function and provide
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: the needed local receipt as proof. If the state channel
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: smart contract verifies the payer frauds, the deposited
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: balance of the payer can be slashed.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: There are different implementations for layer 2 state channel solutions.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned, we have offchain computing and storage built into
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: the state channel wallet. This will increase the footprint of the wallet and
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: need to customize the crypto wallet. Another solution is to implement
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: the state channel offchain computing through a private blockchain using
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: permissioned consensus such as proof of authority (POA) or Byzantine
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: Fault Tolerance (BFT) blockchain. The private blockchain can process
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: and record transactions among state channel participants. Only the entry
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: and exit transactions of the state channel will be sent to mainnet for
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: security and persistent record. The wallet can be a regular wallet such as a
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask wallet that can switch from mainnet chain to private chain for
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: state channel transactions.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '346'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: Although state channels can improve scalability for Ethereum
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: by moving transactions offchain, there are some limitations for this
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: mechanism. First, state channel participants need to actively participate
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: in the transactions. Their accounts will need to be registered in the state
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: channel smart contract. A sender cannot send transactions to an arbitrary
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: address not in the channel. Secondly, all state channel participants will
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: need to be actively involved in the transactions by verifying transactions
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: and multisign exit transactions. Thirdly, since the mainnet only has the
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: initial state and final state, it will need to rely on the offchain participants
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: to provide proof if there are discrepancies with the state channel
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: transactions. Needing participants to be involved to secure state channels
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: is a big drawback and makes it difficult to develop a generalized solution
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: for state channels.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '**Plasma As a Layer 2 Technology**'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Plasma is another layer 2 scaling solution that uses smart
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: contracts to link external blockchains with Ethereum mainnet as a security
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: and arbitration platform. These children blockchains are called plasma
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 以及仲裁平台。这些子区块链被称为plasma
- en: chains, and their blockchain transaction records are merkelized, and the
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 链，以及它们的区块链交易记录被合并（merkelized），并且
- en: roots of the Merkle tree are sent to mainnet to be stored as proofs.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树的根节点被发送到主网作为证据存储。
- en: The preceding diagram (Figure [9-3](index_split_006.html#p358)) shows the components
    and
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表（图[9-3](index_split_006.html#p358)）展示了组件和
- en: workflow of plasma blockchain working as a layer 2 solution.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: plasma区块链作为第二层解决方案的工作流程。
- en: '347'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '347'
