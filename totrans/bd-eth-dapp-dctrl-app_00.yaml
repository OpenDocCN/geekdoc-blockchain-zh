- en: Part 1\.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part 1](#part01) is a high-level introduction to Ethereum Dapps and related
    technologies. [Chapter 1](kindle_split_012.xhtml#ch01) introduces decentralized
    applications. [Chapter 2](kindle_split_013.xhtml#ch02) presents the blockchain
    and smart contracts. In [chapter 3](kindle_split_014.xhtml#ch03), you’ll meet
    the Ethereum platform, including the Ethereum Virtual Machine (EVM), the Go Ethereum
    (geth) client, and the Ethereum wallet. In this part, you’ll establish the foundation
    you need to progress through the book. You’ll also implement your first Dapp—a
    simple cryptocurrency—and, in [chapter 4](kindle_split_015.xhtml#ch04), deploy
    it on a public test network.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1\. A first look at decentralized applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: What a decentralized application is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a Dapp looks like and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapp terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable and less suitable Dapps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'How many times have you found yourself in the following situation? You were
    browsing around to buy the latest gadget and were comparing prices online, when
    you came across [SmallWebRetailer.com](http://SmallWebRetailer.com) that was offering
    it 30% cheaper than [WellKnown.com](http://WellKnown.com). You quickly put the
    item in the basket, fearing the price would rise at any moment, and entered your
    postal address and credit card details, but suddenly...you got cold feet. You
    started to wonder: Is the price too good to be true? What if this unknown [SmallWebRetailer.com](http://SmallWebRetailer.com)
    is a scam? Will they run off with my money? After a few minutes of hesitating
    on the Buy button, you opened a new browser tab and went straight to [WellKnown.com](http://WellKnown.com).
    You submitted the order, aware you might have overpaid 30% for your gadget.'
  prefs: []
  type: TYPE_NORMAL
- en: Why did you panic? Perhaps you didn’t trust [SmallWebRetailer.com](http://SmallWebRetailer.com).
    Perhaps you didn’t want to waste your time contacting the credit card company
    and possibly waiting for a refund if the transaction turned sour.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you could’ve bought the gadget from the same small, unknown retailer
    through an “alternative e-commerce application” that guaranteed the seller couldn’t
    access your money until you’d confirmed safe delivery of your order? What if that
    guarantee hadn’t been provided by the seller or by a single third party, but by
    many independent parties participating in a platform designed to process transactions
    according to conditions encoded in software anyone could inspect? Hold on, probably
    I’ve said it too fast. I’ll repeat it more slowly:'
  prefs: []
  type: TYPE_NORMAL
- en: What if the money transfer was held until delivery, not by the retailer or a
    third party but by many participants in the platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if the rules for escrowing and then releasing the money transfer were encoded
    in logic, not subjected to manual interaction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if, in case you were still unconvinced, you could inspect the code yourself?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I bet you’d click Buy, confident your funds would be safely stored on this platform
    until the delivery arrived. Such systems do exist, and they’re called *decentralized
    applications*. Decentralized marketplaces, such as OpenBazaar ([https://openbazaar.org/](https://openbazaar.org/)),
    work this way. The mechanism by which funds are routed to the seller only when
    you’ve confirmed safe delivery of the goods is called a *smart contract*.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized applications, also known as *decentralized apps* or *Dapps* (generally
    pronounced dee-apps), are part of a new wave of web applications meant to increase
    the transparency around commercial transactions, governmental processes, supply
    chains, and all those systems that currently require mutual trust between customer
    and supplier, user and provider. The objective of Dapps is to minimize or eliminate
    the need for any trust between the participants in a system interaction, with
    the aim of empowering users beyond what Web 2.0 has delivered. Some claim Dapps
    could be the backbone of Web 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have programming experience—even better if it’s in JavaScript—and
    some familiarity with web applications, this book will teach you how to build
    Dapps made of one or more smart contracts controlled by a user interface. By the
    end of this book, you’ll be able to not only write smart contract code but design,
    implement, test, debug, deploy, and secure a full end-to-end decentralized application.
    Along the way, you’ll also learn a new language, a new platform, and, most of
    all, a new way of thinking about, designing, and running applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this first chapter, I’ll give you a high-level overview of Dapps. I’ll explain
    in detail what they are, what they look like, what technology stack they’re built
    on, and when it makes sense to build them. Best of all, I’ll help you start building
    your own! Let’s start our journey.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. What is a Dapp?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before I talk about decentralized applications, I’ll refresh a concept you’re
    already familiar with, most likely without realizing it: that of a *centralized
    application*. Probably you’ve never heard this expression before because conventional
    web and enterprise applications are implicitly centralized with respect to their
    users. I can hear you asking, what does “centralized” mean exactly?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *centralized application* or system is controlled by a single or *central*
    entity: an individual, company, institution, governmental agency, and so on. The
    entity hosts the system directly on its premises or through a service or cloud
    provider and has full control of all the components and layers of the system architecture.
    The user trusts the good faith of the central entity and decides whether to access
    its system depending on the entity’s reputation. From the point of view of the
    user, the system is either *trusted* or not. This is how most web and enterprise
    applications are designed today.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1.1](#ch01fig01) illustrates a typical interaction between a user and
    a *centralized* *trusted* system. You shouldn’t find anything surprising about
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1\. A centralized application is strongly associated with the single
    entity controlling it. Consequently, users decide whether to access it depending
    on their trust of the entity.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s move on to decentralized applications. If you consider for a moment the
    alternative e-commerce application I introduced earlier, you’ll agree it has advantages
    with respect to [SmallWebRetailer.com](http://SmallWebRetailer.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Favorable transaction conditions*—The transaction would be completed and the
    money would be fully transferred to the retailer only when the retailer had complied
    with all the conditions associated with the transaction, such as your confirmation
    of safe delivery. This would remove one of the biggest reservations you had about
    [SmallWebRetailer.com](http://SmallWebRetailer.com): uncertainty whether you’d
    get the delivery and what would happen to your money if not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Independent transaction execution and verification*—The transaction wouldn’t
    be processed by the retailer or a single third party but by one of many participants
    in the platform supporting the e-commerce application, and then all the participants
    in the platform would independently verify it. The mechanism that all parties
    would use to agree on the verification of a transaction is called *consensus*
    (defined in the callout). The consensus mechanism would reassure you that the
    promised transaction conditions would be enforced and verified by many independent
    parties rather than an unknown retailer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consensus is a *distributed and trustless* form of agreement on the verification
    of a transaction. *Distributed* means that an independent central authority doesn’t
    perform the verification of a transaction; instead, all parties contribute to
    and agree on its verification. *Trustless* means that parties don’t need to trust
    each other to agree on the verification outcome. Consensus is reached when a qualified
    majority of the participants have agreed on the outcome of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '*Transparency*—You’d be able to check the code processing the transaction and
    verify that it was observing the specified conditions before transferring your
    money to the retailer. This would give you a further level of reassurance that
    the application was executing under the promised terms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deliver all of these requirements by building the alternative e-commerce
    application as a network of processing nodes of equal importance and functionality,
    each owned by a different party. Each node would
  prefs: []
  type: TYPE_NORMAL
- en: be able to process a transaction the same way other nodes do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: verify all transactions in the same way other nodes do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: contribute in an equal way to the outcome of a transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The consequence of this architecture would be that the processing would be
    decentralized to a network of independent nodes rather than being centralized
    to a specific set of servers that a specific entity owns. Such decentralization
    would relieve the user from having to trust a specific entity: the user would
    have to trust only the design of the network as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications built on this architecture are known as *decentralized applications*.
    I’ll provide another example to make the concept clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1\. Dapps vs. conventional centralized applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To explain more clearly the benefit of building a Dapp, as opposed to developing
    a conventional centralized application, I’ll illustrate for you a typical use
    case: an electronic voting application.'
  prefs: []
  type: TYPE_NORMAL
- en: Centralized voting application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Traditional centralized voting applications are generally provided by a company
    to facilitate shareholder voting or by a local administration or government to
    facilitate the approval or selection of law proposals. The institution running
    the application owns it, directly or indirectly, at least during the voting session.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see at the top of [figure 1.2](#ch01fig02), a centralized voting
    application runs on one or more application servers connected to a central database.
    The system is exposed to the voters through one or more web servers hosting the
    voting website. The institution can have the web, application, and database servers
    hosted directly on the premises or in the cloud. Cloud hosting can happen through
    a cloud computing provider offering Infrastructure as a Service (IaaS) if the
    voting system has been implemented in-house by the institution, or through a cloud
    application provider offering Software as a Service (SaaS) if the voting system
    is only leased or rented from an external provider during the voting session.
    This architecture might not be ideal from the point of view of the voter, because
    of potential worries about trust and security.
  prefs: []
  type: TYPE_NORMAL
- en: Trust in centralized voting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given all the financial and accounting scandals that have happened at both corporate
    and governmental levels in the last few years, it’s understandable if you don’t
    fully *trust* the organizations you’re a shareholder or citizen of. You might
    wonder whether the outcome of electronic voting might get manipulated in some
    way.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to imagine, for example, that a malicious developer or administrator
    of the voting application, colluding with some party interested in a certain outcome
    of the voting, could access key parts of the system and tamper with the way votes
    are collected, processed, and stored at various levels of the application architecture.
    Depending on how the application has been designed, it could be possible for some
    malicious database administrators to even modify votes retroactively.
  prefs: []
  type: TYPE_NORMAL
- en: Security in centralized voting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When voting through a centralized application, you’d worry about not only the
    good faith of the company or institution organizing the election, but also whether
    the system was secured adequately against external manipulation. For example,
    external parties might be interested in having the voting go a certain way and
    might try to get their desired outcome by hacking into the system.
  prefs: []
  type: TYPE_NORMAL
- en: As I explained earlier, a centralized voting system includes only a certain
    number of servers located within the same network. Each server generally provides
    only one function, and it’s therefore a single point of failure, not only from
    a processing point of view but also, and especially, from a security point of
    view. For example, if a hacker managed to alter code on the web server so that
    votes were intercepted and modified in that layer, the entire system would be
    compromised. The same outcome could be achieved by hacking only into the application
    server or, even better, into the database server. A breach of security in one
    part of the system is sufficient to compromise the security of the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized voting application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A decentralized application is based on two key technical principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Its application logic is present and executed simultaneously and independently
    on each server of a *peer-to-peer (P2P) network*. In theory, a different participant
    owns each server, also known as a *node*. A central node doesn’t control or coordinate
    the servers; instead, they communicate directly with each other and are consequently
    also known as *peer nodes*. They continuously verify each other’s output, so a
    user need only trust the P2P network, not an individual organization. The application
    data and state are stored on a local copy of a database on each server of the
    network, as shown at the bottom of [figure 1.2](#ch01fig02).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its database technology, called *blockchain*, guarantees that data can’t be
    modified retroactively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 1.2\. Comparison of a centralized voting application with a decentralized
    one. One institution owns all servers of a centralized application. A decentralized
    voting application runs simultaneously on multiple nodes of a network that different
    entities own.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trust and security in Dapps thanks to P2P network replication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How can you address trust and security concerns by decentralizing the voting
    application according to the two principles I outlined? A decentralized voting
    application makes trust and security breaches pointless by replicating its execution
    over a network including many servers, each in theory owned by a different party.
    Think about it: if votes were processed and verified not by one single server
    but independently by many servers owned by different parties, and they were stored
    not in a single database but in many databases, each one local to the processing
    party, both trust and security concerns would be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Trust*—If one of the participants tried to maliciously alter a vote and propagate
    the modified vote to the network, the other participants would detect the vote
    as modified during their validation and would reject it. They wouldn’t store it
    in their local copy of the database and wouldn’t propagate the altered vote further
    throughout the network, so the malicious modification would become pointless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Security*—Hackers would find trying to alter votes in a decentralized system
    much more difficult than trying to do so in a centralized one. Even if they managed
    to modify votes on one server, or they hosted themselves on one server of the
    decentralized voting application network to do so more easily, other participants
    would spot and reject the alteration, as seen earlier. Successful hacking would
    therefore require compromising not one server of the network but at least 51%
    of the nodes of the network simultaneously, assuming the state of the application
    is what is agreed among the majority of the network nodes. As you can understand,
    trying to manipulate a large part of a network including thousands of servers
    is an incredibly challenging task, especially if each one is managed independently.
    Also, each one might potentially be set up with a different way of preventing
    security breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trust and security in Dapps thanks to the blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A blockchain database is based on a data structure that, as its name suggests,
    is a chain of blocks. A block can be seen as a record containing a set of transactions,
    each one digitally signed, some metadata (such as block number and time stamp
    information), and a link to the previous block. Each transaction, each block as
    a whole, and the links between blocks are secured with cryptographic technology,
    which makes them *immutable*: retroactive alteration of single transactions is
    nearly impossible, especially as more blocks are added to the chain. A blockchain
    database therefore addresses trust and security concerns by providing further
    protection against manipulation attempts by malicious participants and external
    parties.'
  prefs: []
  type: TYPE_NORMAL
- en: Outstanding questions on low-level aspects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this stage, you might find the decentralized voting application concept
    promising from a logical or a high-level point of view, but you might still be
    confused about physical and lower level aspects of its architecture. You might
    have doubts in various areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*System architecture*—Is the network hosting the decentralized voting application
    a special kind of network? Do servers communicate with each other using a special
    protocol or using standard internet technology?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vote processing and validation*—How does vote submission get propagated across
    the network so that a vote gets processed on each server of the network? How does
    a vote get counted and then stored on the blockchain? How does a member of the
    network verify the authenticity of the consolidated vote records received from
    other members?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’ll try to answer these questions in the next two sections, which cover low-level
    details of the decentralized voting application. I’ll also assume the voting Dapp
    has been developed for Ethereum, the blockchain and Dapp platform this book is
    focused on. Doing so will allow me to start introducing Ethereum and to refer
    to concrete infrastructural components while presenting two complementary low-level
    views of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A structural Dapp view*—I’ll describe the low-level architecture of the client
    and server sides of our voting Dapp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A transactional Dapp view*—I’ll walk you, step-by-step, through the entire
    lifecycle of a voting transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.1.2\. Structural view: Anatomy of a Dapp'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *structural view* of the decentralized voting application includes a description
    of the components of both the client side, represented by the web UI through which
    a voter submits a vote, and the server side, represented by a network of servers
    running the application logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dapp client side: a web application'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The voting application web client, shown in [figure 1.3](#ch01fig03), gets initially
    downloaded into the user browser from a conventional web server, generally as
    a web application containing HTML and JavaScript. The web user interface doesn’t
    contain any server-side scripts and communicates directly with a specific server
    of the network through a client-side JavaScript library called Web3.js. It might
    also allow the user to communicate with a network node located on their premises.
    So far, this application differs in no major way from a conventional web application.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3\. A decentralized voting application is exposed to the voter as a
    web application, which contains both HTML and JavaScript and is downloaded from
    a conventional web server. The web application, which doesn’t contain any server-side
    scripts (otherwise, it would be partially centralized), is generally configured
    to communicate directly with a specific node of the network.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Dapp server side: a P2P network'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The server side of a decentralized application is a P2P network of servers that
    run the same code and have identical copies of a blockchain database. As you know,
    a key characteristic of this network topology is that it uses no central coordination,
    but instead uses direct communication between each node and a number of other
    nodes, known as *peer nodes* or simply *peers*. No master node is needed. As shown
    in [figure 1.4](#ch01fig04), a node doesn’t need to be connected to all of the
    other nodes of the network. Being connected to a few nodes is sufficient to ensure
    transactions are rapidly propagated to the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4\. A peer-to-peer (P2P) network is made of nodes that communicate
    directly with each other without the coordination of a master node.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Ethereum network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Various P2P networks supporting blockchain platforms exist. The most well-known
    one is the Bitcoin network.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’ll focus on the Ethereum network, whose *participant* nodes,
    as shown in [figure 1.5](#ch01fig05), host a *blockchain database* and a piece
    of software called a node *client*, which allows a node to communicate with other
    nodes. Because all nodes are equivalent to each other, within the Ethereum network
    you have no clear-cut concept of client and server. Each node is a server to other
    nodes, but, at the same time, it’s also a client of other nodes. That’s why the
    software element of an Ethereum node is called a client.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum clients expose a common client interface and communicate with each
    other through a P2P protocol called *Wire*. That protocol enforces a standard
    way of sending data throughout the network, specifically a *transaction*, such
    as a submitted vote, and a *block*, such as a set of votes consolidated in the
    blockchain database.
  prefs: []
  type: TYPE_NORMAL
- en: Various implementations of an Ethereum client exist. As you can see in [figure
    1.5](#ch01fig05), they’re written in various languages, from C++ to Go, but all
    implement the standard client interface and the Wire protocol, so they can interact
    seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5\. Each node of the Ethereum network hosts a blockchain database and
    a node client capable of executing application code stored in the blockchain.
    Nodes communicate through the Wire protocol and expose the same interface but
    can be implemented in different languages.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of an Ethereum node client over a Bitcoin node client is that
    it’s able not only to propagate cryptocurrency transactions and blocks throughout
    the network, as a Bitcoin node does, but also to execute application code hosted
    on the blockchain database. From this point of view, platforms such as Ethereum
    are known as *programmable blockchains*. The code of decentralized applications
    is structured in *smart contracts*, which encapsulate logic and state in the same
    way classes do in most object-oriented languages. The voting decentralized application,
    for example, would be structured on various smart contracts that would be hosted
    on the Ethereum blockchain. I’ll explain shortly what a smart contract is, how
    you deploy it, how you execute it, and where a smart contract is stored and runs.
    Bear with me.
  prefs: []
  type: TYPE_NORMAL
- en: The role of network nodes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Although all network nodes communicate seamlessly through the common P2P Wire
    protocol, not all nodes perform the same function. Broadly, as shown in [figure
    1.6](#ch01fig06), the two main types of nodes, which are functionally different,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Full node*—Most nodes have a standard setup that allows them to process transactions
    passively: they can read from the blockchain database, but they can’t create new
    blockchain blocks. But they can append blocks received from peer nodes to the
    local blockchain. They do execute transactions, but only to verify the correctness
    of the blockchain blocks they receive from peer nodes. In the case of the voting
    application, full nodes propagate votes received from their peers to other peers.
    They also verify that the blocks received are correct and contain authentic votes
    by running the voting Dapp smart contracts. But full nodes don’t store votes in
    new blockchain blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 1.6\. The Ethereum network includes two main types of nodes. Full nodes
    process transactions passively and can read, but can’t write on, the blockchain.
    Mining nodes process transactions actively: they validate the correctness of transactions
    as full nodes do, but they also assemble transactions into new blocks that are
    appended onto the blockchain.'
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-06_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Mining node*—Some of the nodes are configured to process transactions actively:
    they group and store transactions in new blockchain blocks. They’re rewarded in
    Ether, the cryptocurrency supported in the Ethereum platform, for performing such
    computationally intensive and energy demanding work. They then propagate these
    new blocks to the rest of the P2P network. Such nodes are called mining nodes
    because the process of consolidating a new block to the blockchain and being rewarded
    for it in cryptocurrency tokens is known as *mining*. In the case of the voting
    Dapp, mining nodes group votes received from peer nodes into a new block, append
    the block to the blockchain, and propagate the block through their peers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ve examined the structural view of the voting Dapp. [Figure 1.7](#ch01fig07)
    shows the entire system, including the client and server sides.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7\. The entire static view of a decentralized voting application, including
    client and server sides
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '1.1.3\. Transactional view: Through the lifecycle of a transaction'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding a temporal dimension to the static view you saw in [figure 1.7](#ch01fig07),
    [figure 1.8](#ch01fig08) illustrates step-by-step the full lifecycle of a voting
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: The user selects one of the possible voting options from a drop-down list box
    on the web client and clicks Vote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A JavaScript function handles the click event and grabs the voting selection.
    Then, through various web3.js library functions, it sets up the communication
    with a configured Ethereum node, connects with the voting smart contract, and
    calls the `castVote()` function on it. The invocation of `castVote()` generates
    a transaction message that’s digitally signed against the account of the user
    to prove they’re the genuine sender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The contacted local Ethereum node handles the transaction message, verifies
    it, and relays it to its peer nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer nodes do the same and keep propagating the transaction, until the transaction
    hits mining nodes. This will happen relatively quickly, depending on the ratio
    of full nodes to mining nodes. Mining nodes perform the same steps (steps 2 and
    3) of a full node. In addition, a mining node picks a transaction, such as a voting
    transaction. A transaction is considered profitable if it’s expected to generate
    an acceptable transaction fee, higher than the electricity costs the mining node
    faces while processing transactions. If so, the mining node executes the `castVote()`
    function and competes with other mining nodes to store the transaction on the
    blockchain. The winning mining node (which is the mining node successfully solving
    the so-called consensus algorithm, a cryptographic problem) consolidates the voting
    transaction among other transactions in a new block of the blockchain. It then
    relays the new block to all its peer nodes (regardless of whether they’re full
    or mining nodes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each node that has received a new block verifies whether the individual transactions
    included in it are genuine and whether the block as a whole is valid. It then
    processes all the transactions present in it. While doing this, it implicitly
    verifies the validity of the contract state. For example, the vote submission
    logic might include an invariant verifying that the number of votes cast for a
    candidate, or the total number of votes cast for all candidates, isn’t higher
    than the number of registered voters. If the node verifies the block successfully,
    it relays it to its peer nodes, which perform the same validation and propagation
    action until the whole network has acquired the new blockchain block. (The verification
    process will become clearer to you in the next chapter, when I’ll present the
    cryptographic techniques it’s based on.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local Ethereum node with respect to the user receives the new block and
    verifies it by executing all the transactions present on it, as all the other
    nodes have done. One of these is the voting transaction, which has been programmed
    to raise a `VoteConfirmation` event on successful completion. The event is published
    to all the clients subscribed to it, including the Dapp web UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 1.8\. The lifecycle of a voting transaction. A voting transaction is
    created when a voter browser invokes the `castVote()` function on the Voting smart
    contract on a local node of the Ethereum network. This is then validated and propagated
    throughout the network until it’s included on a new blockchain block by a mining
    node. The new block is propagated throughout the network, and then it finally
    gets back to the local node.
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-08_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The JavaScript code present on the voting web client contains a callback function
    registered against the `VoteConfirmation` event, which then gets triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the callback function shows a vote confirmation notification on the
    voter’s screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1.1.4\. Some Dapp terminology
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although decentralized applications are a relatively new idea, standard terminology
    around them started to appear relatively soon after the first Dapps were built.
    In this section, I’ll provide a summary of the key terms that Vitalik Buterin,
    the creator of Ethereum, described in a famous blog post^([[1](#ch01fn01)]) he
    wrote to explain key Dapp concepts. You’ve already come across some of these terms
    in the previous sections, but now I’ll define them more precisely.
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Vitalik Buterin, “DAOs, DACs, DAs and More: An Incomplete Terminology Guide,”
    [http://mng.bz/vNrq](http://mng.bz/vNrq).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Smart contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *smart contract* is an arrangement between two or more parties that involves
    an exchange of digital assets. One or more of these parties allocates digital
    assets to the contract at its initiation. Subsequently, the assets are redistributed
    among the parties according to a predefined protocol encoded in logic and a state
    that’s initialized at the start of the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous agent
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An *autonomous agent* is a software entity that interacts autonomously with
    external software services and can reconfigure or even reprogram itself following
    verified changes in the external environment.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized organization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A traditional *centralized organization* contains assets and different classes
    of individuals, typically investors, employees, and customers. Investors control
    the organization by owning a part of it through the purchase of shares. Interactions
    between some classes of individuals are influenced by whether they control the
    organization. For instance, employees can get recruited by investors or by other
    employees authorized directly or indirectly by investors.
  prefs: []
  type: TYPE_NORMAL
- en: A *decentralized organization* (DO) isn’t controlled by any one person or entity.
    Predefined protocols are what determine interactions between classes of individuals
    involved in the organization. But such protocols can be designed so that certain
    individuals have more power than others—for instance, depending on the number
    of shares owned—exactly as with centralized organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized autonomous organization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *decentralized autonomous organization* (DAO) is both a DO and an autonomous
    agent. Like an autonomous agent, it’s a software entity that interacts autonomously
    with external software services. Individuals involved with the DAO interact, as
    with DOs, through predefined protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a DAO and a DO is that interactions between DAOs
    and external parties are largely automated, and the interaction protocols are
    programmed in a *smart contract*, whereas interactions between the individuals
    who own the DO and external parties are subject only to a *manual protocol*. The
    key point is that from the point of view of external parties, DAOs are more trustworthy
    than DOs because automated interactions are predictable, whereas interactions
    based on a manual protocol rely entirely on the reputation of the individuals
    following it.
  prefs: []
  type: TYPE_NORMAL
- en: According to these definitions, opinions diverge as to whether blockchain platforms
    built with the main or only purpose of supporting a cryptocurrency can be classified
    as DAOs or DOs. Because the Bitcoin infrastructure doesn’t allow for implementation
    of easily automated interaction protocols, some think it should be classified
    as a DO.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized autonomous corporation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *decentralized autonomous corporation* (DAC) is a DAO that can be partially
    owned through a purchase of shares. As with classic (centralized) corporations,
    a DAC redistributes dividends periodically, depending on its financial success.
    A pure DAO, on the other hand, is generally a nonprofit organization, and participants
    benefit economically exclusively by contributing to its ecosystem and increasing
    its internal capital.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The current widely accepted definition of *decentralized application* corresponds
    to that of DAO described previously, which is still in use among Ethereum purists.
    I’ll use this definition for Dapp for the rest of this book. The reason why the
    initial terminology used the word *organization* rather than *application* was
    because the Ethereum founders wanted to put emphasis on the fact that a decentralized
    application can transact with other parties exactly like conventional organizations:
    by following rules and protocols and exchanging monetary value, obviously in the
    form of cryptocurrency rather than conventional currency.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The key aspects of each of these terms are summarized in [table 1.1](#ch01table01).
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1\. Matrix summarizing key aspects of each term, with DAO standing for
    Dapp
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | Is software | Has capital | Is autonomous | Is owned |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Autonom agent | YES | NO | YES | NO |'
  prefs: []
  type: TYPE_TB
- en: '| DO | NO | YES | NO | YES |'
  prefs: []
  type: TYPE_TB
- en: '| **DAO** | **YES** | **YES** | **YES** | **NO** |'
  prefs: []
  type: TYPE_TB
- en: '| DAC | YES | YES | YES | **YES** |'
  prefs: []
  type: TYPE_TB
- en: Although you’ve learned some of the high-level terms, you can’t truly understand
    the purpose of Dapps and how they work without familiarizing yourself with the
    concept of blockchain. Because Dapps are built on top of the blockchain and rely
    heavily on it, you should learn about it and its underlying technologies. I’ll
    cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Decentralized vs. distributed applications**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decentralized* applications shouldn’t be confused with *distributed* applications.
    The two concepts have similarities, but they’re not the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: An application is distributed if it runs over multiple servers within a network.
    The simplest example of a distributed application is a web application, which
    is typically distributed over a web server, an application server, and a database
    server, and possibly an email server and legacy mainframes. The centralized voting
    application seen earlier is an example of a distributed application. It’s distributed
    because it’s spread over several servers, but it’s also centralized because all
    the servers are owned by the same institution.
  prefs: []
  type: TYPE_NORMAL
- en: A distributed application runs over multiple servers of a network. A decentralized
    application is replicated in its entirety over each node of a wide network.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0019-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of the structures of distributed and decentralized applications
  prefs: []
  type: TYPE_NORMAL
- en: An application is decentralized if it’s replicated in its entirety over each
    node of a network, with each node being theoretically owned by a different entity.
    The higher the number of entities owning nodes of the network, the more trustful
    the network in its entirety is. Obviously, networks that have only a few owners
    can’t be considered trustful because they don’t truly decentralize the processing.
  prefs: []
  type: TYPE_NORMAL
- en: A centralized application is generally distributed, but decentralized applications
    can also be distributed over multiple servers within each logical node.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 1.2\. Good and bad Dapps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last few years, many Dapps have been developed. Some have received various
    rounds of venture capital funding and have been deployed successfully into production.
    Others have failed to convince investors and users and never passed the proof-of-concept
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1\. Good use cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the novelty of the technology, it’s hard to predict what’s going to work
    and what’s going to fail. Nevertheless, various use cases are being widely recognized
    as a good fit for the blockchain and in particular for Ethereum. Ideal Dapps are
    those that take advantage of the main benefits of these technologies, specifically
    record immutability, decentralization, security, and resilience. As a result,
    the main fields likely to be revolutionized by Dapps are provenance and ownership
    tracking, authenticity tracking, identity verification, regulatory auditing, charity
    expense auditing, prediction markets, customer loyalty management, crowdfunding,
    electronic voting, investing, gambling, lending, online games management, author
    royalty payment, Internet of Things, cloud computing, and even freedom of speech.
    Let’s see what innovative solutions have already been found in some of these areas.
  prefs: []
  type: TYPE_NORMAL
- en: Provenance and authenticity tracking
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One of the biggest problems affecting supply chain management, particularly
    when involving long chains of processed goods crossing several countries, is tracking
    the authenticity of materials. Here are some Dapps that are innovating in this
    area with blockchain-based solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Dapps such as Provenance provide blockchain-based provenance tracking of materials
    to ensure no information is lost or manipulated within the supplier chain and
    goods of expected quality reach the end customer. One of the first applications
    built on Provenance has been focused on the food industry, to track the supply
    chain of ingredients from the point of collection, though the process of food
    manufacturing, to the final point of consumer sale. The aim of this system is
    to prove the food being sold has the claimed characteristics advertised to the
    consumers, such as location and sustainability of harvesting or breeding, whether
    the sources are organic or have been genetically modified, whether they’re coming
    from fair trade, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unilever, the multinational consumer goods corporation, is developing a blockchain-based
    system in collaboration with a number of start-ups to track the tea supply chain
    starting from farmers in Malawi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everledger is a Dapp that aims to replace the paper certification process for
    diamonds with a blockchain-based system. A full digital record of a diamond, including
    its certificate ID and many properties, such as cut, grade, clarity, color, and
    carat, is stored on the blockchain, and the certificate ID is then engraved with
    a laser on the stone. All the information related to a diamond can then be retrieved
    at any point of the supply chain with the help of a scanner that reads the certificate
    ID from the stone. Almost 2 million diamonds have already been stored on Everledger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pharmaceutical company Pfizer is partnering with the biotechnology company
    Genentech to develop MediLedger, a blockchain-based drug delivery tracking system.
    The aim is to verify the provenance and authenticity of Pfizer drug deliveries
    throughout the entire distribution chain to prevent thefts, fraud, and counterfeiting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity verification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As with provenance tracking, verification of proof of identity tries to protect
    businesses and individuals from the consequences of fraud and identity theft.
    KYC-Chain is a novel platform built on the Ethereum blockchain that allows users
    to manage their digital identity securely. It also helps businesses and financial
    institutions to manage customer data in a reliable and easy manner. The system
    is designed so that users own the “keys” to their personal data and identity certificates.
    Consequently, identity owners, who can be individuals or companies, are the only
    ones who get to choose which part of their information is shared, with whom, and
    under what terms. Such information is digitally attested by notaries and institutions
    before being shared by owners and registered agents.
  prefs: []
  type: TYPE_NORMAL
- en: Proving ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Traditional blockchains associated with cryptocurrencies such as Bitcoin as
    ledgers implicitly prove the ownership of digital assets, such as the amount of
    Bitcoin stored at a certain address. Only the legitimate owners of the address
    are able to transfer funds because they’re the only ones who know the private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: TrustToken tries to go further. It’s a Dapp conceived for proving the ownership
    of physical assets, such as real estate; financial assets, such as stocks and
    bonds; commodities, such as gold; and even intellectual property, such as music,
    books, and patents, through smart contracts. The idea is that you can transfer
    the ownership of these assets from one person to the other in the same way Bitcoins
    are transferred between addresses. The underlying assumption for TrustToken to
    be successful is that proof of ownership recorded through the system should be
    enforceable under law.
  prefs: []
  type: TYPE_NORMAL
- en: Economy of Things
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The tech startup Slock.it ([https://slock.it/](https://slock.it/)) is building
    the infrastructure for the “economy of things,” which lies at the intersection
    between the Internet of Things and blockchain technology. This infrastructure,
    which the company has named the Universal Sharing Network, has the potential to
    be used as a financial internet, where connected autonomous objects can not only
    sell and rent themselves but also pay for each other’s services. The technology
    the company is developing, based on Ethereum smart contracts, aims to provide
    autonomous objects an identity and the ability to receive payments and enter into
    agreements without the need for intermediaries. Smart lockers, which enable the
    unlocking of physical objects when a fee is paid, are some of the applications
    already created on this platform. Because smart lockers make renting of sports
    equipment, hotel rooms, bicycles, and offices easy, this solution is thought to
    provide the foundation for the sharing economy.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized prediction markets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prediction markets reward people for correctly predicting real-world events,
    such as the winner of a presidential election, the outcome of a referendum, the
    level of interest rates at a specific date, or the winner of a sports competition.
    Aside from speculative uses, they’re also useful tools for economists, public
    administration planners, and corporate strategists, who can base their decisions
    on the event probabilities being currently traded, which are thought to reflect
    the “wisdom of the crowds.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Although centralized markets such as [predictit.org](http://predictit.org)
    ([www.predictit.org](http://www.predictit.org)) exist, several decentralized initiatives
    are starting to emerge. Augur is a decentralized market prediction platform built
    on Ethereum. The idea is that decentralization brings the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Being based on the Ethereum network, it has no central point of failure, so
    it’s inherently highly available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nobody controls the definition of markets: anyone can start a new market on
    a new prediction and can get rewarded for having created that market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official outcome of each prediction isn’t decided centrally; it’s crowdsourced
    from market participants, so it’s less likely to be subject to manipulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Funds are stored on the blockchain, which eliminates counterparty risk, makes
    payment to prediction winners fast, and reduces the likelihood of errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: International trade finance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: International trade between a supplier and a manufacturer located in different
    countries is a complex business. As you can see in [figure 1.9](#ch01fig09), it’s
    generally based on a complicated workflow involving many parties, such as banks
    that facilitate the payment, commercial intermediaries that facilitate the distribution,
    shipping and delivery companies that transport the goods, insurers that cover
    financial risks while the goods are in transit, and customs officials who check
    the legality of the goods and the payment of import duties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9\. Typical international trade involving many parties: banks, commercial
    intermediaries, shipping companies, insurers, customs officials, and so on'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Parties involved in a specific transaction often have never dealt with each
    other previously. But for the transaction to complete successfully, they must
    communicate with each other effectively, generally through established lengthy
    protocols designed to protect a party against the malicious behavior of another
    party. Parties cross-check each other, and this takes a huge amount of paperwork
    and time, which often causes long delays.
  prefs: []
  type: TYPE_NORMAL
- en: we.trade is a platform sponsored by a consortium of banking partners (including
    Société Générale, Deutsche Bank, Nordea, Santander, and HSBC) that aims at simplifying
    and streamlining such processes with the help of blockchain technology. The platform
    tracks each step of the transaction openly and transparently so that each party
    is able to submit and consume the relevant documentation with the confidence that
    no one will tamper with it. Trades that used to take weeks can be now completed
    in a few days.
  prefs: []
  type: TYPE_NORMAL
- en: Regulatory auditing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The blockchain is particularly suitable for ensuring that records stored on
    it haven’t been altered or tampered with. Balanc3 is a Dapp built on Ethereum
    that ensures the integrity of accountancy records for regulatory purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Crowdfunding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: WeiFund aims at providing open source modular and extensible decentralized crowdfunding
    utilities based on the Ethereum blockchain. Users can set up and manage crowdfunding
    campaigns through these utilities. The possibility of encoding funding rules based
    on smart contract technology allows users to know precisely what will happen with
    their money if the campaign fails or is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Gambling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Intuitively, a natural fit for a decentralized application is a gambling platform,
    because users get the benefit of being assured that bets are processed fairly
    and predictably. Edgeless is an example of such a platform, and it’s currently
    being developed after a successful crowdfunding campaign.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about some successful Dapp implementations, you might
    be wondering whether it’s always worth basing your application on blockchain technology.
    We’ll explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2\. Pointless Dapps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Deciding whether the blockchain is a suitable technology for an application
    you’re planning to build might be difficult. What you should ask yourself is whether
    the functionality that a blockchain platform offers will meet your business requirements.
    More importantly, consider whether the benefits of using such a platform would
    be outweighed by all the technical limitations and additional complexities that
    come with this technology. A sobering blog post titled “Avoiding the Pointless
    Blockchain Project”^([[2](#ch01fn02)]) analyzes the requirements necessary to
    justify the use of a blockchain platform over more traditional technologies such
    as SQL or NoSQL databases. It concludes that a blockchain project only makes sense
    if you can answer yes to all of the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: ²
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gideon Greenspan, “Avoiding the Pointless Blockchain Project,” [http://mng.bz/4Oqg](http://mng.bz/4Oqg).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does your application require a shared database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the database need to support multiple writing parties?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the writing parties have no trust in each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the writing parties want to modify the state of the database directly, without
    requiring a central entity trusted by all participants?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do transactions that the writing parties create interact collaboratively with
    each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to these criteria, for example, an internal enterprise application
    that wouldn’t expose any data to external parties wouldn’t be a suitable choice
    for a Dapp. Other poor Dapp candidates are applications for which confidentiality
    around the business rules is important. A smart contract is, by definition, completely
    open and transparent to all interacting parties. Therefore, preventing participants
    from accessing and understanding the logic of the rules would defeat the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Although decentralized microblogging applications such as EthTweet are considered
    sensible Dapps to those who value the fact that messages can’t be censored and
    altered after they’re sent, an instant messaging Dapp, such as a “decentralized
    WhatsApp,” wouldn’t be a particularly useful product for a fundamental reason.
    One of the technical downsides of the blockchain platform is that processing transactions
    (in this case instant messages) requires roughly 15 seconds to consolidate a new
    blockchain block. Therefore, messages would never be *instant* at all.
  prefs: []
  type: TYPE_NORMAL
- en: When building a Dapp, you also should keep in mind some operational aspects
    that, given the novelty of the technology, may cause some issues down the road.
    For instance, although a smart contract can automatically guarantee funds are
    routed and released subject to certain conditions, a commercial transaction might
    also be subject to real-world conditions that programming logic can’t enforce.
    A classic example for a non-fully automatically enforceable smart contract is
    that of an electronic loan. If the borrower had to keep the borrowed money stuck
    on a blockchain account so a smart contract could automatically give it back to
    the lender if the borrower missed an interest payment, the borrowing wouldn’t
    make any economic sense. In these cases, it isn’t clear yet whether a court of
    law would be able to enforce the nonautomated elements of a smart contract or
    it would be necessary to complement the deal with a traditional legal arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. A five-minute Dapp implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you should have a good understanding of what a Dapp is, the purpose
    of Dapps over conventional apps, the main architectural components of a decentralized
    application, and whether it makes sense to embark on a project based on blockchain
    technologies. It’s now time to take one little step further and get on with some
    programming. In the rest of the chapter, you’ll start building the smart contract
    for a custom cryptocurrency. You’ll then activate it and interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1\. Building SimpleCoin, a basic cryptocurrency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most Dapps are designed using functionality based on the exchange of cryptocurrency
    or tokens through rules encoded in one or more smart contracts. You’ll start to
    get a feel for Dapps programming by building SimpleCoin, a basic cryptocurrency
    that will present useful preliminary concepts about smart contracts and the Ethereum
    platform. You’ll progressively build on it in the following chapters, where you’ll
    learn more about Dapp development. You’ll also use or reference SimpleCoin from
    other Dapps that you’ll build in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Because you haven’t installed an Ethereum platform client on your computer yet,
    you’ll be writing code on the Remix Solidity (previously known as Browser Solidity)
    integrated development environment (IDE) for now. This online tool will allow
    you to implement smart contracts in a high-level language called Solidity, similar
    to Java-Script, and run them on a local JavaScript VM that emulates the Ethereum
    Virtual Machine that you’ll meet in the next chapter. It’s also possible through
    this tool to interact with real smart contracts deployed on the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and go to: [http://remix.ethereum.org/](http://remix.ethereum.org/).
    You should see a screen like [figure 1.10](#ch01fig10). On the website, the left
    side of the IDE is a file explorer (which you can hide by clicking the double
    arrow toggle at the top left); in the middle you have the code editor; and the
    right side contains various panels to run the code and interact with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10\. Screenshot of the Remix opening screen, with the code on the left
    and the code execution panels on the right. I’ve hidden the file explorer by clicking
    the double arrow toggle at the top left.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In your first encounter with Solidity, you’ll implement the simplest possible
    smart contract. If you think of a smart contract as the equivalent of a class
    in an object-oriented language, you’ll write a single class with only one member
    field, one constructor, and one method. Then you’ll run it and interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Hide the file explorer by clicking the double arrow toggle at the top left,
    and then enter the code in [listing 1.1](#ch01ex01) in the Remix editor, in the
    left side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.1\. First implementation of SimpleCoin, a basic cryptocurrency
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Pragma directive indicating the supported version of the Solidity
    compiler. (The code supports a compiler later than 0.4.0 but earlier than 0.5.0.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Defines a contract, which is similar to a class in other languages**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Defines a state variable as a “mapping” between an address and an
    integer. A state variable is the equivalent of a member variable. A mapping is
    equivalent to a hash table or hash map.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Starts defining the contract constructor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Assigns 10,000 SimpleCoin tokens to the coin account with address
    0x14723a09acff6d2a60dcdf7aa4aff308fddc160c at contract creation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Defines a function that moves a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Decreases the coin balance of the message sender by the specified
    number of tokens. (The special implicit property msg.sender represents the address
    of the sender of the transaction.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Increases the coin balance by the specified number of tokens**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine this code in detail. A *contract* in Solidity is a type similar
    to a class in any other language: it has *state variables* (such as `coinBalance`),
    a constructor, functions (such as `transfer`), and events.'
  prefs: []
  type: TYPE_NORMAL
- en: The `coinBalance` state variable is defined as a `mapping`. A *mapping* is a
    hash map, equivalent to a hashMap in Java, Dictionary in C#, or dict in Python.
    In this example, the type of the key is an `address`, whereas the value is a `uint256`—an
    unsigned 256-bit integer. An *address* holds a 20-byte value and can identify
    a specific smart contract account or a specific user account. An account, as you’ll
    see later in detail, is the sender or the receiver of a transaction. The `coinBalance`
    state variable therefore represents a collection of coin accounts, each holding
    a number of SimpleCoin tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The `transfer` function is meant to move a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account. In smart
    contract terminology, a function caller is the *transaction sender*. `msg` is
    a special implicitly defined variable that represents the incoming message. It
    has various properties, among which `msg.sender` represents the address of the
    sender of the transaction, who is the caller of `transfer`.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the transfer function is simple to understand. It involves subtracting
    the specified amount from the cash account associated with the function caller
    and adding the amount specified in the `_amount` parameter to the account associated
    with the address specified in the `_to` parameter. To keep this initial code simple,
    this implementation isn’t performing any boundary checks yet on the number of
    SimpleCoin tokens owned by the transaction sender, who, for example, shouldn’t
    be allowed to send more tokens than they own. You’ll perform such checks when
    we revisit SimpleCoin in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand that your `SimpleCoin` contract is, in
    practice, a class with a constructor (`SimpleCoin` function), some state (`coinBalance`
    variable), and a method (`transfer` function). [Table 1.2](#ch01table02) gives
    a quick summary of the Solidity keywords you’ve come across.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.2\. A summary of Solidity keywords used in the first code sample
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Keyword | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| contract | **Type similar to class in any other language** |'
  prefs: []
  type: TYPE_TB
- en: '| mapping | **Data structure similar to a hash table or hash map** |'
  prefs: []
  type: TYPE_TB
- en: '| address | 20-byte value representing an Ethereum user account or contract
    account |'
  prefs: []
  type: TYPE_TB
- en: '| uint256 | **Unsigned 256-bit integer** |'
  prefs: []
  type: TYPE_TB
- en: '| msg | **Special variable representing an incoming message object** |'
  prefs: []
  type: TYPE_TB
- en: '| msg.sender | **Property of the msg object representing the address of the
    message sender** |'
  prefs: []
  type: TYPE_TB
- en: 1.3.2\. Running the contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Move now to the right side of the screen to deploy the `SimpleCoin` contract.
    First, make sure the Auto Compile option in the Compile tab is checked, as shown
    in [figure 1.11](#ch01fig11), so that Remix will recompile the code at every change.
    Also, make sure you’ve selected version 0.4.24 of the compiler (for example 0.4.24+commit.e67f0147),
    because this is the version I’ve been using when writing `SimpleCoin`.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11\. The Auto Compile option in the Compile tab makes sure the code
    entered in the editor is recompiled at every change.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you’ve typed your code correctly (I recommend you copy the code from the
    files provided on the book website!), and no compilation errors have occurred,
    you should see the following buttons in the Run tab: Deploy and At Address, as
    shown in [figure 1.12](#ch01fig12). Ignore At Address for now and focus your attention
    on Deploy. By clicking this button, you’ll deploy the `SimpleCoin` contract on
    an emulated blockchain within Remix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12\. Once the code has been compiled correctly, the Run tab will show
    two buttons: Deploy and At Address. You can instantiate the contract by clicking
    Deploy.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The contract will be stored against an address on the emulated Ethereum blockchain,
    and a new Deployed Contracts panel will appear, as shown in [figure 1.13](#ch01fig13).
    You can read the deployment address by clicking the Copy Address icon and pasting
    it in Notepad, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13\. After deploying the contract, the Deployed Contracts panel appears,
    containing a drop-down with a SimpleCoin option; click it, and you’ll see the
    contract operations.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-13_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 1.3.3\. Interacting with the contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that the `SimpleCoin` contract has been deployed, you’ll be able to perform
    simple operations against it: you’ll check SimpleCoin token balances and move
    tokens across accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the SimpleCoin drop-down list within the Deployed Contracts panel. Two
    new buttons will appear: CoinBalance and Transfer, as shown in [figure 1.14](#ch01fig14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14\. SimpleCoin operations buttons: CoinBalance and Transfer. CoinBalance
    is a getter of the coinBalance state variable and is a read-only operation. Transfer
    allows you to transfer the specified number of tokens to the indicated address.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Remix IDE shows two types of buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Blue buttons*—They perform read operations against the contract, such as checking
    the value of state variables or calling read-only functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Red buttons*—They perform write operations against the contract, such as instantiating
    the contract through the constructor (Create), or call functions that modify any
    state variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, CoinBalance is blue because it allows you to read the coin balance
    associated with an address. Transfer is red because by clicking it you’ll alter
    the state of the contract, specifically by changing values contained in the `coinBalance`
    mapping state variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now check that the `coinBalance` associated with the address specified in the
    constructor has the full initial supply of SimpleCoin you set at construction.
    Wrap the address with double quotes: `"0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C"`.
    Enter it in the text box and click CoinBalance. Some output will appear. At the
    bottom, you should see the expected number of SimpleCoin tokens you specified
    in the constructor: 10,000.'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is the address of one of the five
    test accounts present on the Remix IDE. You can see them in the Transaction Origin
    drop-down list box on the top-right of the screen. Although they aren’t fully
    visible on the screen, their full addresses are reported in [table 1.3](#ch01table03).
    (I’ve retrieved them one by one by clicking the Copy Address icon next to the
    Account drop-down.)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.3\. Remix test accounts whose full address is hidden behind the HTML
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 |'
  prefs: []
  type: TYPE_TB
- en: 'You can double-check that the amount of SimpleCoin tokens associated with any
    address different from `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is zero. For
    instance, enter the following address, wrapped with double quotes as you did earlier,
    in the CoinBalance text box: `"0x583031D1113aD414F02576BD6afaBfb302140225"`. After
    clicking the button, you’ll see a zero, as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: To recap, when you instantiated the contract, an amount of 10,000 SimpleCoin
    tokens got assigned as initial money supply to the address starting with `0x14723A09`.
    No other address owns any tokens yet, as summarized in [table 1.4](#ch01table04).
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.4\. Balance of each Remix test account after contract instantiation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **10,000** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  prefs: []
  type: TYPE_TB
- en: 'Now you’ll call the `transfer` function to move some tokens from the account
    with the address starting with `0x14723a09` to a different test account. Because
    the transfer function moves tokens from the account of its caller, the function
    must be called from the contract creator’s address starting with `0x14723a09`.
    Pick this address from the Account drop-down at the top right of the Run tab,
    then enter in the text box of the transfer method the destination address—for
    example, the address starting with `0x4b0897b0`—and a number of tokens to be transferred—for
    instance, 150 tokens. You should separate the values of these parameters with
    a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now click Transfer. The function returns no result, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Check the number of tokens present in the contract creator’s address by clicking
    CoinBalance after entering the contract creator’s address (`"0x14723A09AC-ff6-D2-A60Dcd-F7aA4AFf308FDDC160C"`)
    in the related text box. The value is now 9,850, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: If you perform the same check on the destination address (`"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB"`),
    you’ll get 150\. All other addresses still have zero tokens, as summarized in
    [table 1.5](#ch01table05).
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.5\. Balance of each Remix test account after a transfer operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **9,850** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **150** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  prefs: []
  type: TYPE_TB
- en: As an exercise, you can try to transfer coins from the address starting with
    `0x4b0897b05` to a different address and recheck if the amounts are correct. While
    doing so, please don’t perform any crazy transactions yet, such as trying to move
    more coins than a certain address is holding. To keep the code simple for the
    moment, you haven’t coded any boundary conditions to handle such situations. You’ll
    learn about these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Although the code you’ve written so far is simple, your main objective at this
    stage was only to start to familiarize yourself with smart contracts, the Solidity
    language, and Remix. By now, you should have achieved that objective, and you
    should understand how contract instantiation works and how to interact with a
    contract from different accounts.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleCoin is still at the stage of an embryonic Dapp. So far, you’ve only executed
    its code on a JavaScript VM-based simulator and, because it’s lacking a UI, you’ve
    seen its output through Remix. In the next chapter, you’ll take a step further
    and install an Ethereum client. You’ll then deploy SimpleCoin to a real Ethereum
    network and interact with it again.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the compiler configured in the Compile tab is version 0.4.25, Remix will
    only allow you to enter addresses with a valid checksum in the code editor. I’ll
    explain what a valid checksum is in [chapter 5](kindle_split_017.xhtml#ch05).
    But for now, it means `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c` (all in lowercase)
    and `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` aren’t interpreted as being equivalent
    to each other. Unfortunately, addresses in the Account drop-down within the Run
    tab are all in lowercase and therefore aren’t compliant. If you want to know the
    corresponding address with a valid checksum, you can use Etherscan, the online
    blockchain viewer ([https://etherscan.io/](https://etherscan.io/)). Enter the
    incorrectly formatted address (for example, `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c)`
    in the text box at the top of the screen, and you’ll see the correctly formatted
    corresponding address (`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`) in the Address
    header also at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A decentralized application is a novel type of application that isn’t owned
    or controlled by any entity and runs on a trustless decentralized P2P network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topology of a decentralized application is different from that of a conventional,
    centralized, one because both its business logic layer and its data layer (the
    blockchain) are fully replicated on each node of the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapps rely on blockchain technology, which is based, in turn, on public key
    cryptography, cryptographic hash functions, and the concept of mining through
    a consensus protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many appropriate use cases exist for decentralizing an application, especially
    in the fields of provenance and authenticity tracking, identity verification,
    regulatory auditing, prediction markets, and crowdfunding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized applications aren’t always the best solution for a business problem.
    For example, it doesn’t make sense to decentralize an internal enterprise application
    that isn’t shared with any external participant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement smart contracts, which are at the heart of Dapps, within the
    Ethereum platform in a language called Solidity, similar to JavaScript. It’s possible
    to write simple smart contracts through the Remix Solidity IDE and simulate their
    activation and interaction with various mock Ethereum accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 2\. Understanding the blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level details of an Ethereum node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technology stack you use to build Ethereum Dapps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technologies underlying the Ethereum blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum’s history and governance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: I intended [chapter 1](kindle_split_012.xhtml#ch01) to give you a high-level
    overview of decentralized applications without overwhelming you with too many
    details. Consequently, I’m sure you’re still wondering what technical stack you
    need to learn to build a full Dapp. Also, you might feel the architectural presentation
    on Dapps didn’t go as far as you’d have liked, and you might still have doubts
    about how a blockchain exactly works. If you’re asking yourself these questions,
    I’ll address them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start by revisiting the voting Dapp I introduced in the previous chapter,
    and I’ll cover some aspects of an Ethereum node I skipped earlier for simplicity.
    I’ll then cover the entire technology stack required to implement a full end-to-end
    decentralized application. Additionally, I’ll introduce the cryptographic concepts
    and foundations you need to acquire to appreciate how a blockchain works. Before
    closing the chapter, I’ll present technologies specific to the Ethereum blockchain
    and give you some information on Ethereum’s history and governance.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. A deeper look at decentralized applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I presented the structural and transactional views of a decentralized application
    in [chapter 1](kindle_split_012.xhtml#ch01), I decided to keep them at a relatively
    high level. I’m aware blockchain technology might be completely new to you, so
    I wanted to make sure you understood the high-level architecture and the purpose
    of decentralized applications without confusing you with too much jargon and too
    many technologies. Now that you’ve acquired a solid foundation, it’s time to have
    a deeper look at Ethereum Dapps. Let’s start by stepping into an Ethereum node.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1\. Inside an Ethereum node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As shown in [figure 2.1](#ch02fig01), each node of the Ethereum P2P network
    contains two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An Ethereum client*—This acts as a runtime and contains four elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine called *Ethereum Virtual Machine (EVM)*, capable of executing
    smart contract code generally written in a language called Solidity and compiled
    into EVM bytecode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.1\. An Ethereum node includes an Ethereum client and a blockchain
    database. The client contains a client process, an Ethereum Virtual Machine, a
    memory pool, and a JSON-RPC API exposing the functionality of the node externally.
    There are two types of nodes: full nodes and mining nodes.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-01_alt.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: A *memory pool*, where the node stores transactions that it receives, such as
    a vote submitted by a voter from the client side, before it propagates them further
    into the network.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *client process*, which coordinates the processing. It handles incoming messages
    and transactions, dispatches them to the EVM when appropriate, and stores transactions
    to, and retrieves them from, the memory pool. The client process also handles
    incoming blockchain blocks that the node receives from peer nodes and appends
    them to the local copy of the blockchain database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *JSON-RPC API*, which exposes the functionality of the client to other nodes
    and external users.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A blockchain database*—Apart from transaction data, such as votes submitted
    by voters, the blockchain also keeps a copy of the EVM bytecode of all smart contracts
    deployed on the network and holds their state. Mining nodes append new blocks
    to the blockchain regularly, every 15 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.2\. Revisiting the lifecycle of a transaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know an Ethereum node hosts a JSON-RPC interface, an EVM, and a
    memory pool, I can explain to you, with the help of some diagrams ([figures 2.2](#ch02fig02)
    to [2.4](#ch02fig04)), what role they play during the transaction lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2\. The lifecycle of a transaction. A voting transaction is created
    when a function is invoked on a smart contract on a chosen Ethereum node through
    the JSON-RPC interface. The node places the transaction in the memory pool and
    executes it on the EVM for validation. If the validation is successful, the transaction
    is broadcast to peer nodes until it reaches a mining node; otherwise, it dies
    out.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A transaction is generated when a function is invoked on a smart contract of
    the chosen Ethereum node through the JSON-RPC interface. (See [figure 2.2](#ch02fig02).)
  prefs: []
  type: TYPE_NORMAL
- en: A full node receives the transaction from a peer node and places it in the memory
    pool. (See [figure 2.2](#ch02fig02).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full node executes the transaction on the EVM for validation. (See [figure
    2.2](#ch02fig02).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the validation is successful, the node broadcasts the transaction to its
    peer nodes. If the validation is unsuccessful, the node doesn’t propagate the
    transaction further, and it dies out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mining node places the transaction received from a peer node in the memory
    pool. (See [figure 2.3](#ch02fig03).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mining node picks transactions deemed to be profitable from the memory pool,
    executes them on the EVM, and tries to add them onto a new block. (See [figure
    2.3](#ch02fig03).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the block created is added successfully to the blockchain, the mining node
    removes the related transactions from the memory pool. (See [figure 2.3](#ch02fig03).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.3\. A mining node receives the transaction from a peer node and places
    it in its memory pool. The node later picks it and executes it on the EVM, among
    other transactions, to place it on a new block. If the block is appended on the
    blockchain, the transaction is removed from the memory pool and the block is broadcast
    to peer nodes.
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-03_alt.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The node broadcasts the new block to peer nodes. (See [figure 2.3](#ch02fig03).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A full node receives the new block from a peer node. (See [figure 2.4](#ch02fig04).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full node executes all the block transactions on the EVM for validation.
    (See [figure 2.4](#ch02fig04).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node removes all the associated transactions from its memory pool if the
    block has been validated successfully. (See [figure 2.4](#ch02fig04).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node broadcasts the block to peer nodes. (See [figure 2.4](#ch02fig04).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.4\. The full node’s process, from when it receives the new block to
    when it processes all its transactions on the EVM for validation, then, if validation
    is successful, removes the related transactions from the memory pool and propagates
    the block further into the network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '2.1.3\. Development view: Deploying the voting smart contract'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By now, you should have a good idea of both what a decentralized application
    looks like and how a transaction flows throughout the system. You might still
    be wondering, though, when and how a smart contract gets propagated throughout
    the network. It turns out that the server-side contract propagation process is
    similar to that of a standard transaction, such as the voting transaction analyzed
    in the previous chapter in [figure 1.8](kindle_split_012.xhtml#ch01fig08).
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum smart contract, such as the voting smart contract of the voting
    Dapp, is code written in the Solidity language. A smart contract developer compiles
    the code into EVM bytecode and then deploys it across the P2P network through
    a contract deployment transaction, which executes on a local Ethereum node and
    then propagates throughout the network. During its propagation throughout the
    network, a mining node processes the deployment transaction and stores its EVM
    bytecode on the blockchain, as illustrated in [figure 2.5](#ch02fig05).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5\. A developer writes the voting smart contract in the Solidity language,
    then compiles it into EVM bytecode and inserts it into a contract deployment transaction.
    This is pushed to the local Ethereum node and propagated throughout the network.
    It’s then mined and appended to the blockchain.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might have noticed, while going through the static, dynamic, and development
    views of a Dapp, in these two initial chapters, that I’ve mentioned languages
    and Java-Script libraries that might be unfamiliar to you. You shouldn’t be particularly
    worried about the amount of technology you’ll have to learn. You can implement
    a Dapp based on the Ethereum blockchain with languages much like those used in
    centralized apps you’re already familiar with. The client side of a Dapp is generally
    based on standard HTML5 + JavaScript; the communication layer between the UI and
    the server side is based on a JavaScript library called Web3 that’s executed on
    the client side; and you can implement server-side smart contracts in Solidity,
    which is a flavor of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Your journey through this book will continue, as shown in [figure 2.6](#ch02fig06),
    from the server side, which is the core of decentralized applications, and you’ll
    write smart contracts in Solidity. Then you’ll learn how to interact with a smart
    contract remotely through the Web3.js JavaScript library. Finally, you’ll implement
    a web-based UI, built on HTML and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6\. You’ll progress from writing smart contracts in Solidity, to interacting
    with smart contracts remotely through the Web3.js Java-Script library, to building
    a web UI in HTML and JavaScript.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In summary, with some knowledge of JavaScript, or any C-like language, it isn’t
    difficult to transition from centralized to decentralized application development.
    But during that transition, it’s important to fully understand the technologies
    underlying decentralized applications, because they’re rather different from the
    technologies that centralized applications are built on. We’ll explore that in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. What technologies make Dapps viable?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you know, a Dapp is based on business logic encapsulated into smart contracts
    that are executed against a distributed database called blockchain. Blockchain
    technology is based, in turn, on public key cryptography, cryptographic hash functions,
    and the concept of consensus, which you can implement using *proof of work* and
    *proof of stake* algorithms, among other ways.
  prefs: []
  type: TYPE_NORMAL
- en: You might be feeling like I keep opening more and more Russian dolls, and this
    might never end, but please don’t get frustrated! Cryptography is the lowest level
    I’m going to cover, I promise.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1\. Blockchain technologies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next several sections, I’ll explain briefly all the cryptographic terms
    I’ve just mentioned so you can form a mental model of how a blockchain database
    works before we proceed further. Public key cryptography is the lowest technological
    block underlying the blockchain, so let’s start from there.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Public key cryptography* is an encryption methodology based on a pair of keys:
    a *private key*, usually generated randomly, which is known only to its owner,
    and a *public key*, known to everyone, generated from an algorithm that takes
    the private key as an input. [Figure 2.7](#ch02fig07) illustrates how private
    and public keys are generated.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7\. A private key is generated with a random number generator. It’s
    then fed to an algorithm that generates a public key.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To better visualize it, think of the private key as the physical key of your
    mailbox (only you have a copy of it) and the public key as your postal address
    (everyone knows it), as shown in [figure 2.8](#ch02fig08).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8\. To understand the purpose of private and public keys, you can think
    of the public key as your postal address, known by everybody, and the private
    key as the key to your mailbox, only owned by you.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The private key has two main purposes, as illustrated in [figure 2.9](#ch02fig09):'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the decryption of data that has been encrypted using the public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows someone to digitally sign a document. They can produce the signature
    only if they know the private key, but anyone who knows the public key can verify
    the signature. As you’ll see, the authenticity of smart contract transactions
    relies on digital signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2.9\. You can use a private key to decrypt a document that has been encrypted
    with the related public key, as you can see in the top diagram. As shown in the
    bottom diagram, a private key also allows someone to sign a document digitally
    to prove provenance. The generated digital signature can then be verified against
    the document and the related public key.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the context of a blockchain platform, cryptocurrency is generally stored
    against an account that is identified by a public key but can be operated only
    if you know the private key. If the private key is forgotten or lost, no one can
    use the account anymore, and its funds are considered lost.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *hash function* is any function that can map data of arbitrary size to data
    of fixed size. The fixed size data is called hash or digest. To give an example,
    you can design a hash function so that it always generates a 64-bit hash from
    a file or string of any size. Whether its size is 10 KB or 10 GB, a 64-bit hash
    will be generated, as illustrated in [figure 2.10](#ch02fig10).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10\. A hash function produces a hash of a fixed size (64 bits in this
    example) given an input of any size.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A *cryptographic hash function* is a hash function that has five additional
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s deterministic*. The same input will always generate the same hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It’s quick to compute*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It’s a one-way function, unfeasible to invert*. This means that the only way
    to deduce the original data from its hash would be to try, by brute force, to
    obtain the same hash by applying the function to an enormous number of input data
    sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It should be almost impossible to obtain the same hash from two different
    sets of input data*. Although a small chance exists that two inputs might produce
    the same hash, it’s impossible to determine them a priori, without applying the
    function to an enormous number of inputs, as suggested in the previous point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A slight change in the input data should produce substantially different hash
    values*. Consequently, also because of what I said in the previous point, unless
    you’re applying the cryptographic hash function to the same input, you won’t be
    able to *intentionally* get the same hash or even a close one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given these properties, think about the following scenario. Imagine you’re writing
    a check for $30 to pay for the latest blockchain book from your local bookstore.
    I know, checks are almost no longer used and, if you’re a young reader, you might
    never have seen one! Please bear with me for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: You filled out and signed the check, and you’re on your way to the bookstore,
    when, while on your mobile phone chat app, you trip over a curb. You don’t realize
    the check falls on the road and a gust of wind takes it away. You’re so unlucky
    that it ends up in the hands of Jack Forger, a local petty criminal. He knows
    how to remove ink, and he quickly replaces the amount and recipient as shown in
    [figure 2.11](#ch02fig11).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11\. A physical check forged by reusing the original signature and
    altering the recipient and amount
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jack then goes to a bank and successfully cashes the check for $30,000\. The
    criminal had your handwritten signature and was able to replace the name of the
    recipient and the amount. Let’s see how a digital signature on an electronic check
    would avoid this unpleasant situation.
  prefs: []
  type: TYPE_NORMAL
- en: The digital signature on an electronic check would be a cryptographic hash produced
    using as the input the details of your check, the amount you’re paying, and the
    recipient, together with a private key associated with your bank account (the
    equivalent of your handwritten signature), as illustrated in [figure 2.12](#ch02fig12).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12\. An e-check can be secured with a digital signature generated with
    the private key associated with the sending bank account and the details of the
    check. It can be verified by checking the digital signature against the public
    key associated with the sender bank account and the check details.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When someone presents this kind of electronic check to a bank, together with
    the public key associated with your bank account, the bank can verify that the
    digital signature matches the details of the check (amount and recipient) and
    has been produced using your private key. That’s how the bookstore owner will
    be able to cash your check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the digital signature is a cryptographic hash, that exact signature
    can only be produced from the specific details you used when filing the electronic
    check. If someone tried to hijack the electronic check—let’s say a group of skilled
    hackers—changing the amount and, most importantly, the recipient would be pointless
    for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: A new amount or recipient would generate a completely different digital signature,
    so the bank wouldn’t recognize the current one as valid, as shown in [figure 2.13](#ch02fig13).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hackers attempted to generate a new digital signature with new check
    details, they couldn’t generate one that could be associated with the public key
    of your bank account because they don’t know your private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.13\. An attempt at forging an e-check secured by a digital signature
    is unsuccessful because the new original digital signature doesn’t match the altered
    check details.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-13_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Blockchain transactions are much like the electronic check described here:'
  prefs: []
  type: TYPE_NORMAL
- en: They originate from an account identified by a public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They contain transaction details, such as an amount of cryptocurrency and the
    recipient, also identified by a public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They carry a digital signature proving the transaction details have been entered
    by the owner of the sender account through their private key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain transactions don’t have to carry cryptocurrency; they can carry any
    data. The crucial point is that by carrying a digital signature, they can prove
    they’ve been genuinely sent by the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash functions aren’t only useful for digital signatures. If you’re
    interested in finding out more, read in the sidebar how you can use them to protect
    a seller from malicious buyers.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Protecting a seller from malicious buyers with a commit-reveal scheme**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptographic hash functions can be handy in various situations. Do you remember
    the decentralized e-commerce application I described at the beginning of [chapter
    1](kindle_split_012.xhtml#ch01)? If you’re reading this book with the mindset
    of a seller, you might have found the solution not as convincing as when seen
    through the eyes of a buyer. For example, there seems to be nothing, in the solution
    presented, preventing the user from accepting the goods and then not authorizing
    the payment to the seller. That’s disappointing! Don''t despair: cryptographic
    hash functions to the rescue!'
  prefs: []
  type: TYPE_NORMAL
- en: You could make the application more secure for sellers if you required the buyer
    to generate a secret code, for instance a secret phrase or a random number, and
    then supply its cryptographic hash to the seller during the confirmation of the
    order. You could view this hash as a sort of keylock for the payment. When delivery
    comes, the courier would hand the goods over only upon receipt of the secret code,
    which, when supplied to the e-commerce Dapp, would generate the expected initial
    hash code and, as a physical key into its associated keylock, would unlock the
    payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of initially providing a hash of the original information and then
    revealing the full information in a second stage is called a *commitment scheme*
    or *commit-reveal scheme*, and it has two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The commit phase, during which a cryptographic hash of the original information
    produced with a disclosed algorithm is committed to the other party
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reveal phase, during which the full information is revealed, and it’s verified
    against the committed hash to prove the revealed information is indeed associated
    with the hash
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This powerful idea of proving the knowledge of some information without revealing
    the information itself had already been used in the 16th century by Galileo, who
    initially published his discovery of the phases of Venus in an anagram of the
    original paper, before finalizing his research. Hooke and Newton later used a
    similar technique to conceal the details of their discoveries, while at the same
    time being able to claim they were the first to make such discoveries.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, you’ll see how this idea is used to secure decentralized
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Congratulations, you’ve completed the Cryptography 101 course! I hope it wasn’t
    too painful. You now have the necessary tools to understand how a blockchain works.
    Now we’ll enter the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A blockchain is a distributed database that holds records called blocks. [Figure
    2.14](#ch02fig14) illustrates the structure of a typical blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14\. A blockchain is a sequence of blocks, each containing a sequence
    number, a timestamp, and a list of transactions, each individually digitally signed.
    Each block also references the cryptographic hash of the previous block.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A block includes a list of transactions, which are digitally signed to prove
    their provenance. Most blockchains digitally sign transactions with an *elliptic
    curve digital signature algorithm* (ECDSA), based on elliptic-curve cryptography,
    rather than a traditional digital signature algorithm (DSA), because ECDSA is
    harder to break and uses smaller keys to guarantee the same level of security.
    Each block contains a timestamp and a link to a previous block based on its cryptographic
    hash. It also contains a cryptographic hash summarizing the full content of the
    block, including the hash of the previous block. In this way, the blockchain holds
    both the current state (the latest block) and the full history of all the transactions
    that have been stored on it since its inception.
  prefs: []
  type: TYPE_NORMAL
- en: This structure guarantees transactions can’t be tampered with or modified. A
    transaction recorded in a block can’t be altered retroactively because to modify
    it, the hash of the block containing it would have to be regenerated, and this
    wouldn’t match the existing one already referenced by subsequent blocks, as shown
    in [figure 2.15](#ch02fig15).
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15\. An attempt at altering the contents of a block, for example its
    transactions, won’t be successful: the new hash generated from the altered block
    details won’t match the original block’s hash already directly referenced in the
    next block and indirectly referenced in the subsequent blocks.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-15_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If two transactions contradict each other—for instance, each of them tries to
    transfer all the funds of the same account to a different destination account
    (known as a “double-spend attack”)—miners will execute only the first one, recognized
    in the Ethereum network through a globally accessible sequence number. They will
    reject the second one, and it will never appear on a consolidated block. Satoshi
    Nakamoto of Bitcoin was the first to solve the double-spend problem. Every blockchain
    has a solution for it; otherwise, it wouldn’t be viable.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The blockchain structure I’ve described is, in fact, a simplified version of
    real-world blockchain data structures such as the Merkle tree used by Bitcoin
    or the Patricia tree used in Ethereum. A blockchain is managed autonomously through
    a P2P network that facilitates fault tolerance and decentralized consensus by
    processing all transactions independently on each node. Given these characteristics,
    blockchains are particularly suitable for recording permanently the history of
    events. This is useful for identity management, transaction processing, and provenance
    tracking, to name a few use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To encourage the P2P network supporting the blockchain to process its transactions
    continuously, active processing nodes, also called *mining nodes* or *miners*,
    are rewarded for the computational resources provided, and indirectly to cover
    the associated electricity costs, through the *consensus* mechanism. Every few
    seconds, one successful miner is entitled to generate and keep a certain number
    of tokens of the cryptocurrency supported by the platform. Such cryptocurrency
    has economic value, as it can be used to purchase services on the network, but
    it also can be exchanged for conventional currencies, such as dollars, yen, euros,
    and so forth. In the case of the Bitcoin blockchain, they’ll be given several
    Bitcoin tokens, worth around $2,000 each at the time of writing. The tokens given
    by the Ethereum blockchain are called Ether, and they’re worth around $200 each
    at the time of writing. Let’s now look at how the consensus mechanism works.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consensus is, as I mentioned earlier, the mechanism by which participant nodes
    of the network agree on the outcome of a transaction. In the consensus definition
    I presented at the beginning of [chapter 1](kindle_split_012.xhtml#ch01), I also
    emphasized that consensus is distributed, because it’s determined by many participants,
    and trustless, because the participants don’t need to trust each other. In fact,
    consensus isn’t reached on individual transactions but on new blockchain blocks.
    Each participant verifies independently that a new block is valid and, if satisfied,
    propagates it further to the rest of the network.
  prefs: []
  type: TYPE_NORMAL
- en: What happens in practice is that if most participants have accepted the block
    as valid and it has propagated successfully throughout the network, miners will
    use such a block as the latest valid block, and the rest of the blockchain will
    be built on it. If a malicious miner appended an incorrect block to the blockchain
    and it propagated to its peer nodes, these nodes would reject the new block, and
    the malicious chain would die out immediately. The same would happen if a full
    node tried to modify a block before propagating it to its peers.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the key step of the consensus mechanism is the verification
    of the latest block by a participant node. After verifying the digital signature
    of the individual transactions present on a block, a participant node verifies
    that the hash of the block is valid. Such hash is produced by miners according
    to an agreed protocol. The earlier versions of Ethereum used an algorithm called
    *Ethash*, based on a Proof of Work protocol. Future versions will be based on
    a Full of Stake protocol called *Casper*. I’ll explain both protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Work
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you saw earlier, a block contains a cryptographic hash summarizing the full
    content of the block, including its metadata and transactions data, and an additional
    piece of data of a fixed length, such as 32 bits, called *nonce*. The objective
    of the Proof of Work (PoW) protocol is that miners must find a nonce such that
    the hash generated fits a certain constraint, for instance, having many leading
    zeros. Constraining a 64-bit unsigned integer hash to have 13 leading zeros when
    represented in hexadecimal format, as in the example of [figure 2.16](#ch02fig16),
    reduces the number of valid hashes from the theoretical maximum number of 18,446,744,073,709,551,615
    to 4,095.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16\. Proof of Work: generation of an unsuccessful and a successful
    block hash'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-16_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because of the properties of hash functions you saw earlier, the only way a
    miner can find such a nonce is by trying many possible values until the constraint
    on the hash has been met. In the example I just gave, every such attempt will
    only have a roughly 0.00000000000002% chance of being successful. When a satisfactory
    hash has been found, the miner is entitled to append the new block being processed
    to the blockchain and claim the token reward. As you can understand, this way
    of producing a valid hash is CPU-intensive, energy-consuming, and, consequently,
    economically expensive. The main reason for such an expensive algorithm is to
    dissuade malicious participants from appending new incorrect blocks or modifying
    preexisting blocks and making them look like genuine blocks. The amount of energy
    (and money) necessary to perform such actions would make them unviable. In the
    sidebar in [section 3.3.4](kindle_split_014.xhtml#ch03lev2sec11), I’ll give you
    an idea of the hardware most miners use.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Proof of Work, which the Bitcoin network also uses, has been widely criticized
    for the immense amount of energy consumed (or rather, wasted?) by the competing
    miners. It has been estimated that the Bitcoin network alone will consume as much
    electricity as Bulgaria by 2020.
  prefs: []
  type: TYPE_NORMAL
- en: To tackle this problem, Vitalik Buterin, one of the Ethereum founders, has proposed
    an alternative approach based on a Proof of Stake. This is based on a pool of
    *validators* that vote on the validity of new blockchain blocks. To join the validator
    pool, which is open to anyone, a node must commit an Ether deposit that will be
    held until the node leaves the pool. Votes expressed by each node are weighted
    on the amount of the deposit committed (which equates to the stake of a node in
    the pool). Under this scheme, a validator profits from transaction fees that the
    transaction senders pay. If a validator cheats, the associated Ether deposit is
    deleted from the network and the owner is banned from rejoining, which acts as
    a deterrent against manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now covered all the general cryptographic techniques underlying blockchain
    databases. If you’d like to learn more about the subject, I encourage you to read
    *Grok-king Bitcoin* by Kalle Rosenbaum) (Manning, 2019). Let’s now examine more
    recent technologies that have simplified Dapp development.
  prefs: []
  type: TYPE_NORMAL
- en: The Merkle tree and Merkle root
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The blockchain structure I’ve shown in the previous diagrams is a simplified
    representation of a real one. Generally, a miner places in the block two parts:
    a *header* and a *body*, as shown in [figure 2.17](#ch02fig17). The body contains
    all the transactions included in the block. The header contains the block metadata
    you saw earlier, such as the block number, timestamp, previous block hash, and
    PoW nonce. It also contains the *Merkle root* of the *transactions Merkle tree*
    that the miner calculates.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17\. The structure of a block, including a header containing metadata,
    such as the block number, timestamp, previous block hash, and Merkle root of the
    transactions Merkle tree, and a body containing the transactions collection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-17_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The transactions Merkle tree, as shown in [figure 2.18](#ch02fig18), is a tree
    structure built as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The block’s transactions are placed at the bottom of the tree, arranged in pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each transaction is hashed, and each of these hashes becomes a leaf of the Merkle
    tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash is calculated for each pair of contiguous hashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hashing of contiguous hashes is repeated until only two hashes remain. The
    hash of these two final hashes is the *Merkle root*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.18\. A Merkle tree. Individual transactions are located at the bottom;
    the tree’s leaves are the hashes of the individual transactions; and the next
    row up is made of the hashes of the tree’s leaves. The top row, which is the hash
    of the hashes below, ends the tree: this is the Merkle root.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-18_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Merkle root is therefore a single hash summarizing all of the transactions
    contained in the block in a way that guarantees their integrity. The advantage
    of having the Merkle root on the block header is that a client can synchronize
    the blockchain in a faster way by retrieving the block headers, rather than the
    entire transaction history, from the network peers. This is generally called *light
    synchronization*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2\. Ethereum technologies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although smart contracts can be implemented, with some difficulty, on early
    blockchain systems such as Bitcoin, they can be more easily written and executed
    on later blockchain platforms, such as Hyperledger, Nxt, and Ethereum, that have
    been designed with the main purpose of simplifying their development. For this
    reason, later blockchain platforms are considered part of the so-called *smart
    blockchain* or *blockchain 2.0* wave. Let’s now examine briefly the main innovations
    that Ethereum has introduced: an improved blockchain design, the EVM, and smart
    contracts.'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the previous section, you learned about the blockchain and a more efficient
    structure that allows quicker client synchronization based on a block header containing
    a block’s metadata and a body containing the transactions. The Ethereum blockchain
    improves the design further. First of all, transactions are hashed in a more compact
    and efficient (yet still cryptographically authenticated) structure called a *Merkle-Patricia
    trie* (see sidebar for more details). Secondly, the block header (generated as
    usual by the miner) also contains, in addition to the Merkle-Patricia root of
    the transactions, the Merkle-Patricia root of the receipts, which are the transaction
    outputs, and the Merkle-Patricia root of the current blockchain state, as shown
    in [figure 2.19](#ch02fig19).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19\. An Ethereum improved block header. The header of a block of the
    Ethereum blockchain contains the root of the transactions Merkle- Patricia trie,
    which is a more compact and efficient structure than a Merkle tree. In addition,
    it contains the Merkle-Patricia root of receipts (which are the transactions effects)
    and the blockchain state.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-19_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As Vitalik Buterin explained in his blog post “Merkling in Ethereum,”^([[1](#ch02fn01)])
    with these three Merkle-Patricia tries, a client can efficiently check, in a verifiable
    way, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Merkling in Ethereum,” Ethereum Blog, November 15, 2015,
    [http://mng.bz/QQYe](http://mng.bz/QQYe).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether a certain transaction is included in a certain block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the output of a transaction would be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether an account exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the balance of an account is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**The Merkle-Patricia trie**'
  prefs: []
  type: TYPE_NORMAL
- en: A *trie*^([[2](#ch02fn02)]) (or *prefix* *tree*) is an ordered data structure
    you use to store a dynamic set, where the keys are usually strings. The root of
    a trie is an empty string, and then all the descendants of a node have the common
    prefix of the string associated with that node, as you can see in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: ²
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the “Trie” Wikipedia page at [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    for more information on this data structure.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/f0053-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Trie structure (Credit: Booyabazooka (based on a PNG image by Deco). Modifications
    by Superm401\. - own work (based on PNG image by Deco))'
  prefs: []
  type: TYPE_NORMAL
- en: The Merkle-Patricia trie is a data structure that combines a trie and Merkle
    tree. It improves the efficiency of a Merkle tree (named after Ralph Merkle) by
    storing the node keys using the *PATRICIA* algorithm (*practical algorithm to
    retrieve information coded in alphanumeric*), designed by D. R. Morrison in 1968\.
    You can read about the Patricia algorithm on the Lloyd Allison Algorithm Repository.^([[3](#ch02fn03)])
    The Ethereum Merkle-Patricia trie is described in detail, with code examples,
    in the Ethereum wiki.^([[4](#ch02fn04)])
  prefs: []
  type: TYPE_NORMAL
- en: ³
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/](http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁴
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'When a full node receives a new block, the transactions contained in the body
    are processed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The transactions are arranged in a transaction Merkle-Patricia trie specific
    to the new block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions are executed on the EVM. This action generates transaction receipts,
    which are arranged in a receipts Merkle-Patricia trie specific to the new block.
    It also alters the global state trie, of which only one instance exists on each
    node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the roots of the new transaction trie, receipt trie, and modified state
    trie match those in the header, the block is considered validated. Then the new
    and altered tries are stored on the full node in a respective key-value store
    based on LevelDB, an open source NoSQL database developed by Google. Note the
    following in [figure 2.20](#ch02fig20):'
  prefs: []
  type: TYPE_NORMAL
- en: The *transaction store* contains a transaction trie per block, and each trie
    is immutable. The key of this store is the transaction hash (keccak 256-bit hash).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *receipts store* contains a transaction trie per block, and each trie is
    immutable. The key of this store is the hash of the receipts of a transaction
    (keccak 256-bit hash).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *state store* contains a single *state trie* that represents the latest
    global state and is updated each time a new block is appended to the blockchain.
    The state trie is account-centric, so the key of this store is the account address
    (160 bytes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2.20\. Detailed block processing in an Ethereum node. When a full node
    receives a new block, it separates the header and the body. It then creates a
    local transactions trie and a local receipts trie and updates the existing state
    trie. The new and updated tries are then committed in the respective stores.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-20_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A major benefit of the Ethereum blockchain design is that it allows three types
    of synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Full*—Your client downloads the entire blockchain and validates all blocks
    locally. This is the slowest option, but you’d be confident of the integrity of
    the local blockchain copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fast*—Your client downloads the entire blockchain, but validates only the
    64 blocks prior to the start of the synchronization and the new ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Light*—Your client retrieves the current state trie of the blockchain from
    a peer full node and stores it locally. It doesn’t retrieve any historic blocks
    from peers, and it receives only the new ones, so you don’t have to wait long.
    This will allow you to get up and running quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although in this section I’ve covered the physical design of the Ethereum blockchain
    in some detail because it’s important you understand how transactions and state
    are maintained, in the rest of the book I’ll use simplified logical diagrams in
    which I’ll represent a block as a collection of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Ethereum Virtual Machine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *Ethereum Virtual Machine (EVM)* is similar in purpose to the Java Virtual
    Machine (JVM) or the .NET Common Language Runtime (CLR). It runs on each node
    of the Ethereum P2P network. It’s Turing complete, which means it can run code
    of any complexity. It can access blockchain data, both in read and write mode.
    The EVM executes code only after its digital signature has been verified and constraints
    based on the current state of the blockchain are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *smart contract,* or simply *contract*, encapsulates the logic of a decentralized
    application. As I mentioned earlier, an Ethereum smart contract is written in
    a high-level language, such as Solidity or Serpent, and is compiled into EVM bytecode.
    It gets deployed on each node of the P2P network and is executed on the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Next generation blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thanks to the EVM, Ethereum is a *programmable blockchain*. Therefore, you can
    develop any type of decentralized application on it, not only cryptocurrencies,
    as was the case for earlier blockchains. Because of this programmability, Ethereum
    is considered a generalized or next generation blockchain. Some go as far as thinking
    smart blockchain platforms will be the foundation of a new generation of the internet,
    a Web 3.0 (although this exact version of the web is also used by the “semantic
    web” community), which will be characterized by more empowered users.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Ethereum’s history and governance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before closing the chapter, I’d like to share how Ethereum was created and how
    it evolved after the initial release. In the next few chapters, you’ll start using
    several components of the Ethereum platform. Before you do so, it’s important
    you understand how these components came about and what the process is for proposing
    and agreeing on changes. You’ll realize decentralization isn’t only a technical
    aspect of Ethereum; it’s almost a philosophy that also permeates its governance.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1\. Who created Ethereum?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ethereum is the brainchild of Vitalik Buterin, an early follower of bitcoin
    and cryptocurrency technology since 2011, when he also cofounded Bitcoin magazine.
    After researching the possibility of generalizing blockchain technology for building
    any application, in November 2013 he wrote the *Ethereum White Paper* ([https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)),
    in which he laid out the design of the Ethereum protocol, together with the first
    details of the smart contract infrastructure. Among the first people who engaged
    with Vitalik’s vision were Gavin Wood, who contributed to the shaping of the protocol
    and became the lead developer of the C++ client, and Jeffrey Wilcke, who became
    the lead developer of the Go client. After only a few months of work, in January
    2014, Vitalik announced the Ethereum initiative on bitcointalk^([[5](#ch02fn05)])
    and received considerable response. Soon afterwards, in April 2014, Gavin wrote
    the *Ethereum Yellow Paper*,^([[6](#ch02fn06)]) which specifies the design of
    the Ethereum virtual machine. To accelerate the development of the platform, in
    July 2014 Ethereum raised around $18.4M through an Ether crowdsale, which was
    legally backed by the Ethereum Foundation, set up in Switzerland only one month
    earlier with the mission to do the following (quoting the official website at
    [https://www.ethereum.org/foundation](https://www.ethereum.org/foundation)):'
  prefs: []
  type: TYPE_NORMAL
- en: ⁵
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Welcome to the Beginning,” [https://bitcointalk.org/index.php?topic=428589.0](https://bitcointalk.org/index.php?topic=428589.0).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁶
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “About the Ethereum Foundation,” [https://github.com/ethereum/yellowpaper](https://github.com/ethereum/yellowpaper).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...promote and support Ethereum platform and base layer research, development
    and education to bring decentralized protocols and tools to the world that empower
    developers to produce next generation decentralized applications (Dapps), and
    together build a more globally accessible, more free and more trustworthy Internet.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Table 2.1](#ch02table01) summarizes Ethereum’s timeline since its inception
    to the time of writing of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1\. Ethereum timeline from inception to summer 2018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Sep 2011 | Vitalik Buterin cofounds Bitcoin magazine with Mihai Alisie. |'
  prefs: []
  type: TYPE_TB
- en: '| Nov 2013 | Vitalik publishes the Ethereum White Paper, presenting the design
    of the Ethereum protocol and the smart contract infrastructure. |'
  prefs: []
  type: TYPE_TB
- en: '| Dec 2013 | Gavin Wood contacts Vitalik, and they start detailed design discussions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jan 2014 | Vitalik makes the official Ethereum announcement on bitcointalk.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Apr 2014 | Gavin wood publishes the Ethereum Yellow Paper, which specifies
    the Ethereum virtual machine (EVM). |'
  prefs: []
  type: TYPE_TB
- en: '| Jun 2014 | The Ethereum Foundation is set up in Switzerland. |'
  prefs: []
  type: TYPE_TB
- en: '| Jul 2014 | Ethereum raises $18.4M through an Ether crowdsale. |'
  prefs: []
  type: TYPE_TB
- en: '| Aug 2014 | Vitalik Buterin, Gavin Wood, and Jeffrey Wilcke set up ETH DEV,
    a nonprofit organization focused on the development of the core Ethereum protocol
    and infrastructure, which managed the development of various proofs of concept
    throughout 2014. |'
  prefs: []
  type: TYPE_TB
- en: '| Nov 2014 | ETH DEV organizes DEVCON-0, the first Ethereum developer conference,
    in Berlin, where the entire Ethereum project team meets for the first time. |'
  prefs: []
  type: TYPE_TB
- en: '| Jan 2015 | The Go Ethereum team meets in Amsterdam, where Whisper Dapp and
    Mist prototypes are presented. |'
  prefs: []
  type: TYPE_TB
- en: '| Jul 2015 | Mainnet release 1.0, codenamed Frontier, and the stable beta of
    Ethereum Wallet are released. |'
  prefs: []
  type: TYPE_TB
- en: '| Nov 2015 | In London, 400 people attend DEVCON-1, where more than 80 talks
    on each part of the Ethereum ecosystem are given. |'
  prefs: []
  type: TYPE_TB
- en: '| Mar 2016 | The project releases Mainnet release 2.0, codenamed Homestead.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jul 2016 | An unplanned Ethereum fork occurs following a DAO attack, and
    a split takes place between Ethereum and Ethereum Classic. (See the sidebar.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Oct 2017 | The project releases Mainnet release 3.0, codenamed Byzantium.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jun 2018 | The project releases the Proof of Stake (PoS) Testnet release,
    codenamed Casper. |'
  prefs: []
  type: TYPE_TB
- en: 'If you’re interested in knowing more about the history of Ethereum, the official
    documentation has a page^([[7](#ch02fn07)]) dedicated to it. But you can get a
    firsthand and more engaging account of the main events that took place around
    Ethereum’s creation in the blog posts “Cut and Try: Building a Dream,”^([[8](#ch02fn08)])
    by Taylor Gerring (a core Ethereum developer), and “A Prehistory of the Ethereum
    Protocol,”^([[9](#ch02fn09)]) by Vitalik Buterin himself.'
  prefs: []
  type: TYPE_NORMAL
- en: ⁷
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “History of Etherum,” Ethereum Homestead, [http://mng.bz/XgwM](http://mng.bz/XgwM).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁸
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Taylor Gerring, “Cut and Try: Building a Dream,” February 9, 2016, [http://mng.bz/y1BE](http://mng.bz/y1BE).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁹
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “A Prehistory of the Ethereum Protocol,” [http://mng.bz/MxRm](http://mng.bz/MxRm).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**The DAO attack and the split between Ethereum and Ethereum Classic**'
  prefs: []
  type: TYPE_NORMAL
- en: The DAO (which stands for decentralized autonomous organization) was one of
    the first mainstream Dapps in the Ethereum space. It was a decentralized venture
    capital fund. The DAO token holders were meant to vote on all investment decisions.
    While the DAO smart contract was still being developed, tokens were sold to investors
    through a crowdsale, a sort of decentralized crowdfunding application. (You’ll
    read more about crowdsales in [chapters 6](kindle_split_018.xhtml#ch06) and [7](kindle_split_019.xhtml#ch07).)
    This funding campaign, which took place in May 2016, managed to collect over 12M
    Ether, which at the time was worth around $150M (with Ether trading at $11).
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of the DAO contract was that groups of DAO token holders
    unhappy with decisions that the qualified majority made (investment decisions
    were approved with 20% of the votes) could split from the main DAO and create
    their own Child DAO, where they’d start to vote on different investment proposals.
    In June 2016, this feature, which had been identified by some community members
    as potentially weak from a security point of view, was exploited by a hacker,
    who managed to gain control of 3.5M Ether (worth around $50M at that time) through
    a recursive call that kept withdrawing funds.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Child DAO creation feature required funds to be withheld for 28
    days before they could be transferred out to another account, so the hacker couldn’t
    steal them immediately. This gave the DAO developers and the Ethereum community
    some time to propose solutions to prevent the theft. Finally, after a failed soft
    fork of the blockchain that would have blacklisted any transaction coming out
    of the DAO, the community voted for a hard fork, including a smart contract designed
    to return the stolen funds to the original owners. Although the majority had voted
    for the hard fork, some members of the community argued that the hard fork had
    broken various principles of the Ethereum white paper, mainly the promise that
    smart contract code is implicitly law and the guarantee that the blockchain is
    immutable. They consequently decided to keep the original blockchain running,
    and this was renamed Ethereum Classic.
  prefs: []
  type: TYPE_NORMAL
- en: You can find many articles and blog posts on the DAO attack, ranging in complexity
    from the technical to the high-level. Given that you don’t yet have a strong technical
    foundation in this area, if you want to learn more about this, I recommend you
    have a look at “The DAO, The Hack, The Soft Fork and The Hard Fork,”^([[10](#ch02fn10)])
    which describes in detail what happened without getting too much into the technical
    side. You’ll be able to understand the DAO attack better after having read [chapter
    15](kindle_split_029.xhtml#ch15) on security, but I cover it specifically because
    most of the techniques used are beyond the scope of this book. Nevertheless, if
    at that point you’re eager to jump to the technical details of the hack, I recommend
    the brilliant “Analysis of the DAO Exploit.”^([[11](#ch02fn11)])
  prefs: []
  type: TYPE_NORMAL
- en: ^(10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Antonio Madeira, “The DAO, The Hack, The Soft Fork and The Hard Fork,” July
    26, 2016, [http://mng.bz/a7NY](http://mng.bz/a7NY).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(11)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Phil Daian, “Analysis of the DAO exploit,” Hacking, Distributed, June 18,
    2016, [http://mng.bz/gNrn](http://mng.bz/gNrn).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 2.3.2\. Who controls Ethereum’s development?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the Frontier release back in July 2015, the hot topic of Ethereum governance
    started to gather momentum within the Ethereum Foundation, as well as across the
    wider Ethereum community. Key questions, such as “Who controls Ethereum’s development,”
    “How do changes get proposed,” and “Who approves them and how” got debated openly
    so that early adopters could be encouraged to use and trust the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain governance is about the rules and processes that participants must
    follow for making changes to the platform, and about how the rules and processes
    themselves should get defined. In short, it’s about who decides on changes and
    how the decisions get approved and followed.
  prefs: []
  type: TYPE_NORMAL
- en: ETH DEV, the nonprofit organization leading Ethereum development, gathers proposals
    in the Ethereum Improvement Proposals (EIPs, [https://eips.ethereum.org/](https://eips.ethereum.org/))
    repository.^([[12](#ch02fn12)]) This is based on established processes also followed
    by other open source projects—Python Improvement Proposals (PIPs) and Bitcoin
    Improvement Proposals (BIPs) are classic examples. Proposals are initially studied
    and Proofs of Concept (PoCs) often follow.
  prefs: []
  type: TYPE_NORMAL
- en: ^(12)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the EIPs page on GitHub at [https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a proposal gathers enough momentum (it’s considered interesting by the core
    Ethereum developers), it progresses to *Draft* status and might be debated further
    among the wider community at developer conferences or official online forums.
    If an informal consensus is reached, the proposal can progress immediately to
    *Accepted* or *Rejected* status. Accepted proposals get scheduled for future platform
    releases, and more effort is consequently put into them. Obviously, there’s always
    the risk that the participants won’t all agree with the proposal or its implementation,
    so the proposal is considered implicitly accepted only after most participants
    have adopted it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, some proposals cause heated debate in the wider community. In
    those cases, the decision isn’t clear-cut, and they go through formal on-chain
    voting. When it comes to on-chain voting, one of the following two competing models
    is generally followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Loosely coupled on-chain voting (aka informal governance)*—The community leaders
    (for example the Ethereum Foundation and ETH DEV) signal how to vote. Participants
    vote on-chain through a dedicated smart contract that weights their preference
    based on how much Ether they own. (This voting is often referred to as *coinvoting.*)
    The proposal is then implemented if the outcome of the voting is favorable. Although
    the vote is ethically binding, developers or other key participants, such as miners,
    might always decide not to implement or adopt the winning proposal, at risk of
    being stigmatized by the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tightly coupled on-chain voting (a.k.a on-chain governance)*—The proposal
    gets fully implemented before the vote takes place, generally by a group of developers
    backing it, and then a smart contract switches on the functionality in the production
    network only following successful on-chain voting. This model is often favored
    by purists, who argue the technical analysis shouldn’t be influenced by politics
    until the last stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled on-chain voting has been introduced in various blockchain platforms
    and has become somewhat fashionable. But like other established blockchain platforms,
    such as Bitcoin and Zcash, Ethereum tends to follow the principle of loosely coupled
    voting, openly supported by Vitalik Buterin in his blog post “Notes on Blockchain
    Governance.”^([[13](#ch02fn13)])
  prefs: []
  type: TYPE_NORMAL
- en: ^(13)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Notes on Blockchain Governance,” December 17, 2017, [https://vitalik.ca/general/2017/12/17/voting.html](https://vitalik.ca/general/2017/12/17/voting.html).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you can see, Ethereum governance is relatively informal and centralized,
    as core developers seem to have more decision-making weight than the wider community.
    The argument is that if everything went through formal voting, the platform would
    evolve too slowly. If you’re interested in reading more on Ethereum governance,
    I recommend the following articles:'
  prefs: []
  type: TYPE_NORMAL
- en: “Ethereum Is Throwing Out the Crypto Governance Playbook”^([[14](#ch02fn14)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(14)
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Ethereum Is Throwing Out the Crypto Governance Playbook,”
    Coindesk, March 14, 2018, [http://mng.bz/edwZ](http://mng.bz/edwZ).
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Experimental Voting Effort Aims to Break Ethereum Governance Gridlock”^([[15](#ch02fn15)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(15)
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Experimental Voting Effort Aims to Break Ethereum
    Governance Gridlock,” Coindesk, May 23, 2018, [http://mng.bz/pgQ0](http://mng.bz/pgQ0).
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: “A user’s perspective and introduction to blockchain governance”^([[16](#ch02fn16)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(16)
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Richard Red, “A user’s perspective and introduction to blockchain governance,”
    Medium, [http://mng.bz/O2VO](http://mng.bz/O2VO).
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Ethereum node hosts an Ethereum client and a copy of the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum client contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a virtual machine called Ethereum Virtual Machine (EVM), capable of executing
    smart contract bytecode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a memory pool, where transactions received by the node get stored before being
    propagated further into the network
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a JSON-RPC API, which exposes the functionality of the client to other nodes
    and external users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a client process, which coordinates the processing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum smart contract is code written in the Solidity language and compiled
    into EVM bytecode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum smart contract is deployed across the P2P network through a contract
    deployment transaction, pushed to a local Ethereum node, and then propagated throughout
    the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blockchain is a sequence of blocks, each containing a sequence number, a timestamp,
    and a list of transactions, each individually digitally signed. Each block includes
    a copy of the cryptographic hash of the previous block and the nonce, which generates
    the hash of the current block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main innovation introduced by Ethereum with respect to previous blockchain
    implementations is the EVM and the concept of the smart contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ethereum follows an informal governance model, where proposals go through the
    Ethereum Improvement Proposals (EIPs) process: they get analyzed by the core Ethereum
    developers, are often tried through Proofs of Concept (PoCs), and ultimately get
    accepted or rejected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, when an EIP causes heated debate, it gets formally voted on-chain
    by the participants, but, even if the vote is favorable, a proposal is considered
    practically accepted only when the majority of the participants have adopted it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 3\. The Ethereum platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Ethereum through the Ethereum wallet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the characteristics of Ethereum smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Ethereum through the Go Ethereum (geth) client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and managing accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The previous chapter introduced Dapps and the underlying concepts and technologies,
    among which is Ethereum. In this chapter, I’ll cover Ethereum in much greater
    depth, so you’ll get the foundation you need to develop Dapps on this platform
    effectively. I’ll begin by presenting the Ethereum wallet, a UI tool you’ll use
    to start interacting with the Ethereum P2P network by transferring some Ether,
    the Ethereum cryptocurrency. Then you’ll get a wide overview of smart contracts,
    the key technology that Ethereum introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning about Go Ethereum, one of the many clients available on the
    platform, and once you understand the purpose of accounts, you’ll move to the
    next level and start interacting with the Ethereum network through Go Ethereum
    in several ways: with commands entered into the operating system shell, with instructions
    entered into the Go Ethereum console, and with HTTP requests. At that point, you
    should have acquired enough familiarity with the platform to progress with confidence
    through the rest of the book. It’ll be a dense but rewarding chapter. Let’s get
    started.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Connecting to Ethereum through the wallet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ethereum network offers two main graphical user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mist*—A browser for Ethereum Dapps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ethereum wallet*—A specific version of Mist with a single Dapp bundled in
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll learn about Mist in a later chapter. For the moment, we’ll focus on the
    Ethereum wallet. The main purpose of the wallet is to store, receive, and transfer
    Ether, the Ethereum cryptocurrency. It’s similar to a Bitcoin wallet, if you’ve
    ever handled bitcoins, and you’ll initially use it to transfer Ether so that you
    can start to interact with the platform in the simplest way. It’s also a useful
    tool to learn how to deploy smart contracts and interact with them on one of the
    public Ethereum networks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1\. Getting started with the Ethereum wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you open the download page ([https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)),
    you’ll find various versions of Mist and the Ethereum wallet. Pick the version
    of the Ethereum wallet corresponding to your operating system and download the
    related zip file. (I’ve picked Ethereum-Wallet-win64-0-11-1.zip.) After unzipping
    it, you can run the executable Ethereum Wallet.exe directly. The first time you
    launch it, it’ll default to the main network. In this chapter, you’ll work against
    the public test Ropsten network instead. To select it, you must pick it from the
    top menu, as shown in [figure 3.1](#ch03fig01): Develop > Network > Ropsten. You
    also can select the Ropsten network through the Alt+Ctrl+2 shortcut.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1\. Choosing the test Ropsten network from the Develop > Network >
    Ropsten menu option or through the Alt+Ctrl+2 shortcut
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you select the Ropsten network, the wallet will start to synchronize
    with the related blockchain. By default, the synchronization mode is Light, which,
    as you saw in the previous chapter, downloads the current state trie from a peer
    full node, so you don’t have to wait long (minutes). This will allow you to get
    up and running quickly. But if you want to perform write operations, such as transferring
    Ether or deploying smart contracts, which is what you’ll be doing, you must get
    a full copy of the blockchain—you can choose between Fast and Full. (Go back to
    the previous chapter if you don’t remember how these sync modes work.) Here’s
    a rough estimate of what to expect when you’re synchronizing the Ropsten blockchain
    locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fast*—Uses roughly 1 GB of disk space and takes two to four hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full*—Uses roughly 100 GB of disk space and can take up to a day or two'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re synchronized, you’ll be able to see synchronization details at the
    top of the screen, including the name of the network you’re connected to, the
    latest block number, and the number of seconds passed since receiving the last
    block, as shown in [figure 3.2](#ch03fig02).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2\. You can see synchronization details, including the name of the
    network and the latest block number, at the top of the screen.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To perform the operations I’ll cover in this chapter and the next, you *must
    choose Fast or Full* synchronization; otherwise, you won’t be able to transfer
    Ether or deploy a contract through the wallet. To be able to execute a transaction,
    you must have a full local copy of the blockchain. If the wallet appears unresponsive
    after a while and you don’t notice any progress in the synchronization, it might
    be because the wallet hasn’t managed to connect to any peer nodes. In that case,
    close it down and try to synchronize the Ropsten blockchain through the geth client.
    If you need to do this, read about geth in [section 3.3](#ch03lev1sec3), and then
    synchronize it to Ropsten as explained in [chapter 8](kindle_split_020.xhtml#ch08),
    [section 8.1](kindle_split_020.xhtml#ch08lev1sec1).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Figure 3.3\. Accounts overview screen. You can create an account by clicking
    Add Account.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, you’re ready to create accounts. Click the Wallets tab, which
    will bring you to the Accounts Overview screen, and then click the Add Account
    button, which has a plus symbol next to it, as you can see in [figure 3.3](#ch03fig03).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a small dialog box asking for a strong password. (Make sure you stretch
    the dialog from the bottom-right corner until you see the OK button.) After entering
    a password (twice), you’ll be reminded to back up your keyfiles (more on this
    later) and password.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Manage your passwords carefully. If you forget your password, you won’t be able
    to click any “I Forgot My Password” button. Losing your password means losing
    the Ether stored in the account. This isn’t a major problem when pointing to a
    test network, because Ether has no value there. But, especially when moving to
    the production network, you should get into the habit of choosing a strong password
    and keeping a copy of it somewhere secure. Better safe than sorry!
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re using the Ethereum wallet for Mac OS or LINUX, the interface is slightly
    different, screenshots won’t match what you see, and my descriptions might not
    work to the letter. Also, the default network shown might be different. But you
    should be able to find alternative ways to perform the operations I describe.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: After the wallet has generated the account, on the Accounts Overview screen
    you’ll see *Account 1* with the related hexadecimal address and a balance of zero
    Ether. I’ll cover accounts in more detail later; for now, create one more account
    in the same way, and you now should see two accounts on the screen, as shown in
    [figure 3.4](#ch03fig04). Now that you have a couple of accounts (feel free to
    create more), you can try out some common operations with the wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4\. Account details shown on the Accounts Overview screen after their
    creation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3.1.2\. Performing common operations with the wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With a balance of zero Ether (the Ethereum cryptocurrency) on all your accounts,
    you won’t be able to go too far, because as you’ll learn, to execute transactions
    on the network, you must pay transaction costs in Ether. Because it isn’t possible
    to buy Ether in the test network, you’ll have to generate it somehow. One way
    is through mining.
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Mining is the process through which new transactions get consolidated into
    blocks of the blockchain. Many participants in the Ethereum network run special
    mining nodes through which they hope to be rewarded in Ether tokens and be compensated
    for the computational power they provide to the network. Although mining Ether
    in the real public network is challenging and requires specialized hardware based
    on advanced GPU chipsets, it’s easy to generate Ether in the test network with
    “plain CPU” mining through the wallet menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop > Start Mining (Testnet only)
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The menu option Develop > Start Mining will appear only after the blockchain
    has been entirely synchronized in Fast or Full mode.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The CPU of your machine will get busy, and after a few minutes you should have
    accumulated enough Ether to get going.
  prefs: []
  type: TYPE_NORMAL
- en: 'If for any reason mining is taking too long, an alternative way to fund your
    Ropsten accounts is through the so-called *faucet*. The following URL can send
    your addresses free test Ether: http://faucet.ropsten.be:3001/donate/<destinationaddress>,
    for example, http://faucet.ropsten.be:3001/donate/0x8713Cb74c7DB911f2056C8DD2bA5036-7-eeEa11D0\.
    After a few seconds, your destination address should receive 1 Ether, as you can
    see in [figure 3.5](#ch03fig05). You can check the status of the Ether transfer
    from the faucet by entering your address in the text box at the top of the Ropsten
    Etherscan webpage: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    If faucet.ropsten.be isn’t working as expected or you keep getting gray-listed,
    try [https://faucet.kyber.network/](https://faucet.kyber.network/). Alternatively,
    try Google ropsten faucet.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5\. Account balances after using the faucet facility
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transferring Ether
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now you can try to move some Ether between accounts. It’s easy. First, go to
    the Send screen. Select the source (Account 1) and target account addresses (copy
    the address of Account 2 from the Accounts Overview screen), then select the amount
    of Ether you want to transfer—for example, 0.5 Ether. Finally, after deciding
    on a transaction fee, click Send Transaction. Don’t worry too much about this
    for now; we’ll examine transaction fees later.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be prompted to enter a password, as shown in [figure 3.6](#ch03fig06).
    Enter the password of the source account (Account 1) to digitally sign the transaction
    and subsequently prove that the account owner is sending it, and then click Send
    Transaction. You’ve now completed your first Ether transaction!
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6\. Password entry screen for moving Ether between accounts. You’re
    required to enter the password of the sending account when transferring Ether
    with the Ethereum wallet, to digitally sign the transaction and consequently prove
    it’s genuinely the account owner who’s sending the Ether.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To check the status of the transaction, go back to the Accounts Overview screen
    and click Latest Transactions at the bottom of the screen. Clicking on the related
    link will allow you to drill down into further details, such as those shown in
    the screenshot in [figure 3.7](#ch03fig07).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7\. Summary transaction information from the Transactions panel of
    the Accounts Overview screen
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can get a better idea of how your transaction has contributed to the Ropsten
    blockchain by checking it on *Etherscan*, a website reporting the real-time evolution
    of the Ethereum blockchain. Use this URL to access the test network: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    You’ll be able to get detailed block and transaction information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve acquired some familiarity with Ethereum, it’s time to learn
    more about one of the greatest innovations that this platform introduced: smart
    contracts. Once you grasp how smart contracts work, you’ll be able to make further
    progress on SimpleCoin, the cryptocurrency you started to build in the previous
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.2\. Smart contracts: The brain of Dapps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I described in [chapter 1](kindle_split_012.xhtml#ch01), an Ethereum smart
    contract, or simply *contract*, is a software artifact containing business rules
    and a state. It’s written in a high-level language such as Solidity, compiled
    into EVM bytecode, deployed onto the Ethereum network, and stored on its blockchain
    against a specific account generated at deployment.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [figure 3.8](#ch03fig08), a contract receives transaction messages
    from a user account (or from other contracts) and executes its logic on the Ethereum
    Virtual Machine (EVM). This might optionally involve sending messages to other
    contracts, reading state from the blockchain, or writing state to the blockchain
    (specifically from/to the State Merkle-Patricia trie). The account sending the
    message to the contract gets charged (in Ether) by the successful mining node
    for computation and network resources consumed during the processing of the requested
    operation. The amount of such computation and resources is calculated in a unit
    called *gas*, as you’ll see in [section 3.2.3](#ch03lev2sec5), so it’s common
    to say that a transaction consumes a certain amount of gas (rather than resources).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8\. An Ethereum contract receives a transaction message from a user
    account. Its logic is executed on the Ethereum Virtual Machine (EVM); then the
    successful miner calculates the cost for the computational and network resources
    used, in a unit called gas, and charges the user account in Ether.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to understand smart contracts, how they get instantiated by users
    and by other contracts, and especially how they get executed, you need to go in
    greater detail through various concepts I’ve only touched on so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether and gas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll start by telling you more about the various types of accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1\. Accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve already come across the concept of *accounts* a few times. Accounts
    are available in two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Externally owned accounts (EOA)* (or simply *External Accounts*)—These are
    also known informally as *user accounts*. They’re publicly identifiable from their
    public key, but they can only be operated by knowing the private key. If you buy
    some Ether, you’d store it in this type of account. Also, you’d start a transaction
    against a smart contract from an EOA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contract accounts*—These are the accounts that contracts are executed under.
    The account address is generated at deployment time, and it identifies the location
    of the contract in the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both EOAs and contract accounts hold data in the form of a key-value store and
    an Ether balance. [Table 3.1](#ch03table01) compares the main properties of EOAs
    and contract accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1\. Comparison between an EOA and a Contract Account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Property | Externally owned account | Contract account |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Has Ether balance | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Can start transaction message | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Can start call message | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Has code | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: 3.2.2\. Ether
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve mentioned Ether casually a few times, so it’s probably time you learned
    more about it. Ether is the cryptocurrency that the Ethereum blockchain supports.
    Its main purpose is to represent monetary value for services and goods traded
    over the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Ether is also used to pay for transaction fees. These are, as mentioned in [section
    3.2](#ch03lev1sec2) and covered more in [section 3.2.3](#ch03lev2sec5), calculated
    in a unit called gas, which measures computational resources that a transaction
    consumes. But these fees are settled in Ether (calculated from the price of a
    unit of gas, expressed in Ether). Miners charge transaction fees to get compensated
    for the computational power they provide the network while appending new transaction
    blocks to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ether comes in various denominations, which are all defined, as you can see
    in [table 3.2](#ch03table02), as a multiple of Wei, the smallest Ether denomination.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2\. Ether denominations and values in Wei
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Unit | Wei value | Wei |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Wei | 1 Wei | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Kwei (Babbage) | 1e3 Wei | 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Mwei (Lovelace) | 1e6 Wei | 1,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Gwei (Shannon) | 1e9 Wei | 1,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Microether (Szabo) | 1e12 Wei | 1,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Milliether (Finney) | 1e15 Wei | 1,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Ether | 1e18 Wei | 1,000,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 3.9](#ch03fig09) summarizes the Ether lifecycle, which goes through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Minting Ether
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transferring Ether
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing Ether
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exchanging Ether
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.9\. The Ether lifecycle. Ether is minted by miner nodes into miner
    user accounts. Then it’s transferred to EOAs (also known as user accounts). From
    there, it can be stored on various wallets. Ultimately, it can be converted to
    real currency, such as USD, EUR, YEN, GBP, and others, through cryptocurrency
    exchanges.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Minting Ether
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re unfamiliar with cryptocurrencies, you must be wondering how Ether
    is minted and exchanged. Ether is generated through the mining process, during
    which miners compete to group and append transactions into new blockchain blocks,
    as I discussed in [section 1.1.2](kindle_split_012.xhtml#ch01lev2sec2). When successful,
    a miner gets rewarded with a certain number of Ether coins. Blocks are added to
    the Ethereum blockchain every 15 seconds or so, and the money supply increases
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring Ether
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once Ether has been generated, it’s allocated to the miner’s external account.
    Miners can then transfer Ether to other external accounts or contract accounts,
    either through the Ethereum wallet or programmatically, as you’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging Ether
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because Ether is valuable, it doesn’t generally get transferred for free between
    accounts. It’s often transferred in return for goods and services traded through
    smart contracts, but also in return for conventional currency, such as US dollars,
    euros, pounds, yen, and so on. Although it’s possible to buy Ether from individual
    owners and pay them an agreed amount of conventional currency, it’s more effective
    to handle such transactions using cryptocurrency exchanges. Two main types of
    exchanges are available: centralized, such as Kraken, Coinbase, and Coinsquare,
    and decentralized, such as EtherEx. Each exchange is generally biased toward a
    specific real-world currency.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing Ether
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once someone acquires Ether, whether through mining, smart contract trading,
    or exchange-based trading, it’s allocated to an account. You can manage accounts
    using many methods, each with a different trade-off between convenience and security.
    The most convenient one is generally through desktop or online wallets, which
    allow you to transfer Ether easily. The most secure one is through cold or paper
    storage, which means generating the private key offline and holding it literally
    on a piece of paper. Hardware wallets present another high-security option and
    are conceptually similar to paper wallets because they can be considered offline.
    The main difference is that the account owner stores the private key on a small
    electronic device similar to a USB key. [Table 3.3](#ch03table03) summarizes the
    different options.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.3\. Wallet types and their characteristics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Wallet type | Convenience | Security | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Desktop wallet | High | High | Ethereum wallet, Exodus |'
  prefs: []
  type: TYPE_TB
- en: '| Mobile wallet | High | Low | Jaxx |'
  prefs: []
  type: TYPE_TB
- en: '| Online wallet | High | Medium | MyEtherWallet, Coinbase, Kraken |'
  prefs: []
  type: TYPE_TB
- en: '| Hardware wallet | Medium | Very high | Trezor, Ledger Nano, KeepKey |'
  prefs: []
  type: TYPE_TB
- en: '| Paper storage | Low | Very high | EthAddress |'
  prefs: []
  type: TYPE_TB
- en: I’ve mentioned that transaction fees are charged in Ether but calculated in
    a unit called gas. Let’s see what gas is and how it’s related to transaction costs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3\. Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gas is the unit of measure for transaction fees charged on the Ethereum platform.
    The amount of gas used to complete a transaction depends on the amount of computational
    resources that the EVM spends while running the transaction. Specifically, it
    depends on the exact low-level EVM instructions that have been executed during
    the transaction. [Table 3.4](#ch03table04) gives an idea of the amount of gas
    charged for the most common EVM operations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.4\. Gas cost for simple EVM operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Operation | EVM op code | Gas cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Addition, subtraction | ADD, SUB | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication, division | MUL, DIV | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison | LT, GT, SLT, SGT | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Load word from memory | MLOAD | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Store word to memory | MSTORE | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Load word from storage | SLOAD | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| Storing word into storage | SSTORE | >5000 |'
  prefs: []
  type: TYPE_TB
- en: '| Contract creation | CREATE | 32000 |'
  prefs: []
  type: TYPE_TB
- en: The main reason the execution of a transaction is charged in units of gas, and
    indirectly in units of computational work, is to prevent denial of service (DoS)
    attacks by unscrupulous participants who might want to disrupt the network. To
    launch a DoS attack, a malicious participant would have to spam the network with
    a high number of transactions, each performing a large amount of computational
    work; for instance, an infinite loop. The amount of gas corresponding to this
    work would be high, and it would have to be paid in a correspondingly high amount
    of Ether—it’s unlikely anyone would pay to disrupt a service!
  prefs: []
  type: TYPE_NORMAL
- en: Most smart contract development IDEs give an idea of the total amount of gas
    required to complete a transaction. For example, in the screenshot in [figure
    3.10](#ch03fig10), you can see a gas estimate for the execution of the transfer
    function of the `SimpleCoin` contract from the last section of [chapter 1](kindle_split_012.xhtml#ch01),
    obtained by clicking the Details button on the output panel.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10\. Transaction costs for the execution of the `SimpleCoin` transfer
    function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Transaction fee costs are calculated according to this formula: transaction
    fees (in Ether) = number of units of gas consumed * price per unit of gas (in
    Ether). Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: The EVM determines the *number of units of gas consumed* while running the transaction,
    and that depends on the computational cost of the code being run during the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender of the transaction decides the *price of a unit of gas* (in Ether).
    The higher it is, the more likely it is that miners will include the transaction
    in the block they’re processing. Miners prioritize transactions that are likely
    to pay high fees, so if a transaction is expected to consume a relatively low
    amount of gas, the sender will have to set a relatively high gas price to guarantee
    quick processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transaction sender sets a *limit* for *the maximum amount of gas* that a
    transaction should consume. This protects the sender from higher-than-expected
    transaction costs due to execution of the code in a way different from what was
    intended; for instance, if the developer introduces a bug that causes an infinite
    loop. Such limits should be relatively close to the estimated amount of gas needed
    to complete the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While a transaction is being executed, the EVM consumes its gas. Two outcomes
    are possible at the end of the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The transaction completes successfully*. In this case, the unused gas is returned
    to the sender.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The amount of gas available ends before the completion of the transaction*.
    In this case, the EVM throws an *end of gas exception*, and the transaction is
    rolled back.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might be wondering who pockets the transaction fee. Given either of the
    two transaction outcomes, the miner who has processed the transaction receives
    the fee. For the first outcome, they earn the fee by including the transaction
    in a new block that has been successfully appended to the blockchain. For the
    second outcome, even though the EVM throws an exception, the miner still charges
    the gas in Ether, and they collect the related transaction fee as usual. In short,
    a successful miner is rewarded by minting new Ether and getting transaction fees
    from the transaction senders. In the early stages of the Ethereum platform, most
    of a miner’s profits came from minting.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.4\. Calls and transactions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accounts interact with each other through two types of messages: calls and
    transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: Calls
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A call is sent through a message that doesn’t get stored on the blockchain
    and whose execution has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It can only perform read-only operations, which don’t alter the state of the
    blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t consume any gas, and consequently, it’s free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s processed synchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It immediately returns a return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t allow transferring Ether to the contract account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical calls are direct invocations of contract member variables, including
    mappings, and invocations of so-called *constant functions*, which don’t alter
    contract state. You performed calls, for example, when you checked account balances
    of SimpleCoin, the basic cryptocurrency you started to build at the end of [chapter
    1](kindle_split_012.xhtml#ch01).
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A transaction, which I introduced to you in the Dapp dynamic view in [chapter
    1](kindle_split_012.xhtml#ch01), is sent through a message that gets serialized
    and stored on the blockchain during the mining process. It contains the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sender address*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recipient address*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Value*—Amount of Ether to be transferred (in Wei), in case the message is
    being used to transfer Ether (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data*—Input parameters, in case the message is being used as a function call
    (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*StartGas*—Maximum amount of gas to be used for the execution of the message.
    If this limit is exceeded, the EVM throws an exception and rolls back the state
    of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Digital signature*—Proves the identity of the transaction sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GasPrice*—The price of a unit of gas (expressed in Ether) the transaction
    initiator is willing to pay, as discussed in the gas section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You executed transactions when you performed SimpleCoin transfers. The execution
    of a transaction has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It can perform write operations, which alter the state of the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It consumes gas, which must be paid for in Ether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s processed asynchronously: it gets executed through mining and then gets
    appended on a new blockchain block, which gets broadcast throughout the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It immediately returns a transaction ID, but not a return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows transferring Ether to the contract account. (The Ether transfer becomes
    part of the transaction itself.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now you know contracts are executed on the EVM on each node of the Ethereum
    network. I’ll provide a quick overview of how the EVM works.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.5\. The Ethereum Virtual Machine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Ethereum Virtual Machine (EVM) is a stack-based abstract computing machine,
    similar in purpose to the Java virtual machine (JVM) and to the .NET Common Language
    Runtime (CLR). It enables a computer to run an Ethereum application and has two
    memory areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Volatile memory*, or simply *memory*. This is a word-addressed byte array,
    which gets allocated to a contract at every message call. Reads access 256-bit
    words, whereas writes can be performed on a width of 8 or 256 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storage*. This is a key-value store where both key and value have a width
    of 256 bits. Storage is allocated to each account and is persisted on the blockchain.
    A contract account can access only its own storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EVM opcodes cover operations including Boolean, bitwise, and arithmetic comparisons
    and jumps (both conditional and unconditional). These are the main opcodes handling
    contract creation and calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE`—This performs the creation of a new contract instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CALL`—A contract sends a message to itself or other contracts through this
    operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELEGATECALL`—This operator allows the calling contract to send a message
    to an external contract but execute the related code in the context of the caller.
    This operator is especially useful for the creation of libraries of shared code
    that multiple contracts can access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The EVM is completely sandboxed: a contract can’t access network or filesystem
    resources. It can only access other contracts. A more in-depth explanation of
    the EVM is outside the scope of this book. The best reference for understanding
    its design is Gavin Wood’s so-called *Yellow Paper*: [http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you’ve consolidated your knowledge on smart contracts. Now it’s
    time to take a step further and connect to the Ethereum network through a proper
    client: the Go Ethereum client.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Connecting to Ethereum with geth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start installing a client, I’d like to give you a more detailed overview
    of the Ethereum network, which I started introducing in [chapter 1](kindle_split_012.xhtml#ch01).
    It’ll help you understand the wider context that a client fits in.
  prefs: []
  type: TYPE_NORMAL
- en: You already know the Ethereum network is a peer-to-peer (P2P) network, which
    means there’s no central master or server node coordinating them. Consequently,
    all nodes are clients to each other. Nodes are designed to work and communicate
    with each other in exactly the same way, according to a predefined protocol called
    Wire, described in the Yellow Paper. This means all nodes must be able to append
    new transaction blocks to the blockchain (if mining is activated) and verify them
    while blocks get propagated throughout the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an implementation point of view, the network contains two broad categories
    of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Miners*—They process the latest transactions and consolidate them into the
    blockchain in exchange for transaction fees and a mining reward (in Ether) if
    they manage to execute the consensus algorithm successfully. In that case, they
    propagate the blocks they’ve consolidated onto the blockchain to other peers of
    the network. Because these nodes generate new blocks, they’re considered producers
    (although they’re technically also still consumers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full nodes*—They mainly verify the validity of the blocks they’ve received
    from neighboring peers and keep propagating them to the rest of the network. Therefore,
    they’re considered consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining nodes run on clients optimized for processing transactions, generating
    blocks, and executing the Proof of Work algorithm efficiently, to get rewarded
    relatively frequently. Mining implementations, such as *ethminer*, have been written
    in C++ and use GPU libraries such as NVIDIA’s CUDA. Consequently, they run on
    GPU hardware that can deliver superior performance.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, full nodes don’t have performance requirements, so standard
    clients have been implemented in various languages. [Table 3.5](#ch03table05)
    summarizes the main client implementations available to date, ordered by popularity,
    as reported in Ethernodes ([https://ethernodes.org/network/1](https://ethernodes.org/network/1)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.5\. Ethereum client implementations by language
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Client | Language |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Go Ethereum (geth) | Go |'
  prefs: []
  type: TYPE_TB
- en: '| Parity | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| Cpp-ethereum (eth) | C++ |'
  prefs: []
  type: TYPE_TB
- en: '| Ethereum(J) | Java |'
  prefs: []
  type: TYPE_TB
- en: '| Pyethapp | Python |'
  prefs: []
  type: TYPE_TB
- en: '| ethereumjs-lib | JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| ruby-ethereum | Ruby |'
  prefs: []
  type: TYPE_TB
- en: '| ethereumH | Haskell |'
  prefs: []
  type: TYPE_TB
- en: Each client comes with a console, and some of them also include a graphical
    browser or a wallet. While working with this book, you’ll use Go Ethereum, also
    known as geth, which is the most popular client, installed on over 70% of the
    network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1\. Getting started with geth
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The download page for the Go Ethereum website, [https://ethereum.github.io/go-ethereum/downloads/](https://ethereum.github.io/go-ethereum/downloads/),
    shows releases for all major operating systems: Android, iOS, Linux, MacOS, and
    Windows. Various installation formats are available for some of the supported
    operating systems. For example, for Windows, you can choose between the 32- and
    64-bit version and whether to download only the executable (Archive option) or
    the full installer (Installer option). I’ve picked the 64-bit Geth & Tools 1.8.13
    archive.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed or uncompressed the relevant file, you can run the geth
    executable. If you have the Ethereum wallet open, close it before starting geth,
    because they use the same port number! If you run geth with no parameters, it’ll
    start to synchronize in Full mode with the public production network, also known
    as MAINNET, as shown in the screenshot in [figure 3.11](#ch03fig11).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11\. geth synchronizing with the MAINNET network at startup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After geth has synchronized the full blockchain (this could take from hours
    to days, depending on your hardware and internet connection), the console will
    start to slow down and show blocks being added to the blockchain in real time.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for the wallet, you can synchronize geth in Light or Fast mode—for example,
    `C:\program files\geth>geth –-syncmode "light"`—if you prefer to get up and running
    more quickly (in minutes as opposed to hours or even days) and don’t mind not
    having downloaded the full blockchain locally.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'You can interact with geth in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Through the user-friendly geth interactive JavaScript console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through low-level JSON-RPC calls over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’ll present both techniques to you. Let’s start with the simpler tool: the
    interactive JavaScript console.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2\. A first look at the geth interactive console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: geth comes with an interactive console that accepts JavaScript instructions.
    It implicitly references Web3.js, a JavaScript implementation of Web3, the official
    high-level library for interacting with Ethereum clients. This console is similar
    in purpose to read-eval-print loop (REPL) consoles for programming language IDEs.
    I’ll cover Web3 extensively in the next few chapters. For the moment, let’s get
    a quick feel for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the interactive console. You’ve got two possible ways to start
    it up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If no geth clients are running on the same machine, run the geth executable
    with the console command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a geth client is already running on the machine, attach to a running geth
    process with the attach command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have a running geth process, so you’ll go for the second option.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this book, I’m assuming you use Windows, as over 60% of the nodes of the
    Ethereum network run on this operating system. Consequently, I’ll show shell commands
    with a Windows command prompt format. Also note that after successful execution
    of instructions in the console, you might see *undefined* right before or after
    the correct results. You can ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Displaying version information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First of all, you can query the console for version information. A Web3 object
    named web3 is implicitly instantiated when opening the console, so you can access
    version information in this way by typing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the version property is an object that contains many subproperties.
    If you want, you can be specific and query an individual property of the version
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the console accepts JavaScript instructions, it’s possible to assign
    the values of Web3 properties and subproperties to variables and then display
    them through the console object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Checking connectivity
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can get some client connectivity information from the web3.net object. (You
    can omit the web3 namespace because it’s implicitly referenced.) If you type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: you’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the version object, you can directly access individual properties of
    the net object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you want to get more detailed information about your node, you can use the
    web3.admin object and call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `peers` property gives you detailed information about the peers you’re
    connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: will yield something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `web3.eth` object retrieves real-time information about the client and the
    blockchain. Look at the console of the geth process currently running. You should
    see how new blocks are getting appended to the blockchain in real time. Take note
    of the block number of a recently appended block, and then switch back to the
    JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the most recent block number through the `eth.blockNumber` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then you can display summary information about this block by calling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: and you’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can drill down at transaction level. You can get the first transaction
    stored in the latest block in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I encourage you to have a look at the content of the whole `eth` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Performing Ether conversions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Web3 API offers some useful functions to convert any Ether denomination
    from/to Wei. You can convert a Wei amount to a specific denomination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can convert a specific denomination into Wei:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 3.3.3\. A first look at JSON-RPC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve learned the basics of the JavaScript console, you can try to
    interact with geth by performing a few JSON-RPC calls. geth offers a remote procedure
    call (RPC) interface that allows you to access node functionality and blockchain
    data to a much finer degree of control than that offered by the Web3 API. In fact,
    Web3 is built on top of the RPC layer, which is the lowest level API exposed by
    the Ethereum platform, as shown in [figure 3.12](#ch03fig12).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12\. Comparison between accessing geth through Web3.js and JSON-RPC
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The RPC interface has been designed against the JSON-RPC 2.0 standard, and consequently
    it sends and receives data in JSON format. You can find more information on JSON-RPC
    in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to communicate with geth directly through JSON-RPC, you have to
    do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop any instance of geth running in a standard operating system command shell
    or in a geth console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start geth in RPC mode using the `--rpc` and `--rpcapi` options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you launch geth in RPC mode, it’s accessible through an HTTP server that
    accepts HTTP requests, by default on
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**JSON-RPC**'
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC is a lightweight remote procedure call that uses JSON as a data format.
  prefs: []
  type: TYPE_NORMAL
- en: You invoke an RPC call by sending a request object to a server, typically over
    HTTP, or in any other way, such as socket or even messaging, because the transport
    layer isn’t part of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request object must contain the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`—Name of the remote procedure to be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`—Array with procedure parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`—A call identifier, typically a string or integer. It must be not null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the server processes the call, it replies with a response object, which
    contains the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result`—This field is present if the response is successful; it isn’t included
    if errors occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`—This field is present if errors occur; it isn’t included if the response
    is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`—Same as specified in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: You’ll perform JSON-RPC calls to geth’s HTTP server using the cURL console command.
    To help you appreciate the differences between the Web3 API and the JSON-RPC API,
    I’ll show you how to execute in cURL the same operations you performed in Web3
    through the interactive console.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: cURL is available in most operating systems, including Windows (version 7 and
    10) and Linux. Alternatively, you can either download from the internet an open
    source version of cURL or perform HTTP requests through a graphical tool such
    as Postman, if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Displaying version information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can retrieve version information about the geth client with this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: (If you’re using Windows, you must escape JSON double quotes, as explained in
    the sidebar.) The result is equivalent to what you got from `web3.version.node`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**cURL JSON escaping on Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'cURL operations must escape the double-quote symbol " with \" in the JSON POST
    data, in certain versions of Windows. For example, in a command shell in Windows,
    you perform the request this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Checking client connectivity
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get connectivity information by performing several calls. For instance,
    to check whether the client is actively listening for network connection, you
    must execute this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And you’ll get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The result is equivalent to `web3.net.listening`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the number of peers connected to the client, you must execute this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And you’ll get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The result, which contains numbers encoded in hexadecimal format, as explained
    in the sidebar, is equivalent to `web3.net.peerCount`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Numbers through JSON-RPC**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum’s JSON-RPC interface handles numbers differently than the official
    JSON-RPC 2.0 specification does. Numbers sent and returned through JSON-RPC must
    be encoded in hexadecimal format. Doing so makes sure each client implementation
    parses and processes large numbers appropriately, independent of the support for
    large numbers that the underlying language in which the client has been coded
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal encoding should include a 0x prefix and at least one valid digit
    with no leading zeros, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This is equivalent to 1234 in decimal.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how numbers should be encoded into hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal format | Hexadecimal format |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0x0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 0x9 |'
  prefs: []
  type: TYPE_TB
- en: '| 1234 | 0x4d2 |'
  prefs: []
  type: TYPE_TB
- en: 'And here are some examples of incorrectly encoded numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Incorrect hex encoding | Reason |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x | No digit has been specified after the 0x prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| 42d | No 0x prefix has been specified. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x042d | Leading 0 digits aren’t allowed. |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Accessing the blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get the latest blockchain block number this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And you’ll get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the latest block number, you can inspect it by calling (replacing
    the block number in `params` with the one from your `result`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And you’ll get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can inspect the first transaction of the block you retrieved in a
    way equivalent to how you did in Web3 through the interactive console (again,
    putting the block number you got in `results` into `params`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: And you’ll get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The result object is similar to that returned by the Web3 `eth.getTransactionFromBlock`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, you’ll be interacting with geth mainly through Web3.js,
    but occasionally I’ll show you how to perform equivalent operations in JSON-RPC.
    If you’re interested in learning more about the JSON-RPC API, consult its wiki
    at [https://github.com/ethereum/wiki/wiki/JSON-RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4\. Mining with the geth console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t consider a section on Ethereum clients to be complete before at least
    mentioning how to perform mining through a client. You already performed some
    mining through the Ethereum wallet at the beginning of this chapter, to load your
    test accounts with Ether.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, performing operations through the wallet hides what happens
    under the hood. For example, have you asked yourself why the Ether you mined got
    assigned to account1? That happened because the *etherbase* account, which is
    the account associated with the miner thread, is set by default to `eth.accounts[0]`.
    But after restarting geth and reopening the geth console in attach mode, as you
    did previously (in case you shut it down), you can reconfigure the etherbase account
    to `eth.accounts[1]`, if you prefer, through the implicitly instantiated `miner`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether your etherbase account is `eth.accounts[0]` or you’ve
    reconfigured it to `eth.accounts[1]`, you can start mining as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the CPU of your machine will go to nearly 100%. Then you can
    stop mining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the unlikely event you’ve mined some Ether, this will now be assigned to
    your `eth.accounts[1]`, or to `eth.accounts[0]` if you decided not to reconfigure
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you kicked off mining on the geth interactive window with `miner.start()`,
    you might have noticed output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder what DAG is and why it takes such a long time to compute. DAG
    stands for directed acyclic graph, and it’s the data structure underlying *Ethash*,
    the Proof of Work (PoW) algorithm for mining on the Ethereum platform. DAG requires
    a relatively high amount of memory, so Ethash is considered a memory-intensive
    PoW algorithm. It consequently discourages mining through application-specific
    integrated circuit (ASIC) hardware, which is effective only for CPU-intensive
    PoW algorithms, such as the one used on the Bitcoin network. The Ethash algorithm
    encourages mining instead through commodity hardware, such as a GPU chipset (explained
    more in sidebar).
  prefs: []
  type: TYPE_NORMAL
- en: Mining is a specialized topic outside the scope of this book. If you’re interested
    in learning more about Ethash, I encourage you to consult the official notes at
    [http://mng.bz/WaOw](http://mng.bz/WaOw).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve experienced mining firsthand, you might ask yourself what happens
    if you have the luck to append a new block to the blockchain, get the related
    Ether reward in your etherbase account, and then decide to quit your mining activity
    by shutting down your node. Would the block you’ve created and appended to the
    blockchain still be valid, even if you’ve disappeared from the network? Would
    the transactions included in the block still be valid? Would you still be able
    to transfer the Ether in your etherbase account to another account?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to all these questions is yes. Remember that the blockchain validation
    process, performed continuously by all active full nodes, only cares about the
    cryptographic consistency between a block hash and the public address of the miner
    who has generated the block, in the same way it cares about the consistency between
    a transaction hash and the public address of the account that has generated it.
    So whether the node that created a new block is active or inactive is as irrelevant
    to the block (and transaction) history as whether your computer is on or off after
    having transferred some Ether from an account of your desktop Ethereum wallet
    to another account.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**GPU mining**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try your luck and hope to get rich by generating Ether on the
    public production network with CPU mining, as you’ve done so far in the test network,
    I hate to break the news, but you’re more likely to get rich by winning the lottery.
    As you saw in [chapter 1](kindle_split_012.xhtml#ch01), the execution of the PoW
    algorithm is successful only if the hash obtained combining the block information
    and a nonce has certain characteristics—for example, a high number of leading
    zeros. PoW algorithms are designed so that you must try millions of nonce values
    before hitting the lucky one that generates a valid hash. Consequently, mining
    successfully means being able to generate more hashes per second than other miners.
  prefs: []
  type: TYPE_NORMAL
- en: With the best CPU chipset, you’ll be able to generate at most 1 megahash per
    second (Mh/s), where megahash means one million hashes. With good GPU chipsets,
    you might be able to generate up to 30 Mh/s—nearly 30 times the hashing capability
    of a standard CPU. Also consider that mining pools, which are organizations that
    pool various GPU miners together so they can share resources and rewards, can
    generate up to 30 Th/s (30 trillion hashes per second), which means up to 30 million
    times what a CPU is able to generate during the same time. Finally, consider that
    in the Ethereum space, around 40 mining pools have a hash rate ranging between
    30 Gh/s and 30 Th/s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can understand why your chances of generating Ether using a CPU alone
    are slim. You might find this stark reality disappointing, and you might even
    think that the huge influence of mining pools on the mining process might bring
    into question Ethereum’s credibility, as far as decentralization is concerned.
    Many Ethereum participants believe that as long as many mining pools are competing,
    decentralization should be guaranteed. Also consider that the new consensus algorithm
    being implemented, Stake of Work, introduced in the previous chapter, might change
    completely how power is concentrated (or hopefully spread) in the Ethereum network.
    Here’s a quick summary of the hash rate that different hardware can achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Hardware | Hashrate |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Single CPU | 1 Mh/s |'
  prefs: []
  type: TYPE_TB
- en: '| Single GPU | 30 Mh/s |'
  prefs: []
  type: TYPE_TB
- en: '| GPU rig (10xGPUs) | 300 Mh/s |'
  prefs: []
  type: TYPE_TB
- en: '| Mining pool | 30,000,000 Mh/s |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 3.3.5\. Other clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although Go Ethereum is the most popular client, other implementations offer
    various benefits with respect to geth:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parity*, written in Rust, is the second most popular Ethereum client, and
    it’s regarded as the fastest, lightest, and most secure implementation. It comes
    with a console and a built-in wallet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cpp-ethereum*, written in C++ and known as *eth*, is another fast implementation,
    third in popularity, and well regarded for its portability. *Ethminer*, a specialized
    mining client, is a fork from cpp-ethereum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pyethapp*, written in Python, is built on two core components: *pyethereum*
    provides EVM, blockchain, and mining functionality, whereas *pydevp2p* supports
    access to the P2P network and node discovery mechanisms. Python developers especially
    appreciate this implementation for its extensibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve learned about various components and tools of the Ethereum platform.
    Before leaving this chapter, you’ll reinforce your understanding of accounts,
    a key concept you must get familiar with to work effectively with Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. Managing accounts with geth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the beginning of this chapter, while covering smart contracts, I touched
    briefly on accounts. I also helped you create some accounts through the Ethereum
    wallet UI so you could use them to transfer some Ether around. Armed with the
    geth console, you can now deepen your knowledge of accounts by creating them and
    interacting with them programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1\. Ethereum accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you know, the Ethereum platform supports two types of accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Externally owned accounts (EOAs)*—These impersonate end users, as well as
    miners and autonomous agents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contract accounts*—These impersonate contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll deal only with EOAs, which I’ll call *accounts*.
  prefs: []
  type: TYPE_NORMAL
- en: As with most blockchain systems, the security of the Ethereum platform is based
    on public key cryptography. An account is therefore identified by a private/public
    key pair. The account’s address is represented by the last 20 bytes of the public
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private/public key pair associated with an account is stored in a text
    *keyfile*. The public key is visible in plain text, whereas the private key is
    encrypted with the password introduced at account creation. Account keyfiles are
    in the *keystore* folder within the Ethereum node’s data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: C:\Users\username\%appdata%\Roaming\Ethereum\keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum/keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum/keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s strongly recommended that you back up the keystore folder on a regular
    basis and keep a copy of the passwords you’ve introduced when creating each account
    in a secure place. Sorry if I keep pestering you with this, but if you haven't
    noticed, I do want to make a point of how sensitive key and password details are
    in the blockchain world!
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Account portability**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use an account that you’ve created on the public production network
    on a test network, for example Ropsten, and vice versa. This is because the keystore
    of each network is different and is located in a separate folder within the Ethereum
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main prod network keystore: ~/.ethereum/keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rinkeby test network keystore: ~/.ethereum/rinkeby/keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ropsten test network keystore: ~/.ethereum/testnet/keystore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'You can create accounts and interact with them through four different avenues:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum wallet, as you saw earlier in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geth commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web3 on the geth console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-RPC calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve already seen how to manage accounts with the Ethereum wallet. In the
    next several sections, you’ll manage accounts through geth commands and the geth
    console. You’ll also get a quick feel for how to perform some operations on accounts
    through the JSON-RPC API.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2\. Managing accounts with the geth command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can manage an account easily through your operating system console by entering
    specific geth commands from the directory of the geth executable (or from any
    directory if geth is in your PATH global variable).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can create a new account manually or using a plain text file:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual creation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new account, enter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll be prompted to enter a password twice, and then you’ll be shown the
    address of the account you created:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '|  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: Get into the habit of choosing strong passwords or generating them through a
    strong password generator. I’m repeating myself; I know, I know! But this is important,
    believe me!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Text file creation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid having to enter the password manually, you can store it in plain text
    in a text file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the geth account command as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you can understand, although placing a password in a plaintext file might
    be acceptable in a test environment, this way of creating an account might pose
    much greater risks in a production environment, where you must make sure access
    to the password file is tightly restricted.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Listing accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once you’ve created an account, you can verify it’s indeed present in your
    node by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the accounts you created through the geth account command and the
    geth console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Updating accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After geth creates and saves an account in a keyfile in the keystore folder,
    a subsequent geth release might implement a new keyfile format. In that case,
    it becomes necessary to update the account. Another reason you might want to update
    an account is because you want to change the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update account 47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1 you created
    earlier with the following geth command (obviously replace with your account number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll be prompted to enter the existing password, to unlock the account, and
    subsequently a new password, which you’ll have to type twice, as usual. You’ll
    then be shown the new address of the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The geth account update command offers the same `--password` option that the
    geth account new command provides. But in this case you can also use it to unlock
    the account for the purpose of converting it into a new keyfile format.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3\. Managing accounts with Web3 on the geth console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s repeat some of the earlier account management operations through the interactive
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Go back to the interactive geth console. You can create accounts using the
    `web3.personal` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the geth account command, you’ll be asked to enter a password twice,
    and then you’ll be shown the account address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Listing accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can list accounts with the interactive console by displaying the value
    of the `account` property of the `web3.eth` object. You’ll get the same result
    set you obtained with the geth account list command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: will yield something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can directly reference a specific account of the `eth.accounts` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This will yield something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Checking an account’s Ether balance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can check the amount of Ether stored in an account using the following
    call, which returns it in Wei:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can convert it to Ether as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Transferring Ether between accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can try transferring 0.0025 Ether from `accounts[1]` to `accounts[2]`.
    First of all, check the current balances of these accounts, as you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Before transferring Ether from a certain account, for example `accounts[1]`,
    you must unlock it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, you’ll be asked to enter the password associated with this account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can transfer Ether between accounts with the web3.eth.sendTransaction
    function, which takes an amount in Wei, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The value returned is the hash of the transaction sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a couple of minutes, recheck the balances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the balance hasn’t been updated yet, it’s because the transaction hasn’t
    been mined yet.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4\. Managing accounts with JSON-RPC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ll give you a quick example of how to perform account management operations
    in JSON-RPC. Open a new OS shell and you can list your accounts with the following
    JSON-RPC call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This will yield something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 3.5\. Revisiting SimpleCoin’s contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve covered quite a lot of ground in this chapter. If you’ve followed me
    up to this point, congratulations: you’ve completed the introduction to Ethereum
    covering the Ethereum wallet and the Go Ethereum client. You’ve also started interacting
    with the platform in many ways—through the geth commands, through Web3 instructions
    on the geth interactive console, and through direct JSON-RPC requests.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s been an intense ride. I bet you’re eager to get back to some coding! Let’s
    revisit your initial implementation of SimpleCoin, the basic cryptocurrency I
    introduced at the end of [chapter 1](kindle_split_012.xhtml#ch01), and try to
    improve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reenter the `SimpleCoin` code you saw in the previous chapter into Remix ([http://remix.ethereum.org](http://remix.ethereum.org)),
    as shown in the following listing. As usual, ignore warnings for the moment: they’ll
    disappear as you improve the code in the next chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1\. `SimpleCoin` contract as you left it in [chapter 1](kindle_split_012.xhtml#ch01)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This code is rudimentary. Even if you don’t know the Solidity language yet,
    you can see a hardcoded value in the constructor and a lack of input validation
    in the `transfer` function. You can improve the code in several ways. First of
    all, you can parameterize the constructor so the initial money supply doesn’t
    get allocated to the address of an arbitrary test account, but to the address
    of the contract owner’s account. Then you can introduce some checks in the transfer
    function to prevent incorrect transfers. Finally, you can set things up so that
    when tokens get transferred, an event can be raised, and then clients of the smart
    contract can be notified or react to it.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1\. Improving SimpleCoin’s contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll improve both the constructor and the transfer function. You can start
    from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing the constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Rewrite the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You’ve already come across the special property `msg.sender`, whose value is
    the address of the message sender (or function caller). When it comes to the constructor,
    the message sender is the account that instantiates the contract, which consequently
    becomes its owner. As a result, when the constructor gets called, the `amount`
    of tokens specified in the `_initialSupply` parameter gets allocated to the contract
    owner.
  prefs: []
  type: TYPE_NORMAL
- en: Making transfers more robust
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rewrite the transfer function as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2\. A more robust transfer function with checks on the input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Checks that the sender account has an amount of coins equal to or
    larger than what you’re trying to transfer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks that an arithmetic overflow hasn’t been produced on the recipient’s
    balance during the transfer operation. (This can happen if the balance, because
    of the amount received from the sender, becomes bigger than uint256.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `require` special function throws an exception if the condition isn’t met.
    You can also throw the exception directly with the `throw` keyword, but this way
    of validating input is being deprecated. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: could have been previously written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Raising an event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A contract can declare one or more events that can be raised in any of its
    functions. A client that’s monitoring the state of a contract can handle an event.
    For instance, you can declare an event that notifies that a transfer of SimpleCoin
    tokens has taken place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll raise this event at the bottom of the transfer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 3.5.2\. Trying out the amended code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The amended `SimpleCoin` contract will now look like the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3\. `SimpleCoin` with parameterized constructor, input validation,
    and event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Trying out the amended constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Reopen Remix if you closed it, and copy the code in [listing 3.3](#ch03ex03)
    into the editor. Then pick a test account address from the Transaction Origin
    drop-down list; for example, 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db. This
    will be the account executing the constructor, and it’ll consequently become the
    contract owner.
  prefs: []
  type: TYPE_NORMAL
- en: Click the Run tab on the right panel. You can now enter the initial supply of
    SimpleCoin tokens next to the Deploy button, say 10,000, and then click Deploy.
    As usual, the coinBalance and transfer buttons will appear on the lower part of
    the screen, as in the previous chapter, as shown in the screenshot in [figure
    3.13](#ch03fig13).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13\. The Deploy operation now accepts the constructor input. After
    you instantiate the contract by clicking Deploy, the CoinBalance and Transfer
    buttons appear.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-13_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can check the contract owner’s address balance in the coinBalance mapping.
    As expected, you’ll get 10,000\. You can also double-check that the balances of
    the other addresses are zero, as shown in [table 3.6](#ch03table06).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.6\. The balances of the SimpleCoin accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 10,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Trying out the amended transfer function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Try to transfer some SimpleCoin tokens from an account that doesn’t have any;
    for example, 0x583031d1113ad414f02576bd6afabfb302140225. Select this address from
    the Transaction Origin drop-down list and enter the following comma-delimited
    value into the transfer text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After clicking Transfer, you’ll get the following error message, thanks to
    the `require` check you added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to transfer 150 tokens from the contract owner’s account to the same
    recipient you just tried. You need to select the account starting with 0x4b0897b
    on the Transaction Origin drop-down list and reenter the following comma-delimited
    value into the transfer text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The operation will now be successful, as you can see in the output on the left
    side of the screen shown in [figure 3.14](#ch03fig14).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14\. Output of successful transfer operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click the arrow next to Debug, you can verify in the `logs` property
    that the Transfer event has been raised at the end of the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: After rechecking all the balances, the results should match [table 3.7](#ch03table07).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.7\. The new balances of the SimpleCoin accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 150 |'
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve completed this exercise. The improvements you’ve made
    weren’t particularly challenging, but making them should have helped you gain
    more familiarity with contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3\. How does the coin transfer execute in the Ethereum network?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might have understood the Solidity code that performs the coin transfer
    but...if this transfer was taking place on a real Ethereum network rather than
    on the Remix JavaScript EVM emulator, would you know where within the network
    it would be executed? And would you know what effect a transfer of SimpleCoin
    tokens would have on the blockchain? You can get the answers to these questions
    by looking at the diagram in [figure 3.15](#ch03fig15). I’ve adapted it for SimpleCoin
    from the transactional view you saw in [figure 1.8](kindle_split_012.xhtml#ch01fig08)
    ([chapter 1](kindle_split_012.xhtml#ch01)).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see other transaction lifecycle diagrams similar to this for all Dapps
    I’ll cover in the book. The lifecycle of an Ethereum transaction will be cemented
    in your head progressively throughout the book, until it becomes second nature
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15\. The lifecycle of a SimpleCoin transfer transaction. A transfer
    transaction is created when a SimpleCoin wallet invokes the `transfer()` function
    on the `SimpleCoin` smart contract on a local node of the Ethereum network. This
    is then validated and propagated throughout the network until it’s included on
    a new blockchain block by a mining node. The new block is then propagated throughout
    the network, and finally it gets back to the local node.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-15_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethereum wallet is a GUI that allows you to interact with the platform by
    creating accounts and transferring Ether intuitively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular Ethereum client is Go Ethereum, also known as geth. It comes
    with an interactive console that references Web3.js, a high-level interface to
    Ethereum clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s possible to interact with geth, for instance to create accounts, through
    various avenues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geth commands executed in the operating system command shell
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Web3.js instructions executed in the geth interactive console
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP JSON-RPC commands executed through cURL or a UI tool such as Postman
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum smart contracts, or just *contracts*, are written in a high-level language
    such as Solidity, compiled into EVM bytecode, deployed on the Ethereum network,
    and stored in the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to communicate with contracts using calls, transactions, and events.
    A transaction involves the consumption of computational and network resources,
    which is calculated in a unit called gas and settled in Ether, the cryptocurrency
    of the Ethereum platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 4\. Deploying your first smart contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a contract onto the Ethereum network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the contract over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodeless contract deployment and interaction with MetaMask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In the first two chapters, you started building SimpleCoin, your basic cryptocurrency.
    You did so in the Remix IDE and tried out its minimal functionality through its
    JavaScript-based EVM emulator. The experience was useful to help you understand
    from a conceptual point of view what a smart contract looks like and how to activate
    and interact with it. But SimpleCoin still looks like a bit of code running in
    an IDE. Now that you’re becoming familiar with the Ethereum platform, you may
    be wondering, “Wouldn’t it be nice to see SimpleCoin in action in a more realistic
    environment?” That’s exactly what you’ll be doing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll deploy the `SimpleCoin` contract onto the Ethereum network, and then
    you’ll interact with it in a couple of ways. First, you’ll go through the Ethereum
    wallet, which requires you to import a copy of the blockchain locally, and then
    you’ll go through MetaMask, a third-party tool that allows you to connect to the
    Ether-eum network without accessing an Ethereum client or the wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1\. Deploying a contract onto the network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re probably used to deploying centralized applications on servers. If you’ve
    ever developed a web application, for example, you might have initially developed
    all the layers on your desktop computer. Then, after the application was mature
    enough for users or testers to test it, you deployed its components into the user
    acceptance testing (UAT) environment on one or more servers. A typical deployment
    for a web application might include
  prefs: []
  type: TYPE_NORMAL
- en: One web server that hosts static and dynamic web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more application servers that host the services the web pages use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more database servers that persist the data that the services use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment of a decentralized application is quite different. Even a simple
    decentralized application consisting of only one smart contract, like your SimpleCoin
    application, would get deployed across the entire Ethereum network. As you might
    recall from the development view I introduced in [chapter 2](kindle_split_013.xhtml#ch02),
    [section 2.1.3](kindle_split_013.xhtml#ch02lev2sec3), a smart contract gets deployed
    as a special transaction whose payload is compiled EVM bytecode. You submit the
    deployment transaction through a local node, which propagates it throughout the
    Ethereum network until it hits mining nodes. The smart contract only gets deployed
    after a mining node has successfully processed the deployment transaction containing
    the contract EVM bytecode to a new block that gets appended to the blockchain.
    That block is then replicated throughout the Ethereum network, as shown in [figure
    4.1](#ch04fig01).
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two options for deploying contracts onto the network:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually, through the Ethereum wallet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through terminal commands, on geth’s interactive console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 4.1\. A contract written in a high-level language such as Solidity is
    compiled into EVM bytecode and deployed to the network through a deployment transaction
    containing the contract EVM bytecode, which is executed through a local full node
    of the network. The deployment transaction is propagated throughout the network;
    then it’s processed by a mining node and included in a new block that gets replicated
    throughout the network. It’s like any other transaction, except that what’s being
    stored on the blockchain isn’t Ether or data but EVM bytecode.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll deploy the `SimpleCoin` contract manually. By doing
    so, you’ll go through the deployment process in a visual and intuitive way that
    will help you learn quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get used to deploying contracts through the Ethereum wallet, you’ll
    be ready for the next step: command-based deployment. Though it may seem slightly
    intimidating at first, deploying contracts through geth’s console is a useful
    exercise because it helps you understand the platform more thoroughly. You’ll
    explore this in the next several chapters. For now, I’ll quickly recap what you
    know:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The mechanisms to trigger deployment*—You know that you can deploy contracts
    manually through the Ethereum wallet or by using commands on geth’s console. (You’ll
    see these in action soon.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What happens during deployment*—The contract’s bytecode gets stored on the
    blockchain following the execution of its deployment transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what exactly is the Ethereum network? I’ll answer that question in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1\. Ethereum public networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you connected to Ethereum in the previous chapter, you might not have
    noticed that you connected to two different networks:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Ethereum wallet, you connected to *Ropsten*, a public test network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From geth, you connected to *Mainnet*, the public production network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ropsten* is the public test network that Ethereum provides for mining based
    on proof of work (PoW), which is the current algorithm used in the public production
    network. If you followed the instructions I gave you, your Ethereum wallet is
    already pointing to the Ropsten network, and you only have fake Ether in your
    accounts, which you generated through CPU mining.'
  prefs: []
  type: TYPE_NORMAL
- en: If you left your geth client running from the previous chapter, it’s pointing
    to *Mainnet*, the production network. Ether moved between accounts in this network
    is real. You should use this network only to perform transactions against production
    Dapps; you should avoid it during development.
  prefs: []
  type: TYPE_NORMAL
- en: Another public test network called *Kovan* is available, and it supports mining
    performed with a new algorithm called Proof of Authority. So far, this has only
    been implemented in the Parity client, so it’s outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll deploy the `SimpleCoin` contract to Ropsten through
    the wallet. As a result, you don’t need to make any environmental configuration
    changes yet.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2\. Deploying SimpleCoin with the Ethereum wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start up the Ethereum wallet—make sure the sync mode is Fast or Full and wait
    until it’s fully synchronized—and open the Contracts screen by clicking Contracts
    on the top bar, near the top-right corner. You’ll see two main options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Deploy New Contract*—You can deploy a new contract by supplying its Solidity
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Watch Contract*—You can reference a contract that already has been deployed
    so you can interact with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Deploy New Contract. When the Deploy Contract screen opens, you can decide
    which account will become the contract owner. Choose Account 1, and then click
    the Solidity Contract Source Code tab at the bottom of the screen and paste the
    `SimpleCoin` code from the end of [chapter 3](kindle_split_014.xhtml#ch03), as
    shown in the following listing. (Make sure the constructor and functions are declared
    as *public* to be compiled in the wallet; I’ll explain function access modifiers
    such as public in [chapter 5](kindle_split_017.xhtml#ch05).)
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1\. Latest version of `SimpleCoin` (from [chapter 3](kindle_split_014.xhtml#ch03))
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve pasted the code, the wallet will compile it into EVM bytecode, and
    a drop-down list will appear on the right-hand side. Pick Simple Coin from the
    list and enter 10000 as the constructor parameter. Finally, click Deploy at the
    bottom of the screen, as shown in [figure 4.2](#ch04fig02).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2\. After you enter the Solidity code of a contract, the wallet compiles
    it into EVM bytecode. Supply the contract parameters, click Deploy, and a new
    dialog box will confirm the deployment transaction.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A new dialog box will appear, as shown in [figure 4.3](#ch04fig03). You’ll
    be asked to enter the password and to send the deployment transaction. Remember:
    you need Ether in your account to be able to submit the transaction! Once you
    send the deployment transaction, you can check its status in the Latest Transactions
    section of the wallet main screen. There you can see that the deployment transaction
    is treated like any other transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3\. A dialog box asks you to enter the password of the account that
    you’ll deploy the contract from. After you supply it and click Send, a deployment
    transaction is generated and sent to the network.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the contract has received all the necessary network confirmations, which
    you can view in the Latest Transactions panel (see [figure 4.4](#ch04fig04)),
    go back to the Contracts screen. You’ll see Simple Coin with a balance of zero
    Ether ([figure 4.5](#ch04fig05)).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4\. After a contract transaction has been submitted to the network,
    you can monitor its network confirmations in the Latest Transactions panel of
    the Contracts screen.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5\. After the contract receives 12 confirmations, which makes it very
    likely the deployment transaction is permanently stored on the blockchain, a deployed
    contract appears in the Contracts panel.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Transaction confirmations* indicate the depth of the transaction in the blockchain.
    A new confirmation is received as soon as a new block is appended to the blockchain
    after the block containing the transaction in question. The probability of a block
    reversal decreases exponentially as the number of confirmations increase, so a
    transaction is considered consolidated after 12 confirmations. (That means 12
    blocks have been added to the blockchain after the block containing the transaction.)'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve deployed your first contract on the Ethereum network.
    Now you can interact with the contract, much as you did earlier with Remix. You
    can start by moving SimpleCoin tokens between accounts and verifying the expected
    balances.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Interacting with the contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting to move SimpleCoin tokens, go back to the wallet’s main screen
    and add two more accounts. (Remember to take note of the related passwords.) These
    extra accounts will become handy when testing contract operations. I recommend
    you copy all the account addresses you have in your wallet to a temporary text
    file. [Table 4.1](#ch04table01) shows what it would contain in my case.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1\. Ethereum wallet account addresses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account name | Account address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Main account | 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 |'
  prefs: []
  type: TYPE_TB
- en: '| Account 2 | 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 |'
  prefs: []
  type: TYPE_TB
- en: '| Account 3 | 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 |'
  prefs: []
  type: TYPE_TB
- en: '| Account 4 | 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To copy an address, select it, and then click Copy Address. Alternatively, you
    can use the usual Ctrl+C shortcut. Either way, the wallet will ask you to confirm
    you want to go ahead with this operation. (There is risk that malware may replace
    the address.)
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Now go back to the Contracts screen and click SimpleCoin. At the top of the
    screen, just below the name of the contract, you’ll see the contract address,
    which is the account address of the contract in the blockchain. You’ll notice
    that the area associated with the `SimpleCoin` contract is logically divided into
    two parts: Read from Contract on the left and Write on Contract on the right.
    This arrangement is similar to the color codes you saw in Remix for read-only
    functionality (blue) and write functionality (red).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1\. Checking coin balances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can first check the coin balance of all accounts by entering the address
    of each account next to the coin balance textbox. The expected balances are shown
    in [table 4.2](#ch04table02).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2\. Expected account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: What happens if you try to check the balance of an invalid address? For example,
    replace the last digit of the main account (starting with 0xedDE06bC) with an
    8 and try to check the coin balance. You won’t be allowed to enter such an address
    because the wallet will consider its checksum invalid. But you will be allowed
    to enter any valid Ethereum address, even if it’s not associated with your accounts.
    (You can grab some to try from [https://etherscan.io/](https://etherscan.io/).)
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2\. Transferring coins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you can move some coins around. You can start with a transfer of 150 SimpleCoins
    from the Main Account to Account 3\. This is the same operation you performed
    on Remix in the previous chapter. Pick Transfer from the Select Function drop-down
    in the Write to Contract panel. All the input fields required for the coin transfer
    will appear, as in [figure 4.6](#ch04fig06).
  prefs: []
  type: TYPE_NORMAL
- en: Pick the Main Account from the Execute From list, then set the address of Account
    3 in the To field and an amount of 150. After you click Execute, you’ll be asked
    to enter the password of the Main account to digitally sign the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: If you select the Watch Contract Events box in the Latest Events pane, you’ll
    soon see the details of the transaction you’ve sent. At this point, you can recheck
    the balances of all addresses. The expected balances are shown in [table 4.3](#ch04table03).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3\. Expected updated account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Figure 4.6\. Checking the SimpleCoin balance is a read-only operation, so you
    only need to specify the input address. Transferring coins is a write operation.
    As seen here, you have to specify the number of coins to be transferred, the destination
    address, and the sending account.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now try to move 50 coins from Account 3 to Account 2 and recheck the balances
    after the transaction has appeared in the Latest Events panel. You’ll notice that
    the only accounts listed in the Execute From drop-down list are the Main Account
    and Account 2\. This is because the wallet doesn’t allow you to execute a transaction
    from an account with no Ether in it.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [chapter 2](kindle_split_013.xhtml#ch02), the executing account
    must pay a transaction fee calculated in gas but settled in Ether to perform a
    transaction. For Accounts 3 and 4 to be useful, you must send some Ether to them
    from the Main Account. You can perform this Ether transfer from the Send screen,
    as you did in the previous chapter when you set up Account 2\. As usual, you can
    monitor the Ether transfer transactions on the Latest Transactions panel and wait
    for them to complete. Once all accounts own some Ether, you’re ready to perform
    a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `SimpleCoin` contract screen and pick the transfer function again.
    The Execute From drop-down list will now show all the accounts, so you can pick
    Account 3\. Enter the address of Account 2 in the To textbox and 50 in the Amount
    field. When you click Execute, you’ll be asked for the password for Account 3,
    the sending account. After the transaction has been confirmed, recheck the balances.
    The new expected balances are shown in [table 4.4](#ch04table04).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.4\. Updated account balances after second transfer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Trying to transfer unavailable coins
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you’ll remember, the code of the SimpleCoin `transfer` function performs
    some checks before modifying the balances of the sender and recipient addresses.
    It prevents an account from attempting to transfer unavailable coins by throwing
    an error. You can see what happens if you try to do so through the wallet. For
    example, try to move 200 coins from Account 4 to Account 3\. As expected, you’ll
    get an error message indicating the transaction will fail, as shown in [figure
    4.7](#ch04fig07).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7\. If a transaction generated from a write operation, such as `SimpleCoin.transfer()`,
    fails validation checks, it can’t be sent to the network.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might be surprised that the error message is thrown before the transaction
    has even been sent out. This happens because the wallet verifies transactions
    locally, before sending, as any node would do. If an error is returned, the wallet
    doesn’t propagate the transaction to the network, and you receive an error message
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You’ve fully, manually, tested `SimpleCoin` on the public test network.
  prefs: []
  type: TYPE_NORMAL
- en: So far, this chapter has given you an idea of how to deploy a smart contract
    to a public network without having to run a full Ethereum node. You performed
    it through the Ethereum wallet, which, under the hood, still connects to a fully
    synchronized copy of the blockchain. But you might be wondering whether you can
    achieve the same thing without having a local synchronized copy of the blockchain.
    The answer is yes. As we’ll explore in the next section, you can connect to a
    set of publicly accessible nodes exposed by a Chrome plugin called Metamask.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. Nodeless deployment through MetaMask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MetaMask* is a Chrome extension that connects you to an external set of Ethereum
    nodes, as you can see in [figure 4.8](#ch04fig08). It allows you to deploy a contract
    to a public network and interact with it without having to install and maintain
    any Ethereum software. As an alternative, if you don’t want to use Chrome, you
    can download the Brave browser and install MetaMask as an extension. MetaMask
    is especially handy if you don’t develop smart contracts continuously and don’t
    want the inconvenience of having to update the wallet or Go Ethereum client and
    resynchronize the blockchain every time you resume your development.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8\. When connecting to Ethereum through the Ethereum wallet or the
    Go Ethereum client console, you do so through a local node. When connecting to
    Ethereum through Metamask, you do so through a remote node.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you’ll install MetaMask. Then you’ll redeploy `SimpleCoin`
    to Ropsten through MetaMask and interact with it, completely bypassing your local
    geth client and Ethereum wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1\. Installing MetaMask
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can install the MetaMask chrome extension from this url: [http://mng.bz/8JzB](http://mng.bz/8JzB).
    After adding the extension, you should see the MetaMask icon next to the browser
    address bar.'
  prefs: []
  type: TYPE_NORMAL
- en: You can now start to set up a MetaMask wallet by clicking on the MetaMask icon.
    You’ll be invited to accept a privacy notice and terms and conditions (at your
    own risk). Then you’ll be asked to create a new password, as shown in [figure
    4.9](#ch04fig09).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9\. Creation of a password to secure the MetaMask wallet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter your new (possibly secure) password and click Create. You’ll be advised
    to copy and securely store the system-generated 12-word recovery passphrase. The
    wallet will be created after you confirm you’ve done so, and at that point you’ll
    see on the top left, next to the MetaMask icon, the name of the network you’re
    connected to. Initially, you’re connected to Main Ethereum Network, as shown in
    [figure 4.10](#ch04fig10).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10\. MetaMask initially points to Main Ethereum Network.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Given that you’ll deploy `SimpleCoin` onto a test network, change your current
    network by clicking Main Ethereum Network and selecting the Ropsten Test Network
    from the drop-down list, as shown in [figure 4.11](#ch04fig11).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11\. It’s possible to connect to various Ethereum networks through
    MetaMask.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ll notice the default account has nothing to do with any of the accounts
    you have in your Ropsten Ethereum wallet. And this default test account hasn’t
    got any Ether, so you won’t be able to do much with it. To import some of your
    existing Ropsten accounts, which already contain Ether, click the menu icon on
    the top right, and then select Import. In the Import dialog box, you’ll see a
    Select Type drop-down list. Select JSON File, as shown in [figure 4.12](#ch04fig12).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12\. Dialog box for importing accounts from JSON files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-12_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you have to supply the JSON file containing the private key of your existing
    Ropsten account. Remember, the key pairs of your Ropsten account are held in the
    testnet keystore, which, depending on your OS, you can find in one of the locations
    shown in [table 4.5](#ch04table05).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.5\. Testnet keystore locations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| System | Keystore path |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | C:\Users\username\%appdata%\Roaming\Ethereum\testnet\keystore |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | ~/.ethereum/testnet/keystore |'
  prefs: []
  type: TYPE_TB
- en: '| Mac | ~/Library/Ethereum/testnet/keystore |'
  prefs: []
  type: TYPE_TB
- en: 'The testnet keystore folder should contain a list of files whose names contain
    the timestamp and the account address they refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T08-49-46.377533700Z--edde06bc0e45645e2f105972bdefc220ed37ae10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T13-26-18.696630000Z--4e6c30154768b6bc3da693b1b28c6bd14302b578`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-36.890638200Z--70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-47.794428600Z--c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the file extension isn’t present, these are JSON files. For example,
    the second file on the list refers to account 4e6c30154768b6bc3da693b1b28c6bd14302b578\.
    If you open the file with a text editor, such as Notepad in Windows, you should
    see JSON content similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the MetaMask Import Account dialog box, click Choose File, navigate to your
    testnet keystore, and then pick the file related to the account you want to import.
    You must supply the password you entered when creating this account, and then
    click Import. After a few seconds, you should see the details of the account you’ve
    imported, including the Ether contained in it, as shown in [figure 4.13](#ch04fig13).
    Once you’ve imported a couple of your existing Ropsten accounts, you can proceed
    to the deployment of `SimpleCoin`.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13\. After you import an account from the keystore, all its details
    appear on MetaMask.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-13_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 4.3.2\. Deploying SimpleCoin through MetaMask
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To deploy `SimpleCoin`, first open Remix and enter the latest version of `SimpleCoin`,
    the same one you entered into the wallet, shown earlier in [listing 4.1](#ch04ex01).
    Now pick the Injected Web3 option in the Environment drop-down list in the Run
    tab of the right-hand side panel, as shown in [figure 4.14](#ch04fig14).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14\. The screenshot shows how you can configure Remix to use external
    MetaMask nodes (rather than the local JavaScript Virtual Machine emulator) by
    selecting Injected Web3 in the Environment drop-down list.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-14_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remix will detect MetaMask, and it’ll use one of the MetaMask nodes rather than
    the local JavaScript EVM emulator. If no account is showing in the Account drop-down
    list, refresh the Remix webpage and the account currently selected in MetaMask
    will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: You can trigger `SimpleCoin`’s deployment by clicking the red Deploy button.
    Account 2, whose address starts with 0x4e6c30154, is the only option available
    and is currently selected in the Account drop-down list box. That account will
    deploy the contract.
  prefs: []
  type: TYPE_NORMAL
- en: After you click Deploy, you’ll see a dialog box summarizing information on the
    executing account and transaction costs for the deployment transaction. You’ll
    also be asked to confirm you want to go ahead with it, as you can see in [figure
    4.15](#ch04fig15).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15\. After configuring Remix to point to external Metamask nodes and
    starting the deployment of a contract (such as `SimpleCoin`), you get a (deployment)
    transaction confirmation dialog box from Metamask. This shows information on the
    account executing the deployment transaction and on transaction costs. The dialog
    box also asks the user to confirm whether to go ahead with the deployment of the
    contract.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-15_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After clicking Confirm, you can check the transaction status in the bottom area
    of the Metamask wallet. The status will move from Submitted to Confirmed, as shown
    in [figure 4.16](#ch04fig16).
  prefs: []
  type: TYPE_NORMAL
- en: If you click the label Transaction Number while the contract is in status Submitted,
    and then after it has moved to Confirmed, you’ll see the transaction details from
    the Etherscan website, as shown in [figure 4.17](#ch04fig17). As you can see,
    Etherscan also shows the destination address (starting with 0x0c9189e4d6) of the
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16\. It’s possible to monitor the status of the deployment transaction
    in the bottom area of the Metamask wallet. This will change from Submitted to
    Confirmed.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-16_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17\. Transaction details from the Etherscan website, invoked when clicking
    the (Submitted or Confirmed) status on the MetaMask wallet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-17_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you move back to Remix, you’ll see some deployment details below the Deploy
    button, including the deployment address, which is the same one you saw on the
    Etherscan page. You can grab the address by clicking the Copy Address link, as
    shown in [figure 4.18](#ch04fig18).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18\. After the completion of the deployment transaction, the contract
    address is shown in Remix, below the Deploy button.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-18_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well done! You’ve redeployed `SimpleCoin` on Ropsten through MetaMask. Now you
    can see how you can interact with it through MetaMask.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3\. Interacting with SimpleCoin through MetaMask
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4.18](#ch04fig18) also shows that after deploying `SimpleCoin`, Remix
    displays two buttons: CoinBalance and Transfer. These are exactly the same buttons
    that appeared when you created the contract for the first time on the JavaScript
    VM, back in [chapter 1](kindle_split_012.xhtml#ch01). This time, though, you’ll
    be interacting with a contract instantiated on a real network.'
  prefs: []
  type: TYPE_NORMAL
- en: The first operation you can perform is to check the token balance of Account
    2, the account that deployed the contract. Enter “0x4e6c30154768b6bc3da693b1b28-c6bd14302b578”
    (remember, as usual, to surround the address with double quotes) and click CoinBalance.
    You’ll immediately get 10,000, as expected. As with checking balances through
    the Ethereum wallet, this operation is read-only and doesn’t produce a transaction.
    Consequently, you don’t need to authorize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now move 250 tokens from Account 2 to Account 3\. Enter this into the Transfer
    text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Click Transfer. This is a write operation, so the MetaMask transaction confirmation
    dialog box pops up, as shown in [figure 4.19](#ch04fig19). You can authorize it
    from Account 2\. Click Confirm and follow the transaction status in the MetaMask
    dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19\. To transfer SimpleCoin tokens, which is a contract-state write
    operation, the sending account needs to be authorized. Subsequently, the MetaMask
    transaction confirmation dialog box is shown to get user confirmation.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-19_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the transaction number icon, you’ll see the transaction details
    in Etherscan. You can now go back to Remix and check the transaction details there
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Both Etherscan and Remix confirm that the move of 250 SimpleCoin tokens from
    Account 2 to Account 3 has been successful, but you can double-check the new balances
    of these accounts with the `coinBalance` function, which should match those in
    [table 4.6](#ch04table06).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.6\. Account balances after transferring 250 tokens
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 9,750 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 250 |'
  prefs: []
  type: TYPE_TB
- en: I’ll stop here, but I’d encourage you to generate some error messages, for example
    by trying to move unavailable coins, as you did previously with the Ethereum wallet.
    Doing so will allow you to confirm whether the contract also works correctly on
    MetaMask.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    the Ethereum wallet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum wallet communicates with Ethereum through a local geth instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    MetaMask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
