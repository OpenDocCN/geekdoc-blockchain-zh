- en: Part 1\.
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part 1](#part01) is a high-level introduction to Ethereum Dapps and related
    technologies. [Chapter 1](kindle_split_012.xhtml#ch01) introduces decentralized
    applications. [Chapter 2](kindle_split_013.xhtml#ch02) presents the blockchain
    and smart contracts. In [chapter 3](kindle_split_014.xhtml#ch03), you’ll meet
    the Ethereum platform, including the Ethereum Virtual Machine (EVM), the Go Ethereum
    (geth) client, and the Ethereum wallet. In this part, you’ll establish the foundation
    you need to progress through the book. You’ll also implement your first Dapp—a
    simple cryptocurrency—and, in [chapter 4](kindle_split_015.xhtml#ch04), deploy
    it on a public test network.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1\. A first look at decentralized applications
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What a decentralized application is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a Dapp looks like and how it works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapp terminology
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable and less suitable Dapps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: 'How many times have you found yourself in the following situation? You were
    browsing around to buy the latest gadget and were comparing prices online, when
    you came across [SmallWebRetailer.com](http://SmallWebRetailer.com) that was offering
    it 30% cheaper than [WellKnown.com](http://WellKnown.com). You quickly put the
    item in the basket, fearing the price would rise at any moment, and entered your
    postal address and credit card details, but suddenly...you got cold feet. You
    started to wonder: Is the price too good to be true? What if this unknown [SmallWebRetailer.com](http://SmallWebRetailer.com)
    is a scam? Will they run off with my money? After a few minutes of hesitating
    on the Buy button, you opened a new browser tab and went straight to [WellKnown.com](http://WellKnown.com).
    You submitted the order, aware you might have overpaid 30% for your gadget.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Why did you panic? Perhaps you didn’t trust [SmallWebRetailer.com](http://SmallWebRetailer.com).
    Perhaps you didn’t want to waste your time contacting the credit card company
    and possibly waiting for a refund if the transaction turned sour.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you could’ve bought the gadget from the same small, unknown retailer
    through an “alternative e-commerce application” that guaranteed the seller couldn’t
    access your money until you’d confirmed safe delivery of your order? What if that
    guarantee hadn’t been provided by the seller or by a single third party, but by
    many independent parties participating in a platform designed to process transactions
    according to conditions encoded in software anyone could inspect? Hold on, probably
    I’ve said it too fast. I’ll repeat it more slowly:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: What if the money transfer was held until delivery, not by the retailer or a
    third party but by many participants in the platform?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if the rules for escrowing and then releasing the money transfer were encoded
    in logic, not subjected to manual interaction?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if, in case you were still unconvinced, you could inspect the code yourself?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I bet you’d click Buy, confident your funds would be safely stored on this platform
    until the delivery arrived. Such systems do exist, and they’re called *decentralized
    applications*. Decentralized marketplaces, such as OpenBazaar ([https://openbazaar.org/](https://openbazaar.org/)),
    work this way. The mechanism by which funds are routed to the seller only when
    you’ve confirmed safe delivery of the goods is called a *smart contract*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，您会点击购买，自信您的资金将安全地存储在这个平台上，直到货物送达。这样的系统确实存在，它们被称为*去中心化应用程序*。像OpenBazaar这样的去中心化市场就是这样的运作方式。[https://openbazaar.org/](https://openbazaar.org/)。资金在您确认商品安全送达后才转到卖家的机制称为*智能合约*。
- en: Decentralized applications, also known as *decentralized apps* or *Dapps* (generally
    pronounced dee-apps), are part of a new wave of web applications meant to increase
    the transparency around commercial transactions, governmental processes, supply
    chains, and all those systems that currently require mutual trust between customer
    and supplier, user and provider. The objective of Dapps is to minimize or eliminate
    the need for any trust between the participants in a system interaction, with
    the aim of empowering users beyond what Web 2.0 has delivered. Some claim Dapps
    could be the backbone of Web 3.0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序，也被称为*去中心化应用*或*Dapps*（通常发音为dee-apps），是新一代网络应用程序的一部分，旨在增加商业交易、政府流程、供应链以及所有目前需要客户和供应商、用户和提供商之间相互信任的系统的透明度。Dapps的目标是尽量减少或消除系统参与者之间的信任需求，以实现超越Web
    2.0的用户赋权。一些人认为Dapps可能是Web 3.0的支柱。
- en: Assuming you have programming experience—even better if it’s in JavaScript—and
    some familiarity with web applications, this book will teach you how to build
    Dapps made of one or more smart contracts controlled by a user interface. By the
    end of this book, you’ll be able to not only write smart contract code but design,
    implement, test, debug, deploy, and secure a full end-to-end decentralized application.
    Along the way, you’ll also learn a new language, a new platform, and, most of
    all, a new way of thinking about, designing, and running applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有编程经验——如果使用JavaScript就更好了——并且对网络应用程序有些了解，这本书将教您如何构建由一个或多个由用户界面控制的智能合约组成的Dapps。到本书结束时，您将不仅能够编写智能合约代码，还能够设计、实现、测试、调试、部署和一个完整的端到端去中心化应用程序。在这个过程中，您还将学习一种新语言，一个新平台，以及最重要的，一种关于设计、思考和运行应用程序的新方式。
- en: In this first chapter, I’ll give you a high-level overview of Dapps. I’ll explain
    in detail what they are, what they look like, what technology stack they’re built
    on, and when it makes sense to build them. Best of all, I’ll help you start building
    your own! Let’s start our journey.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我将为您提供一个关于Dapps的高级概览。我将详细解释它们是什么，长什么样子，建立在什么技术栈上，以及在什么情况下构建它们是有意义的。更重要的是，我会帮助您开始构建您自己的Dapp！让我们开始我们的旅程。
- en: 1.1\. What is a Dapp?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 什么是Dapp？
- en: 'Before I talk about decentralized applications, I’ll refresh a concept you’re
    already familiar with, most likely without realizing it: that of a *centralized
    application*. Probably you’ve never heard this expression before because conventional
    web and enterprise applications are implicitly centralized with respect to their
    users. I can hear you asking, what does “centralized” mean exactly?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我谈论去中心化应用程序之前，我将刷新一个您可能已经熟悉但很可能没有意识到的概念：那就是*中心化应用程序*。您可能从未听说过这个表达，因为传统的网络和企业应用程序在其用户方面是隐式中心化的。我能听到您在问，“中心化”到底是什么意思？
- en: 'A *centralized application* or system is controlled by a single or *central*
    entity: an individual, company, institution, governmental agency, and so on. The
    entity hosts the system directly on its premises or through a service or cloud
    provider and has full control of all the components and layers of the system architecture.
    The user trusts the good faith of the central entity and decides whether to access
    its system depending on the entity’s reputation. From the point of view of the
    user, the system is either *trusted* or not. This is how most web and enterprise
    applications are designed today.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*中心化应用程序*或系统是由一个或*中央*实体控制的：一个人、公司、机构、政府机构等等。实体直接在其场地上或通过一个服务或云提供商托管系统，并拥有系统架构中所有组件和层的全权控制。用户信任中央实体的善意，并根据实体的声誉决定是否访问其系统。从用户的角度来看，系统要么是*可信*的，要么不是。这就是大多数网络和企业应用程序目前的设计方式。
- en: '[Figure 1.1](#ch01fig01) illustrates a typical interaction between a user and
    a *centralized* *trusted* system. You shouldn’t find anything surprising about
    it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1\. A centralized application is strongly associated with the single
    entity controlling it. Consequently, users decide whether to access it depending
    on their trust of the entity.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Let’s move on to decentralized applications. If you consider for a moment the
    alternative e-commerce application I introduced earlier, you’ll agree it has advantages
    with respect to [SmallWebRetailer.com](http://SmallWebRetailer.com):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '*Favorable transaction conditions*—The transaction would be completed and the
    money would be fully transferred to the retailer only when the retailer had complied
    with all the conditions associated with the transaction, such as your confirmation
    of safe delivery. This would remove one of the biggest reservations you had about
    [SmallWebRetailer.com](http://SmallWebRetailer.com): uncertainty whether you’d
    get the delivery and what would happen to your money if not.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Independent transaction execution and verification*—The transaction wouldn’t
    be processed by the retailer or a single third party but by one of many participants
    in the platform supporting the e-commerce application, and then all the participants
    in the platform would independently verify it. The mechanism that all parties
    would use to agree on the verification of a transaction is called *consensus*
    (defined in the callout). The consensus mechanism would reassure you that the
    promised transaction conditions would be enforced and verified by many independent
    parties rather than an unknown retailer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: Definition
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consensus is a *distributed and trustless* form of agreement on the verification
    of a transaction. *Distributed* means that an independent central authority doesn’t
    perform the verification of a transaction; instead, all parties contribute to
    and agree on its verification. *Trustless* means that parties don’t need to trust
    each other to agree on the verification outcome. Consensus is reached when a qualified
    majority of the participants have agreed on the outcome of the transaction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '*Transparency*—You’d be able to check the code processing the transaction and
    verify that it was observing the specified conditions before transferring your
    money to the retailer. This would give you a further level of reassurance that
    the application was executing under the promised terms.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deliver all of these requirements by building the alternative e-commerce
    application as a network of processing nodes of equal importance and functionality,
    each owned by a different party. Each node would
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: be able to process a transaction the same way other nodes do
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: verify all transactions in the same way other nodes do
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: contribute in an equal way to the outcome of a transaction
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The consequence of this architecture would be that the processing would be
    decentralized to a network of independent nodes rather than being centralized
    to a specific set of servers that a specific entity owns. Such decentralization
    would relieve the user from having to trust a specific entity: the user would
    have to trust only the design of the network as a whole.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的后果将是处理过程将分散到一组独立节点的网络中，而不是集中到特定实体拥有的特定服务器上。这种去中心化将使用户不必信任特定实体：用户只需信任整个网络的设计。
- en: Applications built on this architecture are known as *decentralized applications*.
    I’ll provide another example to make the concept clearer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此架构的应用程序被称为**去中心化应用**（Dapp）。我将提供另一个例子以使这个概念更清晰。
- en: 1.1.1\. Dapps vs. conventional centralized applications
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. Dapps与传统的中心化应用
- en: 'To explain more clearly the benefit of building a Dapp, as opposed to developing
    a conventional centralized application, I’ll illustrate for you a typical use
    case: an electronic voting application.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地解释构建Dapp的好处，以及与开发传统中心化应用相比的优点，我将为您举一个典型的用例：一个电子投票应用。
- en: Centralized voting application
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中心化投票应用
- en: Traditional centralized voting applications are generally provided by a company
    to facilitate shareholder voting or by a local administration or government to
    facilitate the approval or selection of law proposals. The institution running
    the application owns it, directly or indirectly, at least during the voting session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的中心化投票应用程序通常由公司提供，以促进股东投票，或由地方政府或政府提供，以促进法律提案的批准或选择。运行应用程序的机构在投票期间至少直接或间接拥有它。
- en: As you can see at the top of [figure 1.2](#ch01fig02), a centralized voting
    application runs on one or more application servers connected to a central database.
    The system is exposed to the voters through one or more web servers hosting the
    voting website. The institution can have the web, application, and database servers
    hosted directly on the premises or in the cloud. Cloud hosting can happen through
    a cloud computing provider offering Infrastructure as a Service (IaaS) if the
    voting system has been implemented in-house by the institution, or through a cloud
    application provider offering Software as a Service (SaaS) if the voting system
    is only leased or rented from an external provider during the voting session.
    This architecture might not be ideal from the point of view of the voter, because
    of potential worries about trust and security.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.2](#ch01fig02)顶部所示，中心化投票应用运行在一个或多个应用服务器上，这些服务器连接到一个中心数据库。系统通过一个或多个托管投票网站的网络服务器暴露给选民。机构可以在自己的场所或云端托管网络、应用和数据库服务器。如果机构内部开发了投票系统，则可以通过提供基础设施即服务（IaaS）的云服务提供商进行云托管；如果投票系统只是在投票期间从外部提供商那里租用或租用，则可以通过提供软件即服务（SaaS）的云应用提供商进行云托管。从选民的角度来看，这种架构可能不是理想的，因为可能存在关于信任和安全的潜在担忧。
- en: Trust in centralized voting
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对中心化投票的信任
- en: Given all the financial and accounting scandals that have happened at both corporate
    and governmental levels in the last few years, it’s understandable if you don’t
    fully *trust* the organizations you’re a shareholder or citizen of. You might
    wonder whether the outcome of electronic voting might get manipulated in some
    way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到过去几年在企业层面和政府层面发生的所有金融和会计丑闻，如果您不完全*信任*您是股东或公民的组织，这是可以理解的。您可能想知道电子投票的结果是否可能以某种方式被操纵。
- en: It’s easy to imagine, for example, that a malicious developer or administrator
    of the voting application, colluding with some party interested in a certain outcome
    of the voting, could access key parts of the system and tamper with the way votes
    are collected, processed, and stored at various levels of the application architecture.
    Depending on how the application has been designed, it could be possible for some
    malicious database administrators to even modify votes retroactively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很容易想象，一个恶意开发人员或投票应用的管理员，与某些有兴趣达到某种投票结果的党派勾结，可以访问系统的关键部分，并篡改投票的收集、处理和存储方式，在应用程序架构的不同层次上。根据应用程序的设计方式，某些恶意数据库管理员甚至可能
    retroactively 修改投票。
- en: Security in centralized voting
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中心化投票的安全性
- en: When voting through a centralized application, you’d worry about not only the
    good faith of the company or institution organizing the election, but also whether
    the system was secured adequately against external manipulation. For example,
    external parties might be interested in having the voting go a certain way and
    might try to get their desired outcome by hacking into the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集中式应用投票时，您不仅会担心组织选举的公司或机构的善意，还会担心系统是否足够安全，以防止外部操纵。例如，外部各方可能希望投票结果朝某个方向发展，并可能通过入侵系统来获得他们所期望的结果。
- en: As I explained earlier, a centralized voting system includes only a certain
    number of servers located within the same network. Each server generally provides
    only one function, and it’s therefore a single point of failure, not only from
    a processing point of view but also, and especially, from a security point of
    view. For example, if a hacker managed to alter code on the web server so that
    votes were intercepted and modified in that layer, the entire system would be
    compromised. The same outcome could be achieved by hacking only into the application
    server or, even better, into the database server. A breach of security in one
    part of the system is sufficient to compromise the security of the entire system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前解释的，集中式投票系统只包括位于同一网络中的少数服务器。每台服务器通常只提供一种功能，因此从处理角度看，它是一个单点失败，而且尤其是从安全角度看。例如，如果黑客设法修改Web服务器的代码，以便在那一层拦截并修改投票，整个系统都会受到威胁。通过仅入侵应用服务器或，更好的是，数据库服务器，可以实现相同的结果。系统中的一个安全漏洞就足以威胁到整个系统的安全。
- en: Decentralized voting application
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化投票应用
- en: 'A decentralized application is based on two key technical principles:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序基于两个关键技术原则：
- en: Its application logic is present and executed simultaneously and independently
    on each server of a *peer-to-peer (P2P) network*. In theory, a different participant
    owns each server, also known as a *node*. A central node doesn’t control or coordinate
    the servers; instead, they communicate directly with each other and are consequently
    also known as *peer nodes*. They continuously verify each other’s output, so a
    user need only trust the P2P network, not an individual organization. The application
    data and state are stored on a local copy of a database on each server of the
    network, as shown at the bottom of [figure 1.2](#ch01fig02).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的应用逻辑在*点对点(P2P)网络*的每一台服务器上同时存在并独立执行。在理论 上，每一台服务器由不同的参与者拥有，也称为*节点*。中心节点不控制或协调服务器；相反，它们直接相互通信，因此也被称为*对等节点*。它们持续地验证彼此的输出，因此用户只需信任P2P网络，而不需要信任某个单独的组织。应用数据和状态存储在网络中每台服务器的本地数据库副本上，如图
    1.2 所示。
- en: Its database technology, called *blockchain*, guarantees that data can’t be
    modified retroactively.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的数据库技术，称为*区块链*，确保数据不能被追溯修改。
- en: Figure 1.2\. Comparison of a centralized voting application with a decentralized
    one. One institution owns all servers of a centralized application. A decentralized
    voting application runs simultaneously on multiple nodes of a network that different
    entities own.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2. 集中式投票应用与去中心化投票应用的比较。集中式应用的所有服务器都由一个机构拥有。而去中心化投票应用则是在不同实体拥有的网络多个节点上同时运行。
- en: '![](Images/fig01-02_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-02_alt.jpg)'
- en: Trust and security in Dapps thanks to P2P network replication
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信任和安全得益于 P2P 网络复制
- en: 'How can you address trust and security concerns by decentralizing the voting
    application according to the two principles I outlined? A decentralized voting
    application makes trust and security breaches pointless by replicating its execution
    over a network including many servers, each in theory owned by a different party.
    Think about it: if votes were processed and verified not by one single server
    but independently by many servers owned by different parties, and they were stored
    not in a single database but in many databases, each one local to the processing
    party, both trust and security concerns would be addressed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我概述的两个原则，您如何通过去中心化投票应用来解决信任和安全问题？去中心化投票应用通过在包括许多服务器的网络中复制其执行，使信任和安全漏洞变得毫无意义，理论上每个服务器都由不同的方拥有。想想看：如果投票不是由一台单一服务器处理和验证，而是由许多不同方拥有且独立运行的服务器处理和验证，并且它们不是存储在单一数据库中，而是存储在许多本地数据库中，每个数据库都由处理方拥有，那么信任和安全问题都将得到解决：
- en: '*Trust*—If one of the participants tried to maliciously alter a vote and propagate
    the modified vote to the network, the other participants would detect the vote
    as modified during their validation and would reject it. They wouldn’t store it
    in their local copy of the database and wouldn’t propagate the altered vote further
    throughout the network, so the malicious modification would become pointless.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任—如果参与者之一试图恶意地篡改选票并将其修改后的选票传播到网络中，其他参与者在验证过程中会发现选票被修改了，并将拒绝它。他们不会在本地数据库副本中存储它，并且不会将修改后的选票进一步传播到网络中，因此恶意修改变得毫无意义。
- en: '*Security*—Hackers would find trying to alter votes in a decentralized system
    much more difficult than trying to do so in a centralized one. Even if they managed
    to modify votes on one server, or they hosted themselves on one server of the
    decentralized voting application network to do so more easily, other participants
    would spot and reject the alteration, as seen earlier. Successful hacking would
    therefore require compromising not one server of the network but at least 51%
    of the nodes of the network simultaneously, assuming the state of the application
    is what is agreed among the majority of the network nodes. As you can understand,
    trying to manipulate a large part of a network including thousands of servers
    is an incredibly challenging task, especially if each one is managed independently.
    Also, each one might potentially be set up with a different way of preventing
    security breaches.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性—黑客在去中心化系统中尝试篡改选票会比在中心化系统中难得多。即便他们成功地在某台服务器上修改了选票，或者他们自己在一台去中心化投票应用网络的服务器上进行操作以更容易地篡改，其他参与者也会发现并拒绝这种修改，如前所述。因此，成功的黑客攻击将需要同时攻陷网络中至少51%的节点，假设应用程序的状态是网络节点中的大多数所达成的共识。如你所理解，试图操纵包括成千上万服务器在内的网络的大部分，特别是如果每个服务器都独立管理的话，是一项极其困难的任务。此外，每个服务器可能都有不同的防止安全漏洞的方法。
- en: Trust and security in Dapps thanks to the blockchain
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 区块链带来的Dapps的信任和安全
- en: 'A blockchain database is based on a data structure that, as its name suggests,
    is a chain of blocks. A block can be seen as a record containing a set of transactions,
    each one digitally signed, some metadata (such as block number and time stamp
    information), and a link to the previous block. Each transaction, each block as
    a whole, and the links between blocks are secured with cryptographic technology,
    which makes them *immutable*: retroactive alteration of single transactions is
    nearly impossible, especially as more blocks are added to the chain. A blockchain
    database therefore addresses trust and security concerns by providing further
    protection against manipulation attempts by malicious participants and external
    parties.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据库基于一种数据结构，正如其名称所示，它是区块的链条。区块可以被看作是包含一组交易记录，每个记录都经过数字签名，一些元数据（如区块号码和时间戳信息），以及到前一个区块的链接。每笔交易、每个区块整体以及区块之间的链接都通过加密技术得到保护，这使得它们*不可更改*：回溯性地修改单个交易几乎是不可能的，尤其是当链中添加更多区块时。因此，区块链数据库通过提供进一步的保护，以防止恶意参与者和外部实体对应用程序进行篡改尝试，从而解决信任和安全问题。
- en: Outstanding questions on low-level aspects
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 低级方面的未解问题
- en: 'At this stage, you might find the decentralized voting application concept
    promising from a logical or a high-level point of view, but you might still be
    confused about physical and lower level aspects of its architecture. You might
    have doubts in various areas:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能从逻辑或高层次的角度认为去中心化投票应用概念是有希望的，但你可能仍然对它的物理和低级架构方面感到困惑。你可能在各个领域都有疑虑：
- en: '*System architecture*—Is the network hosting the decentralized voting application
    a special kind of network? Do servers communicate with each other using a special
    protocol or using standard internet technology?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构—去中心化投票应用的网络是一种特殊的网络吗？服务器是否使用特殊的协议或标准互联网技术进行相互通信？
- en: '*Vote processing and validation*—How does vote submission get propagated across
    the network so that a vote gets processed on each server of the network? How does
    a vote get counted and then stored on the blockchain? How does a member of the
    network verify the authenticity of the consolidated vote records received from
    other members?'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票处理和验证—投票提交是如何在网络上传播，以便在网络的每台服务器上进行处理的？投票是如何被计数并存储在区块链上的？网络的一名成员是如何验证从其他成员那里接收到的合并投票记录的真实性的？
- en: 'I’ll try to answer these questions in the next two sections, which cover low-level
    details of the decentralized voting application. I’ll also assume the voting Dapp
    has been developed for Ethereum, the blockchain and Dapp platform this book is
    focused on. Doing so will allow me to start introducing Ethereum and to refer
    to concrete infrastructural components while presenting two complementary low-level
    views of the system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我将尝试回答这些问题，这些部分涵盖了去中心化投票应用的高级细节。我还假设投票Dapp是为以太坊开发的，这是本书关注的区块链和Dapp平台。这样做将允许我开始介绍以太坊，并在呈现系统的两个互补的高级视图时参考具体的底层组件：
- en: '*A structural Dapp view*—I’ll describe the low-level architecture of the client
    and server sides of our voting Dapp.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构Dapp视图*——我将描述我们投票Dapp的客户端和服务器端的高级架构。'
- en: '*A transactional Dapp view*—I’ll walk you, step-by-step, through the entire
    lifecycle of a voting transaction.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交易Dapp视图*——我将带你逐步了解投票交易的整个生命周期。'
- en: '1.1.2\. Structural view: Anatomy of a Dapp'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 结构视图：Dapp的解剖
- en: The *structural view* of the decentralized voting application includes a description
    of the components of both the client side, represented by the web UI through which
    a voter submits a vote, and the server side, represented by a network of servers
    running the application logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化投票应用的*结构视图*包括客户端组件的描述，由代表投票者提交投票的网页用户界面（UI）表示，以及服务器端组件的描述，由运行应用逻辑的一组服务器表示。
- en: 'Dapp client side: a web application'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化应用（Dapp）客户端：一个网页应用
- en: The voting application web client, shown in [figure 1.3](#ch01fig03), gets initially
    downloaded into the user browser from a conventional web server, generally as
    a web application containing HTML and JavaScript. The web user interface doesn’t
    contain any server-side scripts and communicates directly with a specific server
    of the network through a client-side JavaScript library called Web3.js. It might
    also allow the user to communicate with a network node located on their premises.
    So far, this application differs in no major way from a conventional web application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1.3所示，投票应用的网页客户端最初从传统的网页服务器下载到用户浏览器中，通常是一个包含HTML和JavaScript的网页应用。网页用户界面不包含任何服务器端脚本，并通过一个名为Web3.js的客户端JavaScript库直接与网络中的特定服务器通信。它还可能允许用户与位于其场地的网络节点进行通信。到目前为止，这个应用与传统的网页应用在主要方面没有区别。
- en: Figure 1.3\. A decentralized voting application is exposed to the voter as a
    web application, which contains both HTML and JavaScript and is downloaded from
    a conventional web server. The web application, which doesn’t contain any server-side
    scripts (otherwise, it would be partially centralized), is generally configured
    to communicate directly with a specific node of the network.
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 对投票者而言，去中心化投票应用呈现为一个网页应用，其中包含HTML和JavaScript，并从传统的网页服务器下载。这个不包含任何服务器端脚本（否则它将是部分中心化的）的网页应用通常配置为直接与网络的特定节点通信。
- en: '![](Images/fig01-03_alt.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-03_alt.jpg)'
- en: 'Dapp server side: a P2P network'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化应用（Dapp）服务器端：一个P2P网络
- en: The server side of a decentralized application is a P2P network of servers that
    run the same code and have identical copies of a blockchain database. As you know,
    a key characteristic of this network topology is that it uses no central coordination,
    but instead uses direct communication between each node and a number of other
    nodes, known as *peer nodes* or simply *peers*. No master node is needed. As shown
    in [figure 1.4](#ch01fig04), a node doesn’t need to be connected to all of the
    other nodes of the network. Being connected to a few nodes is sufficient to ensure
    transactions are rapidly propagated to the whole network.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用的服务器端是一个运行相同代码并拥有区块链数据库相同副本的一组服务器构成的P2P网络。正如你所知，这种网络拓扑的一个关键特征是它不使用中心协调，而是使用每个节点与称为*对等节点*或简称*
    peers*的多个其他节点的直接通信。不需要主节点。如图1.4所示，一个节点不需要连接到网络的所有其他节点。与几个节点的连接就足以确保交易快速传播到整个网络。
- en: Figure 1.4\. A peer-to-peer (P2P) network is made of nodes that communicate
    directly with each other without the coordination of a master node.
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4. 对等网络（P2P）由直接与其他节点通信，无需主节点协调的节点组成。
- en: '![](Images/fig01-04_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-04_alt.jpg)'
- en: The Ethereum network
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以太坊网络
- en: Various P2P networks supporting blockchain platforms exist. The most well-known
    one is the Bitcoin network.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存在支持区块链平台的各种P2P网络。最著名的一个是以太坊网络。
- en: In this book, I’ll focus on the Ethereum network, whose *participant* nodes,
    as shown in [figure 1.5](#ch01fig05), host a *blockchain database* and a piece
    of software called a node *client*, which allows a node to communicate with other
    nodes. Because all nodes are equivalent to each other, within the Ethereum network
    you have no clear-cut concept of client and server. Each node is a server to other
    nodes, but, at the same time, it’s also a client of other nodes. That’s why the
    software element of an Ethereum node is called a client.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将重点关注以太坊网络，其*参与者*节点如图1.5所示([figure 1.5](#ch01fig05))，托管一个*区块链数据库*和一块被称为节点*客户端*的软件，该软件允许节点与其他节点通信。因为所有节点彼此平等，所以在以太坊网络中，你没有一个清晰定义的客户端和服务器概念。每个节点对其他节点来说是服务器，但同时，它也是其他节点的客户端。这就是为什么以太坊节点的软件元素被称为客户端。
- en: Ethereum clients expose a common client interface and communicate with each
    other through a P2P protocol called *Wire*. That protocol enforces a standard
    way of sending data throughout the network, specifically a *transaction*, such
    as a submitted vote, and a *block*, such as a set of votes consolidated in the
    blockchain database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊客户端暴露出一个共同的客户端接口，并通过名为*Wire*的P2P协议相互通信。该协议确保了在网络中发送数据的标准方式，具体包括*交易*，比如提交的投票，以及*区块*，比如在区块链数据库中的一组投票汇总。
- en: Various implementations of an Ethereum client exist. As you can see in [figure
    1.5](#ch01fig05), they’re written in various languages, from C++ to Go, but all
    implement the standard client interface and the Wire protocol, so they can interact
    seamlessly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种以太坊客户端的实现。如图1.5所示([figure 1.5](#ch01fig05))，它们是用各种语言编写的，从C++到Go，但都实现了标准的客户端接口和Wire协议，因此它们可以无缝交互。
- en: Figure 1.5\. Each node of the Ethereum network hosts a blockchain database and
    a node client capable of executing application code stored in the blockchain.
    Nodes communicate through the Wire protocol and expose the same interface but
    can be implemented in different languages.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5\. 以太坊网络的每个节点都托管一个区块链数据库和一个能够执行存储在区块链中的应用程序代码的节点客户端。节点通过Wire协议通信，并暴露出相同的接口，但可以采用不同的编程语言实现。
- en: '![](Images/fig01-05_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-05_alt.jpg)'
- en: The advantage of an Ethereum node client over a Bitcoin node client is that
    it’s able not only to propagate cryptocurrency transactions and blocks throughout
    the network, as a Bitcoin node does, but also to execute application code hosted
    on the blockchain database. From this point of view, platforms such as Ethereum
    are known as *programmable blockchains*. The code of decentralized applications
    is structured in *smart contracts*, which encapsulate logic and state in the same
    way classes do in most object-oriented languages. The voting decentralized application,
    for example, would be structured on various smart contracts that would be hosted
    on the Ethereum blockchain. I’ll explain shortly what a smart contract is, how
    you deploy it, how you execute it, and where a smart contract is stored and runs.
    Bear with me.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊节点客户端与比特币节点客户端的优势在于，它不仅能够像比特币节点那样在网络中传播加密货币交易和区块，还能够执行托管在区块链数据库上的应用程序代码。从这一点来看，像以太坊这样的平台被称为*可编程区块链*。去中心化应用程序的代码结构在*智能合约*中，智能合约以大多数面向对象语言中的类封装逻辑和状态的方式封装逻辑和状态。例如，投票去中心化应用程序将基于各种智能合约进行结构化，这些智能合约将托管在以太坊区块链上。我即将解释智能合约是什么，如何部署它，如何执行它，以及智能合约存储和运行的位置。耐心点。
- en: The role of network nodes
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络节点的作用
- en: 'Although all network nodes communicate seamlessly through the common P2P Wire
    protocol, not all nodes perform the same function. Broadly, as shown in [figure
    1.6](#ch01fig06), the two main types of nodes, which are functionally different,
    are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有网络节点都通过共同的P2P Wire协议无缝通信，但并非所有节点执行相同的功能。广泛来说，如图1.6所示([figure 1.6](#ch01fig06))，两大类节点，功能上不同，如下所述：
- en: '*Full node*—Most nodes have a standard setup that allows them to process transactions
    passively: they can read from the blockchain database, but they can’t create new
    blockchain blocks. But they can append blocks received from peer nodes to the
    local blockchain. They do execute transactions, but only to verify the correctness
    of the blockchain blocks they receive from peer nodes. In the case of the voting
    application, full nodes propagate votes received from their peers to other peers.
    They also verify that the blocks received are correct and contain authentic votes
    by running the voting Dapp smart contracts. But full nodes don’t store votes in
    new blockchain blocks.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整节点*—大多数节点具有标准设置，使它们能够被动处理交易：它们可以从区块链数据库中读取，但不能创建新的区块链块。但它们可以将从对等节点接收的块附加到本地区块链。它们确实执行交易，但仅用于验证从对等节点接收的区块链块的正确性。在投票应用程序的情况下，完整节点将来自其对等节的投票传播给其他对等节点。它们还验证接收到的块是否正确，并包含真实的投票，通过运行投票Dapp智能合约来实现。但完整节点不会在新区块链块中存储投票。'
- en: 'Figure 1.6\. The Ethereum network includes two main types of nodes. Full nodes
    process transactions passively and can read, but can’t write on, the blockchain.
    Mining nodes process transactions actively: they validate the correctness of transactions
    as full nodes do, but they also assemble transactions into new blocks that are
    appended onto the blockchain.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6。以太坊网络包括两种主要类型的节点。完整节点被动处理交易，可以从区块链数据库中读取，但不能写入。挖矿节点主动处理交易：它们像完整节点一样验证交易的正确性，但它们还组装新的交易块，这些块被附加到区块链上。
- en: '![](Images/fig01-06_alt.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig01-06_alt.jpg)'
- en: '*Mining node*—Some of the nodes are configured to process transactions actively:
    they group and store transactions in new blockchain blocks. They’re rewarded in
    Ether, the cryptocurrency supported in the Ethereum platform, for performing such
    computationally intensive and energy demanding work. They then propagate these
    new blocks to the rest of the P2P network. Such nodes are called mining nodes
    because the process of consolidating a new block to the blockchain and being rewarded
    for it in cryptocurrency tokens is known as *mining*. In the case of the voting
    Dapp, mining nodes group votes received from peer nodes into a new block, append
    the block to the blockchain, and propagate the block through their peers.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*挖矿节点*—一些节点被配置为主动处理交易：它们将交易分组并存储在新的区块链块中。它们通过在以太坊平台上支持的加密货币Ether中执行这样计算密集型和能源消耗型工作而获得奖励。然后，它们将这些新块传播到P2P网络的其余部分。这些节点被称为挖矿节点，因为将新块整合到区块链中并因此获得加密货币代币奖励的过程被称为*挖矿*。在投票Dapp的情况下，挖矿节点将来自对等节点的投票分组到一个新块中，将块附加到区块链，并通过其对等节点传播该块。'
- en: Putting everything together
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: You’ve examined the structural view of the voting Dapp. [Figure 1.7](#ch01fig07)
    shows the entire system, including the client and server sides.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经检查了投票Dapp的结构视图。[图1.7](#ch01fig07)展示了整个系统，包括客户端和服务器端。
- en: Figure 1.7\. The entire static view of a decentralized voting application, including
    client and server sides
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7。分布式投票应用程序的整个静态视图，包括客户端和服务器端
- en: '![](Images/fig01-07_alt.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-07_alt.jpg)'
- en: '1.1.3\. Transactional view: Through the lifecycle of a transaction'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3。交易视图：通过交易的生命周期
- en: 'Adding a temporal dimension to the static view you saw in [figure 1.7](#ch01fig07),
    [figure 1.8](#ch01fig08) illustrates step-by-step the full lifecycle of a voting
    transaction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在[图1.7](#ch01fig07)中看到的静态视图的基础上增加时间维度，[图1.8](#ch01fig08)逐步说明了投票交易的完整生命周期：
- en: The user selects one of the possible voting options from a drop-down list box
    on the web client and clicks Vote.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从网页客户端的下拉列表框中选择一个可能的投票选项，然后单击投票。
- en: A JavaScript function handles the click event and grabs the voting selection.
    Then, through various web3.js library functions, it sets up the communication
    with a configured Ethereum node, connects with the voting smart contract, and
    calls the `castVote()` function on it. The invocation of `castVote()` generates
    a transaction message that’s digitally signed against the account of the user
    to prove they’re the genuine sender.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个JavaScript函数处理点击事件并获取投票选择。然后，通过各种web3.js库函数，它与配置的以太坊节点建立通信，连接到投票智能合约，并在其上调用`castVote()`函数。对`castVote()`的调用生成一个交易消息，该消息以用户的账户为依据进行数字签名，以证明他们是真正的发送者。
- en: The contacted local Ethereum node handles the transaction message, verifies
    it, and relays it to its peer nodes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系到的本地以太坊节点处理交易消息，验证它，并将它传递给其对等节点。
- en: Peer nodes do the same and keep propagating the transaction, until the transaction
    hits mining nodes. This will happen relatively quickly, depending on the ratio
    of full nodes to mining nodes. Mining nodes perform the same steps (steps 2 and
    3) of a full node. In addition, a mining node picks a transaction, such as a voting
    transaction. A transaction is considered profitable if it’s expected to generate
    an acceptable transaction fee, higher than the electricity costs the mining node
    faces while processing transactions. If so, the mining node executes the `castVote()`
    function and competes with other mining nodes to store the transaction on the
    blockchain. The winning mining node (which is the mining node successfully solving
    the so-called consensus algorithm, a cryptographic problem) consolidates the voting
    transaction among other transactions in a new block of the blockchain. It then
    relays the new block to all its peer nodes (regardless of whether they’re full
    or mining nodes).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点之间相互转发交易，直到交易到达挖矿节点。这相对较快发生，取决于完整节点与挖矿节点的比例。挖矿节点执行与完整节点相同的步骤（第2步和第3步）。此外，挖矿节点选择一个交易，如一个投票交易。如果一个交易预计能产生一个可接受的交易费，高于挖矿节点处理交易时面临的电力成本，那么这个挖矿节点就会执行`castVote()`函数，与其他挖矿节点竞争将交易存储在区块链上。获胜的挖矿节点（即成功解决所谓共识算法，一个加密问题的挖矿节点）会在区块链的新区块中与其他交易一起巩固投票交易。然后，它将新区块传递给所有其同伴节点（不论它们是完整节点还是挖矿节点）。
- en: Each node that has received a new block verifies whether the individual transactions
    included in it are genuine and whether the block as a whole is valid. It then
    processes all the transactions present in it. While doing this, it implicitly
    verifies the validity of the contract state. For example, the vote submission
    logic might include an invariant verifying that the number of votes cast for a
    candidate, or the total number of votes cast for all candidates, isn’t higher
    than the number of registered voters. If the node verifies the block successfully,
    it relays it to its peer nodes, which perform the same validation and propagation
    action until the whole network has acquired the new blockchain block. (The verification
    process will become clearer to you in the next chapter, when I’ll present the
    cryptographic techniques it’s based on.)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个接收到新块的节点都会验证其中包含的个别交易是否真实，以及整个区块是否有效。然后处理其中的所有交易。在这个过程中，它隐式地验证了合约状态的有效性。例如，投票提交逻辑可能包括一个不变量，验证对于一个候选人投出的票数，或所有候选人投出的总票数，不会高于注册选民的数量。如果节点成功验证了区块，它会将其传递给它的同伴节点，这些节点执行相同的验证和传播动作，直到整个网络都获得了新的区块链区块。（验证过程在下一章中会更清晰地解释给你听，届时我将介绍它所基于的加密技术。）
- en: The local Ethereum node with respect to the user receives the new block and
    verifies it by executing all the transactions present on it, as all the other
    nodes have done. One of these is the voting transaction, which has been programmed
    to raise a `VoteConfirmation` event on successful completion. The event is published
    to all the clients subscribed to it, including the Dapp web UI.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于用户而言，本地的以太坊节点接收新块并通过执行其中的所有交易来验证它，像其他所有节点一样。其中一个是投票交易，它已经被编程在成功完成时触发一个`VoteConfirmation`事件。事件被发布给所有订阅它的客户端，包括Dapp的Web
    UI。
- en: Figure 1.8\. The lifecycle of a voting transaction. A voting transaction is
    created when a voter browser invokes the `castVote()` function on the Voting smart
    contract on a local node of the Ethereum network. This is then validated and propagated
    throughout the network until it’s included on a new blockchain block by a mining
    node. The new block is propagated throughout the network, and then it finally
    gets back to the local node.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 投票交易的生命周期。当一个选民浏览器在以太坊网络的本地节点上调用`castVote()`函数在一个投票智能合约上时，就会创建一个投票交易。这然后被验证并在整个网络中传播，直到它被一个挖矿节点包含在一个新的区块链区块中。新的区块在整个网络中传播，然后最终返回到本地节点。
- en: '![](Images/fig01-08_alt.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig01-08_alt.jpg)'
- en: The JavaScript code present on the voting web client contains a callback function
    registered against the `VoteConfirmation` event, which then gets triggered.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票Web客户端上存在的JavaScript代码包含一个针对`VoteConfirmation`事件的回调函数，该函数随后会被触发。
- en: Finally, the callback function shows a vote confirmation notification on the
    voter’s screen.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回调函数在选民屏幕上显示一个投票确认通知。
- en: 1.1.4\. Some Dapp terminology
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 一些Dapp术语
- en: Although decentralized applications are a relatively new idea, standard terminology
    around them started to appear relatively soon after the first Dapps were built.
    In this section, I’ll provide a summary of the key terms that Vitalik Buterin,
    the creator of Ethereum, described in a famous blog post^([[1](#ch01fn01)]) he
    wrote to explain key Dapp concepts. You’ve already come across some of these terms
    in the previous sections, but now I’ll define them more precisely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管去中心化应用是一个相对较新的概念，但在第一个Dapps构建后相对较短的时间内，围绕它们的标准化术语开始出现。在本节中，我将概述以太坊创始人Vitalik
    Buterin在一篇著名的博客文章中描述的关键术语^([[1](#ch01fn01)])，以解释关键的Dapp概念。您已经在之前的章节中遇到过一些这些术语，但现在我将更精确地定义它们。
- en: ¹
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Vitalik Buterin, “DAOs, DACs, DAs and More: An Incomplete Terminology Guide,”
    [http://mng.bz/vNrq](http://mng.bz/vNrq).'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Vitalik Buterin，“DAOs, DACs, DAs and More: An Incomplete Terminology Guide，”[http://mng.bz/vNrq](http://mng.bz/vNrq)。'
- en: Smart contract
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智能合约
- en: A *smart contract* is an arrangement between two or more parties that involves
    an exchange of digital assets. One or more of these parties allocates digital
    assets to the contract at its initiation. Subsequently, the assets are redistributed
    among the parties according to a predefined protocol encoded in logic and a state
    that’s initialized at the start of the contract.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*智能合约*是涉及数字资产交换的两个或多个方的安排。其中一个或多个方在合约启动时向合约分配数字资产。随后，根据逻辑中预定义的协议和初始化的状态，资产根据逻辑重新分配给各方。
- en: Autonomous agent
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自主代理
- en: An *autonomous agent* is a software entity that interacts autonomously with
    external software services and can reconfigure or even reprogram itself following
    verified changes in the external environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*自主代理*是一个与外部软件服务自主交互的软件实体，根据外部环境验证的变化重新配置或甚至重新编程自己。
- en: Decentralized organization
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化组织
- en: A traditional *centralized organization* contains assets and different classes
    of individuals, typically investors, employees, and customers. Investors control
    the organization by owning a part of it through the purchase of shares. Interactions
    between some classes of individuals are influenced by whether they control the
    organization. For instance, employees can get recruited by investors or by other
    employees authorized directly or indirectly by investors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传统的*中心化组织*包含资产和不同类别的个体，通常是投资者、员工和客户。投资者通过购买股份拥有组织的一部分来控制组织。某些类别的个体之间的交互受到他们是否控制组织的影响。例如，员工可以被投资者直接或间接授权的其他员工招募。
- en: A *decentralized organization* (DO) isn’t controlled by any one person or entity.
    Predefined protocols are what determine interactions between classes of individuals
    involved in the organization. But such protocols can be designed so that certain
    individuals have more power than others—for instance, depending on the number
    of shares owned—exactly as with centralized organizations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*去中心化组织*（DO）不由任何一个人或实体控制。预定义的协议决定了组织中涉及的不同类别人群之间的交互。但是，这些协议可以设计成让某些人比其他人拥有更多的权力——例如，根据所拥有的股份数量——正如集中式组织一样。
- en: Decentralized autonomous organization
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化自治组织
- en: A *decentralized autonomous organization* (DAO) is both a DO and an autonomous
    agent. Like an autonomous agent, it’s a software entity that interacts autonomously
    with external software services. Individuals involved with the DAO interact, as
    with DOs, through predefined protocols.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*去中心化自治组织*（DAO）既是DO又是自主代理。与自主代理一样，它是一个与外部软件服务自主交互的软件实体。参与DAO的个人通过预定义的协议与DOs交互。
- en: The main difference between a DAO and a DO is that interactions between DAOs
    and external parties are largely automated, and the interaction protocols are
    programmed in a *smart contract*, whereas interactions between the individuals
    who own the DO and external parties are subject only to a *manual protocol*. The
    key point is that from the point of view of external parties, DAOs are more trustworthy
    than DOs because automated interactions are predictable, whereas interactions
    based on a manual protocol rely entirely on the reputation of the individuals
    following it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DAO与DO的主要区别在于，DAO与外部实体的交互 largely是自动化的，且交互协议编程在*智能合约*中，而拥有DO的个人与外部实体的交互仅受*手动协议*的约束。关键点是，从外部实体的角度来看，DAOs比DOs更可信，因为自动交互是可预测的，而基于手动协议的交互完全依赖于遵循它的个体的声誉。
- en: According to these definitions, opinions diverge as to whether blockchain platforms
    built with the main or only purpose of supporting a cryptocurrency can be classified
    as DAOs or DOs. Because the Bitcoin infrastructure doesn’t allow for implementation
    of easily automated interaction protocols, some think it should be classified
    as a DO.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized autonomous corporation
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *decentralized autonomous corporation* (DAC) is a DAO that can be partially
    owned through a purchase of shares. As with classic (centralized) corporations,
    a DAC redistributes dividends periodically, depending on its financial success.
    A pure DAO, on the other hand, is generally a nonprofit organization, and participants
    benefit economically exclusively by contributing to its ecosystem and increasing
    its internal capital.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The current widely accepted definition of *decentralized application* corresponds
    to that of DAO described previously, which is still in use among Ethereum purists.
    I’ll use this definition for Dapp for the rest of this book. The reason why the
    initial terminology used the word *organization* rather than *application* was
    because the Ethereum founders wanted to put emphasis on the fact that a decentralized
    application can transact with other parties exactly like conventional organizations:
    by following rules and protocols and exchanging monetary value, obviously in the
    form of cryptocurrency rather than conventional currency.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: The key aspects of each of these terms are summarized in [table 1.1](#ch01table01).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1\. Matrix summarizing key aspects of each term, with DAO standing for
    Dapp
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | Is software | Has capital | Is autonomous | Is owned |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Autonom agent | YES | NO | YES | NO |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| DO | NO | YES | NO | YES |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| **DAO** | **YES** | **YES** | **YES** | **NO** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| DAC | YES | YES | YES | **YES** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: Although you’ve learned some of the high-level terms, you can’t truly understand
    the purpose of Dapps and how they work without familiarizing yourself with the
    concept of blockchain. Because Dapps are built on top of the blockchain and rely
    heavily on it, you should learn about it and its underlying technologies. I’ll
    cover this in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '**Decentralized vs. distributed applications**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '*Decentralized* applications shouldn’t be confused with *distributed* applications.
    The two concepts have similarities, but they’re not the same thing.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: An application is distributed if it runs over multiple servers within a network.
    The simplest example of a distributed application is a web application, which
    is typically distributed over a web server, an application server, and a database
    server, and possibly an email server and legacy mainframes. The centralized voting
    application seen earlier is an example of a distributed application. It’s distributed
    because it’s spread over several servers, but it’s also centralized because all
    the servers are owned by the same institution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: A distributed application runs over multiple servers of a network. A decentralized
    application is replicated in its entirety over each node of a wide network.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0019-01_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Comparison of the structures of distributed and decentralized applications
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: An application is decentralized if it’s replicated in its entirety over each
    node of a network, with each node being theoretically owned by a different entity.
    The higher the number of entities owning nodes of the network, the more trustful
    the network in its entirety is. Obviously, networks that have only a few owners
    can’t be considered trustful because they don’t truly decentralize the processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: A centralized application is generally distributed, but decentralized applications
    can also be distributed over multiple servers within each logical node.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: 1.2\. Good and bad Dapps
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last few years, many Dapps have been developed. Some have received various
    rounds of venture capital funding and have been deployed successfully into production.
    Others have failed to convince investors and users and never passed the proof-of-concept
    stage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1\. Good use cases
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the novelty of the technology, it’s hard to predict what’s going to work
    and what’s going to fail. Nevertheless, various use cases are being widely recognized
    as a good fit for the blockchain and in particular for Ethereum. Ideal Dapps are
    those that take advantage of the main benefits of these technologies, specifically
    record immutability, decentralization, security, and resilience. As a result,
    the main fields likely to be revolutionized by Dapps are provenance and ownership
    tracking, authenticity tracking, identity verification, regulatory auditing, charity
    expense auditing, prediction markets, customer loyalty management, crowdfunding,
    electronic voting, investing, gambling, lending, online games management, author
    royalty payment, Internet of Things, cloud computing, and even freedom of speech.
    Let’s see what innovative solutions have already been found in some of these areas.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Provenance and authenticity tracking
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One of the biggest problems affecting supply chain management, particularly
    when involving long chains of processed goods crossing several countries, is tracking
    the authenticity of materials. Here are some Dapps that are innovating in this
    area with blockchain-based solutions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Dapps such as Provenance provide blockchain-based provenance tracking of materials
    to ensure no information is lost or manipulated within the supplier chain and
    goods of expected quality reach the end customer. One of the first applications
    built on Provenance has been focused on the food industry, to track the supply
    chain of ingredients from the point of collection, though the process of food
    manufacturing, to the final point of consumer sale. The aim of this system is
    to prove the food being sold has the claimed characteristics advertised to the
    consumers, such as location and sustainability of harvesting or breeding, whether
    the sources are organic or have been genetically modified, whether they’re coming
    from fair trade, and so on.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Provenance这样的Dapp提供了基于区块链的来源追踪，以确保在供应商链中没有信息丢失或被操纵，并确保符合预期质量的商品到达最终客户。Provenance上构建的第一个应用程序一直专注于食品行业，追踪从收集点开始的原料供应链，经过食品制造过程，最终到达消费者销售点。该系统的目的是证明销售的食品具有向消费者广告的声称特征，例如收割或饲养的地点和可持续性，来源是否有机或经过基因改造，是否来自公平贸易等等。
- en: Unilever, the multinational consumer goods corporation, is developing a blockchain-based
    system in collaboration with a number of start-ups to track the tea supply chain
    starting from farmers in Malawi.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合利华这家跨国消费品公司正在与多家初创公司合作，开发一个基于区块链的系统，以追踪从马拉维农民开始的茶叶供应链。
- en: Everledger is a Dapp that aims to replace the paper certification process for
    diamonds with a blockchain-based system. A full digital record of a diamond, including
    its certificate ID and many properties, such as cut, grade, clarity, color, and
    carat, is stored on the blockchain, and the certificate ID is then engraved with
    a laser on the stone. All the information related to a diamond can then be retrieved
    at any point of the supply chain with the help of a scanner that reads the certificate
    ID from the stone. Almost 2 million diamonds have already been stored on Everledger.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Everledger是一个旨在用基于区块链的系统替换钻石纸质认证流程的Dapp。一颗钻石的完整数字记录，包括其证书ID和许多属性，如切割、等级、清晰度、颜色和克拉重量，存储在区块链上，然后使用激光在钻石上刻上证书ID。然后，在任何供应链环节，都可以使用读取石头上证书ID的扫描仪检索与钻石相关的所有信息。已经有近200万颗钻石存储在Everledger上。
- en: The pharmaceutical company Pfizer is partnering with the biotechnology company
    Genentech to develop MediLedger, a blockchain-based drug delivery tracking system.
    The aim is to verify the provenance and authenticity of Pfizer drug deliveries
    throughout the entire distribution chain to prevent thefts, fraud, and counterfeiting.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制药公司辉瑞正在与生物技术公司基因泰克合作开发MediLedger，这是一个基于区块链的药物交付追踪系统。目标是验证辉瑞药物在整个分销链中的来源和真实性，以防止盗窃、欺诈和假冒。
- en: Identity verification
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 身份验证
- en: As with provenance tracking, verification of proof of identity tries to protect
    businesses and individuals from the consequences of fraud and identity theft.
    KYC-Chain is a novel platform built on the Ethereum blockchain that allows users
    to manage their digital identity securely. It also helps businesses and financial
    institutions to manage customer data in a reliable and easy manner. The system
    is designed so that users own the “keys” to their personal data and identity certificates.
    Consequently, identity owners, who can be individuals or companies, are the only
    ones who get to choose which part of their information is shared, with whom, and
    under what terms. Such information is digitally attested by notaries and institutions
    before being shared by owners and registered agents.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如来源追踪一样，身份证明的验证试图保护企业和个人免受欺诈和身份盗窃的后果。KYC-Chain是一个建立在以太坊区块链上的新型平台，使用户能够安全地管理他们的数字身份。它还帮助企业和金融机构以可靠和简单的方式管理客户数据。该系统设计成用户拥有个人数据和身份证明的“钥匙”。因此，身份所有者，可以是个人或公司，是唯一可以选择分享其信息的一部分、与谁分享以及分享条件的唯一人员。在所有者及其注册代理分享之前，此类信息由公证人和机构数字证实。
- en: Proving ownership
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 证明所有权
- en: Traditional blockchains associated with cryptocurrencies such as Bitcoin as
    ledgers implicitly prove the ownership of digital assets, such as the amount of
    Bitcoin stored at a certain address. Only the legitimate owners of the address
    are able to transfer funds because they’re the only ones who know the private
    key.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的区块链技术，如与比特币关联的加密货币，隐含地证明了数字资产的所有权，比如某个地址存储的比特币数量。只有地址的合法所有者才能转账，因为他们是唯一知道私钥的人。
- en: TrustToken tries to go further. It’s a Dapp conceived for proving the ownership
    of physical assets, such as real estate; financial assets, such as stocks and
    bonds; commodities, such as gold; and even intellectual property, such as music,
    books, and patents, through smart contracts. The idea is that you can transfer
    the ownership of these assets from one person to the other in the same way Bitcoins
    are transferred between addresses. The underlying assumption for TrustToken to
    be successful is that proof of ownership recorded through the system should be
    enforceable under law.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: TrustToken试图更进一步。它是一个旨在通过智能合约证明实体资产所有权的Dapp，如房地产、股票和债券等金融资产、黄金等商品，甚至音乐、书籍和专利等知识产权。想法是你可以像转移比特币一样，将这类资产的所有权从一个人转移到另一个人。TrustToken成功的根本假设是，通过系统记录的所有权证明在法律上应该是可执行的。
- en: Economy of Things
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网经济
- en: The tech startup Slock.it ([https://slock.it/](https://slock.it/)) is building
    the infrastructure for the “economy of things,” which lies at the intersection
    between the Internet of Things and blockchain technology. This infrastructure,
    which the company has named the Universal Sharing Network, has the potential to
    be used as a financial internet, where connected autonomous objects can not only
    sell and rent themselves but also pay for each other’s services. The technology
    the company is developing, based on Ethereum smart contracts, aims to provide
    autonomous objects an identity and the ability to receive payments and enter into
    agreements without the need for intermediaries. Smart lockers, which enable the
    unlocking of physical objects when a fee is paid, are some of the applications
    already created on this platform. Because smart lockers make renting of sports
    equipment, hotel rooms, bicycles, and offices easy, this solution is thought to
    provide the foundation for the sharing economy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 科技创业公司Slock.it（[https://slock.it/](https://slock.it/)）正在构建物联网与区块链技术交汇点的“物联网经济”的基础设施。该公司称之为“通用共享网络”的基础设施，有潜力作为金融互联网使用，在其中的自主物体不仅可以出售和出租自己，还可以互相支付服务费用。该公司正在开发的技术，基于以太坊智能合约，旨在为自主物体提供身份认证，并使其能够接收付款和签订协议，而无需中介。已经在这个平台上创建了智能锁柜等应用，这些应用可以在支付费用时解锁物理对象。由于智能锁柜使得租赁体育设备、酒店房间、自行车和办公室变得容易，这种解决方案被认为为共享经济提供了基础。
- en: Decentralized prediction markets
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化的预测市场
- en: Prediction markets reward people for correctly predicting real-world events,
    such as the winner of a presidential election, the outcome of a referendum, the
    level of interest rates at a specific date, or the winner of a sports competition.
    Aside from speculative uses, they’re also useful tools for economists, public
    administration planners, and corporate strategists, who can base their decisions
    on the event probabilities being currently traded, which are thought to reflect
    the “wisdom of the crowds.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 预测市场通过正确预测现实世界事件来奖励人们，如总统选举的获胜者、公投的结果、特定日期的利率水平或体育比赛的获胜者。除了用于投机，它还是一种有用的工具，供经济学家、公共行政规划者和企业战略家使用，他们可以根据目前市场上正在交易的事件概率做出决策，这些概率被认为反映了“群体智慧”。
- en: 'Although centralized markets such as [predictit.org](http://predictit.org)
    ([www.predictit.org](http://www.predictit.org)) exist, several decentralized initiatives
    are starting to emerge. Augur is a decentralized market prediction platform built
    on Ethereum. The idea is that decentralization brings the following benefits:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在像[predictit.org](http://predictit.org)（[www.predictit.org](http://www.predictit.org)）这样的集中市场，但已经有几个去中心化的倡议开始出现。Augur是一个基于以太坊的去中心化市场预测平台。理念是去中心化能够带来以下好处：
- en: Being based on the Ethereum network, it has no central point of failure, so
    it’s inherently highly available.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于以太坊网络，它没有单一的失败点，因此具有高度的可用性。
- en: 'Nobody controls the definition of markets: anyone can start a new market on
    a new prediction and can get rewarded for having created that market.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人控制市场的定义：任何人都可以开始一个新的市场，对新的预测进行预测，并且可以因为创造了这个市场而获得奖励。
- en: The official outcome of each prediction isn’t decided centrally; it’s crowdsourced
    from market participants, so it’s less likely to be subject to manipulation.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个预测的官方结果并不是集中决定的；它是由市场参与者集体提供的，因此不太可能受到操纵。
- en: Funds are stored on the blockchain, which eliminates counterparty risk, makes
    payment to prediction winners fast, and reduces the likelihood of errors.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金存储在区块链上，消除了对手方风险，支付给预测赢家迅速，并减少了出错的可能性。
- en: International trade finance
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 国际贸易融资
- en: International trade between a supplier and a manufacturer located in different
    countries is a complex business. As you can see in [figure 1.9](#ch01fig09), it’s
    generally based on a complicated workflow involving many parties, such as banks
    that facilitate the payment, commercial intermediaries that facilitate the distribution,
    shipping and delivery companies that transport the goods, insurers that cover
    financial risks while the goods are in transit, and customs officials who check
    the legality of the goods and the payment of import duties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 位于不同国家的供应商和制造商之间的国际贸易是一项复杂的业务。正如你在[图1.9](#ch01fig09)中所看到的，它通常基于一个涉及许多方的复杂工作流程，如银行促进支付、商业中介促进分销、航运和交付公司运输货物、保险公司在货物运输过程中承担金融风险、海关官员检查货物的合法性和支付进口关税。
- en: 'Figure 1.9\. Typical international trade involving many parties: banks, commercial
    intermediaries, shipping companies, insurers, customs officials, and so on'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 涉及许多参与方的典型国际贸易：银行、商业中介、航运公司、保险公司、海关官员等等。
- en: '![](Images/fig01-09_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-09_alt.jpg)'
- en: Parties involved in a specific transaction often have never dealt with each
    other previously. But for the transaction to complete successfully, they must
    communicate with each other effectively, generally through established lengthy
    protocols designed to protect a party against the malicious behavior of another
    party. Parties cross-check each other, and this takes a huge amount of paperwork
    and time, which often causes long delays.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参与特定交易的各方通常以前从未相互交易过。但是，为了使交易成功完成，他们必须有效地相互沟通，通常是通过建立的长达数小时的协议，旨在保护一方免受另一方的恶意行为。各方相互核实，这需要大量的文件和时间，常常导致长时间延迟。
- en: we.trade is a platform sponsored by a consortium of banking partners (including
    Société Générale, Deutsche Bank, Nordea, Santander, and HSBC) that aims at simplifying
    and streamlining such processes with the help of blockchain technology. The platform
    tracks each step of the transaction openly and transparently so that each party
    is able to submit and consume the relevant documentation with the confidence that
    no one will tamper with it. Trades that used to take weeks can be now completed
    in a few days.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: we.trade是一个由银行合作伙伴（包括Société Générale、Deutsche Bank、Nordea、Santander和HSBC）组成的平台，旨在利用区块链技术简化并优化这些流程。该平台公开透明地跟踪交易的每个步骤，以便各方能够提交和消费相关文件，确信没有人会篡改它们。以前需要几周的交易现在可以在几天内完成。
- en: Regulatory auditing
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监管审计
- en: The blockchain is particularly suitable for ensuring that records stored on
    it haven’t been altered or tampered with. Balanc3 is a Dapp built on Ethereum
    that ensures the integrity of accountancy records for regulatory purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链特别适用于确保存储在其中的记录没有被更改或篡改。Balanc3是一个基于以太坊的Dapp，用于确保会计记录的完整性以满足监管要求。
- en: Crowdfunding
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 众筹
- en: WeiFund aims at providing open source modular and extensible decentralized crowdfunding
    utilities based on the Ethereum blockchain. Users can set up and manage crowdfunding
    campaigns through these utilities. The possibility of encoding funding rules based
    on smart contract technology allows users to know precisely what will happen with
    their money if the campaign fails or is successful.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: WeiFund旨在提供基于以太坊区块链的开源模块化和可扩展的众筹工具。用户可以通过这些工具建立和管理众筹活动。基于智能合约技术编码的筹款规则使得用户能够确切知道如果活动失败或成功，他们的钱会发生什么。
- en: Gambling
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赌博
- en: Intuitively, a natural fit for a decentralized application is a gambling platform,
    because users get the benefit of being assured that bets are processed fairly
    and predictably. Edgeless is an example of such a platform, and it’s currently
    being developed after a successful crowdfunding campaign.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about some successful Dapp implementations, you might
    be wondering whether it’s always worth basing your application on blockchain technology.
    We’ll explore this in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2\. Pointless Dapps
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Deciding whether the blockchain is a suitable technology for an application
    you’re planning to build might be difficult. What you should ask yourself is whether
    the functionality that a blockchain platform offers will meet your business requirements.
    More importantly, consider whether the benefits of using such a platform would
    be outweighed by all the technical limitations and additional complexities that
    come with this technology. A sobering blog post titled “Avoiding the Pointless
    Blockchain Project”^([[2](#ch01fn02)]) analyzes the requirements necessary to
    justify the use of a blockchain platform over more traditional technologies such
    as SQL or NoSQL databases. It concludes that a blockchain project only makes sense
    if you can answer yes to all of the following questions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: ²
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gideon Greenspan, “Avoiding the Pointless Blockchain Project,” [http://mng.bz/4Oqg](http://mng.bz/4Oqg).
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does your application require a shared database?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the database need to support multiple writing parties?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the writing parties have no trust in each other?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the writing parties want to modify the state of the database directly, without
    requiring a central entity trusted by all participants?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do transactions that the writing parties create interact collaboratively with
    each other?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to these criteria, for example, an internal enterprise application
    that wouldn’t expose any data to external parties wouldn’t be a suitable choice
    for a Dapp. Other poor Dapp candidates are applications for which confidentiality
    around the business rules is important. A smart contract is, by definition, completely
    open and transparent to all interacting parties. Therefore, preventing participants
    from accessing and understanding the logic of the rules would defeat the purpose.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Although decentralized microblogging applications such as EthTweet are considered
    sensible Dapps to those who value the fact that messages can’t be censored and
    altered after they’re sent, an instant messaging Dapp, such as a “decentralized
    WhatsApp,” wouldn’t be a particularly useful product for a fundamental reason.
    One of the technical downsides of the blockchain platform is that processing transactions
    (in this case instant messages) requires roughly 15 seconds to consolidate a new
    blockchain block. Therefore, messages would never be *instant* at all.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When building a Dapp, you also should keep in mind some operational aspects
    that, given the novelty of the technology, may cause some issues down the road.
    For instance, although a smart contract can automatically guarantee funds are
    routed and released subject to certain conditions, a commercial transaction might
    also be subject to real-world conditions that programming logic can’t enforce.
    A classic example for a non-fully automatically enforceable smart contract is
    that of an electronic loan. If the borrower had to keep the borrowed money stuck
    on a blockchain account so a smart contract could automatically give it back to
    the lender if the borrower missed an interest payment, the borrowing wouldn’t
    make any economic sense. In these cases, it isn’t clear yet whether a court of
    law would be able to enforce the nonautomated elements of a smart contract or
    it would be necessary to complement the deal with a traditional legal arrangement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. A five-minute Dapp implementation
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you should have a good understanding of what a Dapp is, the purpose
    of Dapps over conventional apps, the main architectural components of a decentralized
    application, and whether it makes sense to embark on a project based on blockchain
    technologies. It’s now time to take one little step further and get on with some
    programming. In the rest of the chapter, you’ll start building the smart contract
    for a custom cryptocurrency. You’ll then activate it and interact with it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1\. Building SimpleCoin, a basic cryptocurrency
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most Dapps are designed using functionality based on the exchange of cryptocurrency
    or tokens through rules encoded in one or more smart contracts. You’ll start to
    get a feel for Dapps programming by building SimpleCoin, a basic cryptocurrency
    that will present useful preliminary concepts about smart contracts and the Ethereum
    platform. You’ll progressively build on it in the following chapters, where you’ll
    learn more about Dapp development. You’ll also use or reference SimpleCoin from
    other Dapps that you’ll build in later chapters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Because you haven’t installed an Ethereum platform client on your computer yet,
    you’ll be writing code on the Remix Solidity (previously known as Browser Solidity)
    integrated development environment (IDE) for now. This online tool will allow
    you to implement smart contracts in a high-level language called Solidity, similar
    to Java-Script, and run them on a local JavaScript VM that emulates the Ethereum
    Virtual Machine that you’ll meet in the next chapter. It’s also possible through
    this tool to interact with real smart contracts deployed on the Ethereum network.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and go to: [http://remix.ethereum.org/](http://remix.ethereum.org/).
    You should see a screen like [figure 1.10](#ch01fig10). On the website, the left
    side of the IDE is a file explorer (which you can hide by clicking the double
    arrow toggle at the top left); in the middle you have the code editor; and the
    right side contains various panels to run the code and interact with it.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10\. Screenshot of the Remix opening screen, with the code on the left
    and the code execution panels on the right. I’ve hidden the file explorer by clicking
    the double arrow toggle at the top left.
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-10_alt.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: In your first encounter with Solidity, you’ll implement the simplest possible
    smart contract. If you think of a smart contract as the equivalent of a class
    in an object-oriented language, you’ll write a single class with only one member
    field, one constructor, and one method. Then you’ll run it and interact with it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Hide the file explorer by clicking the double arrow toggle at the top left,
    and then enter the code in [listing 1.1](#ch01ex01) in the Remix editor, in the
    left side of the screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.1\. First implementation of SimpleCoin, a basic cryptocurrency
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Pragma directive indicating the supported version of the Solidity
    compiler. (The code supports a compiler later than 0.4.0 but earlier than 0.5.0.)**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Defines a contract, which is similar to a class in other languages**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Defines a state variable as a “mapping” between an address and an
    integer. A state variable is the equivalent of a member variable. A mapping is
    equivalent to a hash table or hash map.**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Starts defining the contract constructor**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Assigns 10,000 SimpleCoin tokens to the coin account with address
    0x14723a09acff6d2a60dcdf7aa4aff308fddc160c at contract creation**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Defines a function that moves a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Decreases the coin balance of the message sender by the specified
    number of tokens. (The special implicit property msg.sender represents the address
    of the sender of the transaction.)**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Increases the coin balance by the specified number of tokens**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine this code in detail. A *contract* in Solidity is a type similar
    to a class in any other language: it has *state variables* (such as `coinBalance`),
    a constructor, functions (such as `transfer`), and events.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The `coinBalance` state variable is defined as a `mapping`. A *mapping* is a
    hash map, equivalent to a hashMap in Java, Dictionary in C#, or dict in Python.
    In this example, the type of the key is an `address`, whereas the value is a `uint256`—an
    unsigned 256-bit integer. An *address* holds a 20-byte value and can identify
    a specific smart contract account or a specific user account. An account, as you’ll
    see later in detail, is the sender or the receiver of a transaction. The `coinBalance`
    state variable therefore represents a collection of coin accounts, each holding
    a number of SimpleCoin tokens.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The `transfer` function is meant to move a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account. In smart
    contract terminology, a function caller is the *transaction sender*. `msg` is
    a special implicitly defined variable that represents the incoming message. It
    has various properties, among which `msg.sender` represents the address of the
    sender of the transaction, who is the caller of `transfer`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The body of the transfer function is simple to understand. It involves subtracting
    the specified amount from the cash account associated with the function caller
    and adding the amount specified in the `_amount` parameter to the account associated
    with the address specified in the `_to` parameter. To keep this initial code simple,
    this implementation isn’t performing any boundary checks yet on the number of
    SimpleCoin tokens owned by the transaction sender, who, for example, shouldn’t
    be allowed to send more tokens than they own. You’ll perform such checks when
    we revisit SimpleCoin in later chapters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand that your `SimpleCoin` contract is, in
    practice, a class with a constructor (`SimpleCoin` function), some state (`coinBalance`
    variable), and a method (`transfer` function). [Table 1.2](#ch01table02) gives
    a quick summary of the Solidity keywords you’ve come across.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.2\. A summary of Solidity keywords used in the first code sample
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Keyword | Explanation |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| contract | **Type similar to class in any other language** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| mapping | **Data structure similar to a hash table or hash map** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| address | 20-byte value representing an Ethereum user account or contract
    account |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| uint256 | **Unsigned 256-bit integer** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| msg | **Special variable representing an incoming message object** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| msg.sender | **Property of the msg object representing the address of the
    message sender** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: 1.3.2\. Running the contract
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Move now to the right side of the screen to deploy the `SimpleCoin` contract.
    First, make sure the Auto Compile option in the Compile tab is checked, as shown
    in [figure 1.11](#ch01fig11), so that Remix will recompile the code at every change.
    Also, make sure you’ve selected version 0.4.24 of the compiler (for example 0.4.24+commit.e67f0147),
    because this is the version I’ve been using when writing `SimpleCoin`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11\. The Auto Compile option in the Compile tab makes sure the code
    entered in the editor is recompiled at every change.
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-11_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'If you’ve typed your code correctly (I recommend you copy the code from the
    files provided on the book website!), and no compilation errors have occurred,
    you should see the following buttons in the Run tab: Deploy and At Address, as
    shown in [figure 1.12](#ch01fig12). Ignore At Address for now and focus your attention
    on Deploy. By clicking this button, you’ll deploy the `SimpleCoin` contract on
    an emulated blockchain within Remix.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12\. Once the code has been compiled correctly, the Run tab will show
    two buttons: Deploy and At Address. You can instantiate the contract by clicking
    Deploy.'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-12_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: The contract will be stored against an address on the emulated Ethereum blockchain,
    and a new Deployed Contracts panel will appear, as shown in [figure 1.13](#ch01fig13).
    You can read the deployment address by clicking the Copy Address icon and pasting
    it in Notepad, for example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13\. After deploying the contract, the Deployed Contracts panel appears,
    containing a drop-down with a SimpleCoin option; click it, and you’ll see the
    contract operations.
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-13_alt.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 1.3.3\. Interacting with the contract
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that the `SimpleCoin` contract has been deployed, you’ll be able to perform
    simple operations against it: you’ll check SimpleCoin token balances and move
    tokens across accounts.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the SimpleCoin drop-down list within the Deployed Contracts panel. Two
    new buttons will appear: CoinBalance and Transfer, as shown in [figure 1.14](#ch01fig14).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14\. SimpleCoin operations buttons: CoinBalance and Transfer. CoinBalance
    is a getter of the coinBalance state variable and is a read-only operation. Transfer
    allows you to transfer the specified number of tokens to the indicated address.'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig01-14_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'The Remix IDE shows two types of buttons:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*Blue buttons*—They perform read operations against the contract, such as checking
    the value of state variables or calling read-only functions.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Red buttons*—They perform write operations against the contract, such as instantiating
    the contract through the constructor (Create), or call functions that modify any
    state variables.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, CoinBalance is blue because it allows you to read the coin balance
    associated with an address. Transfer is red because by clicking it you’ll alter
    the state of the contract, specifically by changing values contained in the `coinBalance`
    mapping state variable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now check that the `coinBalance` associated with the address specified in the
    constructor has the full initial supply of SimpleCoin you set at construction.
    Wrap the address with double quotes: `"0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C"`.
    Enter it in the text box and click CoinBalance. Some output will appear. At the
    bottom, you should see the expected number of SimpleCoin tokens you specified
    in the constructor: 10,000.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is the address of one of the five
    test accounts present on the Remix IDE. You can see them in the Transaction Origin
    drop-down list box on the top-right of the screen. Although they aren’t fully
    visible on the screen, their full addresses are reported in [table 1.3](#ch01table03).
    (I’ve retrieved them one by one by clicking the Copy Address icon next to the
    Account drop-down.)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.3\. Remix test accounts whose full address is hidden behind the HTML
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: 'You can double-check that the amount of SimpleCoin tokens associated with any
    address different from `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is zero. For
    instance, enter the following address, wrapped with double quotes as you did earlier,
    in the CoinBalance text box: `"0x583031D1113aD414F02576BD6afaBfb302140225"`. After
    clicking the button, you’ll see a zero, as expected.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: To recap, when you instantiated the contract, an amount of 10,000 SimpleCoin
    tokens got assigned as initial money supply to the address starting with `0x14723A09`.
    No other address owns any tokens yet, as summarized in [table 1.4](#ch01table04).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.4\. Balance of each Remix test account after contract instantiation
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **10,000** |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **0** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: 'Now you’ll call the `transfer` function to move some tokens from the account
    with the address starting with `0x14723a09` to a different test account. Because
    the transfer function moves tokens from the account of its caller, the function
    must be called from the contract creator’s address starting with `0x14723a09`.
    Pick this address from the Account drop-down at the top right of the Run tab,
    then enter in the text box of the transfer method the destination address—for
    example, the address starting with `0x4b0897b0`—and a number of tokens to be transferred—for
    instance, 150 tokens. You should separate the values of these parameters with
    a comma:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now click Transfer. The function returns no result, as expected.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Check the number of tokens present in the contract creator’s address by clicking
    CoinBalance after entering the contract creator’s address (`"0x14723A09AC-ff6-D2-A60Dcd-F7aA4AFf308FDDC160C"`)
    in the related text box. The value is now 9,850, as expected.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: If you perform the same check on the destination address (`"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB"`),
    you’ll get 150\. All other addresses still have zero tokens, as summarized in
    [table 1.5](#ch01table05).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.5\. Balance of each Remix test account after a transfer operation
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **9,850** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **150** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: As an exercise, you can try to transfer coins from the address starting with
    `0x4b0897b05` to a different address and recheck if the amounts are correct. While
    doing so, please don’t perform any crazy transactions yet, such as trying to move
    more coins than a certain address is holding. To keep the code simple for the
    moment, you haven’t coded any boundary conditions to handle such situations. You’ll
    learn about these in the next chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Although the code you’ve written so far is simple, your main objective at this
    stage was only to start to familiarize yourself with smart contracts, the Solidity
    language, and Remix. By now, you should have achieved that objective, and you
    should understand how contract instantiation works and how to interact with a
    contract from different accounts.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: SimpleCoin is still at the stage of an embryonic Dapp. So far, you’ve only executed
    its code on a JavaScript VM-based simulator and, because it’s lacking a UI, you’ve
    seen its output through Remix. In the next chapter, you’ll take a step further
    and install an Ethereum client. You’ll then deploy SimpleCoin to a real Ethereum
    network and interact with it again.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the compiler configured in the Compile tab is version 0.4.25, Remix will
    only allow you to enter addresses with a valid checksum in the code editor. I’ll
    explain what a valid checksum is in [chapter 5](kindle_split_017.xhtml#ch05).
    But for now, it means `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c` (all in lowercase)
    and `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` aren’t interpreted as being equivalent
    to each other. Unfortunately, addresses in the Account drop-down within the Run
    tab are all in lowercase and therefore aren’t compliant. If you want to know the
    corresponding address with a valid checksum, you can use Etherscan, the online
    blockchain viewer ([https://etherscan.io/](https://etherscan.io/)). Enter the
    incorrectly formatted address (for example, `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c)`
    in the text box at the top of the screen, and you’ll see the correctly formatted
    corresponding address (`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`) in the Address
    header also at the top of the screen.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A decentralized application is a novel type of application that isn’t owned
    or controlled by any entity and runs on a trustless decentralized P2P network.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topology of a decentralized application is different from that of a conventional,
    centralized, one because both its business logic layer and its data layer (the
    blockchain) are fully replicated on each node of the network.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapps rely on blockchain technology, which is based, in turn, on public key
    cryptography, cryptographic hash functions, and the concept of mining through
    a consensus protocol.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many appropriate use cases exist for decentralizing an application, especially
    in the fields of provenance and authenticity tracking, identity verification,
    regulatory auditing, prediction markets, and crowdfunding.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized applications aren’t always the best solution for a business problem.
    For example, it doesn’t make sense to decentralize an internal enterprise application
    that isn’t shared with any external participant.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement smart contracts, which are at the heart of Dapps, within the
    Ethereum platform in a language called Solidity, similar to JavaScript. It’s possible
    to write simple smart contracts through the Remix Solidity IDE and simulate their
    activation and interaction with various mock Ethereum accounts.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 2\. Understanding the blockchain
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Low-level details of an Ethereum node
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technology stack you use to build Ethereum Dapps
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technologies underlying the Ethereum blockchain
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum’s history and governance
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: I intended [chapter 1](kindle_split_012.xhtml#ch01) to give you a high-level
    overview of decentralized applications without overwhelming you with too many
    details. Consequently, I’m sure you’re still wondering what technical stack you
    need to learn to build a full Dapp. Also, you might feel the architectural presentation
    on Dapps didn’t go as far as you’d have liked, and you might still have doubts
    about how a blockchain exactly works. If you’re asking yourself these questions,
    I’ll address them in this chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start by revisiting the voting Dapp I introduced in the previous chapter,
    and I’ll cover some aspects of an Ethereum node I skipped earlier for simplicity.
    I’ll then cover the entire technology stack required to implement a full end-to-end
    decentralized application. Additionally, I’ll introduce the cryptographic concepts
    and foundations you need to acquire to appreciate how a blockchain works. Before
    closing the chapter, I’ll present technologies specific to the Ethereum blockchain
    and give you some information on Ethereum’s history and governance.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. A deeper look at decentralized applications
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I presented the structural and transactional views of a decentralized application
    in [chapter 1](kindle_split_012.xhtml#ch01), I decided to keep them at a relatively
    high level. I’m aware blockchain technology might be completely new to you, so
    I wanted to make sure you understood the high-level architecture and the purpose
    of decentralized applications without confusing you with too much jargon and too
    many technologies. Now that you’ve acquired a solid foundation, it’s time to have
    a deeper look at Ethereum Dapps. Let’s start by stepping into an Ethereum node.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1\. Inside an Ethereum node
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As shown in [figure 2.1](#ch02fig01), each node of the Ethereum P2P network
    contains two main components:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '*An Ethereum client*—This acts as a runtime and contains four elements:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine called *Ethereum Virtual Machine (EVM)*, capable of executing
    smart contract code generally written in a language called Solidity and compiled
    into EVM bytecode.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.1\. An Ethereum node includes an Ethereum client and a blockchain
    database. The client contains a client process, an Ethereum Virtual Machine, a
    memory pool, and a JSON-RPC API exposing the functionality of the node externally.
    There are two types of nodes: full nodes and mining nodes.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-01_alt.jpg)'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: A *memory pool*, where the node stores transactions that it receives, such as
    a vote submitted by a voter from the client side, before it propagates them further
    into the network.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *client process*, which coordinates the processing. It handles incoming messages
    and transactions, dispatches them to the EVM when appropriate, and stores transactions
    to, and retrieves them from, the memory pool. The client process also handles
    incoming blockchain blocks that the node receives from peer nodes and appends
    them to the local copy of the blockchain database.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *JSON-RPC API*, which exposes the functionality of the client to other nodes
    and external users.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A blockchain database*—Apart from transaction data, such as votes submitted
    by voters, the blockchain also keeps a copy of the EVM bytecode of all smart contracts
    deployed on the network and holds their state. Mining nodes append new blocks
    to the blockchain regularly, every 15 seconds.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.2\. Revisiting the lifecycle of a transaction
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know an Ethereum node hosts a JSON-RPC interface, an EVM, and a
    memory pool, I can explain to you, with the help of some diagrams ([figures 2.2](#ch02fig02)
    to [2.4](#ch02fig04)), what role they play during the transaction lifecycle.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2\. The lifecycle of a transaction. A voting transaction is created
    when a function is invoked on a smart contract on a chosen Ethereum node through
    the JSON-RPC interface. The node places the transaction in the memory pool and
    executes it on the EVM for validation. If the validation is successful, the transaction
    is broadcast to peer nodes until it reaches a mining node; otherwise, it dies
    out.
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-02_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: A transaction is generated when a function is invoked on a smart contract of
    the chosen Ethereum node through the JSON-RPC interface. (See [figure 2.2](#ch02fig02).)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: A full node receives the transaction from a peer node and places it in the memory
    pool. (See [figure 2.2](#ch02fig02).)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full node executes the transaction on the EVM for validation. (See [figure
    2.2](#ch02fig02).)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the validation is successful, the node broadcasts the transaction to its
    peer nodes. If the validation is unsuccessful, the node doesn’t propagate the
    transaction further, and it dies out.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mining node places the transaction received from a peer node in the memory
    pool. (See [figure 2.3](#ch02fig03).)
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mining node picks transactions deemed to be profitable from the memory pool,
    executes them on the EVM, and tries to add them onto a new block. (See [figure
    2.3](#ch02fig03).)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the block created is added successfully to the blockchain, the mining node
    removes the related transactions from the memory pool. (See [figure 2.3](#ch02fig03).)
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.3\. A mining node receives the transaction from a peer node and places
    it in its memory pool. The node later picks it and executes it on the EVM, among
    other transactions, to place it on a new block. If the block is appended on the
    blockchain, the transaction is removed from the memory pool and the block is broadcast
    to peer nodes.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-03_alt.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The node broadcasts the new block to peer nodes. (See [figure 2.3](#ch02fig03).)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A full node receives the new block from a peer node. (See [figure 2.4](#ch02fig04).)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full node executes all the block transactions on the EVM for validation.
    (See [figure 2.4](#ch02fig04).)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node removes all the associated transactions from its memory pool if the
    block has been validated successfully. (See [figure 2.4](#ch02fig04).)
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node broadcasts the block to peer nodes. (See [figure 2.4](#ch02fig04).)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.4\. The full node’s process, from when it receives the new block to
    when it processes all its transactions on the EVM for validation, then, if validation
    is successful, removes the related transactions from the memory pool and propagates
    the block further into the network
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-04_alt.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: '2.1.3\. Development view: Deploying the voting smart contract'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By now, you should have a good idea of both what a decentralized application
    looks like and how a transaction flows throughout the system. You might still
    be wondering, though, when and how a smart contract gets propagated throughout
    the network. It turns out that the server-side contract propagation process is
    similar to that of a standard transaction, such as the voting transaction analyzed
    in the previous chapter in [figure 1.8](kindle_split_012.xhtml#ch01fig08).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum smart contract, such as the voting smart contract of the voting
    Dapp, is code written in the Solidity language. A smart contract developer compiles
    the code into EVM bytecode and then deploys it across the P2P network through
    a contract deployment transaction, which executes on a local Ethereum node and
    then propagates throughout the network. During its propagation throughout the
    network, a mining node processes the deployment transaction and stores its EVM
    bytecode on the blockchain, as illustrated in [figure 2.5](#ch02fig05).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5\. A developer writes the voting smart contract in the Solidity language,
    then compiles it into EVM bytecode and inserts it into a contract deployment transaction.
    This is pushed to the local Ethereum node and propagated throughout the network.
    It’s then mined and appended to the blockchain.
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-05_alt.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: You might have noticed, while going through the static, dynamic, and development
    views of a Dapp, in these two initial chapters, that I’ve mentioned languages
    and Java-Script libraries that might be unfamiliar to you. You shouldn’t be particularly
    worried about the amount of technology you’ll have to learn. You can implement
    a Dapp based on the Ethereum blockchain with languages much like those used in
    centralized apps you’re already familiar with. The client side of a Dapp is generally
    based on standard HTML5 + JavaScript; the communication layer between the UI and
    the server side is based on a JavaScript library called Web3 that’s executed on
    the client side; and you can implement server-side smart contracts in Solidity,
    which is a flavor of JavaScript.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Your journey through this book will continue, as shown in [figure 2.6](#ch02fig06),
    from the server side, which is the core of decentralized applications, and you’ll
    write smart contracts in Solidity. Then you’ll learn how to interact with a smart
    contract remotely through the Web3.js JavaScript library. Finally, you’ll implement
    a web-based UI, built on HTML and JavaScript.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6\. You’ll progress from writing smart contracts in Solidity, to interacting
    with smart contracts remotely through the Web3.js Java-Script library, to building
    a web UI in HTML and JavaScript.
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-06_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: In summary, with some knowledge of JavaScript, or any C-like language, it isn’t
    difficult to transition from centralized to decentralized application development.
    But during that transition, it’s important to fully understand the technologies
    underlying decentralized applications, because they’re rather different from the
    technologies that centralized applications are built on. We’ll explore that in
    the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. What technologies make Dapps viable?
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you know, a Dapp is based on business logic encapsulated into smart contracts
    that are executed against a distributed database called blockchain. Blockchain
    technology is based, in turn, on public key cryptography, cryptographic hash functions,
    and the concept of consensus, which you can implement using *proof of work* and
    *proof of stake* algorithms, among other ways.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: You might be feeling like I keep opening more and more Russian dolls, and this
    might never end, but please don’t get frustrated! Cryptography is the lowest level
    I’m going to cover, I promise.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1\. Blockchain technologies
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next several sections, I’ll explain briefly all the cryptographic terms
    I’ve just mentioned so you can form a mental model of how a blockchain database
    works before we proceed further. Public key cryptography is the lowest technological
    block underlying the blockchain, so let’s start from there.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Public key cryptography* is an encryption methodology based on a pair of keys:
    a *private key*, usually generated randomly, which is known only to its owner,
    and a *public key*, known to everyone, generated from an algorithm that takes
    the private key as an input. [Figure 2.7](#ch02fig07) illustrates how private
    and public keys are generated.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7\. A private key is generated with a random number generator. It’s
    then fed to an algorithm that generates a public key.
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-07_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: To better visualize it, think of the private key as the physical key of your
    mailbox (only you have a copy of it) and the public key as your postal address
    (everyone knows it), as shown in [figure 2.8](#ch02fig08).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8\. To understand the purpose of private and public keys, you can think
    of the public key as your postal address, known by everybody, and the private
    key as the key to your mailbox, only owned by you.
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-08_alt.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: 'The private key has two main purposes, as illustrated in [figure 2.9](#ch02fig09):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: It allows the decryption of data that has been encrypted using the public key.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows someone to digitally sign a document. They can produce the signature
    only if they know the private key, but anyone who knows the public key can verify
    the signature. As you’ll see, the authenticity of smart contract transactions
    relies on digital signatures.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2.9\. You can use a private key to decrypt a document that has been encrypted
    with the related public key, as you can see in the top diagram. As shown in the
    bottom diagram, a private key also allows someone to sign a document digitally
    to prove provenance. The generated digital signature can then be verified against
    the document and the related public key.
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-09_alt.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: In the context of a blockchain platform, cryptocurrency is generally stored
    against an account that is identified by a public key but can be operated only
    if you know the private key. If the private key is forgotten or lost, no one can
    use the account anymore, and its funds are considered lost.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash functions
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *hash function* is any function that can map data of arbitrary size to data
    of fixed size. The fixed size data is called hash or digest. To give an example,
    you can design a hash function so that it always generates a 64-bit hash from
    a file or string of any size. Whether its size is 10 KB or 10 GB, a 64-bit hash
    will be generated, as illustrated in [figure 2.10](#ch02fig10).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10\. A hash function produces a hash of a fixed size (64 bits in this
    example) given an input of any size.
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-10_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: 'A *cryptographic hash function* is a hash function that has five additional
    properties:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s deterministic*. The same input will always generate the same hash.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It’s quick to compute*.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It’s a one-way function, unfeasible to invert*. This means that the only way
    to deduce the original data from its hash would be to try, by brute force, to
    obtain the same hash by applying the function to an enormous number of input data
    sets.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It should be almost impossible to obtain the same hash from two different
    sets of input data*. Although a small chance exists that two inputs might produce
    the same hash, it’s impossible to determine them a priori, without applying the
    function to an enormous number of inputs, as suggested in the previous point.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A slight change in the input data should produce substantially different hash
    values*. Consequently, also because of what I said in the previous point, unless
    you’re applying the cryptographic hash function to the same input, you won’t be
    able to *intentionally* get the same hash or even a close one.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given these properties, think about the following scenario. Imagine you’re writing
    a check for $30 to pay for the latest blockchain book from your local bookstore.
    I know, checks are almost no longer used and, if you’re a young reader, you might
    never have seen one! Please bear with me for a moment.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: You filled out and signed the check, and you’re on your way to the bookstore,
    when, while on your mobile phone chat app, you trip over a curb. You don’t realize
    the check falls on the road and a gust of wind takes it away. You’re so unlucky
    that it ends up in the hands of Jack Forger, a local petty criminal. He knows
    how to remove ink, and he quickly replaces the amount and recipient as shown in
    [figure 2.11](#ch02fig11).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11\. A physical check forged by reusing the original signature and
    altering the recipient and amount
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-11_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Jack then goes to a bank and successfully cashes the check for $30,000\. The
    criminal had your handwritten signature and was able to replace the name of the
    recipient and the amount. Let’s see how a digital signature on an electronic check
    would avoid this unpleasant situation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The digital signature on an electronic check would be a cryptographic hash produced
    using as the input the details of your check, the amount you’re paying, and the
    recipient, together with a private key associated with your bank account (the
    equivalent of your handwritten signature), as illustrated in [figure 2.12](#ch02fig12).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12\. An e-check can be secured with a digital signature generated with
    the private key associated with the sending bank account and the details of the
    check. It can be verified by checking the digital signature against the public
    key associated with the sender bank account and the check details.
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-12_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: When someone presents this kind of electronic check to a bank, together with
    the public key associated with your bank account, the bank can verify that the
    digital signature matches the details of the check (amount and recipient) and
    has been produced using your private key. That’s how the bookstore owner will
    be able to cash your check.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the digital signature is a cryptographic hash, that exact signature
    can only be produced from the specific details you used when filing the electronic
    check. If someone tried to hijack the electronic check—let’s say a group of skilled
    hackers—changing the amount and, most importantly, the recipient would be pointless
    for two reasons:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: A new amount or recipient would generate a completely different digital signature,
    so the bank wouldn’t recognize the current one as valid, as shown in [figure 2.13](#ch02fig13).
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hackers attempted to generate a new digital signature with new check
    details, they couldn’t generate one that could be associated with the public key
    of your bank account because they don’t know your private key.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.13\. An attempt at forging an e-check secured by a digital signature
    is unsuccessful because the new original digital signature doesn’t match the altered
    check details.
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-13_alt.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: 'Blockchain transactions are much like the electronic check described here:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: They originate from an account identified by a public key.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They contain transaction details, such as an amount of cryptocurrency and the
    recipient, also identified by a public key.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They carry a digital signature proving the transaction details have been entered
    by the owner of the sender account through their private key.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain transactions don’t have to carry cryptocurrency; they can carry any
    data. The crucial point is that by carrying a digital signature, they can prove
    they’ve been genuinely sent by the sender.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash functions aren’t only useful for digital signatures. If you’re
    interested in finding out more, read in the sidebar how you can use them to protect
    a seller from malicious buyers.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '**Protecting a seller from malicious buyers with a commit-reveal scheme**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptographic hash functions can be handy in various situations. Do you remember
    the decentralized e-commerce application I described at the beginning of [chapter
    1](kindle_split_012.xhtml#ch01)? If you’re reading this book with the mindset
    of a seller, you might have found the solution not as convincing as when seen
    through the eyes of a buyer. For example, there seems to be nothing, in the solution
    presented, preventing the user from accepting the goods and then not authorizing
    the payment to the seller. That’s disappointing! Don''t despair: cryptographic
    hash functions to the rescue!'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: You could make the application more secure for sellers if you required the buyer
    to generate a secret code, for instance a secret phrase or a random number, and
    then supply its cryptographic hash to the seller during the confirmation of the
    order. You could view this hash as a sort of keylock for the payment. When delivery
    comes, the courier would hand the goods over only upon receipt of the secret code,
    which, when supplied to the e-commerce Dapp, would generate the expected initial
    hash code and, as a physical key into its associated keylock, would unlock the
    payment.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of initially providing a hash of the original information and then
    revealing the full information in a second stage is called a *commitment scheme*
    or *commit-reveal scheme*, and it has two phases:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The commit phase, during which a cryptographic hash of the original information
    produced with a disclosed algorithm is committed to the other party
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reveal phase, during which the full information is revealed, and it’s verified
    against the committed hash to prove the revealed information is indeed associated
    with the hash
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This powerful idea of proving the knowledge of some information without revealing
    the information itself had already been used in the 16th century by Galileo, who
    initially published his discovery of the phases of Venus in an anagram of the
    original paper, before finalizing his research. Hooke and Newton later used a
    similar technique to conceal the details of their discoveries, while at the same
    time being able to claim they were the first to make such discoveries.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, you’ll see how this idea is used to secure decentralized
    applications.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: Congratulations, you’ve completed the Cryptography 101 course! I hope it wasn’t
    too painful. You now have the necessary tools to understand how a blockchain works.
    Now we’ll enter the blockchain.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A blockchain is a distributed database that holds records called blocks. [Figure
    2.14](#ch02fig14) illustrates the structure of a typical blockchain.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14\. A blockchain is a sequence of blocks, each containing a sequence
    number, a timestamp, and a list of transactions, each individually digitally signed.
    Each block also references the cryptographic hash of the previous block.
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-14_alt.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: A block includes a list of transactions, which are digitally signed to prove
    their provenance. Most blockchains digitally sign transactions with an *elliptic
    curve digital signature algorithm* (ECDSA), based on elliptic-curve cryptography,
    rather than a traditional digital signature algorithm (DSA), because ECDSA is
    harder to break and uses smaller keys to guarantee the same level of security.
    Each block contains a timestamp and a link to a previous block based on its cryptographic
    hash. It also contains a cryptographic hash summarizing the full content of the
    block, including the hash of the previous block. In this way, the blockchain holds
    both the current state (the latest block) and the full history of all the transactions
    that have been stored on it since its inception.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: This structure guarantees transactions can’t be tampered with or modified. A
    transaction recorded in a block can’t be altered retroactively because to modify
    it, the hash of the block containing it would have to be regenerated, and this
    wouldn’t match the existing one already referenced by subsequent blocks, as shown
    in [figure 2.15](#ch02fig15).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15\. An attempt at altering the contents of a block, for example its
    transactions, won’t be successful: the new hash generated from the altered block
    details won’t match the original block’s hash already directly referenced in the
    next block and indirectly referenced in the subsequent blocks.'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-15_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If two transactions contradict each other—for instance, each of them tries to
    transfer all the funds of the same account to a different destination account
    (known as a “double-spend attack”)—miners will execute only the first one, recognized
    in the Ethereum network through a globally accessible sequence number. They will
    reject the second one, and it will never appear on a consolidated block. Satoshi
    Nakamoto of Bitcoin was the first to solve the double-spend problem. Every blockchain
    has a solution for it; otherwise, it wouldn’t be viable.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: The blockchain structure I’ve described is, in fact, a simplified version of
    real-world blockchain data structures such as the Merkle tree used by Bitcoin
    or the Patricia tree used in Ethereum. A blockchain is managed autonomously through
    a P2P network that facilitates fault tolerance and decentralized consensus by
    processing all transactions independently on each node. Given these characteristics,
    blockchains are particularly suitable for recording permanently the history of
    events. This is useful for identity management, transaction processing, and provenance
    tracking, to name a few use cases.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To encourage the P2P network supporting the blockchain to process its transactions
    continuously, active processing nodes, also called *mining nodes* or *miners*,
    are rewarded for the computational resources provided, and indirectly to cover
    the associated electricity costs, through the *consensus* mechanism. Every few
    seconds, one successful miner is entitled to generate and keep a certain number
    of tokens of the cryptocurrency supported by the platform. Such cryptocurrency
    has economic value, as it can be used to purchase services on the network, but
    it also can be exchanged for conventional currencies, such as dollars, yen, euros,
    and so forth. In the case of the Bitcoin blockchain, they’ll be given several
    Bitcoin tokens, worth around $2,000 each at the time of writing. The tokens given
    by the Ethereum blockchain are called Ether, and they’re worth around $200 each
    at the time of writing. Let’s now look at how the consensus mechanism works.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consensus is, as I mentioned earlier, the mechanism by which participant nodes
    of the network agree on the outcome of a transaction. In the consensus definition
    I presented at the beginning of [chapter 1](kindle_split_012.xhtml#ch01), I also
    emphasized that consensus is distributed, because it’s determined by many participants,
    and trustless, because the participants don’t need to trust each other. In fact,
    consensus isn’t reached on individual transactions but on new blockchain blocks.
    Each participant verifies independently that a new block is valid and, if satisfied,
    propagates it further to the rest of the network.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: What happens in practice is that if most participants have accepted the block
    as valid and it has propagated successfully throughout the network, miners will
    use such a block as the latest valid block, and the rest of the blockchain will
    be built on it. If a malicious miner appended an incorrect block to the blockchain
    and it propagated to its peer nodes, these nodes would reject the new block, and
    the malicious chain would die out immediately. The same would happen if a full
    node tried to modify a block before propagating it to its peers.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the key step of the consensus mechanism is the verification
    of the latest block by a participant node. After verifying the digital signature
    of the individual transactions present on a block, a participant node verifies
    that the hash of the block is valid. Such hash is produced by miners according
    to an agreed protocol. The earlier versions of Ethereum used an algorithm called
    *Ethash*, based on a Proof of Work protocol. Future versions will be based on
    a Full of Stake protocol called *Casper*. I’ll explain both protocols.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Work
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you saw earlier, a block contains a cryptographic hash summarizing the full
    content of the block, including its metadata and transactions data, and an additional
    piece of data of a fixed length, such as 32 bits, called *nonce*. The objective
    of the Proof of Work (PoW) protocol is that miners must find a nonce such that
    the hash generated fits a certain constraint, for instance, having many leading
    zeros. Constraining a 64-bit unsigned integer hash to have 13 leading zeros when
    represented in hexadecimal format, as in the example of [figure 2.16](#ch02fig16),
    reduces the number of valid hashes from the theoretical maximum number of 18,446,744,073,709,551,615
    to 4,095.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16\. Proof of Work: generation of an unsuccessful and a successful
    block hash'
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-16_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: Because of the properties of hash functions you saw earlier, the only way a
    miner can find such a nonce is by trying many possible values until the constraint
    on the hash has been met. In the example I just gave, every such attempt will
    only have a roughly 0.00000000000002% chance of being successful. When a satisfactory
    hash has been found, the miner is entitled to append the new block being processed
    to the blockchain and claim the token reward. As you can understand, this way
    of producing a valid hash is CPU-intensive, energy-consuming, and, consequently,
    economically expensive. The main reason for such an expensive algorithm is to
    dissuade malicious participants from appending new incorrect blocks or modifying
    preexisting blocks and making them look like genuine blocks. The amount of energy
    (and money) necessary to perform such actions would make them unviable. In the
    sidebar in [section 3.3.4](kindle_split_014.xhtml#ch03lev2sec11), I’ll give you
    an idea of the hardware most miners use.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Proof of Work, which the Bitcoin network also uses, has been widely criticized
    for the immense amount of energy consumed (or rather, wasted?) by the competing
    miners. It has been estimated that the Bitcoin network alone will consume as much
    electricity as Bulgaria by 2020.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: To tackle this problem, Vitalik Buterin, one of the Ethereum founders, has proposed
    an alternative approach based on a Proof of Stake. This is based on a pool of
    *validators* that vote on the validity of new blockchain blocks. To join the validator
    pool, which is open to anyone, a node must commit an Ether deposit that will be
    held until the node leaves the pool. Votes expressed by each node are weighted
    on the amount of the deposit committed (which equates to the stake of a node in
    the pool). Under this scheme, a validator profits from transaction fees that the
    transaction senders pay. If a validator cheats, the associated Ether deposit is
    deleted from the network and the owner is banned from rejoining, which acts as
    a deterrent against manipulation.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now covered all the general cryptographic techniques underlying blockchain
    databases. If you’d like to learn more about the subject, I encourage you to read
    *Grok-king Bitcoin* by Kalle Rosenbaum) (Manning, 2019). Let’s now examine more
    recent technologies that have simplified Dapp development.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The Merkle tree and Merkle root
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The blockchain structure I’ve shown in the previous diagrams is a simplified
    representation of a real one. Generally, a miner places in the block two parts:
    a *header* and a *body*, as shown in [figure 2.17](#ch02fig17). The body contains
    all the transactions included in the block. The header contains the block metadata
    you saw earlier, such as the block number, timestamp, previous block hash, and
    PoW nonce. It also contains the *Merkle root* of the *transactions Merkle tree*
    that the miner calculates.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17\. The structure of a block, including a header containing metadata,
    such as the block number, timestamp, previous block hash, and Merkle root of the
    transactions Merkle tree, and a body containing the transactions collection
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-17_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'The transactions Merkle tree, as shown in [figure 2.18](#ch02fig18), is a tree
    structure built as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The block’s transactions are placed at the bottom of the tree, arranged in pairs.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each transaction is hashed, and each of these hashes becomes a leaf of the Merkle
    tree.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash is calculated for each pair of contiguous hashes.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hashing of contiguous hashes is repeated until only two hashes remain. The
    hash of these two final hashes is the *Merkle root*.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.18\. A Merkle tree. Individual transactions are located at the bottom;
    the tree’s leaves are the hashes of the individual transactions; and the next
    row up is made of the hashes of the tree’s leaves. The top row, which is the hash
    of the hashes below, ends the tree: this is the Merkle root.'
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-18_alt.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: The Merkle root is therefore a single hash summarizing all of the transactions
    contained in the block in a way that guarantees their integrity. The advantage
    of having the Merkle root on the block header is that a client can synchronize
    the blockchain in a faster way by retrieving the block headers, rather than the
    entire transaction history, from the network peers. This is generally called *light
    synchronization*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2\. Ethereum technologies
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although smart contracts can be implemented, with some difficulty, on early
    blockchain systems such as Bitcoin, they can be more easily written and executed
    on later blockchain platforms, such as Hyperledger, Nxt, and Ethereum, that have
    been designed with the main purpose of simplifying their development. For this
    reason, later blockchain platforms are considered part of the so-called *smart
    blockchain* or *blockchain 2.0* wave. Let’s now examine briefly the main innovations
    that Ethereum has introduced: an improved blockchain design, the EVM, and smart
    contracts.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the previous section, you learned about the blockchain and a more efficient
    structure that allows quicker client synchronization based on a block header containing
    a block’s metadata and a body containing the transactions. The Ethereum blockchain
    improves the design further. First of all, transactions are hashed in a more compact
    and efficient (yet still cryptographically authenticated) structure called a *Merkle-Patricia
    trie* (see sidebar for more details). Secondly, the block header (generated as
    usual by the miner) also contains, in addition to the Merkle-Patricia root of
    the transactions, the Merkle-Patricia root of the receipts, which are the transaction
    outputs, and the Merkle-Patricia root of the current blockchain state, as shown
    in [figure 2.19](#ch02fig19).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19\. An Ethereum improved block header. The header of a block of the
    Ethereum blockchain contains the root of the transactions Merkle- Patricia trie,
    which is a more compact and efficient structure than a Merkle tree. In addition,
    it contains the Merkle-Patricia root of receipts (which are the transactions effects)
    and the blockchain state.
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-19_alt.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: 'As Vitalik Buterin explained in his blog post “Merkling in Ethereum,”^([[1](#ch02fn01)])
    with these three Merkle-Patricia tries, a client can efficiently check, in a verifiable
    way, the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Merkling in Ethereum,” Ethereum Blog, November 15, 2015,
    [http://mng.bz/QQYe](http://mng.bz/QQYe).
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether a certain transaction is included in a certain block
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the output of a transaction would be
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether an account exists
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the balance of an account is
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '**The Merkle-Patricia trie**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: A *trie*^([[2](#ch02fn02)]) (or *prefix* *tree*) is an ordered data structure
    you use to store a dynamic set, where the keys are usually strings. The root of
    a trie is an empty string, and then all the descendants of a node have the common
    prefix of the string associated with that node, as you can see in the figure.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: ²
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the “Trie” Wikipedia page at [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    for more information on this data structure.
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/f0053-01.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
- en: 'Trie structure (Credit: Booyabazooka (based on a PNG image by Deco). Modifications
    by Superm401\. - own work (based on PNG image by Deco))'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: The Merkle-Patricia trie is a data structure that combines a trie and Merkle
    tree. It improves the efficiency of a Merkle tree (named after Ralph Merkle) by
    storing the node keys using the *PATRICIA* algorithm (*practical algorithm to
    retrieve information coded in alphanumeric*), designed by D. R. Morrison in 1968\.
    You can read about the Patricia algorithm on the Lloyd Allison Algorithm Repository.^([[3](#ch02fn03)])
    The Ethereum Merkle-Patricia trie is described in detail, with code examples,
    in the Ethereum wiki.^([[4](#ch02fn04)])
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: ³
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/](http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/).'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁴
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree).'
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: 'When a full node receives a new block, the transactions contained in the body
    are processed as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The transactions are arranged in a transaction Merkle-Patricia trie specific
    to the new block.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions are executed on the EVM. This action generates transaction receipts,
    which are arranged in a receipts Merkle-Patricia trie specific to the new block.
    It also alters the global state trie, of which only one instance exists on each
    node.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the roots of the new transaction trie, receipt trie, and modified state
    trie match those in the header, the block is considered validated. Then the new
    and altered tries are stored on the full node in a respective key-value store
    based on LevelDB, an open source NoSQL database developed by Google. Note the
    following in [figure 2.20](#ch02fig20):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The *transaction store* contains a transaction trie per block, and each trie
    is immutable. The key of this store is the transaction hash (keccak 256-bit hash).
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *receipts store* contains a transaction trie per block, and each trie is
    immutable. The key of this store is the hash of the receipts of a transaction
    (keccak 256-bit hash).
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *state store* contains a single *state trie* that represents the latest
    global state and is updated each time a new block is appended to the blockchain.
    The state trie is account-centric, so the key of this store is the account address
    (160 bytes).
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2.20\. Detailed block processing in an Ethereum node. When a full node
    receives a new block, it separates the header and the body. It then creates a
    local transactions trie and a local receipts trie and updates the existing state
    trie. The new and updated tries are then committed in the respective stores.
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig02-20_alt.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
- en: 'A major benefit of the Ethereum blockchain design is that it allows three types
    of synchronization:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '*Full*—Your client downloads the entire blockchain and validates all blocks
    locally. This is the slowest option, but you’d be confident of the integrity of
    the local blockchain copy.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fast*—Your client downloads the entire blockchain, but validates only the
    64 blocks prior to the start of the synchronization and the new ones.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Light*—Your client retrieves the current state trie of the blockchain from
    a peer full node and stores it locally. It doesn’t retrieve any historic blocks
    from peers, and it receives only the new ones, so you don’t have to wait long.
    This will allow you to get up and running quickly.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although in this section I’ve covered the physical design of the Ethereum blockchain
    in some detail because it’s important you understand how transactions and state
    are maintained, in the rest of the book I’ll use simplified logical diagrams in
    which I’ll represent a block as a collection of transactions.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
- en: Ethereum Virtual Machine
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *Ethereum Virtual Machine (EVM)* is similar in purpose to the Java Virtual
    Machine (JVM) or the .NET Common Language Runtime (CLR). It runs on each node
    of the Ethereum P2P network. It’s Turing complete, which means it can run code
    of any complexity. It can access blockchain data, both in read and write mode.
    The EVM executes code only after its digital signature has been verified and constraints
    based on the current state of the blockchain are satisfied.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *smart contract,* or simply *contract*, encapsulates the logic of a decentralized
    application. As I mentioned earlier, an Ethereum smart contract is written in
    a high-level language, such as Solidity or Serpent, and is compiled into EVM bytecode.
    It gets deployed on each node of the P2P network and is executed on the EVM.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Next generation blockchain
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thanks to the EVM, Ethereum is a *programmable blockchain*. Therefore, you can
    develop any type of decentralized application on it, not only cryptocurrencies,
    as was the case for earlier blockchains. Because of this programmability, Ethereum
    is considered a generalized or next generation blockchain. Some go as far as thinking
    smart blockchain platforms will be the foundation of a new generation of the internet,
    a Web 3.0 (although this exact version of the web is also used by the “semantic
    web” community), which will be characterized by more empowered users.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Ethereum’s history and governance
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before closing the chapter, I’d like to share how Ethereum was created and how
    it evolved after the initial release. In the next few chapters, you’ll start using
    several components of the Ethereum platform. Before you do so, it’s important
    you understand how these components came about and what the process is for proposing
    and agreeing on changes. You’ll realize decentralization isn’t only a technical
    aspect of Ethereum; it’s almost a philosophy that also permeates its governance.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1\. Who created Ethereum?
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ethereum is the brainchild of Vitalik Buterin, an early follower of bitcoin
    and cryptocurrency technology since 2011, when he also cofounded Bitcoin magazine.
    After researching the possibility of generalizing blockchain technology for building
    any application, in November 2013 he wrote the *Ethereum White Paper* ([https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)),
    in which he laid out the design of the Ethereum protocol, together with the first
    details of the smart contract infrastructure. Among the first people who engaged
    with Vitalik’s vision were Gavin Wood, who contributed to the shaping of the protocol
    and became the lead developer of the C++ client, and Jeffrey Wilcke, who became
    the lead developer of the Go client. After only a few months of work, in January
    2014, Vitalik announced the Ethereum initiative on bitcointalk^([[5](#ch02fn05)])
    and received considerable response. Soon afterwards, in April 2014, Gavin wrote
    the *Ethereum Yellow Paper*,^([[6](#ch02fn06)]) which specifies the design of
    the Ethereum virtual machine. To accelerate the development of the platform, in
    July 2014 Ethereum raised around $18.4M through an Ether crowdsale, which was
    legally backed by the Ethereum Foundation, set up in Switzerland only one month
    earlier with the mission to do the following (quoting the official website at
    [https://www.ethereum.org/foundation](https://www.ethereum.org/foundation)):'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: ⁵
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Welcome to the Beginning,” [https://bitcointalk.org/index.php?topic=428589.0](https://bitcointalk.org/index.php?topic=428589.0).
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁶
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “About the Ethereum Foundation,” [https://github.com/ethereum/yellowpaper](https://github.com/ethereum/yellowpaper).
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...promote and support Ethereum platform and base layer research, development
    and education to bring decentralized protocols and tools to the world that empower
    developers to produce next generation decentralized applications (Dapps), and
    together build a more globally accessible, more free and more trustworthy Internet.'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Table 2.1](#ch02table01) summarizes Ethereum’s timeline since its inception
    to the time of writing of this book.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1\. Ethereum timeline from inception to summer 2018
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Sep 2011 | Vitalik Buterin cofounds Bitcoin magazine with Mihai Alisie. |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
- en: '| Nov 2013 | Vitalik publishes the Ethereum White Paper, presenting the design
    of the Ethereum protocol and the smart contract infrastructure. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
- en: '| Dec 2013 | Gavin Wood contacts Vitalik, and they start detailed design discussions.
    |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
- en: '| Jan 2014 | Vitalik makes the official Ethereum announcement on bitcointalk.
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
- en: '| Apr 2014 | Gavin wood publishes the Ethereum Yellow Paper, which specifies
    the Ethereum virtual machine (EVM). |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
- en: '| Jun 2014 | The Ethereum Foundation is set up in Switzerland. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
- en: '| Jul 2014 | Ethereum raises $18.4M through an Ether crowdsale. |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
- en: '| Aug 2014 | Vitalik Buterin, Gavin Wood, and Jeffrey Wilcke set up ETH DEV,
    a nonprofit organization focused on the development of the core Ethereum protocol
    and infrastructure, which managed the development of various proofs of concept
    throughout 2014. |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
- en: '| Nov 2014 | ETH DEV organizes DEVCON-0, the first Ethereum developer conference,
    in Berlin, where the entire Ethereum project team meets for the first time. |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
- en: '| Jan 2015 | The Go Ethereum team meets in Amsterdam, where Whisper Dapp and
    Mist prototypes are presented. |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
- en: '| Jul 2015 | Mainnet release 1.0, codenamed Frontier, and the stable beta of
    Ethereum Wallet are released. |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: '| Nov 2015 | In London, 400 people attend DEVCON-1, where more than 80 talks
    on each part of the Ethereum ecosystem are given. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| Mar 2016 | The project releases Mainnet release 2.0, codenamed Homestead.
    |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '| Jul 2016 | An unplanned Ethereum fork occurs following a DAO attack, and
    a split takes place between Ethereum and Ethereum Classic. (See the sidebar.)
    |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| Oct 2017 | The project releases Mainnet release 3.0, codenamed Byzantium.
    |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| Jun 2018 | The project releases the Proof of Stake (PoS) Testnet release,
    codenamed Casper. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: 'If you’re interested in knowing more about the history of Ethereum, the official
    documentation has a page^([[7](#ch02fn07)]) dedicated to it. But you can get a
    firsthand and more engaging account of the main events that took place around
    Ethereum’s creation in the blog posts “Cut and Try: Building a Dream,”^([[8](#ch02fn08)])
    by Taylor Gerring (a core Ethereum developer), and “A Prehistory of the Ethereum
    Protocol,”^([[9](#ch02fn09)]) by Vitalik Buterin himself.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: ⁷
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “History of Etherum,” Ethereum Homestead, [http://mng.bz/XgwM](http://mng.bz/XgwM).
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁸
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Taylor Gerring, “Cut and Try: Building a Dream,” February 9, 2016, [http://mng.bz/y1BE](http://mng.bz/y1BE).'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁹
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “A Prehistory of the Ethereum Protocol,” [http://mng.bz/MxRm](http://mng.bz/MxRm).
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
- en: '**The DAO attack and the split between Ethereum and Ethereum Classic**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: The DAO (which stands for decentralized autonomous organization) was one of
    the first mainstream Dapps in the Ethereum space. It was a decentralized venture
    capital fund. The DAO token holders were meant to vote on all investment decisions.
    While the DAO smart contract was still being developed, tokens were sold to investors
    through a crowdsale, a sort of decentralized crowdfunding application. (You’ll
    read more about crowdsales in [chapters 6](kindle_split_018.xhtml#ch06) and [7](kindle_split_019.xhtml#ch07).)
    This funding campaign, which took place in May 2016, managed to collect over 12M
    Ether, which at the time was worth around $150M (with Ether trading at $11).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of the DAO contract was that groups of DAO token holders
    unhappy with decisions that the qualified majority made (investment decisions
    were approved with 20% of the votes) could split from the main DAO and create
    their own Child DAO, where they’d start to vote on different investment proposals.
    In June 2016, this feature, which had been identified by some community members
    as potentially weak from a security point of view, was exploited by a hacker,
    who managed to gain control of 3.5M Ether (worth around $50M at that time) through
    a recursive call that kept withdrawing funds.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Child DAO creation feature required funds to be withheld for 28
    days before they could be transferred out to another account, so the hacker couldn’t
    steal them immediately. This gave the DAO developers and the Ethereum community
    some time to propose solutions to prevent the theft. Finally, after a failed soft
    fork of the blockchain that would have blacklisted any transaction coming out
    of the DAO, the community voted for a hard fork, including a smart contract designed
    to return the stolen funds to the original owners. Although the majority had voted
    for the hard fork, some members of the community argued that the hard fork had
    broken various principles of the Ethereum white paper, mainly the promise that
    smart contract code is implicitly law and the guarantee that the blockchain is
    immutable. They consequently decided to keep the original blockchain running,
    and this was renamed Ethereum Classic.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: You can find many articles and blog posts on the DAO attack, ranging in complexity
    from the technical to the high-level. Given that you don’t yet have a strong technical
    foundation in this area, if you want to learn more about this, I recommend you
    have a look at “The DAO, The Hack, The Soft Fork and The Hard Fork,”^([[10](#ch02fn10)])
    which describes in detail what happened without getting too much into the technical
    side. You’ll be able to understand the DAO attack better after having read [chapter
    15](kindle_split_029.xhtml#ch15) on security, but I cover it specifically because
    most of the techniques used are beyond the scope of this book. Nevertheless, if
    at that point you’re eager to jump to the technical details of the hack, I recommend
    the brilliant “Analysis of the DAO Exploit.”^([[11](#ch02fn11)])
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: ^(10)
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Antonio Madeira, “The DAO, The Hack, The Soft Fork and The Hard Fork,” July
    26, 2016, [http://mng.bz/a7NY](http://mng.bz/a7NY).
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(11)
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Phil Daian, “Analysis of the DAO exploit,” Hacking, Distributed, June 18,
    2016, [http://mng.bz/gNrn](http://mng.bz/gNrn).
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
- en: 2.3.2\. Who controls Ethereum’s development?
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the Frontier release back in July 2015, the hot topic of Ethereum governance
    started to gather momentum within the Ethereum Foundation, as well as across the
    wider Ethereum community. Key questions, such as “Who controls Ethereum’s development,”
    “How do changes get proposed,” and “Who approves them and how” got debated openly
    so that early adopters could be encouraged to use and trust the platform.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain governance is about the rules and processes that participants must
    follow for making changes to the platform, and about how the rules and processes
    themselves should get defined. In short, it’s about who decides on changes and
    how the decisions get approved and followed.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: ETH DEV, the nonprofit organization leading Ethereum development, gathers proposals
    in the Ethereum Improvement Proposals (EIPs, [https://eips.ethereum.org/](https://eips.ethereum.org/))
    repository.^([[12](#ch02fn12)]) This is based on established processes also followed
    by other open source projects—Python Improvement Proposals (PIPs) and Bitcoin
    Improvement Proposals (BIPs) are classic examples. Proposals are initially studied
    and Proofs of Concept (PoCs) often follow.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: ^(12)
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the EIPs page on GitHub at [https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs).
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a proposal gathers enough momentum (it’s considered interesting by the core
    Ethereum developers), it progresses to *Draft* status and might be debated further
    among the wider community at developer conferences or official online forums.
    If an informal consensus is reached, the proposal can progress immediately to
    *Accepted* or *Rejected* status. Accepted proposals get scheduled for future platform
    releases, and more effort is consequently put into them. Obviously, there’s always
    the risk that the participants won’t all agree with the proposal or its implementation,
    so the proposal is considered implicitly accepted only after most participants
    have adopted it.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, some proposals cause heated debate in the wider community. In
    those cases, the decision isn’t clear-cut, and they go through formal on-chain
    voting. When it comes to on-chain voting, one of the following two competing models
    is generally followed:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '*Loosely coupled on-chain voting (aka informal governance)*—The community leaders
    (for example the Ethereum Foundation and ETH DEV) signal how to vote. Participants
    vote on-chain through a dedicated smart contract that weights their preference
    based on how much Ether they own. (This voting is often referred to as *coinvoting.*)
    The proposal is then implemented if the outcome of the voting is favorable. Although
    the vote is ethically binding, developers or other key participants, such as miners,
    might always decide not to implement or adopt the winning proposal, at risk of
    being stigmatized by the community.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tightly coupled on-chain voting (a.k.a on-chain governance)*—The proposal
    gets fully implemented before the vote takes place, generally by a group of developers
    backing it, and then a smart contract switches on the functionality in the production
    network only following successful on-chain voting. This model is often favored
    by purists, who argue the technical analysis shouldn’t be influenced by politics
    until the last stage.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled on-chain voting has been introduced in various blockchain platforms
    and has become somewhat fashionable. But like other established blockchain platforms,
    such as Bitcoin and Zcash, Ethereum tends to follow the principle of loosely coupled
    voting, openly supported by Vitalik Buterin in his blog post “Notes on Blockchain
    Governance.”^([[13](#ch02fn13)])
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: ^(13)
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Notes on Blockchain Governance,” December 17, 2017, [https://vitalik.ca/general/2017/12/17/voting.html](https://vitalik.ca/general/2017/12/17/voting.html).
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you can see, Ethereum governance is relatively informal and centralized,
    as core developers seem to have more decision-making weight than the wider community.
    The argument is that if everything went through formal voting, the platform would
    evolve too slowly. If you’re interested in reading more on Ethereum governance,
    I recommend the following articles:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: “Ethereum Is Throwing Out the Crypto Governance Playbook”^([[14](#ch02fn14)])
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(14)
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Ethereum Is Throwing Out the Crypto Governance Playbook,”
    Coindesk, March 14, 2018, [http://mng.bz/edwZ](http://mng.bz/edwZ).
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Experimental Voting Effort Aims to Break Ethereum Governance Gridlock”^([[15](#ch02fn15)])
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(15)
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Experimental Voting Effort Aims to Break Ethereum
    Governance Gridlock,” Coindesk, May 23, 2018, [http://mng.bz/pgQ0](http://mng.bz/pgQ0).
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: “A user’s perspective and introduction to blockchain governance”^([[16](#ch02fn16)])
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^(16)
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Richard Red, “A user’s perspective and introduction to blockchain governance,”
    Medium, [http://mng.bz/O2VO](http://mng.bz/O2VO).
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Ethereum node hosts an Ethereum client and a copy of the blockchain.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum client contains
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a virtual machine called Ethereum Virtual Machine (EVM), capable of executing
    smart contract bytecode
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a memory pool, where transactions received by the node get stored before being
    propagated further into the network
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a JSON-RPC API, which exposes the functionality of the client to other nodes
    and external users
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a client process, which coordinates the processing
  id: totrans-589
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum smart contract is code written in the Solidity language and compiled
    into EVM bytecode.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum smart contract is deployed across the P2P network through a contract
    deployment transaction, pushed to a local Ethereum node, and then propagated throughout
    the network.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blockchain is a sequence of blocks, each containing a sequence number, a timestamp,
    and a list of transactions, each individually digitally signed. Each block includes
    a copy of the cryptographic hash of the previous block and the nonce, which generates
    the hash of the current block.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main innovation introduced by Ethereum with respect to previous blockchain
    implementations is the EVM and the concept of the smart contract.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ethereum follows an informal governance model, where proposals go through the
    Ethereum Improvement Proposals (EIPs) process: they get analyzed by the core Ethereum
    developers, are often tried through Proofs of Concept (PoCs), and ultimately get
    accepted or rejected.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, when an EIP causes heated debate, it gets formally voted on-chain
    by the participants, but, even if the vote is favorable, a proposal is considered
    practically accepted only when the majority of the participants have adopted it.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 3\. The Ethereum platform
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Ethereum through the Ethereum wallet
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the characteristics of Ethereum smart contracts
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Ethereum through the Go Ethereum (geth) client
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and managing accounts
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: The previous chapter introduced Dapps and the underlying concepts and technologies,
    among which is Ethereum. In this chapter, I’ll cover Ethereum in much greater
    depth, so you’ll get the foundation you need to develop Dapps on this platform
    effectively. I’ll begin by presenting the Ethereum wallet, a UI tool you’ll use
    to start interacting with the Ethereum P2P network by transferring some Ether,
    the Ethereum cryptocurrency. Then you’ll get a wide overview of smart contracts,
    the key technology that Ethereum introduced.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning about Go Ethereum, one of the many clients available on the
    platform, and once you understand the purpose of accounts, you’ll move to the
    next level and start interacting with the Ethereum network through Go Ethereum
    in several ways: with commands entered into the operating system shell, with instructions
    entered into the Go Ethereum console, and with HTTP requests. At that point, you
    should have acquired enough familiarity with the platform to progress with confidence
    through the rest of the book. It’ll be a dense but rewarding chapter. Let’s get
    started.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Connecting to Ethereum through the wallet
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ethereum network offers two main graphical user interfaces:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '*Mist*—A browser for Ethereum Dapps'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ethereum wallet*—A specific version of Mist with a single Dapp bundled in
    it'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll learn about Mist in a later chapter. For the moment, we’ll focus on the
    Ethereum wallet. The main purpose of the wallet is to store, receive, and transfer
    Ether, the Ethereum cryptocurrency. It’s similar to a Bitcoin wallet, if you’ve
    ever handled bitcoins, and you’ll initially use it to transfer Ether so that you
    can start to interact with the platform in the simplest way. It’s also a useful
    tool to learn how to deploy smart contracts and interact with them on one of the
    public Ethereum networks.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1\. Getting started with the Ethereum wallet
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you open the download page ([https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)),
    you’ll find various versions of Mist and the Ethereum wallet. Pick the version
    of the Ethereum wallet corresponding to your operating system and download the
    related zip file. (I’ve picked Ethereum-Wallet-win64-0-11-1.zip.) After unzipping
    it, you can run the executable Ethereum Wallet.exe directly. The first time you
    launch it, it’ll default to the main network. In this chapter, you’ll work against
    the public test Ropsten network instead. To select it, you must pick it from the
    top menu, as shown in [figure 3.1](#ch03fig01): Develop > Network > Ropsten. You
    also can select the Ropsten network through the Alt+Ctrl+2 shortcut.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1\. Choosing the test Ropsten network from the Develop > Network >
    Ropsten menu option or through the Alt+Ctrl+2 shortcut
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-01_alt.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
- en: 'After you select the Ropsten network, the wallet will start to synchronize
    with the related blockchain. By default, the synchronization mode is Light, which,
    as you saw in the previous chapter, downloads the current state trie from a peer
    full node, so you don’t have to wait long (minutes). This will allow you to get
    up and running quickly. But if you want to perform write operations, such as transferring
    Ether or deploying smart contracts, which is what you’ll be doing, you must get
    a full copy of the blockchain—you can choose between Fast and Full. (Go back to
    the previous chapter if you don’t remember how these sync modes work.) Here’s
    a rough estimate of what to expect when you’re synchronizing the Ropsten blockchain
    locally:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '*Fast*—Uses roughly 1 GB of disk space and takes two to four hours'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full*—Uses roughly 100 GB of disk space and can take up to a day or two'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re synchronized, you’ll be able to see synchronization details at the
    top of the screen, including the name of the network you’re connected to, the
    latest block number, and the number of seconds passed since receiving the last
    block, as shown in [figure 3.2](#ch03fig02).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2\. You can see synchronization details, including the name of the
    network and the latest block number, at the top of the screen.
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-02_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To perform the operations I’ll cover in this chapter and the next, you *must
    choose Fast or Full* synchronization; otherwise, you won’t be able to transfer
    Ether or deploy a contract through the wallet. To be able to execute a transaction,
    you must have a full local copy of the blockchain. If the wallet appears unresponsive
    after a while and you don’t notice any progress in the synchronization, it might
    be because the wallet hasn’t managed to connect to any peer nodes. In that case,
    close it down and try to synchronize the Ropsten blockchain through the geth client.
    If you need to do this, read about geth in [section 3.3](#ch03lev1sec3), and then
    synchronize it to Ropsten as explained in [chapter 8](kindle_split_020.xhtml#ch08),
    [section 8.1](kindle_split_020.xhtml#ch08lev1sec1).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
- en: Figure 3.3\. Accounts overview screen. You can create an account by clicking
    Add Account.
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-03_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
- en: At this point, you’re ready to create accounts. Click the Wallets tab, which
    will bring you to the Accounts Overview screen, and then click the Add Account
    button, which has a plus symbol next to it, as you can see in [figure 3.3](#ch03fig03).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a small dialog box asking for a strong password. (Make sure you stretch
    the dialog from the bottom-right corner until you see the OK button.) After entering
    a password (twice), you’ll be reminded to back up your keyfiles (more on this
    later) and password.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Manage your passwords carefully. If you forget your password, you won’t be able
    to click any “I Forgot My Password” button. Losing your password means losing
    the Ether stored in the account. This isn’t a major problem when pointing to a
    test network, because Ether has no value there. But, especially when moving to
    the production network, you should get into the habit of choosing a strong password
    and keeping a copy of it somewhere secure. Better safe than sorry!
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re using the Ethereum wallet for Mac OS or LINUX, the interface is slightly
    different, screenshots won’t match what you see, and my descriptions might not
    work to the letter. Also, the default network shown might be different. But you
    should be able to find alternative ways to perform the operations I describe.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
- en: After the wallet has generated the account, on the Accounts Overview screen
    you’ll see *Account 1* with the related hexadecimal address and a balance of zero
    Ether. I’ll cover accounts in more detail later; for now, create one more account
    in the same way, and you now should see two accounts on the screen, as shown in
    [figure 3.4](#ch03fig04). Now that you have a couple of accounts (feel free to
    create more), you can try out some common operations with the wallet.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4\. Account details shown on the Accounts Overview screen after their
    creation
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-04_alt.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
- en: 3.1.2\. Performing common operations with the wallet
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With a balance of zero Ether (the Ethereum cryptocurrency) on all your accounts,
    you won’t be able to go too far, because as you’ll learn, to execute transactions
    on the network, you must pay transaction costs in Ether. Because it isn’t possible
    to buy Ether in the test network, you’ll have to generate it somehow. One way
    is through mining.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Mining is the process through which new transactions get consolidated into
    blocks of the blockchain. Many participants in the Ethereum network run special
    mining nodes through which they hope to be rewarded in Ether tokens and be compensated
    for the computational power they provide to the network. Although mining Ether
    in the real public network is challenging and requires specialized hardware based
    on advanced GPU chipsets, it’s easy to generate Ether in the test network with
    “plain CPU” mining through the wallet menu:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Develop > Start Mining (Testnet only)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The menu option Develop > Start Mining will appear only after the blockchain
    has been entirely synchronized in Fast or Full mode.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
- en: The CPU of your machine will get busy, and after a few minutes you should have
    accumulated enough Ether to get going.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'If for any reason mining is taking too long, an alternative way to fund your
    Ropsten accounts is through the so-called *faucet*. The following URL can send
    your addresses free test Ether: http://faucet.ropsten.be:3001/donate/<destinationaddress>,
    for example, http://faucet.ropsten.be:3001/donate/0x8713Cb74c7DB911f2056C8DD2bA5036-7-eeEa11D0\.
    After a few seconds, your destination address should receive 1 Ether, as you can
    see in [figure 3.5](#ch03fig05). You can check the status of the Ether transfer
    from the faucet by entering your address in the text box at the top of the Ropsten
    Etherscan webpage: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    If faucet.ropsten.be isn’t working as expected or you keep getting gray-listed,
    try [https://faucet.kyber.network/](https://faucet.kyber.network/). Alternatively,
    try Google ropsten faucet.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5\. Account balances after using the faucet facility
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-05_alt.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
- en: Transferring Ether
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now you can try to move some Ether between accounts. It’s easy. First, go to
    the Send screen. Select the source (Account 1) and target account addresses (copy
    the address of Account 2 from the Accounts Overview screen), then select the amount
    of Ether you want to transfer—for example, 0.5 Ether. Finally, after deciding
    on a transaction fee, click Send Transaction. Don’t worry too much about this
    for now; we’ll examine transaction fees later.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be prompted to enter a password, as shown in [figure 3.6](#ch03fig06).
    Enter the password of the source account (Account 1) to digitally sign the transaction
    and subsequently prove that the account owner is sending it, and then click Send
    Transaction. You’ve now completed your first Ether transaction!
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6\. Password entry screen for moving Ether between accounts. You’re
    required to enter the password of the sending account when transferring Ether
    with the Ethereum wallet, to digitally sign the transaction and consequently prove
    it’s genuinely the account owner who’s sending the Ether.
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-06_alt.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
- en: To check the status of the transaction, go back to the Accounts Overview screen
    and click Latest Transactions at the bottom of the screen. Clicking on the related
    link will allow you to drill down into further details, such as those shown in
    the screenshot in [figure 3.7](#ch03fig07).
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7\. Summary transaction information from the Transactions panel of
    the Accounts Overview screen
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-07_alt.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
- en: 'You can get a better idea of how your transaction has contributed to the Ropsten
    blockchain by checking it on *Etherscan*, a website reporting the real-time evolution
    of the Ethereum blockchain. Use this URL to access the test network: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    You’ll be able to get detailed block and transaction information.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve acquired some familiarity with Ethereum, it’s time to learn
    more about one of the greatest innovations that this platform introduced: smart
    contracts. Once you grasp how smart contracts work, you’ll be able to make further
    progress on SimpleCoin, the cryptocurrency you started to build in the previous
    chapter.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '3.2\. Smart contracts: The brain of Dapps'
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I described in [chapter 1](kindle_split_012.xhtml#ch01), an Ethereum smart
    contract, or simply *contract*, is a software artifact containing business rules
    and a state. It’s written in a high-level language such as Solidity, compiled
    into EVM bytecode, deployed onto the Ethereum network, and stored on its blockchain
    against a specific account generated at deployment.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [figure 3.8](#ch03fig08), a contract receives transaction messages
    from a user account (or from other contracts) and executes its logic on the Ethereum
    Virtual Machine (EVM). This might optionally involve sending messages to other
    contracts, reading state from the blockchain, or writing state to the blockchain
    (specifically from/to the State Merkle-Patricia trie). The account sending the
    message to the contract gets charged (in Ether) by the successful mining node
    for computation and network resources consumed during the processing of the requested
    operation. The amount of such computation and resources is calculated in a unit
    called *gas*, as you’ll see in [section 3.2.3](#ch03lev2sec5), so it’s common
    to say that a transaction consumes a certain amount of gas (rather than resources).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8\. An Ethereum contract receives a transaction message from a user
    account. Its logic is executed on the Ethereum Virtual Machine (EVM); then the
    successful miner calculates the cost for the computational and network resources
    used, in a unit called gas, and charges the user account in Ether.
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-08_alt.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
- en: 'If you want to understand smart contracts, how they get instantiated by users
    and by other contracts, and especially how they get executed, you need to go in
    greater detail through various concepts I’ve only touched on so far:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Accounts
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether and gas
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction messages
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll start by telling you more about the various types of accounts.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1\. Accounts
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve already come across the concept of *accounts* a few times. Accounts
    are available in two types:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '*Externally owned accounts (EOA)* (or simply *External Accounts*)—These are
    also known informally as *user accounts*. They’re publicly identifiable from their
    public key, but they can only be operated by knowing the private key. If you buy
    some Ether, you’d store it in this type of account. Also, you’d start a transaction
    against a smart contract from an EOA.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contract accounts*—These are the accounts that contracts are executed under.
    The account address is generated at deployment time, and it identifies the location
    of the contract in the blockchain.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both EOAs and contract accounts hold data in the form of a key-value store and
    an Ether balance. [Table 3.1](#ch03table01) compares the main properties of EOAs
    and contract accounts.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1\. Comparison between an EOA and a Contract Account
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Property | Externally owned account | Contract account |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
- en: '| Has Ether balance | Yes | Yes |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
- en: '| Can start transaction message | Yes | No |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
- en: '| Can start call message | No | Yes |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
- en: '| Has code | No | Yes |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
- en: 3.2.2\. Ether
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve mentioned Ether casually a few times, so it’s probably time you learned
    more about it. Ether is the cryptocurrency that the Ethereum blockchain supports.
    Its main purpose is to represent monetary value for services and goods traded
    over the platform.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Ether is also used to pay for transaction fees. These are, as mentioned in [section
    3.2](#ch03lev1sec2) and covered more in [section 3.2.3](#ch03lev2sec5), calculated
    in a unit called gas, which measures computational resources that a transaction
    consumes. But these fees are settled in Ether (calculated from the price of a
    unit of gas, expressed in Ether). Miners charge transaction fees to get compensated
    for the computational power they provide the network while appending new transaction
    blocks to the blockchain.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Ether comes in various denominations, which are all defined, as you can see
    in [table 3.2](#ch03table02), as a multiple of Wei, the smallest Ether denomination.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2\. Ether denominations and values in Wei
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Unit | Wei value | Wei |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
- en: '| Wei | 1 Wei | 1 |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
- en: '| Kwei (Babbage) | 1e3 Wei | 1,000 |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| Mwei (Lovelace) | 1e6 Wei | 1,000,000 |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| Gwei (Shannon) | 1e9 Wei | 1,000,000,000 |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| Microether (Szabo) | 1e12 Wei | 1,000,000,000,000 |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: '| Milliether (Finney) | 1e15 Wei | 1,000,000,000,000,000 |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
- en: '| Ether | 1e18 Wei | 1,000,000,000,000,000,000 |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: '[Figure 3.9](#ch03fig09) summarizes the Ether lifecycle, which goes through
    the following steps:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Minting Ether
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transferring Ether
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing Ether
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exchanging Ether
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.9\. The Ether lifecycle. Ether is minted by miner nodes into miner
    user accounts. Then it’s transferred to EOAs (also known as user accounts). From
    there, it can be stored on various wallets. Ultimately, it can be converted to
    real currency, such as USD, EUR, YEN, GBP, and others, through cryptocurrency
    exchanges.
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-09_alt.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
- en: Minting Ether
  id: totrans-707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re unfamiliar with cryptocurrencies, you must be wondering how Ether
    is minted and exchanged. Ether is generated through the mining process, during
    which miners compete to group and append transactions into new blockchain blocks,
    as I discussed in [section 1.1.2](kindle_split_012.xhtml#ch01lev2sec2). When successful,
    a miner gets rewarded with a certain number of Ether coins. Blocks are added to
    the Ethereum blockchain every 15 seconds or so, and the money supply increases
    accordingly.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Transferring Ether
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once Ether has been generated, it’s allocated to the miner’s external account.
    Miners can then transfer Ether to other external accounts or contract accounts,
    either through the Ethereum wallet or programmatically, as you’ll see later.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging Ether
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because Ether is valuable, it doesn’t generally get transferred for free between
    accounts. It’s often transferred in return for goods and services traded through
    smart contracts, but also in return for conventional currency, such as US dollars,
    euros, pounds, yen, and so on. Although it’s possible to buy Ether from individual
    owners and pay them an agreed amount of conventional currency, it’s more effective
    to handle such transactions using cryptocurrency exchanges. Two main types of
    exchanges are available: centralized, such as Kraken, Coinbase, and Coinsquare,
    and decentralized, such as EtherEx. Each exchange is generally biased toward a
    specific real-world currency.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Storing Ether
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once someone acquires Ether, whether through mining, smart contract trading,
    or exchange-based trading, it’s allocated to an account. You can manage accounts
    using many methods, each with a different trade-off between convenience and security.
    The most convenient one is generally through desktop or online wallets, which
    allow you to transfer Ether easily. The most secure one is through cold or paper
    storage, which means generating the private key offline and holding it literally
    on a piece of paper. Hardware wallets present another high-security option and
    are conceptually similar to paper wallets because they can be considered offline.
    The main difference is that the account owner stores the private key on a small
    electronic device similar to a USB key. [Table 3.3](#ch03table03) summarizes the
    different options.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.3\. Wallet types and their characteristics
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Wallet type | Convenience | Security | Examples |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
- en: '| Desktop wallet | High | High | Ethereum wallet, Exodus |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
- en: '| Mobile wallet | High | Low | Jaxx |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
- en: '| Online wallet | High | Medium | MyEtherWallet, Coinbase, Kraken |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| Hardware wallet | Medium | Very high | Trezor, Ledger Nano, KeepKey |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| Paper storage | Low | Very high | EthAddress |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: I’ve mentioned that transaction fees are charged in Ether but calculated in
    a unit called gas. Let’s see what gas is and how it’s related to transaction costs.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3\. Gas
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gas is the unit of measure for transaction fees charged on the Ethereum platform.
    The amount of gas used to complete a transaction depends on the amount of computational
    resources that the EVM spends while running the transaction. Specifically, it
    depends on the exact low-level EVM instructions that have been executed during
    the transaction. [Table 3.4](#ch03table04) gives an idea of the amount of gas
    charged for the most common EVM operations.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.4\. Gas cost for simple EVM operations
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Operation | EVM op code | Gas cost |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
- en: '| Addition, subtraction | ADD, SUB | 3 |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
- en: '| Multiplication, division | MUL, DIV | 5 |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
- en: '| Comparison | LT, GT, SLT, SGT | 3 |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: '| Load word from memory | MLOAD | 3 |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
- en: '| Store word to memory | MSTORE | 3 |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| Load word from storage | SLOAD | 200 |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| Storing word into storage | SSTORE | >5000 |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| Contract creation | CREATE | 32000 |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: The main reason the execution of a transaction is charged in units of gas, and
    indirectly in units of computational work, is to prevent denial of service (DoS)
    attacks by unscrupulous participants who might want to disrupt the network. To
    launch a DoS attack, a malicious participant would have to spam the network with
    a high number of transactions, each performing a large amount of computational
    work; for instance, an infinite loop. The amount of gas corresponding to this
    work would be high, and it would have to be paid in a correspondingly high amount
    of Ether—it’s unlikely anyone would pay to disrupt a service!
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Most smart contract development IDEs give an idea of the total amount of gas
    required to complete a transaction. For example, in the screenshot in [figure
    3.10](#ch03fig10), you can see a gas estimate for the execution of the transfer
    function of the `SimpleCoin` contract from the last section of [chapter 1](kindle_split_012.xhtml#ch01),
    obtained by clicking the Details button on the output panel.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10\. Transaction costs for the execution of the `SimpleCoin` transfer
    function
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-10_alt.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
- en: 'Transaction fee costs are calculated according to this formula: transaction
    fees (in Ether) = number of units of gas consumed * price per unit of gas (in
    Ether). Let’s break it down:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: The EVM determines the *number of units of gas consumed* while running the transaction,
    and that depends on the computational cost of the code being run during the transaction.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender of the transaction decides the *price of a unit of gas* (in Ether).
    The higher it is, the more likely it is that miners will include the transaction
    in the block they’re processing. Miners prioritize transactions that are likely
    to pay high fees, so if a transaction is expected to consume a relatively low
    amount of gas, the sender will have to set a relatively high gas price to guarantee
    quick processing.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transaction sender sets a *limit* for *the maximum amount of gas* that a
    transaction should consume. This protects the sender from higher-than-expected
    transaction costs due to execution of the code in a way different from what was
    intended; for instance, if the developer introduces a bug that causes an infinite
    loop. Such limits should be relatively close to the estimated amount of gas needed
    to complete the transaction.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While a transaction is being executed, the EVM consumes its gas. Two outcomes
    are possible at the end of the transaction:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '*The transaction completes successfully*. In this case, the unused gas is returned
    to the sender.'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The amount of gas available ends before the completion of the transaction*.
    In this case, the EVM throws an *end of gas exception*, and the transaction is
    rolled back.'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might be wondering who pockets the transaction fee. Given either of the
    two transaction outcomes, the miner who has processed the transaction receives
    the fee. For the first outcome, they earn the fee by including the transaction
    in a new block that has been successfully appended to the blockchain. For the
    second outcome, even though the EVM throws an exception, the miner still charges
    the gas in Ether, and they collect the related transaction fee as usual. In short,
    a successful miner is rewarded by minting new Ether and getting transaction fees
    from the transaction senders. In the early stages of the Ethereum platform, most
    of a miner’s profits came from minting.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.4\. Calls and transactions
  id: totrans-749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accounts interact with each other through two types of messages: calls and
    transactions.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: Calls
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A call is sent through a message that doesn’t get stored on the blockchain
    and whose execution has the following characteristics:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: It can only perform read-only operations, which don’t alter the state of the
    blockchain.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t consume any gas, and consequently, it’s free.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s processed synchronously.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It immediately returns a return value.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t allow transferring Ether to the contract account.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical calls are direct invocations of contract member variables, including
    mappings, and invocations of so-called *constant functions*, which don’t alter
    contract state. You performed calls, for example, when you checked account balances
    of SimpleCoin, the basic cryptocurrency you started to build at the end of [chapter
    1](kindle_split_012.xhtml#ch01).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A transaction, which I introduced to you in the Dapp dynamic view in [chapter
    1](kindle_split_012.xhtml#ch01), is sent through a message that gets serialized
    and stored on the blockchain during the mining process. It contains the following
    fields:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '*Sender address*'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recipient address*'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Value*—Amount of Ether to be transferred (in Wei), in case the message is
    being used to transfer Ether (optional)'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data*—Input parameters, in case the message is being used as a function call
    (optional)'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*StartGas*—Maximum amount of gas to be used for the execution of the message.
    If this limit is exceeded, the EVM throws an exception and rolls back the state
    of the message.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Digital signature*—Proves the identity of the transaction sender'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GasPrice*—The price of a unit of gas (expressed in Ether) the transaction
    initiator is willing to pay, as discussed in the gas section'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You executed transactions when you performed SimpleCoin transfers. The execution
    of a transaction has the following characteristics:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: It can perform write operations, which alter the state of the blockchain.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It consumes gas, which must be paid for in Ether.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s processed asynchronously: it gets executed through mining and then gets
    appended on a new blockchain block, which gets broadcast throughout the network.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It immediately returns a transaction ID, but not a return value.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows transferring Ether to the contract account. (The Ether transfer becomes
    part of the transaction itself.)
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now you know contracts are executed on the EVM on each node of the Ethereum
    network. I’ll provide a quick overview of how the EVM works.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.5\. The Ethereum Virtual Machine
  id: totrans-775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Ethereum Virtual Machine (EVM) is a stack-based abstract computing machine,
    similar in purpose to the Java virtual machine (JVM) and to the .NET Common Language
    Runtime (CLR). It enables a computer to run an Ethereum application and has two
    memory areas:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '*Volatile memory*, or simply *memory*. This is a word-addressed byte array,
    which gets allocated to a contract at every message call. Reads access 256-bit
    words, whereas writes can be performed on a width of 8 or 256 bits.'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storage*. This is a key-value store where both key and value have a width
    of 256 bits. Storage is allocated to each account and is persisted on the blockchain.
    A contract account can access only its own storage.'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EVM opcodes cover operations including Boolean, bitwise, and arithmetic comparisons
    and jumps (both conditional and unconditional). These are the main opcodes handling
    contract creation and calls:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE`—This performs the creation of a new contract instance.'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CALL`—A contract sends a message to itself or other contracts through this
    operator.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELEGATECALL`—This operator allows the calling contract to send a message
    to an external contract but execute the related code in the context of the caller.
    This operator is especially useful for the creation of libraries of shared code
    that multiple contracts can access.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The EVM is completely sandboxed: a contract can’t access network or filesystem
    resources. It can only access other contracts. A more in-depth explanation of
    the EVM is outside the scope of this book. The best reference for understanding
    its design is Gavin Wood’s so-called *Yellow Paper*: [http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf).'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you’ve consolidated your knowledge on smart contracts. Now it’s
    time to take a step further and connect to the Ethereum network through a proper
    client: the Go Ethereum client.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Connecting to Ethereum with geth
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start installing a client, I’d like to give you a more detailed overview
    of the Ethereum network, which I started introducing in [chapter 1](kindle_split_012.xhtml#ch01).
    It’ll help you understand the wider context that a client fits in.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: You already know the Ethereum network is a peer-to-peer (P2P) network, which
    means there’s no central master or server node coordinating them. Consequently,
    all nodes are clients to each other. Nodes are designed to work and communicate
    with each other in exactly the same way, according to a predefined protocol called
    Wire, described in the Yellow Paper. This means all nodes must be able to append
    new transaction blocks to the blockchain (if mining is activated) and verify them
    while blocks get propagated throughout the network.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'From an implementation point of view, the network contains two broad categories
    of nodes:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '*Miners*—They process the latest transactions and consolidate them into the
    blockchain in exchange for transaction fees and a mining reward (in Ether) if
    they manage to execute the consensus algorithm successfully. In that case, they
    propagate the blocks they’ve consolidated onto the blockchain to other peers of
    the network. Because these nodes generate new blocks, they’re considered producers
    (although they’re technically also still consumers).'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full nodes*—They mainly verify the validity of the blocks they’ve received
    from neighboring peers and keep propagating them to the rest of the network. Therefore,
    they’re considered consumers.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining nodes run on clients optimized for processing transactions, generating
    blocks, and executing the Proof of Work algorithm efficiently, to get rewarded
    relatively frequently. Mining implementations, such as *ethminer*, have been written
    in C++ and use GPU libraries such as NVIDIA’s CUDA. Consequently, they run on
    GPU hardware that can deliver superior performance.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, full nodes don’t have performance requirements, so standard
    clients have been implemented in various languages. [Table 3.5](#ch03table05)
    summarizes the main client implementations available to date, ordered by popularity,
    as reported in Ethernodes ([https://ethernodes.org/network/1](https://ethernodes.org/network/1)).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.5\. Ethereum client implementations by language
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Client | Language |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
- en: '| Go Ethereum (geth) | Go |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
- en: '| Parity | Rust |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
- en: '| Cpp-ethereum (eth) | C++ |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
- en: '| Ethereum(J) | Java |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
- en: '| Pyethapp | Python |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
- en: '| ethereumjs-lib | JavaScript |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
- en: '| ruby-ethereum | Ruby |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
- en: '| ethereumH | Haskell |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
- en: Each client comes with a console, and some of them also include a graphical
    browser or a wallet. While working with this book, you’ll use Go Ethereum, also
    known as geth, which is the most popular client, installed on over 70% of the
    network nodes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1\. Getting started with geth
  id: totrans-805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The download page for the Go Ethereum website, [https://ethereum.github.io/go-ethereum/downloads/](https://ethereum.github.io/go-ethereum/downloads/),
    shows releases for all major operating systems: Android, iOS, Linux, MacOS, and
    Windows. Various installation formats are available for some of the supported
    operating systems. For example, for Windows, you can choose between the 32- and
    64-bit version and whether to download only the executable (Archive option) or
    the full installer (Installer option). I’ve picked the 64-bit Geth & Tools 1.8.13
    archive.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed or uncompressed the relevant file, you can run the geth
    executable. If you have the Ethereum wallet open, close it before starting geth,
    because they use the same port number! If you run geth with no parameters, it’ll
    start to synchronize in Full mode with the public production network, also known
    as MAINNET, as shown in the screenshot in [figure 3.11](#ch03fig11).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11\. geth synchronizing with the MAINNET network at startup
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-11_alt.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
- en: After geth has synchronized the full blockchain (this could take from hours
    to days, depending on your hardware and internet connection), the console will
    start to slow down and show blocks being added to the blockchain in real time.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for the wallet, you can synchronize geth in Light or Fast mode—for example,
    `C:\program files\geth>geth –-syncmode "light"`—if you prefer to get up and running
    more quickly (in minutes as opposed to hours or even days) and don’t mind not
    having downloaded the full blockchain locally.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
- en: 'You can interact with geth in two ways:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Through the user-friendly geth interactive JavaScript console
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through low-level JSON-RPC calls over HTTP
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’ll present both techniques to you. Let’s start with the simpler tool: the
    interactive JavaScript console.'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2\. A first look at the geth interactive console
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: geth comes with an interactive console that accepts JavaScript instructions.
    It implicitly references Web3.js, a JavaScript implementation of Web3, the official
    high-level library for interacting with Ethereum clients. This console is similar
    in purpose to read-eval-print loop (REPL) consoles for programming language IDEs.
    I’ll cover Web3 extensively in the next few chapters. For the moment, let’s get
    a quick feel for it.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the interactive console. You’ve got two possible ways to start
    it up:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'If no geth clients are running on the same machine, run the geth executable
    with the console command:'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If a geth client is already running on the machine, attach to a running geth
    process with the attach command:'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-825
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You have a running geth process, so you’ll go for the second option.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this book, I’m assuming you use Windows, as over 60% of the nodes of the
    Ethereum network run on this operating system. Consequently, I’ll show shell commands
    with a Windows command prompt format. Also note that after successful execution
    of instructions in the console, you might see *undefined* right before or after
    the correct results. You can ignore it.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
- en: Displaying version information
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First of all, you can query the console for version information. A Web3 object
    named web3 is implicitly instantiated when opening the console, so you can access
    version information in this way by typing
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and you’ll see something like
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the version property is an object that contains many subproperties.
    If you want, you can be specific and query an individual property of the version
    object:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and you’ll see something like
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because the console accepts JavaScript instructions, it’s possible to assign
    the values of Web3 properties and subproperties to variables and then display
    them through the console object:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Checking connectivity
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can get some client connectivity information from the web3.net object. (You
    can omit the web3 namespace because it’s implicitly referenced.) If you type
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: you’ll see something like
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As for the version object, you can directly access individual properties of
    the net object as follows:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to get more detailed information about your node, you can use the
    web3.admin object and call
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and you’ll see something like
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `peers` property gives you detailed information about the peers you’re
    connected to:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: will yield something like
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Accessing the blockchain
  id: totrans-857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `web3.eth` object retrieves real-time information about the client and the
    blockchain. Look at the console of the geth process currently running. You should
    see how new blocks are getting appended to the blockchain in real time. Take note
    of the block number of a recently appended block, and then switch back to the
    JavaScript console.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the most recent block number through the `eth.blockNumber` property:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then you can display summary information about this block by calling
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: and you’ll see something like
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You also can drill down at transaction level. You can get the first transaction
    stored in the latest block in this way:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll see something like
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I encourage you to have a look at the content of the whole `eth` object:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Performing Ether conversions
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Web3 API offers some useful functions to convert any Ether denomination
    from/to Wei. You can convert a Wei amount to a specific denomination:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And you can convert a specific denomination into Wei:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 3.3.3\. A first look at JSON-RPC
  id: totrans-876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve learned the basics of the JavaScript console, you can try to
    interact with geth by performing a few JSON-RPC calls. geth offers a remote procedure
    call (RPC) interface that allows you to access node functionality and blockchain
    data to a much finer degree of control than that offered by the Web3 API. In fact,
    Web3 is built on top of the RPC layer, which is the lowest level API exposed by
    the Ethereum platform, as shown in [figure 3.12](#ch03fig12).
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12\. Comparison between accessing geth through Web3.js and JSON-RPC
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-12_alt.jpg)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
- en: The RPC interface has been designed against the JSON-RPC 2.0 standard, and consequently
    it sends and receives data in JSON format. You can find more information on JSON-RPC
    in the sidebar.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to communicate with geth directly through JSON-RPC, you have to
    do two things:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: Stop any instance of geth running in a standard operating system command shell
    or in a geth console.
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start geth in RPC mode using the `--rpc` and `--rpcapi` options:'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-884
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you launch geth in RPC mode, it’s accessible through an HTTP server that
    accepts HTTP requests, by default on
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
- en: '**JSON-RPC**'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC is a lightweight remote procedure call that uses JSON as a data format.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: You invoke an RPC call by sending a request object to a server, typically over
    HTTP, or in any other way, such as socket or even messaging, because the transport
    layer isn’t part of the protocol.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'The request object must contain the following members:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`—Name of the remote procedure to be called.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`—Array with procedure parameters.'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`—A call identifier, typically a string or integer. It must be not null.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the server processes the call, it replies with a response object, which
    contains the following members:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result`—This field is present if the response is successful; it isn’t included
    if errors occur.'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`—This field is present if errors occur; it isn’t included if the response
    is successful.'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`—Same as specified in the request.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
- en: You’ll perform JSON-RPC calls to geth’s HTTP server using the cURL console command.
    To help you appreciate the differences between the Web3 API and the JSON-RPC API,
    I’ll show you how to execute in cURL the same operations you performed in Web3
    through the interactive console.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: cURL is available in most operating systems, including Windows (version 7 and
    10) and Linux. Alternatively, you can either download from the internet an open
    source version of cURL or perform HTTP requests through a graphical tool such
    as Postman, if you prefer.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
- en: Displaying version information
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can retrieve version information about the geth client with this call:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: (If you’re using Windows, you must escape JSON double quotes, as explained in
    the sidebar.) The result is equivalent to what you got from `web3.version.node`.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
- en: '**cURL JSON escaping on Windows**'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: 'cURL operations must escape the double-quote symbol " with \" in the JSON POST
    data, in certain versions of Windows. For example, in a command shell in Windows,
    you perform the request this way:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And in Linux:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
- en: Checking client connectivity
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get connectivity information by performing several calls. For instance,
    to check whether the client is actively listening for network connection, you
    must execute this request:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And you’ll get
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result is equivalent to `web3.net.listening`.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the number of peers connected to the client, you must execute this call:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And you’ll get
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result, which contains numbers encoded in hexadecimal format, as explained
    in the sidebar, is equivalent to `web3.net.peerCount`.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
- en: '**Numbers through JSON-RPC**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum’s JSON-RPC interface handles numbers differently than the official
    JSON-RPC 2.0 specification does. Numbers sent and returned through JSON-RPC must
    be encoded in hexadecimal format. Doing so makes sure each client implementation
    parses and processes large numbers appropriately, independent of the support for
    large numbers that the underlying language in which the client has been coded
    provides.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal encoding should include a 0x prefix and at least one valid digit
    with no leading zeros, as shown here:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** **This is equivalent to 1234 in decimal.**'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how numbers should be encoded into hexadecimal format:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal format | Hexadecimal format |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0x0 |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: '| 9 | 0x9 |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
- en: '| 1234 | 0x4d2 |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
- en: 'And here are some examples of incorrectly encoded numbers:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '| Incorrect hex encoding | Reason |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
- en: '| 0x | No digit has been specified after the 0x prefix. |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
- en: '| 42d | No 0x prefix has been specified. |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
- en: '| 0x042d | Leading 0 digits aren’t allowed. |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
- en: Accessing the blockchain
  id: totrans-948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get the latest blockchain block number this way:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And you’ll get
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you have the latest block number, you can inspect it by calling (replacing
    the block number in `params` with the one from your `result`):'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And you’ll get
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then you can inspect the first transaction of the block you retrieved in a
    way equivalent to how you did in Web3 through the interactive console (again,
    putting the block number you got in `results` into `params`):'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And you’ll get
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result object is similar to that returned by the Web3 `eth.getTransactionFromBlock`
    call.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, you’ll be interacting with geth mainly through Web3.js,
    but occasionally I’ll show you how to perform equivalent operations in JSON-RPC.
    If you’re interested in learning more about the JSON-RPC API, consult its wiki
    at [https://github.com/ethereum/wiki/wiki/JSON-RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4\. Mining with the geth console
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t consider a section on Ethereum clients to be complete before at least
    mentioning how to perform mining through a client. You already performed some
    mining through the Ethereum wallet at the beginning of this chapter, to load your
    test accounts with Ether.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, performing operations through the wallet hides what happens
    under the hood. For example, have you asked yourself why the Ether you mined got
    assigned to account1? That happened because the *etherbase* account, which is
    the account associated with the miner thread, is set by default to `eth.accounts[0]`.
    But after restarting geth and reopening the geth console in attach mode, as you
    did previously (in case you shut it down), you can reconfigure the etherbase account
    to `eth.accounts[1]`, if you prefer, through the implicitly instantiated `miner`
    object, as follows:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Regardless of whether your etherbase account is `eth.accounts[0]` or you’ve
    reconfigured it to `eth.accounts[1]`, you can start mining as follows:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point, the CPU of your machine will go to nearly 100%. Then you can
    stop mining:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the unlikely event you’ve mined some Ether, this will now be assigned to
    your `eth.accounts[1]`, or to `eth.accounts[0]` if you decided not to reconfigure
    it.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: 'When you kicked off mining on the geth interactive window with `miner.start()`,
    you might have noticed output similar to the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You might wonder what DAG is and why it takes such a long time to compute. DAG
    stands for directed acyclic graph, and it’s the data structure underlying *Ethash*,
    the Proof of Work (PoW) algorithm for mining on the Ethereum platform. DAG requires
    a relatively high amount of memory, so Ethash is considered a memory-intensive
    PoW algorithm. It consequently discourages mining through application-specific
    integrated circuit (ASIC) hardware, which is effective only for CPU-intensive
    PoW algorithms, such as the one used on the Bitcoin network. The Ethash algorithm
    encourages mining instead through commodity hardware, such as a GPU chipset (explained
    more in sidebar).
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: Mining is a specialized topic outside the scope of this book. If you’re interested
    in learning more about Ethash, I encourage you to consult the official notes at
    [http://mng.bz/WaOw](http://mng.bz/WaOw).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve experienced mining firsthand, you might ask yourself what happens
    if you have the luck to append a new block to the blockchain, get the related
    Ether reward in your etherbase account, and then decide to quit your mining activity
    by shutting down your node. Would the block you’ve created and appended to the
    blockchain still be valid, even if you’ve disappeared from the network? Would
    the transactions included in the block still be valid? Would you still be able
    to transfer the Ether in your etherbase account to another account?
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: The answer to all these questions is yes. Remember that the blockchain validation
    process, performed continuously by all active full nodes, only cares about the
    cryptographic consistency between a block hash and the public address of the miner
    who has generated the block, in the same way it cares about the consistency between
    a transaction hash and the public address of the account that has generated it.
    So whether the node that created a new block is active or inactive is as irrelevant
    to the block (and transaction) history as whether your computer is on or off after
    having transferred some Ether from an account of your desktop Ethereum wallet
    to another account.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
- en: '**GPU mining**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try your luck and hope to get rich by generating Ether on the
    public production network with CPU mining, as you’ve done so far in the test network,
    I hate to break the news, but you’re more likely to get rich by winning the lottery.
    As you saw in [chapter 1](kindle_split_012.xhtml#ch01), the execution of the PoW
    algorithm is successful only if the hash obtained combining the block information
    and a nonce has certain characteristics—for example, a high number of leading
    zeros. PoW algorithms are designed so that you must try millions of nonce values
    before hitting the lucky one that generates a valid hash. Consequently, mining
    successfully means being able to generate more hashes per second than other miners.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: With the best CPU chipset, you’ll be able to generate at most 1 megahash per
    second (Mh/s), where megahash means one million hashes. With good GPU chipsets,
    you might be able to generate up to 30 Mh/s—nearly 30 times the hashing capability
    of a standard CPU. Also consider that mining pools, which are organizations that
    pool various GPU miners together so they can share resources and rewards, can
    generate up to 30 Th/s (30 trillion hashes per second), which means up to 30 million
    times what a CPU is able to generate during the same time. Finally, consider that
    in the Ethereum space, around 40 mining pools have a hash rate ranging between
    30 Gh/s and 30 Th/s.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can understand why your chances of generating Ether using a CPU alone
    are slim. You might find this stark reality disappointing, and you might even
    think that the huge influence of mining pools on the mining process might bring
    into question Ethereum’s credibility, as far as decentralization is concerned.
    Many Ethereum participants believe that as long as many mining pools are competing,
    decentralization should be guaranteed. Also consider that the new consensus algorithm
    being implemented, Stake of Work, introduced in the previous chapter, might change
    completely how power is concentrated (or hopefully spread) in the Ethereum network.
    Here’s a quick summary of the hash rate that different hardware can achieve:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '| Hardware | Hashrate |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
- en: '| Single CPU | 1 Mh/s |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
- en: '| Single GPU | 30 Mh/s |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: '| GPU rig (10xGPUs) | 300 Mh/s |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
- en: '| Mining pool | 30,000,000 Mh/s |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
- en: 3.3.5\. Other clients
  id: totrans-990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although Go Ethereum is the most popular client, other implementations offer
    various benefits with respect to geth:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '*Parity*, written in Rust, is the second most popular Ethereum client, and
    it’s regarded as the fastest, lightest, and most secure implementation. It comes
    with a console and a built-in wallet.'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cpp-ethereum*, written in C++ and known as *eth*, is another fast implementation,
    third in popularity, and well regarded for its portability. *Ethminer*, a specialized
    mining client, is a fork from cpp-ethereum.'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pyethapp*, written in Python, is built on two core components: *pyethereum*
    provides EVM, blockchain, and mining functionality, whereas *pydevp2p* supports
    access to the P2P network and node discovery mechanisms. Python developers especially
    appreciate this implementation for its extensibility.'
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve learned about various components and tools of the Ethereum platform.
    Before leaving this chapter, you’ll reinforce your understanding of accounts,
    a key concept you must get familiar with to work effectively with Ethereum.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. Managing accounts with geth
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the beginning of this chapter, while covering smart contracts, I touched
    briefly on accounts. I also helped you create some accounts through the Ethereum
    wallet UI so you could use them to transfer some Ether around. Armed with the
    geth console, you can now deepen your knowledge of accounts by creating them and
    interacting with them programmatically.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1\. Ethereum accounts
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you know, the Ethereum platform supports two types of accounts:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '*Externally owned accounts (EOAs)*—These impersonate end users, as well as
    miners and autonomous agents.'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contract accounts*—These impersonate contracts.'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll deal only with EOAs, which I’ll call *accounts*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: As with most blockchain systems, the security of the Ethereum platform is based
    on public key cryptography. An account is therefore identified by a private/public
    key pair. The account’s address is represented by the last 20 bytes of the public
    key.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: 'The private/public key pair associated with an account is stored in a text
    *keyfile*. The public key is visible in plain text, whereas the private key is
    encrypted with the password introduced at account creation. Account keyfiles are
    in the *keystore* folder within the Ethereum node’s data directory:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: C:\Users\username\%appdata%\Roaming\Ethereum\keystore'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum/keystore'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum/keystore'
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s strongly recommended that you back up the keystore folder on a regular
    basis and keep a copy of the passwords you’ve introduced when creating each account
    in a secure place. Sorry if I keep pestering you with this, but if you haven't
    noticed, I do want to make a point of how sensitive key and password details are
    in the blockchain world!
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
- en: '**Account portability**'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use an account that you’ve created on the public production network
    on a test network, for example Ropsten, and vice versa. This is because the keystore
    of each network is different and is located in a separate folder within the Ethereum
    folder:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: 'Main prod network keystore: ~/.ethereum/keystore'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rinkeby test network keystore: ~/.ethereum/rinkeby/keystore'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ropsten test network keystore: ~/.ethereum/testnet/keystore'
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
- en: 'You can create accounts and interact with them through four different avenues:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum wallet, as you saw earlier in this chapter
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geth commands
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web3 on the geth console
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-RPC calls
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve already seen how to manage accounts with the Ethereum wallet. In the
    next several sections, you’ll manage accounts through geth commands and the geth
    console. You’ll also get a quick feel for how to perform some operations on accounts
    through the JSON-RPC API.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2\. Managing accounts with the geth command
  id: totrans-1025
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can manage an account easily through your operating system console by entering
    specific geth commands from the directory of the geth executable (or from any
    directory if geth is in your PATH global variable).
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can create a new account manually or using a plain text file:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Manual creation
  id: totrans-1029
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new account, enter
  id: totrans-1030
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You’ll be prompted to enter a password twice, and then you’ll be shown the
    address of the account you created:'
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-1034
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Tip
  id: totrans-1035
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: Get into the habit of choosing strong passwords or generating them through a
    strong password generator. I’m repeating myself; I know, I know! But this is important,
    believe me!
  id: totrans-1036
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1037
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Text file creation
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid having to enter the password manually, you can store it in plain text
    in a text file.
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the geth account command as follows:'
  id: totrans-1040
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1041
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you can understand, although placing a password in a plaintext file might
    be acceptable in a test environment, this way of creating an account might pose
    much greater risks in a production environment, where you must make sure access
    to the password file is tightly restricted.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
- en: Listing accounts
  id: totrans-1046
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once you’ve created an account, you can verify it’s indeed present in your
    node by executing the following command:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You’ll see the accounts you created through the geth account command and the
    geth console:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Updating accounts
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After geth creates and saves an account in a keyfile in the keystore folder,
    a subsequent geth release might implement a new keyfile format. In that case,
    it becomes necessary to update the account. Another reason you might want to update
    an account is because you want to change the password.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update account 47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1 you created
    earlier with the following geth command (obviously replace with your account number):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You’ll be prompted to enter the existing password, to unlock the account, and
    subsequently a new password, which you’ll have to type twice, as usual. You’ll
    then be shown the new address of the account:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The geth account update command offers the same `--password` option that the
    geth account new command provides. But in this case you can also use it to unlock
    the account for the purpose of converting it into a new keyfile format.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3\. Managing accounts with Web3 on the geth console
  id: totrans-1058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s repeat some of the earlier account management operations through the interactive
    console.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Go back to the interactive geth console. You can create accounts using the
    `web3.personal` object:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As for the geth account command, you’ll be asked to enter a password twice,
    and then you’ll be shown the account address:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Listing accounts
  id: totrans-1065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can list accounts with the interactive console by displaying the value
    of the `account` property of the `web3.eth` object. You’ll get the same result
    set you obtained with the geth account list command:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: will yield something like
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You also can directly reference a specific account of the `eth.accounts` array:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will yield something like
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Checking an account’s Ether balance
  id: totrans-1074
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can check the amount of Ether stored in an account using the following
    call, which returns it in Wei:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then you can convert it to Ether as usual:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Transferring Ether between accounts
  id: totrans-1079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can try transferring 0.0025 Ether from `accounts[1]` to `accounts[2]`.
    First of all, check the current balances of these accounts, as you saw earlier:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before transferring Ether from a certain account, for example `accounts[1]`,
    you must unlock it:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As usual, you’ll be asked to enter the password associated with this account:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, you can transfer Ether between accounts with the web3.eth.sendTransaction
    function, which takes an amount in Wei, as follows:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The value returned is the hash of the transaction sent.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: 'After a couple of minutes, recheck the balances:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the balance hasn’t been updated yet, it’s because the transaction hasn’t
    been mined yet.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4\. Managing accounts with JSON-RPC
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ll give you a quick example of how to perform account management operations
    in JSON-RPC. Open a new OS shell and you can list your accounts with the following
    JSON-RPC call:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will yield something like
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 3.5\. Revisiting SimpleCoin’s contract
  id: totrans-1097
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve covered quite a lot of ground in this chapter. If you’ve followed me
    up to this point, congratulations: you’ve completed the introduction to Ethereum
    covering the Ethereum wallet and the Go Ethereum client. You’ve also started interacting
    with the platform in many ways—through the geth commands, through Web3 instructions
    on the geth interactive console, and through direct JSON-RPC requests.'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: It’s been an intense ride. I bet you’re eager to get back to some coding! Let’s
    revisit your initial implementation of SimpleCoin, the basic cryptocurrency I
    introduced at the end of [chapter 1](kindle_split_012.xhtml#ch01), and try to
    improve it.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'Reenter the `SimpleCoin` code you saw in the previous chapter into Remix ([http://remix.ethereum.org](http://remix.ethereum.org)),
    as shown in the following listing. As usual, ignore warnings for the moment: they’ll
    disappear as you improve the code in the next chapters.'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1\. `SimpleCoin` contract as you left it in [chapter 1](kindle_split_012.xhtml#ch01)
  id: totrans-1101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code is rudimentary. Even if you don’t know the Solidity language yet,
    you can see a hardcoded value in the constructor and a lack of input validation
    in the `transfer` function. You can improve the code in several ways. First of
    all, you can parameterize the constructor so the initial money supply doesn’t
    get allocated to the address of an arbitrary test account, but to the address
    of the contract owner’s account. Then you can introduce some checks in the transfer
    function to prevent incorrect transfers. Finally, you can set things up so that
    when tokens get transferred, an event can be raised, and then clients of the smart
    contract can be notified or react to it.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1\. Improving SimpleCoin’s contract
  id: totrans-1104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll improve both the constructor and the transfer function. You can start
    from the constructor.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing the constructor
  id: totrans-1106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Rewrite the constructor as follows:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You’ve already come across the special property `msg.sender`, whose value is
    the address of the message sender (or function caller). When it comes to the constructor,
    the message sender is the account that instantiates the contract, which consequently
    becomes its owner. As a result, when the constructor gets called, the `amount`
    of tokens specified in the `_initialSupply` parameter gets allocated to the contract
    owner.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: Making transfers more robust
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rewrite the transfer function as shown in the following listing.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2\. A more robust transfer function with checks on the input
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** **Checks that the sender account has an amount of coins equal to or
    larger than what you’re trying to transfer**'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks that an arithmetic overflow hasn’t been produced on the recipient’s
    balance during the transfer operation. (This can happen if the balance, because
    of the amount received from the sender, becomes bigger than uint256.)**'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `require` special function throws an exception if the condition isn’t met.
    You can also throw the exception directly with the `throw` keyword, but this way
    of validating input is being deprecated. For example
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: could have been previously written as
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Raising an event
  id: totrans-1120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A contract can declare one or more events that can be raised in any of its
    functions. A client that’s monitoring the state of a contract can handle an event.
    For instance, you can declare an event that notifies that a transfer of SimpleCoin
    tokens has taken place:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You’ll raise this event at the bottom of the transfer function:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 3.5.2\. Trying out the amended code
  id: totrans-1125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The amended `SimpleCoin` contract will now look like the following listing.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3\. `SimpleCoin` with parameterized constructor, input validation,
    and event
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Trying out the amended constructor
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Reopen Remix if you closed it, and copy the code in [listing 3.3](#ch03ex03)
    into the editor. Then pick a test account address from the Transaction Origin
    drop-down list; for example, 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db. This
    will be the account executing the constructor, and it’ll consequently become the
    contract owner.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: Click the Run tab on the right panel. You can now enter the initial supply of
    SimpleCoin tokens next to the Deploy button, say 10,000, and then click Deploy.
    As usual, the coinBalance and transfer buttons will appear on the lower part of
    the screen, as in the previous chapter, as shown in the screenshot in [figure
    3.13](#ch03fig13).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13\. The Deploy operation now accepts the constructor input. After
    you instantiate the contract by clicking Deploy, the CoinBalance and Transfer
    buttons appear.
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-13_alt.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
- en: You can check the contract owner’s address balance in the coinBalance mapping.
    As expected, you’ll get 10,000\. You can also double-check that the balances of
    the other addresses are zero, as shown in [table 3.6](#ch03table06).
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.6\. The balances of the SimpleCoin accounts
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 10,000 |'
  id: totrans-1140
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 0 |'
  id: totrans-1142
  prefs: []
  type: TYPE_TB
- en: Trying out the amended transfer function
  id: totrans-1143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Try to transfer some SimpleCoin tokens from an account that doesn’t have any;
    for example, 0x583031d1113ad414f02576bd6afabfb302140225. Select this address from
    the Transaction Origin drop-down list and enter the following comma-delimited
    value into the transfer text box:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After clicking Transfer, you’ll get the following error message, thanks to
    the `require` check you added earlier:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now try to transfer 150 tokens from the contract owner’s account to the same
    recipient you just tried. You need to select the account starting with 0x4b0897b
    on the Transaction Origin drop-down list and reenter the following comma-delimited
    value into the transfer text box:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The operation will now be successful, as you can see in the output on the left
    side of the screen shown in [figure 3.14](#ch03fig14).
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14\. Output of successful transfer operation
  id: totrans-1151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-14_alt.jpg)'
  id: totrans-1152
  prefs: []
  type: TYPE_IMG
- en: 'If you click the arrow next to Debug, you can verify in the `logs` property
    that the Transfer event has been raised at the end of the function call:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: After rechecking all the balances, the results should match [table 3.7](#ch03table07).
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.7\. The new balances of the SimpleCoin accounts
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  id: totrans-1160
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 9,850 |'
  id: totrans-1161
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  id: totrans-1162
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 150 |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve completed this exercise. The improvements you’ve made
    weren’t particularly challenging, but making them should have helped you gain
    more familiarity with contracts.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3\. How does the coin transfer execute in the Ethereum network?
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might have understood the Solidity code that performs the coin transfer
    but...if this transfer was taking place on a real Ethereum network rather than
    on the Remix JavaScript EVM emulator, would you know where within the network
    it would be executed? And would you know what effect a transfer of SimpleCoin
    tokens would have on the blockchain? You can get the answers to these questions
    by looking at the diagram in [figure 3.15](#ch03fig15). I’ve adapted it for SimpleCoin
    from the transactional view you saw in [figure 1.8](kindle_split_012.xhtml#ch01fig08)
    ([chapter 1](kindle_split_012.xhtml#ch01)).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see other transaction lifecycle diagrams similar to this for all Dapps
    I’ll cover in the book. The lifecycle of an Ethereum transaction will be cemented
    in your head progressively throughout the book, until it becomes second nature
    to you.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15\. The lifecycle of a SimpleCoin transfer transaction. A transfer
    transaction is created when a SimpleCoin wallet invokes the `transfer()` function
    on the `SimpleCoin` smart contract on a local node of the Ethereum network. This
    is then validated and propagated throughout the network until it’s included on
    a new blockchain block by a mining node. The new block is then propagated throughout
    the network, and finally it gets back to the local node.
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-15_alt.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-1170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethereum wallet is a GUI that allows you to interact with the platform by
    creating accounts and transferring Ether intuitively.
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular Ethereum client is Go Ethereum, also known as geth. It comes
    with an interactive console that references Web3.js, a high-level interface to
    Ethereum clients.
  id: totrans-1172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s possible to interact with geth, for instance to create accounts, through
    various avenues:'
  id: totrans-1173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geth commands executed in the operating system command shell
  id: totrans-1174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Web3.js instructions executed in the geth interactive console
  id: totrans-1175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP JSON-RPC commands executed through cURL or a UI tool such as Postman
  id: totrans-1176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum smart contracts, or just *contracts*, are written in a high-level language
    such as Solidity, compiled into EVM bytecode, deployed on the Ethereum network,
    and stored in the blockchain.
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to communicate with contracts using calls, transactions, and events.
    A transaction involves the consumption of computational and network resources,
    which is calculated in a unit called gas and settled in Ether, the cryptocurrency
    of the Ethereum platform.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 4\. Deploying your first smart contract
  id: totrans-1179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1180
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a contract onto the Ethereum network
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the contract over the network
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodeless contract deployment and interaction with MetaMask
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1185
  prefs: []
  type: TYPE_TB
- en: In the first two chapters, you started building SimpleCoin, your basic cryptocurrency.
    You did so in the Remix IDE and tried out its minimal functionality through its
    JavaScript-based EVM emulator. The experience was useful to help you understand
    from a conceptual point of view what a smart contract looks like and how to activate
    and interact with it. But SimpleCoin still looks like a bit of code running in
    an IDE. Now that you’re becoming familiar with the Ethereum platform, you may
    be wondering, “Wouldn’t it be nice to see SimpleCoin in action in a more realistic
    environment?” That’s exactly what you’ll be doing in this chapter.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: You’ll deploy the `SimpleCoin` contract onto the Ethereum network, and then
    you’ll interact with it in a couple of ways. First, you’ll go through the Ethereum
    wallet, which requires you to import a copy of the blockchain locally, and then
    you’ll go through MetaMask, a third-party tool that allows you to connect to the
    Ether-eum network without accessing an Ethereum client or the wallet.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 4.1\. Deploying a contract onto the network
  id: totrans-1188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re probably used to deploying centralized applications on servers. If you’ve
    ever developed a web application, for example, you might have initially developed
    all the layers on your desktop computer. Then, after the application was mature
    enough for users or testers to test it, you deployed its components into the user
    acceptance testing (UAT) environment on one or more servers. A typical deployment
    for a web application might include
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: One web server that hosts static and dynamic web pages
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more application servers that host the services the web pages use
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more database servers that persist the data that the services use
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment of a decentralized application is quite different. Even a simple
    decentralized application consisting of only one smart contract, like your SimpleCoin
    application, would get deployed across the entire Ethereum network. As you might
    recall from the development view I introduced in [chapter 2](kindle_split_013.xhtml#ch02),
    [section 2.1.3](kindle_split_013.xhtml#ch02lev2sec3), a smart contract gets deployed
    as a special transaction whose payload is compiled EVM bytecode. You submit the
    deployment transaction through a local node, which propagates it throughout the
    Ethereum network until it hits mining nodes. The smart contract only gets deployed
    after a mining node has successfully processed the deployment transaction containing
    the contract EVM bytecode to a new block that gets appended to the blockchain.
    That block is then replicated throughout the Ethereum network, as shown in [figure
    4.1](#ch04fig01).
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two options for deploying contracts onto the network:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: Manually, through the Ethereum wallet
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through terminal commands, on geth’s interactive console
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 4.1\. A contract written in a high-level language such as Solidity is
    compiled into EVM bytecode and deployed to the network through a deployment transaction
    containing the contract EVM bytecode, which is executed through a local full node
    of the network. The deployment transaction is propagated throughout the network;
    then it’s processed by a mining node and included in a new block that gets replicated
    throughout the network. It’s like any other transaction, except that what’s being
    stored on the blockchain isn’t Ether or data but EVM bytecode.
  id: totrans-1197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-01_alt.jpg)'
  id: totrans-1198
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll deploy the `SimpleCoin` contract manually. By doing
    so, you’ll go through the deployment process in a visual and intuitive way that
    will help you learn quickly.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get used to deploying contracts through the Ethereum wallet, you’ll
    be ready for the next step: command-based deployment. Though it may seem slightly
    intimidating at first, deploying contracts through geth’s console is a useful
    exercise because it helps you understand the platform more thoroughly. You’ll
    explore this in the next several chapters. For now, I’ll quickly recap what you
    know:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '*The mechanisms to trigger deployment*—You know that you can deploy contracts
    manually through the Ethereum wallet or by using commands on geth’s console. (You’ll
    see these in action soon.)'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What happens during deployment*—The contract’s bytecode gets stored on the
    blockchain following the execution of its deployment transaction.'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what exactly is the Ethereum network? I’ll answer that question in the next
    section.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1\. Ethereum public networks
  id: totrans-1204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you connected to Ethereum in the previous chapter, you might not have
    noticed that you connected to two different networks:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: From the Ethereum wallet, you connected to *Ropsten*, a public test network.
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From geth, you connected to *Mainnet*, the public production network.
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ropsten* is the public test network that Ethereum provides for mining based
    on proof of work (PoW), which is the current algorithm used in the public production
    network. If you followed the instructions I gave you, your Ethereum wallet is
    already pointing to the Ropsten network, and you only have fake Ether in your
    accounts, which you generated through CPU mining.'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: If you left your geth client running from the previous chapter, it’s pointing
    to *Mainnet*, the production network. Ether moved between accounts in this network
    is real. You should use this network only to perform transactions against production
    Dapps; you should avoid it during development.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Another public test network called *Kovan* is available, and it supports mining
    performed with a new algorithm called Proof of Authority. So far, this has only
    been implemented in the Parity client, so it’s outside the scope of this book.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll deploy the `SimpleCoin` contract to Ropsten through
    the wallet. As a result, you don’t need to make any environmental configuration
    changes yet.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2\. Deploying SimpleCoin with the Ethereum wallet
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start up the Ethereum wallet—make sure the sync mode is Fast or Full and wait
    until it’s fully synchronized—and open the Contracts screen by clicking Contracts
    on the top bar, near the top-right corner. You’ll see two main options:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '*Deploy New Contract*—You can deploy a new contract by supplying its Solidity
    code.'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Watch Contract*—You can reference a contract that already has been deployed
    so you can interact with it.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Deploy New Contract. When the Deploy Contract screen opens, you can decide
    which account will become the contract owner. Choose Account 1, and then click
    the Solidity Contract Source Code tab at the bottom of the screen and paste the
    `SimpleCoin` code from the end of [chapter 3](kindle_split_014.xhtml#ch03), as
    shown in the following listing. (Make sure the constructor and functions are declared
    as *public* to be compiled in the wallet; I’ll explain function access modifiers
    such as public in [chapter 5](kindle_split_017.xhtml#ch05).)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1\. Latest version of `SimpleCoin` (from [chapter 3](kindle_split_014.xhtml#ch03))
  id: totrans-1217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Once you’ve pasted the code, the wallet will compile it into EVM bytecode, and
    a drop-down list will appear on the right-hand side. Pick Simple Coin from the
    list and enter 10000 as the constructor parameter. Finally, click Deploy at the
    bottom of the screen, as shown in [figure 4.2](#ch04fig02).
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2\. After you enter the Solidity code of a contract, the wallet compiles
    it into EVM bytecode. Supply the contract parameters, click Deploy, and a new
    dialog box will confirm the deployment transaction.
  id: totrans-1220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-02_alt.jpg)'
  id: totrans-1221
  prefs: []
  type: TYPE_IMG
- en: 'A new dialog box will appear, as shown in [figure 4.3](#ch04fig03). You’ll
    be asked to enter the password and to send the deployment transaction. Remember:
    you need Ether in your account to be able to submit the transaction! Once you
    send the deployment transaction, you can check its status in the Latest Transactions
    section of the wallet main screen. There you can see that the deployment transaction
    is treated like any other transaction.'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3\. A dialog box asks you to enter the password of the account that
    you’ll deploy the contract from. After you supply it and click Send, a deployment
    transaction is generated and sent to the network.
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-03_alt.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
- en: Once the contract has received all the necessary network confirmations, which
    you can view in the Latest Transactions panel (see [figure 4.4](#ch04fig04)),
    go back to the Contracts screen. You’ll see Simple Coin with a balance of zero
    Ether ([figure 4.5](#ch04fig05)).
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4\. After a contract transaction has been submitted to the network,
    you can monitor its network confirmations in the Latest Transactions panel of
    the Contracts screen.
  id: totrans-1226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-04_alt.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5\. After the contract receives 12 confirmations, which makes it very
    likely the deployment transaction is permanently stored on the blockchain, a deployed
    contract appears in the Contracts panel.
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-05_alt.jpg)'
  id: totrans-1229
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
- en: Definition
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Transaction confirmations* indicate the depth of the transaction in the blockchain.
    A new confirmation is received as soon as a new block is appended to the blockchain
    after the block containing the transaction in question. The probability of a block
    reversal decreases exponentially as the number of confirmations increase, so a
    transaction is considered consolidated after 12 confirmations. (That means 12
    blocks have been added to the blockchain after the block containing the transaction.)'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1233
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve deployed your first contract on the Ethereum network.
    Now you can interact with the contract, much as you did earlier with Remix. You
    can start by moving SimpleCoin tokens between accounts and verifying the expected
    balances.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Interacting with the contract
  id: totrans-1235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting to move SimpleCoin tokens, go back to the wallet’s main screen
    and add two more accounts. (Remember to take note of the related passwords.) These
    extra accounts will become handy when testing contract operations. I recommend
    you copy all the account addresses you have in your wallet to a temporary text
    file. [Table 4.1](#ch04table01) shows what it would contain in my case.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1\. Ethereum wallet account addresses
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account name | Account address |'
  id: totrans-1238
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
- en: '| Main account | 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
- en: '| Account 2 | 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
- en: '| Account 3 | 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
- en: '| Account 4 | 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-1244
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To copy an address, select it, and then click Copy Address. Alternatively, you
    can use the usual Ctrl+C shortcut. Either way, the wallet will ask you to confirm
    you want to go ahead with this operation. (There is risk that malware may replace
    the address.)
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
- en: 'Now go back to the Contracts screen and click SimpleCoin. At the top of the
    screen, just below the name of the contract, you’ll see the contract address,
    which is the account address of the contract in the blockchain. You’ll notice
    that the area associated with the `SimpleCoin` contract is logically divided into
    two parts: Read from Contract on the left and Write on Contract on the right.
    This arrangement is similar to the color codes you saw in Remix for read-only
    functionality (blue) and write functionality (red).'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1\. Checking coin balances
  id: totrans-1249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can first check the coin balance of all accounts by entering the address
    of each account next to the coin balance textbox. The expected balances are shown
    in [table 4.2](#ch04table02).
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2\. Expected account balances
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1252
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1253
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |'
  id: totrans-1256
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
- en: What happens if you try to check the balance of an invalid address? For example,
    replace the last digit of the main account (starting with 0xedDE06bC) with an
    8 and try to check the coin balance. You won’t be allowed to enter such an address
    because the wallet will consider its checksum invalid. But you will be allowed
    to enter any valid Ethereum address, even if it’s not associated with your accounts.
    (You can grab some to try from [https://etherscan.io/](https://etherscan.io/).)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2\. Transferring coins
  id: totrans-1259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you can move some coins around. You can start with a transfer of 150 SimpleCoins
    from the Main Account to Account 3\. This is the same operation you performed
    on Remix in the previous chapter. Pick Transfer from the Select Function drop-down
    in the Write to Contract panel. All the input fields required for the coin transfer
    will appear, as in [figure 4.6](#ch04fig06).
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Pick the Main Account from the Execute From list, then set the address of Account
    3 in the To field and an amount of 150. After you click Execute, you’ll be asked
    to enter the password of the Main account to digitally sign the transaction.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: If you select the Watch Contract Events box in the Latest Events pane, you’ll
    soon see the details of the transaction you’ve sent. At this point, you can recheck
    the balances of all addresses. The expected balances are shown in [table 4.3](#ch04table03).
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3\. Expected updated account balances
  id: totrans-1263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1264
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1266
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1267
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |'
  id: totrans-1268
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1269
  prefs: []
  type: TYPE_TB
- en: Figure 4.6\. Checking the SimpleCoin balance is a read-only operation, so you
    only need to specify the input address. Transferring coins is a write operation.
    As seen here, you have to specify the number of coins to be transferred, the destination
    address, and the sending account.
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-06_alt.jpg)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
- en: Now try to move 50 coins from Account 3 to Account 2 and recheck the balances
    after the transaction has appeared in the Latest Events panel. You’ll notice that
    the only accounts listed in the Execute From drop-down list are the Main Account
    and Account 2\. This is because the wallet doesn’t allow you to execute a transaction
    from an account with no Ether in it.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [chapter 2](kindle_split_013.xhtml#ch02), the executing account
    must pay a transaction fee calculated in gas but settled in Ether to perform a
    transaction. For Accounts 3 and 4 to be useful, you must send some Ether to them
    from the Main Account. You can perform this Ether transfer from the Send screen,
    as you did in the previous chapter when you set up Account 2\. As usual, you can
    monitor the Ether transfer transactions on the Latest Transactions panel and wait
    for them to complete. Once all accounts own some Ether, you’re ready to perform
    a transaction.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `SimpleCoin` contract screen and pick the transfer function again.
    The Execute From drop-down list will now show all the accounts, so you can pick
    Account 3\. Enter the address of Account 2 in the To textbox and 50 in the Amount
    field. When you click Execute, you’ll be asked for the password for Account 3,
    the sending account. After the transaction has been confirmed, recheck the balances.
    The new expected balances are shown in [table 4.4](#ch04table04).
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.4\. Updated account balances after second transfer
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1276
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1277
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1278
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  id: totrans-1280
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1281
  prefs: []
  type: TYPE_TB
- en: Trying to transfer unavailable coins
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you’ll remember, the code of the SimpleCoin `transfer` function performs
    some checks before modifying the balances of the sender and recipient addresses.
    It prevents an account from attempting to transfer unavailable coins by throwing
    an error. You can see what happens if you try to do so through the wallet. For
    example, try to move 200 coins from Account 4 to Account 3\. As expected, you’ll
    get an error message indicating the transaction will fail, as shown in [figure
    4.7](#ch04fig07).
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7\. If a transaction generated from a write operation, such as `SimpleCoin.transfer()`,
    fails validation checks, it can’t be sent to the network.
  id: totrans-1284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-07_alt.jpg)'
  id: totrans-1285
  prefs: []
  type: TYPE_IMG
- en: You might be surprised that the error message is thrown before the transaction
    has even been sent out. This happens because the wallet verifies transactions
    locally, before sending, as any node would do. If an error is returned, the wallet
    doesn’t propagate the transaction to the network, and you receive an error message
    immediately.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You’ve fully, manually, tested `SimpleCoin` on the public test network.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: So far, this chapter has given you an idea of how to deploy a smart contract
    to a public network without having to run a full Ethereum node. You performed
    it through the Ethereum wallet, which, under the hood, still connects to a fully
    synchronized copy of the blockchain. But you might be wondering whether you can
    achieve the same thing without having a local synchronized copy of the blockchain.
    The answer is yes. As we’ll explore in the next section, you can connect to a
    set of publicly accessible nodes exposed by a Chrome plugin called Metamask.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. Nodeless deployment through MetaMask
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MetaMask* is a Chrome extension that connects you to an external set of Ethereum
    nodes, as you can see in [figure 4.8](#ch04fig08). It allows you to deploy a contract
    to a public network and interact with it without having to install and maintain
    any Ethereum software. As an alternative, if you don’t want to use Chrome, you
    can download the Brave browser and install MetaMask as an extension. MetaMask
    is especially handy if you don’t develop smart contracts continuously and don’t
    want the inconvenience of having to update the wallet or Go Ethereum client and
    resynchronize the blockchain every time you resume your development.'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8\. When connecting to Ethereum through the Ethereum wallet or the
    Go Ethereum client console, you do so through a local node. When connecting to
    Ethereum through Metamask, you do so through a remote node.
  id: totrans-1291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-08_alt.jpg)'
  id: totrans-1292
  prefs: []
  type: TYPE_IMG
- en: In the next section, you’ll install MetaMask. Then you’ll redeploy `SimpleCoin`
    to Ropsten through MetaMask and interact with it, completely bypassing your local
    geth client and Ethereum wallet.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1\. Installing MetaMask
  id: totrans-1294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can install the MetaMask chrome extension from this url: [http://mng.bz/8JzB](http://mng.bz/8JzB).
    After adding the extension, you should see the MetaMask icon next to the browser
    address bar.'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: You can now start to set up a MetaMask wallet by clicking on the MetaMask icon.
    You’ll be invited to accept a privacy notice and terms and conditions (at your
    own risk). Then you’ll be asked to create a new password, as shown in [figure
    4.9](#ch04fig09).
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9\. Creation of a password to secure the MetaMask wallet
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-09_alt.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
- en: Enter your new (possibly secure) password and click Create. You’ll be advised
    to copy and securely store the system-generated 12-word recovery passphrase. The
    wallet will be created after you confirm you’ve done so, and at that point you’ll
    see on the top left, next to the MetaMask icon, the name of the network you’re
    connected to. Initially, you’re connected to Main Ethereum Network, as shown in
    [figure 4.10](#ch04fig10).
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10\. MetaMask initially points to Main Ethereum Network.
  id: totrans-1300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-10_alt.jpg)'
  id: totrans-1301
  prefs: []
  type: TYPE_IMG
- en: Given that you’ll deploy `SimpleCoin` onto a test network, change your current
    network by clicking Main Ethereum Network and selecting the Ropsten Test Network
    from the drop-down list, as shown in [figure 4.11](#ch04fig11).
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11\. It’s possible to connect to various Ethereum networks through
    MetaMask.
  id: totrans-1303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-11_alt.jpg)'
  id: totrans-1304
  prefs: []
  type: TYPE_IMG
- en: You’ll notice the default account has nothing to do with any of the accounts
    you have in your Ropsten Ethereum wallet. And this default test account hasn’t
    got any Ether, so you won’t be able to do much with it. To import some of your
    existing Ropsten accounts, which already contain Ether, click the menu icon on
    the top right, and then select Import. In the Import dialog box, you’ll see a
    Select Type drop-down list. Select JSON File, as shown in [figure 4.12](#ch04fig12).
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12\. Dialog box for importing accounts from JSON files
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-12_alt.jpg)'
  id: totrans-1307
  prefs: []
  type: TYPE_IMG
- en: Now you have to supply the JSON file containing the private key of your existing
    Ropsten account. Remember, the key pairs of your Ropsten account are held in the
    testnet keystore, which, depending on your OS, you can find in one of the locations
    shown in [table 4.5](#ch04table05).
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.5\. Testnet keystore locations
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| System | Keystore path |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
- en: '| Windows | C:\Users\username\%appdata%\Roaming\Ethereum\testnet\keystore |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
- en: '| Linux | ~/.ethereum/testnet/keystore |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
- en: '| Mac | ~/Library/Ethereum/testnet/keystore |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
- en: 'The testnet keystore folder should contain a list of files whose names contain
    the timestamp and the account address they refer to:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T08-49-46.377533700Z--edde06bc0e45645e2f105972bdefc220ed37ae10`'
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T13-26-18.696630000Z--4e6c30154768b6bc3da693b1b28c6bd14302b578`'
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-36.890638200Z--70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02`'
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-47.794428600Z--c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4`'
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the file extension isn’t present, these are JSON files. For example,
    the second file on the list refers to account 4e6c30154768b6bc3da693b1b28c6bd14302b578\.
    If you open the file with a text editor, such as Notepad in Windows, you should
    see JSON content similar to this:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the MetaMask Import Account dialog box, click Choose File, navigate to your
    testnet keystore, and then pick the file related to the account you want to import.
    You must supply the password you entered when creating this account, and then
    click Import. After a few seconds, you should see the details of the account you’ve
    imported, including the Ether contained in it, as shown in [figure 4.13](#ch04fig13).
    Once you’ve imported a couple of your existing Ropsten accounts, you can proceed
    to the deployment of `SimpleCoin`.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13\. After you import an account from the keystore, all its details
    appear on MetaMask.
  id: totrans-1323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-13_alt.jpg)'
  id: totrans-1324
  prefs: []
  type: TYPE_IMG
- en: 4.3.2\. Deploying SimpleCoin through MetaMask
  id: totrans-1325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To deploy `SimpleCoin`, first open Remix and enter the latest version of `SimpleCoin`,
    the same one you entered into the wallet, shown earlier in [listing 4.1](#ch04ex01).
    Now pick the Injected Web3 option in the Environment drop-down list in the Run
    tab of the right-hand side panel, as shown in [figure 4.14](#ch04fig14).
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14\. The screenshot shows how you can configure Remix to use external
    MetaMask nodes (rather than the local JavaScript Virtual Machine emulator) by
    selecting Injected Web3 in the Environment drop-down list.
  id: totrans-1327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-14_alt.jpg)'
  id: totrans-1328
  prefs: []
  type: TYPE_IMG
- en: Remix will detect MetaMask, and it’ll use one of the MetaMask nodes rather than
    the local JavaScript EVM emulator. If no account is showing in the Account drop-down
    list, refresh the Remix webpage and the account currently selected in MetaMask
    will be selected.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: You can trigger `SimpleCoin`’s deployment by clicking the red Deploy button.
    Account 2, whose address starts with 0x4e6c30154, is the only option available
    and is currently selected in the Account drop-down list box. That account will
    deploy the contract.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: After you click Deploy, you’ll see a dialog box summarizing information on the
    executing account and transaction costs for the deployment transaction. You’ll
    also be asked to confirm you want to go ahead with it, as you can see in [figure
    4.15](#ch04fig15).
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15\. After configuring Remix to point to external Metamask nodes and
    starting the deployment of a contract (such as `SimpleCoin`), you get a (deployment)
    transaction confirmation dialog box from Metamask. This shows information on the
    account executing the deployment transaction and on transaction costs. The dialog
    box also asks the user to confirm whether to go ahead with the deployment of the
    contract.
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-15_alt.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
- en: After clicking Confirm, you can check the transaction status in the bottom area
    of the Metamask wallet. The status will move from Submitted to Confirmed, as shown
    in [figure 4.16](#ch04fig16).
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: If you click the label Transaction Number while the contract is in status Submitted,
    and then after it has moved to Confirmed, you’ll see the transaction details from
    the Etherscan website, as shown in [figure 4.17](#ch04fig17). As you can see,
    Etherscan also shows the destination address (starting with 0x0c9189e4d6) of the
    contract.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16\. It’s possible to monitor the status of the deployment transaction
    in the bottom area of the Metamask wallet. This will change from Submitted to
    Confirmed.
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-16_alt.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17\. Transaction details from the Etherscan website, invoked when clicking
    the (Submitted or Confirmed) status on the MetaMask wallet
  id: totrans-1338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-17_alt.jpg)'
  id: totrans-1339
  prefs: []
  type: TYPE_IMG
- en: If you move back to Remix, you’ll see some deployment details below the Deploy
    button, including the deployment address, which is the same one you saw on the
    Etherscan page. You can grab the address by clicking the Copy Address link, as
    shown in [figure 4.18](#ch04fig18).
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18\. After the completion of the deployment transaction, the contract
    address is shown in Remix, below the Deploy button.
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-18_alt.jpg)'
  id: totrans-1342
  prefs: []
  type: TYPE_IMG
- en: Well done! You’ve redeployed `SimpleCoin` on Ropsten through MetaMask. Now you
    can see how you can interact with it through MetaMask.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3\. Interacting with SimpleCoin through MetaMask
  id: totrans-1344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4.18](#ch04fig18) also shows that after deploying `SimpleCoin`, Remix
    displays two buttons: CoinBalance and Transfer. These are exactly the same buttons
    that appeared when you created the contract for the first time on the JavaScript
    VM, back in [chapter 1](kindle_split_012.xhtml#ch01). This time, though, you’ll
    be interacting with a contract instantiated on a real network.'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: The first operation you can perform is to check the token balance of Account
    2, the account that deployed the contract. Enter “0x4e6c30154768b6bc3da693b1b28-c6bd14302b578”
    (remember, as usual, to surround the address with double quotes) and click CoinBalance.
    You’ll immediately get 10,000, as expected. As with checking balances through
    the Ethereum wallet, this operation is read-only and doesn’t produce a transaction.
    Consequently, you don’t need to authorize it.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: 'Now move 250 tokens from Account 2 to Account 3\. Enter this into the Transfer
    text box:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Click Transfer. This is a write operation, so the MetaMask transaction confirmation
    dialog box pops up, as shown in [figure 4.19](#ch04fig19). You can authorize it
    from Account 2\. Click Confirm and follow the transaction status in the MetaMask
    dialog box.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19\. To transfer SimpleCoin tokens, which is a contract-state write
    operation, the sending account needs to be authorized. Subsequently, the MetaMask
    transaction confirmation dialog box is shown to get user confirmation.
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-19_alt.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
- en: If you click on the transaction number icon, you’ll see the transaction details
    in Etherscan. You can now go back to Remix and check the transaction details there
    as well.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Both Etherscan and Remix confirm that the move of 250 SimpleCoin tokens from
    Account 2 to Account 3 has been successful, but you can double-check the new balances
    of these accounts with the `coinBalance` function, which should match those in
    [table 4.6](#ch04table06).
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.6\. Account balances after transferring 250 tokens
  id: totrans-1354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1355
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1356
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 9,750 |'
  id: totrans-1357
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 250 |'
  id: totrans-1358
  prefs: []
  type: TYPE_TB
- en: I’ll stop here, but I’d encourage you to generate some error messages, for example
    by trying to move unavailable coins, as you did previously with the Ethereum wallet.
    Doing so will allow you to confirm whether the contract also works correctly on
    MetaMask.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    the Ethereum wallet.
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum wallet communicates with Ethereum through a local geth instance.
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    MetaMask.
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
