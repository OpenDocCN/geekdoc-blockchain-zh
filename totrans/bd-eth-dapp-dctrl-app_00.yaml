- en: Part 1\.
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分。
- en: '[Part 1](#part01) is a high-level introduction to Ethereum Dapps and related
    technologies. [Chapter 1](kindle_split_012.xhtml#ch01) introduces decentralized
    applications. [Chapter 2](kindle_split_013.xhtml#ch02) presents the blockchain
    and smart contracts. In [chapter 3](kindle_split_014.xhtml#ch03), you’ll meet
    the Ethereum platform, including the Ethereum Virtual Machine (EVM), the Go Ethereum
    (geth) client, and the Ethereum wallet. In this part, you’ll establish the foundation
    you need to progress through the book. You’ll also implement your first Dapp—a
    simple cryptocurrency—and, in [chapter 4](kindle_split_015.xhtml#ch04), deploy
    it on a public test network.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 【第一部分】（#part01）是对以太坊Dapps和相关技术的高级介绍。【第1章】（kindle_split_012.xhtml#ch01）介绍了去中心化应用。【第2章】（kindle_split_013.xhtml#ch02）阐述了区块链和智能合约。【第3章】（kindle_split_014.xhtml#ch03）介绍了以太坊平台，包括以太坊虚拟机（EVM）、Go
    Ethereum（geth）客户端和以太坊钱包。在本部分，你将建立继续阅读本书所需的基础知识。你还将实现你的第一个Dapp——一个简单的加密货币——在【第4章】（kindle_split_015.xhtml#ch04），将其部署在公共测试网络上。
- en: Chapter 1\. A first look at decentralized applications
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章。初探去中心化应用
- en: '|  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '**This chapter covers**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容概述**'
- en: What a decentralized application is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用是什么
- en: What a Dapp looks like and how it works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用的样子以及它是如何工作的
- en: Dapp terminology
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapp术语
- en: Suitable and less suitable Dapps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合和不适合的Dapps
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: 'How many times have you found yourself in the following situation? You were
    browsing around to buy the latest gadget and were comparing prices online, when
    you came across [SmallWebRetailer.com](http://SmallWebRetailer.com) that was offering
    it 30% cheaper than [WellKnown.com](http://WellKnown.com). You quickly put the
    item in the basket, fearing the price would rise at any moment, and entered your
    postal address and credit card details, but suddenly...you got cold feet. You
    started to wonder: Is the price too good to be true? What if this unknown [SmallWebRetailer.com](http://SmallWebRetailer.com)
    is a scam? Will they run off with my money? After a few minutes of hesitating
    on the Buy button, you opened a new browser tab and went straight to [WellKnown.com](http://WellKnown.com).
    You submitted the order, aware you might have overpaid 30% for your gadget.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次发现自己处于以下情况？你在浏览购买最新小玩意，并在网上比较价格时，发现[SmallWebRetailer.com](http://SmallWebRetailer.com)比[WellKnown.com](http://WellKnown.com)便宜30%。你迅速把商品加入购物车，担心价格随时会上涨，并输入了你的邮寄地址和信用卡详情，但突然...你打退堂鼓。你开始怀疑：这个价格是不是好的不真实？如果这个不知名的[SmallWebRetailer.com](http://SmallWebRetailer.com)是个骗局怎么办？他们会卷走我的钱吗？在犹豫了几分钟是否点击购买按钮后，你打开了一个新浏览器标签页，直接访问了[WellKnown.com](http://WellKnown.com)。你提交了订单，意识到你可能为这个小玩意多付了30%的钱。
- en: Why did you panic? Perhaps you didn’t trust [SmallWebRetailer.com](http://SmallWebRetailer.com).
    Perhaps you didn’t want to waste your time contacting the credit card company
    and possibly waiting for a refund if the transaction turned sour.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么会恐慌？也许你不信任[SmallWebRetailer.com](http://SmallWebRetailer.com)。也许你不想浪费时间联系信用卡公司，可能还要等待如果交易变坏时的退款。
- en: 'What if you could’ve bought the gadget from the same small, unknown retailer
    through an “alternative e-commerce application” that guaranteed the seller couldn’t
    access your money until you’d confirmed safe delivery of your order? What if that
    guarantee hadn’t been provided by the seller or by a single third party, but by
    many independent parties participating in a platform designed to process transactions
    according to conditions encoded in software anyone could inspect? Hold on, probably
    I’ve said it too fast. I’ll repeat it more slowly:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能通过一个“替代电子商务应用”从同一个小型未知零售商那里购买小玩意，这个应用能保证卖家在您确认订单安全交付之前无法接触到您的钱，那会怎样？如果这个保证不是由卖家或单一的第三方提供，而是由许多独立参与的一个平台提供，这个平台旨在根据任何人都可以检查的软件条件处理交易呢？慢着，我可能说得有点快了。我会更慢地重复一遍：
- en: What if the money transfer was held until delivery, not by the retailer or a
    third party but by many participants in the platform?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资金转账在交付后才被释放，不是由零售商或第三方，而是由平台上的许多参与者来持有，那会怎样？
- en: What if the rules for escrowing and then releasing the money transfer were encoded
    in logic, not subjected to manual interaction?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资金托管和释放的规则是通过逻辑编码，而不是受人工交互影响呢？
- en: What if, in case you were still unconvinced, you could inspect the code yourself?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你仍然不够信服，那假如你可以亲自检查代码呢？
- en: I bet you’d click Buy, confident your funds would be safely stored on this platform
    until the delivery arrived. Such systems do exist, and they’re called *decentralized
    applications*. Decentralized marketplaces, such as OpenBazaar ([https://openbazaar.org/](https://openbazaar.org/)),
    work this way. The mechanism by which funds are routed to the seller only when
    you’ve confirmed safe delivery of the goods is called a *smart contract*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，您会点击购买，自信您的资金将安全地存储在这个平台上，直到货物送达。这样的系统确实存在，它们被称为*去中心化应用程序*。像OpenBazaar这样的去中心化市场就是这样的运作方式。[https://openbazaar.org/](https://openbazaar.org/)。资金在您确认商品安全送达后才转到卖家的机制称为*智能合约*。
- en: Decentralized applications, also known as *decentralized apps* or *Dapps* (generally
    pronounced dee-apps), are part of a new wave of web applications meant to increase
    the transparency around commercial transactions, governmental processes, supply
    chains, and all those systems that currently require mutual trust between customer
    and supplier, user and provider. The objective of Dapps is to minimize or eliminate
    the need for any trust between the participants in a system interaction, with
    the aim of empowering users beyond what Web 2.0 has delivered. Some claim Dapps
    could be the backbone of Web 3.0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序，也被称为*去中心化应用*或*Dapps*（通常发音为dee-apps），是新一代网络应用程序的一部分，旨在增加商业交易、政府流程、供应链以及所有目前需要客户和供应商、用户和提供商之间相互信任的系统的透明度。Dapps的目标是尽量减少或消除系统参与者之间的信任需求，以实现超越Web
    2.0的用户赋权。一些人认为Dapps可能是Web 3.0的支柱。
- en: Assuming you have programming experience—even better if it’s in JavaScript—and
    some familiarity with web applications, this book will teach you how to build
    Dapps made of one or more smart contracts controlled by a user interface. By the
    end of this book, you’ll be able to not only write smart contract code but design,
    implement, test, debug, deploy, and secure a full end-to-end decentralized application.
    Along the way, you’ll also learn a new language, a new platform, and, most of
    all, a new way of thinking about, designing, and running applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有编程经验——如果使用JavaScript就更好了——并且对网络应用程序有些了解，这本书将教您如何构建由一个或多个由用户界面控制的智能合约组成的Dapps。到本书结束时，您将不仅能够编写智能合约代码，还能够设计、实现、测试、调试、部署和一个完整的端到端去中心化应用程序。在这个过程中，您还将学习一种新语言，一个新平台，以及最重要的，一种关于设计、思考和运行应用程序的新方式。
- en: In this first chapter, I’ll give you a high-level overview of Dapps. I’ll explain
    in detail what they are, what they look like, what technology stack they’re built
    on, and when it makes sense to build them. Best of all, I’ll help you start building
    your own! Let’s start our journey.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我将为您提供一个关于Dapps的高级概览。我将详细解释它们是什么，长什么样子，建立在什么技术栈上，以及在什么情况下构建它们是有意义的。更重要的是，我会帮助您开始构建您自己的Dapp！让我们开始我们的旅程。
- en: 1.1\. What is a Dapp?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 什么是Dapp？
- en: 'Before I talk about decentralized applications, I’ll refresh a concept you’re
    already familiar with, most likely without realizing it: that of a *centralized
    application*. Probably you’ve never heard this expression before because conventional
    web and enterprise applications are implicitly centralized with respect to their
    users. I can hear you asking, what does “centralized” mean exactly?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我谈论去中心化应用程序之前，我将刷新一个您可能已经熟悉但很可能没有意识到的概念：那就是*中心化应用程序*。您可能从未听说过这个表达，因为传统的网络和企业应用程序在其用户方面是隐式中心化的。我能听到您在问，“中心化”到底是什么意思？
- en: 'A *centralized application* or system is controlled by a single or *central*
    entity: an individual, company, institution, governmental agency, and so on. The
    entity hosts the system directly on its premises or through a service or cloud
    provider and has full control of all the components and layers of the system architecture.
    The user trusts the good faith of the central entity and decides whether to access
    its system depending on the entity’s reputation. From the point of view of the
    user, the system is either *trusted* or not. This is how most web and enterprise
    applications are designed today.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*中心化应用程序*或系统是由一个或*中央*实体控制的：一个人、公司、机构、政府机构等等。实体直接在其场地上或通过一个服务或云提供商托管系统，并拥有系统架构中所有组件和层的全权控制。用户信任中央实体的善意，并根据实体的声誉决定是否访问其系统。从用户的角度来看，系统要么是*可信*的，要么不是。这就是大多数网络和企业应用程序目前的设计方式。
- en: '[Figure 1.1](#ch01fig01) illustrates a typical interaction between a user and
    a *centralized* *trusted* system. You shouldn’t find anything surprising about
    it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1（#ch01fig01）展示了用户与一个*集中式* *可信*系统之间的典型交互。你不应该觉得它有什么奇怪的地方。
- en: Figure 1.1\. A centralized application is strongly associated with the single
    entity controlling it. Consequently, users decide whether to access it depending
    on their trust of the entity.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1。集中式应用与控制它的单一实体有很强的关联。因此，用户根据对实体的信任来决定是否访问它。
- en: '![](Images/fig01-01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-01_alt.jpg)'
- en: 'Let’s move on to decentralized applications. If you consider for a moment the
    alternative e-commerce application I introduced earlier, you’ll agree it has advantages
    with respect to [SmallWebRetailer.com](http://SmallWebRetailer.com):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看去中心化应用。如果你稍微考虑一下我之前介绍的替代电子商务应用，你会同意它在[SmallWebRetailer.com](http://SmallWebRetailer.com)方面有一些优势：
- en: '*Favorable transaction conditions*—The transaction would be completed and the
    money would be fully transferred to the retailer only when the retailer had complied
    with all the conditions associated with the transaction, such as your confirmation
    of safe delivery. This would remove one of the biggest reservations you had about
    [SmallWebRetailer.com](http://SmallWebRetailer.com): uncertainty whether you’d
    get the delivery and what would happen to your money if not.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有利的交易条件——只有当零售商遵守与交易相关的所有条件，例如你确认安全交货时，交易才会完成，并将全部款项转移给零售商。这将消除你对[SmallWebRetailer.com](http://SmallWebRetailer.com)的最大疑虑之一：是否能够收到交货以及如果不能，你的钱会怎样。
- en: '*Independent transaction execution and verification*—The transaction wouldn’t
    be processed by the retailer or a single third party but by one of many participants
    in the platform supporting the e-commerce application, and then all the participants
    in the platform would independently verify it. The mechanism that all parties
    would use to agree on the verification of a transaction is called *consensus*
    (defined in the callout). The consensus mechanism would reassure you that the
    promised transaction conditions would be enforced and verified by many independent
    parties rather than an unknown retailer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的交易执行和验证——交易不会由零售商或单一的第三方处理，而是由支持电子商务应用的平台上的众多参与者之一处理，然后平台上的所有参与者都会独立地验证它。所有各方用来对交易的验证达成一致的机制被称为*共识*（在注释中定义）。共识机制会让你相信，承诺的交易条件将由许多独立方执行和验证，而不是一个不知名的零售商。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: Consensus is a *distributed and trustless* form of agreement on the verification
    of a transaction. *Distributed* means that an independent central authority doesn’t
    perform the verification of a transaction; instead, all parties contribute to
    and agree on its verification. *Trustless* means that parties don’t need to trust
    each other to agree on the verification outcome. Consensus is reached when a qualified
    majority of the participants have agreed on the outcome of the transaction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 共识是一种*分布式和无需信任*的对交易验证达成一致的形式。*分布式*意味着独立的中央权威机构不执行交易的验证；相反，所有各方共同贡献并同意其验证。*无需信任*意味着各方不需要相互信任就能对验证结果达成一致。当参与者的合格多数同意了交易的结局时，共识就达成了。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '*Transparency*—You’d be able to check the code processing the transaction and
    verify that it was observing the specified conditions before transferring your
    money to the retailer. This would give you a further level of reassurance that
    the application was executing under the promised terms.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度——你将能够检查处理交易的代码并验证它是否在转账给零售商之前遵守了指定的条件。这将给你额外的信心，应用程序是在承诺的条款下执行的。
- en: You can deliver all of these requirements by building the alternative e-commerce
    application as a network of processing nodes of equal importance and functionality,
    each owned by a different party. Each node would
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过构建作为一个由平等重要和功能的处理节点网络的替代电子商务应用来实现所有这些要求，每个节点由不同的方拥有。每个节点将
- en: be able to process a transaction the same way other nodes do
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够像其他节点一样处理交易
- en: verify all transactions in the same way other nodes do
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像其他节点一样验证所有交易
- en: contribute in an equal way to the outcome of a transaction
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以平等的方式对交易结果做出贡献
- en: 'The consequence of this architecture would be that the processing would be
    decentralized to a network of independent nodes rather than being centralized
    to a specific set of servers that a specific entity owns. Such decentralization
    would relieve the user from having to trust a specific entity: the user would
    have to trust only the design of the network as a whole.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的后果将是处理过程将分散到一组独立节点的网络中，而不是集中到特定实体拥有的特定服务器上。这种去中心化将使用户不必信任特定实体：用户只需信任整个网络的设计。
- en: Applications built on this architecture are known as *decentralized applications*.
    I’ll provide another example to make the concept clearer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此架构的应用程序被称为**去中心化应用**（Dapp）。我将提供另一个例子以使这个概念更清晰。
- en: 1.1.1\. Dapps vs. conventional centralized applications
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. Dapps与传统的中心化应用
- en: 'To explain more clearly the benefit of building a Dapp, as opposed to developing
    a conventional centralized application, I’ll illustrate for you a typical use
    case: an electronic voting application.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地解释构建Dapp的好处，以及与开发传统中心化应用相比的优点，我将为您举一个典型的用例：一个电子投票应用。
- en: Centralized voting application
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中心化投票应用
- en: Traditional centralized voting applications are generally provided by a company
    to facilitate shareholder voting or by a local administration or government to
    facilitate the approval or selection of law proposals. The institution running
    the application owns it, directly or indirectly, at least during the voting session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的中心化投票应用程序通常由公司提供，以促进股东投票，或由地方政府或政府提供，以促进法律提案的批准或选择。运行应用程序的机构在投票期间至少直接或间接拥有它。
- en: As you can see at the top of [figure 1.2](#ch01fig02), a centralized voting
    application runs on one or more application servers connected to a central database.
    The system is exposed to the voters through one or more web servers hosting the
    voting website. The institution can have the web, application, and database servers
    hosted directly on the premises or in the cloud. Cloud hosting can happen through
    a cloud computing provider offering Infrastructure as a Service (IaaS) if the
    voting system has been implemented in-house by the institution, or through a cloud
    application provider offering Software as a Service (SaaS) if the voting system
    is only leased or rented from an external provider during the voting session.
    This architecture might not be ideal from the point of view of the voter, because
    of potential worries about trust and security.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.2](#ch01fig02)顶部所示，中心化投票应用运行在一个或多个应用服务器上，这些服务器连接到一个中心数据库。系统通过一个或多个托管投票网站的网络服务器暴露给选民。机构可以在自己的场所或云端托管网络、应用和数据库服务器。如果机构内部开发了投票系统，则可以通过提供基础设施即服务（IaaS）的云服务提供商进行云托管；如果投票系统只是在投票期间从外部提供商那里租用或租用，则可以通过提供软件即服务（SaaS）的云应用提供商进行云托管。从选民的角度来看，这种架构可能不是理想的，因为可能存在关于信任和安全的潜在担忧。
- en: Trust in centralized voting
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对中心化投票的信任
- en: Given all the financial and accounting scandals that have happened at both corporate
    and governmental levels in the last few years, it’s understandable if you don’t
    fully *trust* the organizations you’re a shareholder or citizen of. You might
    wonder whether the outcome of electronic voting might get manipulated in some
    way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到过去几年在企业层面和政府层面发生的所有金融和会计丑闻，如果您不完全*信任*您是股东或公民的组织，这是可以理解的。您可能想知道电子投票的结果是否可能以某种方式被操纵。
- en: It’s easy to imagine, for example, that a malicious developer or administrator
    of the voting application, colluding with some party interested in a certain outcome
    of the voting, could access key parts of the system and tamper with the way votes
    are collected, processed, and stored at various levels of the application architecture.
    Depending on how the application has been designed, it could be possible for some
    malicious database administrators to even modify votes retroactively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很容易想象，一个恶意开发人员或投票应用的管理员，与某些有兴趣达到某种投票结果的党派勾结，可以访问系统的关键部分，并篡改投票的收集、处理和存储方式，在应用程序架构的不同层次上。根据应用程序的设计方式，某些恶意数据库管理员甚至可能
    retroactively 修改投票。
- en: Security in centralized voting
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中心化投票的安全性
- en: When voting through a centralized application, you’d worry about not only the
    good faith of the company or institution organizing the election, but also whether
    the system was secured adequately against external manipulation. For example,
    external parties might be interested in having the voting go a certain way and
    might try to get their desired outcome by hacking into the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集中式应用投票时，您不仅会担心组织选举的公司或机构的善意，还会担心系统是否足够安全，以防止外部操纵。例如，外部各方可能希望投票结果朝某个方向发展，并可能通过入侵系统来获得他们所期望的结果。
- en: As I explained earlier, a centralized voting system includes only a certain
    number of servers located within the same network. Each server generally provides
    only one function, and it’s therefore a single point of failure, not only from
    a processing point of view but also, and especially, from a security point of
    view. For example, if a hacker managed to alter code on the web server so that
    votes were intercepted and modified in that layer, the entire system would be
    compromised. The same outcome could be achieved by hacking only into the application
    server or, even better, into the database server. A breach of security in one
    part of the system is sufficient to compromise the security of the entire system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前解释的，集中式投票系统只包括位于同一网络中的少数服务器。每台服务器通常只提供一种功能，因此从处理角度看，它是一个单点失败，而且尤其是从安全角度看。例如，如果黑客设法修改Web服务器的代码，以便在那一层拦截并修改投票，整个系统都会受到威胁。通过仅入侵应用服务器或，更好的是，数据库服务器，可以实现相同的结果。系统中的一个安全漏洞就足以威胁到整个系统的安全。
- en: Decentralized voting application
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化投票应用
- en: 'A decentralized application is based on two key technical principles:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序基于两个关键技术原则：
- en: Its application logic is present and executed simultaneously and independently
    on each server of a *peer-to-peer (P2P) network*. In theory, a different participant
    owns each server, also known as a *node*. A central node doesn’t control or coordinate
    the servers; instead, they communicate directly with each other and are consequently
    also known as *peer nodes*. They continuously verify each other’s output, so a
    user need only trust the P2P network, not an individual organization. The application
    data and state are stored on a local copy of a database on each server of the
    network, as shown at the bottom of [figure 1.2](#ch01fig02).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的应用逻辑在*点对点(P2P)网络*的每一台服务器上同时存在并独立执行。在理论 上，每一台服务器由不同的参与者拥有，也称为*节点*。中心节点不控制或协调服务器；相反，它们直接相互通信，因此也被称为*对等节点*。它们持续地验证彼此的输出，因此用户只需信任P2P网络，而不需要信任某个单独的组织。应用数据和状态存储在网络中每台服务器的本地数据库副本上，如图
    1.2 所示。
- en: Its database technology, called *blockchain*, guarantees that data can’t be
    modified retroactively.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的数据库技术，称为*区块链*，确保数据不能被追溯修改。
- en: Figure 1.2\. Comparison of a centralized voting application with a decentralized
    one. One institution owns all servers of a centralized application. A decentralized
    voting application runs simultaneously on multiple nodes of a network that different
    entities own.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2. 集中式投票应用与去中心化投票应用的比较。集中式应用的所有服务器都由一个机构拥有。而去中心化投票应用则是在不同实体拥有的网络多个节点上同时运行。
- en: '![](Images/fig01-02_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-02_alt.jpg)'
- en: Trust and security in Dapps thanks to P2P network replication
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信任和安全得益于 P2P 网络复制
- en: 'How can you address trust and security concerns by decentralizing the voting
    application according to the two principles I outlined? A decentralized voting
    application makes trust and security breaches pointless by replicating its execution
    over a network including many servers, each in theory owned by a different party.
    Think about it: if votes were processed and verified not by one single server
    but independently by many servers owned by different parties, and they were stored
    not in a single database but in many databases, each one local to the processing
    party, both trust and security concerns would be addressed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我概述的两个原则，您如何通过去中心化投票应用来解决信任和安全问题？去中心化投票应用通过在包括许多服务器的网络中复制其执行，使信任和安全漏洞变得毫无意义，理论上每个服务器都由不同的方拥有。想想看：如果投票不是由一台单一服务器处理和验证，而是由许多不同方拥有且独立运行的服务器处理和验证，并且它们不是存储在单一数据库中，而是存储在许多本地数据库中，每个数据库都由处理方拥有，那么信任和安全问题都将得到解决：
- en: '*Trust*—If one of the participants tried to maliciously alter a vote and propagate
    the modified vote to the network, the other participants would detect the vote
    as modified during their validation and would reject it. They wouldn’t store it
    in their local copy of the database and wouldn’t propagate the altered vote further
    throughout the network, so the malicious modification would become pointless.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任—如果参与者之一试图恶意地篡改选票并将其修改后的选票传播到网络中，其他参与者在验证过程中会发现选票被修改了，并将拒绝它。他们不会在本地数据库副本中存储它，并且不会将修改后的选票进一步传播到网络中，因此恶意修改变得毫无意义。
- en: '*Security*—Hackers would find trying to alter votes in a decentralized system
    much more difficult than trying to do so in a centralized one. Even if they managed
    to modify votes on one server, or they hosted themselves on one server of the
    decentralized voting application network to do so more easily, other participants
    would spot and reject the alteration, as seen earlier. Successful hacking would
    therefore require compromising not one server of the network but at least 51%
    of the nodes of the network simultaneously, assuming the state of the application
    is what is agreed among the majority of the network nodes. As you can understand,
    trying to manipulate a large part of a network including thousands of servers
    is an incredibly challenging task, especially if each one is managed independently.
    Also, each one might potentially be set up with a different way of preventing
    security breaches.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性—黑客在去中心化系统中尝试篡改选票会比在中心化系统中难得多。即便他们成功地在某台服务器上修改了选票，或者他们自己在一台去中心化投票应用网络的服务器上进行操作以更容易地篡改，其他参与者也会发现并拒绝这种修改，如前所述。因此，成功的黑客攻击将需要同时攻陷网络中至少51%的节点，假设应用程序的状态是网络节点中的大多数所达成的共识。如你所理解，试图操纵包括成千上万服务器在内的网络的大部分，特别是如果每个服务器都独立管理的话，是一项极其困难的任务。此外，每个服务器可能都有不同的防止安全漏洞的方法。
- en: Trust and security in Dapps thanks to the blockchain
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 区块链带来的Dapps的信任和安全
- en: 'A blockchain database is based on a data structure that, as its name suggests,
    is a chain of blocks. A block can be seen as a record containing a set of transactions,
    each one digitally signed, some metadata (such as block number and time stamp
    information), and a link to the previous block. Each transaction, each block as
    a whole, and the links between blocks are secured with cryptographic technology,
    which makes them *immutable*: retroactive alteration of single transactions is
    nearly impossible, especially as more blocks are added to the chain. A blockchain
    database therefore addresses trust and security concerns by providing further
    protection against manipulation attempts by malicious participants and external
    parties.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据库基于一种数据结构，正如其名称所示，它是区块的链条。区块可以被看作是包含一组交易记录，每个记录都经过数字签名，一些元数据（如区块号码和时间戳信息），以及到前一个区块的链接。每笔交易、每个区块整体以及区块之间的链接都通过加密技术得到保护，这使得它们*不可更改*：回溯性地修改单个交易几乎是不可能的，尤其是当链中添加更多区块时。因此，区块链数据库通过提供进一步的保护，以防止恶意参与者和外部实体对应用程序进行篡改尝试，从而解决信任和安全问题。
- en: Outstanding questions on low-level aspects
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 低级方面的未解问题
- en: 'At this stage, you might find the decentralized voting application concept
    promising from a logical or a high-level point of view, but you might still be
    confused about physical and lower level aspects of its architecture. You might
    have doubts in various areas:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能从逻辑或高层次的角度认为去中心化投票应用概念是有希望的，但你可能仍然对它的物理和低级架构方面感到困惑。你可能在各个领域都有疑虑：
- en: '*System architecture*—Is the network hosting the decentralized voting application
    a special kind of network? Do servers communicate with each other using a special
    protocol or using standard internet technology?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构—去中心化投票应用的网络是一种特殊的网络吗？服务器是否使用特殊的协议或标准互联网技术进行相互通信？
- en: '*Vote processing and validation*—How does vote submission get propagated across
    the network so that a vote gets processed on each server of the network? How does
    a vote get counted and then stored on the blockchain? How does a member of the
    network verify the authenticity of the consolidated vote records received from
    other members?'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票处理和验证—投票提交是如何在网络上传播，以便在网络的每台服务器上进行处理的？投票是如何被计数并存储在区块链上的？网络的一名成员是如何验证从其他成员那里接收到的合并投票记录的真实性的？
- en: 'I’ll try to answer these questions in the next two sections, which cover low-level
    details of the decentralized voting application. I’ll also assume the voting Dapp
    has been developed for Ethereum, the blockchain and Dapp platform this book is
    focused on. Doing so will allow me to start introducing Ethereum and to refer
    to concrete infrastructural components while presenting two complementary low-level
    views of the system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我将尝试回答这些问题，这些部分涵盖了去中心化投票应用的高级细节。我还假设投票Dapp是为以太坊开发的，这是本书关注的区块链和Dapp平台。这样做将允许我开始介绍以太坊，并在呈现系统的两个互补的高级视图时参考具体的底层组件：
- en: '*A structural Dapp view*—I’ll describe the low-level architecture of the client
    and server sides of our voting Dapp.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构Dapp视图*——我将描述我们投票Dapp的客户端和服务器端的高级架构。'
- en: '*A transactional Dapp view*—I’ll walk you, step-by-step, through the entire
    lifecycle of a voting transaction.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交易Dapp视图*——我将带你逐步了解投票交易的整个生命周期。'
- en: '1.1.2\. Structural view: Anatomy of a Dapp'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 结构视图：Dapp的解剖
- en: The *structural view* of the decentralized voting application includes a description
    of the components of both the client side, represented by the web UI through which
    a voter submits a vote, and the server side, represented by a network of servers
    running the application logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化投票应用的*结构视图*包括客户端组件的描述，由代表投票者提交投票的网页用户界面（UI）表示，以及服务器端组件的描述，由运行应用逻辑的一组服务器表示。
- en: 'Dapp client side: a web application'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化应用（Dapp）客户端：一个网页应用
- en: The voting application web client, shown in [figure 1.3](#ch01fig03), gets initially
    downloaded into the user browser from a conventional web server, generally as
    a web application containing HTML and JavaScript. The web user interface doesn’t
    contain any server-side scripts and communicates directly with a specific server
    of the network through a client-side JavaScript library called Web3.js. It might
    also allow the user to communicate with a network node located on their premises.
    So far, this application differs in no major way from a conventional web application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1.3所示，投票应用的网页客户端最初从传统的网页服务器下载到用户浏览器中，通常是一个包含HTML和JavaScript的网页应用。网页用户界面不包含任何服务器端脚本，并通过一个名为Web3.js的客户端JavaScript库直接与网络中的特定服务器通信。它还可能允许用户与位于其场地的网络节点进行通信。到目前为止，这个应用与传统的网页应用在主要方面没有区别。
- en: Figure 1.3\. A decentralized voting application is exposed to the voter as a
    web application, which contains both HTML and JavaScript and is downloaded from
    a conventional web server. The web application, which doesn’t contain any server-side
    scripts (otherwise, it would be partially centralized), is generally configured
    to communicate directly with a specific node of the network.
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 对投票者而言，去中心化投票应用呈现为一个网页应用，其中包含HTML和JavaScript，并从传统的网页服务器下载。这个不包含任何服务器端脚本（否则它将是部分中心化的）的网页应用通常配置为直接与网络的特定节点通信。
- en: '![](Images/fig01-03_alt.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-03_alt.jpg)'
- en: 'Dapp server side: a P2P network'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化应用（Dapp）服务器端：一个P2P网络
- en: The server side of a decentralized application is a P2P network of servers that
    run the same code and have identical copies of a blockchain database. As you know,
    a key characteristic of this network topology is that it uses no central coordination,
    but instead uses direct communication between each node and a number of other
    nodes, known as *peer nodes* or simply *peers*. No master node is needed. As shown
    in [figure 1.4](#ch01fig04), a node doesn’t need to be connected to all of the
    other nodes of the network. Being connected to a few nodes is sufficient to ensure
    transactions are rapidly propagated to the whole network.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用的服务器端是一个运行相同代码并拥有区块链数据库相同副本的一组服务器构成的P2P网络。正如你所知，这种网络拓扑的一个关键特征是它不使用中心协调，而是使用每个节点与称为*对等节点*或简称*
    peers*的多个其他节点的直接通信。不需要主节点。如图1.4所示，一个节点不需要连接到网络的所有其他节点。与几个节点的连接就足以确保交易快速传播到整个网络。
- en: Figure 1.4\. A peer-to-peer (P2P) network is made of nodes that communicate
    directly with each other without the coordination of a master node.
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4. 对等网络（P2P）由直接与其他节点通信，无需主节点协调的节点组成。
- en: '![](Images/fig01-04_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-04_alt.jpg)'
- en: The Ethereum network
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以太坊网络
- en: Various P2P networks supporting blockchain platforms exist. The most well-known
    one is the Bitcoin network.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存在支持区块链平台的各种P2P网络。最著名的一个是以太坊网络。
- en: In this book, I’ll focus on the Ethereum network, whose *participant* nodes,
    as shown in [figure 1.5](#ch01fig05), host a *blockchain database* and a piece
    of software called a node *client*, which allows a node to communicate with other
    nodes. Because all nodes are equivalent to each other, within the Ethereum network
    you have no clear-cut concept of client and server. Each node is a server to other
    nodes, but, at the same time, it’s also a client of other nodes. That’s why the
    software element of an Ethereum node is called a client.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将重点关注以太坊网络，其*参与者*节点如图1.5所示([figure 1.5](#ch01fig05))，托管一个*区块链数据库*和一块被称为节点*客户端*的软件，该软件允许节点与其他节点通信。因为所有节点彼此平等，所以在以太坊网络中，你没有一个清晰定义的客户端和服务器概念。每个节点对其他节点来说是服务器，但同时，它也是其他节点的客户端。这就是为什么以太坊节点的软件元素被称为客户端。
- en: Ethereum clients expose a common client interface and communicate with each
    other through a P2P protocol called *Wire*. That protocol enforces a standard
    way of sending data throughout the network, specifically a *transaction*, such
    as a submitted vote, and a *block*, such as a set of votes consolidated in the
    blockchain database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊客户端暴露出一个共同的客户端接口，并通过名为*Wire*的P2P协议相互通信。该协议确保了在网络中发送数据的标准方式，具体包括*交易*，比如提交的投票，以及*区块*，比如在区块链数据库中的一组投票汇总。
- en: Various implementations of an Ethereum client exist. As you can see in [figure
    1.5](#ch01fig05), they’re written in various languages, from C++ to Go, but all
    implement the standard client interface and the Wire protocol, so they can interact
    seamlessly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种以太坊客户端的实现。如图1.5所示([figure 1.5](#ch01fig05))，它们是用各种语言编写的，从C++到Go，但都实现了标准的客户端接口和Wire协议，因此它们可以无缝交互。
- en: Figure 1.5\. Each node of the Ethereum network hosts a blockchain database and
    a node client capable of executing application code stored in the blockchain.
    Nodes communicate through the Wire protocol and expose the same interface but
    can be implemented in different languages.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5\. 以太坊网络的每个节点都托管一个区块链数据库和一个能够执行存储在区块链中的应用程序代码的节点客户端。节点通过Wire协议通信，并暴露出相同的接口，但可以采用不同的编程语言实现。
- en: '![](Images/fig01-05_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-05_alt.jpg)'
- en: The advantage of an Ethereum node client over a Bitcoin node client is that
    it’s able not only to propagate cryptocurrency transactions and blocks throughout
    the network, as a Bitcoin node does, but also to execute application code hosted
    on the blockchain database. From this point of view, platforms such as Ethereum
    are known as *programmable blockchains*. The code of decentralized applications
    is structured in *smart contracts*, which encapsulate logic and state in the same
    way classes do in most object-oriented languages. The voting decentralized application,
    for example, would be structured on various smart contracts that would be hosted
    on the Ethereum blockchain. I’ll explain shortly what a smart contract is, how
    you deploy it, how you execute it, and where a smart contract is stored and runs.
    Bear with me.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊节点客户端与比特币节点客户端的优势在于，它不仅能够像比特币节点那样在网络中传播加密货币交易和区块，还能够执行托管在区块链数据库上的应用程序代码。从这一点来看，像以太坊这样的平台被称为*可编程区块链*。去中心化应用程序的代码结构在*智能合约*中，智能合约以大多数面向对象语言中的类封装逻辑和状态的方式封装逻辑和状态。例如，投票去中心化应用程序将基于各种智能合约进行结构化，这些智能合约将托管在以太坊区块链上。我即将解释智能合约是什么，如何部署它，如何执行它，以及智能合约存储和运行的位置。耐心点。
- en: The role of network nodes
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络节点的作用
- en: 'Although all network nodes communicate seamlessly through the common P2P Wire
    protocol, not all nodes perform the same function. Broadly, as shown in [figure
    1.6](#ch01fig06), the two main types of nodes, which are functionally different,
    are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有网络节点都通过共同的P2P Wire协议无缝通信，但并非所有节点执行相同的功能。广泛来说，如图1.6所示([figure 1.6](#ch01fig06))，两大类节点，功能上不同，如下所述：
- en: '*Full node*—Most nodes have a standard setup that allows them to process transactions
    passively: they can read from the blockchain database, but they can’t create new
    blockchain blocks. But they can append blocks received from peer nodes to the
    local blockchain. They do execute transactions, but only to verify the correctness
    of the blockchain blocks they receive from peer nodes. In the case of the voting
    application, full nodes propagate votes received from their peers to other peers.
    They also verify that the blocks received are correct and contain authentic votes
    by running the voting Dapp smart contracts. But full nodes don’t store votes in
    new blockchain blocks.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整节点*—大多数节点具有标准设置，使它们能够被动处理交易：它们可以从区块链数据库中读取，但不能创建新的区块链块。但它们可以将从对等节点接收的块附加到本地区块链。它们确实执行交易，但仅用于验证从对等节点接收的区块链块的正确性。在投票应用程序的情况下，完整节点将来自其对等节的投票传播给其他对等节点。它们还验证接收到的块是否正确，并包含真实的投票，通过运行投票Dapp智能合约来实现。但完整节点不会在新区块链块中存储投票。'
- en: 'Figure 1.6\. The Ethereum network includes two main types of nodes. Full nodes
    process transactions passively and can read, but can’t write on, the blockchain.
    Mining nodes process transactions actively: they validate the correctness of transactions
    as full nodes do, but they also assemble transactions into new blocks that are
    appended onto the blockchain.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6。以太坊网络包括两种主要类型的节点。完整节点被动处理交易，可以从区块链数据库中读取，但不能写入。挖矿节点主动处理交易：它们像完整节点一样验证交易的正确性，但它们还组装新的交易块，这些块被附加到区块链上。
- en: '![](Images/fig01-06_alt.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig01-06_alt.jpg)'
- en: '*Mining node*—Some of the nodes are configured to process transactions actively:
    they group and store transactions in new blockchain blocks. They’re rewarded in
    Ether, the cryptocurrency supported in the Ethereum platform, for performing such
    computationally intensive and energy demanding work. They then propagate these
    new blocks to the rest of the P2P network. Such nodes are called mining nodes
    because the process of consolidating a new block to the blockchain and being rewarded
    for it in cryptocurrency tokens is known as *mining*. In the case of the voting
    Dapp, mining nodes group votes received from peer nodes into a new block, append
    the block to the blockchain, and propagate the block through their peers.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*挖矿节点*—一些节点被配置为主动处理交易：它们将交易分组并存储在新的区块链块中。它们通过在以太坊平台上支持的加密货币Ether中执行这样计算密集型和能源消耗型工作而获得奖励。然后，它们将这些新块传播到P2P网络的其余部分。这些节点被称为挖矿节点，因为将新块整合到区块链中并因此获得加密货币代币奖励的过程被称为*挖矿*。在投票Dapp的情况下，挖矿节点将来自对等节点的投票分组到一个新块中，将块附加到区块链，并通过其对等节点传播该块。'
- en: Putting everything together
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: You’ve examined the structural view of the voting Dapp. [Figure 1.7](#ch01fig07)
    shows the entire system, including the client and server sides.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经检查了投票Dapp的结构视图。[图1.7](#ch01fig07)展示了整个系统，包括客户端和服务器端。
- en: Figure 1.7\. The entire static view of a decentralized voting application, including
    client and server sides
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7。分布式投票应用程序的整个静态视图，包括客户端和服务器端
- en: '![](Images/fig01-07_alt.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-07_alt.jpg)'
- en: '1.1.3\. Transactional view: Through the lifecycle of a transaction'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3。交易视图：通过交易的生命周期
- en: 'Adding a temporal dimension to the static view you saw in [figure 1.7](#ch01fig07),
    [figure 1.8](#ch01fig08) illustrates step-by-step the full lifecycle of a voting
    transaction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在[图1.7](#ch01fig07)中看到的静态视图的基础上增加时间维度，[图1.8](#ch01fig08)逐步说明了投票交易的完整生命周期：
- en: The user selects one of the possible voting options from a drop-down list box
    on the web client and clicks Vote.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从网页客户端的下拉列表框中选择一个可能的投票选项，然后单击投票。
- en: A JavaScript function handles the click event and grabs the voting selection.
    Then, through various web3.js library functions, it sets up the communication
    with a configured Ethereum node, connects with the voting smart contract, and
    calls the `castVote()` function on it. The invocation of `castVote()` generates
    a transaction message that’s digitally signed against the account of the user
    to prove they’re the genuine sender.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个JavaScript函数处理点击事件并获取投票选择。然后，通过各种web3.js库函数，它与配置的以太坊节点建立通信，连接到投票智能合约，并在其上调用`castVote()`函数。对`castVote()`的调用生成一个交易消息，该消息以用户的账户为依据进行数字签名，以证明他们是真正的发送者。
- en: The contacted local Ethereum node handles the transaction message, verifies
    it, and relays it to its peer nodes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系到的本地以太坊节点处理交易消息，验证它，并将它传递给其对等节点。
- en: Peer nodes do the same and keep propagating the transaction, until the transaction
    hits mining nodes. This will happen relatively quickly, depending on the ratio
    of full nodes to mining nodes. Mining nodes perform the same steps (steps 2 and
    3) of a full node. In addition, a mining node picks a transaction, such as a voting
    transaction. A transaction is considered profitable if it’s expected to generate
    an acceptable transaction fee, higher than the electricity costs the mining node
    faces while processing transactions. If so, the mining node executes the `castVote()`
    function and competes with other mining nodes to store the transaction on the
    blockchain. The winning mining node (which is the mining node successfully solving
    the so-called consensus algorithm, a cryptographic problem) consolidates the voting
    transaction among other transactions in a new block of the blockchain. It then
    relays the new block to all its peer nodes (regardless of whether they’re full
    or mining nodes).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点之间相互转发交易，直到交易到达挖矿节点。这相对较快发生，取决于完整节点与挖矿节点的比例。挖矿节点执行与完整节点相同的步骤（第2步和第3步）。此外，挖矿节点选择一个交易，如一个投票交易。如果一个交易预计能产生一个可接受的交易费，高于挖矿节点处理交易时面临的电力成本，那么这个挖矿节点就会执行`castVote()`函数，与其他挖矿节点竞争将交易存储在区块链上。获胜的挖矿节点（即成功解决所谓共识算法，一个加密问题的挖矿节点）会在区块链的新区块中与其他交易一起巩固投票交易。然后，它将新区块传递给所有其同伴节点（不论它们是完整节点还是挖矿节点）。
- en: Each node that has received a new block verifies whether the individual transactions
    included in it are genuine and whether the block as a whole is valid. It then
    processes all the transactions present in it. While doing this, it implicitly
    verifies the validity of the contract state. For example, the vote submission
    logic might include an invariant verifying that the number of votes cast for a
    candidate, or the total number of votes cast for all candidates, isn’t higher
    than the number of registered voters. If the node verifies the block successfully,
    it relays it to its peer nodes, which perform the same validation and propagation
    action until the whole network has acquired the new blockchain block. (The verification
    process will become clearer to you in the next chapter, when I’ll present the
    cryptographic techniques it’s based on.)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个接收到新块的节点都会验证其中包含的个别交易是否真实，以及整个区块是否有效。然后处理其中的所有交易。在这个过程中，它隐式地验证了合约状态的有效性。例如，投票提交逻辑可能包括一个不变量，验证对于一个候选人投出的票数，或所有候选人投出的总票数，不会高于注册选民的数量。如果节点成功验证了区块，它会将其传递给它的同伴节点，这些节点执行相同的验证和传播动作，直到整个网络都获得了新的区块链区块。（验证过程在下一章中会更清晰地解释给你听，届时我将介绍它所基于的加密技术。）
- en: The local Ethereum node with respect to the user receives the new block and
    verifies it by executing all the transactions present on it, as all the other
    nodes have done. One of these is the voting transaction, which has been programmed
    to raise a `VoteConfirmation` event on successful completion. The event is published
    to all the clients subscribed to it, including the Dapp web UI.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于用户而言，本地的以太坊节点接收新块并通过执行其中的所有交易来验证它，像其他所有节点一样。其中一个是投票交易，它已经被编程在成功完成时触发一个`VoteConfirmation`事件。事件被发布给所有订阅它的客户端，包括Dapp的Web
    UI。
- en: Figure 1.8\. The lifecycle of a voting transaction. A voting transaction is
    created when a voter browser invokes the `castVote()` function on the Voting smart
    contract on a local node of the Ethereum network. This is then validated and propagated
    throughout the network until it’s included on a new blockchain block by a mining
    node. The new block is propagated throughout the network, and then it finally
    gets back to the local node.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 投票交易的生命周期。当一个选民浏览器在以太坊网络的本地节点上调用`castVote()`函数在一个投票智能合约上时，就会创建一个投票交易。这然后被验证并在整个网络中传播，直到它被一个挖矿节点包含在一个新的区块链区块中。新的区块在整个网络中传播，然后最终返回到本地节点。
- en: '![](Images/fig01-08_alt.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig01-08_alt.jpg)'
- en: The JavaScript code present on the voting web client contains a callback function
    registered against the `VoteConfirmation` event, which then gets triggered.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票Web客户端上存在的JavaScript代码包含一个针对`VoteConfirmation`事件的回调函数，该函数随后会被触发。
- en: Finally, the callback function shows a vote confirmation notification on the
    voter’s screen.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回调函数在选民屏幕上显示一个投票确认通知。
- en: 1.1.4\. Some Dapp terminology
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 一些Dapp术语
- en: Although decentralized applications are a relatively new idea, standard terminology
    around them started to appear relatively soon after the first Dapps were built.
    In this section, I’ll provide a summary of the key terms that Vitalik Buterin,
    the creator of Ethereum, described in a famous blog post^([[1](#ch01fn01)]) he
    wrote to explain key Dapp concepts. You’ve already come across some of these terms
    in the previous sections, but now I’ll define them more precisely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管去中心化应用是一个相对较新的概念，但在第一个Dapps构建后相对较短的时间内，围绕它们的标准化术语开始出现。在本节中，我将概述以太坊创始人Vitalik
    Buterin在一篇著名的博客文章中描述的关键术语^([[1](#ch01fn01)])，以解释关键的Dapp概念。您已经在之前的章节中遇到过一些这些术语，但现在我将更精确地定义它们。
- en: ¹
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Vitalik Buterin, “DAOs, DACs, DAs and More: An Incomplete Terminology Guide,”
    [http://mng.bz/vNrq](http://mng.bz/vNrq).'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Vitalik Buterin，“DAOs, DACs, DAs and More: An Incomplete Terminology Guide，”[http://mng.bz/vNrq](http://mng.bz/vNrq)。'
- en: Smart contract
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智能合约
- en: A *smart contract* is an arrangement between two or more parties that involves
    an exchange of digital assets. One or more of these parties allocates digital
    assets to the contract at its initiation. Subsequently, the assets are redistributed
    among the parties according to a predefined protocol encoded in logic and a state
    that’s initialized at the start of the contract.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*智能合约*是涉及数字资产交换的两个或多个方的安排。其中一个或多个方在合约启动时向合约分配数字资产。随后，根据逻辑中预定义的协议和初始化的状态，资产根据逻辑重新分配给各方。
- en: Autonomous agent
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自主代理
- en: An *autonomous agent* is a software entity that interacts autonomously with
    external software services and can reconfigure or even reprogram itself following
    verified changes in the external environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*自主代理*是一个与外部软件服务自主交互的软件实体，根据外部环境验证的变化重新配置或甚至重新编程自己。
- en: Decentralized organization
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化组织
- en: A traditional *centralized organization* contains assets and different classes
    of individuals, typically investors, employees, and customers. Investors control
    the organization by owning a part of it through the purchase of shares. Interactions
    between some classes of individuals are influenced by whether they control the
    organization. For instance, employees can get recruited by investors or by other
    employees authorized directly or indirectly by investors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传统的*中心化组织*包含资产和不同类别的个体，通常是投资者、员工和客户。投资者通过购买股份拥有组织的一部分来控制组织。某些类别的个体之间的交互受到他们是否控制组织的影响。例如，员工可以被投资者直接或间接授权的其他员工招募。
- en: A *decentralized organization* (DO) isn’t controlled by any one person or entity.
    Predefined protocols are what determine interactions between classes of individuals
    involved in the organization. But such protocols can be designed so that certain
    individuals have more power than others—for instance, depending on the number
    of shares owned—exactly as with centralized organizations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*去中心化组织*（DO）不由任何一个人或实体控制。预定义的协议决定了组织中涉及的不同类别人群之间的交互。但是，这些协议可以设计成让某些人比其他人拥有更多的权力——例如，根据所拥有的股份数量——正如集中式组织一样。
- en: Decentralized autonomous organization
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化自治组织
- en: A *decentralized autonomous organization* (DAO) is both a DO and an autonomous
    agent. Like an autonomous agent, it’s a software entity that interacts autonomously
    with external software services. Individuals involved with the DAO interact, as
    with DOs, through predefined protocols.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*去中心化自治组织*（DAO）既是DO又是自主代理。与自主代理一样，它是一个与外部软件服务自主交互的软件实体。参与DAO的个人通过预定义的协议与DOs交互。
- en: The main difference between a DAO and a DO is that interactions between DAOs
    and external parties are largely automated, and the interaction protocols are
    programmed in a *smart contract*, whereas interactions between the individuals
    who own the DO and external parties are subject only to a *manual protocol*. The
    key point is that from the point of view of external parties, DAOs are more trustworthy
    than DOs because automated interactions are predictable, whereas interactions
    based on a manual protocol rely entirely on the reputation of the individuals
    following it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DAO与DO的主要区别在于，DAO与外部实体的交互 largely是自动化的，且交互协议编程在*智能合约*中，而拥有DO的个人与外部实体的交互仅受*手动协议*的约束。关键点是，从外部实体的角度来看，DAOs比DOs更可信，因为自动交互是可预测的，而基于手动协议的交互完全依赖于遵循它的个体的声誉。
- en: According to these definitions, opinions diverge as to whether blockchain platforms
    built with the main or only purpose of supporting a cryptocurrency can be classified
    as DAOs or DOs. Because the Bitcoin infrastructure doesn’t allow for implementation
    of easily automated interaction protocols, some think it should be classified
    as a DO.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，关于是否可以将构建区块链平台的主要或唯一目的定义为支持加密货币的DAO或DO存在分歧。因为比特币基础设施不允许实现容易自动化的交互协议，有些人认为它应该被归类为DO。
- en: Decentralized autonomous corporation
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化自治公司
- en: A *decentralized autonomous corporation* (DAC) is a DAO that can be partially
    owned through a purchase of shares. As with classic (centralized) corporations,
    a DAC redistributes dividends periodically, depending on its financial success.
    A pure DAO, on the other hand, is generally a nonprofit organization, and participants
    benefit economically exclusively by contributing to its ecosystem and increasing
    its internal capital.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*去中心化自治公司*（DAC）是一个可以通过购买股份部分拥有的DAO。与经典的（中心化的）公司一样，根据其财务成功，DAC会定期重新分配股息。另一方面，纯粹的DAO通常是一个非营利组织，参与者的经济利益仅限于为其生态系统做出贡献并增加其内部资本。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注
- en: 'The current widely accepted definition of *decentralized application* corresponds
    to that of DAO described previously, which is still in use among Ethereum purists.
    I’ll use this definition for Dapp for the rest of this book. The reason why the
    initial terminology used the word *organization* rather than *application* was
    because the Ethereum founders wanted to put emphasis on the fact that a decentralized
    application can transact with other parties exactly like conventional organizations:
    by following rules and protocols and exchanging monetary value, obviously in the
    form of cryptocurrency rather than conventional currency.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'The current widely accepted definition of *decentralized application* corresponds
    to that of DAO described previously, which is still in use among Ethereum purists.
    I’ll use this definition for Dapp for the rest of this book. The reason why the
    initial terminology used the word *organization* rather than *application* was
    because the Ethereum founders wanted to put emphasis on the fact that a decentralized
    application can transact with other parties exactly like conventional organizations:
    by following rules and protocols and exchanging monetary value, obviously in the
    form of cryptocurrency rather than conventional currency.'
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The key aspects of each of these terms are summarized in [table 1.1](#ch01table01).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: The key aspects of each of these terms are summarized in [table 1.1](#ch01table01).
- en: Table 1.1\. Matrix summarizing key aspects of each term, with DAO standing for
    Dapp
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.1. 各术语关键方面的矩阵总结，DAO代表Dapp
- en: '|  | Is software | Has capital | Is autonomous | Is owned |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  | 是软件 | 有资本 | 自治 | 被拥有 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Autonom agent | YES | NO | YES | NO |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Autonom agent | YES | NO | YES | NO |'
- en: '| DO | NO | YES | NO | YES |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| DO | NO | YES | NO | YES |'
- en: '| **DAO** | **YES** | **YES** | **YES** | **NO** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **DAO** | **YES** | **YES** | **YES** | **NO** |'
- en: '| DAC | YES | YES | YES | **YES** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| DAC | YES | YES | YES | **YES** |'
- en: Although you’ve learned some of the high-level terms, you can’t truly understand
    the purpose of Dapps and how they work without familiarizing yourself with the
    concept of blockchain. Because Dapps are built on top of the blockchain and rely
    heavily on it, you should learn about it and its underlying technologies. I’ll
    cover this in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经了解了一些高级术语，但不去熟悉区块链的概念，你无法真正理解Dapps的目的以及它们是如何工作的。因为Dapps是构建在区块链之上的，并且严重依赖它，你应该去了解它以及其底层技术。我在下一节会覆盖这个内容。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Decentralized vs. distributed applications**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**去中心化应用与分布式应用对比**'
- en: '*Decentralized* applications shouldn’t be confused with *distributed* applications.
    The two concepts have similarities, but they’re not the same thing.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*去中心化*的应用不应该与*分布式*应用混淆。这两个概念有相似之处，但它们并不是一回事。'
- en: An application is distributed if it runs over multiple servers within a network.
    The simplest example of a distributed application is a web application, which
    is typically distributed over a web server, an application server, and a database
    server, and possibly an email server and legacy mainframes. The centralized voting
    application seen earlier is an example of a distributed application. It’s distributed
    because it’s spread over several servers, but it’s also centralized because all
    the servers are owned by the same institution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序在网络中的多个服务器上运行，则该应用程序是分布式的。分布式应用程序的最简单例子是一个网络应用程序，它通常在网络服务器、应用服务器和数据库服务器上分布式运行，可能还包括邮件服务器和遗留的大型计算机。前面提到的中心化投票应用程序是一个分布式应用程序的例子。它是分布式的，因为它在多个服务器上运行，但它也是中心化的，因为所有服务器都属于同一机构。
- en: A distributed application runs over multiple servers of a network. A decentralized
    application is replicated in its entirety over each node of a wide network.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用在网络的多个服务器上运行。而去中心化应用则是完整地复制在广泛网络的每个节点上。
- en: '![](Images/f0019-01_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0019-01_alt.jpg)'
- en: Comparison of the structures of distributed and decentralized applications
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式与去中心化应用结构的比较
- en: An application is decentralized if it’s replicated in its entirety over each
    node of a network, with each node being theoretically owned by a different entity.
    The higher the number of entities owning nodes of the network, the more trustful
    the network in its entirety is. Obviously, networks that have only a few owners
    can’t be considered trustful because they don’t truly decentralize the processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用若是其完整副本分布在网络的每个节点上，并且每个节点理论上属于不同的实体，那么这个应用就是去中心化的。拥有网络节点实体数量越多，整个网络的可信度就越高。显然，只有少数所有者的网络不能被认为是可信的，因为它们并没有真正实现处理的去中心化。
- en: A centralized application is generally distributed, but decentralized applications
    can also be distributed over multiple servers within each logical node.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 中心化的应用通常是分布式的，但去中心化的应用也可以分布在每个逻辑节点内的多个服务器上。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.2\. Good and bad Dapps
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 好的和不好的Dapps
- en: In the last few years, many Dapps have been developed. Some have received various
    rounds of venture capital funding and have been deployed successfully into production.
    Others have failed to convince investors and users and never passed the proof-of-concept
    stage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，开发了许多Dapps。一些已经获得了多轮风险投资，并成功部署到生产环境中。其他的则未能说服投资者和用户，从未走出概念验证阶段。
- en: 1.2.1\. Good use cases
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 好的用例
- en: Given the novelty of the technology, it’s hard to predict what’s going to work
    and what’s going to fail. Nevertheless, various use cases are being widely recognized
    as a good fit for the blockchain and in particular for Ethereum. Ideal Dapps are
    those that take advantage of the main benefits of these technologies, specifically
    record immutability, decentralization, security, and resilience. As a result,
    the main fields likely to be revolutionized by Dapps are provenance and ownership
    tracking, authenticity tracking, identity verification, regulatory auditing, charity
    expense auditing, prediction markets, customer loyalty management, crowdfunding,
    electronic voting, investing, gambling, lending, online games management, author
    royalty payment, Internet of Things, cloud computing, and even freedom of speech.
    Let’s see what innovative solutions have already been found in some of these areas.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这项技术的新颖性，很难预测哪些会成功，哪些会失败。尽管如此，各种用例正在被广泛认为是区块链以及特别是以太坊的一个很好的匹配。理想的Dapps是那些利用了这些技术主要优势的应用，具体来说是记录不可变性、去中心化、安全和弹性。因此，可能主要由Dapps引发革命的领域包括来源和所有权追踪、真实性追踪、身份验证、监管审计、慈善支出审计、预测市场、客户忠诚度管理、众筹、电子投票、投资、赌博、借贷、在线游戏管理、作者版税支付、物联网、云计算，甚至包括言论自由。让我们看看在这些领域中已经找到了哪些创新性解决方案。
- en: Provenance and authenticity tracking
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 来源和真实性追踪
- en: 'One of the biggest problems affecting supply chain management, particularly
    when involving long chains of processed goods crossing several countries, is tracking
    the authenticity of materials. Here are some Dapps that are innovating in this
    area with blockchain-based solutions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 影响供应链管理的一个最大问题，特别是在涉及穿越多个国家的加工商品长链时，是追踪材料的真实性。以下是一些基于区块链解决方案在这一领域进行创新的Dapps：
- en: Dapps such as Provenance provide blockchain-based provenance tracking of materials
    to ensure no information is lost or manipulated within the supplier chain and
    goods of expected quality reach the end customer. One of the first applications
    built on Provenance has been focused on the food industry, to track the supply
    chain of ingredients from the point of collection, though the process of food
    manufacturing, to the final point of consumer sale. The aim of this system is
    to prove the food being sold has the claimed characteristics advertised to the
    consumers, such as location and sustainability of harvesting or breeding, whether
    the sources are organic or have been genetically modified, whether they’re coming
    from fair trade, and so on.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Provenance这样的Dapp提供了基于区块链的来源追踪，以确保在供应商链中没有信息丢失或被操纵，并确保符合预期质量的商品到达最终客户。Provenance上构建的第一个应用程序一直专注于食品行业，追踪从收集点开始的原料供应链，经过食品制造过程，最终到达消费者销售点。该系统的目的是证明销售的食品具有向消费者广告的声称特征，例如收割或饲养的地点和可持续性，来源是否有机或经过基因改造，是否来自公平贸易等等。
- en: Unilever, the multinational consumer goods corporation, is developing a blockchain-based
    system in collaboration with a number of start-ups to track the tea supply chain
    starting from farmers in Malawi.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合利华这家跨国消费品公司正在与多家初创公司合作，开发一个基于区块链的系统，以追踪从马拉维农民开始的茶叶供应链。
- en: Everledger is a Dapp that aims to replace the paper certification process for
    diamonds with a blockchain-based system. A full digital record of a diamond, including
    its certificate ID and many properties, such as cut, grade, clarity, color, and
    carat, is stored on the blockchain, and the certificate ID is then engraved with
    a laser on the stone. All the information related to a diamond can then be retrieved
    at any point of the supply chain with the help of a scanner that reads the certificate
    ID from the stone. Almost 2 million diamonds have already been stored on Everledger.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Everledger是一个旨在用基于区块链的系统替换钻石纸质认证流程的Dapp。一颗钻石的完整数字记录，包括其证书ID和许多属性，如切割、等级、清晰度、颜色和克拉重量，存储在区块链上，然后使用激光在钻石上刻上证书ID。然后，在任何供应链环节，都可以使用读取石头上证书ID的扫描仪检索与钻石相关的所有信息。已经有近200万颗钻石存储在Everledger上。
- en: The pharmaceutical company Pfizer is partnering with the biotechnology company
    Genentech to develop MediLedger, a blockchain-based drug delivery tracking system.
    The aim is to verify the provenance and authenticity of Pfizer drug deliveries
    throughout the entire distribution chain to prevent thefts, fraud, and counterfeiting.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制药公司辉瑞正在与生物技术公司基因泰克合作开发MediLedger，这是一个基于区块链的药物交付追踪系统。目标是验证辉瑞药物在整个分销链中的来源和真实性，以防止盗窃、欺诈和假冒。
- en: Identity verification
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 身份验证
- en: As with provenance tracking, verification of proof of identity tries to protect
    businesses and individuals from the consequences of fraud and identity theft.
    KYC-Chain is a novel platform built on the Ethereum blockchain that allows users
    to manage their digital identity securely. It also helps businesses and financial
    institutions to manage customer data in a reliable and easy manner. The system
    is designed so that users own the “keys” to their personal data and identity certificates.
    Consequently, identity owners, who can be individuals or companies, are the only
    ones who get to choose which part of their information is shared, with whom, and
    under what terms. Such information is digitally attested by notaries and institutions
    before being shared by owners and registered agents.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如来源追踪一样，身份证明的验证试图保护企业和个人免受欺诈和身份盗窃的后果。KYC-Chain是一个建立在以太坊区块链上的新型平台，使用户能够安全地管理他们的数字身份。它还帮助企业和金融机构以可靠和简单的方式管理客户数据。该系统设计成用户拥有个人数据和身份证明的“钥匙”。因此，身份所有者，可以是个人或公司，是唯一可以选择分享其信息的一部分、与谁分享以及分享条件的唯一人员。在所有者及其注册代理分享之前，此类信息由公证人和机构数字证实。
- en: Proving ownership
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 证明所有权
- en: Traditional blockchains associated with cryptocurrencies such as Bitcoin as
    ledgers implicitly prove the ownership of digital assets, such as the amount of
    Bitcoin stored at a certain address. Only the legitimate owners of the address
    are able to transfer funds because they’re the only ones who know the private
    key.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的区块链技术，如与比特币关联的加密货币，隐含地证明了数字资产的所有权，比如某个地址存储的比特币数量。只有地址的合法所有者才能转账，因为他们是唯一知道私钥的人。
- en: TrustToken tries to go further. It’s a Dapp conceived for proving the ownership
    of physical assets, such as real estate; financial assets, such as stocks and
    bonds; commodities, such as gold; and even intellectual property, such as music,
    books, and patents, through smart contracts. The idea is that you can transfer
    the ownership of these assets from one person to the other in the same way Bitcoins
    are transferred between addresses. The underlying assumption for TrustToken to
    be successful is that proof of ownership recorded through the system should be
    enforceable under law.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: TrustToken试图更进一步。它是一个旨在通过智能合约证明实体资产所有权的Dapp，如房地产、股票和债券等金融资产、黄金等商品，甚至音乐、书籍和专利等知识产权。想法是你可以像转移比特币一样，将这类资产的所有权从一个人转移到另一个人。TrustToken成功的根本假设是，通过系统记录的所有权证明在法律上应该是可执行的。
- en: Economy of Things
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网经济
- en: The tech startup Slock.it ([https://slock.it/](https://slock.it/)) is building
    the infrastructure for the “economy of things,” which lies at the intersection
    between the Internet of Things and blockchain technology. This infrastructure,
    which the company has named the Universal Sharing Network, has the potential to
    be used as a financial internet, where connected autonomous objects can not only
    sell and rent themselves but also pay for each other’s services. The technology
    the company is developing, based on Ethereum smart contracts, aims to provide
    autonomous objects an identity and the ability to receive payments and enter into
    agreements without the need for intermediaries. Smart lockers, which enable the
    unlocking of physical objects when a fee is paid, are some of the applications
    already created on this platform. Because smart lockers make renting of sports
    equipment, hotel rooms, bicycles, and offices easy, this solution is thought to
    provide the foundation for the sharing economy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 科技创业公司Slock.it（[https://slock.it/](https://slock.it/)）正在构建物联网与区块链技术交汇点的“物联网经济”的基础设施。该公司称之为“通用共享网络”的基础设施，有潜力作为金融互联网使用，在其中的自主物体不仅可以出售和出租自己，还可以互相支付服务费用。该公司正在开发的技术，基于以太坊智能合约，旨在为自主物体提供身份认证，并使其能够接收付款和签订协议，而无需中介。已经在这个平台上创建了智能锁柜等应用，这些应用可以在支付费用时解锁物理对象。由于智能锁柜使得租赁体育设备、酒店房间、自行车和办公室变得容易，这种解决方案被认为为共享经济提供了基础。
- en: Decentralized prediction markets
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 去中心化的预测市场
- en: Prediction markets reward people for correctly predicting real-world events,
    such as the winner of a presidential election, the outcome of a referendum, the
    level of interest rates at a specific date, or the winner of a sports competition.
    Aside from speculative uses, they’re also useful tools for economists, public
    administration planners, and corporate strategists, who can base their decisions
    on the event probabilities being currently traded, which are thought to reflect
    the “wisdom of the crowds.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 预测市场通过正确预测现实世界事件来奖励人们，如总统选举的获胜者、公投的结果、特定日期的利率水平或体育比赛的获胜者。除了用于投机，它还是一种有用的工具，供经济学家、公共行政规划者和企业战略家使用，他们可以根据目前市场上正在交易的事件概率做出决策，这些概率被认为反映了“群体智慧”。
- en: 'Although centralized markets such as [predictit.org](http://predictit.org)
    ([www.predictit.org](http://www.predictit.org)) exist, several decentralized initiatives
    are starting to emerge. Augur is a decentralized market prediction platform built
    on Ethereum. The idea is that decentralization brings the following benefits:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在像[predictit.org](http://predictit.org)（[www.predictit.org](http://www.predictit.org)）这样的集中市场，但已经有几个去中心化的倡议开始出现。Augur是一个基于以太坊的去中心化市场预测平台。理念是去中心化能够带来以下好处：
- en: Being based on the Ethereum network, it has no central point of failure, so
    it’s inherently highly available.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于以太坊网络，它没有单一的失败点，因此具有高度的可用性。
- en: 'Nobody controls the definition of markets: anyone can start a new market on
    a new prediction and can get rewarded for having created that market.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人控制市场的定义：任何人都可以开始一个新的市场，对新的预测进行预测，并且可以因为创造了这个市场而获得奖励。
- en: The official outcome of each prediction isn’t decided centrally; it’s crowdsourced
    from market participants, so it’s less likely to be subject to manipulation.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个预测的官方结果并不是集中决定的；它是由市场参与者集体提供的，因此不太可能受到操纵。
- en: Funds are stored on the blockchain, which eliminates counterparty risk, makes
    payment to prediction winners fast, and reduces the likelihood of errors.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金存储在区块链上，消除了对手方风险，支付给预测赢家迅速，并减少了出错的可能性。
- en: International trade finance
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 国际贸易融资
- en: International trade between a supplier and a manufacturer located in different
    countries is a complex business. As you can see in [figure 1.9](#ch01fig09), it’s
    generally based on a complicated workflow involving many parties, such as banks
    that facilitate the payment, commercial intermediaries that facilitate the distribution,
    shipping and delivery companies that transport the goods, insurers that cover
    financial risks while the goods are in transit, and customs officials who check
    the legality of the goods and the payment of import duties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 位于不同国家的供应商和制造商之间的国际贸易是一项复杂的业务。正如你在[图1.9](#ch01fig09)中所看到的，它通常基于一个涉及许多方的复杂工作流程，如银行促进支付、商业中介促进分销、航运和交付公司运输货物、保险公司在货物运输过程中承担金融风险、海关官员检查货物的合法性和支付进口关税。
- en: 'Figure 1.9\. Typical international trade involving many parties: banks, commercial
    intermediaries, shipping companies, insurers, customs officials, and so on'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 涉及许多参与方的典型国际贸易：银行、商业中介、航运公司、保险公司、海关官员等等。
- en: '![](Images/fig01-09_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-09_alt.jpg)'
- en: Parties involved in a specific transaction often have never dealt with each
    other previously. But for the transaction to complete successfully, they must
    communicate with each other effectively, generally through established lengthy
    protocols designed to protect a party against the malicious behavior of another
    party. Parties cross-check each other, and this takes a huge amount of paperwork
    and time, which often causes long delays.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参与特定交易的各方通常以前从未相互交易过。但是，为了使交易成功完成，他们必须有效地相互沟通，通常是通过建立的长达数小时的协议，旨在保护一方免受另一方的恶意行为。各方相互核实，这需要大量的文件和时间，常常导致长时间延迟。
- en: we.trade is a platform sponsored by a consortium of banking partners (including
    Société Générale, Deutsche Bank, Nordea, Santander, and HSBC) that aims at simplifying
    and streamlining such processes with the help of blockchain technology. The platform
    tracks each step of the transaction openly and transparently so that each party
    is able to submit and consume the relevant documentation with the confidence that
    no one will tamper with it. Trades that used to take weeks can be now completed
    in a few days.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: we.trade是一个由银行合作伙伴（包括Société Générale、Deutsche Bank、Nordea、Santander和HSBC）组成的平台，旨在利用区块链技术简化并优化这些流程。该平台公开透明地跟踪交易的每个步骤，以便各方能够提交和消费相关文件，确信没有人会篡改它们。以前需要几周的交易现在可以在几天内完成。
- en: Regulatory auditing
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监管审计
- en: The blockchain is particularly suitable for ensuring that records stored on
    it haven’t been altered or tampered with. Balanc3 is a Dapp built on Ethereum
    that ensures the integrity of accountancy records for regulatory purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链特别适用于确保存储在其中的记录没有被更改或篡改。Balanc3是一个基于以太坊的Dapp，用于确保会计记录的完整性以满足监管要求。
- en: Crowdfunding
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 众筹
- en: WeiFund aims at providing open source modular and extensible decentralized crowdfunding
    utilities based on the Ethereum blockchain. Users can set up and manage crowdfunding
    campaigns through these utilities. The possibility of encoding funding rules based
    on smart contract technology allows users to know precisely what will happen with
    their money if the campaign fails or is successful.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: WeiFund旨在提供基于以太坊区块链的开源模块化和可扩展的众筹工具。用户可以通过这些工具建立和管理众筹活动。基于智能合约技术编码的筹款规则使得用户能够确切知道如果活动失败或成功，他们的钱会发生什么。
- en: Gambling
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赌博
- en: Intuitively, a natural fit for a decentralized application is a gambling platform,
    because users get the benefit of being assured that bets are processed fairly
    and predictably. Edgeless is an example of such a platform, and it’s currently
    being developed after a successful crowdfunding campaign.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，一个自然适合去中心化应用的平台是一个赌博平台，因为用户可以确保投注被公平且可预测地处理。Edgeless就是这样一个平台的例子，它在一个成功的众筹活动之后目前正在开发中。
- en: Now that you’ve learned about some successful Dapp implementations, you might
    be wondering whether it’s always worth basing your application on blockchain technology.
    We’ll explore this in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了某些成功的Dapp实现，你可能想知道是否总是值得将你的应用程序建立在区块链技术之上。我们将在下一节探讨这个问题。
- en: 1.2.2\. Pointless Dapps
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2. 无意义的Dapps
- en: 'Deciding whether the blockchain is a suitable technology for an application
    you’re planning to build might be difficult. What you should ask yourself is whether
    the functionality that a blockchain platform offers will meet your business requirements.
    More importantly, consider whether the benefits of using such a platform would
    be outweighed by all the technical limitations and additional complexities that
    come with this technology. A sobering blog post titled “Avoiding the Pointless
    Blockchain Project”^([[2](#ch01fn02)]) analyzes the requirements necessary to
    justify the use of a blockchain platform over more traditional technologies such
    as SQL or NoSQL databases. It concludes that a blockchain project only makes sense
    if you can answer yes to all of the following questions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 决定区块链是否是一个适合你计划构建的应用的技术可能会很困难。你应该问自己的是，区块链平台提供的功能是否符合你的业务需求。更重要的是，考虑使用此类平台的好处是否会因这项技术带来的所有技术限制和额外的复杂性而抵消。一篇题为“避免无意义的区块链项目”的冷静博文([[2](#ch01fn02)])分析了使用区块链平台而非更传统的如SQL或NoSQL数据库等技术的需求。它得出结论，只有在你能对以下所有问题回答“是”的情况下，区块链项目才是有意义的：
- en: ²
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gideon Greenspan, “Avoiding the Pointless Blockchain Project,” [http://mng.bz/4Oqg](http://mng.bz/4Oqg).
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 避免无意义的区块链项目](http://mng.bz/4Oqg)。
- en: Does your application require a shared database?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序需要一个共享数据库吗？
- en: Does the database need to support multiple writing parties?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库是否需要支持多个写入方？
- en: Do the writing parties have no trust in each other?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入方之间是否互不信任？
- en: Do the writing parties want to modify the state of the database directly, without
    requiring a central entity trusted by all participants?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入方是否希望直接修改数据库的状态，而不需要所有参与者都信任的中心实体？
- en: Do transactions that the writing parties create interact collaboratively with
    each other?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入方创建的交易是否相互协作地交互？
- en: According to these criteria, for example, an internal enterprise application
    that wouldn’t expose any data to external parties wouldn’t be a suitable choice
    for a Dapp. Other poor Dapp candidates are applications for which confidentiality
    around the business rules is important. A smart contract is, by definition, completely
    open and transparent to all interacting parties. Therefore, preventing participants
    from accessing and understanding the logic of the rules would defeat the purpose.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些标准，例如，一个不会向外部各方暴露任何数据的内部企业应用不适合作为Dapp。其他不适合作为Dapp的候选应用是那些业务规则保密性重要的应用。智能合约，按定义，对所有交互方完全公开和透明。因此，防止参与者访问和理解规则的逻辑将违背目的。
- en: Although decentralized microblogging applications such as EthTweet are considered
    sensible Dapps to those who value the fact that messages can’t be censored and
    altered after they’re sent, an instant messaging Dapp, such as a “decentralized
    WhatsApp,” wouldn’t be a particularly useful product for a fundamental reason.
    One of the technical downsides of the blockchain platform is that processing transactions
    (in this case instant messages) requires roughly 15 seconds to consolidate a new
    blockchain block. Therefore, messages would never be *instant* at all.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像EthTweet这样的去中心化微博应用被那些重视信息发送后不能被审查和修改的人来说是合理的Dapp，但一个即时通讯的Dapp，比如一个“去中心化的WhatsApp”，并不会是一个特别有用的产品，原因在于一个基本的技术缺点。区块链平台的一个技术缺点是处理交易（在这种情况下是即时消息）需要大约15秒来巩固一个新的区块链区块。因此，消息根本不可能*即时*。
- en: When building a Dapp, you also should keep in mind some operational aspects
    that, given the novelty of the technology, may cause some issues down the road.
    For instance, although a smart contract can automatically guarantee funds are
    routed and released subject to certain conditions, a commercial transaction might
    also be subject to real-world conditions that programming logic can’t enforce.
    A classic example for a non-fully automatically enforceable smart contract is
    that of an electronic loan. If the borrower had to keep the borrowed money stuck
    on a blockchain account so a smart contract could automatically give it back to
    the lender if the borrower missed an interest payment, the borrowing wouldn’t
    make any economic sense. In these cases, it isn’t clear yet whether a court of
    law would be able to enforce the nonautomated elements of a smart contract or
    it would be necessary to complement the deal with a traditional legal arrangement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Dapp时，你还应该考虑一些操作方面的问题，由于这项技术的新颖性，这些问题可能会在以后出现。例如，尽管智能合约可以自动保证在满足某些条件的情况下路由和释放资金，但商业交易也可能受到现实世界条件的影响，这些条件编程逻辑无法强制执行。一个非完全自动强制执行的经典智能合约例子是电子贷款。如果借款人必须将借来的钱困在区块链账户上，以便智能合约能够在借款人错过利息支付时自动将其还给贷款人，那么借款在经济上就没有任何意义。在这些情况下，法院是否能够强制执行智能合约的非自动元素尚不明确，或者是否需要用传统法律安排来补充交易。
- en: 1.3\. A five-minute Dapp implementation
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 五分钟的Dapp实现
- en: By now, you should have a good understanding of what a Dapp is, the purpose
    of Dapps over conventional apps, the main architectural components of a decentralized
    application, and whether it makes sense to embark on a project based on blockchain
    technologies. It’s now time to take one little step further and get on with some
    programming. In the rest of the chapter, you’ll start building the smart contract
    for a custom cryptocurrency. You’ll then activate it and interact with it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对Dapp有了很好的了解，包括Dapp与传统应用相比的目的，去中心化应用程序的主要架构组件，以及基于区块链技术进行项目是否合理。现在，是时候再迈出一小步，开始进行编程了。在本章的剩余部分，你将开始构建一个自定义加密货币的智能合约。然后激活它并与之交互。
- en: 1.3.1\. Building SimpleCoin, a basic cryptocurrency
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1. 构建基本加密货币SimpleCoin
- en: Most Dapps are designed using functionality based on the exchange of cryptocurrency
    or tokens through rules encoded in one or more smart contracts. You’ll start to
    get a feel for Dapps programming by building SimpleCoin, a basic cryptocurrency
    that will present useful preliminary concepts about smart contracts and the Ethereum
    platform. You’ll progressively build on it in the following chapters, where you’ll
    learn more about Dapp development. You’ll also use or reference SimpleCoin from
    other Dapps that you’ll build in later chapters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Dapp都是基于加密货币或代币的交换功能设计的，这些功能编码在一个或多个智能合约中。你将通过构建一个名为SimpleCoin的基本加密货币来开始了解Dapp编程，它将为你提供关于智能合约和以太坊平台的有用的初步概念。在接下来的章节中，你将逐步在此基础上构建，了解更多关于Dapp开发的内容。你还将从其他章节中构建的Dapp中使用或参考SimpleCoin。
- en: Because you haven’t installed an Ethereum platform client on your computer yet,
    you’ll be writing code on the Remix Solidity (previously known as Browser Solidity)
    integrated development environment (IDE) for now. This online tool will allow
    you to implement smart contracts in a high-level language called Solidity, similar
    to Java-Script, and run them on a local JavaScript VM that emulates the Ethereum
    Virtual Machine that you’ll meet in the next chapter. It’s also possible through
    this tool to interact with real smart contracts deployed on the Ethereum network.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你还没有在电脑上安装以太坊平台客户端，你现在将使用Remix Solidity（以前称为Browser Solidity）集成开发环境（IDE）编写代码。这个在线工具将允许你使用类似于JavaScript的高级语言Solidity实现智能合约，并在本地JavaScript虚拟机上运行，该虚拟机模拟你将在下一章遇到的以太坊虚拟机。通过这个工具，还可以与部署在以太坊网络上的真实智能合约进行交互。
- en: 'Open a web browser and go to: [http://remix.ethereum.org/](http://remix.ethereum.org/).
    You should see a screen like [figure 1.10](#ch01fig10). On the website, the left
    side of the IDE is a file explorer (which you can hide by clicking the double
    arrow toggle at the top left); in the middle you have the code editor; and the
    right side contains various panels to run the code and interact with it.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器，访问：[http://remix.ethereum.org/](http://remix.ethereum.org/)。你应该会看到类似图1.10[
    figure 1.10](#ch01fig10)的屏幕。在网站上，IDE的左侧是一个文件资源管理器（你可以通过点击左上角的的双箭头切换按钮来隐藏它）；中间是代码编辑器；右侧包含运行代码和与之交互的各种面板。
- en: Figure 1.10\. Screenshot of the Remix opening screen, with the code on the left
    and the code execution panels on the right. I’ve hidden the file explorer by clicking
    the double arrow toggle at the top left.
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10\. Remix启动屏幕的截图，左侧是代码，右侧是代码执行面板。我已经通过点击左上角的的双箭头切换按钮隐藏了文件资源管理器。
- en: '![](Images/fig01-10_alt.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-10_alt.jpg)'
- en: In your first encounter with Solidity, you’ll implement the simplest possible
    smart contract. If you think of a smart contract as the equivalent of a class
    in an object-oriented language, you’ll write a single class with only one member
    field, one constructor, and one method. Then you’ll run it and interact with it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在你第一次接触Solidity时，你将实现最简单的智能合约。如果你把智能合约看作是面向对象语言中类的等价物，那么你将写出一个只有一个成员字段、一个构造函数和一个方法的单一类。然后你将运行它并与它交互。
- en: Hide the file explorer by clicking the double arrow toggle at the top left,
    and then enter the code in [listing 1.1](#ch01ex01) in the Remix editor, in the
    left side of the screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击左上角的的双箭头切换按钮隐藏文件资源管理器，然后在第1.1节[清单](#ch01ex01)中，在屏幕左侧的Remix编辑器中输入代码。
- en: Listing 1.1\. First implementation of SimpleCoin, a basic cryptocurrency
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单1.1\. SimpleCoin的基本加密货币的第一次实现
- en: '[PRE0]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Pragma directive indicating the supported version of the Solidity
    compiler. (The code supports a compiler later than 0.4.0 but earlier than 0.5.0.)**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **Pragma指令指定了Solidity编译器支持版本（代码支持0.4.0之后、0.5.0之前的编译器）**'
- en: '***2*** **Defines a contract, which is similar to a class in other languages**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义一个合约，这与其他语言中的类相似**'
- en: '***3*** **Defines a state variable as a “mapping” between an address and an
    integer. A state variable is the equivalent of a member variable. A mapping is
    equivalent to a hash table or hash map.**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义一个状态变量作为一个“映射”（between an address and an integer）。状态变量相当于一个成员变量。映射相当于哈希表或哈希映射。**'
- en: '***4*** **Starts defining the contract constructor**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **开始定义合约构造函数**'
- en: '***5*** **Assigns 10,000 SimpleCoin tokens to the coin account with address
    0x14723a09acff6d2a60dcdf7aa4aff308fddc160c at contract creation**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在合约创建时将10,000 SimpleCoin代币分配给地址为0x14723a09acff6d2a60dcdf7aa4aff308fddc160c的代币账户**'
- en: '***6*** **Defines a function that moves a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **定义了一个函数，将一定数量的SimpleCoin代币从函数调用者的代币账户移动到指定的代币账户**'
- en: '***7*** **Decreases the coin balance of the message sender by the specified
    number of tokens. (The special implicit property msg.sender represents the address
    of the sender of the transaction.)**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **通过特定数量的代币减少消息发送者的币余额。 （特殊的隐式属性msg.sender代表交易发送者的地址。）**'
- en: '***8*** **Increases the coin balance by the specified number of tokens**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **通过特定数量的代币增加币余额**'
- en: 'Let’s examine this code in detail. A *contract* in Solidity is a type similar
    to a class in any other language: it has *state variables* (such as `coinBalance`),
    a constructor, functions (such as `transfer`), and events.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这段代码。在Solidity中，*合约*是一种与其他语言中的类相似的类型：它有*状态变量*（如`coinBalance`）、构造函数、函数（如`transfer`）和事件。
- en: The `coinBalance` state variable is defined as a `mapping`. A *mapping* is a
    hash map, equivalent to a hashMap in Java, Dictionary in C#, or dict in Python.
    In this example, the type of the key is an `address`, whereas the value is a `uint256`—an
    unsigned 256-bit integer. An *address* holds a 20-byte value and can identify
    a specific smart contract account or a specific user account. An account, as you’ll
    see later in detail, is the sender or the receiver of a transaction. The `coinBalance`
    state variable therefore represents a collection of coin accounts, each holding
    a number of SimpleCoin tokens.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`coinBalance` 状态变量被定义为一个 `mapping`。*mapping* 是一个哈希表，相当于 Java 中的 hashMap、C#
    中的 Dictionary 或 Python 中的 dict。在此示例中，键的类型是一个 `address`，而值是一个 `uint256`——一个无符号的256位整数。*address*
    保持一个20字节值，可以识别一个特定的智能合约账户或一个特定的用户账户。如您稍后详细看到的，账户是交易的发送者或接收者。因此 `coinBalance` 状态变量代表了一组代币账户，每个账户都持有若干
    SimpleCoin 代币。'
- en: The `transfer` function is meant to move a number of SimpleCoin tokens from
    the coin account of the function caller to a specified coin account. In smart
    contract terminology, a function caller is the *transaction sender*. `msg` is
    a special implicitly defined variable that represents the incoming message. It
    has various properties, among which `msg.sender` represents the address of the
    sender of the transaction, who is the caller of `transfer`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`transfer` 函数旨在将一定数量的 SimpleCoin 代币从函数调用者的代币账户转移到指定的代币账户。在智能合约术语中，函数调用者是 *交易发送者*。`msg`
    是一个特殊隐式定义的变量，代表传入的消息。它有各种属性，其中 `msg.sender` 代表交易发送者的地址，即 `transfer` 的调用者。'
- en: The body of the transfer function is simple to understand. It involves subtracting
    the specified amount from the cash account associated with the function caller
    and adding the amount specified in the `_amount` parameter to the account associated
    with the address specified in the `_to` parameter. To keep this initial code simple,
    this implementation isn’t performing any boundary checks yet on the number of
    SimpleCoin tokens owned by the transaction sender, who, for example, shouldn’t
    be allowed to send more tokens than they own. You’ll perform such checks when
    we revisit SimpleCoin in later chapters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`transfer` 函数的主体简单易懂。它涉及从与函数调用者关联的现金账户中减去指定金额，并将 `_amount` 参数中指定的金额添加到 `_to`
    参数中指定的地址关联的账户。为了保持这个初始代码简单，此实现尚未对交易发送者拥有的 SimpleCoin 代币数量执行任何边界检查，例如，不应该允许发送比他们拥有的更多代币。当我们在后面的章节中重新访问
    SimpleCoin 时，您将执行此类检查。'
- en: At this point, you should understand that your `SimpleCoin` contract is, in
    practice, a class with a constructor (`SimpleCoin` function), some state (`coinBalance`
    variable), and a method (`transfer` function). [Table 1.2](#ch01table02) gives
    a quick summary of the Solidity keywords you’ve come across.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您应该明白您的 `SimpleCoin` 合约实际上是一个具有构造函数（`SimpleCoin` 函数）、一些状态（`coinBalance`
    变量）和方法（`transfer` 函数）的类。 [表1.2](#ch01table02) 对您已经遇到的 Solidity 关键词进行了简要总结。
- en: Table 1.2\. A summary of Solidity keywords used in the first code sample
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.2. Solidity关键词汇总，用于第一个代码示例
- en: '| Keyword | Explanation |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 关键词 | 解释 |'
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| contract | **Type similar to class in any other language** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| contract | **与其他任何语言中的类相似的类型** |'
- en: '| mapping | **Data structure similar to a hash table or hash map** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| mapping | **与哈希表或哈希映射类似的数据结构** |'
- en: '| address | 20-byte value representing an Ethereum user account or contract
    account |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| address | 表示 Ethereum 用户账户或合约账户的20字节值 |'
- en: '| uint256 | **Unsigned 256-bit integer** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| uint256 | **无符号的256位整数** |'
- en: '| msg | **Special variable representing an incoming message object** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| msg | **代表传入消息对象的特别变量** |'
- en: '| msg.sender | **Property of the msg object representing the address of the
    message sender** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| msg.sender | **msg对象的代表消息发送者地址的属性** |'
- en: 1.3.2\. Running the contract
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2. 运行合约
- en: Move now to the right side of the screen to deploy the `SimpleCoin` contract.
    First, make sure the Auto Compile option in the Compile tab is checked, as shown
    in [figure 1.11](#ch01fig11), so that Remix will recompile the code at every change.
    Also, make sure you’ve selected version 0.4.24 of the compiler (for example 0.4.24+commit.e67f0147),
    because this is the version I’ve been using when writing `SimpleCoin`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标移至屏幕右侧以部署 `SimpleCoin` 合约。首先，确保在编译标签页中的自动编译选项已勾选，如图 [1.11](#ch01fig11) 所示，以便
    Remix 在每次更改后重新编译代码。同时，确保您选择了编译器的 0.4.24 版本（例如 0.4.24+commit.e67f0147），因为我在编写 `SimpleCoin`
    时使用的正是这个版本。
- en: Figure 1.11\. The Auto Compile option in the Compile tab makes sure the code
    entered in the editor is recompiled at every change.
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.11\. 编译选项卡中的自动编译选项确保在每次更改时重新编译编辑器中输入的代码。
- en: '![](Images/fig01-11_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-11_alt.jpg)'
- en: 'If you’ve typed your code correctly (I recommend you copy the code from the
    files provided on the book website!), and no compilation errors have occurred,
    you should see the following buttons in the Run tab: Deploy and At Address, as
    shown in [figure 1.12](#ch01fig12). Ignore At Address for now and focus your attention
    on Deploy. By clicking this button, you’ll deploy the `SimpleCoin` contract on
    an emulated blockchain within Remix.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地输入了您的代码（我建议您从本书网站提供的文件中复制代码！），并且没有发生编译错误，您应该在运行选项卡中看到以下按钮：部署和 At 地址，如图
    [1.12](#ch01fig12) 所示。现在忽略 At 地址，将注意力集中在部署上。通过点击此按钮，您将在 Remix 内模拟的区块链上部署 `SimpleCoin`
    合约。
- en: 'Figure 1.12\. Once the code has been compiled correctly, the Run tab will show
    two buttons: Deploy and At Address. You can instantiate the contract by clicking
    Deploy.'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.12\. 一旦代码正确编译，运行选项卡将显示两个按钮：部署和 At 地址。您可以通过点击部署来实例化合约。
- en: '![](Images/fig01-12_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-12_alt.jpg)'
- en: The contract will be stored against an address on the emulated Ethereum blockchain,
    and a new Deployed Contracts panel will appear, as shown in [figure 1.13](#ch01fig13).
    You can read the deployment address by clicking the Copy Address icon and pasting
    it in Notepad, for example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 合约将被存储在模拟的以太坊区块链上的地址中，并将出现一个新的已部署合约面板，如图 [1.13](#ch01fig13) 所示。您可以通过点击复制地址图标并将其粘贴到记事本等应用程序中来读取部署地址。
- en: Figure 1.13\. After deploying the contract, the Deployed Contracts panel appears,
    containing a drop-down with a SimpleCoin option; click it, and you’ll see the
    contract operations.
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.13\. 部署合约后，已部署合约面板出现，包含一个下拉列表，其中有一个 SimpleCoin 选项；点击它，您将看到合约操作。
- en: '![](Images/fig01-13_alt.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-13_alt.jpg)'
- en: 1.3.3\. Interacting with the contract
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 与合约交互
- en: 'Now that the `SimpleCoin` contract has been deployed, you’ll be able to perform
    simple operations against it: you’ll check SimpleCoin token balances and move
    tokens across accounts.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `SimpleCoin` 合约已经部署，您将能够对其执行简单的操作：您将检查 SimpleCoin 代币余额并在账户之间移动代币。
- en: 'Click the SimpleCoin drop-down list within the Deployed Contracts panel. Two
    new buttons will appear: CoinBalance and Transfer, as shown in [figure 1.14](#ch01fig14).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在已部署合约面板内点击 SimpleCoin 下拉列表。将出现两个新按钮：CoinBalance 和 Transfer，如图 [1.14](#ch01fig14)
    所示。
- en: 'Figure 1.14\. SimpleCoin operations buttons: CoinBalance and Transfer. CoinBalance
    is a getter of the coinBalance state variable and is a read-only operation. Transfer
    allows you to transfer the specified number of tokens to the indicated address.'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.14\. SimpleCoin 操作按钮：CoinBalance 和 Transfer。CoinBalance 是获取 coinBalance
    状态变量的读取操作。Transfer 允许您将指定数量的代币转移到指定的地址。
- en: '![](Images/fig01-14_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig01-14_alt.jpg)'
- en: 'The Remix IDE shows two types of buttons:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Remix IDE 显示两种类型的按钮：
- en: '*Blue buttons*—They perform read operations against the contract, such as checking
    the value of state variables or calling read-only functions.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蓝色按钮*—它们对合约执行读操作，例如检查状态变量的值或调用只读函数。'
- en: '*Red buttons*—They perform write operations against the contract, such as instantiating
    the contract through the constructor (Create), or call functions that modify any
    state variables.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*红色按钮*—它们对合约执行写操作，例如通过构造函数实例化合约（Create），或调用修改任何状态变量的函数。'
- en: In this case, CoinBalance is blue because it allows you to read the coin balance
    associated with an address. Transfer is red because by clicking it you’ll alter
    the state of the contract, specifically by changing values contained in the `coinBalance`
    mapping state variable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，CoinBalance 是蓝色，因为它允许您读取与地址关联的代币余额。Transfer 是红色，因为通过点击它，您将改变合约的状态，具体是通过更改
    `coinBalance` 映射状态变量中的值。
- en: 'Now check that the `coinBalance` associated with the address specified in the
    constructor has the full initial supply of SimpleCoin you set at construction.
    Wrap the address with double quotes: `"0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C"`.
    Enter it in the text box and click CoinBalance. Some output will appear. At the
    bottom, you should see the expected number of SimpleCoin tokens you specified
    in the constructor: 10,000.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is the address of one of the five
    test accounts present on the Remix IDE. You can see them in the Transaction Origin
    drop-down list box on the top-right of the screen. Although they aren’t fully
    visible on the screen, their full addresses are reported in [table 1.3](#ch01table03).
    (I’ve retrieved them one by one by clicking the Copy Address icon next to the
    Account drop-down.)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.3\. Remix test accounts whose full address is hidden behind the HTML
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: 'You can double-check that the amount of SimpleCoin tokens associated with any
    address different from `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` is zero. For
    instance, enter the following address, wrapped with double quotes as you did earlier,
    in the CoinBalance text box: `"0x583031D1113aD414F02576BD6afaBfb302140225"`. After
    clicking the button, you’ll see a zero, as expected.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: To recap, when you instantiated the contract, an amount of 10,000 SimpleCoin
    tokens got assigned as initial money supply to the address starting with `0x14723A09`.
    No other address owns any tokens yet, as summarized in [table 1.4](#ch01table04).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.4\. Balance of each Remix test account after contract instantiation
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **10,000** |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **0** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: 'Now you’ll call the `transfer` function to move some tokens from the account
    with the address starting with `0x14723a09` to a different test account. Because
    the transfer function moves tokens from the account of its caller, the function
    must be called from the contract creator’s address starting with `0x14723a09`.
    Pick this address from the Account drop-down at the top right of the Run tab,
    then enter in the text box of the transfer method the destination address—for
    example, the address starting with `0x4b0897b0`—and a number of tokens to be transferred—for
    instance, 150 tokens. You should separate the values of these parameters with
    a comma:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now click Transfer. The function returns no result, as expected.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Check the number of tokens present in the contract creator’s address by clicking
    CoinBalance after entering the contract creator’s address (`"0x14723A09AC-ff6-D2-A60Dcd-F7aA4AFf308FDDC160C"`)
    in the related text box. The value is now 9,850, as expected.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 点击进入合约创建者的地址（`"0x14723A09AC-ff6-D2-A60Dcd-F7aA4AFf308FDDC160C"`）后的CoinBalance，检查合约创建者的地址中代币的数量。现在的值是9,850，如预期。
- en: If you perform the same check on the destination address (`"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB"`),
    you’ll get 150\. All other addresses still have zero tokens, as summarized in
    [table 1.5](#ch01table05).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对目标地址（`"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB"`）执行相同的检查，你会得到150。所有其他地址仍然没有代币，如[表1.5](#ch01table05)所总结。
- en: Table 1.5\. Balance of each Remix test account after a transfer operation
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.5。转账操作后每个Remix测试账户的余额
- en: '| Account address | Account balance |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 账户地址 | 账户余额 |'
- en: '| --- | --- |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |'
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **9,850** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **9,850** |'
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **150** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **150** |'
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |'
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |'
- en: As an exercise, you can try to transfer coins from the address starting with
    `0x4b0897b05` to a different address and recheck if the amounts are correct. While
    doing so, please don’t perform any crazy transactions yet, such as trying to move
    more coins than a certain address is holding. To keep the code simple for the
    moment, you haven’t coded any boundary conditions to handle such situations. You’ll
    learn about these in the next chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，你可以尝试将`0x4b0897b05`开头的地址的代币转到一个不同的地址，并重新检查金额是否正确。在这个过程中，请不要执行任何疯狂的交易，比如尝试移动一个地址持有的比更多代币。为了保持代码目前简单，你没有编写任何边界条件来处理这种情况。你将在下一章学习这些内容。
- en: Although the code you’ve written so far is simple, your main objective at this
    stage was only to start to familiarize yourself with smart contracts, the Solidity
    language, and Remix. By now, you should have achieved that objective, and you
    should understand how contract instantiation works and how to interact with a
    contract from different accounts.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你到目前为止所写的代码很简单，但在这个阶段的唯一目标是开始熟悉智能合约、Solidity语言和Remix。到现在，你应该已经实现了这个目标，并且你应该理解合约实例化是如何工作的，以及如何从不同的账户与合约进行交互。
- en: SimpleCoin is still at the stage of an embryonic Dapp. So far, you’ve only executed
    its code on a JavaScript VM-based simulator and, because it’s lacking a UI, you’ve
    seen its output through Remix. In the next chapter, you’ll take a step further
    and install an Ethereum client. You’ll then deploy SimpleCoin to a real Ethereum
    network and interact with it again.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleCoin仍处于一个胚胎期的Dapp阶段。到目前为止，你只是在基于JavaScript VM的模拟器上执行了它的代码，因为它缺少UI，所以你是通过Remix看到它的输出的。在下一章，你将更进一步，安装一个以太坊客户端。然后你将在真正的以太坊网络上部署SimpleCoin，并再次与之交互。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If the compiler configured in the Compile tab is version 0.4.25, Remix will
    only allow you to enter addresses with a valid checksum in the code editor. I’ll
    explain what a valid checksum is in [chapter 5](kindle_split_017.xhtml#ch05).
    But for now, it means `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c` (all in lowercase)
    and `0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C` aren’t interpreted as being equivalent
    to each other. Unfortunately, addresses in the Account drop-down within the Run
    tab are all in lowercase and therefore aren’t compliant. If you want to know the
    corresponding address with a valid checksum, you can use Etherscan, the online
    blockchain viewer ([https://etherscan.io/](https://etherscan.io/)). Enter the
    incorrectly formatted address (for example, `0x14723a09acff6d2a60dcdf7aa4aff308fddc160c)`
    in the text box at the top of the screen, and you’ll see the correctly formatted
    corresponding address (`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`) in the Address
    header also at the top of the screen.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器配置在“编译”标签中是0.4.25版本，Remix将只允许你在代码编辑器中输入具有有效校验和的地址。我将在[第5章](kindle_split_017.xhtml#ch05)解释什么是有效校验和。但目前，它意味着`0x14723a09acff6d2a60dcdf7aa4aff308fddc160c`（全部小写）和`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`不被解释为彼此等价。不幸的是，运行标签中的账户下拉菜单中的所有地址都是小写的，因此不符合要求。如果你想知道具有有效校验和的对应地址，你可以使用Etherscan，一个在线区块链浏览器（[https://etherscan.io/](https://etherscan.io/)）。在屏幕顶部的文本框中输入格式不正确的地址（例如，`0x14723a09acff6d2a60dcdf7aa4aff308fddc160c)`，你将在屏幕顶部同样顶部的地址栏中看到格式正确的对应地址（`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`）。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: A decentralized application is a novel type of application that isn’t owned
    or controlled by any entity and runs on a trustless decentralized P2P network.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用是一种新型的应用，它不由任何实体拥有或控制，并在无需信任的分布式P2P网络上运行。
- en: The topology of a decentralized application is different from that of a conventional,
    centralized, one because both its business logic layer and its data layer (the
    blockchain) are fully replicated on each node of the network.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用的网络拓扑与传统的、中心化的应用不同，因为它的业务逻辑层和数据层（区块链）在网络的每个节点上都完全复制。
- en: Dapps rely on blockchain technology, which is based, in turn, on public key
    cryptography, cryptographic hash functions, and the concept of mining through
    a consensus protocol.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapps依赖于区块链技术，而区块链技术又基于公钥密码学、密码学哈希函数和通过共识协议挖矿的概念。
- en: Many appropriate use cases exist for decentralizing an application, especially
    in the fields of provenance and authenticity tracking, identity verification,
    regulatory auditing, prediction markets, and crowdfunding.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多合适的用例都适用于去中心化应用，特别是在来源和真实性追踪、身份验证、合规审计、预测市场和众筹等领域。
- en: Decentralized applications aren’t always the best solution for a business problem.
    For example, it doesn’t make sense to decentralize an internal enterprise application
    that isn’t shared with any external participant.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用并不总是解决业务问题的最佳方案。例如，将一个不与任何外部参与者共享的内部企业应用去中心化是没有意义的。
- en: You can implement smart contracts, which are at the heart of Dapps, within the
    Ethereum platform in a language called Solidity, similar to JavaScript. It’s possible
    to write simple smart contracts through the Remix Solidity IDE and simulate their
    activation and interaction with various mock Ethereum accounts.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以太坊平台上使用类似于JavaScript的Solidity语言实现智能合约，这是Dapps的核心。通过Remix Solidity IDE，你可以编写简单的智能合约，并模拟它们的激活和与各种模拟以太坊账户的互动。
- en: Chapter 2\. Understanding the blockchain
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章. 理解区块链
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '**This chapter covers**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Low-level details of an Ethereum node
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊节点的低级细节
- en: The technology stack you use to build Ethereum Dapps
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建以太坊Dapps所使用的技术栈
- en: Technologies underlying the Ethereum blockchain
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊区块链背后的技术
- en: Ethereum’s history and governance
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊的历史和治理
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: I intended [chapter 1](kindle_split_012.xhtml#ch01) to give you a high-level
    overview of decentralized applications without overwhelming you with too many
    details. Consequently, I’m sure you’re still wondering what technical stack you
    need to learn to build a full Dapp. Also, you might feel the architectural presentation
    on Dapps didn’t go as far as you’d have liked, and you might still have doubts
    about how a blockchain exactly works. If you’re asking yourself these questions,
    I’ll address them in this chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我本意是[第1章](kindle_split_012.xhtml#ch01)给你提供去中心化应用的高级概览，而不会让你感到过于详细的信息。因此，我相信你仍然想知道你需要学习什么技术堆栈来构建一个完整的Dapp。另外，你可能会觉得Dapps的建筑呈现没有达到你想要的程度，你可能仍然对区块链如何工作有所疑虑。如果你自己在问这些问题，我将在这一章中回答它们。
- en: I’ll start by revisiting the voting Dapp I introduced in the previous chapter,
    and I’ll cover some aspects of an Ethereum node I skipped earlier for simplicity.
    I’ll then cover the entire technology stack required to implement a full end-to-end
    decentralized application. Additionally, I’ll introduce the cryptographic concepts
    and foundations you need to acquire to appreciate how a blockchain works. Before
    closing the chapter, I’ll present technologies specific to the Ethereum blockchain
    and give you some information on Ethereum’s history and governance.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先重新审视前章中我介绍的投票Dapp，并覆盖我之前为了简单起见而跳过的以太坊节点的某些方面。然后，我将涵盖实现完整端到端去中心化应用所需整个技术堆栈。此外，我将介绍你需要掌握的密码学概念和基础，以理解区块链是如何工作的。在章节结束之前，我将介绍以太坊区块链特有的技术，并给你一些关于以太坊历史和治理的信息。
- en: 2.1\. A deeper look at decentralized applications
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 深入查看去中心化应用
- en: When I presented the structural and transactional views of a decentralized application
    in [chapter 1](kindle_split_012.xhtml#ch01), I decided to keep them at a relatively
    high level. I’m aware blockchain technology might be completely new to you, so
    I wanted to make sure you understood the high-level architecture and the purpose
    of decentralized applications without confusing you with too much jargon and too
    many technologies. Now that you’ve acquired a solid foundation, it’s time to have
    a deeper look at Ethereum Dapps. Let’s start by stepping into an Ethereum node.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我队在[第1章](kindle_split_012.xhtml#ch01)中呈现去中心化应用的结构和交易视图时，我决定保持在一个相对较高的层面。我明白区块链技术可能对你来说完全是新的，所以我想确保你理解去中心化应用的高级架构和目的，而不是用太多的行话和太多的技术让你感到困惑。既然你已经打下了坚实的基础，那就是深入了解以太坊Dapp的时候了。让我们先走进一个以太坊节点。
- en: 2.1.1\. Inside an Ethereum node
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1. 在以太坊节点内部
- en: 'As shown in [figure 2.1](#ch02fig01), each node of the Ethereum P2P network
    contains two main components:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[2.1](#ch02fig01)所示，以太坊P2P网络的每个节点包含两个主要组件：
- en: '*An Ethereum client*—This acts as a runtime and contains four elements:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*以太坊客户端*——这作为运行时，包含四个元素：
- en: A virtual machine called *Ethereum Virtual Machine (EVM)*, capable of executing
    smart contract code generally written in a language called Solidity and compiled
    into EVM bytecode.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为*以太坊虚拟机(EVM)*的虚拟机，能够执行通常用名为Solidity的语言编写的智能合约代码，并编译成EVM字节码。
- en: 'Figure 2.1\. An Ethereum node includes an Ethereum client and a blockchain
    database. The client contains a client process, an Ethereum Virtual Machine, a
    memory pool, and a JSON-RPC API exposing the functionality of the node externally.
    There are two types of nodes: full nodes and mining nodes.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1. 一个以太坊节点包括一个以太坊客户端和一个区块链数据库。客户端包含一个客户端进程、一个以太坊虚拟机、一个内存池和一个暴露节点外部功能的JSON-RPC
    API。节点有两种类型：完整节点和挖矿节点。
- en: '![](Images/fig02-01_alt.jpg)'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig02-01_alt.jpg)'
- en: A *memory pool*, where the node stores transactions that it receives, such as
    a vote submitted by a voter from the client side, before it propagates them further
    into the network.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*内存池*，节点在此存储它接收到的交易，如来自客户端方面的选民提交的投票，然后再将它们传播到网络中。
- en: A *client process*, which coordinates the processing. It handles incoming messages
    and transactions, dispatches them to the EVM when appropriate, and stores transactions
    to, and retrieves them from, the memory pool. The client process also handles
    incoming blockchain blocks that the node receives from peer nodes and appends
    them to the local copy of the blockchain database.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*客户端进程*，负责协调处理工作。它处理传入的消息和交易，在合适的时候将它们分派到EVM，并将交易存储到内存池中，从内存池中检索它们。客户端进程还处理节点从对等节点接收到的区块链块，并将它们附加到区块链数据库的本地副本。
- en: A *JSON-RPC API*, which exposes the functionality of the client to other nodes
    and external users.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON-RPC API*，它暴露客户端的功能给其他节点和外部用户。'
- en: '*A blockchain database*—Apart from transaction data, such as votes submitted
    by voters, the blockchain also keeps a copy of the EVM bytecode of all smart contracts
    deployed on the network and holds their state. Mining nodes append new blocks
    to the blockchain regularly, every 15 seconds.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*区块链数据库*——除了交易数据（如选民提交的投票），区块链还保留网络上所有部署的智能合约的EVM字节码的副本，并持有它们的状态。矿工节点定期在区块链上添加新块，每隔15秒一次。'
- en: 2.1.2\. Revisiting the lifecycle of a transaction
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 重新审视交易的生命周期
- en: Now that you know an Ethereum node hosts a JSON-RPC interface, an EVM, and a
    memory pool, I can explain to you, with the help of some diagrams ([figures 2.2](#ch02fig02)
    to [2.4](#ch02fig04)), what role they play during the transaction lifecycle.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道以太坊节点托管了一个JSON-RPC接口、一个EVM和一个内存池，我可以借助一些图表（[图2.2](#ch02fig02)至[2.4](#ch02fig04)）向你解释它们在交易生命周期中扮演的角色。
- en: Figure 2.2\. The lifecycle of a transaction. A voting transaction is created
    when a function is invoked on a smart contract on a chosen Ethereum node through
    the JSON-RPC interface. The node places the transaction in the memory pool and
    executes it on the EVM for validation. If the validation is successful, the transaction
    is broadcast to peer nodes until it reaches a mining node; otherwise, it dies
    out.
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 交易的生命周期。当在选定的以太坊节点上的智能合约上通过JSON-RPC接口调用函数时创建投票交易。节点将交易放入内存池并在EVM上执行以进行验证。如果验证成功，交易会被广播到同伴节点，直到它达到矿工节点；否则，它就会消亡。
- en: '![](Images/fig02-02_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-02_alt.jpg)'
- en: A transaction is generated when a function is invoked on a smart contract of
    the chosen Ethereum node through the JSON-RPC interface. (See [figure 2.2](#ch02fig02).)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过JSON-RPC接口在选定的以太坊节点上的智能合约上调用函数时生成交易。（参见[图2.2](#ch02fig02)。）
- en: A full node receives the transaction from a peer node and places it in the memory
    pool. (See [figure 2.2](#ch02fig02).)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个完整节点从同伴节点接收交易，并将其放入内存池中。（参见[图2.2](#ch02fig02)。）
- en: The full node executes the transaction on the EVM for validation. (See [figure
    2.2](#ch02fig02).)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整节点在EVM上执行交易以进行验证。（参见[图2.2](#ch02fig02)。）
- en: If the validation is successful, the node broadcasts the transaction to its
    peer nodes. If the validation is unsuccessful, the node doesn’t propagate the
    transaction further, and it dies out.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果验证成功，节点将其交易广播给它的同伴节点。如果验证失败，节点不会进一步传播交易，它就会消亡。
- en: A mining node places the transaction received from a peer node in the memory
    pool. (See [figure 2.3](#ch02fig03).)
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个矿工节点将来自同伴节点的交易放入内存池中。（参见[图2.3](#ch02fig03)。）
- en: The mining node picks transactions deemed to be profitable from the memory pool,
    executes them on the EVM, and tries to add them onto a new block. (See [figure
    2.3](#ch02fig03).)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矿工节点从内存池中选择被认为是盈利的交易，在EVM上执行它们，并尝试将它们添加到新区块中。（参见[图2.3](#ch02fig03)。）
- en: If the block created is added successfully to the blockchain, the mining node
    removes the related transactions from the memory pool. (See [figure 2.3](#ch02fig03).)
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功将创建的块添加到区块链，矿工节点将内存池中与相关交易移除。（参见[图2.3](#ch02fig03)。）
- en: Figure 2.3\. A mining node receives the transaction from a peer node and places
    it in its memory pool. The node later picks it and executes it on the EVM, among
    other transactions, to place it on a new block. If the block is appended on the
    blockchain, the transaction is removed from the memory pool and the block is broadcast
    to peer nodes.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 矿工节点从同伴节点接收交易并将其放入其内存池中。节点随后挑选它并在EVM上与其他交易一起执行，将其放在新区块中。如果块被添加到区块链上，交易将被从内存池中移除，并将块广播给同伴节点。
- en: '![](Images/fig02-03_alt.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/fig02-03_alt.jpg)'
- en: The node broadcasts the new block to peer nodes. (See [figure 2.3](#ch02fig03).)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点将新块广播给同伴节点。（参见[图2.3](#ch02fig03)。）
- en: A full node receives the new block from a peer node. (See [figure 2.4](#ch02fig04).)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个完整节点从同伴节点接收新块。（参见[图2.4](#ch02fig04)。）
- en: The full node executes all the block transactions on the EVM for validation.
    (See [figure 2.4](#ch02fig04).)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整节点在EVM上执行所有区块交易以进行验证。（参见[图2.4](#ch02fig04)。）
- en: The node removes all the associated transactions from its memory pool if the
    block has been validated successfully. (See [figure 2.4](#ch02fig04).)
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果块成功验证，节点将其内存池中所有相关交易移除。（参见[图2.4](#ch02fig04)。）
- en: The node broadcasts the block to peer nodes. (See [figure 2.4](#ch02fig04).)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点将区块广播给对等节点。（参见[图2.4](#ch02fig04)。）
- en: Figure 2.4\. The full node’s process, from when it receives the new block to
    when it processes all its transactions on the EVM for validation, then, if validation
    is successful, removes the related transactions from the memory pool and propagates
    the block further into the network
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4. 从节点接收到新区块开始，到它在EVM上处理所有交易进行验证，然后，如果验证成功，将相关交易从内存池中移除并进一步传播到网络中
- en: '![](Images/fig02-04_alt.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-04_alt.jpg)'
- en: '2.1.3\. Development view: Deploying the voting smart contract'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3节. 开发视图：部署投票智能合约
- en: By now, you should have a good idea of both what a decentralized application
    looks like and how a transaction flows throughout the system. You might still
    be wondering, though, when and how a smart contract gets propagated throughout
    the network. It turns out that the server-side contract propagation process is
    similar to that of a standard transaction, such as the voting transaction analyzed
    in the previous chapter in [figure 1.8](kindle_split_012.xhtml#ch01fig08).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对去中心化应用程序的外观以及交易如何在系统中流转有一个很好的了解。不过，您可能仍在想知道智能合约何时以及如何传播到整个网络。结果是，服务器端合约传播过程与标准交易（如前章分析的[图1.8](kindle_split_012.xhtml#ch01fig08)中的投票交易）类似。
- en: An Ethereum smart contract, such as the voting smart contract of the voting
    Dapp, is code written in the Solidity language. A smart contract developer compiles
    the code into EVM bytecode and then deploys it across the P2P network through
    a contract deployment transaction, which executes on a local Ethereum node and
    then propagates throughout the network. During its propagation throughout the
    network, a mining node processes the deployment transaction and stores its EVM
    bytecode on the blockchain, as illustrated in [figure 2.5](#ch02fig05).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊智能合约，如投票Dapp的投票智能合约，是用Solidity语言编写的代码。智能合约开发者将代码编译成EVM字节码，然后通过合约部署交易将其部署到P2P网络中，该交易在本地以太坊节点执行，然后传播到整个网络。在其传播过程中，矿工节点处理部署交易，并在区块链上存储其EVM字节码，如图2.5所示。
- en: Figure 2.5\. A developer writes the voting smart contract in the Solidity language,
    then compiles it into EVM bytecode and inserts it into a contract deployment transaction.
    This is pushed to the local Ethereum node and propagated throughout the network.
    It’s then mined and appended to the blockchain.
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5. 开发者用Solidity语言编写投票智能合约，然后将其编译成EVM字节码并插入到合约部署交易中。该交易会被推送到本地以太坊节点，并传播到整个网络。随后被矿工挖掘并添加到区块链上。
- en: '![](Images/fig02-05_alt.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-05_alt.jpg)'
- en: You might have noticed, while going through the static, dynamic, and development
    views of a Dapp, in these two initial chapters, that I’ve mentioned languages
    and Java-Script libraries that might be unfamiliar to you. You shouldn’t be particularly
    worried about the amount of technology you’ll have to learn. You can implement
    a Dapp based on the Ethereum blockchain with languages much like those used in
    centralized apps you’re already familiar with. The client side of a Dapp is generally
    based on standard HTML5 + JavaScript; the communication layer between the UI and
    the server side is based on a JavaScript library called Web3 that’s executed on
    the client side; and you can implement server-side smart contracts in Solidity,
    which is a flavor of JavaScript.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章的前两节，关于Dapp的静态、动态和开发视图时，你可能会注意到我提到了一些可能会让你感到陌生的语言和JavaScript库。你不必过于担心需要学习的技术含量。你可以使用与您已经熟悉的中心化应用相似的编程语言来实现基于以太坊区块链的Dapp。Dapp的客户端通常基于标准的HTML5+JavaScript；UI与服务器端之间的通信层基于在客户端执行的JavaScript库Web3；您还可以使用Solidity实现服务器端智能合约，这是JavaScript的一种变体。
- en: Your journey through this book will continue, as shown in [figure 2.6](#ch02fig06),
    from the server side, which is the core of decentralized applications, and you’ll
    write smart contracts in Solidity. Then you’ll learn how to interact with a smart
    contract remotely through the Web3.js JavaScript library. Finally, you’ll implement
    a web-based UI, built on HTML and JavaScript.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图2.6](#ch02fig06)所示，您将继续通过服务器端深入了解去中心化应用的核心，您将使用Solidity编写智能合约。然后，您将学习如何使用Web3.js
    JavaScript库远程与智能合约进行交互。最后，您将实现一个基于HTML和JavaScript的Web UI。
- en: Figure 2.6\. You’ll progress from writing smart contracts in Solidity, to interacting
    with smart contracts remotely through the Web3.js Java-Script library, to building
    a web UI in HTML and JavaScript.
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6。你将从用Solidity编写智能合约开始，然后通过Web3.js Java-Script库远程与智能合约交互，最后用HTML和JavaScript构建web
    UI。
- en: '![](Images/fig02-06_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-06_alt.jpg)'
- en: In summary, with some knowledge of JavaScript, or any C-like language, it isn’t
    difficult to transition from centralized to decentralized application development.
    But during that transition, it’s important to fully understand the technologies
    underlying decentralized applications, because they’re rather different from the
    technologies that centralized applications are built on. We’ll explore that in
    the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，有了一些JavaScript的知识，或者任何C语言样的语言，从中心化到去中心化应用开发的过渡并不困难。但在那种过渡中，完全理解去中心化应用背后的技术是很重要的，因为它们与中心化应用所基于的技术相当不同。我们在下一节探讨那个。
- en: 2.2\. What technologies make Dapps viable?
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2。是什么技术使Dapps变得可行？
- en: As you know, a Dapp is based on business logic encapsulated into smart contracts
    that are executed against a distributed database called blockchain. Blockchain
    technology is based, in turn, on public key cryptography, cryptographic hash functions,
    and the concept of consensus, which you can implement using *proof of work* and
    *proof of stake* algorithms, among other ways.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，一个Dapp是基于业务逻辑被封装到智能合约中，这些智能合约是针对一个分布式数据库区块链执行的。区块链技术，反过来，基于公钥密码学、密码学散列函数和共识概念，你可以使用*工作量证明*和*权益证明*算法等多种方式来实现。
- en: You might be feeling like I keep opening more and more Russian dolls, and this
    might never end, but please don’t get frustrated! Cryptography is the lowest level
    I’m going to cover, I promise.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得我一直在打开越来越多的俄罗斯套娃，这可能永远不会结束，但请别灰心！密码学是我要覆盖的最低级别，我保证。
- en: 2.2.1\. Blockchain technologies
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1。区块链技术
- en: In the next several sections, I’ll explain briefly all the cryptographic terms
    I’ve just mentioned so you can form a mental model of how a blockchain database
    works before we proceed further. Public key cryptography is the lowest technological
    block underlying the blockchain, so let’s start from there.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将简要解释我刚才提到的所有密码学术语，这样你可以在我们进一步前进之前形成一个关于区块链数据库如何工作的心理模型。公钥密码学是区块链
    underlying的最低技术块，所以让我们从那里开始。
- en: Public key cryptography
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 公钥密码学
- en: '*Public key cryptography* is an encryption methodology based on a pair of keys:
    a *private key*, usually generated randomly, which is known only to its owner,
    and a *public key*, known to everyone, generated from an algorithm that takes
    the private key as an input. [Figure 2.7](#ch02fig07) illustrates how private
    and public keys are generated.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学是一种基于一对密钥的加密方法：一个*私钥*，通常随机生成，只有其所有者知道，和一个*公钥*，对每个人公开，由一个输入私钥的算法生成。图2.7说明了私钥和公钥是如何生成的。
- en: Figure 2.7\. A private key is generated with a random number generator. It’s
    then fed to an algorithm that generates a public key.
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7。私钥使用随机数生成器生成，然后输入到一个算法中生成公钥。
- en: '![](Images/fig02-07_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-07_alt.jpg)'
- en: To better visualize it, think of the private key as the physical key of your
    mailbox (only you have a copy of it) and the public key as your postal address
    (everyone knows it), as shown in [figure 2.8](#ch02fig08).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，想象一下私钥就是你的邮箱的物理钥匙（只有你有它的副本）和公钥就是你的邮政地址（每个人都知道它），如图[2.8](#ch02fig08)所示。
- en: Figure 2.8\. To understand the purpose of private and public keys, you can think
    of the public key as your postal address, known by everybody, and the private
    key as the key to your mailbox, only owned by you.
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8。为了理解私钥和公钥的目的，你可以把公钥想成是大家都知道的你的邮政地址，而私钥是想成是你邮箱的钥匙，只有你拥有。
- en: '![](Images/fig02-08_alt.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-08_alt.jpg)'
- en: 'The private key has two main purposes, as illustrated in [figure 2.9](#ch02fig09):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥有两个主要目的，如图2.9所示：
- en: It allows the decryption of data that has been encrypted using the public key.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许解密使用公钥加密的数据。
- en: It allows someone to digitally sign a document. They can produce the signature
    only if they know the private key, but anyone who knows the public key can verify
    the signature. As you’ll see, the authenticity of smart contract transactions
    relies on digital signatures.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许某人数字签名文档。他们只有知道私钥时才能产生签名，但任何知道公钥的人都可以验证签名。正如你将看到的，智能合约交易的真实性依赖于数字签名。
- en: Figure 2.9\. You can use a private key to decrypt a document that has been encrypted
    with the related public key, as you can see in the top diagram. As shown in the
    bottom diagram, a private key also allows someone to sign a document digitally
    to prove provenance. The generated digital signature can then be verified against
    the document and the related public key.
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9。你可以使用私钥解密用相关公钥加密的文档，如顶部图表所示。如图底部图表所示，私钥还允许某人数字签名文档以证明其来源。生成的数字签名随后可以与文档和相关公钥进行验证。
- en: '![](Images/fig02-09_alt.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-09_alt.jpg)'
- en: In the context of a blockchain platform, cryptocurrency is generally stored
    against an account that is identified by a public key but can be operated only
    if you know the private key. If the private key is forgotten or lost, no one can
    use the account anymore, and its funds are considered lost.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链平台的背景下，加密货币通常存储在与公钥相关联的账户中，但只有知道私钥才能操作。如果私钥被遗忘或丢失，没有人可以使用该账户 anymore，其资金被认为是丢失的。
- en: Cryptographic hash functions
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 密码学哈希函数
- en: A *hash function* is any function that can map data of arbitrary size to data
    of fixed size. The fixed size data is called hash or digest. To give an example,
    you can design a hash function so that it always generates a 64-bit hash from
    a file or string of any size. Whether its size is 10 KB or 10 GB, a 64-bit hash
    will be generated, as illustrated in [figure 2.10](#ch02fig10).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*哈希函数*是任何可以将任意大小的数据映射到固定大小数据的函数。固定大小的数据称为哈希或摘要。举个例子，你可以设计一个哈希函数，使其总能从任意大小的文件或字符串生成一个64位的哈希值。无论其大小是10
    KB还是10 GB，都会生成一个64位的哈希值，如图2.10所示。
- en: Figure 2.10\. A hash function produces a hash of a fixed size (64 bits in this
    example) given an input of any size.
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10。一个哈希函数给定任意大小的输入数据生成一个固定大小的哈希值（本例中为64位）。
- en: '![](Images/fig02-10_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-10_alt.jpg)'
- en: 'A *cryptographic hash function* is a hash function that has five additional
    properties:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*密码学哈希函数*具有五个额外的属性：
- en: '*It’s deterministic*. The same input will always generate the same hash.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是确定性的*。相同的输入总会生成相同的哈希值。'
- en: '*It’s quick to compute*.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算起来*很快*。
- en: '*It’s a one-way function, unfeasible to invert*. This means that the only way
    to deduce the original data from its hash would be to try, by brute force, to
    obtain the same hash by applying the function to an enormous number of input data
    sets.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是一个单向函数，反向操作不可行*。这意味着，除非你通过尝试，用函数对大量输入数据集进行暴力破解，否则无法从其哈希值推导出原始数据。'
- en: '*It should be almost impossible to obtain the same hash from two different
    sets of input data*. Although a small chance exists that two inputs might produce
    the same hash, it’s impossible to determine them a priori, without applying the
    function to an enormous number of inputs, as suggested in the previous point.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它应该几乎不可能从两组不同的输入数据中得到相同的哈希值*。尽管存在两个输入可能产生相同哈希的小概率事件，但不可能事先确定它们，除非像前一点所建议的那样，将函数应用于大量输入数据。'
- en: '*A slight change in the input data should produce substantially different hash
    values*. Consequently, also because of what I said in the previous point, unless
    you’re applying the cryptographic hash function to the same input, you won’t be
    able to *intentionally* get the same hash or even a close one.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入数据的微小变化应产生截然不同的哈希值*。因此，也正因为我在前一点所说，除非你用密码学哈希函数对相同的输入进行操作，否则你无法*故意*得到相同的哈希值，甚至是一个接近的值。'
- en: Given these properties, think about the following scenario. Imagine you’re writing
    a check for $30 to pay for the latest blockchain book from your local bookstore.
    I know, checks are almost no longer used and, if you’re a young reader, you might
    never have seen one! Please bear with me for a moment.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些特性，思考以下场景。想象你正在写一张30美元的支票来支付你当地书店最新区块链书籍的费用。我知道，支票几乎已经不再使用，如果你是一位年轻的读者，你可能从未见过！请暂时忍受我一下。
- en: You filled out and signed the check, and you’re on your way to the bookstore,
    when, while on your mobile phone chat app, you trip over a curb. You don’t realize
    the check falls on the road and a gust of wind takes it away. You’re so unlucky
    that it ends up in the hands of Jack Forger, a local petty criminal. He knows
    how to remove ink, and he quickly replaces the amount and recipient as shown in
    [figure 2.11](#ch02fig11).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你填写并签署了支票，正前往书店的路上，这时，你在手机聊天应用上绊倒了 curb。你没意识到支票掉在了路上，一阵风把它吹走了。你太倒霉了，它最后落到了当地小罪犯
    Jack Forger 手中。他知道如何去除墨水，并迅速更换了金额和收款人，如图 2.11 所示。
- en: Figure 2.11\. A physical check forged by reusing the original signature and
    altering the recipient and amount
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11\. 通过重新使用原始签名并更改收款人和金额来伪造物理支票
- en: '![](Images/fig02-11_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-11_alt.jpg)'
- en: Jack then goes to a bank and successfully cashes the check for $30,000\. The
    criminal had your handwritten signature and was able to replace the name of the
    recipient and the amount. Let’s see how a digital signature on an electronic check
    would avoid this unpleasant situation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Jack 然后去了一家银行，成功兑现了 30,000 美元的支票。罪犯有了你的手写签名，并成功更换了收款人和金额。让我们看看电子支票上的数字签名如何避免这种令人不快的局面。
- en: The digital signature on an electronic check would be a cryptographic hash produced
    using as the input the details of your check, the amount you’re paying, and the
    recipient, together with a private key associated with your bank account (the
    equivalent of your handwritten signature), as illustrated in [figure 2.12](#ch02fig12).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 电子支票上的数字签名将是使用你的支票详情、支付的金额和收款人以及与你的银行账户关联的私钥（相当于你的手写签名）生成的加密哈希，如图 2.12 所示。
- en: Figure 2.12\. An e-check can be secured with a digital signature generated with
    the private key associated with the sending bank account and the details of the
    check. It can be verified by checking the digital signature against the public
    key associated with the sender bank account and the check details.
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.12\. 电子支票可以利用与发送方银行账户关联的私钥生成的数字签名以及支票详情进行加密。可以通过将数字签名与发送方银行账户和支票详情关联的公钥进行比对来验证它。
- en: '![](Images/fig02-12_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-12_alt.jpg)'
- en: When someone presents this kind of electronic check to a bank, together with
    the public key associated with your bank account, the bank can verify that the
    digital signature matches the details of the check (amount and recipient) and
    has been produced using your private key. That’s how the bookstore owner will
    be able to cash your check.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人提交这种电子支票以及与你的银行账户关联的公钥时，银行可以验证数字签名是否与支票（金额和收款人）详情匹配，并且是否使用你的私钥生成。这就是书店老板将能够兑现你的支票的方式。
- en: 'Because the digital signature is a cryptographic hash, that exact signature
    can only be produced from the specific details you used when filing the electronic
    check. If someone tried to hijack the electronic check—let’s say a group of skilled
    hackers—changing the amount and, most importantly, the recipient would be pointless
    for two reasons:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数字签名是一种加密哈希，所以只能从你填写电子支票时使用的特定详情中生成该签名。如果有人试图劫持电子支票——比如说一组熟练的黑客——改变金额，更重要的是，收款人将是毫无意义的，原因有两个：
- en: A new amount or recipient would generate a completely different digital signature,
    so the bank wouldn’t recognize the current one as valid, as shown in [figure 2.13](#ch02fig13).
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的金额或收款人将会生成一个完全不同的数字签名，所以银行不会认为当前的签名是有效的，如图 2.13 所示。
- en: If the hackers attempted to generate a new digital signature with new check
    details, they couldn’t generate one that could be associated with the public key
    of your bank account because they don’t know your private key.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果黑客尝试使用新的校验细节生成一个新的数字签名，他们无法生成与你的银行账户的公钥相关联的签名，因为他们不知道你的私钥。
- en: Figure 2.13\. An attempt at forging an e-check secured by a digital signature
    is unsuccessful because the new original digital signature doesn’t match the altered
    check details.
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.13\. 尝试伪造一个由数字签名保护的电子支票是徒劳的，因为新的原始数字签名与更改后的支票详情不匹配。
- en: '![](Images/fig02-13_alt.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-13_alt.jpg)'
- en: 'Blockchain transactions are much like the electronic check described here:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链交易与这里描述的电子支票非常相似：
- en: They originate from an account identified by a public key.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们起源于一个由公钥标识的账户。
- en: They contain transaction details, such as an amount of cryptocurrency and the
    recipient, also identified by a public key.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含交易详情，如加密货币的金额和收款人，也通过公钥进行标识。
- en: They carry a digital signature proving the transaction details have been entered
    by the owner of the sender account through their private key.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们携带数字签名，证明交易详情是通过发件人账户的所有者的私钥输入的。
- en: Blockchain transactions don’t have to carry cryptocurrency; they can carry any
    data. The crucial point is that by carrying a digital signature, they can prove
    they’ve been genuinely sent by the sender.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链交易不必携带加密货币；它们可以携带任何数据。关键的一点是，通过携带数字签名，它们可以证明它们确实是由发件人发送的。
- en: Cryptographic hash functions aren’t only useful for digital signatures. If you’re
    interested in finding out more, read in the sidebar how you can use them to protect
    a seller from malicious buyers.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学散列函数不仅适用于数字签名。如果您想了解更多内容，请阅读边栏部分，了解如何使用它们来保护卖家免受恶意买家的侵害。
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Protecting a seller from malicious buyers with a commit-reveal scheme**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用提交-揭示方案保护卖家免受恶意买家侵害**'
- en: 'Cryptographic hash functions can be handy in various situations. Do you remember
    the decentralized e-commerce application I described at the beginning of [chapter
    1](kindle_split_012.xhtml#ch01)? If you’re reading this book with the mindset
    of a seller, you might have found the solution not as convincing as when seen
    through the eyes of a buyer. For example, there seems to be nothing, in the solution
    presented, preventing the user from accepting the goods and then not authorizing
    the payment to the seller. That’s disappointing! Don''t despair: cryptographic
    hash functions to the rescue!'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学散列函数在各种情况下都很有用。您还记得我在第1章开头描述的去中心化电子商务应用程序吗？如果您是以卖家的身份阅读这本书，您可能会觉得这个解决方案没有从买家的角度来看那么有说服力。例如，根据所提出的解决方案，似乎没有什么能阻止用户接受货物，然后不授权向卖家付款。这令人失望！不要绝望：密码学散列函数来帮忙！
- en: You could make the application more secure for sellers if you required the buyer
    to generate a secret code, for instance a secret phrase or a random number, and
    then supply its cryptographic hash to the seller during the confirmation of the
    order. You could view this hash as a sort of keylock for the payment. When delivery
    comes, the courier would hand the goods over only upon receipt of the secret code,
    which, when supplied to the e-commerce Dapp, would generate the expected initial
    hash code and, as a physical key into its associated keylock, would unlock the
    payment.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求买家生成一个秘密代码，例如一个秘密短语或一个随机数，并在订单确认时将其加密散列值提供给卖家，那么您可以使应用程序对卖家更安全。您可以将这个散列值视为支付的一种键锁。当货物送达时，快递员只有在收到秘密代码后才会交付货物，该代码，当提供给电子商务Dapp时，会生成预期的初始散列代码，并且，作为一个物理钥匙，可以打开其关联的键锁，从而解锁支付。
- en: 'This way of initially providing a hash of the original information and then
    revealing the full information in a second stage is called a *commitment scheme*
    or *commit-reveal scheme*, and it has two phases:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最初提供原始信息的散列值，然后在第二阶段揭示完整信息的方式，被称为*提交方案*或*提交-揭示方案*，它有两个阶段：
- en: The commit phase, during which a cryptographic hash of the original information
    produced with a disclosed algorithm is committed to the other party
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交阶段，在此阶段，使用公开算法生成的原始信息的加密散列值提交给另一方。
- en: The reveal phase, during which the full information is revealed, and it’s verified
    against the committed hash to prove the revealed information is indeed associated
    with the hash
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 揭示阶段，在此阶段，完整的信息被揭示，并与提交的散列值进行验证，以证明揭示的信息确实与该散列值相关联。
- en: This powerful idea of proving the knowledge of some information without revealing
    the information itself had already been used in the 16th century by Galileo, who
    initially published his discovery of the phases of Venus in an anagram of the
    original paper, before finalizing his research. Hooke and Newton later used a
    similar technique to conceal the details of their discoveries, while at the same
    time being able to claim they were the first to make such discoveries.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的想法：证明拥有某些信息的知识，而不透露信息本身，早在16世纪就已经被伽利略使用过。伽利略最初以原论文的字母谜形式发表了他对金星的相位的发现，在最终确定研究之前，并未透露其真实信息。胡克和牛顿后来使用了类似的技巧，隐藏了他们发现的细节，同时又能声称他们是首先做出这些发现的人。
- en: In the rest of the book, you’ll see how this idea is used to secure decentralized
    applications.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，你将看到这个想法是如何用来保护去中心化应用程序的。
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Congratulations, you’ve completed the Cryptography 101 course! I hope it wasn’t
    too painful. You now have the necessary tools to understand how a blockchain works.
    Now we’ll enter the blockchain.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了密码学101课程！希望这并不是太痛苦。你现在有了理解区块链如何工作的必要工具。现在我们将进入区块链。
- en: Blockchain
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 区块链
- en: A blockchain is a distributed database that holds records called blocks. [Figure
    2.14](#ch02fig14) illustrates the structure of a typical blockchain.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个分布式数据库，包含称为块的记录。图2.14（#ch02fig14）展示了典型区块链的结构。
- en: Figure 2.14\. A blockchain is a sequence of blocks, each containing a sequence
    number, a timestamp, and a list of transactions, each individually digitally signed.
    Each block also references the cryptographic hash of the previous block.
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.14. 区块链是一系列块的序列，每个块包含一个序列号、一个时间戳和一系列交易，每个交易都有单独的数字签名。每个块还引用了前一个块的加密哈希。
- en: '![](Images/fig02-14_alt.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-14_alt.jpg)'
- en: A block includes a list of transactions, which are digitally signed to prove
    their provenance. Most blockchains digitally sign transactions with an *elliptic
    curve digital signature algorithm* (ECDSA), based on elliptic-curve cryptography,
    rather than a traditional digital signature algorithm (DSA), because ECDSA is
    harder to break and uses smaller keys to guarantee the same level of security.
    Each block contains a timestamp and a link to a previous block based on its cryptographic
    hash. It also contains a cryptographic hash summarizing the full content of the
    block, including the hash of the previous block. In this way, the blockchain holds
    both the current state (the latest block) and the full history of all the transactions
    that have been stored on it since its inception.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块包括一系列交易，这些交易通过数字签名来证明它们的来源。大多数区块链使用*椭圆曲线数字签名算法*（ECDSA），基于椭圆曲线密码学，而不是传统的数字签名算法（DSA），因为ECDSA更难破解，并且使用更小的密钥来保证相同级别的安全性。每个区块包含一个时间戳和一个基于其加密哈希的前一个区块的链接。它还包含一个加密哈希，总结区块的完整内容，包括前一个区块的哈希。这样，区块链既保存了当前状态（最新的区块），又保存了自其成立以来存储在其中的所有交易的完整历史。
- en: This structure guarantees transactions can’t be tampered with or modified. A
    transaction recorded in a block can’t be altered retroactively because to modify
    it, the hash of the block containing it would have to be regenerated, and this
    wouldn’t match the existing one already referenced by subsequent blocks, as shown
    in [figure 2.15](#ch02fig15).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构保证了交易不能被篡改或修改。在区块中记录的交易不能被追溯性地修改，因为要修改它，包含它的块的哈希将必须被重新生成，而这不会与已经由后续块引用的现有的哈希相匹配，如图2.15（#ch02fig15）所示。
- en: 'Figure 2.15\. An attempt at altering the contents of a block, for example its
    transactions, won’t be successful: the new hash generated from the altered block
    details won’t match the original block’s hash already directly referenced in the
    next block and indirectly referenced in the subsequent blocks.'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.15. 试图更改区块内容的尝试，例如其交易，是不会成功的：从被更改的区块详情生成的新的哈希不会与已经在下一个区块直接引用并在后续区块间接引用的原始区块的哈希相匹配。
- en: '![](Images/fig02-15_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-15_alt.jpg)'
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If two transactions contradict each other—for instance, each of them tries to
    transfer all the funds of the same account to a different destination account
    (known as a “double-spend attack”)—miners will execute only the first one, recognized
    in the Ethereum network through a globally accessible sequence number. They will
    reject the second one, and it will never appear on a consolidated block. Satoshi
    Nakamoto of Bitcoin was the first to solve the double-spend problem. Every blockchain
    has a solution for it; otherwise, it wouldn’t be viable.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个交易相互矛盾——例如，它们都试图将同一个账户的所有资金转移到不同的目标账户（这被称为“双重花费攻击”）——矿工会只执行第一个，通过全球可访问的序列号在以太坊网络中被识别。他们会拒绝第二个，并且它永远不会出现在合并的区块上。比特币的创始人中本聪是第一个解决双重花费问题的人。每个区块链都有解决这个问题的方案；否则，它就不会是可行的。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The blockchain structure I’ve described is, in fact, a simplified version of
    real-world blockchain data structures such as the Merkle tree used by Bitcoin
    or the Patricia tree used in Ethereum. A blockchain is managed autonomously through
    a P2P network that facilitates fault tolerance and decentralized consensus by
    processing all transactions independently on each node. Given these characteristics,
    blockchains are particularly suitable for recording permanently the history of
    events. This is useful for identity management, transaction processing, and provenance
    tracking, to name a few use cases.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述的区块链结构实际上是现实世界中区块链数据结构的一个简化版本，比如比特币中使用的默克尔树或以太坊中使用的帕特里夏树。区块链通过一个P2P网络自主管理，通过在每个节点上独立处理所有交易来实现容错和去中心化共识。由于这些特性，区块链特别适合记录事件的历史。这在身份管理、交易处理和来源追踪等几个用例中非常有用。
- en: Mining
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 挖矿
- en: To encourage the P2P network supporting the blockchain to process its transactions
    continuously, active processing nodes, also called *mining nodes* or *miners*,
    are rewarded for the computational resources provided, and indirectly to cover
    the associated electricity costs, through the *consensus* mechanism. Every few
    seconds, one successful miner is entitled to generate and keep a certain number
    of tokens of the cryptocurrency supported by the platform. Such cryptocurrency
    has economic value, as it can be used to purchase services on the network, but
    it also can be exchanged for conventional currencies, such as dollars, yen, euros,
    and so forth. In the case of the Bitcoin blockchain, they’ll be given several
    Bitcoin tokens, worth around $2,000 each at the time of writing. The tokens given
    by the Ethereum blockchain are called Ether, and they’re worth around $200 each
    at the time of writing. Let’s now look at how the consensus mechanism works.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了鼓励支持区块链的P2P网络持续处理其交易，活跃的处理节点，也称为*挖矿节点*或*矿工*，会因为提供的计算资源而获得奖励，间接地覆盖相关的电力成本，通过*共识*机制。每几秒钟，一个成功的矿工有权生成并保留平台支持加密货币的若干代币。这种加密货币具有经济价值，因为它可以用来购买网络上的服务，但它也可以兑换成美元、日元、欧元等传统货币。在比特币区块链的情况下，他们将获得几个比特币代币，截至撰写本文时，每个代币价值约2000美元。以太坊区块链给出的代币称为以太币，截至撰写本文时，每个代币价值约200美元。现在让我们来看看共识机制是如何工作的。
- en: Consensus
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 共识
- en: Consensus is, as I mentioned earlier, the mechanism by which participant nodes
    of the network agree on the outcome of a transaction. In the consensus definition
    I presented at the beginning of [chapter 1](kindle_split_012.xhtml#ch01), I also
    emphasized that consensus is distributed, because it’s determined by many participants,
    and trustless, because the participants don’t need to trust each other. In fact,
    consensus isn’t reached on individual transactions but on new blockchain blocks.
    Each participant verifies independently that a new block is valid and, if satisfied,
    propagates it further to the rest of the network.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，共识是网络参与节点就交易结果达成一致的机制。在我[第1章](kindle_split_012.xhtml#ch01)一开始提出的共识定义中，我还强调共识是分布式的，因为它是由许多参与者确定的，并且是无信任的，因为参与者不需要相互信任。实际上，共识并不是针对单个交易达成的，而是针对新的区块链区块。每个参与者独立验证一个新的区块是否有效，如果满意，将进一步将其传播到网络的其余部分。
- en: What happens in practice is that if most participants have accepted the block
    as valid and it has propagated successfully throughout the network, miners will
    use such a block as the latest valid block, and the rest of the blockchain will
    be built on it. If a malicious miner appended an incorrect block to the blockchain
    and it propagated to its peer nodes, these nodes would reject the new block, and
    the malicious chain would die out immediately. The same would happen if a full
    node tried to modify a block before propagating it to its peers.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 实际中发生的情况是，如果大多数参与者都接受该区块作为有效区块，并且它已经成功地在整个网络中传播，矿工们将会使用这样的区块作为最新的有效区块，区块链的其余部分也将建立在这个区块之上。如果恶意矿工向区块链中添加了一个错误的区块，并且它传播到了其同伴节点，这些节点将会拒绝这个新区块，恶意链将会立即消亡。如果一个完整节点试图在传播给其同伴之前修改一个区块，也会有同样的结果。
- en: As you can see, the key step of the consensus mechanism is the verification
    of the latest block by a participant node. After verifying the digital signature
    of the individual transactions present on a block, a participant node verifies
    that the hash of the block is valid. Such hash is produced by miners according
    to an agreed protocol. The earlier versions of Ethereum used an algorithm called
    *Ethash*, based on a Proof of Work protocol. Future versions will be based on
    a Full of Stake protocol called *Casper*. I’ll explain both protocols.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，共识机制的关键步骤是参与者节点验证最新区块。在验证区块中个人交易的数字签名后，参与者节点验证块的散列值是否有效。这样的散列值是由矿工根据商定的协议产生的。以太坊的早期版本使用了一种名为*Ethash*的算法，基于工作量证明协议。未来版本将基于一种权益证明协议，名为*Casper*。我会解释这两种协议。
- en: Proof of Work
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 工作量证明
- en: As you saw earlier, a block contains a cryptographic hash summarizing the full
    content of the block, including its metadata and transactions data, and an additional
    piece of data of a fixed length, such as 32 bits, called *nonce*. The objective
    of the Proof of Work (PoW) protocol is that miners must find a nonce such that
    the hash generated fits a certain constraint, for instance, having many leading
    zeros. Constraining a 64-bit unsigned integer hash to have 13 leading zeros when
    represented in hexadecimal format, as in the example of [figure 2.16](#ch02fig16),
    reduces the number of valid hashes from the theoretical maximum number of 18,446,744,073,709,551,615
    to 4,095.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，一个区块包含一个加密散列值，它总结了区块的完整内容，包括其元数据和交易数据，还有一个固定长度的额外数据，例如32位，称为*nonce*。工作量证明（PoW）协议的目标是矿工必须找到一个nonce，使得生成的散列值符合某种约束，例如，具有很多前导零。将64位无符号整数散列约束为在十六进制格式中具有13个前导零，如[图
    2.16](#ch02fig16)的示例，将有效的散列数从理论上的最大值18,446,744,073,709,551,615减少到4,095。
- en: 'Figure 2.16\. Proof of Work: generation of an unsuccessful and a successful
    block hash'
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.16. 工作量证明：生成一个不成功的区块散列和一个成功的区块散列
- en: '![](Images/fig02-16_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-16_alt.jpg)'
- en: Because of the properties of hash functions you saw earlier, the only way a
    miner can find such a nonce is by trying many possible values until the constraint
    on the hash has been met. In the example I just gave, every such attempt will
    only have a roughly 0.00000000000002% chance of being successful. When a satisfactory
    hash has been found, the miner is entitled to append the new block being processed
    to the blockchain and claim the token reward. As you can understand, this way
    of producing a valid hash is CPU-intensive, energy-consuming, and, consequently,
    economically expensive. The main reason for such an expensive algorithm is to
    dissuade malicious participants from appending new incorrect blocks or modifying
    preexisting blocks and making them look like genuine blocks. The amount of energy
    (and money) necessary to perform such actions would make them unviable. In the
    sidebar in [section 3.3.4](kindle_split_014.xhtml#ch03lev2sec11), I’ll give you
    an idea of the hardware most miners use.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您之前看到的散列函数的特性，矿工找到这样的nonce的唯一方法是尝试许多可能的值，直到满足散列值的约束。在我刚才给出的例子中，每一次尝试成功的几率大约只有0.00000000000002%。当找到一个满意的散列值时，矿工有权将正在处理的新区块附加到区块链上，并声称代币奖励。正如您所理解，产生有效散列值这种方式对CPU要求高，耗能，因此经济上昂贵。这种昂贵算法的主要原因是阻止恶意参与者附加新的错误区块或修改已存在的区块，使它们看起来像真正的区块。执行这些操作所需的能量（和金钱）会使它们变得不可行。在[第3.3.4节](kindle_split_014.xhtml#ch03lev2sec11)的边栏中，我会向您介绍大多数矿工使用的硬件。
- en: Proof of Stake
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权益证明
- en: Proof of Work, which the Bitcoin network also uses, has been widely criticized
    for the immense amount of energy consumed (or rather, wasted?) by the competing
    miners. It has been estimated that the Bitcoin network alone will consume as much
    electricity as Bulgaria by 2020.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（Proof of Work，PoW），比特币网络也使用这种机制，因耗费巨大能源（或者说，浪费？）而受到广泛批评。据估计，到2020年，比特币网络本身将消耗与保加利亚相同的电力。
- en: To tackle this problem, Vitalik Buterin, one of the Ethereum founders, has proposed
    an alternative approach based on a Proof of Stake. This is based on a pool of
    *validators* that vote on the validity of new blockchain blocks. To join the validator
    pool, which is open to anyone, a node must commit an Ether deposit that will be
    held until the node leaves the pool. Votes expressed by each node are weighted
    on the amount of the deposit committed (which equates to the stake of a node in
    the pool). Under this scheme, a validator profits from transaction fees that the
    transaction senders pay. If a validator cheats, the associated Ether deposit is
    deleted from the network and the owner is banned from rejoining, which acts as
    a deterrent against manipulation.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，以太坊创始人之一Vitalik Buterin提出了一种基于**权益证明**的替代方法。这基于一组*验证者*对新区块链块的有效性进行投票。要加入验证者池，该池对任何人开放，节点必须提交一个以太币存款，直到节点离开该池才会释放。每个节点表达的投票权以其承诺的存款金额（相当于节点在池中的股份）为基准。在此方案下，验证者可以从发送者支付的交易费中获利。如果验证者作弊，与其关联的以太币存款将从网络上删除，并且所有者将被禁止重新加入，这起到了防止操纵的威慑作用。
- en: You’ve now covered all the general cryptographic techniques underlying blockchain
    databases. If you’d like to learn more about the subject, I encourage you to read
    *Grok-king Bitcoin* by Kalle Rosenbaum) (Manning, 2019). Let’s now examine more
    recent technologies that have simplified Dapp development.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已覆盖了区块链数据库背后所有的通用加密技术。如果你想要了解更多关于这个主题的内容，我鼓励你阅读**Kalle Rosenbaum**所著的《Grok-king
    Bitcoin》（Manning, 2019）。现在让我们来考察一下简化Dapp开发的新近技术。
- en: The Merkle tree and Merkle root
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 梅克尔树和梅克尔根
- en: 'The blockchain structure I’ve shown in the previous diagrams is a simplified
    representation of a real one. Generally, a miner places in the block two parts:
    a *header* and a *body*, as shown in [figure 2.17](#ch02fig17). The body contains
    all the transactions included in the block. The header contains the block metadata
    you saw earlier, such as the block number, timestamp, previous block hash, and
    PoW nonce. It also contains the *Merkle root* of the *transactions Merkle tree*
    that the miner calculates.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面的图表中展示的区块链结构是真实的一个简化表示。通常，矿工在块中放置两部分：*头部*和*身体*，如图2.17[所示](#ch02fig17)。身体包含块中包括的所有交易。头部包含你之前看到的块元数据，如区块号码、时间戳、前一个区块哈希和证明工作（PoW）的非数值。它还包含矿工计算的*交易梅克尔树*的*梅克尔根*。
- en: Figure 2.17\. The structure of a block, including a header containing metadata,
    such as the block number, timestamp, previous block hash, and Merkle root of the
    transactions Merkle tree, and a body containing the transactions collection
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.17。包括包含元数据的头部，如区块号码、时间戳、前一个区块哈希和交易梅克尔树的梅克尔根，以及包含交易集合的身体
- en: '![](Images/fig02-17_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-17_alt.jpg)'
- en: 'The transactions Merkle tree, as shown in [figure 2.18](#ch02fig18), is a tree
    structure built as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.18](#ch02fig18)所示，交易Merkle树是一种按以下方式构建的树结构：
- en: The block’s transactions are placed at the bottom of the tree, arranged in pairs.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块的交易放在树的底部，成对排列。
- en: Each transaction is hashed, and each of these hashes becomes a leaf of the Merkle
    tree.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个交易都被哈希，这些哈希中的每一个都成为梅克尔树的一个叶子。
- en: A hash is calculated for each pair of contiguous hashes.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每对连续的哈希值都会计算一个哈希。
- en: The hashing of contiguous hashes is repeated until only two hashes remain. The
    hash of these two final hashes is the *Merkle root*.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续哈希的哈希一直重复，直到只剩下两个哈希值。这两个最终哈希值的哈希是*梅克尔根*。
- en: 'Figure 2.18\. A Merkle tree. Individual transactions are located at the bottom;
    the tree’s leaves are the hashes of the individual transactions; and the next
    row up is made of the hashes of the tree’s leaves. The top row, which is the hash
    of the hashes below, ends the tree: this is the Merkle root.'
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.18。梅克尔树。单个交易位于树的底部；树的叶子是单个交易的哈希；再上一行是由树的叶子哈希组成的。最上面的一行，即下面的哈希的哈希，结束了树：这是梅克尔根。
- en: '![](Images/fig02-18_alt.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-18_alt.jpg)'
- en: The Merkle root is therefore a single hash summarizing all of the transactions
    contained in the block in a way that guarantees their integrity. The advantage
    of having the Merkle root on the block header is that a client can synchronize
    the blockchain in a faster way by retrieving the block headers, rather than the
    entire transaction history, from the network peers. This is generally called *light
    synchronization*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Merkle树根是一个单一的散列值，它以一种保证其完整性的方式总结了包含在区块中的所有交易。在区块头中拥有Merkle树根的优势是，客户端可以通过检索网络对等体的区块头，而不是整个交易历史，以更快的速度同步区块链。这通常被称为*轻量级同步*。
- en: 2.2.2\. Ethereum technologies
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2. 以太坊技术
- en: 'Although smart contracts can be implemented, with some difficulty, on early
    blockchain systems such as Bitcoin, they can be more easily written and executed
    on later blockchain platforms, such as Hyperledger, Nxt, and Ethereum, that have
    been designed with the main purpose of simplifying their development. For this
    reason, later blockchain platforms are considered part of the so-called *smart
    blockchain* or *blockchain 2.0* wave. Let’s now examine briefly the main innovations
    that Ethereum has introduced: an improved blockchain design, the EVM, and smart
    contracts.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以困难地在早期的区块链系统（如比特币）上实现智能合约，但后来设计的区块链平台（如Hyperledger、Nxt和Ethereum）可以更容易地编写和执行智能合约，这些平台的主要目的是简化其开发。因此，后来的区块链平台被认为是所谓的*智能区块链*或*区块链2.0*的一部分。现在让我们简要地检查以太坊引入的主要创新：改进的区块链设计、EVM和智能合约。
- en: The Ethereum blockchain
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以太坊区块链
- en: In the previous section, you learned about the blockchain and a more efficient
    structure that allows quicker client synchronization based on a block header containing
    a block’s metadata and a body containing the transactions. The Ethereum blockchain
    improves the design further. First of all, transactions are hashed in a more compact
    and efficient (yet still cryptographically authenticated) structure called a *Merkle-Patricia
    trie* (see sidebar for more details). Secondly, the block header (generated as
    usual by the miner) also contains, in addition to the Merkle-Patricia root of
    the transactions, the Merkle-Patricia root of the receipts, which are the transaction
    outputs, and the Merkle-Patricia root of the current blockchain state, as shown
    in [figure 2.19](#ch02fig19).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分，您学习了关于区块链以及一种更高效的结构，该结构基于包含区块元数据的区块头和包含交易的区块体，使得客户端同步更快。以太坊区块链进一步改进了设计。首先，交易被散列在一个更紧凑且高效的（但仍具有加密验证）结构中，称为*Merkle-Patricia树*（有关详细信息请参见侧边栏）。其次，区块头（由矿工通常生成）还包含除了交易Merkle-Patricia树的根之外，还包含收据（即交易输出）的Merkle-Patricia树的根和当前区块链状态的Merkle-Patricia树的根，如图[2.19](#ch02fig19)所示。
- en: Figure 2.19\. An Ethereum improved block header. The header of a block of the
    Ethereum blockchain contains the root of the transactions Merkle- Patricia trie,
    which is a more compact and efficient structure than a Merkle tree. In addition,
    it contains the Merkle-Patricia root of receipts (which are the transactions effects)
    and the blockchain state.
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.19. 以太坊改进的区块头。以太坊区块链的区块头包含交易Merkle-Patricia树的根，这是一个比Merkle树更紧凑高效的结构。此外，它还包含收据（即交易效果）和区块链状态的Merkle-Patricia树的根。
- en: '![](Images/fig02-19_alt.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-19_alt.jpg)'
- en: 'As Vitalik Buterin explained in his blog post “Merkling in Ethereum,”^([[1](#ch02fn01)])
    with these three Merkle-Patricia tries, a client can efficiently check, in a verifiable
    way, the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如Vitalik Buterin在他博客文章“Merkling in Ethereum”中解释的，^([[1](#ch02fn01)])借助这三个Merkle-Patricia树，客户端可以有效地以可验证的方式检查以下内容：
- en: ¹
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Merkling in Ethereum,” Ethereum Blog, November 15, 2015,
    [http://mng.bz/QQYe](http://mng.bz/QQYe).
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Vitalik Buterin，“Merkling in Ethereum，” Ethereum Blog，November 15，2015， [http://mng.bz/QQYe](http://mng.bz/QQYe)。
- en: Whether a certain transaction is included in a certain block
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某个交易是否包含在某个区块中
- en: What the output of a transaction would be
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易输出会是什么
- en: Whether an account exists
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户是否存在
- en: What the balance of an account is
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户余额是什么
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Merkle-Patricia trie**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**Merkle-Patricia树**'
- en: A *trie*^([[2](#ch02fn02)]) (or *prefix* *tree*) is an ordered data structure
    you use to store a dynamic set, where the keys are usually strings. The root of
    a trie is an empty string, and then all the descendants of a node have the common
    prefix of the string associated with that node, as you can see in the figure.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*trie*^([[2](#ch02fn02)])（或*前缀树*）是一种有序的数据结构，用于存储动态集合，其中键通常是字符串。trie的根是一个空字符串，然后节点的所有后代都有与该节点关联的字符串的共同前缀，如图所示。'
- en: ²
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the “Trie” Wikipedia page at [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    for more information on this data structure.
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参考维基百科上的“Trie”页面了解更多关于这种数据结构的信息。[https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
- en: '![](Images/f0053-01.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0053-01.jpg)'
- en: 'Trie structure (Credit: Booyabazooka (based on a PNG image by Deco). Modifications
    by Superm401\. - own work (based on PNG image by Deco))'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Trie结构（图片：Booyabazooka（基于Deco的PNG图像）。Superm401的修改 - 自己的工作（基于Deco的PNG图像））
- en: The Merkle-Patricia trie is a data structure that combines a trie and Merkle
    tree. It improves the efficiency of a Merkle tree (named after Ralph Merkle) by
    storing the node keys using the *PATRICIA* algorithm (*practical algorithm to
    retrieve information coded in alphanumeric*), designed by D. R. Morrison in 1968\.
    You can read about the Patricia algorithm on the Lloyd Allison Algorithm Repository.^([[3](#ch02fn03)])
    The Ethereum Merkle-Patricia trie is described in detail, with code examples,
    in the Ethereum wiki.^([[4](#ch02fn04)])
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**Merkle-Patricia trie**是一种结合了trie和Merkle树的数据结构。它通过使用*PATRICIA*算法（由D. R. Morrison于1968年设计的*实践的字母数字编码信息检索算法*）存储节点键，提高了Merkle树的效率（以Ralph
    Merkle的名字命名）。你可以在Lloyd Allison算法存储库上了解有关Patricia算法的信息。^([[3](#ch02fn03)]) 以太坊的Merkle-Patricia
    trie在以太坊维基上有详细的描述，附有代码示例。^([[4](#ch02fn04)])'
- en: ³
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/](http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/).'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/](http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/)'
- en: ⁴
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree).'
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)'
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When a full node receives a new block, the transactions contained in the body
    are processed as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当完整节点接收到一个新的块时，块体中包含的交易将按照以下方式处理：
- en: The transactions are arranged in a transaction Merkle-Patricia trie specific
    to the new block.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易按照新块的特定交易Merkle-Patricia trie组织。
- en: Transactions are executed on the EVM. This action generates transaction receipts,
    which are arranged in a receipts Merkle-Patricia trie specific to the new block.
    It also alters the global state trie, of which only one instance exists on each
    node.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易在EVM上执行。这一操作生成了交易收据，这些收据按照新块的特定Merkle-Patricia trie组织。它还改变了全局状态trie，每个节点上只存在一个实例。
- en: 'If the roots of the new transaction trie, receipt trie, and modified state
    trie match those in the header, the block is considered validated. Then the new
    and altered tries are stored on the full node in a respective key-value store
    based on LevelDB, an open source NoSQL database developed by Google. Note the
    following in [figure 2.20](#ch02fig20):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新交易trie、收据trie和修改后的状态trie的根与头部中的根匹配，则认为区块已验证。然后，新的和修改后的trie基于LevelDB存储在完整节点上，LevelDB是一个开源的NoSQL数据库，由谷歌开发。请注意以下内容：[图2.20](#ch02fig20)：
- en: The *transaction store* contains a transaction trie per block, and each trie
    is immutable. The key of this store is the transaction hash (keccak 256-bit hash).
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交易存储*包含每个块的交易trie，每个trie都是不可变的。这个存储的键是交易hash（keccak 256位hash）。'
- en: The *receipts store* contains a transaction trie per block, and each trie is
    immutable. The key of this store is the hash of the receipts of a transaction
    (keccak 256-bit hash).
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*收据存储*包含每个块的交易trie，每个trie都是不可变的。这个存储的键是交易收据的hash（keccak 256位hash）。'
- en: The *state store* contains a single *state trie* that represents the latest
    global state and is updated each time a new block is appended to the blockchain.
    The state trie is account-centric, so the key of this store is the account address
    (160 bytes).
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态存储*包含一个代表最新全局状态的*状态trie*，每当新块添加到区块链时，这个trie就会更新。trie是以账户为中心的，所以这个存储的键是账户地址（160字节）。'
- en: Figure 2.20\. Detailed block processing in an Ethereum node. When a full node
    receives a new block, it separates the header and the body. It then creates a
    local transactions trie and a local receipts trie and updates the existing state
    trie. The new and updated tries are then committed in the respective stores.
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.20. 以太坊节点中详细的区块处理。当一个完整节点收到一个新的区块时，它会分离出头部和体部。然后它会创建一个本地交易尝试和一个本地收据尝试，并更新现有的状态尝试。新的和更新的尝试随后被提交到各自的存储中。
- en: '![](Images/fig02-20_alt.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig02-20_alt.jpg)'
- en: 'A major benefit of the Ethereum blockchain design is that it allows three types
    of synchronization:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链设计的一个主要好处是，它允许三种类型的同步：
- en: '*Full*—Your client downloads the entire blockchain and validates all blocks
    locally. This is the slowest option, but you’d be confident of the integrity of
    the local blockchain copy.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整*——你的客户端下载整个区块链，并在本地验证所有区块。这是最慢的选项，但你会有信心本地区块链副本的一致性。'
- en: '*Fast*—Your client downloads the entire blockchain, but validates only the
    64 blocks prior to the start of the synchronization and the new ones.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速*——你的客户端下载整个区块链，但只验证在同步开始前64个区块和新的区块。'
- en: '*Light*—Your client retrieves the current state trie of the blockchain from
    a peer full node and stores it locally. It doesn’t retrieve any historic blocks
    from peers, and it receives only the new ones, so you don’t have to wait long.
    This will allow you to get up and running quickly.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*轻量级*——你的客户端从一个对等完整节点检索区块链的当前状态尝试，并将其存储在本地。它不会从对等节点检索任何历史区块，只会接收新的区块，所以你不必等待很长时间。这将允许你快速启动。'
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although in this section I’ve covered the physical design of the Ethereum blockchain
    in some detail because it’s important you understand how transactions and state
    are maintained, in the rest of the book I’ll use simplified logical diagrams in
    which I’ll represent a block as a collection of transactions.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本节中我详细介绍了以太坊区块链的物理设计，因为了解交易和状态是如何维护的是很重要的，但在整本书中，我将使用简化的逻辑图，在这些图中，我将区块表示为交易的集合。
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Ethereum Virtual Machine
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以太坊虚拟机
- en: The *Ethereum Virtual Machine (EVM)* is similar in purpose to the Java Virtual
    Machine (JVM) or the .NET Common Language Runtime (CLR). It runs on each node
    of the Ethereum P2P network. It’s Turing complete, which means it can run code
    of any complexity. It can access blockchain data, both in read and write mode.
    The EVM executes code only after its digital signature has been verified and constraints
    based on the current state of the blockchain are satisfied.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）的目的与Java虚拟机（JVM）或.NET公共语言运行时（CLR）相似。它在以太坊P2P网络的每个节点上运行。它是图灵完整的，这意味着它可以运行任何复杂度的代码。它可以在读取和写入模式下访问区块链数据。只有在数字签名已验证且满足基于区块链当前状态的限制后，EVM才会执行代码。
- en: Smart contract
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智能合约
- en: A *smart contract,* or simply *contract*, encapsulates the logic of a decentralized
    application. As I mentioned earlier, an Ethereum smart contract is written in
    a high-level language, such as Solidity or Serpent, and is compiled into EVM bytecode.
    It gets deployed on each node of the P2P network and is executed on the EVM.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约，或简称为合约，封装了去中心化应用的逻辑。如我之前提到的，以太坊智能合约是用像Solidity或Serpent这样的高级语言编写的，并编译成EVM字节码。它部署在P2P网络的每个节点上，并在EVM上执行。
- en: Next generation blockchain
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 下一代区块链
- en: Thanks to the EVM, Ethereum is a *programmable blockchain*. Therefore, you can
    develop any type of decentralized application on it, not only cryptocurrencies,
    as was the case for earlier blockchains. Because of this programmability, Ethereum
    is considered a generalized or next generation blockchain. Some go as far as thinking
    smart blockchain platforms will be the foundation of a new generation of the internet,
    a Web 3.0 (although this exact version of the web is also used by the “semantic
    web” community), which will be characterized by more empowered users.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了EVM，以太坊是一个*可编程区块链*。因此，你可以在其上开发任何类型的去中心化应用，不仅仅是加密货币，这是早期区块链的情况。由于这种可编程性，以太坊被认为是通用或下一代区块链。有些人甚至认为智能区块链平台将是新一代互联网的基础，即Web
    3.0（尽管这个版本的网络也被“语义网络”社区使用），这将特征更加强大的用户。
- en: 2.3\. Ethereum’s history and governance
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 以太坊的历史和治理
- en: Before closing the chapter, I’d like to share how Ethereum was created and how
    it evolved after the initial release. In the next few chapters, you’ll start using
    several components of the Ethereum platform. Before you do so, it’s important
    you understand how these components came about and what the process is for proposing
    and agreeing on changes. You’ll realize decentralization isn’t only a technical
    aspect of Ethereum; it’s almost a philosophy that also permeates its governance.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想分享一下以太坊的创建过程以及初始发布后的发展。在接下来的几章中，你将开始使用以太坊平台的一些组件。在你这样做之前，了解这些组件是如何产生的以及提议和达成变更的过程是很重要的。你会发现去中心化不仅是以太坊的一个技术方面；它几乎是一种哲学，也渗透在其治理之中。
- en: 2.3.1\. Who created Ethereum?
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 谁创造了以太坊？
- en: 'Ethereum is the brainchild of Vitalik Buterin, an early follower of bitcoin
    and cryptocurrency technology since 2011, when he also cofounded Bitcoin magazine.
    After researching the possibility of generalizing blockchain technology for building
    any application, in November 2013 he wrote the *Ethereum White Paper* ([https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)),
    in which he laid out the design of the Ethereum protocol, together with the first
    details of the smart contract infrastructure. Among the first people who engaged
    with Vitalik’s vision were Gavin Wood, who contributed to the shaping of the protocol
    and became the lead developer of the C++ client, and Jeffrey Wilcke, who became
    the lead developer of the Go client. After only a few months of work, in January
    2014, Vitalik announced the Ethereum initiative on bitcointalk^([[5](#ch02fn05)])
    and received considerable response. Soon afterwards, in April 2014, Gavin wrote
    the *Ethereum Yellow Paper*,^([[6](#ch02fn06)]) which specifies the design of
    the Ethereum virtual machine. To accelerate the development of the platform, in
    July 2014 Ethereum raised around $18.4M through an Ether crowdsale, which was
    legally backed by the Ethereum Foundation, set up in Switzerland only one month
    earlier with the mission to do the following (quoting the official website at
    [https://www.ethereum.org/foundation](https://www.ethereum.org/foundation)):'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是维塔利克·布特林的创意，他从2011年起就是比特币和加密货币技术的早期追随者，当时他还与米哈伊·阿尔西共同创立了比特币杂志。在研究将区块链技术泛化以构建任何应用程序的可能性之后，2013年11月，他撰写了*以太坊白皮书*（[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)），在其中他阐述了以太坊协议的设计，以及智能合约基础设施的初步细节。在维塔利克的愿景中首批参与的人包括加文·伍德，他参与了协议的塑造，并成为C++客户端的主导开发者，以及杰弗里·威尔克，他成为Go客户端的主导开发者。仅仅几个月的工作后，2014年1月，维塔利克在bitcointalk上宣布了以太坊计划[[5](#ch02fn05)]，并得到了相当大的回应。随后，在2014年4月，加文撰写了*以太坊黄皮书*[[6](#ch02fn06)]，详细说明了以太坊虚拟机的设计。为了加速平台的发展，2014年7月，以太坊通过以太币众筹筹集了约1840万美元，这次众筹在法律上得到了刚刚一个月前在瑞士成立的以太坊基金会的支持，该基金会的使命是（引用官方网站[https://www.ethereum.org/foundation](https://www.ethereum.org/foundation)）：
- en: ⁵
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Welcome to the Beginning,” [https://bitcointalk.org/index.php?topic=428589.0](https://bitcointalk.org/index.php?topic=428589.0).
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见维塔利克·布特林，“欢迎来到开始”[https://bitcointalk.org/index.php?topic=428589.0](https://bitcointalk.org/index.php?topic=428589.0)。
- en: ⁶
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: ''
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “About the Ethereum Foundation,” [https://github.com/ethereum/yellowpaper](https://github.com/ethereum/yellowpaper).
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“关于以太坊基金会”[https://github.com/ethereum/yellowpaper](https://github.com/ethereum/yellowpaper)。
- en: '...promote and support Ethereum platform and base layer research, development
    and education to bring decentralized protocols and tools to the world that empower
    developers to produce next generation decentralized applications (Dapps), and
    together build a more globally accessible, more free and more trustworthy Internet.'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ……促进和支持以太坊平台和基础层的研究、开发和教育，将去中心化协议和工具带到世界各地，使开发者能够产生下一代去中心化应用程序（Dapps），并共同构建一个更加全球可访问、更加自由、更加值得信赖的互联网。
- en: '[Table 2.1](#ch02table01) summarizes Ethereum’s timeline since its inception
    to the time of writing of this book.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.1](#ch02table01) 总结了自以太坊成立以来至本书写作时的时间线。'
- en: Table 2.1\. Ethereum timeline from inception to summer 2018
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1. 自成立以来至2018年夏季以太坊的时间线
- en: '| Sep 2011 | Vitalik Buterin cofounds Bitcoin magazine with Mihai Alisie. |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 2011年9月 | 维塔利克·布特林与米哈伊·阿尔西共同创立了比特币杂志。 |'
- en: '| Nov 2013 | Vitalik publishes the Ethereum White Paper, presenting the design
    of the Ethereum protocol and the smart contract infrastructure. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 2013年11月 | 维塔利克·布特林发布了以太坊白皮书，阐述了以太坊协议的设计和智能合约基础设施。 |'
- en: '| Dec 2013 | Gavin Wood contacts Vitalik, and they start detailed design discussions.
    |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 2013年12月 | 加文·伍德联系了维塔利克，并开始了详细的设计讨论。|'
- en: '| Jan 2014 | Vitalik makes the official Ethereum announcement on bitcointalk.
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 2014年1月 | 维塔利克在bitcointalk上发布了以太坊的正式公告。|'
- en: '| Apr 2014 | Gavin wood publishes the Ethereum Yellow Paper, which specifies
    the Ethereum virtual machine (EVM). |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 2014年4月 | 加文·伍德发布了以太坊黄皮书，详细规定了以太坊虚拟机（EVM）。|'
- en: '| Jun 2014 | The Ethereum Foundation is set up in Switzerland. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 2014年6月 | 以太坊基金会成立于瑞士。|'
- en: '| Jul 2014 | Ethereum raises $18.4M through an Ether crowdsale. |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 2014年7月 | 以太坊通过以太币众筹筹集了1840万美元。|'
- en: '| Aug 2014 | Vitalik Buterin, Gavin Wood, and Jeffrey Wilcke set up ETH DEV,
    a nonprofit organization focused on the development of the core Ethereum protocol
    and infrastructure, which managed the development of various proofs of concept
    throughout 2014. |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 2014年8月 | 维塔利克·布特林、加文·伍德和杰弗里·威尔克设立了ETH DEV，一个专注于以太坊核心协议和基础设施发展的非营利组织，该组织在2014年管理了各种概念验证的开发。|'
- en: '| Nov 2014 | ETH DEV organizes DEVCON-0, the first Ethereum developer conference,
    in Berlin, where the entire Ethereum project team meets for the first time. |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 2014年11月 | ETH DEV在柏林组织了DEVCON-0，这是第一次以太坊开发者大会，整个以太坊项目团队首次聚会。|'
- en: '| Jan 2015 | The Go Ethereum team meets in Amsterdam, where Whisper Dapp and
    Mist prototypes are presented. |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 2015年1月 | Go Ethereum团队在阿姆斯特丹聚会，会上展示了Whisper Dapp和Mist的原型。|'
- en: '| Jul 2015 | Mainnet release 1.0, codenamed Frontier, and the stable beta of
    Ethereum Wallet are released. |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 2015年7月 | 发布了1.0版的主网，代号为Frontier，以及以太坊钱包的稳定测试版。|'
- en: '| Nov 2015 | In London, 400 people attend DEVCON-1, where more than 80 talks
    on each part of the Ethereum ecosystem are given. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| 2015年11月 | 在伦敦，400人参加了DEVCON-1，会上给出了关于以太坊生态系统的每个部分的80多个演讲。|'
- en: '| Mar 2016 | The project releases Mainnet release 2.0, codenamed Homestead.
    |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 2016年3月 | 该项目发布了2.0版的主网，代号为Homestead。|'
- en: '| Jul 2016 | An unplanned Ethereum fork occurs following a DAO attack, and
    a split takes place between Ethereum and Ethereum Classic. (See the sidebar.)
    |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| 2016年7月 | 在DAO攻击后，以太坊发生了一次计划外的分叉，以太坊与以太坊经典之间发生了分裂。（见边栏。）|'
- en: '| Oct 2017 | The project releases Mainnet release 3.0, codenamed Byzantium.
    |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 2017年10月 | 该项目发布了3.0版的主网，代号为Byzantium。|'
- en: '| Jun 2018 | The project releases the Proof of Stake (PoS) Testnet release,
    codenamed Casper. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 2018年6月 | 该项目发布了基于权益证明（PoS）的测试网版本，代号为Casper。|'
- en: 'If you’re interested in knowing more about the history of Ethereum, the official
    documentation has a page^([[7](#ch02fn07)]) dedicated to it. But you can get a
    firsthand and more engaging account of the main events that took place around
    Ethereum’s creation in the blog posts “Cut and Try: Building a Dream,”^([[8](#ch02fn08)])
    by Taylor Gerring (a core Ethereum developer), and “A Prehistory of the Ethereum
    Protocol,”^([[9](#ch02fn09)]) by Vitalik Buterin himself.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你对以太坊的历史感兴趣，官方文档有一个页面^([[7](#ch02fn07)])专门介绍。但你可以在泰勒·格里宁的博客文章“Cut and Try:
    Building a Dream，”^([[8](#ch02fn08)])（一名核心以太坊开发者）和维塔利克·布特林本人撰写的“以太坊协议的史前史，”^([[9](#ch02fn09)])中找到关于以太坊创建过程中发生的主要事件的一手且更吸引人的描述。|'
- en: ⁷
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷|
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “History of Etherum,” Ethereum Homestead, [http://mng.bz/XgwM](http://mng.bz/XgwM).
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“以太坊历史，”以太坊Homestead，[http://mng.bz/XgwM](http://mng.bz/XgwM)。|
- en: ⁸
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸|
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Taylor Gerring, “Cut and Try: Building a Dream,” February 9, 2016, [http://mng.bz/y1BE](http://mng.bz/y1BE).'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '参见泰勒·格里宁，“Cut and Try: Building a Dream，”2016年2月9日，[http://mng.bz/y1BE](http://mng.bz/y1BE)。|'
- en: ⁹
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹|
- en: ''
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “A Prehistory of the Ethereum Protocol,” [http://mng.bz/MxRm](http://mng.bz/MxRm).
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见维塔利克·布特林，“以太坊协议的史前史，”[http://mng.bz/MxRm](http://mng.bz/MxRm)。|
- en: '|  |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The DAO attack and the split between Ethereum and Ethereum Classic**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**DAO攻击以及以太坊与以太坊经典之间的分裂**'
- en: The DAO (which stands for decentralized autonomous organization) was one of
    the first mainstream Dapps in the Ethereum space. It was a decentralized venture
    capital fund. The DAO token holders were meant to vote on all investment decisions.
    While the DAO smart contract was still being developed, tokens were sold to investors
    through a crowdsale, a sort of decentralized crowdfunding application. (You’ll
    read more about crowdsales in [chapters 6](kindle_split_018.xhtml#ch06) and [7](kindle_split_019.xhtml#ch07).)
    This funding campaign, which took place in May 2016, managed to collect over 12M
    Ether, which at the time was worth around $150M (with Ether trading at $11).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: DAO（去中心化自治组织）是以太坊领域内的第一个主流 Dapp。它是一个去中心化的风险投资基金。DAO 代币持有者本应就所有投资决策进行投票。在 DAO
    智能合约仍在开发时，代币通过众筹销售出售给投资者，这是一种去中心化的众筹应用程序。（你会在第6章和第7章中了解更多关于众筹销售的内容。）这场于2016年5月进行的资金筹集活动成功筹集了超过1200万以太币，当时价值约1.5亿美元（以太币交易价格为11美元）。
- en: One of the features of the DAO contract was that groups of DAO token holders
    unhappy with decisions that the qualified majority made (investment decisions
    were approved with 20% of the votes) could split from the main DAO and create
    their own Child DAO, where they’d start to vote on different investment proposals.
    In June 2016, this feature, which had been identified by some community members
    as potentially weak from a security point of view, was exploited by a hacker,
    who managed to gain control of 3.5M Ether (worth around $50M at that time) through
    a recursive call that kept withdrawing funds.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: DAO 合约的一个功能是，如果 DAO 代币持有者对合格多数做出的决定（投资决策需要20%的投票支持）不满意，他们可以分裂出主 DAO 并创建自己的 Child
    DAO，在那里他们开始对不同的投资提案进行投票。2016年6月，一些社区成员认为这一功能从安全角度来看可能存在缺陷，一名黑客利用了这一功能，通过递归调用不断提取资金，成功控制了3500万以太币（当时价值约5亿美元）。
- en: Luckily, the Child DAO creation feature required funds to be withheld for 28
    days before they could be transferred out to another account, so the hacker couldn’t
    steal them immediately. This gave the DAO developers and the Ethereum community
    some time to propose solutions to prevent the theft. Finally, after a failed soft
    fork of the blockchain that would have blacklisted any transaction coming out
    of the DAO, the community voted for a hard fork, including a smart contract designed
    to return the stolen funds to the original owners. Although the majority had voted
    for the hard fork, some members of the community argued that the hard fork had
    broken various principles of the Ethereum white paper, mainly the promise that
    smart contract code is implicitly law and the guarantee that the blockchain is
    immutable. They consequently decided to keep the original blockchain running,
    and this was renamed Ethereum Classic.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Child DAO 创建功能需要保留资金28天，然后才能将其转出到另一个账户，所以黑客不能立即窃取资金。这为 DAO 开发者和以太坊社区提供了一些时间来提出解决方案以防止盗窃。最终，在区块链的软分叉失败后（该分叉将列入黑名单任何来自
    DAO 的交易），社区投票决定进行硬分叉，包括一个旨在将被盗资金归还给原所有者的智能合约。尽管大多数人投票支持硬分叉，但社区中的一些成员认为硬分叉违反了以太坊白皮书中的各种原则，主要是智能合约代码默认为法律的原则以及区块链不可篡改的保证。他们随后决定保留原始的区块链运行，并将其重命名为以太坊经典。
- en: You can find many articles and blog posts on the DAO attack, ranging in complexity
    from the technical to the high-level. Given that you don’t yet have a strong technical
    foundation in this area, if you want to learn more about this, I recommend you
    have a look at “The DAO, The Hack, The Soft Fork and The Hard Fork,”^([[10](#ch02fn10)])
    which describes in detail what happened without getting too much into the technical
    side. You’ll be able to understand the DAO attack better after having read [chapter
    15](kindle_split_029.xhtml#ch15) on security, but I cover it specifically because
    most of the techniques used are beyond the scope of this book. Nevertheless, if
    at that point you’re eager to jump to the technical details of the hack, I recommend
    the brilliant “Analysis of the DAO Exploit.”^([[11](#ch02fn11)])
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 关于DAO攻击的文章和博客文章有很多，从技术层面到高级层面不等。考虑到您在这个领域还没有很强的技术基础，如果您想了解更多关于这方面的内容，我建议您阅读一下“The
    DAO, The Hack, The Soft Fork and The Hard Fork，”^([[10](#ch02fn10)])这篇文章，它详细描述了发生了什么，而没有过多涉及技术细节。在阅读了关于安全性的第15章之后，您将能更好地理解DAO攻击，但我之所以特别提到它，是因为本书大多数所用的技术超出了本书的范围。尽管如此，如果您那时急于了解攻击的技术细节，我推荐您阅读这篇精彩的“Analysis
    of the DAO Exploit.”^([[11](#ch02fn11)])文章。
- en: ^(10)
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Antonio Madeira, “The DAO, The Hack, The Soft Fork and The Hard Fork,” July
    26, 2016, [http://mng.bz/a7NY](http://mng.bz/a7NY).
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅Antonio Madeira的文章，“The DAO, The Hack, The Soft Fork and The Hard Fork，”2016年7月26日，[http://mng.bz/a7NY](http://mng.bz/a7NY)。
- en: ^(11)
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Phil Daian, “Analysis of the DAO exploit,” Hacking, Distributed, June 18,
    2016, [http://mng.bz/gNrn](http://mng.bz/gNrn).
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅Phil Daian的文章，“Analysis of the DAO exploit，” Hacking, Distributed，2016年6月18日，[http://mng.bz/gNrn](http://mng.bz/gNrn)。
- en: '|  |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3.2\. Who controls Ethereum’s development?
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2 谁控制Ethereum的开发？
- en: After the Frontier release back in July 2015, the hot topic of Ethereum governance
    started to gather momentum within the Ethereum Foundation, as well as across the
    wider Ethereum community. Key questions, such as “Who controls Ethereum’s development,”
    “How do changes get proposed,” and “Who approves them and how” got debated openly
    so that early adopters could be encouraged to use and trust the platform.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2015年7月的Frontier版本发布以来，Ethereum治理这个热门话题在Ethereum基金会以及更广泛的Ethereum社区中开始加速推进。诸如“谁控制Ethereum的开发”、“更改如何提出”以及“谁批准它们以及如何批准”的关键问题被公开讨论，以便早期采用者能够被鼓励使用并信任这个平台。
- en: Blockchain governance is about the rules and processes that participants must
    follow for making changes to the platform, and about how the rules and processes
    themselves should get defined. In short, it’s about who decides on changes and
    how the decisions get approved and followed.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链治理关乎参与者必须遵循的规则和流程，以便对平台进行更改，以及这些规则和流程本身应该如何定义。简而言之，它关乎谁决定更改以及决策如何获得批准并得以执行。
- en: ETH DEV, the nonprofit organization leading Ethereum development, gathers proposals
    in the Ethereum Improvement Proposals (EIPs, [https://eips.ethereum.org/](https://eips.ethereum.org/))
    repository.^([[12](#ch02fn12)]) This is based on established processes also followed
    by other open source projects—Python Improvement Proposals (PIPs) and Bitcoin
    Improvement Proposals (BIPs) are classic examples. Proposals are initially studied
    and Proofs of Concept (PoCs) often follow.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ETH DEV，这个领导Ethereum开发的非营利组织，在Ethereum Improvement Proposals (EIPs, [https://eips.ethereum.org/](https://eips.ethereum.org/)
    )存储库中收集提案。^([[12](#ch02fn12)])这是基于其他开源项目也遵循的成熟流程——Python Improvement Proposals
    (PIPs) 和 Bitcoin Improvement Proposals (BIPs) 是典型的例子。提案最初被研究，通常随后会有概念验证（PoCs）。
- en: ^(12)
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the EIPs page on GitHub at [https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs).
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请访问GitHub上的EIPs页面：[https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs)。
- en: If a proposal gathers enough momentum (it’s considered interesting by the core
    Ethereum developers), it progresses to *Draft* status and might be debated further
    among the wider community at developer conferences or official online forums.
    If an informal consensus is reached, the proposal can progress immediately to
    *Accepted* or *Rejected* status. Accepted proposals get scheduled for future platform
    releases, and more effort is consequently put into them. Obviously, there’s always
    the risk that the participants won’t all agree with the proposal or its implementation,
    so the proposal is considered implicitly accepted only after most participants
    have adopted it.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个提案获得了足够的动力（被核心以太坊开发者认为是有趣的），它将进入*草稿*状态，并可能在开发人员会议或官方在线论坛上由更广泛的社区进一步讨论。如果达成了非正式共识，提案可以立即进入*接受*或*拒绝*状态。被接受的提案将被安排在未来的平台版本中发布，因此会投入更多的努力。显然，参与者总是存在不同意提案或其实施的风险，因此只有当大多数参与者采用该提案后，该提案才被视为隐性接受。
- en: 'Occasionally, some proposals cause heated debate in the wider community. In
    those cases, the decision isn’t clear-cut, and they go through formal on-chain
    voting. When it comes to on-chain voting, one of the following two competing models
    is generally followed:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，一些提案会在更广泛的社区中引起热烈讨论。在这些情况下，决策并不清晰，它们会经历正式的链上投票。当涉及到链上投票时，通常遵循以下两种竞争性模型之一：
- en: '*Loosely coupled on-chain voting (aka informal governance)*—The community leaders
    (for example the Ethereum Foundation and ETH DEV) signal how to vote. Participants
    vote on-chain through a dedicated smart contract that weights their preference
    based on how much Ether they own. (This voting is often referred to as *coinvoting.*)
    The proposal is then implemented if the outcome of the voting is favorable. Although
    the vote is ethically binding, developers or other key participants, such as miners,
    might always decide not to implement or adopt the winning proposal, at risk of
    being stigmatized by the community.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合链上投票（亦称非正式治理）—社区领导者（例如以太坊基金会和ETH DEV）示意如何投票。参与者通过一个专用的智能合约在链上投票，该合约根据他们拥有的以太币数量来赋予他们的偏好权重。（这种投票通常被称为*币投票*。）如果投票结果有利，则实施该提案。尽管投票在伦理上是具有约束力的，但开发者或其他关键参与者，如矿工，可能总是决定不实施或采用获胜的提案，冒着被社区贴上标签的风险。
- en: '*Tightly coupled on-chain voting (a.k.a on-chain governance)*—The proposal
    gets fully implemented before the vote takes place, generally by a group of developers
    backing it, and then a smart contract switches on the functionality in the production
    network only following successful on-chain voting. This model is often favored
    by purists, who argue the technical analysis shouldn’t be influenced by politics
    until the last stage.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密耦合链上投票（亦称链上治理）—在投票发生之前，提案得到完全实施，通常是由支持它的开发者团队完成的，然后智能合约在链上投票成功后仅在生产网络上启用功能。这种模型通常受到纯粹主义者的青睐，他们认为技术分析在最后阶段之前不应受到政治影响。
- en: Tightly coupled on-chain voting has been introduced in various blockchain platforms
    and has become somewhat fashionable. But like other established blockchain platforms,
    such as Bitcoin and Zcash, Ethereum tends to follow the principle of loosely coupled
    voting, openly supported by Vitalik Buterin in his blog post “Notes on Blockchain
    Governance.”^([[13](#ch02fn13)])
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合链上投票已在各种区块链平台上引入，并变得相当流行。但与比特币和Zcash等其他 established区块链平台一样，以太坊倾向于遵循松耦合投票的原则，Vitalik
    Buterin在他的博客文章“区块链治理笔记”中公开支持这一点。^([[13](#ch02fn13)])
- en: ^(13)
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Vitalik Buterin, “Notes on Blockchain Governance,” December 17, 2017, [https://vitalik.ca/general/2017/12/17/voting.html](https://vitalik.ca/general/2017/12/17/voting.html).
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Vitalik Buterin，“区块链治理笔记”，2017年12月17日，[https://vitalik.ca/general/2017/12/17/voting.html](https://vitalik.ca/general/2017/12/17/voting.html)。
- en: 'As you can see, Ethereum governance is relatively informal and centralized,
    as core developers seem to have more decision-making weight than the wider community.
    The argument is that if everything went through formal voting, the platform would
    evolve too slowly. If you’re interested in reading more on Ethereum governance,
    I recommend the following articles:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，以太坊治理相对非正式且集中，因为核心开发者似乎比更广泛的社区拥有更多的决策权。这种说法是，如果一切都通过正式投票，平台会发展得太慢。如果你对以太坊治理感兴趣，我推荐以下文章：
- en: “Ethereum Is Throwing Out the Crypto Governance Playbook”^([[14](#ch02fn14)])
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “以太坊正在摒弃加密货币治理手册”^([[14](#ch02fn14)])
- en: ^(14)
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Ethereum Is Throwing Out the Crypto Governance Playbook,”
    Coindesk, March 14, 2018, [http://mng.bz/edwZ](http://mng.bz/edwZ).
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Rachel Rose O’Leary，“以太坊正在摒弃加密治理手册，”Coindesk，2018年3月14日，[http://mng.bz/edwZ](http://mng.bz/edwZ)。
- en: “Experimental Voting Effort Aims to Break Ethereum Governance Gridlock”^([[15](#ch02fn15)])
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “实验性投票努力旨在打破以太坊治理僵局”^([[15](#ch02fn15)])
- en: ^(15)
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Rachel Rose O’Leary, “Experimental Voting Effort Aims to Break Ethereum
    Governance Gridlock,” Coindesk, May 23, 2018, [http://mng.bz/pgQ0](http://mng.bz/pgQ0).
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Rachel Rose O’Leary，“实验性投票努力旨在打破以太坊治理僵局，”Coindesk，2018年5月23日，[http://mng.bz/pgQ0](http://mng.bz/pgQ0)。
- en: “A user’s perspective and introduction to blockchain governance”^([[16](#ch02fn16)])
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “用户视角下的区块链治理介绍”^([[16](#ch02fn16)])
- en: ^(16)
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Richard Red, “A user’s perspective and introduction to blockchain governance,”
    Medium, [http://mng.bz/O2VO](http://mng.bz/O2VO).
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Richard Red，“用户视角下的区块链治理介绍，”Medium，[http://mng.bz/O2VO](http://mng.bz/O2VO)。
- en: Summary
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: An Ethereum node hosts an Ethereum client and a copy of the blockchain.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以太坊节点托管一个以太坊客户端和区块链的一个副本。
- en: An Ethereum client contains
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊客户端包含
- en: a virtual machine called Ethereum Virtual Machine (EVM), capable of executing
    smart contract bytecode
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为Ethereum虚拟机（EVM）的虚拟机，能够执行智能合约字节码。
- en: a memory pool, where transactions received by the node get stored before being
    propagated further into the network
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内存池，其中节点接收的交易在进一步传播到网络之前被存储。
- en: a JSON-RPC API, which exposes the functionality of the client to other nodes
    and external users
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JSON-RPC API，它将客户端的功能暴露给其他节点和外部用户。
- en: a client process, which coordinates the processing
  id: totrans-589
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户端进程，用于协调处理。
- en: An Ethereum smart contract is code written in the Solidity language and compiled
    into EVM bytecode.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊智能合约是使用Solidity语言编写的代码，并编译为EVM字节码。
- en: An Ethereum smart contract is deployed across the P2P network through a contract
    deployment transaction, pushed to a local Ethereum node, and then propagated throughout
    the network.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊智能合约通过合约部署交易在P2P网络上部署，推送到本地以太坊节点，然后在整个网络中传播。
- en: A blockchain is a sequence of blocks, each containing a sequence number, a timestamp,
    and a list of transactions, each individually digitally signed. Each block includes
    a copy of the cryptographic hash of the previous block and the nonce, which generates
    the hash of the current block.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链是一个由区块组成的序列，每个区块包含一个序列号、一个时间戳和一系列交易，每个交易都单独进行数字签名。每个区块包括对前一个区块的加密哈希的副本和nonce，用于生成当前区块的哈希。
- en: The main innovation introduced by Ethereum with respect to previous blockchain
    implementations is the EVM and the concept of the smart contract.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊相对于之前区块链实现的主要创新是EVM和智能合约的概念。
- en: 'Ethereum follows an informal governance model, where proposals go through the
    Ethereum Improvement Proposals (EIPs) process: they get analyzed by the core Ethereum
    developers, are often tried through Proofs of Concept (PoCs), and ultimately get
    accepted or rejected.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊遵循一种非正式的治理模式，其中提案需要经历以太坊改进提案（EIPs）的过程：它们由核心以太坊开发者进行分析，通常通过概念验证（PoCs）进行尝试，最终被接受或拒绝。
- en: Occasionally, when an EIP causes heated debate, it gets formally voted on-chain
    by the participants, but, even if the vote is favorable, a proposal is considered
    practically accepted only when the majority of the participants have adopted it.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶尔，当一个EIP引起热烈讨论时，参与者在链上对其进行正式投票，但是，即使投票有利，一个提案实际上只有在大多数参与者采纳它时才被认为是被接受。
- en: Chapter 3\. The Ethereum platform
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章. 以太坊平台
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Interacting with Ethereum through the Ethereum wallet
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以太坊钱包与以太坊交互
- en: Understanding the characteristics of Ethereum smart contracts
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解以太坊智能合约的特点
- en: Interacting with Ethereum through the Go Ethereum (geth) client
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Go Ethereum (geth) 客户端与以太坊交互
- en: Understanding and managing accounts
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和管理工作账户
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The previous chapter introduced Dapps and the underlying concepts and technologies,
    among which is Ethereum. In this chapter, I’ll cover Ethereum in much greater
    depth, so you’ll get the foundation you need to develop Dapps on this platform
    effectively. I’ll begin by presenting the Ethereum wallet, a UI tool you’ll use
    to start interacting with the Ethereum P2P network by transferring some Ether,
    the Ethereum cryptocurrency. Then you’ll get a wide overview of smart contracts,
    the key technology that Ethereum introduced.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章介绍了 Dapps 和背后的概念和技术，其中就包括以太坊。在本章中，我将更深入地介绍以太坊，所以你会得到开发 Dapps 所需的基础知识。我会首先介绍以太坊钱包，这是一个你将用来通过传输一些以太币（以太坊加密货币）开始与以太坊
    P2P 网络互动的 UI 工具。然后，你将获得智能合约的广泛概述，这是以太坊引入的关键技术。
- en: 'After learning about Go Ethereum, one of the many clients available on the
    platform, and once you understand the purpose of accounts, you’ll move to the
    next level and start interacting with the Ethereum network through Go Ethereum
    in several ways: with commands entered into the operating system shell, with instructions
    entered into the Go Ethereum console, and with HTTP requests. At that point, you
    should have acquired enough familiarity with the platform to progress with confidence
    through the rest of the book. It’ll be a dense but rewarding chapter. Let’s get
    started.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Go Ethereum，也就是平台上众多客户端中的一种之后，当你理解了账户的用途，你将进入下一个阶段，并通过几种方式开始通过 Go Ethereum
    与以太坊网络互动：将命令输入到操作系统壳中，将指令输入到 Go Ethereum 控制台，以及使用 HTTP 请求。到那时，你应该已经对平台有足够的熟悉度，可以自信地继续阅读本书的剩余部分。这将是一个密集但值得的章节。让我们开始吧。
- en: 3.1\. Connecting to Ethereum through the wallet
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 通过钱包连接到以太坊
- en: 'The Ethereum network offers two main graphical user interfaces:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊网络提供两个主要的图形用户界面：
- en: '*Mist*—A browser for Ethereum Dapps'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mist*—用于以太坊 Dapp 的浏览器'
- en: '*Ethereum wallet*—A specific version of Mist with a single Dapp bundled in
    it'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以太坊钱包*—带有单个 Dapp 的 Mist 特定版本'
- en: You’ll learn about Mist in a later chapter. For the moment, we’ll focus on the
    Ethereum wallet. The main purpose of the wallet is to store, receive, and transfer
    Ether, the Ethereum cryptocurrency. It’s similar to a Bitcoin wallet, if you’ve
    ever handled bitcoins, and you’ll initially use it to transfer Ether so that you
    can start to interact with the platform in the simplest way. It’s also a useful
    tool to learn how to deploy smart contracts and interact with them on one of the
    public Ethereum networks.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，你将会了解到 Mist。目前，我们将重点关注以太坊钱包。钱包的主要目的是存储、接收和传输以太币，这是以太坊的加密货币。如果你曾经处理过比特币，它与比特币钱包相似，你将使用它来传输以太币，以便以最简单的方式开始与平台互动。它也是一个有用的工具，可以学习如何在公共以太坊网络上部署智能合约并与之互动。
- en: 3.1.1\. Getting started with the Ethereum wallet
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1. 开始使用以太坊钱包
- en: 'When you open the download page ([https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)),
    you’ll find various versions of Mist and the Ethereum wallet. Pick the version
    of the Ethereum wallet corresponding to your operating system and download the
    related zip file. (I’ve picked Ethereum-Wallet-win64-0-11-1.zip.) After unzipping
    it, you can run the executable Ethereum Wallet.exe directly. The first time you
    launch it, it’ll default to the main network. In this chapter, you’ll work against
    the public test Ropsten network instead. To select it, you must pick it from the
    top menu, as shown in [figure 3.1](#ch03fig01): Develop > Network > Ropsten. You
    also can select the Ropsten network through the Alt+Ctrl+2 shortcut.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开下载页面([https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases))时，你会找到各种版本的
    Mist 和以太坊钱包。选择与你操作系统相对应的以太坊钱包版本，并下载相关的 zip 文件。（我选择了 Ethereum-Wallet-win64-0-11-1.zip。）解压后，你可以直接运行可执行文件
    Ethereum Wallet.exe。第一次启动时，它将默认为主网络。在本章中，你将在公共测试 Ropsten 网络上进行操作，而不是主网络。要选择它，你必须从顶部菜单中选择，如图
    3.1 所示：开发 > 网络 > Ropsten。你还可以通过 Alt+Ctrl+2 快捷键选择 Ropsten 网络。
- en: Figure 3.1\. Choosing the test Ropsten network from the Develop > Network >
    Ropsten menu option or through the Alt+Ctrl+2 shortcut
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1. 从“开发 > 网络 > Ropsten”菜单选项中选择测试 Ropsten 网络，或者通过 Alt+Ctrl+2 快捷键进行选择。
- en: '![](Images/fig03-01_alt.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-01_alt.jpg)'
- en: 'After you select the Ropsten network, the wallet will start to synchronize
    with the related blockchain. By default, the synchronization mode is Light, which,
    as you saw in the previous chapter, downloads the current state trie from a peer
    full node, so you don’t have to wait long (minutes). This will allow you to get
    up and running quickly. But if you want to perform write operations, such as transferring
    Ether or deploying smart contracts, which is what you’ll be doing, you must get
    a full copy of the blockchain—you can choose between Fast and Full. (Go back to
    the previous chapter if you don’t remember how these sync modes work.) Here’s
    a rough estimate of what to expect when you’re synchronizing the Ropsten blockchain
    locally:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择Ropsten网络后，钱包将开始与相关区块链同步。默认情况下，同步模式是轻量级，正如您在上章看到的那样，从对等节点下载当前状态三叉树，因此您不必等待很长时间（几分钟）。这将允许您快速启动。但是，如果您想要执行写操作，例如传输以太币或部署智能合约，这是您将要执行的操作，您必须获取区块链的完整副本——您可以选择快速或完整。如果您不记得这些同步模式是如何工作的，请回到上一章。以下是您在本地同步Ropsten区块链时可以预期的粗略估计：
- en: '*Fast*—Uses roughly 1 GB of disk space and takes two to four hours'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**—占用大约1 GB的磁盘空间，需要两到四个小时'
- en: '*Full*—Uses roughly 100 GB of disk space and can take up to a day or two'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整**—占用大约100 GB的磁盘空间，可能需要一两天'
- en: Once you’re synchronized, you’ll be able to see synchronization details at the
    top of the screen, including the name of the network you’re connected to, the
    latest block number, and the number of seconds passed since receiving the last
    block, as shown in [figure 3.2](#ch03fig02).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您同步完成，您将能够在屏幕顶部看到同步详细信息，包括您连接到的网络名称、最新区块号码以及自接收最后一个区块以来经过的秒数，如图[3.2](#ch03fig02)所示。
- en: Figure 3.2\. You can see synchronization details, including the name of the
    network and the latest block number, at the top of the screen.
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2。您可以在屏幕顶部看到同步详细信息，包括网络名称和最新区块号码。
- en: '![](Images/fig03-02_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-02_alt.jpg)'
- en: '|  |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: To perform the operations I’ll cover in this chapter and the next, you *must
    choose Fast or Full* synchronization; otherwise, you won’t be able to transfer
    Ether or deploy a contract through the wallet. To be able to execute a transaction,
    you must have a full local copy of the blockchain. If the wallet appears unresponsive
    after a while and you don’t notice any progress in the synchronization, it might
    be because the wallet hasn’t managed to connect to any peer nodes. In that case,
    close it down and try to synchronize the Ropsten blockchain through the geth client.
    If you need to do this, read about geth in [section 3.3](#ch03lev1sec3), and then
    synchronize it to Ropsten as explained in [chapter 8](kindle_split_020.xhtml#ch08),
    [section 8.1](kindle_split_020.xhtml#ch08lev1sec1).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行本章及下一章将介绍的操作，您必须选择快速或完整同步；否则，您将无法通过钱包传输以太币或部署合约。为了能够执行交易，您必须拥有区块链的完整本地副本。如果钱包在一段时间后似乎无响应并且您没有注意到同步有任何进展，这可能是因为钱包尚未能够连接到任何对等节点。在这种情况下，关闭它，尝试通过geth客户端同步Ropsten区块链。如果您需要这样做，请阅读[第3.3节](#ch03lev1sec3)中关于geth的部分，然后按照[第8章](kindle_split_020.xhtml#ch08)中[第8.1节](kindle_split_020.xhtml#ch08lev1sec1)的说明同步它到Ropsten。
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 3.3\. Accounts overview screen. You can create an account by clicking
    Add Account.
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3。账户概览屏幕。您可以通过点击“添加账户”来创建一个账户。
- en: '![](Images/fig03-03_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-03_alt.jpg)'
- en: At this point, you’re ready to create accounts. Click the Wallets tab, which
    will bring you to the Accounts Overview screen, and then click the Add Account
    button, which has a plus symbol next to it, as you can see in [figure 3.3](#ch03fig03).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经准备好创建账户。点击“钱包”选项卡，这将带您到“账户概览”屏幕，然后点击带有加号符号的“添加账户”按钮，如图[3.3](#ch03fig03)所示。
- en: You’ll see a small dialog box asking for a strong password. (Make sure you stretch
    the dialog from the bottom-right corner until you see the OK button.) After entering
    a password (twice), you’ll be reminded to back up your keyfiles (more on this
    later) and password.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个要求输入强密码的小对话框。（确保您从右下角拉出对话框，直到看到“确定”按钮。）输入密码（两次）后，您将被告知备份您的密钥文件（稍后详细介绍）和密码。
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Manage your passwords carefully. If you forget your password, you won’t be able
    to click any “I Forgot My Password” button. Losing your password means losing
    the Ether stored in the account. This isn’t a major problem when pointing to a
    test network, because Ether has no value there. But, especially when moving to
    the production network, you should get into the habit of choosing a strong password
    and keeping a copy of it somewhere secure. Better safe than sorry!
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re using the Ethereum wallet for Mac OS or LINUX, the interface is slightly
    different, screenshots won’t match what you see, and my descriptions might not
    work to the letter. Also, the default network shown might be different. But you
    should be able to find alternative ways to perform the operations I describe.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
- en: After the wallet has generated the account, on the Accounts Overview screen
    you’ll see *Account 1* with the related hexadecimal address and a balance of zero
    Ether. I’ll cover accounts in more detail later; for now, create one more account
    in the same way, and you now should see two accounts on the screen, as shown in
    [figure 3.4](#ch03fig04). Now that you have a couple of accounts (feel free to
    create more), you can try out some common operations with the wallet.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4\. Account details shown on the Accounts Overview screen after their
    creation
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-04_alt.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
- en: 3.1.2\. Performing common operations with the wallet
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With a balance of zero Ether (the Ethereum cryptocurrency) on all your accounts,
    you won’t be able to go too far, because as you’ll learn, to execute transactions
    on the network, you must pay transaction costs in Ether. Because it isn’t possible
    to buy Ether in the test network, you’ll have to generate it somehow. One way
    is through mining.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Mining is the process through which new transactions get consolidated into
    blocks of the blockchain. Many participants in the Ethereum network run special
    mining nodes through which they hope to be rewarded in Ether tokens and be compensated
    for the computational power they provide to the network. Although mining Ether
    in the real public network is challenging and requires specialized hardware based
    on advanced GPU chipsets, it’s easy to generate Ether in the test network with
    “plain CPU” mining through the wallet menu:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Develop > Start Mining (Testnet only)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The menu option Develop > Start Mining will appear only after the blockchain
    has been entirely synchronized in Fast or Full mode.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
- en: The CPU of your machine will get busy, and after a few minutes you should have
    accumulated enough Ether to get going.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'If for any reason mining is taking too long, an alternative way to fund your
    Ropsten accounts is through the so-called *faucet*. The following URL can send
    your addresses free test Ether: http://faucet.ropsten.be:3001/donate/<destinationaddress>,
    for example, http://faucet.ropsten.be:3001/donate/0x8713Cb74c7DB911f2056C8DD2bA5036-7-eeEa11D0\.
    After a few seconds, your destination address should receive 1 Ether, as you can
    see in [figure 3.5](#ch03fig05). You can check the status of the Ether transfer
    from the faucet by entering your address in the text box at the top of the Ropsten
    Etherscan webpage: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    If faucet.ropsten.be isn’t working as expected or you keep getting gray-listed,
    try [https://faucet.kyber.network/](https://faucet.kyber.network/). Alternatively,
    try Google ropsten faucet.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '-   如果出于任何原因挖矿时间太长，为你的Ropsten账户提供资金的另一种方式是通过所谓的*水龙头*。以下网址可以免费发送测试以太币到你的地址：http://faucet.ropsten.be:3001/donate/<目的地地址>，例如，http://faucet.ropsten.be:3001/donate/0x8713Cb74c7DB911f2056C8DD2bA5036-7-eeEa11D0\.
    几秒钟后，你的目标地址应该会收到1个以太币，如图3.5所示。[figure 3.5](#ch03fig05) 你可以通过在Ropsten Etherscan网页顶部的文本框中输入你的地址来检查水龙头发送以太币的状态：[https://ropsten.etherscan.io/](https://ropsten.etherscan.io/)。如果faucet.ropsten.be无法按预期工作或者你一直被列入灰名单，可以尝试[https://faucet.kyber.network/](https://faucet.kyber.network/)。或者，尝试Google
    ropsten faucet。'
- en: Figure 3.5\. Account balances after using the faucet facility
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   图3.5. 使用水龙头设施后的账户余额'
- en: '![](Images/fig03-05_alt.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-05_alt.jpg)'
- en: Transferring Ether
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   转移以太币'
- en: Now you can try to move some Ether between accounts. It’s easy. First, go to
    the Send screen. Select the source (Account 1) and target account addresses (copy
    the address of Account 2 from the Accounts Overview screen), then select the amount
    of Ether you want to transfer—for example, 0.5 Ether. Finally, after deciding
    on a transaction fee, click Send Transaction. Don’t worry too much about this
    for now; we’ll examine transaction fees later.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '-   现在你可以尝试在账户之间移动一些以太币。很简单。首先，前往发送屏幕。选择源（账户1）和目标账户地址（从账户概览屏幕复制账户2的地址），然后选择你想转移的以太币金额——例如，0.5以太币。最后，在决定交易费用后，点击发送交易。现在不用担心这个；我们稍后讨论交易费用。'
- en: You’ll be prompted to enter a password, as shown in [figure 3.6](#ch03fig06).
    Enter the password of the source account (Account 1) to digitally sign the transaction
    and subsequently prove that the account owner is sending it, and then click Send
    Transaction. You’ve now completed your first Ether transaction!
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '-   你会被提示输入密码，如图3.6所示。[figure 3.6](#ch03fig06)输入源账户（账户1）的密码以数字签名交易，并随后证明账户所有者正在发送该交易，然后点击发送交易。你现在已经完成了你的第一次以太币交易！'
- en: Figure 3.6\. Password entry screen for moving Ether between accounts. You’re
    required to enter the password of the sending account when transferring Ether
    with the Ethereum wallet, to digitally sign the transaction and consequently prove
    it’s genuinely the account owner who’s sending the Ether.
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   图3.6. 在账户之间移动以太币的密码输入屏幕。当使用以太坊钱包发送以太币时，必须输入发送账户的密码以数字签名交易，从而证明确实是账户所有者发送以太币。'
- en: '![](Images/fig03-06_alt.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-06_alt.jpg)'
- en: To check the status of the transaction, go back to the Accounts Overview screen
    and click Latest Transactions at the bottom of the screen. Clicking on the related
    link will allow you to drill down into further details, such as those shown in
    the screenshot in [figure 3.7](#ch03fig07).
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '-   要查看交易的状态，返回账户概览屏幕，并在屏幕底部点击最新交易。点击相关链接可以进一步查看详细信息，如图3.7所示的屏幕截图。[figure 3.7](#ch03fig07)'
- en: Figure 3.7\. Summary transaction information from the Transactions panel of
    the Accounts Overview screen
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   图3.7. 账户概览屏幕中交易概要信息'
- en: '![](Images/fig03-07_alt.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-07_alt.jpg)'
- en: 'You can get a better idea of how your transaction has contributed to the Ropsten
    blockchain by checking it on *Etherscan*, a website reporting the real-time evolution
    of the Ethereum blockchain. Use this URL to access the test network: [https://ropsten.etherscan.io/](https://ropsten.etherscan.io/).
    You’ll be able to get detailed block and transaction information.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '-   你可以通过在Etherscan网站上检查，更好地了解你的交易对Ropsten区块链的贡献。这是一个报告以太坊区块链实时发展的网站：[https://ropsten.etherscan.io/](https://ropsten.etherscan.io/)。你可以获取详细的区块和交易信息。'
- en: 'Now that you’ve acquired some familiarity with Ethereum, it’s time to learn
    more about one of the greatest innovations that this platform introduced: smart
    contracts. Once you grasp how smart contracts work, you’ll be able to make further
    progress on SimpleCoin, the cryptocurrency you started to build in the previous
    chapter.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经对以太坊有了一些了解，是时候了解更多关于这个平台引入的伟大创新之一：智能合约。一旦你理解了智能合约是如何工作的，你就能在SimpleCoin这个你在上一章开始构建的加密货币上取得更大的进步。
- en: '3.2\. Smart contracts: The brain of Dapps'
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 智能合约：Dapps的大脑
- en: As I described in [chapter 1](kindle_split_012.xhtml#ch01), an Ethereum smart
    contract, or simply *contract*, is a software artifact containing business rules
    and a state. It’s written in a high-level language such as Solidity, compiled
    into EVM bytecode, deployed onto the Ethereum network, and stored on its blockchain
    against a specific account generated at deployment.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在第1章所描述，以太坊智能合约，或简单地说*合约*，是一个包含业务规则和状态的软件实体。它是用如Solidity之类的高级语言编写的，编译成EVM字节码，部署到以太坊网络，并存储在其区块链上的一个特定账户，该账户在部署时生成。
- en: As shown in [figure 3.8](#ch03fig08), a contract receives transaction messages
    from a user account (or from other contracts) and executes its logic on the Ethereum
    Virtual Machine (EVM). This might optionally involve sending messages to other
    contracts, reading state from the blockchain, or writing state to the blockchain
    (specifically from/to the State Merkle-Patricia trie). The account sending the
    message to the contract gets charged (in Ether) by the successful mining node
    for computation and network resources consumed during the processing of the requested
    operation. The amount of such computation and resources is calculated in a unit
    called *gas*, as you’ll see in [section 3.2.3](#ch03lev2sec5), so it’s common
    to say that a transaction consumes a certain amount of gas (rather than resources).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.8所示，合约从用户账户（或其他合约）接收交易消息，并在以太坊虚拟机（EVM）上执行其逻辑。这可能涉及到向其他合约发送消息，从区块链中读取状态，或向区块链写入状态（具体来说是从/到状态Merkle-Patricia树）。向合约发送消息的账户会被成功挖矿节点收取以太币，用于处理所请求操作期间的计算和网络资源消耗。这种计算和资源的数量是以一个称为*燃料*的单位计算的，正如你将在3.2.3节看到的，所以通常说一个交易消耗了一定的燃料（而不是资源）。
- en: Figure 3.8\. An Ethereum contract receives a transaction message from a user
    account. Its logic is executed on the Ethereum Virtual Machine (EVM); then the
    successful miner calculates the cost for the computational and network resources
    used, in a unit called gas, and charges the user account in Ether.
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8. 以太坊合约从用户账户接收交易消息。它的逻辑在以太坊虚拟机（EVM）上执行；然后成功挖矿者计算执行计算和网络资源所使用的燃料单位，并以以太币向用户账户收费。
- en: '![](Images/fig03-08_alt.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-08_alt.jpg)'
- en: 'If you want to understand smart contracts, how they get instantiated by users
    and by other contracts, and especially how they get executed, you need to go in
    greater detail through various concepts I’ve only touched on so far:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要理解智能合约，用户和其他合约是如何实例化它们的，以及它们是如何执行的，你需要更深入地了解我到目前为止只触及的各种概念：
- en: Accounts
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户
- en: Ether and gas
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太币和燃料
- en: Transaction messages
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易消息
- en: The Ethereum Virtual Machine
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊虚拟机
- en: I’ll start by telling you more about the various types of accounts.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我会告诉你更多关于各种类型的账户的信息。
- en: 3.2.1\. Accounts
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1. 账户
- en: 'You’ve already come across the concept of *accounts* a few times. Accounts
    are available in two types:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经遇到了账户的概念好几次了。账户分为两种类型：
- en: '*Externally owned accounts (EOA)* (or simply *External Accounts*)—These are
    also known informally as *user accounts*. They’re publicly identifiable from their
    public key, but they can only be operated by knowing the private key. If you buy
    some Ether, you’d store it in this type of account. Also, you’d start a transaction
    against a smart contract from an EOA.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部所有者账户（EOA）(或简单地说*外部账户*)—这些也被非正式地称为*用户账户*。从其公钥可以公开识别它们，但只有知道私钥才能操作它们。如果你买了一些以太币，你会把它存在这种类型的账户里。而且，你也会从一个EOA开始与智能合约的交易。
- en: '*Contract accounts*—These are the accounts that contracts are executed under.
    The account address is generated at deployment time, and it identifies the location
    of the contract in the blockchain.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约账户—这些账户是用于执行合约的。合约地址在部署时生成，它标识了合约在区块链上的位置。
- en: Both EOAs and contract accounts hold data in the form of a key-value store and
    an Ether balance. [Table 3.1](#ch03table01) compares the main properties of EOAs
    and contract accounts.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所账户和合约账户都以键值存储和以太币余额的形式存储数据。[表 3.1](#ch03table01) 比较了交易所账户和合约账户的主要属性。
- en: Table 3.1\. Comparison between an EOA and a Contract Account
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1. 交易所账户与合约账户对比
- en: '| Property | Externally owned account | Contract account |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 外部所有账户 | 合约账户 |'
- en: '| --- | --- | --- |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Has Ether balance | Yes | Yes |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| 是否有以太币余额 | 是 | 是 |'
- en: '| Can start transaction message | Yes | No |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| 能否发起交易消息 | 是 | 否 |'
- en: '| Can start call message | No | Yes |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| 能否发起调用消息 | 否 | 是 |'
- en: '| Has code | No | Yes |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| 是否有代码 | 否 | 是 |'
- en: 3.2.2\. Ether
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2. 以太币
- en: I’ve mentioned Ether casually a few times, so it’s probably time you learned
    more about it. Ether is the cryptocurrency that the Ethereum blockchain supports.
    Its main purpose is to represent monetary value for services and goods traded
    over the platform.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 我随便提到了几次以太币，所以可能是时候让你了解更多关于以太币的信息了。以太币是支持以太坊区块链的加密货币。其主要用途是代表在平台上交易的服务和商品的货币价值。
- en: Ether is also used to pay for transaction fees. These are, as mentioned in [section
    3.2](#ch03lev1sec2) and covered more in [section 3.2.3](#ch03lev2sec5), calculated
    in a unit called gas, which measures computational resources that a transaction
    consumes. But these fees are settled in Ether (calculated from the price of a
    unit of gas, expressed in Ether). Miners charge transaction fees to get compensated
    for the computational power they provide the network while appending new transaction
    blocks to the blockchain.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币也用于支付交易费用。如[3.2](#ch03lev1sec2)节和[3.2.3](#ch03lev2sec5)节所述，这些费用以计算单位“气”来衡量，该单位衡量交易消耗的计算资源。但是这些费用是以以太币结算的（从单位气的价格计算得出）。矿工通过向网络提供计算能力并在区块链上附加新的交易区块来收取交易费用作为补偿。
- en: Ether comes in various denominations, which are all defined, as you can see
    in [table 3.2](#ch03table02), as a multiple of Wei, the smallest Ether denomination.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币有各种面额，正如您在[表 3.2](#ch03table02)中所见，都是以 Wei 为单位的最小以太币面额来定义的。
- en: Table 3.2\. Ether denominations and values in Wei
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.2. 以太币面额及其在 Wei 中的价值
- en: '| Unit | Wei value | Wei |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| 单位 | Wei 值 | Wei |'
- en: '| --- | --- | --- |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Wei | 1 Wei | 1 |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| Wei | 1 Wei | 1 |'
- en: '| Kwei (Babbage) | 1e3 Wei | 1,000 |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| 克维 (Babbage) | 1e3 Wei | 1,000 |'
- en: '| Mwei (Lovelace) | 1e6 Wei | 1,000,000 |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| 兆维 (Lovelace) | 1e6 Wei | 1,000,000 |'
- en: '| Gwei (Shannon) | 1e9 Wei | 1,000,000,000 |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| 吉维 (Shannon) | 1e9 Wei | 1,000,000,000 |'
- en: '| Microether (Szabo) | 1e12 Wei | 1,000,000,000,000 |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| 微以太 (Szabo) | 1e12 Wei | 1,000,000,000,000 |'
- en: '| Milliether (Finney) | 1e15 Wei | 1,000,000,000,000,000 |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 毫以太 (Finney) | 1e15 Wei | 1,000,000,000,000,000 |'
- en: '| Ether | 1e18 Wei | 1,000,000,000,000,000,000 |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| 以太币 | 1e18 Wei | 1,000,000,000,000,000,000 |'
- en: '[Figure 3.9](#ch03fig09) summarizes the Ether lifecycle, which goes through
    the following steps:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.9](#ch03fig09) 总结了以太币的生命周期，它经历了以下步骤：'
- en: Minting Ether
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 铸造以太币
- en: Transferring Ether
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输以太币
- en: Storing Ether
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储以太币
- en: Exchanging Ether
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换以太币
- en: Figure 3.9\. The Ether lifecycle. Ether is minted by miner nodes into miner
    user accounts. Then it’s transferred to EOAs (also known as user accounts). From
    there, it can be stored on various wallets. Ultimately, it can be converted to
    real currency, such as USD, EUR, YEN, GBP, and others, through cryptocurrency
    exchanges.
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9. 以太币生命周期。以太币由矿工节点铸造到矿工用户账户中。然后它被传输到交易所账户（也称为用户账户）。从那里，它可以存储在各种钱包中。最终，它可以通过加密货币交易所兑换成美元、欧元、日元、英镑等真实货币。
- en: '![](Images/fig03-09_alt.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-09_alt.jpg)'
- en: Minting Ether
  id: totrans-707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 铸造以太币
- en: If you’re unfamiliar with cryptocurrencies, you must be wondering how Ether
    is minted and exchanged. Ether is generated through the mining process, during
    which miners compete to group and append transactions into new blockchain blocks,
    as I discussed in [section 1.1.2](kindle_split_012.xhtml#ch01lev2sec2). When successful,
    a miner gets rewarded with a certain number of Ether coins. Blocks are added to
    the Ethereum blockchain every 15 seconds or so, and the money supply increases
    accordingly.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉加密货币，你可能会想知道以太币是如何铸造和交换的。以太币是通过挖矿过程产生的，在这个过程中，矿工竞争将交易分组并附加到新的区块链区块中，如我在[1.1.2](kindle_split_012.xhtml#ch01lev2sec2)节中讨论的。成功时，矿工将获得一定数量的以太币硬币作为奖励。大约每
    15 秒就会在以太坊区块链上添加一个区块，相应的货币供应量也会增加。
- en: Transferring Ether
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传输以太币
- en: Once Ether has been generated, it’s allocated to the miner’s external account.
    Miners can then transfer Ether to other external accounts or contract accounts,
    either through the Ethereum wallet or programmatically, as you’ll see later.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以太币被生成，它就被分配给矿工的外部账户。矿工然后可以将以太币转移到其他外部账户或合约账户，无论是通过以太坊钱包还是像后面会看到的程序化方式。
- en: Exchanging Ether
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 交换以太币
- en: 'Because Ether is valuable, it doesn’t generally get transferred for free between
    accounts. It’s often transferred in return for goods and services traded through
    smart contracts, but also in return for conventional currency, such as US dollars,
    euros, pounds, yen, and so on. Although it’s possible to buy Ether from individual
    owners and pay them an agreed amount of conventional currency, it’s more effective
    to handle such transactions using cryptocurrency exchanges. Two main types of
    exchanges are available: centralized, such as Kraken, Coinbase, and Coinsquare,
    and decentralized, such as EtherEx. Each exchange is generally biased toward a
    specific real-world currency.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太币有价值，它通常不会免费在账户间转移。它通常是在智能合约进行的商品和服务交换中转移，但也可能是用比如美元、欧元、英镑、日元等传统货币来交换。尽管有可能从个体所有者那里购买以太币，并支付他们约定数量的传统货币，但使用加密货币交易所处理这类交易更加有效。有两种主要的交易所类型可用：集中的，如Kraken、Coinbase和Coinsquare，以及去中心的，如EtherEx。每个交易所通常都倾向于特定的现实世界货币。
- en: Storing Ether
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 存储以太币
- en: Once someone acquires Ether, whether through mining, smart contract trading,
    or exchange-based trading, it’s allocated to an account. You can manage accounts
    using many methods, each with a different trade-off between convenience and security.
    The most convenient one is generally through desktop or online wallets, which
    allow you to transfer Ether easily. The most secure one is through cold or paper
    storage, which means generating the private key offline and holding it literally
    on a piece of paper. Hardware wallets present another high-security option and
    are conceptually similar to paper wallets because they can be considered offline.
    The main difference is that the account owner stores the private key on a small
    electronic device similar to a USB key. [Table 3.3](#ch03table03) summarizes the
    different options.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某人获得以太币，不管通过挖矿、智能合约交易还是基于交易所的交易，它都会分配到一个账户。你可以用很多方法来管理账户，每种方法都在便利性和安全性之间有不同的权衡。最便利的一般是通过桌面或在线钱包，这让你能轻松地转移以太币。最安全的则是通过冷存储或纸质存储，这意味着生成私钥离线，并实际上将其保存在一张纸上。硬件钱包提供了另一种高安全性选择，在概念上与纸质钱包相似，因为它们可以被认为是在线下的。主要区别在于账户所有者将私钥存储在一个类似USB键的小型电子设备上。[表3.3](#ch03table03)总结了不同的选项。
- en: Table 3.3\. Wallet types and their characteristics
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Table 3.3. 钱包类型及其特点
- en: '| Wallet type | Convenience | Security | Examples |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 钱包类型 | 便利性 | 安全性 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Desktop wallet | High | High | Ethereum wallet, Exodus |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| 桌面钱包 | 高 | 高 | 以太坊钱包，Exodus |'
- en: '| Mobile wallet | High | Low | Jaxx |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| 移动钱包 | 高 | 低 | Jaxx |'
- en: '| Online wallet | High | Medium | MyEtherWallet, Coinbase, Kraken |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| 在线钱包 | 高 | 中 | MyEtherWallet, Coinbase, Kraken |'
- en: '| Hardware wallet | Medium | Very high | Trezor, Ledger Nano, KeepKey |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| 硬件钱包 | 中 | 非常高 | Trezor, Ledger Nano, KeepKey |'
- en: '| Paper storage | Low | Very high | EthAddress |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 纸质存储 | 低 | 非常高 | EthAddress |'
- en: I’ve mentioned that transaction fees are charged in Ether but calculated in
    a unit called gas. Let’s see what gas is and how it’s related to transaction costs.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过交易费用是以太币计价，但以一个叫燃气的东西来计算。我们来看看燃气是什么以及它和交易费用有什么关系。
- en: 3.2.3\. Gas
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3. 燃气
- en: Gas is the unit of measure for transaction fees charged on the Ethereum platform.
    The amount of gas used to complete a transaction depends on the amount of computational
    resources that the EVM spends while running the transaction. Specifically, it
    depends on the exact low-level EVM instructions that have been executed during
    the transaction. [Table 3.4](#ch03table04) gives an idea of the amount of gas
    charged for the most common EVM operations.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 燃气是以太坊平台上交易费用衡量单位。完成一笔交易所需的燃气量取决于执行交易时EVM（以太坊虚拟机）花费的计算资源量。具体地说，这取决于交易过程中执行的具体低级EVM指令数量。[表3.4](#ch03table04)提供了最常见EVM操作的燃气费用大概。
- en: Table 3.4\. Gas cost for simple EVM operations
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Table 3.4. 简单EVM操作的燃气费用
- en: '| Operation | EVM op code | Gas cost |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | EVM操作码 | 燃气费用 |'
- en: '| --- | --- | --- |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Addition, subtraction | ADD, SUB | 3 |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| 加法、减法 | ADD, SUB | 3 |'
- en: '| Multiplication, division | MUL, DIV | 5 |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| 乘法、除法 | MUL, DIV | 5 |'
- en: '| Comparison | LT, GT, SLT, SGT | 3 |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: 比较 | LT, GT, SLT, SGT | 3 |
- en: '| Load word from memory | MLOAD | 3 |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: 从内存中加载单词 | MLOAD | 3 |
- en: '| Store word to memory | MSTORE | 3 |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: 将单词存储到内存中 | MSTORE | 3 |
- en: '| Load word from storage | SLOAD | 200 |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: 从存储中加载单词 | SLOAD | 200 |
- en: '| Storing word into storage | SSTORE | >5000 |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: 将单词存储到存储中 | SSTORE | >5000 |
- en: '| Contract creation | CREATE | 32000 |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: 合约创建 | CREATE | 32000 |
- en: The main reason the execution of a transaction is charged in units of gas, and
    indirectly in units of computational work, is to prevent denial of service (DoS)
    attacks by unscrupulous participants who might want to disrupt the network. To
    launch a DoS attack, a malicious participant would have to spam the network with
    a high number of transactions, each performing a large amount of computational
    work; for instance, an infinite loop. The amount of gas corresponding to this
    work would be high, and it would have to be paid in a correspondingly high amount
    of Ether—it’s unlikely anyone would pay to disrupt a service!
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 交易执行以燃料单位计费的主要原因，以及间接以计算工作单位计费，是为了防止不良参与者通过可能想破坏网络的服务拒绝攻击（DoS）。要发起DoS攻击，恶意参与者必须向网络发送大量交易，每笔交易执行大量计算工作；例如，一个无限循环。这笔工作的燃料量会很高，并且必须以相应的高额以太币支付——几乎没有人会支付来破坏一个服务！
- en: Most smart contract development IDEs give an idea of the total amount of gas
    required to complete a transaction. For example, in the screenshot in [figure
    3.10](#ch03fig10), you can see a gas estimate for the execution of the transfer
    function of the `SimpleCoin` contract from the last section of [chapter 1](kindle_split_012.xhtml#ch01),
    obtained by clicking the Details button on the output panel.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数智能合约开发IDE可以提供一个交易完成所需的总燃料量的概念。例如，在[图3.10](#ch03fig10)的截图中，你可以看到通过在输出面板上点击“详情”按钮获得的`SimpleCoin`合约的转移函数执行的燃料估算，该合约是来自[第1章](kindle_split_012.xhtml#ch01)的最后部分。
- en: Figure 3.10\. Transaction costs for the execution of the `SimpleCoin` transfer
    function
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. `SimpleCoin`转移函数执行的成本
- en: '![](Images/fig03-10_alt.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-10_alt.jpg)'
- en: 'Transaction fee costs are calculated according to this formula: transaction
    fees (in Ether) = number of units of gas consumed * price per unit of gas (in
    Ether). Let’s break it down:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 交易费用成本是根据此公式计算的：交易费用（以以太币计）= 消耗的燃料单位数 * 每单位燃料的价格（以以太币计）。让我们来分解一下：
- en: The EVM determines the *number of units of gas consumed* while running the transaction,
    and that depends on the computational cost of the code being run during the transaction.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行交易时，EVM确定消耗的*燃料单位数*，这取决于在交易期间运行的代码的计算成本。
- en: The sender of the transaction decides the *price of a unit of gas* (in Ether).
    The higher it is, the more likely it is that miners will include the transaction
    in the block they’re processing. Miners prioritize transactions that are likely
    to pay high fees, so if a transaction is expected to consume a relatively low
    amount of gas, the sender will have to set a relatively high gas price to guarantee
    quick processing.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的发送者决定了*燃料单位的价格*（以以太币计）。价格越高，矿工将交易包含在他们正在处理的区块中的可能性就越大。矿工优先处理可能支付高费用的交易，因此如果一个交易预计会消耗相对较少的燃料，发送者将不得不设置一个相对较高的燃料价格以确保快速处理。
- en: The transaction sender sets a *limit* for *the maximum amount of gas* that a
    transaction should consume. This protects the sender from higher-than-expected
    transaction costs due to execution of the code in a way different from what was
    intended; for instance, if the developer introduces a bug that causes an infinite
    loop. Such limits should be relatively close to the estimated amount of gas needed
    to complete the transaction.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易发送者为*交易应消耗的最大燃料量*设置了限制。这保护了发送者免受由于代码执行方式与预期不同而导致的意外高的交易成本；例如，如果开发者引入了一个导致无限循环的错误。这些限制应该相对接近完成交易所需的预估燃料量。
- en: 'While a transaction is being executed, the EVM consumes its gas. Two outcomes
    are possible at the end of the transaction:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易执行期间，EVM消耗其燃料。在交易结束时可能有两个结果：
- en: '*The transaction completes successfully*. In this case, the unused gas is returned
    to the sender.'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*交易成功完成*。在这种情况下，未使用的燃料将退还给发送者。'
- en: '*The amount of gas available ends before the completion of the transaction*.
    In this case, the EVM throws an *end of gas exception*, and the transaction is
    rolled back.'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在交易完成之前，可用的燃料量结束了*。在这种情况下，EVM抛出一个*燃料结束异常*，并且交易被回滚。'
- en: You might be wondering who pockets the transaction fee. Given either of the
    two transaction outcomes, the miner who has processed the transaction receives
    the fee. For the first outcome, they earn the fee by including the transaction
    in a new block that has been successfully appended to the blockchain. For the
    second outcome, even though the EVM throws an exception, the miner still charges
    the gas in Ether, and they collect the related transaction fee as usual. In short,
    a successful miner is rewarded by minting new Ether and getting transaction fees
    from the transaction senders. In the early stages of the Ethereum platform, most
    of a miner’s profits came from minting.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道交易费用谁来支付。鉴于这两种交易结果中的任何一种，处理交易的矿工将收到费用。对于第一种结果，他们通过将交易包含在成功附加到区块链的新块中来赚取费用。对于第二种结果，即使EVM抛出异常，矿工仍会以以太币收取燃料费，并像往常一样收取相关交易费用。简而言之，成功的矿工通过铸造新以太币和从交易发送者那里获得交易费用来奖励。在以太坊平台的早期阶段，矿工的大部分利润来自于铸币。
- en: 3.2.4\. Calls and transactions
  id: totrans-749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4. 调用和交易
- en: 'Accounts interact with each other through two types of messages: calls and
    transactions.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 账户通过两种类型的消息相互交互：调用和交易。
- en: Calls
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用
- en: 'A call is sent through a message that doesn’t get stored on the blockchain
    and whose execution has the following characteristics:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 调用是通过不存储在区块链上的消息发送的，其执行具有以下特点：
- en: It can only perform read-only operations, which don’t alter the state of the
    blockchain.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能执行只读操作，这些操作不会改变区块链的状态。
- en: It doesn’t consume any gas, and consequently, it’s free.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不消耗任何燃料，因此是免费的。
- en: It’s processed synchronously.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是同步处理的。
- en: It immediately returns a return value.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它立即返回一个返回值。
- en: It doesn’t allow transferring Ether to the contract account.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许将以太币转移给合约账户。
- en: Typical calls are direct invocations of contract member variables, including
    mappings, and invocations of so-called *constant functions*, which don’t alter
    contract state. You performed calls, for example, when you checked account balances
    of SimpleCoin, the basic cryptocurrency you started to build at the end of [chapter
    1](kindle_split_012.xhtml#ch01).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的调用是对合约成员变量的直接调用，包括映射，以及对所谓的*常量函数*的调用，这些函数不会改变合约状态。例如，当您检查SimpleCoin账户余额时，您进行了调用，这是您在第1章末开始构建的基本加密货币。
- en: Transactions
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 交易
- en: 'A transaction, which I introduced to you in the Dapp dynamic view in [chapter
    1](kindle_split_012.xhtml#ch01), is sent through a message that gets serialized
    and stored on the blockchain during the mining process. It contains the following
    fields:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章的Dapp动态视图中，我向您介绍的交易是通过在挖矿过程中序列化并存储在区块链上的消息发送的。它包含以下字段：
- en: '*Sender address*'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者地址
- en: '*Recipient address*'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收件人地址
- en: '*Value*—Amount of Ether to be transferred (in Wei), in case the message is
    being used to transfer Ether (optional)'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值——转移以太币的数量（以 Wei 计），如果消息被用来转移以太币（可选）
- en: '*Data*—Input parameters, in case the message is being used as a function call
    (optional)'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据——输入参数，以防消息被用作函数调用（可选）
- en: '*StartGas*—Maximum amount of gas to be used for the execution of the message.
    If this limit is exceeded, the EVM throws an exception and rolls back the state
    of the message.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始燃料——用于消息执行的最大燃料量。如果超出此限制，EVM将抛出异常并回滚消息状态。
- en: '*Digital signature*—Proves the identity of the transaction sender'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名——证明交易发送者的身份
- en: '*GasPrice*—The price of a unit of gas (expressed in Ether) the transaction
    initiator is willing to pay, as discussed in the gas section'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燃料价格——交易发起者愿意支付的每单位燃料的价格，如燃料部分所述
- en: 'You executed transactions when you performed SimpleCoin transfers. The execution
    of a transaction has the following characteristics:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 您在执行SimpleCoin转账时执行了交易。交易的执行具有以下特点：
- en: It can perform write operations, which alter the state of the blockchain.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以执行写操作，改变区块链的状态。
- en: It consumes gas, which must be paid for in Ether.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消耗燃料，必须用以太币支付。
- en: 'It’s processed asynchronously: it gets executed through mining and then gets
    appended on a new blockchain block, which gets broadcast throughout the network.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为异步处理：通过挖矿执行，然后附加到新的区块链块上，然后在整个网络上广播。
- en: It immediately returns a transaction ID, but not a return value.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它立即返回一个交易ID，但不返回一个返回值。
- en: It allows transferring Ether to the contract account. (The Ether transfer becomes
    part of the transaction itself.)
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许将以太币转移到合约账户中。（以太币的转移成为交易本身的一部分。）
- en: By now you know contracts are executed on the EVM on each node of the Ethereum
    network. I’ll provide a quick overview of how the EVM works.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您知道智能合约是在以太坊网络的每个节点上由EVM执行的。我将简要介绍EVM是如何工作的。
- en: 3.2.5\. The Ethereum Virtual Machine
  id: totrans-775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.5. 以太坊虚拟机
- en: 'The Ethereum Virtual Machine (EVM) is a stack-based abstract computing machine,
    similar in purpose to the Java virtual machine (JVM) and to the .NET Common Language
    Runtime (CLR). It enables a computer to run an Ethereum application and has two
    memory areas:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）是一个基于栈的抽象计算机器，其目的类似于Java虚拟机（JVM）和.NET公共语言运行时（CLR）。它使计算机能够运行以太坊应用程序，并具有两个内存区域：
- en: '*Volatile memory*, or simply *memory*. This is a word-addressed byte array,
    which gets allocated to a contract at every message call. Reads access 256-bit
    words, whereas writes can be performed on a width of 8 or 256 bits.'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易失内存*，或简称为*内存*。这是一个字地址的字节数组，每次消息调用时都会分配给智能合约。读取访问256位字，而写入可以在8位或256位宽度上执行。'
- en: '*Storage*. This is a key-value store where both key and value have a width
    of 256 bits. Storage is allocated to each account and is persisted on the blockchain.
    A contract account can access only its own storage.'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储*。这是一个键值存储，键和值都是256位宽。存储分配给每个账户，并持久化在区块链上。合约账户只能访问自己的存储。'
- en: 'EVM opcodes cover operations including Boolean, bitwise, and arithmetic comparisons
    and jumps (both conditional and unconditional). These are the main opcodes handling
    contract creation and calls:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: EVM操作码包括布尔、位wise和算术比较与跳转（条件性和无条件）操作。这些是处理合约创建和调用的主要操作码：
- en: '`CREATE`—This performs the creation of a new contract instance.'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE`—这执行了新的合约实例的创建。'
- en: '`CALL`—A contract sends a message to itself or other contracts through this
    operator.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CALL`—合约通过此操作符向自己或其他合约发送消息。'
- en: '`DELEGATECALL`—This operator allows the calling contract to send a message
    to an external contract but execute the related code in the context of the caller.
    This operator is especially useful for the creation of libraries of shared code
    that multiple contracts can access.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELEGATECALL`—此操作符允许调用合约向外部合约发送消息，但在调用者的上下文中执行相关代码。这个操作符特别适用于创建多个合约可以访问的共享代码库。'
- en: 'The EVM is completely sandboxed: a contract can’t access network or filesystem
    resources. It can only access other contracts. A more in-depth explanation of
    the EVM is outside the scope of this book. The best reference for understanding
    its design is Gavin Wood’s so-called *Yellow Paper*: [http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf).'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是完全沙盒化的：合约不能访问网络或文件系统资源。它只能访问其他合约。深入解释EVM的设计超出了本书的范围。要理解其设计，最好的参考资料是Gavin
    Wood所谓的*黄色论文*：[http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf)。
- en: 'At this point, you’ve consolidated your knowledge on smart contracts. Now it’s
    time to take a step further and connect to the Ethereum network through a proper
    client: the Go Ethereum client.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你已经巩固了你对智能合约的知识。现在该更进一步，通过适当的客户端连接到以太坊网络：Go Ethereum客户端。
- en: 3.3\. Connecting to Ethereum with geth
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 使用geth连接到以太坊
- en: Before you start installing a client, I’d like to give you a more detailed overview
    of the Ethereum network, which I started introducing in [chapter 1](kindle_split_012.xhtml#ch01).
    It’ll help you understand the wider context that a client fits in.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始安装客户端之前，我想给您更详细地介绍以太坊网络，我已经在第1章中开始介绍它。这将帮助您了解客户端所适配的更广泛的环境。
- en: You already know the Ethereum network is a peer-to-peer (P2P) network, which
    means there’s no central master or server node coordinating them. Consequently,
    all nodes are clients to each other. Nodes are designed to work and communicate
    with each other in exactly the same way, according to a predefined protocol called
    Wire, described in the Yellow Paper. This means all nodes must be able to append
    new transaction blocks to the blockchain (if mining is activated) and verify them
    while blocks get propagated throughout the network.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道以太坊网络是一个点对点（P2P）网络，这意味着没有中央主节点或服务器节点来协调它们。因此，所有节点彼此都是客户端。节点根据黄色论文中定义的预定义协议（Wire）以完全相同的方式工作和相互通信。这意味着所有节点必须能够将新的交易区块附加到区块链（如果启用了挖矿）并在网络中的区块传播时验证它们。
- en: 'From an implementation point of view, the network contains two broad categories
    of nodes:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现角度来看，网络包含两类广泛的节点：
- en: '*Miners*—They process the latest transactions and consolidate them into the
    blockchain in exchange for transaction fees and a mining reward (in Ether) if
    they manage to execute the consensus algorithm successfully. In that case, they
    propagate the blocks they’ve consolidated onto the blockchain to other peers of
    the network. Because these nodes generate new blocks, they’re considered producers
    (although they’re technically also still consumers).'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*矿工*—他们处理最新的交易，并将它们合并到区块链中，以交易费用和挖矿奖励（以以太币计）的形式作为成功执行共识算法的回报。在这种情况下，它们将合并后的区块传播到网络的其他对等体。因为这些节点生成新块，所以它们被认为是生产者（尽管从技术上讲，它们仍然也是消费者）。'
- en: '*Full nodes*—They mainly verify the validity of the blocks they’ve received
    from neighboring peers and keep propagating them to the rest of the network. Therefore,
    they’re considered consumers.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整节点*—它们主要验证从邻近对等体接收到的区块的有效性，并将其传播到网络的其余部分。因此，它们被认为是消费者。'
- en: Mining nodes run on clients optimized for processing transactions, generating
    blocks, and executing the Proof of Work algorithm efficiently, to get rewarded
    relatively frequently. Mining implementations, such as *ethminer*, have been written
    in C++ and use GPU libraries such as NVIDIA’s CUDA. Consequently, they run on
    GPU hardware that can deliver superior performance.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 挖矿节点运行在优化处理交易、生成区块和有效执行工作量证明算法的客户端上，以相对频繁地获得奖励。像*ethminer*这样的挖矿实现已经用C++编写，并使用NVIDIA的CUDA等GPU库。因此，它们在能够提供卓越性能的GPU硬件上运行。
- en: On the other hand, full nodes don’t have performance requirements, so standard
    clients have been implemented in various languages. [Table 3.5](#ch03table05)
    summarizes the main client implementations available to date, ordered by popularity,
    as reported in Ethernodes ([https://ethernodes.org/network/1](https://ethernodes.org/network/1)).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，完整节点没有性能要求，因此已经用各种语言实现了标准客户端。[表3.5](#ch03table05)总结了至今可用的主要客户端实现，按流行度排序，如Ethernodes([https://ethernodes.org/network/1](https://ethernodes.org/network/1))所报告的。
- en: Table 3.5\. Ethereum client implementations by language
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Table 3.5. 以太坊客户端实现语言表
- en: '| Client | Language |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 语言 |'
- en: '| --- | --- |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Go Ethereum (geth) | Go |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| Go Ethereum (geth) | Go |'
- en: '| Parity | Rust |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '| Parity | Rust |'
- en: '| Cpp-ethereum (eth) | C++ |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| Cpp-ethereum (eth) | C++ |'
- en: '| Ethereum(J) | Java |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| 以太坊(J) | Java |'
- en: '| Pyethapp | Python |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| Pyethapp | Python |'
- en: '| ethereumjs-lib | JavaScript |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| ethereumjs-lib | JavaScript |'
- en: '| ruby-ethereum | Ruby |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| Ruby以太坊 | Ruby |'
- en: '| ethereumH | Haskell |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| 以太坊客户端 | 编程语言 |'
- en: Each client comes with a console, and some of them also include a graphical
    browser or a wallet. While working with this book, you’ll use Go Ethereum, also
    known as geth, which is the most popular client, installed on over 70% of the
    network nodes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端都带有控制台，其中一些还包括图形浏览器或钱包。在本书中，你将使用Go Ethereum，也被称为geth，这是最受欢迎的客户端，安装在超过70%的网络节点上。
- en: 3.3.1\. Getting started with geth
  id: totrans-805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1. 使用geth开始
- en: 'The download page for the Go Ethereum website, [https://ethereum.github.io/go-ethereum/downloads/](https://ethereum.github.io/go-ethereum/downloads/),
    shows releases for all major operating systems: Android, iOS, Linux, MacOS, and
    Windows. Various installation formats are available for some of the supported
    operating systems. For example, for Windows, you can choose between the 32- and
    64-bit version and whether to download only the executable (Archive option) or
    the full installer (Installer option). I’ve picked the 64-bit Geth & Tools 1.8.13
    archive.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: Go Ethereum网站的下载页面[https://ethereum.github.io/go-ethereum/downloads/](https://ethereum.github.io/go-ethereum/downloads/)显示了所有主要操作系统的版本：Android、iOS、Linux、MacOS和Windows。对于一些受支持的操作系统，可用的安装格式各不相同。例如，对于Windows，你可以选择32位和64位版本，以及是否仅下载可执行文件（归档选项）或完整的安装程序（安装程序选项）。我选择了64位的Geth
    & Tools 1.8.13归档。
- en: Once you’ve installed or uncompressed the relevant file, you can run the geth
    executable. If you have the Ethereum wallet open, close it before starting geth,
    because they use the same port number! If you run geth with no parameters, it’ll
    start to synchronize in Full mode with the public production network, also known
    as MAINNET, as shown in the screenshot in [figure 3.11](#ch03fig11).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装或解压了相关文件，就可以运行geth可执行文件。如果你已经打开了以太坊钱包，在启动geth之前关闭它，因为它们使用相同的端口号！如果你没有参数运行geth，它将以完整模式与公共生产网络，也称为MAINNET同步，如[图3.11](#ch03fig11)所示的屏幕截图。
- en: Figure 3.11\. geth synchronizing with the MAINNET network at startup
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11. geth在启动时与MAINNET网络同步
- en: '![](Images/fig03-11_alt.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-11_alt.jpg)'
- en: After geth has synchronized the full blockchain (this could take from hours
    to days, depending on your hardware and internet connection), the console will
    start to slow down and show blocks being added to the blockchain in real time.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在geth同步完整区块链（这可能需要数小时至数天，具体取决于您的硬件和互联网连接速度）之后，控制台将开始减慢速度，并实时显示区块添加到区块链。
- en: '|  |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As for the wallet, you can synchronize geth in Light or Fast mode—for example,
    `C:\program files\geth>geth –-syncmode "light"`—if you prefer to get up and running
    more quickly (in minutes as opposed to hours or even days) and don’t mind not
    having downloaded the full blockchain locally.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 关于钱包，你可以以轻量级或快速模式同步geth——例如，`C:\program files\geth>geth –-syncmode "light"`——如果你希望更快地启动（几分钟而不是几小时或甚至几天），并且不介意没有在本地下载完整区块链。
- en: '|  |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can interact with geth in two ways:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以两种方式与geth交互：
- en: Through the user-friendly geth interactive JavaScript console
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用户友好的geth交互式JavaScript控制台
- en: Through low-level JSON-RPC calls over HTTP
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过低级别的基于HTTP的JSON-RPC调用
- en: 'I’ll present both techniques to you. Let’s start with the simpler tool: the
    interactive JavaScript console.'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示这两种技术。让我们从更简单的工具开始：交互式JavaScript控制台。
- en: 3.3.2\. A first look at the geth interactive console
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2. geth交互式控制台的第一印象
- en: geth comes with an interactive console that accepts JavaScript instructions.
    It implicitly references Web3.js, a JavaScript implementation of Web3, the official
    high-level library for interacting with Ethereum clients. This console is similar
    in purpose to read-eval-print loop (REPL) consoles for programming language IDEs.
    I’ll cover Web3 extensively in the next few chapters. For the moment, let’s get
    a quick feel for it.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: geth带有一个接受JavaScript指令的交互式控制台。它隐式引用Web3.js，这是Web3的JavaScript实现，是用于与Ethereum客户端交互的官方高级库。这个控制台在目的上类似于编程语言IDE的read-eval-print循环（REPL）控制台。我将在接下来的几章中详细介绍Web3。现在，让我们快速了解一下。
- en: 'First, open the interactive console. You’ve got two possible ways to start
    it up:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开交互式控制台。您有两种可能的启动方式：
- en: 'If no geth clients are running on the same machine, run the geth executable
    with the console command:'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在同一台机器上没有运行任何geth客户端，使用console命令运行geth可执行文件：
- en: '[PRE2]'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If a geth client is already running on the machine, attach to a running geth
    process with the attach command:'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器上已经运行了一个geth客户端，使用attach命令附加到运行中的geth进程：
- en: '[PRE3]'
  id: totrans-825
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You have a running geth process, so you’ll go for the second option.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个正在运行的geth进程，所以你会选择第二个选项。
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, I’m assuming you use Windows, as over 60% of the nodes of the
    Ethereum network run on this operating system. Consequently, I’ll show shell commands
    with a Windows command prompt format. Also note that after successful execution
    of instructions in the console, you might see *undefined* right before or after
    the correct results. You can ignore it.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我假设你使用Windows，因为超过60%的Ethereum网络节点运行在这个操作系统上。因此，我将展示带有Windows命令提示符格式的shell命令。还要注意，在控制台成功执行指令后，你可能会在正确结果的前后看到*undefined*。你可以忽略它。
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Displaying version information
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示版本信息
- en: First of all, you can query the console for version information. A Web3 object
    named web3 is implicitly instantiated when opening the console, so you can access
    version information in this way by typing
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以向console查询版本信息。当打开console时，会隐式实例化一个名为web3的Web3对象，因此你可以通过输入
- en: '[PRE4]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and you’ll see something like
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会看到类似的内容
- en: '[PRE5]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the version property is an object that contains many subproperties.
    If you want, you can be specific and query an individual property of the version
    object:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，version属性是一个包含许多子属性的对象。如果你愿意，你可以具体查询version对象的个别属性：
- en: '[PRE6]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and you’ll see something like
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的内容
- en: '[PRE7]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because the console accepts JavaScript instructions, it’s possible to assign
    the values of Web3 properties and subproperties to variables and then display
    them through the console object:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 因为控制台接受JavaScript指令，所以可以将为Web3属性和子属性的值分配给变量，然后通过console对象显示它们：
- en: '[PRE8]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Checking connectivity
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查连通性
- en: You can get some client connectivity information from the web3.net object. (You
    can omit the web3 namespace because it’s implicitly referenced.) If you type
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从web3.net对象获取一些客户端连通性信息。（你可以省略web3命名空间，因为它隐式引用。）如果你输入
- en: '[PRE9]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: you’ll see something like
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的内容
- en: '[PRE10]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As for the version object, you can directly access individual properties of
    the net object as follows:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 至于版本对象，你可以直接访问net对象的个人属性，如下所示：
- en: '[PRE11]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to get more detailed information about your node, you can use the
    web3.admin object and call
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取关于你的节点更详细的信息，你可以使用web3.admin对象并调用：
- en: '[PRE12]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and you’ll see something like
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的结果：
- en: '[PRE13]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `peers` property gives you detailed information about the peers you’re
    connected to:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers`属性为你提供了关于你连接到的对等节点的详细信息：'
- en: '[PRE14]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: will yield something like
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生类似的结果：
- en: '[PRE15]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Accessing the blockchain
  id: totrans-857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问区块链
- en: The `web3.eth` object retrieves real-time information about the client and the
    blockchain. Look at the console of the geth process currently running. You should
    see how new blocks are getting appended to the blockchain in real time. Take note
    of the block number of a recently appended block, and then switch back to the
    JavaScript console.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.eth`对象检索有关客户端和区块链的实时信息。看看当前运行的geth进程的控制台。你应该看到新块如何实时地附加到区块链上。注意最近附加的块的区块号码，然后切换回JavaScript控制台。'
- en: 'You can get the most recent block number through the `eth.blockNumber` property:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`eth.blockNumber`属性获取最新的区块号码：
- en: '[PRE16]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then you can display summary information about this block by calling
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过调用显示关于这个区块的摘要信息：
- en: '[PRE17]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: and you’ll see something like
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的结果：
- en: '[PRE18]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You also can drill down at transaction level. You can get the first transaction
    stored in the latest block in this way:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以深入到交易级别。你可以这样获取存储在最新区块中的第一个交易：
- en: '[PRE19]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll see something like
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的结果：
- en: '[PRE20]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I encourage you to have a look at the content of the whole `eth` object:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看整个`eth`对象的内容：
- en: '[PRE21]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Performing Ether conversions
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行以太币转换
- en: 'The Web3 API offers some useful functions to convert any Ether denomination
    from/to Wei. You can convert a Wei amount to a specific denomination:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: Web3 API提供了一些有用的函数，将任何以太坊货币单位从/转换为Wei。你可以将Wei金额转换为特定的货币单位：
- en: '[PRE22]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And you can convert a specific denomination into Wei:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你可以将特定的货币单位转换为Wei：
- en: '[PRE23]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 3.3.3\. A first look at JSON-RPC
  id: totrans-876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3. JSON-RPC的第一次亮相
- en: Now that you’ve learned the basics of the JavaScript console, you can try to
    interact with geth by performing a few JSON-RPC calls. geth offers a remote procedure
    call (RPC) interface that allows you to access node functionality and blockchain
    data to a much finer degree of control than that offered by the Web3 API. In fact,
    Web3 is built on top of the RPC layer, which is the lowest level API exposed by
    the Ethereum platform, as shown in [figure 3.12](#ch03fig12).
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了JavaScript控制台的基础知识，你可以尝试通过执行几个JSON-RPC调用与geth交互。geth提供了一个远程过程调用（RPC）接口，允许你访问节点的功能和区块链数据，比Web3
    API提供的控制程度要细。实际上，Web3是建立在RPC层之上的，这是以太坊平台暴露的最低级别的API，如图3.12所示。
- en: Figure 3.12\. Comparison between accessing geth through Web3.js and JSON-RPC
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12. 通过Web3.js和JSON-RPC访问geth的比较
- en: '![](Images/fig03-12_alt.jpg)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-12_alt.jpg)'
- en: The RPC interface has been designed against the JSON-RPC 2.0 standard, and consequently
    it sends and receives data in JSON format. You can find more information on JSON-RPC
    in the sidebar.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: RPC接口是根据JSON-RPC 2.0标准设计的，因此它以JSON格式发送和接收数据。你可以在侧边栏找到更多关于JSON-RPC的信息。
- en: 'If you want to communicate with geth directly through JSON-RPC, you have to
    do two things:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接通过JSON-RPC与geth通信，你必须做两件事：
- en: Stop any instance of geth running in a standard operating system command shell
    or in a geth console.
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止任何在标准操作系统命令行或geth控制台中运行的geth实例。
- en: 'Start geth in RPC mode using the `--rpc` and `--rpcapi` options:'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--rpc`和`--rpcapi`选项以RPC模式启动geth：
- en: '[PRE24]'
  id: totrans-884
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you launch geth in RPC mode, it’s accessible through an HTTP server that
    accepts HTTP requests, by default on
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以RPC模式启动geth时，它可以通过一个HTTP服务器来访问，该服务器接受HTTP请求，默认情况下在：
- en: '[PRE25]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**JSON-RPC**'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON-RPC**'
- en: JSON-RPC is a lightweight remote procedure call that uses JSON as a data format.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC是一种轻量级的远程过程调用，使用JSON作为数据格式。
- en: You invoke an RPC call by sending a request object to a server, typically over
    HTTP, or in any other way, such as socket or even messaging, because the transport
    layer isn’t part of the protocol.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过向服务器发送一个请求对象来调用RPC，通常是通过HTTP，或者以其他方式，如套接字甚至是消息传递，因为传输层不是协议的一部分。
- en: 'The request object must contain the following members:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象必须包含以下成员：
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonrpc`—这设置了协议版本，目前为2.0。'
- en: '`method`—Name of the remote procedure to be called.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`—要调用的远程过程的名称。'
- en: '`params`—Array with procedure parameters.'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`—包含过程参数的数组。'
- en: '`id`—A call identifier, typically a string or integer. It must be not null.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—一个调用标识符，通常是一个字符串或整数。它必须不为空。'
- en: 'After the server processes the call, it replies with a response object, which
    contains the following members:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器处理调用后，会回复一个响应对象，其中包含以下成员：
- en: '`jsonrpc`—This sets the protocol version, currently 2.0.'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonrpc`—这设置了协议版本，目前为2.0。'
- en: '`result`—This field is present if the response is successful; it isn’t included
    if errors occur.'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`—如果响应成功，此字段存在；如果出现错误，则不包括。'
- en: '`error`—This field is present if errors occur; it isn’t included if the response
    is successful.'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`—如果出现错误，此字段存在；如果响应成功，则不包括。'
- en: '`id`—Same as specified in the request.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—与请求中指定的相同。'
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll perform JSON-RPC calls to geth’s HTTP server using the cURL console command.
    To help you appreciate the differences between the Web3 API and the JSON-RPC API,
    I’ll show you how to execute in cURL the same operations you performed in Web3
    through the interactive console.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用 cURL 控制台命令对 geth 的 HTTP 服务器执行 JSON-RPC 调用。为了让你了解 Web3 API 与 JSON-RPC API
    之间的差异，我将展示如何通过 cURL 执行你在 Web3 交互式控制台中执行的相同操作。
- en: '|  |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: cURL is available in most operating systems, including Windows (version 7 and
    10) and Linux. Alternatively, you can either download from the internet an open
    source version of cURL or perform HTTP requests through a graphical tool such
    as Postman, if you prefer.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: cURL 可以在包括 Windows（版本7和10）和 Linux 在内的多数操作系统中使用。另外，如果你更喜欢，你可以从互联网上下载 cURL 的开源版本，或者通过图形工具（如
    Postman）执行 HTTP 请求。
- en: '|  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Displaying version information
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示版本信息
- en: 'You can retrieve version information about the geth client with this call:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个调用获取关于 geth 客户端的版本信息：
- en: '[PRE26]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: (If you’re using Windows, you must escape JSON double quotes, as explained in
    the sidebar.) The result is equivalent to what you got from `web3.version.node`.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你在 Windows 上使用，你必须转义 JSON 中的双引号，如边栏中所解释。）结果等价于你从 `web3.version.node` 得到的结果。
- en: '|  |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**cURL JSON escaping on Windows**'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows上的cURL JSON转义**'
- en: 'cURL operations must escape the double-quote symbol " with \" in the JSON POST
    data, in certain versions of Windows. For example, in a command shell in Windows,
    you perform the request this way:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: cURL 操作必须在 JSON POST 数据中转义双引号符号 "，在 Windows 的某些版本中。例如，在 Windows 的命令提示符中，你这样执行请求：
- en: '[PRE27]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And in Linux:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 Linux 中：
- en: '[PRE28]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Checking client connectivity
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查客户端连通性
- en: 'You can get connectivity information by performing several calls. For instance,
    to check whether the client is actively listening for network connection, you
    must execute this request:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行几个调用来获取连通性信息。例如，要检查客户端是否正在积极监听网络连接，你必须执行这个请求：
- en: '[PRE29]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And you’ll get
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会得到
- en: '[PRE30]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result is equivalent to `web3.net.listening`.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 结果等价于 `web3.net.listening`。
- en: 'To get the number of peers connected to the client, you must execute this call:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取与客户端连接的节点数量，你必须执行这个调用：
- en: '[PRE31]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And you’ll get
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会得到
- en: '[PRE32]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result, which contains numbers encoded in hexadecimal format, as explained
    in the sidebar, is equivalent to `web3.net.peerCount`.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，其中包含以十六进制格式编码的数字，如边栏中所解释，等价于 `web3.net.peerCount`。
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Numbers through JSON-RPC**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过 JSON-RPC 的数字**'
- en: Ethereum’s JSON-RPC interface handles numbers differently than the official
    JSON-RPC 2.0 specification does. Numbers sent and returned through JSON-RPC must
    be encoded in hexadecimal format. Doing so makes sure each client implementation
    parses and processes large numbers appropriately, independent of the support for
    large numbers that the underlying language in which the client has been coded
    provides.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的 JSON-RPC 接口处理数字的方式与官方 JSON-RPC 2.0 规范不同。通过 JSON-RPC 发送和返回的数字必须以十六进制格式编码。这样做可以确保每个客户端实现适当地解析和处理大数字，而不依赖于客户端编写语言对大数字的支持。
- en: 'Hexadecimal encoding should include a 0x prefix and at least one valid digit
    with no leading zeros, as shown here:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制编码应包括 0x 前缀，至少有一个有效数字，没有前导零，如所示：
- en: '[PRE33]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** **This is equivalent to 1234 in decimal.**'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这等同于十进制的1234。**'
- en: 'Here are some examples of how numbers should be encoded into hexadecimal format:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些数字应该编码为十六进制格式的例子：
- en: '| Decimal format | Hexadecimal format |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| 十进制格式 | 十六进制格式 |'
- en: '| --- | --- |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0x0 |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0x0 |'
- en: '| 9 | 0x9 |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 0x9 |'
- en: '| 1234 | 0x4d2 |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| 1234 | 0x4d2 |'
- en: 'And here are some examples of incorrectly encoded numbers:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些错误编码数字的例子：
- en: '| Incorrect hex encoding | Reason |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| 错误的十六进制编码 | 原因 |'
- en: '| --- | --- |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0x | No digit has been specified after the 0x prefix. |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
- en: '| 42d | No 0x prefix has been specified. |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
- en: '| 0x042d | Leading 0 digits aren’t allowed. |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
- en: Accessing the blockchain
  id: totrans-948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get the latest blockchain block number this way:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And you’ll get
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you have the latest block number, you can inspect it by calling (replacing
    the block number in `params` with the one from your `result`):'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And you’ll get
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then you can inspect the first transaction of the block you retrieved in a
    way equivalent to how you did in Web3 through the interactive console (again,
    putting the block number you got in `results` into `params`):'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And you’ll get
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result object is similar to that returned by the Web3 `eth.getTransactionFromBlock`
    call.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, you’ll be interacting with geth mainly through Web3.js,
    but occasionally I’ll show you how to perform equivalent operations in JSON-RPC.
    If you’re interested in learning more about the JSON-RPC API, consult its wiki
    at [https://github.com/ethereum/wiki/wiki/JSON-RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4\. Mining with the geth console
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t consider a section on Ethereum clients to be complete before at least
    mentioning how to perform mining through a client. You already performed some
    mining through the Ethereum wallet at the beginning of this chapter, to load your
    test accounts with Ether.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, performing operations through the wallet hides what happens
    under the hood. For example, have you asked yourself why the Ether you mined got
    assigned to account1? That happened because the *etherbase* account, which is
    the account associated with the miner thread, is set by default to `eth.accounts[0]`.
    But after restarting geth and reopening the geth console in attach mode, as you
    did previously (in case you shut it down), you can reconfigure the etherbase account
    to `eth.accounts[1]`, if you prefer, through the implicitly instantiated `miner`
    object, as follows:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Regardless of whether your etherbase account is `eth.accounts[0]` or you’ve
    reconfigured it to `eth.accounts[1]`, you can start mining as follows:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point, the CPU of your machine will go to nearly 100%. Then you can
    stop mining:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the unlikely event you’ve mined some Ether, this will now be assigned to
    your `eth.accounts[1]`, or to `eth.accounts[0]` if you decided not to reconfigure
    it.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: 'When you kicked off mining on the geth interactive window with `miner.start()`,
    you might have noticed output similar to the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You might wonder what DAG is and why it takes such a long time to compute. DAG
    stands for directed acyclic graph, and it’s the data structure underlying *Ethash*,
    the Proof of Work (PoW) algorithm for mining on the Ethereum platform. DAG requires
    a relatively high amount of memory, so Ethash is considered a memory-intensive
    PoW algorithm. It consequently discourages mining through application-specific
    integrated circuit (ASIC) hardware, which is effective only for CPU-intensive
    PoW algorithms, such as the one used on the Bitcoin network. The Ethash algorithm
    encourages mining instead through commodity hardware, such as a GPU chipset (explained
    more in sidebar).
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道DAG是什么，以及为什么计算它需要这么长时间。DAG代表有向无环图，它是构成*Ethash*的数据结构，Ethash是Ethereum平台上的工作量证明（PoW）挖矿算法。DAG需要相对较多的内存，因此Ethash被认为是内存密集型的PoW算法。它进而鼓励通过通用硬件进行挖矿，比如GPU芯片集（在边栏中解释更多）。
- en: Mining is a specialized topic outside the scope of this book. If you’re interested
    in learning more about Ethash, I encourage you to consult the official notes at
    [http://mng.bz/WaOw](http://mng.bz/WaOw).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 挖矿是一个专业性很强的主题，超出了本书的范围。如果你对Ethash更感兴趣，我鼓励你查阅官方笔记，地址为[http://mng.bz/WaOw](http://mng.bz/WaOw)。
- en: Now that you’ve experienced mining firsthand, you might ask yourself what happens
    if you have the luck to append a new block to the blockchain, get the related
    Ether reward in your etherbase account, and then decide to quit your mining activity
    by shutting down your node. Would the block you’ve created and appended to the
    blockchain still be valid, even if you’ve disappeared from the network? Would
    the transactions included in the block still be valid? Would you still be able
    to transfer the Ether in your etherbase account to another account?
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经亲身体验了挖矿，你可能要问自己，如果你有幸将一个新区块添加到区块链上，在您的etherbase账户中获得相关的以太币奖励，然后决定通过关闭节点来退出您的挖矿活动，会发生什么。您创建并添加到区块链上的区块是否仍然有效，即使您已经从网络上消失了呢？区块中包含的交易是否仍然有效？您是否仍然能够将您etherbase账户中的以太币转移到另一个账户？
- en: The answer to all these questions is yes. Remember that the blockchain validation
    process, performed continuously by all active full nodes, only cares about the
    cryptographic consistency between a block hash and the public address of the miner
    who has generated the block, in the same way it cares about the consistency between
    a transaction hash and the public address of the account that has generated it.
    So whether the node that created a new block is active or inactive is as irrelevant
    to the block (and transaction) history as whether your computer is on or off after
    having transferred some Ether from an account of your desktop Ethereum wallet
    to another account.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这些问题，答案都是肯定的。记住，区块链验证过程，由所有活跃的全节点持续执行，只关心一个区块散列和生成该区块的矿工的公钥地址之间的加密一致性，正如它关心一个交易散列和生成该交易账户的公钥地址之间的一致性一样。所以，一个创建新区块的节点是活跃还是不活跃，对于区块（和交易）历史来说，就像你在将一些以太币从你的桌面以太坊钱包的一个账户转移到另一个账户之后，你的电脑是开还是关一样无关紧要。
- en: '|  |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**GPU mining**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**GPU 挖矿**'
- en: If you want to try your luck and hope to get rich by generating Ether on the
    public production network with CPU mining, as you’ve done so far in the test network,
    I hate to break the news, but you’re more likely to get rich by winning the lottery.
    As you saw in [chapter 1](kindle_split_012.xhtml#ch01), the execution of the PoW
    algorithm is successful only if the hash obtained combining the block information
    and a nonce has certain characteristics—for example, a high number of leading
    zeros. PoW algorithms are designed so that you must try millions of nonce values
    before hitting the lucky one that generates a valid hash. Consequently, mining
    successfully means being able to generate more hashes per second than other miners.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试运气，希望通过CPU挖矿在公共生产网络上生成以太币，就像你在测试网络上所做的那样，我不得不告诉你，你通过中彩票致富的可能性更大。正如你在第[1](kindle_split_012.xhtml#ch01)章所见，PoW算法的执行只有在组合了区块信息和随机数（nonce）后获得的散列具有某些特性时才是成功的——例如，前面有大量零。PoW算法设计得如此复杂，以至于你必须尝试数百万个nonce值，才能找到那个幸运值，生成有效的散列。因此，成功挖矿意味着能够比其他矿工每秒生成更多的散列。
- en: With the best CPU chipset, you’ll be able to generate at most 1 megahash per
    second (Mh/s), where megahash means one million hashes. With good GPU chipsets,
    you might be able to generate up to 30 Mh/s—nearly 30 times the hashing capability
    of a standard CPU. Also consider that mining pools, which are organizations that
    pool various GPU miners together so they can share resources and rewards, can
    generate up to 30 Th/s (30 trillion hashes per second), which means up to 30 million
    times what a CPU is able to generate during the same time. Finally, consider that
    in the Ethereum space, around 40 mining pools have a hash rate ranging between
    30 Gh/s and 30 Th/s.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有最佳的 CPU 芯片组，你将能够最多生成 1 兆哈希每秒（Mh/s），其中兆哈希意味着一百万个哈希值。拥有良好的 GPU 芯片组，你可能会能够生成高达
    30 Mh/s——几乎是标准 CPU 哈希能力的 30 倍。同时考虑挖矿池，这是一种组织，将各种 GPU 矿工聚集在一起，共享资源和奖励，它们能够生成高达
    30 Th/s（每秒 30 万亿个哈希值），这意味着在相同时间内，CPU 能够生成的哈希值的 3000 万倍。最后，在以太坊领域，大约有 40 个挖矿池的哈希率在
    30 Gh/s 到 30 Th/s 之间。
- en: 'Now you can understand why your chances of generating Ether using a CPU alone
    are slim. You might find this stark reality disappointing, and you might even
    think that the huge influence of mining pools on the mining process might bring
    into question Ethereum’s credibility, as far as decentralization is concerned.
    Many Ethereum participants believe that as long as many mining pools are competing,
    decentralization should be guaranteed. Also consider that the new consensus algorithm
    being implemented, Stake of Work, introduced in the previous chapter, might change
    completely how power is concentrated (or hopefully spread) in the Ethereum network.
    Here’s a quick summary of the hash rate that different hardware can achieve:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以理解为什么仅使用 CPU 生成以太币的几率很小。你可能会对这一严酷的现实感到失望，甚至可能会认为挖矿池在挖矿过程中的巨大影响可能会对以太坊的去中心化信誉带来疑问。许多以太坊参与者认为，只要许多挖矿池相互竞争，去中心化就应得到保证。同时考虑正在实施的新共识算法——工作量证明（Stake
    of Work），在前一章中介绍，可能会完全改变以太坊网络中权力的集中（或希望分散）方式。以下是不同硬件可以达到的哈希率的快速摘要：
- en: '| Hardware | Hashrate |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| 硬件 | 哈希率 |'
- en: '| --- | --- |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Single CPU | 1 Mh/s |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '| 单核 CPU | 1 Mh/s |'
- en: '| Single GPU | 30 Mh/s |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '| 单 GPU | 30 Mh/s |'
- en: '| GPU rig (10xGPUs) | 300 Mh/s |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '| GPU 挖矿机 (10个GPU) | 300 Mh/s |'
- en: '| Mining pool | 30,000,000 Mh/s |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
  zh: '| 挖矿池 | 30,000,000 Mh/s |'
- en: '|  |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3.5\. Other clients
  id: totrans-990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.5 其他客户端
- en: 'Although Go Ethereum is the most popular client, other implementations offer
    various benefits with respect to geth:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go Ethereum 是最受欢迎的客户端，但其他实现（相对于 geth）在各种方面提供了不同的好处：
- en: '*Parity*, written in Rust, is the second most popular Ethereum client, and
    it’s regarded as the fastest, lightest, and most secure implementation. It comes
    with a console and a built-in wallet.'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parity** 是用 Rust 编写的第二大受欢迎的以太坊客户端，被认为是最快、最轻、最安全的实现。它带有控制台和内置钱包。'
- en: '*cpp-ethereum*, written in C++ and known as *eth*, is another fast implementation,
    third in popularity, and well regarded for its portability. *Ethminer*, a specialized
    mining client, is a fork from cpp-ethereum.'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cpp-ethereum** 是用 C++ 编写的，被称为 **eth**，是另一种快速的实现，受欢迎程度排名第三，因其便携性而受到好评。**Ethminer**
    是一个专门的挖矿客户端，是 cpp-ethereum 的一个分叉。'
- en: '*pyethapp*, written in Python, is built on two core components: *pyethereum*
    provides EVM, blockchain, and mining functionality, whereas *pydevp2p* supports
    access to the P2P network and node discovery mechanisms. Python developers especially
    appreciate this implementation for its extensibility.'
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pyethapp** 是由 Python 编写而成的，它基于两个核心组件：**pyethereum** 为用户提供以太坊虚拟机、区块链和挖矿功能，而
    **pydevp2p** 支持对 P2P 网络的访问和节点发现机制。Python 开发者特别欣赏这一实现，因为其扩展性非常好。'
- en: You’ve learned about various components and tools of the Ethereum platform.
    Before leaving this chapter, you’ll reinforce your understanding of accounts,
    a key concept you must get familiar with to work effectively with Ethereum.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前，你将加深对账户的理解，这是你必须熟悉才能有效地与以太坊工作的关键概念。
- en: 3.4\. Managing accounts with geth
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4 使用 geth 管理账户
- en: At the beginning of this chapter, while covering smart contracts, I touched
    briefly on accounts. I also helped you create some accounts through the Ethereum
    wallet UI so you could use them to transfer some Ether around. Armed with the
    geth console, you can now deepen your knowledge of accounts by creating them and
    interacting with them programmatically.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1\. Ethereum accounts
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you know, the Ethereum platform supports two types of accounts:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '*Externally owned accounts (EOAs)*—These impersonate end users, as well as
    miners and autonomous agents.'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contract accounts*—These impersonate contracts.'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll deal only with EOAs, which I’ll call *accounts*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: As with most blockchain systems, the security of the Ethereum platform is based
    on public key cryptography. An account is therefore identified by a private/public
    key pair. The account’s address is represented by the last 20 bytes of the public
    key.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: 'The private/public key pair associated with an account is stored in a text
    *keyfile*. The public key is visible in plain text, whereas the private key is
    encrypted with the password introduced at account creation. Account keyfiles are
    in the *keystore* folder within the Ethereum node’s data directory:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: C:\Users\username\%appdata%\Roaming\Ethereum\keystore'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum/keystore'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum/keystore'
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s strongly recommended that you back up the keystore folder on a regular
    basis and keep a copy of the passwords you’ve introduced when creating each account
    in a secure place. Sorry if I keep pestering you with this, but if you haven't
    noticed, I do want to make a point of how sensitive key and password details are
    in the blockchain world!
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
- en: '**Account portability**'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use an account that you’ve created on the public production network
    on a test network, for example Ropsten, and vice versa. This is because the keystore
    of each network is different and is located in a separate folder within the Ethereum
    folder:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: 'Main prod network keystore: ~/.ethereum/keystore'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rinkeby test network keystore: ~/.ethereum/rinkeby/keystore'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ropsten test network keystore: ~/.ethereum/testnet/keystore'
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
- en: 'You can create accounts and interact with them through four different avenues:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum wallet, as you saw earlier in this chapter
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geth commands
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web3 on the geth console
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-RPC calls
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve already seen how to manage accounts with the Ethereum wallet. In the
    next several sections, you’ll manage accounts through geth commands and the geth
    console. You’ll also get a quick feel for how to perform some operations on accounts
    through the JSON-RPC API.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2\. Managing accounts with the geth command
  id: totrans-1025
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can manage an account easily through your operating system console by entering
    specific geth commands from the directory of the geth executable (or from any
    directory if geth is in your PATH global variable).
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can create a new account manually or using a plain text file:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Manual creation
  id: totrans-1029
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new account, enter
  id: totrans-1030
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You’ll be prompted to enter a password twice, and then you’ll be shown the
    address of the account you created:'
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-1034
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Tip
  id: totrans-1035
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: Get into the habit of choosing strong passwords or generating them through a
    strong password generator. I’m repeating myself; I know, I know! But this is important,
    believe me!
  id: totrans-1036
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1037
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Text file creation
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid having to enter the password manually, you can store it in plain text
    in a text file.
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the geth account command as follows:'
  id: totrans-1040
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1041
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you can understand, although placing a password in a plaintext file might
    be acceptable in a test environment, this way of creating an account might pose
    much greater risks in a production environment, where you must make sure access
    to the password file is tightly restricted.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
- en: Listing accounts
  id: totrans-1046
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once you’ve created an account, you can verify it’s indeed present in your
    node by executing the following command:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You’ll see the accounts you created through the geth account command and the
    geth console:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Updating accounts
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After geth creates and saves an account in a keyfile in the keystore folder,
    a subsequent geth release might implement a new keyfile format. In that case,
    it becomes necessary to update the account. Another reason you might want to update
    an account is because you want to change the password.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update account 47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1 you created
    earlier with the following geth command (obviously replace with your account number):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You’ll be prompted to enter the existing password, to unlock the account, and
    subsequently a new password, which you’ll have to type twice, as usual. You’ll
    then be shown the new address of the account:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The geth account update command offers the same `--password` option that the
    geth account new command provides. But in this case you can also use it to unlock
    the account for the purpose of converting it into a new keyfile format.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3\. Managing accounts with Web3 on the geth console
  id: totrans-1058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s repeat some of the earlier account management operations through the interactive
    console.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Go back to the interactive geth console. You can create accounts using the
    `web3.personal` object:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As for the geth account command, you’ll be asked to enter a password twice,
    and then you’ll be shown the account address:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Listing accounts
  id: totrans-1065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can list accounts with the interactive console by displaying the value
    of the `account` property of the `web3.eth` object. You’ll get the same result
    set you obtained with the geth account list command:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: will yield something like
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You also can directly reference a specific account of the `eth.accounts` array:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will yield something like
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Checking an account’s Ether balance
  id: totrans-1074
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can check the amount of Ether stored in an account using the following
    call, which returns it in Wei:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then you can convert it to Ether as usual:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Transferring Ether between accounts
  id: totrans-1079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can try transferring 0.0025 Ether from `accounts[1]` to `accounts[2]`.
    First of all, check the current balances of these accounts, as you saw earlier:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试从`accounts[1]`向`accounts[2]`转账0.0025以太币。首先，检查一下这两个账户当前的余额，就像你之前看到的那样：
- en: '[PRE59]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before transferring Ether from a certain account, for example `accounts[1]`,
    you must unlock it:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 在从某个账户，例如`accounts[1]`，转账以太币之前，你必须解锁它：
- en: '[PRE60]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As usual, you’ll be asked to enter the password associated with this account:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，系统会要求你输入与这个账户关联的密码：
- en: '[PRE61]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, you can transfer Ether between accounts with the web3.eth.sendTransaction
    function, which takes an amount in Wei, as follows:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用web3.eth.sendTransaction函数在账户之间转账以太币，该函数需要以 Wei 为单位指定金额，如下所示：
- en: '[PRE62]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The value returned is the hash of the transaction sent.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值是发送的交易哈希。
- en: 'After a couple of minutes, recheck the balances:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，重新检查一下余额：
- en: '[PRE63]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the balance hasn’t been updated yet, it’s because the transaction hasn’t
    been mined yet.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 如果余额还没有更新，那是因为交易还没有被矿工挖出。
- en: 3.4.4\. Managing accounts with JSON-RPC
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4. 使用JSON-RPC管理账户
- en: 'I’ll give you a quick example of how to perform account management operations
    in JSON-RPC. Open a new OS shell and you can list your accounts with the following
    JSON-RPC call:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给你一个关于如何使用JSON-RPC执行账户管理操作的快速示例。打开一个新的操作系统终端，你可以使用以下JSON-RPC调用来列出你的账户：
- en: '[PRE64]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will yield something like
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到类似的结果：
- en: '[PRE65]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 3.5\. Revisiting SimpleCoin’s contract
  id: totrans-1097
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 重新审视SimpleCoin合约
- en: 'We’ve covered quite a lot of ground in this chapter. If you’ve followed me
    up to this point, congratulations: you’ve completed the introduction to Ethereum
    covering the Ethereum wallet and the Go Ethereum client. You’ve also started interacting
    with the platform in many ways—through the geth commands, through Web3 instructions
    on the geth interactive console, and through direct JSON-RPC requests.'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 在这章中我们已经覆盖了相当多的内容。如果你一直跟到现在，恭喜你：你已经完成了以太坊的入门，涵盖了以太坊钱包和Go Ethereum客户端。你也以许多方式开始与这个平台互动——通过geth命令，通过get
    Interactive console上的Web3指令，以及通过直接的JSON-RPC请求。
- en: It’s been an intense ride. I bet you’re eager to get back to some coding! Let’s
    revisit your initial implementation of SimpleCoin, the basic cryptocurrency I
    introduced at the end of [chapter 1](kindle_split_012.xhtml#ch01), and try to
    improve it.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一次紧张的旅程。我敢打赌你迫不及待想要回到编码中了！让我们重新审视一下你在[第1章](kindle_split_012.xhtml#ch01)末尾介绍的SimpleCoin，这个基础加密货币，并尝试改进它。
- en: 'Reenter the `SimpleCoin` code you saw in the previous chapter into Remix ([http://remix.ethereum.org](http://remix.ethereum.org)),
    as shown in the following listing. As usual, ignore warnings for the moment: they’ll
    disappear as you improve the code in the next chapters.'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 重新输入你在上一章看到的`SimpleCoin`代码到Remix中，如下所示列表。像往常一样，暂时忽略警告：随着你在接下来的章节中改进代码，它们会消失。
- en: Listing 3.1\. `SimpleCoin` contract as you left it in [chapter 1](kindle_split_012.xhtml#ch01)
  id: totrans-1101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1. `SimpleCoin`合约，就像你在[第1章](kindle_split_012.xhtml#ch01)中留下的那样
- en: '[PRE66]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code is rudimentary. Even if you don’t know the Solidity language yet,
    you can see a hardcoded value in the constructor and a lack of input validation
    in the `transfer` function. You can improve the code in several ways. First of
    all, you can parameterize the constructor so the initial money supply doesn’t
    get allocated to the address of an arbitrary test account, but to the address
    of the contract owner’s account. Then you can introduce some checks in the transfer
    function to prevent incorrect transfers. Finally, you can set things up so that
    when tokens get transferred, an event can be raised, and then clients of the smart
    contract can be notified or react to it.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很基础。即使你还不了解Solidity语言，你也可以看到构造函数中有一个硬编码的值和一个`transfer`函数中缺乏输入验证。你可以通过几种方式改进代码。首先，你可以参数化构造函数，这样初始货币供应就不会分配给任意测试账户的地址，而是分配给合约所有者账户的地址。然后，你可以在`transfer`函数中引入一些检查，以防止错误的转账。最后，你可以设置当代币被转账时触发一个事件，然后智能合约的客户端可以收到通知或对其作出反应。
- en: 3.5.1\. Improving SimpleCoin’s contract
  id: totrans-1104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 改进SimpleCoin合约
- en: You’ll improve both the constructor and the transfer function. You can start
    from the constructor.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将改进构造函数和`transfer`函数。你可以从构造函数开始着手。
- en: Parameterizing the constructor
  id: totrans-1106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数化构造函数
- en: 'Rewrite the constructor as follows:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 将构造函数重写如下：
- en: '[PRE67]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You’ve already come across the special property `msg.sender`, whose value is
    the address of the message sender (or function caller). When it comes to the constructor,
    the message sender is the account that instantiates the contract, which consequently
    becomes its owner. As a result, when the constructor gets called, the `amount`
    of tokens specified in the `_initialSupply` parameter gets allocated to the contract
    owner.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经遇到了特殊的属性`msg.sender`，其值是消息发送者的地址（或调用者）。当涉及到构造函数时，消息发送者是实例化合约的账户，从而成为其所有者。因此，当构造函数被调用时，`_initialSupply`参数中指定的代币数量将分配给合约所有者。
- en: Making transfers more robust
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使传输更加健壮
- en: Rewrite the transfer function as shown in the following listing.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递函数重写如下列表所示。
- en: Listing 3.2\. A more robust transfer function with checks on the input
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. 一个更健壮的传递函数，带有输入检查
- en: '[PRE68]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** **Checks that the sender account has an amount of coins equal to or
    larger than what you’re trying to transfer**'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查发送者账户是否有等于或大于您试图转移的代币数量**'
- en: '***2*** **Checks that an arithmetic overflow hasn’t been produced on the recipient’s
    balance during the transfer operation. (This can happen if the balance, because
    of the amount received from the sender, becomes bigger than uint256.)**'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查在传输操作期间接收者余额是否产生算术溢出。（如果余额因从发送者接收的金额而变得大于uint256，这种情况可能会发生。）**'
- en: The `require` special function throws an exception if the condition isn’t met.
    You can also throw the exception directly with the `throw` keyword, but this way
    of validating input is being deprecated. For example
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`特殊函数如果条件不满足就会抛出异常。您还可以直接使用`throw`关键字抛出异常，但这种验证输入的方式正在被弃用。例如'
- en: '[PRE69]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: could have been previously written as
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以先前写为
- en: '[PRE70]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Raising an event
  id: totrans-1120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引发事件
- en: 'A contract can declare one or more events that can be raised in any of its
    functions. A client that’s monitoring the state of a contract can handle an event.
    For instance, you can declare an event that notifies that a transfer of SimpleCoin
    tokens has taken place:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 合约可以声明一个或多个事件，可以在其任何函数中引发。监视合约状态的客户端可以处理一个事件。例如，您可以声明一个事件，通知SimpleCoin代币的转移已经发生：
- en: '[PRE71]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You’ll raise this event at the bottom of the transfer function:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在传输函数底部引发这个事件：
- en: '[PRE72]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 3.5.2\. Trying out the amended code
  id: totrans-1125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 尝试修改后的代码
- en: The amended `SimpleCoin` contract will now look like the following listing.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`SimpleCoin`合约现在将如下列表所示。
- en: Listing 3.3\. `SimpleCoin` with parameterized constructor, input validation,
    and event
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. `SimpleCoin`具有参数化构造函数、输入验证和事件
- en: '[PRE73]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Trying out the amended constructor
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试使用修改后的构造函数
- en: Reopen Remix if you closed it, and copy the code in [listing 3.3](#ch03ex03)
    into the editor. Then pick a test account address from the Transaction Origin
    drop-down list; for example, 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db. This
    will be the account executing the constructor, and it’ll consequently become the
    contract owner.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关闭了Remix，请重新打开它，并将[列表3.3](#ch03ex03)的代码复制到编辑器中。然后从交易源下拉列表中选择一个测试账户地址；例如，0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db。这将是要执行构造函数的账户，并且它将相应地成为合约所有者。
- en: Click the Run tab on the right panel. You can now enter the initial supply of
    SimpleCoin tokens next to the Deploy button, say 10,000, and then click Deploy.
    As usual, the coinBalance and transfer buttons will appear on the lower part of
    the screen, as in the previous chapter, as shown in the screenshot in [figure
    3.13](#ch03fig13).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧面板点击运行标签。现在您可以输入SimpleCoin代币的初始供应量，位于部署按钮旁边，比如10,000，然后点击部署。像往常一样，`coinBalance`和`transfer`按钮将出现在屏幕的下方部分，如前章所示，如图[3.13](#ch03fig13)所示。
- en: Figure 3.13\. The Deploy operation now accepts the constructor input. After
    you instantiate the contract by clicking Deploy, the CoinBalance and Transfer
    buttons appear.
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.13\. 部署操作现在接受构造函数输入。在点击部署实例化合约后，`CoinBalance`和`Transfer`按钮出现。
- en: '![](Images/fig03-13_alt.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-13_alt.jpg)'
- en: You can check the contract owner’s address balance in the coinBalance mapping.
    As expected, you’ll get 10,000\. You can also double-check that the balances of
    the other addresses are zero, as shown in [table 3.6](#ch03table06).
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`coinBalance`映射中检查合约拥有者的地址余额。如预期的那样，你会得到10,000。您还可以再次确认其他地址的余额为零，如[表3.6](#ch03table06)所示。
- en: Table 3.6\. The balances of the SimpleCoin accounts
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.6\. SimpleCoin账户的余额
- en: '| Account address | Account balance |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '| 账户地址 | 账户余额 |'
- en: '| --- | --- |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 10,000 |'
  id: totrans-1140
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 0 |'
  id: totrans-1142
  prefs: []
  type: TYPE_TB
- en: Trying out the amended transfer function
  id: totrans-1143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Try to transfer some SimpleCoin tokens from an account that doesn’t have any;
    for example, 0x583031d1113ad414f02576bd6afabfb302140225. Select this address from
    the Transaction Origin drop-down list and enter the following comma-delimited
    value into the transfer text box:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After clicking Transfer, you’ll get the following error message, thanks to
    the `require` check you added earlier:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now try to transfer 150 tokens from the contract owner’s account to the same
    recipient you just tried. You need to select the account starting with 0x4b0897b
    on the Transaction Origin drop-down list and reenter the following comma-delimited
    value into the transfer text box:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The operation will now be successful, as you can see in the output on the left
    side of the screen shown in [figure 3.14](#ch03fig14).
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14\. Output of successful transfer operation
  id: totrans-1151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig03-14_alt.jpg)'
  id: totrans-1152
  prefs: []
  type: TYPE_IMG
- en: 'If you click the arrow next to Debug, you can verify in the `logs` property
    that the Transfer event has been raised at the end of the function call:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: After rechecking all the balances, the results should match [table 3.7](#ch03table07).
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.7\. The new balances of the SimpleCoin accounts
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |'
  id: totrans-1160
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 9,850 |'
  id: totrans-1161
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |'
  id: totrans-1162
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 150 |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve completed this exercise. The improvements you’ve made
    weren’t particularly challenging, but making them should have helped you gain
    more familiarity with contracts.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3\. How does the coin transfer execute in the Ethereum network?
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might have understood the Solidity code that performs the coin transfer
    but...if this transfer was taking place on a real Ethereum network rather than
    on the Remix JavaScript EVM emulator, would you know where within the network
    it would be executed? And would you know what effect a transfer of SimpleCoin
    tokens would have on the blockchain? You can get the answers to these questions
    by looking at the diagram in [figure 3.15](#ch03fig15). I’ve adapted it for SimpleCoin
    from the transactional view you saw in [figure 1.8](kindle_split_012.xhtml#ch01fig08)
    ([chapter 1](kindle_split_012.xhtml#ch01)).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see other transaction lifecycle diagrams similar to this for all Dapps
    I’ll cover in the book. The lifecycle of an Ethereum transaction will be cemented
    in your head progressively throughout the book, until it becomes second nature
    to you.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15\. The lifecycle of a SimpleCoin transfer transaction. A transfer
    transaction is created when a SimpleCoin wallet invokes the `transfer()` function
    on the `SimpleCoin` smart contract on a local node of the Ethereum network. This
    is then validated and propagated throughout the network until it’s included on
    a new blockchain block by a mining node. The new block is then propagated throughout
    the network, and finally it gets back to the local node.
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15. SimpleCoin转账交易的生命周期。当SimpleCoin钱包在以太坊网络的本地节点上调用`transfer()`函数时，创建了一个转账交易。然后它会在网络中被验证并传播，直到被挖矿节点包含在一个新的区块链块中。然后这个新块会在网络上传播，最后回到本地节点。
- en: '![](Images/fig03-15_alt.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig03-15_alt.jpg)'
- en: Summary
  id: totrans-1170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The Ethereum wallet is a GUI that allows you to interact with the platform by
    creating accounts and transferring Ether intuitively.
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊钱包是一个GUI，通过创建账户和直观地转移以太币来与平台交互。
- en: The most popular Ethereum client is Go Ethereum, also known as geth. It comes
    with an interactive console that references Web3.js, a high-level interface to
    Ethereum clients.
  id: totrans-1172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的以太坊客户端是Go Ethereum，也被称为geth。它带有一个交互式控制台，引用Web3.js，这是一个高级接口，用于与以太坊客户端交互。
- en: 'It’s possible to interact with geth, for instance to create accounts, through
    various avenues:'
  id: totrans-1173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，可以通过各种途径与geth交互：
- en: geth commands executed in the operating system command shell
  id: totrans-1174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统命令行中执行geth命令
- en: Web3.js instructions executed in the geth interactive console
  id: totrans-1175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在geth交互式控制台中执行Web3.js指令
- en: HTTP JSON-RPC commands executed through cURL or a UI tool such as Postman
  id: totrans-1176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过cURL或像Postman这样的UI工具执行HTTP JSON-RPC命令
- en: Ethereum smart contracts, or just *contracts*, are written in a high-level language
    such as Solidity, compiled into EVM bytecode, deployed on the Ethereum network,
    and stored in the blockchain.
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊智能合约，或简称*合约*，是用如Solidity这样的高级语言编写的，编译成EVM字节码，部署在以太坊网络上，并存储在区块链上。
- en: It’s possible to communicate with contracts using calls, transactions, and events.
    A transaction involves the consumption of computational and network resources,
    which is calculated in a unit called gas and settled in Ether, the cryptocurrency
    of the Ethereum platform.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过调用、交易和事件与合约进行通信。交易涉及计算和网络资源的消耗，这些资源以称为燃料（gas）的单位计算，并以以太坊平台加密货币以太币（Ether）的形式结算。
- en: Chapter 4\. Deploying your first smart contract
  id: totrans-1179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章. 部署你的第一个智能合约
- en: '|  |'
  id: totrans-1180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Deploying a contract onto the Ethereum network
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将合约部署到以太坊网络上
- en: Interacting with the contract over the network
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络与合约交互
- en: Nodeless contract deployment and interaction with MetaMask
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无节点合约部署和通过MetaMask的交互
- en: '|  |'
  id: totrans-1185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the first two chapters, you started building SimpleCoin, your basic cryptocurrency.
    You did so in the Remix IDE and tried out its minimal functionality through its
    JavaScript-based EVM emulator. The experience was useful to help you understand
    from a conceptual point of view what a smart contract looks like and how to activate
    and interact with it. But SimpleCoin still looks like a bit of code running in
    an IDE. Now that you’re becoming familiar with the Ethereum platform, you may
    be wondering, “Wouldn’t it be nice to see SimpleCoin in action in a more realistic
    environment?” That’s exactly what you’ll be doing in this chapter.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，你开始构建SimpleCoin，你的基本加密货币。你在Remix IDE中这样做，并通过基于JavaScript的EVM模拟器尝试其最小功能。这种体验有助于你从概念上理解智能合约的样子以及如何激活和与之交互。但SimpleCoin仍然看起来像是在IDE中运行的一段代码。现在你已经开始熟悉以太坊平台，你可能在想，“看到SimpleCoin在一个更真实的环境中运行难道不好吗？”本章你将做正好这件事。
- en: You’ll deploy the `SimpleCoin` contract onto the Ethereum network, and then
    you’ll interact with it in a couple of ways. First, you’ll go through the Ethereum
    wallet, which requires you to import a copy of the blockchain locally, and then
    you’ll go through MetaMask, a third-party tool that allows you to connect to the
    Ether-eum network without accessing an Ethereum client or the wallet.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把`SimpleCoin`合约部署到以太坊网络上，然后你将用几种不同的方式与之交互。首先，你将通过以太坊钱包进行，这需要你本地导入区块链的一个副本，然后你将通过MetaMask进行，MetaMask是一个第三方工具，它允许你连接到以太坊网络，而无需访问以太坊客户端或钱包。
- en: 4.1\. Deploying a contract onto the network
  id: totrans-1188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 将合约部署到网络上
- en: You’re probably used to deploying centralized applications on servers. If you’ve
    ever developed a web application, for example, you might have initially developed
    all the layers on your desktop computer. Then, after the application was mature
    enough for users or testers to test it, you deployed its components into the user
    acceptance testing (UAT) environment on one or more servers. A typical deployment
    for a web application might include
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯了在服务器上部署集中式应用。例如，如果你曾经开发过一个网络应用，你可能最初在你的台式计算机上开发所有层次。然后，在应用成熟到足够用户或测试人员测试时，你将其组件部署到用户接受测试（UAT）环境中的一个或多个服务器上。一个网络应用的典型部署可能包括
- en: One web server that hosts static and dynamic web pages
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个托管静态和动态网页的网络服务器
- en: One or more application servers that host the services the web pages use
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个应用服务器，用于托管网页使用的服务
- en: One or more database servers that persist the data that the services use
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个数据库服务器，用于持久化服务使用的数据
- en: The deployment of a decentralized application is quite different. Even a simple
    decentralized application consisting of only one smart contract, like your SimpleCoin
    application, would get deployed across the entire Ethereum network. As you might
    recall from the development view I introduced in [chapter 2](kindle_split_013.xhtml#ch02),
    [section 2.1.3](kindle_split_013.xhtml#ch02lev2sec3), a smart contract gets deployed
    as a special transaction whose payload is compiled EVM bytecode. You submit the
    deployment transaction through a local node, which propagates it throughout the
    Ethereum network until it hits mining nodes. The smart contract only gets deployed
    after a mining node has successfully processed the deployment transaction containing
    the contract EVM bytecode to a new block that gets appended to the blockchain.
    That block is then replicated throughout the Ethereum network, as shown in [figure
    4.1](#ch04fig01).
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用的部署相当不同。即使是一个只包含一个智能合约的简单去中心化应用，如你的SimpleCoin应用，也会跨越整个以太坊网络进行部署。正如你在我在第[2章](kindle_split_013.xhtml#ch02)中介绍的开发视图中所可能回忆到的，在第[2.1.3节](kindle_split_013.xhtml#ch02lev2sec3)中，智能合约作为一种特殊的交易部署，其有效载荷是编译后的EVM字节码。你通过一个本地节点提交部署交易，该交易会传播到整个以太坊网络，直到它到达挖矿节点。只有当挖矿节点成功处理了包含合约EVM字节码的部署交易，并将新区块附加到区块链之后，智能合约才会被部署。正如[图4.1](#ch04fig01)所示，该区块随后会复制到整个以太坊网络。
- en: 'You have two options for deploying contracts onto the network:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 你在网络上部署合约有两个选项：
- en: Manually, through the Ethereum wallet
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以太坊钱包手动部署
- en: Through terminal commands, on geth’s interactive console
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过geth的交互式控制台命令部署
- en: Figure 4.1\. A contract written in a high-level language such as Solidity is
    compiled into EVM bytecode and deployed to the network through a deployment transaction
    containing the contract EVM bytecode, which is executed through a local full node
    of the network. The deployment transaction is propagated throughout the network;
    then it’s processed by a mining node and included in a new block that gets replicated
    throughout the network. It’s like any other transaction, except that what’s being
    stored on the blockchain isn’t Ether or data but EVM bytecode.
  id: totrans-1197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\。用类似Solidity的高级语言编写的合约会被编译成EVM字节码，并通过包含合约EVM字节码的部署交易部署到网络上，该交易通过网络的本地全节点执行。部署交易会传播到整个网络；然后由挖矿节点处理，并包含在新的复制到整个网络的区块中。这就像任何其他交易一样，只不过存储在区块链上的是EVM字节码，而不是以太币或数据。
- en: '![](Images/fig04-01_alt.jpg)'
  id: totrans-1198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig04-01_alt.jpg)'
- en: In this chapter, you’ll deploy the `SimpleCoin` contract manually. By doing
    so, you’ll go through the deployment process in a visual and intuitive way that
    will help you learn quickly.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个章节，你将手动部署`SimpleCoin`合约。这样做，你将以一种视觉化和直观化的方式经历部署过程，这将帮助你快速学习。
- en: 'Once you get used to deploying contracts through the Ethereum wallet, you’ll
    be ready for the next step: command-based deployment. Though it may seem slightly
    intimidating at first, deploying contracts through geth’s console is a useful
    exercise because it helps you understand the platform more thoroughly. You’ll
    explore this in the next several chapters. For now, I’ll quickly recap what you
    know:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了通过以太坊钱包部署合约，你将准备好进行下一步：基于命令的部署。虽然一开始可能会有些令人畏惧，但通过geth控制台部署合约是一个有用的练习，因为它能帮助你更全面地理解平台。你将在接下来的几章中探索这个主题。现在，我会快速回顾你已经知道的内容：
- en: '*The mechanisms to trigger deployment*—You know that you can deploy contracts
    manually through the Ethereum wallet or by using commands on geth’s console. (You’ll
    see these in action soon.)'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触发部署的机制*——你知道你可以通过以太坊钱包手动部署合约，或者使用geth控制台上的命令来部署合约。（你很快就会看到这些内容。）'
- en: '*What happens during deployment*—The contract’s bytecode gets stored on the
    blockchain following the execution of its deployment transaction.'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署过程中会发生什么*——合约的字节码在其部署交易执行后存储在区块链上。'
- en: But what exactly is the Ethereum network? I’ll answer that question in the next
    section.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 但以太坊网络究竟是什么呢？我在下一节回答这个问题。
- en: 4.1.1\. Ethereum public networks
  id: totrans-1204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 以太坊公共网络
- en: 'When you connected to Ethereum in the previous chapter, you might not have
    noticed that you connected to two different networks:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在前一章中连接到以太坊时，你可能没有注意到你连接到了两个不同的网络：
- en: From the Ethereum wallet, you connected to *Ropsten*, a public test network.
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通过以太坊钱包连接到了*Ropsten*，这是一个公共测试网络。
- en: From geth, you connected to *Mainnet*, the public production network.
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从geth中，你连接到了*Mainnet*，这是一个公共生产网络。
- en: '*Ropsten* is the public test network that Ethereum provides for mining based
    on proof of work (PoW), which is the current algorithm used in the public production
    network. If you followed the instructions I gave you, your Ethereum wallet is
    already pointing to the Ropsten network, and you only have fake Ether in your
    accounts, which you generated through CPU mining.'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ropsten*是以太坊提供的公共测试网络，基于工作量证明（PoW）挖矿，这是目前公共生产网络中使用的算法。如果你按照我给你的指示操作，你的以太坊钱包已经指向了Ropsten网络，并且你账户中只有通过CPU挖矿生成的假以太币。'
- en: If you left your geth client running from the previous chapter, it’s pointing
    to *Mainnet*, the production network. Ether moved between accounts in this network
    is real. You should use this network only to perform transactions against production
    Dapps; you should avoid it during development.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前一章中让geth客户端一直运行，它现在指向的是*Mainnet*，即生产网络。在这个网络中账户间转移的以太币是真实的。你应只在此网络上对生产Dapp执行交易；在开发过程中应避免使用此网络。
- en: Another public test network called *Kovan* is available, and it supports mining
    performed with a new algorithm called Proof of Authority. So far, this has only
    been implemented in the Parity client, so it’s outside the scope of this book.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为*Kovan*的公共测试网络，它支持使用名为Proof of Authority的新算法进行挖矿。到目前为止，这只在Parity客户端实现，所以本书不涉及这部分内容。
- en: In the next section, you’ll deploy the `SimpleCoin` contract to Ropsten through
    the wallet. As a result, you don’t need to make any environmental configuration
    changes yet.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将通过钱包将`SimpleCoin`合约部署到Ropsten网络。因此，你暂时还不需要进行任何环境配置更改。
- en: 4.1.2\. Deploying SimpleCoin with the Ethereum wallet
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 使用以太坊钱包部署SimpleCoin
- en: 'Start up the Ethereum wallet—make sure the sync mode is Fast or Full and wait
    until it’s fully synchronized—and open the Contracts screen by clicking Contracts
    on the top bar, near the top-right corner. You’ll see two main options:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 启动以太坊钱包——确保同步模式是快速或完全同步，并等待它完全同步——然后通过点击顶栏附近的Contracts来打开合约屏幕。你会看到两个主要选项：
- en: '*Deploy New Contract*—You can deploy a new contract by supplying its Solidity
    code.'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署新合约*——你可以通过提供其Solidity代码来部署新合约。'
- en: '*Watch Contract*—You can reference a contract that already has been deployed
    so you can interact with it.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察合约*——你可以引用一个已经部署好的合约，以便与之交互。'
- en: Click Deploy New Contract. When the Deploy Contract screen opens, you can decide
    which account will become the contract owner. Choose Account 1, and then click
    the Solidity Contract Source Code tab at the bottom of the screen and paste the
    `SimpleCoin` code from the end of [chapter 3](kindle_split_014.xhtml#ch03), as
    shown in the following listing. (Make sure the constructor and functions are declared
    as *public* to be compiled in the wallet; I’ll explain function access modifiers
    such as public in [chapter 5](kindle_split_017.xhtml#ch05).)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 点击部署新合约。当打开部署合约屏幕时，你可以决定哪个账户将成为合约所有者。选择账户1，然后点击屏幕底部的Solidity合约源代码标签，并粘贴来自[第3章](kindle_split_014.xhtml#ch03)末尾的`SimpleCoin`代码（确保构造函数和函数声明为*public*，以便在钱包中编译；我将在[第5章](kindle_split_017.xhtml#ch05)解释函数访问修饰符，如public）。
- en: Listing 4.1\. Latest version of `SimpleCoin` (from [chapter 3](kindle_split_014.xhtml#ch03))
  id: totrans-1217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. `SimpleCoin`的最新版本（来自[第3章](kindle_split_014.xhtml#ch03)）
- en: '[PRE78]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Once you’ve pasted the code, the wallet will compile it into EVM bytecode, and
    a drop-down list will appear on the right-hand side. Pick Simple Coin from the
    list and enter 10000 as the constructor parameter. Finally, click Deploy at the
    bottom of the screen, as shown in [figure 4.2](#ch04fig02).
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2\. After you enter the Solidity code of a contract, the wallet compiles
    it into EVM bytecode. Supply the contract parameters, click Deploy, and a new
    dialog box will confirm the deployment transaction.
  id: totrans-1220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-02_alt.jpg)'
  id: totrans-1221
  prefs: []
  type: TYPE_IMG
- en: 'A new dialog box will appear, as shown in [figure 4.3](#ch04fig03). You’ll
    be asked to enter the password and to send the deployment transaction. Remember:
    you need Ether in your account to be able to submit the transaction! Once you
    send the deployment transaction, you can check its status in the Latest Transactions
    section of the wallet main screen. There you can see that the deployment transaction
    is treated like any other transaction.'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3\. A dialog box asks you to enter the password of the account that
    you’ll deploy the contract from. After you supply it and click Send, a deployment
    transaction is generated and sent to the network.
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-03_alt.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
- en: Once the contract has received all the necessary network confirmations, which
    you can view in the Latest Transactions panel (see [figure 4.4](#ch04fig04)),
    go back to the Contracts screen. You’ll see Simple Coin with a balance of zero
    Ether ([figure 4.5](#ch04fig05)).
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4\. After a contract transaction has been submitted to the network,
    you can monitor its network confirmations in the Latest Transactions panel of
    the Contracts screen.
  id: totrans-1226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-04_alt.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5\. After the contract receives 12 confirmations, which makes it very
    likely the deployment transaction is permanently stored on the blockchain, a deployed
    contract appears in the Contracts panel.
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-05_alt.jpg)'
  id: totrans-1229
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
- en: Definition
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Transaction confirmations* indicate the depth of the transaction in the blockchain.
    A new confirmation is received as soon as a new block is appended to the blockchain
    after the block containing the transaction in question. The probability of a block
    reversal decreases exponentially as the number of confirmations increase, so a
    transaction is considered consolidated after 12 confirmations. (That means 12
    blocks have been added to the blockchain after the block containing the transaction.)'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1233
  prefs: []
  type: TYPE_TB
- en: Congratulations! You’ve deployed your first contract on the Ethereum network.
    Now you can interact with the contract, much as you did earlier with Remix. You
    can start by moving SimpleCoin tokens between accounts and verifying the expected
    balances.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Interacting with the contract
  id: totrans-1235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting to move SimpleCoin tokens, go back to the wallet’s main screen
    and add two more accounts. (Remember to take note of the related passwords.) These
    extra accounts will become handy when testing contract operations. I recommend
    you copy all the account addresses you have in your wallet to a temporary text
    file. [Table 4.1](#ch04table01) shows what it would contain in my case.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1\. Ethereum wallet account addresses
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account name | Account address |'
  id: totrans-1238
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
- en: '| Main account | 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
- en: '| Account 2 | 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
- en: '| Account 3 | 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
- en: '| Account 4 | 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-1244
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To copy an address, select it, and then click Copy Address. Alternatively, you
    can use the usual Ctrl+C shortcut. Either way, the wallet will ask you to confirm
    you want to go ahead with this operation. (There is risk that malware may replace
    the address.)
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
- en: 'Now go back to the Contracts screen and click SimpleCoin. At the top of the
    screen, just below the name of the contract, you’ll see the contract address,
    which is the account address of the contract in the blockchain. You’ll notice
    that the area associated with the `SimpleCoin` contract is logically divided into
    two parts: Read from Contract on the left and Write on Contract on the right.
    This arrangement is similar to the color codes you saw in Remix for read-only
    functionality (blue) and write functionality (red).'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1\. Checking coin balances
  id: totrans-1249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can first check the coin balance of all accounts by entering the address
    of each account next to the coin balance textbox. The expected balances are shown
    in [table 4.2](#ch04table02).
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2\. Expected account balances
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1252
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1253
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |'
  id: totrans-1256
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
- en: What happens if you try to check the balance of an invalid address? For example,
    replace the last digit of the main account (starting with 0xedDE06bC) with an
    8 and try to check the coin balance. You won’t be allowed to enter such an address
    because the wallet will consider its checksum invalid. But you will be allowed
    to enter any valid Ethereum address, even if it’s not associated with your accounts.
    (You can grab some to try from [https://etherscan.io/](https://etherscan.io/).)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2\. Transferring coins
  id: totrans-1259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you can move some coins around. You can start with a transfer of 150 SimpleCoins
    from the Main Account to Account 3\. This is the same operation you performed
    on Remix in the previous chapter. Pick Transfer from the Select Function drop-down
    in the Write to Contract panel. All the input fields required for the coin transfer
    will appear, as in [figure 4.6](#ch04fig06).
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Pick the Main Account from the Execute From list, then set the address of Account
    3 in the To field and an amount of 150. After you click Execute, you’ll be asked
    to enter the password of the Main account to digitally sign the transaction.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: If you select the Watch Contract Events box in the Latest Events pane, you’ll
    soon see the details of the transaction you’ve sent. At this point, you can recheck
    the balances of all addresses. The expected balances are shown in [table 4.3](#ch04table03).
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3\. Expected updated account balances
  id: totrans-1263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1264
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1266
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1267
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |'
  id: totrans-1268
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1269
  prefs: []
  type: TYPE_TB
- en: Figure 4.6\. Checking the SimpleCoin balance is a read-only operation, so you
    only need to specify the input address. Transferring coins is a write operation.
    As seen here, you have to specify the number of coins to be transferred, the destination
    address, and the sending account.
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-06_alt.jpg)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
- en: Now try to move 50 coins from Account 3 to Account 2 and recheck the balances
    after the transaction has appeared in the Latest Events panel. You’ll notice that
    the only accounts listed in the Execute From drop-down list are the Main Account
    and Account 2\. This is because the wallet doesn’t allow you to execute a transaction
    from an account with no Ether in it.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [chapter 2](kindle_split_013.xhtml#ch02), the executing account
    must pay a transaction fee calculated in gas but settled in Ether to perform a
    transaction. For Accounts 3 and 4 to be useful, you must send some Ether to them
    from the Main Account. You can perform this Ether transfer from the Send screen,
    as you did in the previous chapter when you set up Account 2\. As usual, you can
    monitor the Ether transfer transactions on the Latest Transactions panel and wait
    for them to complete. Once all accounts own some Ether, you’re ready to perform
    a transaction.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `SimpleCoin` contract screen and pick the transfer function again.
    The Execute From drop-down list will now show all the accounts, so you can pick
    Account 3\. Enter the address of Account 2 in the To textbox and 50 in the Amount
    field. When you click Execute, you’ll be asked for the password for Account 3,
    the sending account. After the transaction has been confirmed, recheck the balances.
    The new expected balances are shown in [table 4.4](#ch04table04).
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.4\. Updated account balances after second transfer
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1276
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1277
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1278
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  id: totrans-1280
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1281
  prefs: []
  type: TYPE_TB
- en: Trying to transfer unavailable coins
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you’ll remember, the code of the SimpleCoin `transfer` function performs
    some checks before modifying the balances of the sender and recipient addresses.
    It prevents an account from attempting to transfer unavailable coins by throwing
    an error. You can see what happens if you try to do so through the wallet. For
    example, try to move 200 coins from Account 4 to Account 3\. As expected, you’ll
    get an error message indicating the transaction will fail, as shown in [figure
    4.7](#ch04fig07).
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7\. If a transaction generated from a write operation, such as `SimpleCoin.transfer()`,
    fails validation checks, it can’t be sent to the network.
  id: totrans-1284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-07_alt.jpg)'
  id: totrans-1285
  prefs: []
  type: TYPE_IMG
- en: You might be surprised that the error message is thrown before the transaction
    has even been sent out. This happens because the wallet verifies transactions
    locally, before sending, as any node would do. If an error is returned, the wallet
    doesn’t propagate the transaction to the network, and you receive an error message
    immediately.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You’ve fully, manually, tested `SimpleCoin` on the public test network.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: So far, this chapter has given you an idea of how to deploy a smart contract
    to a public network without having to run a full Ethereum node. You performed
    it through the Ethereum wallet, which, under the hood, still connects to a fully
    synchronized copy of the blockchain. But you might be wondering whether you can
    achieve the same thing without having a local synchronized copy of the blockchain.
    The answer is yes. As we’ll explore in the next section, you can connect to a
    set of publicly accessible nodes exposed by a Chrome plugin called Metamask.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. Nodeless deployment through MetaMask
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MetaMask* is a Chrome extension that connects you to an external set of Ethereum
    nodes, as you can see in [figure 4.8](#ch04fig08). It allows you to deploy a contract
    to a public network and interact with it without having to install and maintain
    any Ethereum software. As an alternative, if you don’t want to use Chrome, you
    can download the Brave browser and install MetaMask as an extension. MetaMask
    is especially handy if you don’t develop smart contracts continuously and don’t
    want the inconvenience of having to update the wallet or Go Ethereum client and
    resynchronize the blockchain every time you resume your development.'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8\. When connecting to Ethereum through the Ethereum wallet or the
    Go Ethereum client console, you do so through a local node. When connecting to
    Ethereum through Metamask, you do so through a remote node.
  id: totrans-1291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-08_alt.jpg)'
  id: totrans-1292
  prefs: []
  type: TYPE_IMG
- en: In the next section, you’ll install MetaMask. Then you’ll redeploy `SimpleCoin`
    to Ropsten through MetaMask and interact with it, completely bypassing your local
    geth client and Ethereum wallet.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1\. Installing MetaMask
  id: totrans-1294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can install the MetaMask chrome extension from this url: [http://mng.bz/8JzB](http://mng.bz/8JzB).
    After adding the extension, you should see the MetaMask icon next to the browser
    address bar.'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: You can now start to set up a MetaMask wallet by clicking on the MetaMask icon.
    You’ll be invited to accept a privacy notice and terms and conditions (at your
    own risk). Then you’ll be asked to create a new password, as shown in [figure
    4.9](#ch04fig09).
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9\. Creation of a password to secure the MetaMask wallet
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-09_alt.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
- en: Enter your new (possibly secure) password and click Create. You’ll be advised
    to copy and securely store the system-generated 12-word recovery passphrase. The
    wallet will be created after you confirm you’ve done so, and at that point you’ll
    see on the top left, next to the MetaMask icon, the name of the network you’re
    connected to. Initially, you’re connected to Main Ethereum Network, as shown in
    [figure 4.10](#ch04fig10).
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10\. MetaMask initially points to Main Ethereum Network.
  id: totrans-1300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-10_alt.jpg)'
  id: totrans-1301
  prefs: []
  type: TYPE_IMG
- en: Given that you’ll deploy `SimpleCoin` onto a test network, change your current
    network by clicking Main Ethereum Network and selecting the Ropsten Test Network
    from the drop-down list, as shown in [figure 4.11](#ch04fig11).
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11\. It’s possible to connect to various Ethereum networks through
    MetaMask.
  id: totrans-1303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-11_alt.jpg)'
  id: totrans-1304
  prefs: []
  type: TYPE_IMG
- en: You’ll notice the default account has nothing to do with any of the accounts
    you have in your Ropsten Ethereum wallet. And this default test account hasn’t
    got any Ether, so you won’t be able to do much with it. To import some of your
    existing Ropsten accounts, which already contain Ether, click the menu icon on
    the top right, and then select Import. In the Import dialog box, you’ll see a
    Select Type drop-down list. Select JSON File, as shown in [figure 4.12](#ch04fig12).
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12\. Dialog box for importing accounts from JSON files
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-12_alt.jpg)'
  id: totrans-1307
  prefs: []
  type: TYPE_IMG
- en: Now you have to supply the JSON file containing the private key of your existing
    Ropsten account. Remember, the key pairs of your Ropsten account are held in the
    testnet keystore, which, depending on your OS, you can find in one of the locations
    shown in [table 4.5](#ch04table05).
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.5\. Testnet keystore locations
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| System | Keystore path |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
- en: '| Windows | C:\Users\username\%appdata%\Roaming\Ethereum\testnet\keystore |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
- en: '| Linux | ~/.ethereum/testnet/keystore |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
- en: '| Mac | ~/Library/Ethereum/testnet/keystore |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
- en: 'The testnet keystore folder should contain a list of files whose names contain
    the timestamp and the account address they refer to:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T08-49-46.377533700Z--edde06bc0e45645e2f105972bdefc220ed37ae10`'
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T13-26-18.696630000Z--4e6c30154768b6bc3da693b1b28c6bd14302b578`'
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-36.890638200Z--70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02`'
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTC--2017-06-24T18-21-47.794428600Z--c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4`'
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the file extension isn’t present, these are JSON files. For example,
    the second file on the list refers to account 4e6c30154768b6bc3da693b1b28c6bd14302b578\.
    If you open the file with a text editor, such as Notepad in Windows, you should
    see JSON content similar to this:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the MetaMask Import Account dialog box, click Choose File, navigate to your
    testnet keystore, and then pick the file related to the account you want to import.
    You must supply the password you entered when creating this account, and then
    click Import. After a few seconds, you should see the details of the account you’ve
    imported, including the Ether contained in it, as shown in [figure 4.13](#ch04fig13).
    Once you’ve imported a couple of your existing Ropsten accounts, you can proceed
    to the deployment of `SimpleCoin`.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13\. After you import an account from the keystore, all its details
    appear on MetaMask.
  id: totrans-1323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-13_alt.jpg)'
  id: totrans-1324
  prefs: []
  type: TYPE_IMG
- en: 4.3.2\. Deploying SimpleCoin through MetaMask
  id: totrans-1325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To deploy `SimpleCoin`, first open Remix and enter the latest version of `SimpleCoin`,
    the same one you entered into the wallet, shown earlier in [listing 4.1](#ch04ex01).
    Now pick the Injected Web3 option in the Environment drop-down list in the Run
    tab of the right-hand side panel, as shown in [figure 4.14](#ch04fig14).
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14\. The screenshot shows how you can configure Remix to use external
    MetaMask nodes (rather than the local JavaScript Virtual Machine emulator) by
    selecting Injected Web3 in the Environment drop-down list.
  id: totrans-1327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-14_alt.jpg)'
  id: totrans-1328
  prefs: []
  type: TYPE_IMG
- en: Remix will detect MetaMask, and it’ll use one of the MetaMask nodes rather than
    the local JavaScript EVM emulator. If no account is showing in the Account drop-down
    list, refresh the Remix webpage and the account currently selected in MetaMask
    will be selected.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: You can trigger `SimpleCoin`’s deployment by clicking the red Deploy button.
    Account 2, whose address starts with 0x4e6c30154, is the only option available
    and is currently selected in the Account drop-down list box. That account will
    deploy the contract.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: After you click Deploy, you’ll see a dialog box summarizing information on the
    executing account and transaction costs for the deployment transaction. You’ll
    also be asked to confirm you want to go ahead with it, as you can see in [figure
    4.15](#ch04fig15).
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15\. After configuring Remix to point to external Metamask nodes and
    starting the deployment of a contract (such as `SimpleCoin`), you get a (deployment)
    transaction confirmation dialog box from Metamask. This shows information on the
    account executing the deployment transaction and on transaction costs. The dialog
    box also asks the user to confirm whether to go ahead with the deployment of the
    contract.
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-15_alt.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
- en: After clicking Confirm, you can check the transaction status in the bottom area
    of the Metamask wallet. The status will move from Submitted to Confirmed, as shown
    in [figure 4.16](#ch04fig16).
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: If you click the label Transaction Number while the contract is in status Submitted,
    and then after it has moved to Confirmed, you’ll see the transaction details from
    the Etherscan website, as shown in [figure 4.17](#ch04fig17). As you can see,
    Etherscan also shows the destination address (starting with 0x0c9189e4d6) of the
    contract.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16\. It’s possible to monitor the status of the deployment transaction
    in the bottom area of the Metamask wallet. This will change from Submitted to
    Confirmed.
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-16_alt.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17\. Transaction details from the Etherscan website, invoked when clicking
    the (Submitted or Confirmed) status on the MetaMask wallet
  id: totrans-1338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-17_alt.jpg)'
  id: totrans-1339
  prefs: []
  type: TYPE_IMG
- en: If you move back to Remix, you’ll see some deployment details below the Deploy
    button, including the deployment address, which is the same one you saw on the
    Etherscan page. You can grab the address by clicking the Copy Address link, as
    shown in [figure 4.18](#ch04fig18).
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18\. After the completion of the deployment transaction, the contract
    address is shown in Remix, below the Deploy button.
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-18_alt.jpg)'
  id: totrans-1342
  prefs: []
  type: TYPE_IMG
- en: Well done! You’ve redeployed `SimpleCoin` on Ropsten through MetaMask. Now you
    can see how you can interact with it through MetaMask.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3\. Interacting with SimpleCoin through MetaMask
  id: totrans-1344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4.18](#ch04fig18) also shows that after deploying `SimpleCoin`, Remix
    displays two buttons: CoinBalance and Transfer. These are exactly the same buttons
    that appeared when you created the contract for the first time on the JavaScript
    VM, back in [chapter 1](kindle_split_012.xhtml#ch01). This time, though, you’ll
    be interacting with a contract instantiated on a real network.'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: The first operation you can perform is to check the token balance of Account
    2, the account that deployed the contract. Enter “0x4e6c30154768b6bc3da693b1b28-c6bd14302b578”
    (remember, as usual, to surround the address with double quotes) and click CoinBalance.
    You’ll immediately get 10,000, as expected. As with checking balances through
    the Ethereum wallet, this operation is read-only and doesn’t produce a transaction.
    Consequently, you don’t need to authorize it.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: 'Now move 250 tokens from Account 2 to Account 3\. Enter this into the Transfer
    text box:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Click Transfer. This is a write operation, so the MetaMask transaction confirmation
    dialog box pops up, as shown in [figure 4.19](#ch04fig19). You can authorize it
    from Account 2\. Click Confirm and follow the transaction status in the MetaMask
    dialog box.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19\. To transfer SimpleCoin tokens, which is a contract-state write
    operation, the sending account needs to be authorized. Subsequently, the MetaMask
    transaction confirmation dialog box is shown to get user confirmation.
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig04-19_alt.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
- en: If you click on the transaction number icon, you’ll see the transaction details
    in Etherscan. You can now go back to Remix and check the transaction details there
    as well.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Both Etherscan and Remix confirm that the move of 250 SimpleCoin tokens from
    Account 2 to Account 3 has been successful, but you can double-check the new balances
    of these accounts with the `coinBalance` function, which should match those in
    [table 4.6](#ch04table06).
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.6\. Account balances after transferring 250 tokens
  id: totrans-1354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1355
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1356
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 9,750 |'
  id: totrans-1357
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 250 |'
  id: totrans-1358
  prefs: []
  type: TYPE_TB
- en: I’ll stop here, but I’d encourage you to generate some error messages, for example
    by trying to move unavailable coins, as you did previously with the Ethereum wallet.
    Doing so will allow you to confirm whether the contract also works correctly on
    MetaMask.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    the Ethereum wallet.
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum wallet communicates with Ethereum through a local geth instance.
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy a contract onto the Ethereum network and interact with it using
    MetaMask.
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
