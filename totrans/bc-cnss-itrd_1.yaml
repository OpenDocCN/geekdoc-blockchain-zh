- en: some basic math concepts first. This will help us to not only understand causality
    but
  prefs: []
  type: TYPE_NORMAL
- en: will also help with concepts explained later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set**'
  prefs: []
  type: TYPE_NORMAL
- en: A set is a collection of elements. It is denoted by a capital letter. All elements
    of the set are listed inside the brackets. If an element x is present in a set,
    then it is written as *x* ∈ *X*, which means x is in X or x belongs to X. Similarly,
    if an element x is not present in a set X, it is written as *x* ∉ *X*. It does
    not matter which order the elements are in. Two sets are equal if they have the
    same elements. Equality is expressed as *X* = *Y*, meaning set X is equal to set
    Y. If two sets X and Y are not equal, it is written as *X* ≠ *Y*. A set that does
    not have any elements is called an empty set and is denoted as { } or *ϕ*. An
    example of a set is *X* = {1 5
  prefs: []
  type: TYPE_NORMAL
- en: ', ,2 8'
  prefs: []
  type: TYPE_NORMAL
- en: ', , }'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: 'A set Y is a subset of set X if every element of Y is also an element of X,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Y* = {2 }'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Set Y is a subset of set X. This relationship is written as
  prefs: []
  type: TYPE_NORMAL
- en: '*Y* ⊆ *X*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A union of two sets A and B contains all the elements in A and B, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A* = {1,2, }'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '*B* = {3,4, }'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: A union of sets A and B is
  prefs: []
  type: TYPE_NORMAL
- en: '*S* = {1,2 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', ,4, }'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: The cartesian product of two sets A and B is the set of ordered pairs (a, b)
    for each
  prefs: []
  type: TYPE_NORMAL
- en: element in sets A and B. It is denoted as *A* × *B*. It is a set of ordered
    pairs (a, b) for each *a* ∈ *A* and *b* ∈ *B*.
  prefs: []
  type: TYPE_NORMAL
- en: An ordered pair is composed of two elements inside parentheses, for example,
    (1,
  prefs: []
  type: TYPE_NORMAL
- en: 2) or (2, 1). Note here that the order of elements is important and matters
    in the case of ordered pairs, whereas in sets the order of elements does not matter.
    For example, (1, 2) is not the same as (2, 1), but {1,2} and {2,1} are the same
    or equal sets.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a cartesian product, *A* × *B*, for sets shown earlier is
  prefs: []
  type: TYPE_NORMAL
- en: '{(1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,3), (3,4), (3,5)}'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the ordered pair, the first element is taken from set A and the
    second
  prefs: []
  type: TYPE_NORMAL
- en: element from set B.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relation**'
  prefs: []
  type: TYPE_NORMAL
- en: A relation (binary) between two sets A and B is a subset of the cartesian product
    *A* × *B*.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between two elements is binary and can be written as a set
    of
  prefs: []
  type: TYPE_NORMAL
- en: ordered pairs. We can express this as a R b (infix notation) or (a, b) \in R,
    meaning the ordered pair (a, b) is in relation R.
  prefs: []
  type: TYPE_NORMAL
- en: When a binary relation on a set S has properties of reflexivity, symmetry, and
  prefs: []
  type: TYPE_NORMAL
- en: transitivity, it is called an **equivalence relation**.
  prefs: []
  type: TYPE_NORMAL
- en: When a binary relation on a set S has three properties of reflexivity, antisymmetry,
  prefs: []
  type: TYPE_NORMAL
- en: and transitivity, then it is called a **partial ordering** on S.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial Order**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a binary relation ≤ (less than or equal to – for comparison) between the
    elements of a set S. A binary relation on a set S, which is reflexive, antisymmetric,
    and transitive, is known as a partial ordering on S. We now define the three conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflexivity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This property means that every element is related to itself. Mathematically,
    we can write it like this: ∀ *a* ∈ *S*, *a* ≤ *a*.'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Antisymmetry**'
  prefs: []
  type: TYPE_NORMAL
- en: This means that two elements cannot be related in both directions. Mathematically,
    it
  prefs: []
  type: TYPE_NORMAL
- en: can be written as ∀ *a*, *b* ∈ *S*, *if a* ≤ *b* ∧ *b* ≤ *a*, *a* = *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transitivity**'
  prefs: []
  type: TYPE_NORMAL
- en: The transitive property indicates a comparative relationship where if *a* <
    *b* and *b* < *c*, it implies that *a* < *c*. Mathematically, it can be written
    as ∀ *a*, *b*, *c* ∈ *S*, *if a* ≤ *b* ∧ *b* ≤ *c then a* ≤ *c*.
  prefs: []
  type: TYPE_NORMAL
- en: A set with a partial order is called a partially ordered set or poset. In terms
    of the
  prefs: []
  type: TYPE_NORMAL
- en: happens-before relationship, the set S is a set of all events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Irreflexive Partial Order**'
  prefs: []
  type: TYPE_NORMAL
- en: The irreflexive partial order or strict partial order is irreflexive, antisymmetric,
    and
  prefs: []
  type: TYPE_NORMAL
- en: transitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Irreflexive**'
  prefs: []
  type: TYPE_NORMAL
- en: This property means that there is no element that is related to itself. Mathematically,
  prefs: []
  type: TYPE_NORMAL
- en: we can write it like ∀ *a* ∈ *S*, *a* ≰ *a*, or given a relation R on a set
    S, R is irreflexive if
  prefs: []
  type: TYPE_NORMAL
- en: '∀ *s* ∈ *S* : ( *s*, *s*) ∉ *R*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total Order**'
  prefs: []
  type: TYPE_NORMAL
- en: A total order or linear order is a partial order in which each pair of elements
    is
  prefs: []
  type: TYPE_NORMAL
- en: comparable.
  prefs: []
  type: TYPE_NORMAL
- en: After this brief introduction to some math concepts, let us now look into what
  prefs: []
  type: TYPE_NORMAL
- en: causality is and what is a happens-before relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '**Happens-Before Relationship and Causality**'
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that a node could perform some events. It can either do the local
  prefs: []
  type: TYPE_NORMAL
- en: computation, send a message, or receive a message. All events happen in a sequential
  prefs: []
  type: TYPE_NORMAL
- en: order on a single node, and it is easy to see what happened before the next
    event. It is a strict total order imposed on each node.
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-70_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: 'A happens-before relationship is an irreflexive partial order (strict partial
    order) with three properties: **irreflexivity**, **antisymmetry**, and **transitivity**.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine there are two events e and f that have happened. To ascertain if
    event e
  prefs: []
  type: TYPE_NORMAL
- en: happened before event f, we use the following rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event e happened before event f if and only if (iff) : e → f (right arrow used
    as a'
  prefs: []
  type: TYPE_NORMAL
- en: 'symbol for happens-before):'
  prefs: []
  type: TYPE_NORMAL
- en: • If e and f occurred on the same process and e executed before f
  prefs: []
  type: TYPE_NORMAL
- en: on this process, then we can deduce that e precedes f, that is, a
  prefs: []
  type: TYPE_NORMAL
- en: sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: • Event e is a message send event of some (unique) message m, and
  prefs: []
  type: TYPE_NORMAL
- en: event f is the receipt of message m.
  prefs: []
  type: TYPE_NORMAL
- en: • If there exists an event g such that e→g and g→f, then e→f. This is
  prefs: []
  type: TYPE_NORMAL
- en: called a transitive relationship.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize all these three rules in Figure [1-23\.](#p70)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-23\.** Happens-before rules*'
  prefs: []
  type: TYPE_NORMAL
- en: If *e* and *f* are partially ordered, we then say that e happened before *f*.
    If *e* and *f* are not partially ordered, then we say that *e* and *f* are concurrent.
    This also doesn’t mean that *e* and *f* are executed independently exactly at
    the same time. It just means that *e* and *f* are not causally related. In other
    words, there is no sequence of messages which leads from
  prefs: []
  type: TYPE_NORMAL
- en: one event to another. The concurrency is written as *e* ∥ *g*. Figur[e 1-24
    sho](#p71)ws an example scenario in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-71_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-24\.** Example happens-before relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 1-24](#p71), the relations *e* → *f*, *g* → *h*, *i* → *j* are due
    to the order in which processes execute the events. The relations *f* → *g*, *h*
    → *j* are due to messages *m* 1 and *m* 2\. Moreover *e* → *g*, *e* → *h*, *e*
    → *j*, *f* → *h*, *f* → *j*, *g* → *j* represent transitive relation. Finally,
    the concurrent events are *e* ∥ *i*, *f* ∥ *i*, *g* ∥ *i*, *h* ∥ *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Logical clocks do not depend on physical clocks and can be used to define the
    order of
  prefs: []
  type: TYPE_NORMAL
- en: events in a distributed system. Logical clocks only measure the order of events
    without
  prefs: []
  type: TYPE_NORMAL
- en: any reference to external physical time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lamport Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: A Lamport clock is a logical counter that is maintained by each process in a
    distributed
  prefs: []
  type: TYPE_NORMAL
- en: system, and with each occurrence of an event, it is incremented to provide a
    means of
  prefs: []
  type: TYPE_NORMAL
- en: maintaining and observing a happens-before relationship between events occurring
    in
  prefs: []
  type: TYPE_NORMAL
- en: the distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea here is that each event is assigned a number which increments as
    the
  prefs: []
  type: TYPE_NORMAL
- en: event occurs in the system. This number is also called the Lamport clock. A
    Lamport
  prefs: []
  type: TYPE_NORMAL
- en: clock captures causality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for Lamport’s clocks/logical clocks is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Every process maintains a local counter which is set to zero at
  prefs: []
  type: TYPE_NORMAL
- en: initialization.
  prefs: []
  type: TYPE_NORMAL
- en: • With every event on a process, the counter is incremented by one by
  prefs: []
  type: TYPE_NORMAL
- en: that process.
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: • When a message is sent, a process includes its current value of the
  prefs: []
  type: TYPE_NORMAL
- en: counter.
  prefs: []
  type: TYPE_NORMAL
- en: • When a message is received, a process sets its counter value to
  prefs: []
  type: TYPE_NORMAL
- en: max(local + received) + 1\.
  prefs: []
  type: TYPE_NORMAL
- en: In a happens-before relationship where *e* → *f*, we can say that possibly *e*
    caused *f*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the happens-before relationship captures causality of the events.
  prefs: []
  type: TYPE_NORMAL
- en: More formally, the Lamport algorithm is shown in Listin[g 1-1\.](#p72)
  prefs: []
  type: TYPE_NORMAL
- en: '***Listing 1-1\.*** Lamport clock'
  prefs: []
  type: TYPE_NORMAL
- en: on init
  prefs: []
  type: TYPE_NORMAL
- en: t := 0
  prefs: []
  type: TYPE_NORMAL
- en: on event localcomputation do
  prefs: []
  type: TYPE_NORMAL
- en: t := t + 1
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: on event send(m) do
  prefs: []
  type: TYPE_NORMAL
- en: t := t + 1
  prefs: []
  type: TYPE_NORMAL
- en: send(m, t)
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: on event receive(m', t') do
  prefs: []
  type: TYPE_NORMAL
- en: t := max(t, t') + 1
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: Lamport clocks are consistent with causality. We can write this like
  prefs: []
  type: TYPE_NORMAL
- en: '*if e* → *f* ⇒ *LC* ( *e*) < *LC* ( *f* )'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if e happened before f, then it implies that the timestamp (Lamport
  prefs: []
  type: TYPE_NORMAL
- en: clock – LC) of event e is less than the timestamp of event f.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a correctness criterion called the **clock condition** which is used
    to evaluate the logical clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '∀ *a*, *b* : *a* → *b* ⇒ *LC* ( *a*) < *LC* ( *b*) 53'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-73_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: 'This is read as follows: for all a and b, a happened before b implies that
    the Lamport'
  prefs: []
  type: TYPE_NORMAL
- en: clock (timestamp) of a is less than the Lamport clock (timestamp) of b.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if event A happens before event B, then it implies that the
    Lamport
  prefs: []
  type: TYPE_NORMAL
- en: clock of event A is less than the Lamport clock of event B.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can see a picture emerging. Without using physical clocks, we can now
    see
  prefs: []
  type: TYPE_NORMAL
- en: how events in a distributed system can be assigned a number which can be used
    for
  prefs: []
  type: TYPE_NORMAL
- en: ordering them by using Lamport clocks.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s run this algorithm on a simple distributed system composed of three
  prefs: []
  type: TYPE_NORMAL
- en: processes (nodes, computers) – P, Q, and R.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key properties of this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If
  prefs: []
  type: TYPE_NORMAL
- en: '*a* → *b*, then LC(a) < LC(b).'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. But
  prefs: []
  type: TYPE_NORMAL
- en: '*LC*( *a*) < *LC*( *b*) does not mean that *a* → *b*.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that two events can have the same timestamp. As shown in Figur[e
    1-25](#p73), on process lines P and R, notice event timestamp 1 as the same. Did
    you spot a problem
  prefs: []
  type: TYPE_NORMAL
- en: here? In this scheme, the total order is not guaranteed because two events can
    get the
  prefs: []
  type: TYPE_NORMAL
- en: same timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-25\.** Example run of a Lamport clock algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: One obvious way to fix this is to use an identifier for the process with the
    timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the total order can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-26 sho](#p74)ws executions with a totally ordered logical clock.
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-74_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-26\.** Example run of a Lamport clock with a total order*'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the order of events in a distributed system is very useful. The order
    of
  prefs: []
  type: TYPE_NORMAL
- en: events allows us to find the causality between the events. The knowledge of
    causality in
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems helps to solve several problems. Some examples include but
    are not
  prefs: []
  type: TYPE_NORMAL
- en: limited to consistency in replicated databases, figuring out causal dependency
    between
  prefs: []
  type: TYPE_NORMAL
- en: different events, measuring the progress of executions in a distributed system,
    and
  prefs: []
  type: TYPE_NORMAL
- en: measuring concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: We can use it to build distributed state machines. If events are timestamped,
    we
  prefs: []
  type: TYPE_NORMAL
- en: can also see when exactly an event has occurred and what happened before and
    what
  prefs: []
  type: TYPE_NORMAL
- en: occurred after, which can help debug and investigate distributed systems’ faults.
    This
  prefs: []
  type: TYPE_NORMAL
- en: knowledge can be instrumental in building debuggers, snapshotting a point in
    time,
  prefs: []
  type: TYPE_NORMAL
- en: pruning some data before a point in time, and many other use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation that *LC*( *a*) < *LC*( *b*) does not mean that *a* → *b*. This
    means that Lamport clocks cannot tell if two events are concurrent or not. This
    problem can be
  prefs: []
  type: TYPE_NORMAL
- en: addressed using vector clocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a type of logical clock which allows detecting concurrent events in addition
    to
  prefs: []
  type: TYPE_NORMAL
- en: determining partial ordering of events and detecting causality violations. Here
    is how
  prefs: []
  type: TYPE_NORMAL
- en: 'it works:'
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: At the start, all vector clocks in a distributed system are set to zero,
  prefs: []
  type: TYPE_NORMAL
- en: that is, [0,0,0,0,0].
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an internal event occurs at a process, the process’s logical
  prefs: []
  type: TYPE_NORMAL
- en: clock value in the vector increments by one.
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-75_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a process sends a message, the process’s logical clock
  prefs: []
  type: TYPE_NORMAL
- en: value in the vector increments by one.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a process receives a message, the process’s logical clock
  prefs: []
  type: TYPE_NORMAL
- en: value in the vector increments by one.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Each element in the vector increments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Faults and Fault Tolerance**'
  prefs: []
  type: TYPE_NORMAL
- en: Faults in a distributed system are inevitable. In fact, distributed systems
    are
  prefs: []
  type: TYPE_NORMAL
- en: characterized by faults. A large body of work is dedicated to fault tolerance
    and is at
  prefs: []
  type: TYPE_NORMAL
- en: the core of the distributed systems research. To understand faults, let’s look
    at a small example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a simplest distributed system with two nodes, shown in Figur[e 1-27](#p75).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-27\.** A simplest distributed system*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about what faults can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: • The processor p1 or p2 may crash.
  prefs: []
  type: TYPE_NORMAL
- en: • Communication link can fail.
  prefs: []
  type: TYPE_NORMAL
- en: • Latency on the communication link.
  prefs: []
  type: TYPE_NORMAL
- en: • Slow processing at p1 or p2\.
  prefs: []
  type: TYPE_NORMAL
- en: • P1 can pretend that it sent some message; in fact, it has not.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be several faults that occur in a distributed system:'
  prefs: []
  type: TYPE_NORMAL
- en: • Process/program faults
  prefs: []
  type: TYPE_NORMAL
- en: • Communication/link faults
  prefs: []
  type: TYPE_NORMAL
- en: • Storage faults
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of faults that have been formally defined in distributed
  prefs: []
  type: TYPE_NORMAL
- en: systems literature. These types are categorized under the so-called fault model
    which
  prefs: []
  type: TYPE_NORMAL
- en: basically tells us which kind of faults can occur.
  prefs: []
  type: TYPE_NORMAL
- en: We now define each one of these as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash-Stop**'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, a process can fail to stop a function at any point in time.
    This can
  prefs: []
  type: TYPE_NORMAL
- en: happen when a hardware fault may have occurred in a node. Other nodes are unable
    to
  prefs: []
  type: TYPE_NORMAL
- en: find out about the crash of the node in this model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fail-Stop**'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, a process can fail by stopping execution of the algorithm. Other
    nodes in
  prefs: []
  type: TYPE_NORMAL
- en: the distributed system can learn about this failure, usually by using failure
    detectors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Omission Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: Omission faults are where a message can be lost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Send Omission**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where a process fails to send a message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Omission**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where a process fails to receive a message.
  prefs: []
  type: TYPE_NORMAL
- en: '**General Omission**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where a process may exhibit either a send omission or a receive omission.
  prefs: []
  type: TYPE_NORMAL
- en: '**Covert Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: This model captures a behavior where a failure might remain hidden or undetected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computation Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we capture the situation where a processor responds incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Byzantine Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: This model captures the arbitrary faults where a process may fail in arbitrarily
  prefs: []
  type: TYPE_NORMAL
- en: many ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byzantine Faults with Authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, a process can exhibit arbitrary behavior; however, there is a
    verification of received messages to this process, which is possible by using
    authentication and digital
  prefs: []
  type: TYPE_NORMAL
- en: signatures. This nonrepudiation and verification can make dealing with Byzantine
    faults
  prefs: []
  type: TYPE_NORMAL
- en: a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byzantine Faults Without Authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, a process can exhibit arbitrary behavior, but no message verification
    is
  prefs: []
  type: TYPE_NORMAL
- en: possible to ascertain the validity of the messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Timing Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where a process can exhibit slow behavior or may run faster than other
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: This can initially look like a partially synchronous behavior, but a node that
    has not
  prefs: []
  type: TYPE_NORMAL
- en: received a message for a very long time can be seen as one example of this type
    of
  prefs: []
  type: TYPE_NORMAL
- en: fault. This covers scenarios where an expected message delivery is not in line
    with the
  prefs: []
  type: TYPE_NORMAL
- en: expected delivery time or lies outside the specified time interval.
  prefs: []
  type: TYPE_NORMAL
- en: Failures can be detected using failure detectors where a process can be suspected
    of
  prefs: []
  type: TYPE_NORMAL
- en: a failure. For example, a message not received for an extended period of time
    or that has gone past the threshold of timeout can be marked as a failed process.
  prefs: []
  type: TYPE_NORMAL
- en: More on failure detector in Chapt[er 3; no](https://doi.org/10.1007/978-1-4842-8179-6_3)w
    let’s discover what a fault model is and fault classes.
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 1-28](#p78), we can visualize various classes of faults, where Byzantine
    faults encompass all types of faults at varying degrees of complexity and can
    happen
  prefs: []
  type: TYPE_NORMAL
- en: arbitrarily, whereas crash faults are the simplest type of faults.
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-78_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-28\.** Diagram of fault models and fault classes*'
  prefs: []
  type: TYPE_NORMAL
- en: Fault classes allow us to see what faults can occur, whereas fault models help
    us
  prefs: []
  type: TYPE_NORMAL
- en: to see what kind of faults the system can exhibit and what types of faults should
    be
  prefs: []
  type: TYPE_NORMAL
- en: tolerated in our distributed algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A system or algorithm that can tolerate crash faults only is called a crash
    fault
  prefs: []
  type: TYPE_NORMAL
- en: tolerant or CFT in short. In contrast, a system that can handle Byzantine faults
    is called the Byzantine fault–tolerant system or algorithm. Usually, this applies
    to consensus
  prefs: []
  type: TYPE_NORMAL
- en: mechanisms categorized and developed with the goal of crash fault tolerance
    or
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine fault tolerance. We will see more about this in Chapt[er 3, wher](https://doi.org/10.1007/978-1-4842-8179-6_3)e
    we discuss consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety and Liveness**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed in communication abstractions that broadcast protocols
    and
  prefs: []
  type: TYPE_NORMAL
- en: point-to-point links have some properties. For example, a fair-loss property
    ensures that messages sent will eventually be delivered under fair-loss links.
    This type of property
  prefs: []
  type: TYPE_NORMAL
- en: where something will eventually happen is considered a liveness property. Colloquially
  prefs: []
  type: TYPE_NORMAL
- en: speaking, this means that something good will eventually occur.
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that under the finite duplication property for fair-loss links,
    we said
  prefs: []
  type: TYPE_NORMAL
- en: that there are finite message duplications. This type of property where something
    can be
  prefs: []
  type: TYPE_NORMAL
- en: measured and observed infinite time is called a safety property. Colloquially
    speaking,
  prefs: []
  type: TYPE_NORMAL
- en: this means that something bad never happens. Of course, if you don’t do anything,
    then
  prefs: []
  type: TYPE_NORMAL
- en: nothing will ever happen, which theoretically satisfies the safety property;
    however, the system is not making any progress in this scenario. Therefore, the
    liveness property,
  prefs: []
  type: TYPE_NORMAL
- en: which ensures the progress of the system, is also necessary.
  prefs: []
  type: TYPE_NORMAL
- en: These properties are used in many different distributed algorithms to reason
    about
  prefs: []
  type: TYPE_NORMAL
- en: the correctness of the protocols. In addition, they are frequently used in describing
    the safety and liveness requirements and properties of consensus protocols. We
    will cover
  prefs: []
  type: TYPE_NORMAL
- en: distributed consensus in detail in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  prefs: []
  type: TYPE_NORMAL
- en: Safety and liveness are correctness properties of a distributed algorithm. For
  prefs: []
  type: TYPE_NORMAL
- en: example, the safety and liveness of traffic signals at a crossing can be described
    as
  prefs: []
  type: TYPE_NORMAL
- en: follows. The safety properties in this scenario are that, at a time, only one
    direction must be a green light, and no signal should have all lights turned on
    at the same time. Another safety property could be that the system should turn
    off no signals. And the liveness
  prefs: []
  type: TYPE_NORMAL
- en: property is that, eventually, each signal must get the green light.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a partially synchronous system, to prove safety properties,
    it is
  prefs: []
  type: TYPE_NORMAL
- en: assumed that the system is asynchronous, whereas to prove the liveness of the
    system,
  prefs: []
  type: TYPE_NORMAL
- en: the partial synchrony assumption is used. The progress of liveness of the system
    is
  prefs: []
  type: TYPE_NORMAL
- en: ensured in a partially synchronous system, for example, after GST when the system
  prefs: []
  type: TYPE_NORMAL
- en: is synchronous for long enough to allow the algorithm to achieve its objective
    and
  prefs: []
  type: TYPE_NORMAL
- en: terminate.
  prefs: []
  type: TYPE_NORMAL
- en: For a distributed system to be practical, safety and liveness properties must
    be
  prefs: []
  type: TYPE_NORMAL
- en: specified and guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forms of Fault Tolerance**'
  prefs: []
  type: TYPE_NORMAL
- en: A correct program (distributed algorithm) satisfies both its safety and liveness
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: If a program tolerates a given class of faults and remains alive and safe, we
    call this type of fault tolerance masking. If a program can remain safe but not
    live, we call this type of fault tolerance fail-safe. Similarly, in the presence
    of faults, a program cannot remain
  prefs: []
  type: TYPE_NORMAL
- en: safe (not safe) but remains live. Such behavior is called nonmasking. If a program
    is
  prefs: []
  type: TYPE_NORMAL
- en: neither live nor safe in the presence of faults, it means that this program
    does not depict any form of fault tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**CAP Theorem**'
  prefs: []
  type: TYPE_NORMAL
- en: The CAP theorem states that a distributed system can only deliver two of three
    desired
  prefs: []
  type: TYPE_NORMAL
- en: features, that is, consistency, availability, and partition tolerance. Let’s
    first define these terms, and then we’ll investigate the theorem in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**'
  prefs: []
  type: TYPE_NORMAL
- en: The consistency property means that data should be consistent across all nodes
    in the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system, and the client connecting to the distributed system at the
    same time
  prefs: []
  type: TYPE_NORMAL
- en: should see the same consistent data. This is commonly achieved using replication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability**'
  prefs: []
  type: TYPE_NORMAL
- en: Availability means the distributed system responds to the client requests even
    in the
  prefs: []
  type: TYPE_NORMAL
- en: presence of faults. This is achieved using fault tolerance techniques such as
    replication, partitioning, or sharding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition Tolerance**'
  prefs: []
  type: TYPE_NORMAL
- en: A partition refers to a scenario where the communication link between two or
    more
  prefs: []
  type: TYPE_NORMAL
- en: nodes breaks. A distributed system should be able to tolerate that and continue
    to
  prefs: []
  type: TYPE_NORMAL
- en: operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We know that partitions in a network are almost inevitable; sooner or later,
    there
  prefs: []
  type: TYPE_NORMAL
- en: will be some communication disruption. This means that as network partitions
    are
  prefs: []
  type: TYPE_NORMAL
- en: unavoidable, the choice really becomes to choose between availability and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The question becomes, in the case of partitions, what we are willing to sacrifice,
  prefs: []
  type: TYPE_NORMAL
- en: consistency or availability. It all depends on the use case. For example, in
    a financial
  prefs: []
  type: TYPE_NORMAL
- en: application, it’s best to sacrifice availability in favor of consistency, but
    perhaps on web search results, we could sacrifice a bit of consistency in favor
    of availability. It should be noted that when there are no network partitions,
    consistency and availability are
  prefs: []
  type: TYPE_NORMAL
- en: both provided. But then again, if a network partition occurs, then what do we
    choose,
  prefs: []
  type: TYPE_NORMAL
- en: availability or consistency?
  prefs: []
  type: TYPE_NORMAL
- en: A Venn diagram shown in Figure [1-29](#p81) can be used to visualize this concept.
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-81_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-29\.** CAP theorem*'
  prefs: []
  type: TYPE_NORMAL
- en: The CAP theorem allows us to categorize databases (NoSQL DBs) based on the
  prefs: []
  type: TYPE_NORMAL
- en: properties they support. For example, a CP database provides consistency and
    partition
  prefs: []
  type: TYPE_NORMAL
- en: tolerance but sacrifices availability. In the case of a partition, the nonconsistent
    nodes are shut down until the network partition heals. An AP database sacrifices
    consistency
  prefs: []
  type: TYPE_NORMAL
- en: but offers availability and partition tolerance. In the case of a network partition,
    there is a chance that nodes that have not been able to get the updates due to
    a network
  prefs: []
  type: TYPE_NORMAL
- en: partition will continue to serve old data. This might be acceptable in some
    scenarios,
  prefs: []
  type: TYPE_NORMAL
- en: such as a web search. When the partition heals, the out-of-sync nodes are synchronized
  prefs: []
  type: TYPE_NORMAL
- en: with the latest updates. On the other hand, a CA database is not partition tolerant
    and
  prefs: []
  type: TYPE_NORMAL
- en: can provide both consistency and availability only if the network is healthy.
    As we saw
  prefs: []
  type: TYPE_NORMAL
- en: earlier, network partitions are inevitable; therefore, CA databases only exist
    in an ideal world where no network partitions occur.
  prefs: []
  type: TYPE_NORMAL
- en: While the CAP theorem is helpful, there are many other more precise impossibility
  prefs: []
  type: TYPE_NORMAL
- en: results in distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now discuss what eventual consistency is. Eventual consistency refers
    to a
  prefs: []
  type: TYPE_NORMAL
- en: situation where nodes may disagree or not update their local database, but,
    eventually,
  prefs: []
  type: TYPE_NORMAL
- en: the state is agreed upon and updated.
  prefs: []
  type: TYPE_NORMAL
- en: One example of such a scenario could be when an electronic voting system captures
  prefs: []
  type: TYPE_NORMAL
- en: voters’ votes and writes them to a central vote registration system. However,
    it could
  prefs: []
  type: TYPE_NORMAL
- en: happen that due to a network partition, the communication link in the central
    vote
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: registration system is lost, and this voting machine is now not able to write
    data to the backend voting registration system. It could now keep receiving votes
    from the user and
  prefs: []
  type: TYPE_NORMAL
- en: record them locally, and when the network partition heals, it can write the
    ballots back
  prefs: []
  type: TYPE_NORMAL
- en: to the central vote registration system. During the network partition from the
    central vote registration system’s point of view, the count of votes is different
    from what the voting machine can see. The machine can write back to the central
    vote registration system
  prefs: []
  type: TYPE_NORMAL
- en: when the partition heals to achieve consistency. The consistency between the
    backend
  prefs: []
  type: TYPE_NORMAL
- en: server storage and local storage is not achieved immediately, but, over time,
    this type of consistency is called eventual consistency.
  prefs: []
  type: TYPE_NORMAL
- en: A now established example of an eventually consistent system is Bitcoin. We
    will
  prefs: []
  type: TYPE_NORMAL
- en: learn more about this in Chapt[er 4](https://doi.org/10.1007/978-1-4842-8179-6_4)
    and see how Bitcoin is eventually consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The domain name system (DNS) is the most prevalent system that implements
  prefs: []
  type: TYPE_NORMAL
- en: eventual consistency. When a name is updated, it is distributed as per a configured
  prefs: []
  type: TYPE_NORMAL
- en: pattern, and, eventually, all clients see the update.
  prefs: []
  type: TYPE_NORMAL
- en: Through the lens of the CAP theorem, the distributed consensus is a CP system
  prefs: []
  type: TYPE_NORMAL
- en: where availability is sacrificed in favor of consistency. As a result, the distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus is used to provide strong consistency guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a five-node system and three nodes go down, then the
  prefs: []
  type: TYPE_NORMAL
- en: whole system stalls until the other three nodes come up. This is so that a consistency
  prefs: []
  type: TYPE_NORMAL
- en: guarantee can be maintained, even if the system is not available for some time.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at Bitcoin, it appears that it is an AP system where consistency
    is sacrificed for some time due to forks, but, eventually, the consistency is
    achieved. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin can also be considered a CP system where consistency is eventually strong.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, strong consistency (also called linearizability) is for what distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus is used for; however, eventual consistency in systems like Bitcoin
    is also
  prefs: []
  type: TYPE_NORMAL
- en: acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptography in Distributed Systems**'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems operate under challenging conditions where they are exposed
    to
  prefs: []
  type: TYPE_NORMAL
- en: adversaries, faults, and untrusted users. In such conditions, it becomes critical
    to protect the distributed system against all these threats. Therefore, appropriate
    security measures are put in place to thwart any attempts to disrupt the system.
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: The usual security services required in a distributed system include confidentiality,
  prefs: []
  type: TYPE_NORMAL
- en: integrity, access control, and authentication. To this end, cryptography plays
    a vital role in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic protocols provide security services in a distributed system by
    utilizing
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic primitives such as symmetric cryptography, asymmetric cryptography,
  prefs: []
  type: TYPE_NORMAL
- en: and hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this topic in Chapter [2, wher](https://doi.org/10.1007/978-1-4842-8179-6_2)e
    we study cryptography in general and its applications in distributed systems and
    blockchain. Chapter [2](https://doi.org/10.1007/978-1-4842-8179-6_2) will introduce
    several primitives that are useful in consensus protocols and blockchain for achieving
    data
  prefs: []
  type: TYPE_NORMAL
- en: integrity and relevant security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered several topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: • A distributed system is a set of interconnected computers
  prefs: []
  type: TYPE_NORMAL
- en: coordinating together via messages to achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: • Distributed systems face several challenges. The most prominent are
  prefs: []
  type: TYPE_NORMAL
- en: (1) no common global knowledge, (2) no global time, (3) achieving
  prefs: []
  type: TYPE_NORMAL
- en: consistency, and (4) failures.
  prefs: []
  type: TYPE_NORMAL
- en: • A distributed system model allows us to reason about the system and
  prefs: []
  type: TYPE_NORMAL
- en: abstract away all unnecessary details.
  prefs: []
  type: TYPE_NORMAL
- en: • The leap second bug that is a cause of significant disruption of
  prefs: []
  type: TYPE_NORMAL
- en: Internet services and several techniques has been developed to
  prefs: []
  type: TYPE_NORMAL
- en: address this.
  prefs: []
  type: TYPE_NORMAL
- en: • Safety and liveness properties must be ensured in distributed
  prefs: []
  type: TYPE_NORMAL
- en: systems.
  prefs: []
  type: TYPE_NORMAL
- en: • Crash fault–tolerant distributed algorithms only handle crash faults,
  prefs: []
  type: TYPE_NORMAL
- en: whereas Byzantine fault–tolerant algorithms are designed to handle
  prefs: []
  type: TYPE_NORMAL
- en: arbitrary faults.
  prefs: []
  type: TYPE_NORMAL
- en: • Logical clocks do not depend on physical clocks and can be used to
  prefs: []
  type: TYPE_NORMAL
- en: define the order of events in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: • In a distributed system, the same algorithm runs on all computers
  prefs: []
  type: TYPE_NORMAL
- en: concurrently to achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: • The CAP theorem states that a distributed system can only deliver
  prefs: []
  type: TYPE_NORMAL
- en: two of three desired features, that is, consistency, availability, and
  prefs: []
  type: TYPE_NORMAL
- en: partition tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Safety and liveness properties were first formalized in a paper
  prefs: []
  type: TYPE_NORMAL
- en: by Alpern, B. and Schneider, F.B., 1987\. Recognizing safety and
  prefs: []
  type: TYPE_NORMAL
- en: liveness. Distributed computing, 2(3), pp. 117–126\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Notion of timing and ordering of events was first introduced in
  prefs: []
  type: TYPE_NORMAL
- en: 1978 in "Lamport, L., 2019\. Time, clocks, and the ordering of
  prefs: []
  type: TYPE_NORMAL
- en: 'events in a distributed system. In Concurrency: the Works of Leslie'
  prefs: []
  type: TYPE_NORMAL
- en: Lamport (pp. 179–196)."
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Cachin, C., Guerraoui, R., and Rodrigues, L., 2011\. Introduction to
  prefs: []
  type: TYPE_NORMAL
- en: reliable and secure distributed programming. Springer Science &
  prefs: []
  type: TYPE_NORMAL
- en: Business Media.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Brewer, E.A., 2000, July. Towards robust distributed systems. In
  prefs: []
  type: TYPE_NORMAL
- en: PODC (Vol. 7, No. 10.1145, pp. 343477–343502).
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Van Steen, M. and Tanenbaum, A., 2002\. Distributed systems
  prefs: []
  type: TYPE_NORMAL
- en: principles and paradigms. Network, 2, p. 28\.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Coulouris, G., Dollimore, J., and Kindberg, T. Distributed Systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and Design Edition 3\. System, 2(11), p. 15\.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Kleppmann, M., 2017\. Designing data-intensive applications: The'
  prefs: []
  type: TYPE_NORMAL
- en: big ideas behind reliable, scalable, and maintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: O’Reilly Media, Inc.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Kleppmann, M., Distributed Systems. Vancouver.
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Sapphire clocks[: https://sciencemeetsbusiness.com.au/](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[sapphire-clock/](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Sapphire clocks[: https://spectrum.ieee.org/for-precision-](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)
  prefs: []
  type: TYPE_NORMAL
- en: '[the-sapphire-clock-outshines-even-the-best-atomic-](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
  prefs: []
  type: TYPE_NORMAL
- en: '[clocks?utm_campaign=post-teaser&utm_content=7190c3vu](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Baran, Paul. On Distributed Communications: I. Introduction to'
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributed Communications Networks. Santa Monica, CA: RAND'
  prefs: []
  type: TYPE_NORMAL
- en: Corporation, 1964\. [www.rand.org/pubs/research_memoranda/](http://www.rand.org/pubs/research_memoranda/RM3420.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[RM3420.html. Als](http://www.rand.org/pubs/research_memoranda/RM3420.html)o
    available in print form.'
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptography**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover cryptography and its two main types, symmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: and public key cryptography. After exploring some fundamental ideas, we will
    dive
  prefs: []
  type: TYPE_NORMAL
- en: deeper into symmetric key primitives and then public key primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we will examine hash functions, message authentication codes, digital
  prefs: []
  type: TYPE_NORMAL
- en: signature schemes, and elliptic curve cryptography. Finally, we’ll shed some
    light on
  prefs: []
  type: TYPE_NORMAL
- en: some progressive ideas, proposals, and techniques, especially those which are
    used in
  prefs: []
  type: TYPE_NORMAL
- en: blockchain consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is the science of secret communication in the presence of adversaries.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, this subject was more of an art, but, now, it is a rigorous and
    formal science with formal definitions, assumptions, and security proofs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three fundamental principles of cryptography: confidentiality, integrity,'
  prefs: []
  type: TYPE_NORMAL
- en: and authenticity. Confidentiality is the assurance that the information is available
    only to the authorized entities. Integrity assures that only authorized entities
    can modify the information. Finally, authenticity guarantees the message validity
    or identity of an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication can be of two types, entity authentication or data origin authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Entity authentication ensures that an entity claiming some identity (the claimant)
  prefs: []
  type: TYPE_NORMAL
- en: is verifiably identifiable to another identity (the verifier) and that the entity
    is alive and participating. Different methods such as something you have (e.g.,
    a hardware token),
  prefs: []
  type: TYPE_NORMAL
- en: something you know (e.g., a password), and something you are (e.g., fingerprint)
    are
  prefs: []
  type: TYPE_NORMAL
- en: used to achieve entity authentication in identification protocols. Entity authentication
  prefs: []
  type: TYPE_NORMAL
- en: is of a fundamental concern in a secure distributed system. As a distributed
    system
  prefs: []
  type: TYPE_NORMAL
- en: is dispersed and heterogenous, with multiple users, it can become an easy target
    for
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_2](https://doi.org/10.1007/978-1-4842-8179-6_2#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-87_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: adversarial attacks. Especially in the case of blockchains and specifically
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocols running on blockchains, entity authentication is of prime importance
    to
  prefs: []
  type: TYPE_NORMAL
- en: ensure protection against adversarial attacks. Authentication protocols are
    built using
  prefs: []
  type: TYPE_NORMAL
- en: symmetric and public key cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Another related assurance is nonrepudiation, where an entity after performing
    an
  prefs: []
  type: TYPE_NORMAL
- en: action cannot deny its action. Usually, this is achieved by digital signatures.
    In addition to two-party protocols, there also are multiparty nonrepudiation protocols
    that are
  prefs: []
  type: TYPE_NORMAL
- en: suitable for multiple parties.
  prefs: []
  type: TYPE_NORMAL
- en: Data origin authentication or message authentication ensures that the source
    of
  prefs: []
  type: TYPE_NORMAL
- en: information is authentic and verified. Message authentication codes (MACs) and
    digital
  prefs: []
  type: TYPE_NORMAL
- en: signatures are used to provide data origin authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Typical Cryptosystem**'
  prefs: []
  type: TYPE_NORMAL
- en: A typical model of a cryptographic system is shown in Figur[e 2-1\. W](#p87)e
    can define a cryptographic system as a combined manifestation of cryptographic
    primitives,
  prefs: []
  type: TYPE_NORMAL
- en: protocols, and algorithms to accomplish specified security goals. Thus, a cryptosystem
    is composed of several components.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-1\.** A model of a cryptographic system or cryptographic scheme*'
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three key actors in this system: sender, receiver, and adversary.
    The sender'
  prefs: []
  type: TYPE_NORMAL
- en: wants to send a secret message to the receiver via an insecure channel in the
    presence
  prefs: []
  type: TYPE_NORMAL
- en: of an adversary who is a malicious attacker wishing to learn about the message.
    Other
  prefs: []
  type: TYPE_NORMAL
- en: 'elements are plaintext, ciphertext, keys, secure channel, encryption function,
    decryption function, and key source:'
  prefs: []
  type: TYPE_NORMAL
- en: • A sender is the sending party of the message.
  prefs: []
  type: TYPE_NORMAL
- en: • A receiver is the intended recipient of the message.
  prefs: []
  type: TYPE_NORMAL
- en: • An encryption function is the encryption algorithm which transforms
  prefs: []
  type: TYPE_NORMAL
- en: a plaintext into ciphertext by using an encryption key and plaintext
  prefs: []
  type: TYPE_NORMAL
- en: as input.
  prefs: []
  type: TYPE_NORMAL
- en: • A decryption function is the decryption algorithm which converts
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext into plaintext by using a decryption key and ciphertext
  prefs: []
  type: TYPE_NORMAL
- en: as input.
  prefs: []
  type: TYPE_NORMAL
- en: • Plaintext is the raw message which Alice wants to send to Bob in
  prefs: []
  type: TYPE_NORMAL
- en: such a way that no one learns about the original message except the
  prefs: []
  type: TYPE_NORMAL
- en: intended recipient. It is readable and accessible by Alice and any
  prefs: []
  type: TYPE_NORMAL
- en: authorized entity.
  prefs: []
  type: TYPE_NORMAL
- en: • Ciphertext is the scrambled form of the plaintext, which unless
  prefs: []
  type: TYPE_NORMAL
- en: decrypted is meaningless to anyone reading it.
  prefs: []
  type: TYPE_NORMAL
- en: • A key source is a key management system or some source of
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic keys from which keys are obtained or generated.
  prefs: []
  type: TYPE_NORMAL
- en: • A key is some value that is used to encrypt and/or decrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: • A secure channel is some channel through which messages can pass
  prefs: []
  type: TYPE_NORMAL
- en: unencrypted without the possibility of eavesdropping.
  prefs: []
  type: TYPE_NORMAL
- en: • An adversary is some malicious hacker (or eavesdropper, observer)
  prefs: []
  type: TYPE_NORMAL
- en: who can read the encrypted data and tries to learn some information
  prefs: []
  type: TYPE_NORMAL
- en: by cryptanalyzing it or by some other means.
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-89_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptographic Primitives**'
  prefs: []
  type: TYPE_NORMAL
- en: A cryptographic primitive is a fundamental method that delivers particular security
  prefs: []
  type: TYPE_NORMAL
- en: services, for example, confidentiality or integrity. These cryptographic primitives
    are
  prefs: []
  type: TYPE_NORMAL
- en: used to build security protocols, such as authentication protocols. Cryptographic
  prefs: []
  type: TYPE_NORMAL
- en: primitives include symmetric primitives, asymmetric primitives, and keyless
    primitives.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level taxonomy of cryptographic primitives is shown in Figure [2-2](#p89).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-2\.** Cryptographic primitives*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s have a look at the symmetric primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric Cryptography**'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptosystems use the same key for encryption and decryption. The
    key
  prefs: []
  type: TYPE_NORMAL
- en: must be kept secret and transferred over a secure channel before the data transfer
  prefs: []
  type: TYPE_NORMAL
- en: between a sender and a receiver. For secure key transfers, key establishment
    protocols
  prefs: []
  type: TYPE_NORMAL
- en: are used. Usually, public key cryptography is used to exchange keys, allowing
    for easier
  prefs: []
  type: TYPE_NORMAL
- en: key management than symmetric key management, where it can become challenging
    to
  prefs: []
  type: TYPE_NORMAL
- en: manage keys as the number of users grows.
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-90_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of designing symmetric cryptography algorithms is to provide
  prefs: []
  type: TYPE_NORMAL
- en: confidentiality, but we can also use them to provide other security services,
    such as data origin authentication.
  prefs: []
  type: TYPE_NORMAL
- en: There are two classes of symmetric cryptosystems, stream ciphers and block ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-3 sho](#p90)ws how stream and block ciphers operate at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-3\.** Stream (left) vs. block ciphers (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream Ciphers**'
  prefs: []
  type: TYPE_NORMAL
- en: These cryptosystems encrypt the plaintext one bit at a time. The algorithm takes
    a single bit of the plaintext as input, processes it, and produces a single bit
    of ciphertext. The processing involves the use of XOR operations to perform encryption
    and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The model of stream ciphers is in Figure [2-4](#p91).
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-91_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-4\.** Stream cipher model*'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, plaintext feeds into the encryption function bit by bit along
    with a
  prefs: []
  type: TYPE_NORMAL
- en: keystream generated by the key generator. The key generator generates a pseudorandom
  prefs: []
  type: TYPE_NORMAL
- en: keystream which is usually much smaller than the plaintext. Usually, the key
    length is
  prefs: []
  type: TYPE_NORMAL
- en: 128 bits. The keystream and plaintext go through the XOR to produce the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: During decryption, the same process applies again, and plaintext is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudorandom generation means that the bits generated are not random but appear
  prefs: []
  type: TYPE_NORMAL
- en: random, hence the term pseudorandom. Keystreams are commonly generated using
  prefs: []
  type: TYPE_NORMAL
- en: linear feedback shift registers (LFSRs). The input bit of LFSR is a linear function
    of its previous state, where the linear function is usually the XOR operation.
  prefs: []
  type: TYPE_NORMAL
- en: The key generator is a cryptographically secure pseudorandom number generator
  prefs: []
  type: TYPE_NORMAL
- en: (CSPRNG or CPRNG). Being “pseudo,” we can compute the number, and anyone
  prefs: []
  type: TYPE_NORMAL
- en: computing it will have the same result, which implies that these PRNGs are also
  prefs: []
  type: TYPE_NORMAL
- en: deterministic. If they are truly random and not deterministic, then once generated,
  prefs: []
  type: TYPE_NORMAL
- en: the random number cannot be regenerated by anyone else, meaning the decryption
  prefs: []
  type: TYPE_NORMAL
- en: won’t be possible. So, they look random, but actually they are not and are computable.
  prefs: []
  type: TYPE_NORMAL
- en: CPRNGs have a particular property that the numbers they generate are unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of stream ciphers: synchronous stream ciphers and'
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous stream ciphers. In synchronous stream ciphers, the keystream is
  prefs: []
  type: TYPE_NORMAL
- en: dependent only on the key. In contrast, the keystream relies on the fixed number
    of
  prefs: []
  type: TYPE_NORMAL
- en: previously transmitted encrypted bits and the key in asynchronous stream ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-92_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Stream ciphers are usually more suited for hardware devices; however, they can
    also
  prefs: []
  type: TYPE_NORMAL
- en: be used in software environments. Many examples of stream ciphers exist, such
    as A5/1,
  prefs: []
  type: TYPE_NORMAL
- en: used in GSM communications to provide confidentiality. However, Salsa20 and
    ChaCha
  prefs: []
  type: TYPE_NORMAL
- en: are most used in software environments. Some other stream ciphers include Trivium,
  prefs: []
  type: TYPE_NORMAL
- en: Rabbit, RC4, and SEAL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Ciphers**'
  prefs: []
  type: TYPE_NORMAL
- en: Block ciphers encrypt the plaintext by dividing it into blocks of fixed length.
    Historically, block ciphers, such as DES, were built using Feistel mechanisms.
    Modern ciphers, such
  prefs: []
  type: TYPE_NORMAL
- en: as AES, use a substitution-permutation network (SPN).
  prefs: []
  type: TYPE_NORMAL
- en: A simple model of a block cipher is shown in Figur[e 2-5\.](#p92)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-5\.** Block cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: The model shown in Figur[e 2-5 com](#p92)prises plaintext, encryption, and ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: The encrypter takes the plaintext in fixed-length blocks and the secret key
    as input and
  prefs: []
  type: TYPE_NORMAL
- en: produces the ciphertext blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Block ciphers are primarily used for encryption but can be used to build hash
  prefs: []
  type: TYPE_NORMAL
- en: functions, create stream ciphers, and build pseudorandom number generators and
  prefs: []
  type: TYPE_NORMAL
- en: message authentication codes.
  prefs: []
  type: TYPE_NORMAL
- en: There are two necessary properties that encryption tries to achieve, confusion
    and
  prefs: []
  type: TYPE_NORMAL
- en: diffusion. Confusion adds obscurity to the relationship between the encrypted
    text and
  prefs: []
  type: TYPE_NORMAL
- en: the plaintext. It is achieved by using substitution, which is performed by lookup
    tables
  prefs: []
  type: TYPE_NORMAL
- en: called S-boxes in modern encryption algorithms, such as AES.
  prefs: []
  type: TYPE_NORMAL
- en: Diffusion ensures that plaintext statistically spreads over the encrypted data.
    In other
  prefs: []
  type: TYPE_NORMAL
- en: words, it ensures that even if a single bit changes in the plaintext, the ciphertext
    changes so much that the relationship between the plaintext and the ciphertext
    is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it hides the statistical properties of the plaintext to thwart
    statistical 73
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: analysis attacks. In addition, permutation boxes provide diffusion in modern
    encryption
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, such as AES. Thus, both confusion and diffusion are combined to
    create
  prefs: []
  type: TYPE_NORMAL
- en: secure cipher algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Encryption Standard (DES) was developed in the 1970s and was used
  prefs: []
  type: TYPE_NORMAL
- en: widely in the 1980s and 1990s. Over time, due to technological advancements,
    the
  prefs: []
  type: TYPE_NORMAL
- en: efficacy of DES started to decrease. It was mainly due to its smaller 56-bit
    key length.
  prefs: []
  type: TYPE_NORMAL
- en: After some successful brute-force attacks in the late 1990s, such as deep crack
    and
  prefs: []
  type: TYPE_NORMAL
- en: COPACOBANA, it became clear that the DES was no longer secure. As a result,
    triple
  prefs: []
  type: TYPE_NORMAL
- en: DES was introduced, which encrypts three times in a row (triple encryption)
    to increase
  prefs: []
  type: TYPE_NORMAL
- en: the key length to 112 bits essentially. It helped to protect against brute-force
    attacks, and indeed triple DES is still unbreakable today. However, NIST finally
    replaced DES with
  prefs: []
  type: TYPE_NORMAL
- en: AES due to concerns over slow performance and 64-bit block size in 2001\.
  prefs: []
  type: TYPE_NORMAL
- en: There are different modes in which block ciphers work. These modes enable block
  prefs: []
  type: TYPE_NORMAL
- en: ciphers to not only provide confidentiality but also integrity and authenticity.
    Some of
  prefs: []
  type: TYPE_NORMAL
- en: the modes include
  prefs: []
  type: TYPE_NORMAL
- en: • Electronic codebook mode
  prefs: []
  type: TYPE_NORMAL
- en: • Cipher block chaining mode
  prefs: []
  type: TYPE_NORMAL
- en: • Counter mode
  prefs: []
  type: TYPE_NORMAL
- en: • Cipher feedback (CFB) mode
  prefs: []
  type: TYPE_NORMAL
- en: • Galois/Counter Mode (GCM)
  prefs: []
  type: TYPE_NORMAL
- en: • Output feedback (OFB) mode
  prefs: []
  type: TYPE_NORMAL
- en: We will explain just three modes here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Codebook**'
  prefs: []
  type: TYPE_NORMAL
- en: Electronic codebook (ECB) is a fundamental mode of operation in which the encrypted
  prefs: []
  type: TYPE_NORMAL
- en: data results from applying the encryption algorithm to each block of plaintext,
  prefs: []
  type: TYPE_NORMAL
- en: one by one.
  prefs: []
  type: TYPE_NORMAL
- en: This mode is the most straightforward, but we should not use it in practice
    as it is
  prefs: []
  type: TYPE_NORMAL
- en: insecure and can reveal information.
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-94_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-94_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-6\.** Electronic codebook mode for block ciphers*'
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-6 sho](#p94)ws that we have plaintext P provided as an input to the
    block cipher encryption function and a key, which produces ciphertext C as output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cipher Block Chaining**'
  prefs: []
  type: TYPE_NORMAL
- en: In cipher block chaining (CBC) mode, each plaintext block is XORed with the
    previously
  prefs: []
  type: TYPE_NORMAL
- en: encrypted block. CBC mode uses the IV to encrypt the first block. The IV must
    be
  prefs: []
  type: TYPE_NORMAL
- en: randomly chosen. CBC mode operation is shown in Figur[e 2-7\.](#p94)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-7\.** Cipher block chaining mode*'
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-95_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: The counter (CTR) mode uses a block cipher as a stream cipher. In this case,
    a unique
  prefs: []
  type: TYPE_NORMAL
- en: nonce is concatenated with the counter value to generate a keystream.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in Figur[e 2-8](#p95), CTR mode works by utilizing a nonce N and a
    counter C that feed into the block cipher encryption function. The block cipher
    encryption
  prefs: []
  type: TYPE_NORMAL
- en: function takes the secret key “KEY” as input and produces a keystream (a stream
    of
  prefs: []
  type: TYPE_NORMAL
- en: pseudorandom or random characters), which, when XORed with the plaintext (P),
  prefs: []
  type: TYPE_NORMAL
- en: generates the ciphertext (C).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-8\.** Counter mode*'
  prefs: []
  type: TYPE_NORMAL
- en: There are other modes that we can use for different purposes other than encryption.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss some of these in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keystream Generation Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: In keystream generation mode, the encryption function generates a keystream.
    Stream
  prefs: []
  type: TYPE_NORMAL
- en: ciphers use this keystream where it is XORed with the plaintext stream to produce
    the
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Authentication Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: A message authentication code (MAC) is produced from an encryption function
    in the
  prefs: []
  type: TYPE_NORMAL
- en: message authentication mode. A MAC is a cryptographic checksum that provides
    the
  prefs: []
  type: TYPE_NORMAL
- en: integrity service. Block ciphers in the cipher block chaining mode (CBC mode)
    are used
  prefs: []
  type: TYPE_NORMAL
- en: to generate MACs. We can use a MAC to check if an unauthorized entity has modified
    a
  prefs: []
  type: TYPE_NORMAL
- en: message. We achieve this by encrypting the message with a key using the MAC
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the receivers check the message’s MAC by encrypting the received message
    again
  prefs: []
  type: TYPE_NORMAL
- en: with the key and comparing it with the received MAC. If they match, it means
    that no
  prefs: []
  type: TYPE_NORMAL
- en: unauthorized entity has modified the message; thus, an integrity service is
    provided. If
  prefs: []
  type: TYPE_NORMAL
- en: they don’t match, then it means that some unauthorized entity has altered the
    message
  prefs: []
  type: TYPE_NORMAL
- en: during transmission.
  prefs: []
  type: TYPE_NORMAL
- en: Any block cipher such as AES in CBC mode can generate a MAC. The MAC of
  prefs: []
  type: TYPE_NORMAL
- en: the message is the output of the last round of the CBC operation. The length
    of the
  prefs: []
  type: TYPE_NORMAL
- en: MAC output is the same as the block length of the block cipher used to generate
  prefs: []
  type: TYPE_NORMAL
- en: the MAC. Even though MACs work like digital signatures, they cannot provide
    the
  prefs: []
  type: TYPE_NORMAL
- en: nonrepudiation service due to their symmetric nature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptographic Hash Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are primarily used to compress a message to a fixed-length digest.
    Block
  prefs: []
  type: TYPE_NORMAL
- en: ciphers in cryptographic hash mode can also be used as a compression function
    to
  prefs: []
  type: TYPE_NORMAL
- en: produce a hash.
  prefs: []
  type: TYPE_NORMAL
- en: Now we describe the Advanced Encryption Standard (AES) in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Encryption Standard**'
  prefs: []
  type: TYPE_NORMAL
- en: AES was originally named Rijndael, after its inventors’ names Joan Daemen and
    Vincent
  prefs: []
  type: TYPE_NORMAL
- en: Rijmen. It was standardized as Advanced Encryption Standard (AES) by NIST in
    2001
  prefs: []
  type: TYPE_NORMAL
- en: after an open competition.
  prefs: []
  type: TYPE_NORMAL
- en: In the original version of Rijndael, different key and block sizes of 128 bits,
    192 bits, and 256 bits are allowed. However, only a 128-bit block size and key
    sizes of 128 bits, 192
  prefs: []
  type: TYPE_NORMAL
- en: bits, and 256 bits are allowed in AES.
  prefs: []
  type: TYPE_NORMAL
- en: AES processes an array of bytes of size 4 x 4 called state in multiple rounds
  prefs: []
  type: TYPE_NORMAL
- en: depending on the key size. For example, if the key length is 128 bits, 10 rounds
    are
  prefs: []
  type: TYPE_NORMAL
- en: required; for 192 bits, it needs 12 rounds; and for 256 bits, it needs 14 rounds.
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: After state initialization using the input plaintext, AES sequentially performs
    the
  prefs: []
  type: TYPE_NORMAL
- en: 'following four operations to produce the ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **AddRoundKey**: First, the state array is XORed with a subkey derived'
  prefs: []
  type: TYPE_NORMAL
- en: from the master key.
  prefs: []
  type: TYPE_NORMAL
- en: '• **SubBytes**: This step performs **byte substitution** where a fixed lookup'
  prefs: []
  type: TYPE_NORMAL
- en: table (S-box) is used to replace all bytes of the 4 x 4 state array.
  prefs: []
  type: TYPE_NORMAL
- en: '• **ShiftRows**: This step shifts each row to the left in the state array in
    a'
  prefs: []
  type: TYPE_NORMAL
- en: cyclic and incremental manner. The first row is excluded, the second
  prefs: []
  type: TYPE_NORMAL
- en: row is shifted left by one byte, the third row is shifted left by two bytes,
  prefs: []
  type: TYPE_NORMAL
- en: and the fourth row is shifted left by three bytes or positions.
  prefs: []
  type: TYPE_NORMAL
- en: '• **MixColumns**: Finally, all bytes are mixed in a linear fashion (i.e.,'
  prefs: []
  type: TYPE_NORMAL
- en: linear transformation), where four bytes of the column are taken as
  prefs: []
  type: TYPE_NORMAL
- en: input by this function, and four new bytes are produced as output
  prefs: []
  type: TYPE_NORMAL
- en: which replaces the input column.
  prefs: []
  type: TYPE_NORMAL
- en: The abovementioned four steps form a single round of AES. In the final round,
  prefs: []
  type: TYPE_NORMAL
- en: step 4 (MixColumns) is not performed. Instead, it is replaced with the AddRoundKey
  prefs: []
  type: TYPE_NORMAL
- en: step to ensure that the first three steps cannot be simply reversed. This process
    is shown in Figure [2-9](#p98).
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-98_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-9\.** AES block cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Some Basic Mathematics**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into cryptography, it is important to understand some very basic
  prefs: []
  type: TYPE_NORMAL
- en: mathematics and related terminology.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prime**'
  prefs: []
  type: TYPE_NORMAL
- en: A prime is a number which is only divisible fully by itself and 1\. For example,
    23 is a
  prefs: []
  type: TYPE_NORMAL
- en: prime number as it can only be divided precisely without leaving any remainder
    either
  prefs: []
  type: TYPE_NORMAL
- en: by 23 or 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular Arithmetic**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a system of performing arithmetic operations on integers where numbers
    wrap
  prefs: []
  type: TYPE_NORMAL
- en: around when they reach a certain fixed number. This fixed number is called a
    modulus,
  prefs: []
  type: TYPE_NORMAL
- en: and all arithmetic operations are performed based on this modulus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Group**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A group *G* is a set whose elements can be combined with an operation ∘. It
    has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closure** means that all group operations are closed. Formally, ∀ *a*,'
  prefs: []
  type: TYPE_NORMAL
- en: '*b* ∈ *G* : *a* ∘ *b* = *c* ∈ *G*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associativity** means that all group operations are associative. Formally,'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ∘ ( *b* ∘ *c*) = ( *a* ∘ *b* ) ∘ *c* : ∀ *a*, *b*, *c* ∈ *G*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a special **identity** element *i* such that ∀ *a* ∈ *G* : *a*
    ∘ *i* = *i* ∘ *a* = *a*.'
  prefs: []
  type: TYPE_NORMAL
- en: In each element *a* ∈ *G* , there is a corresponding **inverse** element *a*−1
    such that *a* ∘ *a*−1 = *a*−1 ∘ *a* = *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abelian Group**'
  prefs: []
  type: TYPE_NORMAL
- en: A group is a commutative or abelian group if in addition to the abovementioned
  prefs: []
  type: TYPE_NORMAL
- en: 'properties of groups, ∀ *a*, *b* ∈ *G* : *a* ∘ *b* = *b* ∘ *a* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Field**'
  prefs: []
  type: TYPE_NORMAL
- en: A field F is a set with two operations on F called addition and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finite Field (Galois Field)**'
  prefs: []
  type: TYPE_NORMAL
- en: A finite field is a field with a finite number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prime Fields**'
  prefs: []
  type: TYPE_NORMAL
- en: A prime field is a finite field containing a prime number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-100_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator**'
  prefs: []
  type: TYPE_NORMAL
- en: A generator is a point on an elliptic curve.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public Key Cryptography**'
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptographic systems use two different keys for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The public key is known openly, and the private key must remain secret. In these
  prefs: []
  type: TYPE_NORMAL
- en: systems, the sender uses the recipient’s public key to encrypt data. The recipient
  prefs: []
  type: TYPE_NORMAL
- en: decrypts the ciphertext by using the corresponding private key.
  prefs: []
  type: TYPE_NORMAL
- en: This model is shown in Figur[e 2-10\.](#p100)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-10\.** Public key cryptography–based cryptosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: A fundamental issue in symmetric key systems is that they need a secret key
    to be
  prefs: []
  type: TYPE_NORMAL
- en: shared before the communication using a secure channel, which can be challenging
    to
  prefs: []
  type: TYPE_NORMAL
- en: achieve. Another issue with symmetric key systems is key management. The number
    of
  prefs: []
  type: TYPE_NORMAL
- en: keys grows exponentially as the number of users grows in the system. An n user
    network
  prefs: []
  type: TYPE_NORMAL
- en: will need n(n-1)/2 keys where each user will store n-1 keys. In a 100-user network,
    each
  prefs: []
  type: TYPE_NORMAL
- en: user will store 99 keys. The formula 100(100-1)/2 means there are 4950 keys
    in total,
  prefs: []
  type: TYPE_NORMAL
- en: which is quite tricky to manage practically. Public key cryptography solves
    this issue of key distribution and key management.
  prefs: []
  type: TYPE_NORMAL
- en: A typical use of public key cryptography is to establish a shared secret key
    between
  prefs: []
  type: TYPE_NORMAL
- en: two parties. This shared secret key is used by symmetric algorithms, such as
    AES, to
  prefs: []
  type: TYPE_NORMAL
- en: encrypt the data. As they have already established a secret key, both parties
    can then
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: encrypt and decrypt without ever transmitting the secret key on the wire. This
    way, the
  prefs: []
  type: TYPE_NORMAL
- en: parties get the high security of public key cryptography with the speed of symmetric
  prefs: []
  type: TYPE_NORMAL
- en: encryption. Asymmetric cryptography is not used much for bulk encryption due
    to slow
  prefs: []
  type: TYPE_NORMAL
- en: performance; however, this is the norm for key establishment. Such systems where
    a
  prefs: []
  type: TYPE_NORMAL
- en: symmetric key is used to encrypt the data and a secret key is encrypted using
    public key
  prefs: []
  type: TYPE_NORMAL
- en: cryptography are called hybrid cryptosystems. For example, the Integrated Encryption
  prefs: []
  type: TYPE_NORMAL
- en: Scheme is a hybrid encryption scheme. ECIES is the elliptic curve (EC) version
    of the
  prefs: []
  type: TYPE_NORMAL
- en: IES scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '**Diffie-Hellman Key Exchange**'
  prefs: []
  type: TYPE_NORMAL
- en: For key exchange, the pioneering and fundamental scheme is the Diffie-Hellman
  prefs: []
  type: TYPE_NORMAL
- en: key exchange. It is an interactive protocol that runs between two parties. A
    basic and
  prefs: []
  type: TYPE_NORMAL
- en: 'intuitive mathematical example of the Diffie-Hellman exchange is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Alice and Bob want to establish a shared secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Both agree on two numbers, a prime number *P* = 13 and a
  prefs: []
  type: TYPE_NORMAL
- en: generator of *P*, *G* = 6\. In practice, however, *P* is very large.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Both randomly choose a large random integer (i.e., private keys).
  prefs: []
  type: TYPE_NORMAL
- en: a. Alice’s private key = 5, Bob’s private key = 4
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Both calculate public keys:'
  prefs: []
  type: TYPE_NORMAL
- en: a. Alice
  prefs: []
  type: TYPE_NORMAL
- en: 65 *mod* 13
  prefs: []
  type: TYPE_NORMAL
- en: 7776 *mod* 13 = 2
  prefs: []
  type: TYPE_NORMAL
- en: '*Public key* = 2'
  prefs: []
  type: TYPE_NORMAL
- en: b. Bob
  prefs: []
  type: TYPE_NORMAL
- en: 64 *mod* 13
  prefs: []
  type: TYPE_NORMAL
- en: 1296 *mod* 13 = 9
  prefs: []
  type: TYPE_NORMAL
- en: '*Public key* = 9'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Bob sends public key 9 to Alice, and Alice sends public key
  prefs: []
  type: TYPE_NORMAL
- en: 2 to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-102_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Both calculate the shared key using private keys 5 and 4\.
  prefs: []
  type: TYPE_NORMAL
- en: a. Alice
  prefs: []
  type: TYPE_NORMAL
- en: 95 *mod* 13 = 3
  prefs: []
  type: TYPE_NORMAL
- en: b. Bob
  prefs: []
  type: TYPE_NORMAL
- en: 24 *mod* 13 = 3
  prefs: []
  type: TYPE_NORMAL
- en: 7\. A shared secret key is established.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptosystems rely on one-way trap door functions. Trapdoor functions
  prefs: []
  type: TYPE_NORMAL
- en: are easy to compute in one direction but difficult to compute in the opposite
    direction,
  prefs: []
  type: TYPE_NORMAL
- en: unless there is a special value, called the trapdoor, available. This concept
    can be
  prefs: []
  type: TYPE_NORMAL
- en: visualized in Figure [2-11](#p102).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-11\.** Trapdoor function*'
  prefs: []
  type: TYPE_NORMAL
- en: Different hard computational problems, such as a large integer factorization
  prefs: []
  type: TYPE_NORMAL
- en: problem and a discrete logarithm problem, provide suitable one-way trapdoor
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography schemes using integer factorization are based on the infeasibility
  prefs: []
  type: TYPE_NORMAL
- en: of factoring large integers. A typical example that relies on such an assumption
    is
  prefs: []
  type: TYPE_NORMAL
- en: RSA. Integer factorization is the decomposition of a composite number (formed
    by
  prefs: []
  type: TYPE_NORMAL
- en: multiplying two smaller integers) into smaller integers (factors).
  prefs: []
  type: TYPE_NORMAL
- en: In cryptography, factors are restricted to prime numbers. We can demonstrate
    the
  prefs: []
  type: TYPE_NORMAL
- en: problem with a simple example as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: For example, it is straightforward to see that 15 is the product of 5 and 3
    as 5 x 3 = 15\.
  prefs: []
  type: TYPE_NORMAL
- en: What about a larger prime number, for example, 6887? It is comparatively difficult,
    but
  prefs: []
  type: TYPE_NORMAL
- en: we get 71 and 97 as factors with some calculation. What if the number is huge,
    say 1024
  prefs: []
  type: TYPE_NORMAL
- en: bits, and prime? Then multiplying two such primes is easy to do but extremely
    hard to
  prefs: []
  type: TYPE_NORMAL
- en: factor, making it a one-way function that we can use in cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: A discrete logarithm problem is the basis for many different cryptography schemes
  prefs: []
  type: TYPE_NORMAL
- en: such as the Diffie-Hellman key exchange and digital signature algorithms. It
    is based
  prefs: []
  type: TYPE_NORMAL
- en: on a problem in modular arithmetic where it is easy to calculate the result
    of a modulo
  prefs: []
  type: TYPE_NORMAL
- en: operation, but it is hard to find the exponent of the generator. This hardness
    creates
  prefs: []
  type: TYPE_NORMAL
- en: a one-way function where it is computationally infeasible to find the input
    from
  prefs: []
  type: TYPE_NORMAL
- en: the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example can demonstrate the crux of this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '*mod*'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: Now, given 9, finding 2, the exponent of the generator 3, is extremely hard
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, we can say that given numbers *a* and *n* where *n* is a prime, the
    function *f b*
  prefs: []
  type: TYPE_NORMAL
- en: '*ab*'
  prefs: []
  type: TYPE_NORMAL
- en: ( ) = *mod n*
  prefs: []
  type: TYPE_NORMAL
- en: is a one-way function, because calculating *f*( *b*) is easy, but given *f*(
    *b*), finding *b* is hard.
  prefs: []
  type: TYPE_NORMAL
- en: Another method developed in the mid-1980s is elliptic curve cryptography. Elliptic
  prefs: []
  type: TYPE_NORMAL
- en: curve cryptography has gained special attention due to its usage in blockchain
    platforms, such as Bitcoin and Ethereum. Protocols such as the Elliptic Curve
    Diffie-Hellman key
  prefs: []
  type: TYPE_NORMAL
- en: exchange and elliptic curve digital signature algorithms are most prevalent
    in this space.
  prefs: []
  type: TYPE_NORMAL
- en: ECC is fundamentally a discrete logarithm problem but founded upon elliptic
    curves
  prefs: []
  type: TYPE_NORMAL
- en: over finite fields. A key advantage of ECC is that a smaller key size provides
    the same
  prefs: []
  type: TYPE_NORMAL
- en: level of security as a larger key size in RSA. For example, a security level
    of a 1024-bit integer factorization scheme, such as RSA, can be achieved by only
    a 160-bit elliptic
  prefs: []
  type: TYPE_NORMAL
- en: curve–based scheme, such as ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptosystems can be used for encryption, though it is very less
    common
  prefs: []
  type: TYPE_NORMAL
- en: and not efficient for large datasets. It is also used for providing other security
    services and protocols, such as digital signatures, entity authentication, and
    key agreement.
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are one of the most common uses of public key cryptography.
    Digital
  prefs: []
  type: TYPE_NORMAL
- en: signatures provide nonrepudiation services. Most common examples include RSA-based
  prefs: []
  type: TYPE_NORMAL
- en: digital signatures, digital signature algorithms, and ECDSA and Schnorr signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: Entity authentication or identification is another service that public key cryptosystems
  prefs: []
  type: TYPE_NORMAL
- en: can provide. Usually, challenge-response mechanisms are in widespread use where
  prefs: []
  type: TYPE_NORMAL
- en: a challenge sent by the verifier is required to be responded to correctly by
    the prover
  prefs: []
  type: TYPE_NORMAL
- en: (claimant of identity) to ascertain the legitimacy of the claimant.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: Key agreement protocols are used to establish secret keys before an encrypted
    data
  prefs: []
  type: TYPE_NORMAL
- en: transfer. The most common example of such protocols is the Diffie-Hellman key
  prefs: []
  type: TYPE_NORMAL
- en: exchange protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**RSA**'
  prefs: []
  type: TYPE_NORMAL
- en: RSA is widely used for secure key transport and building digital signatures.
    Diffie and
  prefs: []
  type: TYPE_NORMAL
- en: Hellman invented public key cryptography in 1976\. Based on this idea, in 1978,
    the RSA
  prefs: []
  type: TYPE_NORMAL
- en: public key cryptosystem was developed by Rivest, Shamir, and Adleman.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will walk you through the steps of generating key pairs in
    RSA and
  prefs: []
  type: TYPE_NORMAL
- en: how to encrypt and decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Pair Generation**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Generate a modulus.
  prefs: []
  type: TYPE_NORMAL
- en: a. Select *p* and *q*, two large prime numbers. Usually, 2^1024 bits or more.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Multiply
  prefs: []
  type: TYPE_NORMAL
- en: '*p* and *q* to generate modulus *n*. *n* = *p*. *q*. n becomes 2^2048\.'
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Choose a random number with some special properties. Assume
  prefs: []
  type: TYPE_NORMAL
- en: that we call this number *e*.
  prefs: []
  type: TYPE_NORMAL
- en: 'a. This number *e* should have some special properties:'
  prefs: []
  type: TYPE_NORMAL
- en: i. It should be greater than 1\.
  prefs: []
  type: TYPE_NORMAL
- en: ii. It should be less than *ϕ*( *n*) = ( *p* − 1) ( *q* − 1).
  prefs: []
  type: TYPE_NORMAL
- en: iii.
  prefs: []
  type: TYPE_NORMAL
- en: '*gcd*( *e*, ( *p* − 1)( *q* − 1) = 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: iv.
  prefs: []
  type: TYPE_NORMAL
- en: '*e* ∈ {1, 2, . . . , *ϕ*( *n*) − 1}.'
  prefs: []
  type: TYPE_NORMAL
- en: Formally speaking, this number e should be the coprime (relatively
  prefs: []
  type: TYPE_NORMAL
- en: prime) of ( *p* − 1) ( *q* − 1), that is, no number other than 1 can
  prefs: []
  type: TYPE_NORMAL
- en: be divided fully into e and ( *p* − 1) ( *q* − 1). Coprimes have no
  prefs: []
  type: TYPE_NORMAL
- en: common factors except 1, so the greatest common divisor (GCD) of
  prefs: []
  type: TYPE_NORMAL
- en: coprimes is 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Public key generation
  prefs: []
  type: TYPE_NORMAL
- en: a. The modulus n generated in step 1 and the special number e generated
  prefs: []
  type: TYPE_NORMAL
- en: in step 2 is pair (n, e) that is the public key. This pair is public, so it
    can be
  prefs: []
  type: TYPE_NORMAL
- en: shared with anyone; however, p and q must be kept secret.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Private key generation
  prefs: []
  type: TYPE_NORMAL
- en: a. The private key, let’s call it *d*, is calculated from two primes *p* and
    *q* from step 1 and the special number *e* from step 2\. The private key is the
    inverse of
  prefs: []
  type: TYPE_NORMAL
- en: '*e* modulo ( *p* − 1)( *q* − 1), which we can write as'
  prefs: []
  type: TYPE_NORMAL
- en: '*ed* =1 *mod* ( *p* − )'
  prefs: []
  type: TYPE_NORMAL
- en: 1 ( *q* − )
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '*ed* =1 *mod* φ *n*'
  prefs: []
  type: TYPE_NORMAL
- en: −1
  prefs: []
  type: TYPE_NORMAL
- en: '*d* = *e* = 7'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '*mod*'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the extended Euclidean algorithm is used to calculate *d* which
    takes *p*, *q*, and e as input and outputs *d*. *d* must be kept secret.
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption and Decryption**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how encryption and decryption operations are performed using
    RSA. RSA
  prefs: []
  type: TYPE_NORMAL
- en: 'uses the following equation to produce ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*'
  prefs: []
  type: TYPE_NORMAL
- en: '*C* = *P mod n*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that plaintext P is raised to the power of e and then reduced to
    modulo n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption in RSA is provided in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* = *C mod n*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the receiver who has a public key pair ( *n*, *e*) can decipher
    the data by raising *C* to the value of the private key *d* and then reducing
    to modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of Key Generation, Encryption, and Decryption**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Let the plaintext be message *m*. *m* = 5, to be sent from Alice to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Let
  prefs: []
  type: TYPE_NORMAL
- en: '*p* = 3 and *q* = 11\.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. *n* = *pq* = 3 *x* 11 = 33\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. *e* = 3, because (3 − 1) (11 − 1) = 20 which is greater than 1 and less
  prefs: []
  type: TYPE_NORMAL
- en: than 20 and *GCD*(3, 20) = 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The public key is pair ( *n*, *e*) = (33, 3).
  prefs: []
  type: TYPE_NORMAL
- en: 6\. The private key is *ed* = 1 *mod* ( *p* − 1)( *q* − 1).
  prefs: []
  type: TYPE_NORMAL
- en: '*d* = *e*−1 7'
  prefs: []
  type: TYPE_NORMAL
- en: 20 (33 7
  prefs: []
  type: TYPE_NORMAL
- en: '*mod* ,'
  prefs: []
  type: TYPE_NORMAL
- en: ', )'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Send public key ( *n*, *e*) (33, 3) to Alice.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Alice does 53 = 125 *mod* 33 = 26\.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Alice sends 26 as the encrypted text to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Bob does 267 = 8031810176 = 8031810176 *mod* 33 = 5 and retrieves
  prefs: []
  type: TYPE_NORMAL
- en: the plaintext message 5\.
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic Curve Cryptography**'
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC) is based on a concept in mathematics called
    elliptic
  prefs: []
  type: TYPE_NORMAL
- en: curves. It is a set of points on a plane whose x, y coordinates satisfy a specific
    equation and some conditions. Typically, it is the Weierstrass form *y* 2 = *x*
    3 + *ax* + *b* where *a* and *b* are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curves are groups. They are used in many different areas of mathematics,
  prefs: []
  type: TYPE_NORMAL
- en: including number theory, complex analysis, and mathematical physics. When used
    in
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, a suitable elliptic curve’s points over a finite field form a
    group structure which allows to build cryptography schemes based on a discrete
    logarithm problem.
  prefs: []
  type: TYPE_NORMAL
- en: A prime field is used in elliptic curve cryptography. *In a prime field, all
    arithmetic* *operations are performed modulo a prime number p*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An elliptic curve is defined in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *x* + *ax* + *b mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a and b belong to a finite field *Zp* or *Fp* (prime finite field), that
    is, ( *a*, *b*) ∈ *Z*, and an imaginary point of infinity. The point of infinity
    ∞ is used to provide identity
  prefs: []
  type: TYPE_NORMAL
- en: operations for points on the curve.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a condition shown below ensures that the curve is nonsingular,
  prefs: []
  type: TYPE_NORMAL
- en: 'meaning the curve does not self-intersect or has vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: + 27 ≠ 0
  prefs: []
  type: TYPE_NORMAL
- en: '*a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: To construct the discrete logarithm problem based on elliptic curves, a large
    enough
  prefs: []
  type: TYPE_NORMAL
- en: cyclic group is required. First, the group elements are identified as a set
    of points that satisfy the elliptic curve equation. After this, group operations
    need to be defined on
  prefs: []
  type: TYPE_NORMAL
- en: these points. The fundamental group operations on elliptic curves are point
    addition
  prefs: []
  type: TYPE_NORMAL
- en: and point doubling. Point addition is a process where two different points are
    added,
  prefs: []
  type: TYPE_NORMAL
- en: and point doubling means that the same point is added to itself.
  prefs: []
  type: TYPE_NORMAL
- en: An elliptic curve can be visualized over real numbers as shown in Figure [2-12\.](#p108)
  prefs: []
  type: TYPE_NORMAL
- en: '88'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-108_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-12\.** An elliptic curve over real numbers y2 = x3* − *3x + 5*'
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the curve and group operations, that is, addition and doubling,
  prefs: []
  type: TYPE_NORMAL
- en: geometrically over real numbers, which helps to build intuition. In practice,
    however, the curve over prime field is used to build ECC-based schemes. Though,
    when we try to plot
  prefs: []
  type: TYPE_NORMAL
- en: it, it appears quite random and not intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Point Addition**'
  prefs: []
  type: TYPE_NORMAL
- en: For adding two points, a line is drawn through points P and Q (the diagonal
    line in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-13) t](#p109)o obtain a third point. This point, when reflected, is
    point R, shown as P+Q
  prefs: []
  type: TYPE_NORMAL
- en: in Figure [2-13](#p109).
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-109_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-13\.** Point addition*'
  prefs: []
  type: TYPE_NORMAL
- en: Algebraically speaking, in point addition operation, two points P and Q are
    added to
  prefs: []
  type: TYPE_NORMAL
- en: 'obtain the coordinates of the third point R on the curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* + *Q* = *R*'
  prefs: []
  type: TYPE_NORMAL
- en: where *P* = ( *x* 1, *y* 1) and *Q* = ( *x* 2, *y* 2) and *R* = ( *x* 3, *y*
    3).
  prefs: []
  type: TYPE_NORMAL
- en: 'For addition, we calculate the gradient between the points:'
  prefs: []
  type: TYPE_NORMAL
- en: ( *y* 2 − *y* 1)
  prefs: []
  type: TYPE_NORMAL
- en: '*S* ='
  prefs: []
  type: TYPE_NORMAL
- en: '*mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: ( *x*
  prefs: []
  type: TYPE_NORMAL
- en: 2 − *x* 1 )
  prefs: []
  type: TYPE_NORMAL
- en: where S depicts the line going through P and Q.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to obtain the new point R:'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = − − *mod*'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '*s*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1 *x* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = ( − ) − *mod*'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '*s x* 1 *x* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 1'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*'
  prefs: []
  type: TYPE_NORMAL
- en: '90'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-110_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Point Doubling**'
  prefs: []
  type: TYPE_NORMAL
- en: In point doubling, P is added to itself. In other words, P and Q are the same
    point. As the point adds to itself, we can call this operation point doubling.
  prefs: []
  type: TYPE_NORMAL
- en: To double a point, a tangent line (the dotted diagonal line in Figure [2-14)
    is dr](#p110)awn through point P, which obtains a second point where the line
    intersects with the curve.
  prefs: []
  type: TYPE_NORMAL
- en: This point is reflected to yield the result R, shown as 2P in Figure [2-14\.](#p110)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-14\.** Elliptic curve point doubling*'
  prefs: []
  type: TYPE_NORMAL
- en: For doubling, we use
  prefs: []
  type: TYPE_NORMAL
- en: (3 *x* 21 + *a*)
  prefs: []
  type: TYPE_NORMAL
- en: '*S* ='
  prefs: []
  type: TYPE_NORMAL
- en: '*mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '*y*'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: where S depicts the tangent line going through point P.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to obtain the point R:'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = − − *mod*'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '*s*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1 *x* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 3 = *s*( *x* 1 − *x* 2) − *y* 1 *mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: '91'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar Point Multiplication**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation is used to multiply a point on the elliptic curve by a given
    integer, for
  prefs: []
  type: TYPE_NORMAL
- en: example, an integer d and the point P. We get dP by repeatedly adding P, d times,
    as
  prefs: []
  type: TYPE_NORMAL
- en: 'shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* + *P* +…+ *P* = *dP*'
  prefs: []
  type: TYPE_NORMAL
- en: This operation is used to generate a public key in ECC-based cryptosystems.
    It is
  prefs: []
  type: TYPE_NORMAL
- en: a very computationally expensive process as both point addition and doubling
    are
  prefs: []
  type: TYPE_NORMAL
- en: 'performed repeatedly to calculate:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Q* = *dP*'
  prefs: []
  type: TYPE_NORMAL
- en: where P is a point on the curve, d is a randomly chosen integer as the private
    key,
  prefs: []
  type: TYPE_NORMAL
- en: and Q is the public key obtained after the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Making point multiplication faster is an active area of research. While there
    are many
  prefs: []
  type: TYPE_NORMAL
- en: algorithms for making scalar multiplication more quickly, we describe a quick
    example
  prefs: []
  type: TYPE_NORMAL
- en: here using the double and add algorithm. It combines point addition and doubling
  prefs: []
  type: TYPE_NORMAL
- en: operations to achieve performance.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if using addition only, to get 9P we must do P + P + P + P + P
    + P + P +
  prefs: []
  type: TYPE_NORMAL
- en: P + P, which can become impracticable very quickly if the number of Ps increases.
    We
  prefs: []
  type: TYPE_NORMAL
- en: can use the double and add mechanism to make this faster. Here, we first convert
    nine
  prefs: []
  type: TYPE_NORMAL
- en: into binary. Starting from the most significant bit (MSB), for each bit that
    is one (high), perform the double and addition operations, and for each zero,
    perform only the double
  prefs: []
  type: TYPE_NORMAL
- en: operation. We do not perform any operation on the most significant bit. Nine
    is 1001 in
  prefs: []
  type: TYPE_NORMAL
- en: binary, so for each bit we get (starting from left to right) P, 2P, 4P, 8P+P.
    This scheme produces 9P only with three double operations and one addition operation,
    instead of
  prefs: []
  type: TYPE_NORMAL
- en: nine addition operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic Curve Discrete Logarithm Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider that *dP* results in producing another point *Q* on the curve.
    Even if we know the points *P* and *Q*, it is computationally infeasible to reconstruct
    the sequence of all the double and addition operations that we did to calculate
    the number d. Even if
  prefs: []
  type: TYPE_NORMAL
- en: someone knows *P* and *Q*, it is impossible for them to find *d*. This means
    that it is a one-way (trapdoor function) function. It is the basis of the elliptic
    curve discrete logarithm problem (ECDLP).
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Consider an elliptic curve E, with two elements P and Q. The discrete logarithm
  prefs: []
  type: TYPE_NORMAL
- en: 'problem is to find the integer d, where 1 < = *d* < = # *E*, such that *P*
    + *P* +…+ *P* = *dP* = *Q*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *Q* is the public key (a point generated on the curve, (x, y)), and *d*
    is the private key (another point on the curve). The public key is a random multiple
    of the generator
  prefs: []
  type: TYPE_NORMAL
- en: point *P*, whereas the private key is the integer d that is used to generate
    the multiple. The Generator point or base point G is a point on the curve that
    generates a cyclic subgroup, which means that every point in the group can be
    reached by repeated addition of the
  prefs: []
  type: TYPE_NORMAL
- en: base point.
  prefs: []
  type: TYPE_NORMAL
- en: '#E represents the order of the group (elliptic curve), which means the number
    of'
  prefs: []
  type: TYPE_NORMAL
- en: points that are present in the cyclic subgroup of the elliptic curve. A cyclic
    group is
  prefs: []
  type: TYPE_NORMAL
- en: formed by a combination of points on the elliptic curve and the point of infinity.
    Cofactor *h* is the number of points in the curve divided by the order of the
    subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: The initial starting point *P* is a public parameter, and the public key *Q*
    is also published, whereas d, the private key, is kept secret. If d is not known,
    it is unfeasible to calculate with only the knowledge of Q and P, thus creating
    the hard problem on which
  prefs: []
  type: TYPE_NORMAL
- en: ECDLP is built.
  prefs: []
  type: TYPE_NORMAL
- en: A key pair is linked with the specific domain parameters of an elliptic curve.
    Domain
  prefs: []
  type: TYPE_NORMAL
- en: parameters are public values that are required to implement ECC schemes. These
  prefs: []
  type: TYPE_NORMAL
- en: 'parameters are represented as a tuple { *p*, *a*, *b*, *G*, *n*, *h*}:'
  prefs: []
  type: TYPE_NORMAL
- en: '• *P*: Field (modulo prime)'
  prefs: []
  type: TYPE_NORMAL
- en: '• *a*, *b*: Fixed elliptic curve coefficients'
  prefs: []
  type: TYPE_NORMAL
- en: '• *G*: The generator point to generate a cyclic group'
  prefs: []
  type: TYPE_NORMAL
- en: '• *n*: Order of the group (curve)'
  prefs: []
  type: TYPE_NORMAL
- en: '• *h*: Cofactor'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Bitcoin uses the SECP256k1 curve with the equation *y* 2 = *x*
    3 + 7 and domain parameters as defined here: [https://en.bitcoin.it/wiki/Secp256k1\.](https://en.bitcoin.it/wiki/Secp256k1)'
  prefs: []
  type: TYPE_NORMAL
- en: The most used curves are NIST proposed curves, such as P-256\. Other curves
    include
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519, Curve1174, and many more. Of course, it is advisable to choose a
    safe curve.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent resource of safe and unsafe curves along with explanations is maintained
  prefs: []
  type: TYPE_NORMAL
- en: 'online here: [https://safecurves.cr.yp.to](https://safecurves.cr.yp.to).'
  prefs: []
  type: TYPE_NORMAL
- en: '93'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography is used to create digital signatures. It is one of the
    most common applications of public key cryptography. In this section, we will
    discover how RSA,
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA, and Schnorr signatures work. Concepts such as aggregate signatures and
  prefs: []
  type: TYPE_NORMAL
- en: multisignatures, also commonly used in blockchains, will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures provide a means of associating a message with an entity from
  prefs: []
  type: TYPE_NORMAL
- en: which the message has originated. Digital signatures are used to provide data
    origin
  prefs: []
  type: TYPE_NORMAL
- en: authentication and nonrepudiation.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are used in consensus algorithms and especially in blockchain
  prefs: []
  type: TYPE_NORMAL
- en: networks to sign the transactions and messages sent by a user on the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: network. Blocks are sealed cryptographically using a digital signature so that
    the
  prefs: []
  type: TYPE_NORMAL
- en: recipient can verify the authenticity of the transmitted block. Similarly, all
    transactions are signed as well. It is common in consensus algorithms that blocks
    are sealed and
  prefs: []
  type: TYPE_NORMAL
- en: broadcast to the network that recipients (other nodes) receive, who verifies
    the signature to ascertain the block’s authenticity. The blocks are inserted into
    the local blockchain
  prefs: []
  type: TYPE_NORMAL
- en: after verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures have three security properties: authenticity, unforgeability,
    and'
  prefs: []
  type: TYPE_NORMAL
- en: nonreusability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticity**'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the digital signatures are verifiable by the receiving party.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unforgeability (Nonrepudiation)**'
  prefs: []
  type: TYPE_NORMAL
- en: This property guarantees that only the message’s sender can sign using the private
  prefs: []
  type: TYPE_NORMAL
- en: key. Digital signatures must also protect against forgery. Forgery means an
    adversary
  prefs: []
  type: TYPE_NORMAL
- en: fabricating a valid signature for a message without access to the legitimate
    signer’s
  prefs: []
  type: TYPE_NORMAL
- en: private key. In other words, unforgeability implies that no one else can produce
    the
  prefs: []
  type: TYPE_NORMAL
- en: signed message produced by a genuine sender.
  prefs: []
  type: TYPE_NORMAL
- en: '94'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-114_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonreusability**'
  prefs: []
  type: TYPE_NORMAL
- en: This property necessitates that the digital signature cannot be separated from
    a message
  prefs: []
  type: TYPE_NORMAL
- en: and used again for another message. In other words, the digital signature is
    firmly bound to the corresponding message and cannot be separated from its original
    message and
  prefs: []
  type: TYPE_NORMAL
- en: attached to another.
  prefs: []
  type: TYPE_NORMAL
- en: The process of signing and verification using digital signatures is shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-15\.](#p114)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-15\.** Digital signing (left) and verification process (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we produce the hash of the data for which we want to prove data origin
  prefs: []
  type: TYPE_NORMAL
- en: authentication. Then we encrypt the hash using the prover’s private key (signing
    key) to
  prefs: []
  type: TYPE_NORMAL
- en: create a “signature” and attach it with the data. Finally, this signed object
    is sent to the verifier.
  prefs: []
  type: TYPE_NORMAL
- en: The verifier decrypts the encrypted hash of the data using the signer’s (sender)
  prefs: []
  type: TYPE_NORMAL
- en: public key to retrieve the original hash. The verifier then takes the data and
    hashes it
  prefs: []
  type: TYPE_NORMAL
- en: again through the hash function to produce the hash. If both these hashes match,
    the
  prefs: []
  type: TYPE_NORMAL
- en: verification is successful, proving that the signer indeed signed the data.
    It also proves the data origin authentication, along with nonrepudiation and data
    integrity properties.
  prefs: []
  type: TYPE_NORMAL
- en: Now we describe how ECDSA (elliptic curve digital signature algorithm) works.
  prefs: []
  type: TYPE_NORMAL
- en: '95'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**ECDSA Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA is a DSA based on elliptic curves. The DSA is a standard for digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: It is based on modular exponentiation and the discrete logarithm problem. It
    is used
  prefs: []
  type: TYPE_NORMAL
- en: on Bitcoin and Ethereum blockchain platforms to validate messages and provide
    data
  prefs: []
  type: TYPE_NORMAL
- en: integrity services.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll describe how ECDSA works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign and verify using the ECDSA scheme, first a key pair needs to be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Define an elliptic curve E with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Modulus *P*
  prefs: []
  type: TYPE_NORMAL
- en: • Coefficients *a* and *b*
  prefs: []
  type: TYPE_NORMAL
- en: • A generator point *A* that forms a cyclic group of prime order *q*
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Choose an integer *d* randomly such that 0 < *d* < *q*.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Calculate the public key *B* so that *B* = *dA*.
  prefs: []
  type: TYPE_NORMAL
- en: '• The public parameters are a sextuple in the form shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kpb* = ( *p*, *a*, *b*, *q*, *A*, *B*)'
  prefs: []
  type: TYPE_NORMAL
- en: '• The private key is a randomly chosen integer d in step 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kpr* = *d*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the signature can be generated using the private and public keys.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. An ephemeral key *Ke* is chosen, where 0 < *Ke* < *q*. Also, ensure that
    *Ke* is random and that no two signatures end up with the same key;
  prefs: []
  type: TYPE_NORMAL
- en: otherwise, the private key can be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. A value *R* is calculated using *R* = *Ke* *A*, that is, by multiplying
    *A* (the generator point) and the random ephemeral key.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Initialize a variable *r* with the *x* coordinate value of point *R* so
    that *r* = *xR*.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. The signature can now be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* = ( *h*( *m*) + *d r*.) *K mod*'
  prefs: []
  type: TYPE_NORMAL
- en: −1
  prefs: []
  type: TYPE_NORMAL
- en: '*q*'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*'
  prefs: []
  type: TYPE_NORMAL
- en: '96'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Here, *m* is the message for which the signature is calculated, and *h*( *m*)
    is the hash of the message *m*.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Signature verification is carried out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • A value *w* is calculated as *w* = *s*−1 *mod q*.
  prefs: []
  type: TYPE_NORMAL
- en: • A value *u* 1 = *w*. *h*( *m*) *mod q*.
  prefs: []
  type: TYPE_NORMAL
- en: • A value *u* 2 = *w*. *r mod q*.
  prefs: []
  type: TYPE_NORMAL
- en: '• Calculate point *P*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* = *u* 1 *A* + *u* 2 *B*'
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Verification is carried out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • *r*, *s* is accepted as a valid signature if the x coordinate of point *P*
  prefs: []
  type: TYPE_NORMAL
- en: calculated in step 4 has the same value as the signature parameter
  prefs: []
  type: TYPE_NORMAL
- en: '*r* mod *q*; that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Xp* = *r mod q* means a valid signature.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Xp* ≠ *r mod q* means an invalid signature.'
  prefs: []
  type: TYPE_NORMAL
- en: This completes our introduction to digital signatures and especially ECDSA.
    ECDSA
  prefs: []
  type: TYPE_NORMAL
- en: is quite commonly used in blockchain networks, including Bitcoin, Ethereum,
    and
  prefs: []
  type: TYPE_NORMAL
- en: several enterprise chains. Now we describe some other digital signature variations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multisignatures**'
  prefs: []
  type: TYPE_NORMAL
- en: In this scheme, multiple unique keys held by their respective owners are used
    to sign a
  prefs: []
  type: TYPE_NORMAL
- en: single message. In blockchain implementations, multisignature schemes allow
    multiple
  prefs: []
  type: TYPE_NORMAL
- en: users to sign a transaction, which results in increased security. Moreover,
    in blockchain networks, these schemes can be used so that users can set the condition
    of at least one or more than one signature to authorize transactions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a 1-of-2 multisignature scheme can represent a joint account where
  prefs: []
  type: TYPE_NORMAL
- en: either one of the joint account holders is required to authorize a transaction
    by signing it. In another variation, a 2-of-2 multisignature can be used where
    both joint account
  prefs: []
  type: TYPE_NORMAL
- en: holders’ signatures must authorize the transaction. This concept is generalized
    as m of
  prefs: []
  type: TYPE_NORMAL
- en: n signatures, where m is the minimum number of expected signatures and n is
    the total
  prefs: []
  type: TYPE_NORMAL
- en: number of signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '97'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-117_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: This process is shown in Figur[e 2-16](#p117).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-16\.** Multisignature scheme*'
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-16 sho](#p117)ws the signing process on the left-hand side, where
    m is the number of different users, and holding m unique signatures signs a single
    transaction. When the
  prefs: []
  type: TYPE_NORMAL
- en: validator or verifier receives it, all the signatures in it need to be individually
    verified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Threshold Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: This scheme does not rely on users to sign the message with their individual
    keys;
  prefs: []
  type: TYPE_NORMAL
- en: instead, it requires only one public key and one private key to produce the
    digital
  prefs: []
  type: TYPE_NORMAL
- en: signature. In a multisignature scheme, the signed message contains digital signatures
  prefs: []
  type: TYPE_NORMAL
- en: from all signers. It requires verification individually by the verification
    party, but the verifier must verify only one digital signature in threshold signatures.
    The key idea in this scheme is to split the private key into multiple parts, and
    each signer keeps its share of the private key. The signing process requires each
    user to use their respective share of
  prefs: []
  type: TYPE_NORMAL
- en: the private key to sign the message. A particular communication protocol manages
    the
  prefs: []
  type: TYPE_NORMAL
- en: communication between the signers.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with multisignatures, the threshold signatures result in smaller
  prefs: []
  type: TYPE_NORMAL
- en: transaction sizes and are faster to verify. A downside, however, is that for
    threshold
  prefs: []
  type: TYPE_NORMAL
- en: signatures to work, all signers must remain online. In multisignature schemes,
    the
  prefs: []
  type: TYPE_NORMAL
- en: '98'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-118_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: signatures can be delivered asynchronously. In other words, users can provide
    signatures
  prefs: []
  type: TYPE_NORMAL
- en: whenever available. One downside is that there could be a situation where users
    may
  prefs: []
  type: TYPE_NORMAL
- en: withhold their signature maliciously, resulting in a denial of service. We can
    also use
  prefs: []
  type: TYPE_NORMAL
- en: threshold signatures to provide anonymity in a blockchain network, as individual
    signers
  prefs: []
  type: TYPE_NORMAL
- en: are unidentifiable in multisignature schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-17 sho](#p118)ws the signing process on the left-hand side, where
    an m number of different users, holding different parts (shares) of a digital
    signature, sign a single transaction. When the validator or verifier receives
    it, only one signature needs to be
  prefs: []
  type: TYPE_NORMAL
- en: verified.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-17\.** Threshold signatures*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregate Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate signatures reduce the size of digital signatures. This scheme is beneficial
  prefs: []
  type: TYPE_NORMAL
- en: in scenarios where multiple digital signatures are in use. The core idea is
    to aggregate
  prefs: []
  type: TYPE_NORMAL
- en: multiple signatures into a single signature without increasing the size of the
    signature of a single message. It is simply a type of digital signature that supports
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: The small aggregate signature is enough to prove to the verifier that all users
    signed
  prefs: []
  type: TYPE_NORMAL
- en: their original messages. Thus, aggregate signatures are commonly used to reduce
    the
  prefs: []
  type: TYPE_NORMAL
- en: size of messages in network and security protocols. For example, we can significantly
  prefs: []
  type: TYPE_NORMAL
- en: reduce the size of digital certificate chains in Public Key Infrastructure (PKI)
    by
  prefs: []
  type: TYPE_NORMAL
- en: compressing all signatures in the chain into a single signature. Boneh-Lynn-Shacham
  prefs: []
  type: TYPE_NORMAL
- en: '99'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-119_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: (BLS) aggregate signatures are a typical example of the aggregate signature.
    BLS has also been used in various blockchains and especially in Ethereum 2.0\.
  prefs: []
  type: TYPE_NORMAL
- en: Schnorr signatures are another type of signature based on elliptic curve
  prefs: []
  type: TYPE_NORMAL
- en: cryptography that allows key and signature aggregation. Schnorr signatures are
    64 bytes
  prefs: []
  type: TYPE_NORMAL
- en: in size as compared to ECDSA, which is 71 bytes in signature size. ECDSA’s private
    key
  prefs: []
  type: TYPE_NORMAL
- en: size is 32 bytes and its public key is 33 bytes, whereas the Schnorr scheme’s
    private
  prefs: []
  type: TYPE_NORMAL
- en: and public keys are 32 bytes in size. Overall, Schnorr signatures are smaller
    and faster
  prefs: []
  type: TYPE_NORMAL
- en: than ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-18 sho](#p119)ws how the aggregate signatures work.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-18\.** Aggregate signatures*'
  prefs: []
  type: TYPE_NORMAL
- en: Schnorr signatures are proposed to be used in Bitcoin under Bitcoin Improvement
  prefs: []
  type: TYPE_NORMAL
- en: Proposal (BIP) 340\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ring Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: Ring signature schemes are mechanisms where any member of a group of signers
    can
  prefs: []
  type: TYPE_NORMAL
- en: sign a message on behalf of the entire group. Each member of the ring group
    keeps
  prefs: []
  type: TYPE_NORMAL
- en: a public key and a private key. The key point here is that the identity of the
    actual
  prefs: []
  type: TYPE_NORMAL
- en: signer who signed the message must remain unknown (computationally infeasible
    to
  prefs: []
  type: TYPE_NORMAL
- en: determine) to an outside observer. It looks equally likely that anyone from
    the trusted
  prefs: []
  type: TYPE_NORMAL
- en: group of signers could have signed the message, but it is not possible to figure
    out the
  prefs: []
  type: TYPE_NORMAL
- en: individual user who signed the message. Thus, we can use ring signatures to
    provide an
  prefs: []
  type: TYPE_NORMAL
- en: anonymity service.
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-120_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are keyless primitives which create fixed-length digests of arbitrarily
    long input data. There are three security properties of hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preimage Resistance**'
  prefs: []
  type: TYPE_NORMAL
- en: This property is also called a one-way property. It can be explained by using
    the simple
  prefs: []
  type: TYPE_NORMAL
- en: 'equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h*( *x*) = *y*'
  prefs: []
  type: TYPE_NORMAL
- en: where *h* is the hash function, *x* is the input, and *y* is the output hash.
    The first security property requires that *y* cannot be reverse-computed to *x*.
    *x* is the preimage of *y*, thus the name preimage resistance. This property is
    depicted in Figure [2-19\.](#p120)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-19\.** Preimage resistance*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second Preimage Resistance**'
  prefs: []
  type: TYPE_NORMAL
- en: This property is also known as the weak collision resistance property. This
    property
  prefs: []
  type: TYPE_NORMAL
- en: ensures that given *x* and *h*( *x*), it is almost impossible to find any other
    message *m*, where *m* ≠ *x* and hash of *m* = hash of *x* or *h*( *m*) = *h*(
    *x*). This property is shown in Figure [2-20\.](#p121)
  prefs: []
  type: TYPE_NORMAL
- en: '101'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-121_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-121_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-20\.** Second preimage resistance*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collision Resistance**'
  prefs: []
  type: TYPE_NORMAL
- en: The collision resistance property requires that two different input messages
    should not
  prefs: []
  type: TYPE_NORMAL
- en: hash to the same output. In other words, *h*( *x*) ≠ *h*( *z*). Figure [2-21
    sho](#p121)ws a depiction of collision resistance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-21\.** Strong collision resistance*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are two functional properties of hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: • Compression of arbitrary size data into a fixed-length digest
  prefs: []
  type: TYPE_NORMAL
- en: • Easy to compute
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions, due to their very nature, are always expected to have collisions,
  prefs: []
  type: TYPE_NORMAL
- en: where two different messages hash to the same output, but in a good hash function,
  prefs: []
  type: TYPE_NORMAL
- en: collisions must be computationally infeasible to find.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, hash functions should also have a property that a small change, even
  prefs: []
  type: TYPE_NORMAL
- en: a single character change in the input text, should result in an entirely different
    hash
  prefs: []
  type: TYPE_NORMAL
- en: output. This is known as the **avalanche effect**.
  prefs: []
  type: TYPE_NORMAL
- en: '102'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are usually designed by using the iterated hash function method,
  prefs: []
  type: TYPE_NORMAL
- en: where the input data is divided into equal block sizes and then they are processed
  prefs: []
  type: TYPE_NORMAL
- en: iteratively through the compression functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some prominent approaches to build hash functions using iterative methods are
  prefs: []
  type: TYPE_NORMAL
- en: 'listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Merkle-Damgard construction
  prefs: []
  type: TYPE_NORMAL
- en: • Sponge construction
  prefs: []
  type: TYPE_NORMAL
- en: The most common hash function schemes are SHA-0, SHA-1, SHA-2, SHA-3,
  prefs: []
  type: TYPE_NORMAL
- en: RIPEMD, and Whirlpool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design of Secure Hash Algorithms (SHA)**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce the design of SHA-256 and SHA-3\. Both are
    used
  prefs: []
  type: TYPE_NORMAL
- en: in Bitcoin and Ethereum, respectively. However, Ethereum uses Keccak, the original
  prefs: []
  type: TYPE_NORMAL
- en: algorithm presented to NIST, rather than NIST standard SHA-3\. NIST, after some
  prefs: []
  type: TYPE_NORMAL
- en: modifications, such as an increase in the number of rounds and simpler message
  prefs: []
  type: TYPE_NORMAL
- en: padding, standardized Keccak as SHA-3\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design of SHA-256**'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 has an input message size limit of 264 − 1 bits. The block size is 512
    bits, and it has a word size of 32 bits. The output is a 256-bit digest.
  prefs: []
  type: TYPE_NORMAL
- en: The compression function processes a 512-bit message block and a 256-bit
  prefs: []
  type: TYPE_NORMAL
- en: 'intermediate hash value. There are two main components of this function: the'
  prefs: []
  type: TYPE_NORMAL
- en: compression function and a message schedule.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works as follows, in nine steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preprocessing**'
  prefs: []
  type: TYPE_NORMAL
- en: • Padding of the message is used to adjust the length of a block to 512
  prefs: []
  type: TYPE_NORMAL
- en: bits if it is smaller than the required block size of 512 bits.
  prefs: []
  type: TYPE_NORMAL
- en: • Parsing the message into message blocks, which ensures that the
  prefs: []
  type: TYPE_NORMAL
- en: message and its padding are divided into equal blocks of 512 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '103'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-123_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: • Setting up the initial hash value, which consists of the eight 32-bit
  prefs: []
  type: TYPE_NORMAL
- en: words obtained by taking the first 32 bits of the fractional parts of the
  prefs: []
  type: TYPE_NORMAL
- en: square roots of the first eight prime numbers. These initial values
  prefs: []
  type: TYPE_NORMAL
- en: are fixed and chosen to initialize the process. They provide a level of
  prefs: []
  type: TYPE_NORMAL
- en: confidence that no backdoor exists in the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash Computation**'
  prefs: []
  type: TYPE_NORMAL
- en: • Each message block is then processed in a sequence, and it requires
  prefs: []
  type: TYPE_NORMAL
- en: 64 rounds to compute the full hash output. Each round uses slightly
  prefs: []
  type: TYPE_NORMAL
- en: different constants to ensure that no two rounds are the same.
  prefs: []
  type: TYPE_NORMAL
- en: • The message schedule prepares.
  prefs: []
  type: TYPE_NORMAL
- en: • Eight working variables initialize.
  prefs: []
  type: TYPE_NORMAL
- en: • The compression function runs 64 times.
  prefs: []
  type: TYPE_NORMAL
- en: • The intermediate hash value is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: • Finally, after repeating steps 5 through 8 until all blocks (chunks
  prefs: []
  type: TYPE_NORMAL
- en: of data) in the input message are processed, the output hash is
  prefs: []
  type: TYPE_NORMAL
- en: produced by concatenating intermediate hash values.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, SHA-256 can be visualized in Figure [2-22\.](#p123)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-22\.** SHA-256 high-level overview*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in Figur[e 2-22](#p123), SHA-256 is a Merkle-Damgard construction that
    takes the input message and divides it into equally sized blocks of 512 bits.
    Initial hash values, or the initialization vector, which are composed of eight
    32-bit words (i.e., 256 bits), are fed 104
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-124_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: into the compression function with the first message. Subsequent blocks are
    fed into the
  prefs: []
  type: TYPE_NORMAL
- en: compression function until all blocks are processed to produce the output hash.
  prefs: []
  type: TYPE_NORMAL
- en: The compression function of SHA-256 is shown in Figure [2-23](#p124).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-23\.** One round of the SHA-256 compression function*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 2-23](#p124), *a*, *b*, *c*, *d*, *e*, *f*, *g*, and *h* are the
    registers for eight working variables. Maj and Ch are functions which are applied
    bitwise. *Σ* 0 and *Σ* 1 perform bitwise rotation. The round constants are *Wj*
    and *Kj*, which are added in the main loop (compressor function) of the hash function,
    which runs 64 times.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design of SHA-3 (Keccak)**'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of SHA-3 is very different from that of SHA-1 and SHA-2\. SHA-3
    is based
  prefs: []
  type: TYPE_NORMAL
- en: on unkeyed permutations instead of other typical hash function constructions
    that used
  prefs: []
  type: TYPE_NORMAL
- en: keyed permutations. Keccak also does not use the Merkle-Damgard transformation,
  prefs: []
  type: TYPE_NORMAL
- en: commonly used to handle arbitrary-length input messages in hash functions. Instead,
  prefs: []
  type: TYPE_NORMAL
- en: a newer approach, called sponge and squeeze construction, is used in Keccak.
    It is a
  prefs: []
  type: TYPE_NORMAL
- en: random permutation model.
  prefs: []
  type: TYPE_NORMAL
- en: Different variants of SHA-3 have been standardized, such as SHA3-224, SHA3-256,
  prefs: []
  type: TYPE_NORMAL
- en: SHA3-384, SHA3-512, SHAKE128, and SHAKE256\. In addition, SHAKE128 and
  prefs: []
  type: TYPE_NORMAL
- en: SHAKE256 are extendable-output functions (XOFs), which allow the output to be
  prefs: []
  type: TYPE_NORMAL
- en: extended to any desired length.
  prefs: []
  type: TYPE_NORMAL
- en: '105'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-125_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-24 sho](#p125)ws the sponge and squeeze model on which SHA-3 or Keccak
    is based. Analogous to a sponge, the data (m input data) is first “absorbed” into
    the sponge after applying padding. It is then changed into a subset of permutation
    state using
  prefs: []
  type: TYPE_NORMAL
- en: XOR (exclusive OR), and, finally, the output is “squeezed” out of the sponge
    function
  prefs: []
  type: TYPE_NORMAL
- en: representing the transformed state. The rate r is the input block size of the
    sponge
  prefs: []
  type: TYPE_NORMAL
- en: function, whereas capacity c determines the security level.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-24\.** The SHA-3 absorbing and squeezing function*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 2-24](#p125), state size b is calculated by adding bit rate r and
    capacity bits c. r and c can be any values if sizes of r + c are 25, 50, 100,
    200, 400, 800, or 1600\. The state is a three-dimensional bit matrix which is
    initially set to 0\. The data m is entered into the
  prefs: []
  type: TYPE_NORMAL
- en: absorb phase block by block via XOR ⊕ after applying padding.
  prefs: []
  type: TYPE_NORMAL
- en: Table [2-1](#p126) shows the value of bit rate r (block size) and capacity c
    required to achieve the desired output hash size under the most efficient setting
    of r + c = 1600\.
  prefs: []
  type: TYPE_NORMAL
- en: '106'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-126_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 2-1\.** Bit rate and capacity supported in SHA-3*'
  prefs: []
  type: TYPE_NORMAL
- en: '-'
  prefs: []
  type: TYPE_NORMAL
- en: The function f is a permutation function. It contains five transformation operations
  prefs: []
  type: TYPE_NORMAL
- en: 'named Theta, Rho, Pi, Chi, and Iota, which are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*θ*− *Theta*: XOR bits in the state, used for mixing'
  prefs: []
  type: TYPE_NORMAL
- en: '*ρ*− *Rho*: Diffusion function performing rotation of bits'
  prefs: []
  type: TYPE_NORMAL
- en: '*π*− *Pi*: Diffusion function'
  prefs: []
  type: TYPE_NORMAL
- en: '*χ*− *Chi*: XOR each bit, bitwise combine'
  prefs: []
  type: TYPE_NORMAL
- en: '*ι*− *Iota*: Combination with round constants'
  prefs: []
  type: TYPE_NORMAL
- en: The key idea is to apply these transformations to achieve the avalanche effect,
    which
  prefs: []
  type: TYPE_NORMAL
- en: ensures that even a tiny change in the input results in a substantial change
    in the output.
  prefs: []
  type: TYPE_NORMAL
- en: These five operations combined form a single round. In the SHA-3 standard, the
    number
  prefs: []
  type: TYPE_NORMAL
- en: of rounds is 24 to achieve the desired level of security.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Authentication Codes**'
  prefs: []
  type: TYPE_NORMAL
- en: Message authentication codes (MACs) are used to provide authentication services
    in a
  prefs: []
  type: TYPE_NORMAL
- en: cryptosystem. MACs are sometimes called keyed hash functions, and we can use
    them
  prefs: []
  type: TYPE_NORMAL
- en: to provide message integrity and data origin authentication. MACs can be constructed
  prefs: []
  type: TYPE_NORMAL
- en: using block ciphers or hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-25 sho](#p127)ws a MAC operation where a sender has appended an authentication
    tag T to the message M. MACs are symmetric cryptographic primitives that use a
    shared
  prefs: []
  type: TYPE_NORMAL
- en: key between the sender and the receiver. The sender uses this key to generate
    the
  prefs: []
  type: TYPE_NORMAL
- en: authentication tag, whereas the receiver uses the same key for verification.
    The MAC
  prefs: []
  type: TYPE_NORMAL
- en: function takes the key and message M as input and produces the authentication
    tag T.
  prefs: []
  type: TYPE_NORMAL
- en: '107'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-127_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-25\.** Operation of a MAC function*'
  prefs: []
  type: TYPE_NORMAL
- en: T and M are sent to the receiver who runs the same process and compares T with
    T’,
  prefs: []
  type: TYPE_NORMAL
- en: which the verifier has generated by applying the same MAC function, and if they
    match,
  prefs: []
  type: TYPE_NORMAL
- en: the verification is successful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash-Based MACs (HMACs)**'
  prefs: []
  type: TYPE_NORMAL
- en: Like the hash functions, hash-based MACs (HMACs) produce a fixed-length output
    and
  prefs: []
  type: TYPE_NORMAL
- en: take an arbitrarily long message as the input. In this scheme, the sender signs
    a message using the MAC, and the receiver verifies it using the shared secret
    key. The key is hashed with the message using either the secret prefix or the
    secret suffix method. With the
  prefs: []
  type: TYPE_NORMAL
- en: secret prefix method, the key is concatenated with the message, that is, the
    key comes
  prefs: []
  type: TYPE_NORMAL
- en: first, and the message comes afterward, whereas with the secret suffix method,
    the key
  prefs: []
  type: TYPE_NORMAL
- en: 'comes after the message, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secret* *prefix* : *M* = *MAC* ( ) = ('
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*k x*'
  prefs: []
  type: TYPE_NORMAL
- en: '*h k* || *x*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secret* *suffix* : *M* = *MAC* ( ) = ('
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*k x*'
  prefs: []
  type: TYPE_NORMAL
- en: '*h x* || *k*'
  prefs: []
  type: TYPE_NORMAL
- en: '108'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: There are pros and cons to both methods. Some attacks on both schemes have
  prefs: []
  type: TYPE_NORMAL
- en: occurred. HMAC construction schemes use *ipad* (inner padding) and *opad* (outer
    padding) for padding, which is considered secure with some assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Various significant applications of hash functions are used in peer-to-peer
    networks
  prefs: []
  type: TYPE_NORMAL
- en: and blockchain networks, such as Merkle trees, Patricia tries, Merkle Patricia
    tries, and distributed hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: Some latest advancements, such as verifiable delay functions, are discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verifiable Delay Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable delay functions (VDFs) are cryptographic primitives that require
    a sequential
  prefs: []
  type: TYPE_NORMAL
- en: number of steps (substantial time) to evaluate but are very quick and efficient
    to verify.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluation must be sequential, and even with parallelization, the evaluation
  prefs: []
  type: TYPE_NORMAL
- en: must take the specified amount of time. However, the verification is efficient.
    VDFs
  prefs: []
  type: TYPE_NORMAL
- en: have multiple applications in distributed networks, for example, they can be
    used as
  prefs: []
  type: TYPE_NORMAL
- en: randomness beacons that publish random, unpredictable, and non-manipulable values
  prefs: []
  type: TYPE_NORMAL
- en: at fixed intervals. Randomness beacons can be used to build random leader election
  prefs: []
  type: TYPE_NORMAL
- en: algorithms. VDFs also have applications in multiparty computations, permissionless
  prefs: []
  type: TYPE_NORMAL
- en: consensus, and timestamping of events.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, VDFs can be defined as follows. There are three procedures involved
  prefs: []
  type: TYPE_NORMAL
- en: 'in a VDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '*setup*( *λ*, *t*) → *pp* where *λ* is the security parameter and *t* is the
    time parameter, for example, a ten-minute delay.'
  prefs: []
  type: TYPE_NORMAL
- en: '*evaluate*( *pp*, *x*) → *y*, *π* where *x* is the input, *pp* is the public
    parameters, *y* is the output, and *π* is the proof. *π* can be optional depending
    on the construction.'
  prefs: []
  type: TYPE_NORMAL
- en: '*verify*( *pp*, *x*, *y*. *π*) → { *true*, *false*} which outputs either true
    or false indicating the success or failure of the verification which checks'
  prefs: []
  type: TYPE_NORMAL
- en: the correctness of the output.
  prefs: []
  type: TYPE_NORMAL
- en: There are two security properties of VDFs, uniqueness and sequentiality. Uniqueness
  prefs: []
  type: TYPE_NORMAL
- en: ensures that the output y produced by VDF is unique for every input x. The sequentiality
  prefs: []
  type: TYPE_NORMAL
- en: property ensures that the delay parameter t is enforced.
  prefs: []
  type: TYPE_NORMAL
- en: '109'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-129_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 2-26 sho](#p129)ws the operation of VDFs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 2-26\.** Operation of a VDF*'
  prefs: []
  type: TYPE_NORMAL
- en: There are many proposals on how to construct VDFs. Some approaches include
  prefs: []
  type: TYPE_NORMAL
- en: hardware enclaves to store cryptographic keys inside the enclave and use those
    keys to
  prefs: []
  type: TYPE_NORMAL
- en: generate VDFs. Using hash functions to iteratively hash the output again as
    input to form a hash chain is another way of constructing verifiable delay functions.
    Creating a hash
  prefs: []
  type: TYPE_NORMAL
- en: chain using a hash function iteratively is a sequential process and takes time;
    thus, it can work as an evaluation function of the VDF. Another method gaining
    more popularity
  prefs: []
  type: TYPE_NORMAL
- en: is the algebraic construction, where finite cyclic groups are used which are
    assumed to
  prefs: []
  type: TYPE_NORMAL
- en: have unknown order.
  prefs: []
  type: TYPE_NORMAL
- en: VDFs have many innovative applications in blockchains, including constructing
  prefs: []
  type: TYPE_NORMAL
- en: consensus algorithms, as a source of verifiable randomness and leader election.
    You will
  prefs: []
  type: TYPE_NORMAL
- en: explore these applications in detail when we discuss relevant consensus protocols
    in
  prefs: []
  type: TYPE_NORMAL
- en: Chapt[er 8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: '**Verifiable Random Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: A verifiable random function (VRF) is a pseudorandom public key function that
    provides
  prefs: []
  type: TYPE_NORMAL
- en: a proof that the output it has generated is correctly calculated. The owner
    of the private key generates the proof and output of the function which is verifiable
    publicly by a
  prefs: []
  type: TYPE_NORMAL
- en: public key to ascertain that the value is indeed correctly calculated. VRFs
    have many
  prefs: []
  type: TYPE_NORMAL
- en: applications in consensus algorithms and blockchains, for example, Cardano and
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot use them in the block production mechanism. They also have been used
    to
  prefs: []
  type: TYPE_NORMAL
- en: provide verifiable randomness on chains, for example, in the case of chainlink.
  prefs: []
  type: TYPE_NORMAL
- en: '110'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: • Cryptography is the science of secret communication.
  prefs: []
  type: TYPE_NORMAL
- en: • Symmetric key cryptography and asymmetric cryptography are the
  prefs: []
  type: TYPE_NORMAL
- en: two main categories of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: • Elliptic curve cryptography has found major applications in
  prefs: []
  type: TYPE_NORMAL
- en: blockchains and relevant consensus protocols, where commonly
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA is used for digitally signing blocks and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: • Hash functions create a fixed-length message digest of an arbitrary-
  prefs: []
  type: TYPE_NORMAL
- en: length input.
  prefs: []
  type: TYPE_NORMAL
- en: • MACs are message authentication codes used for message
  prefs: []
  type: TYPE_NORMAL
- en: authentication.
  prefs: []
  type: TYPE_NORMAL
- en: • Digital signatures provide nonrepudiation, integrity, and
  prefs: []
  type: TYPE_NORMAL
- en: authentication services.
  prefs: []
  type: TYPE_NORMAL
- en: • Authentication protocols are used in distributed systems to provide
  prefs: []
  type: TYPE_NORMAL
- en: entity authentication.
  prefs: []
  type: TYPE_NORMAL
- en: • Hybrid encryption schemes combine public and symmetric key
  prefs: []
  type: TYPE_NORMAL
- en: cryptography to achieve performance and security.
  prefs: []
  type: TYPE_NORMAL
- en: • Verifiable delay functions are functions that take time to evaluate
  prefs: []
  type: TYPE_NORMAL
- en: but are quick to verify and have many applications in consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocols and blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: • VRFs are public key–based functions which generate a verifiable
  prefs: []
  type: TYPE_NORMAL
- en: correct output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Paar, C. and Pelzl, J., 2009\. Understanding cryptography: a'
  prefs: []
  type: TYPE_NORMAL
- en: textbook for students and practitioners. Springer Science &
  prefs: []
  type: TYPE_NORMAL
- en: Business Media.
  prefs: []
  type: TYPE_NORMAL
- en: '111'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2 Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Martin, K.M., 2012\. Everyday cryptography. Everyday
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptography: Fundamental Principles and Applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print publication date: 2017 Print ISBN-13: 9780198788003,'
  prefs: []
  type: TYPE_NORMAL
- en: 'Published to Oxford Scholarship Online: July 2017, DOI:10.1093/'
  prefs: []
  type: TYPE_NORMAL
- en: oso/9780198788003.001.0001\.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Multisignatures: This scheme was introduced in 1983 by Itakura'
  prefs: []
  type: TYPE_NORMAL
- en: et al. in their paper A Public-key Cryptosystem Suitable for Digital
  prefs: []
  type: TYPE_NORMAL
- en: Multisignatures, vol. 71, Nec Research & Development (1983),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 474–480\. Multisignatures are also sometimes called multiparty
  prefs: []
  type: TYPE_NORMAL
- en: signatures in literature.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Daniel J. Bernstein and Tanja Lange. SafeCurves: choosing safe'
  prefs: []
  type: TYPE_NORMAL
- en: curves for elliptic-curve cryptograph[y. https://safecurves.](https://safecurves.cr.yp.to)
  prefs: []
  type: TYPE_NORMAL
- en: '[cr.yp.to](https://safecurves.cr.yp.to), accessed August 7, 2021\.'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. VDF research[: https://vdfresearch.org](https://vdfresearch.org)'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Boneh, D., Bonneau, J., Bünz, B., and Fisch, B., 2018, August.
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable delay functions. In *Annual international cryptology*
  prefs: []
  type: TYPE_NORMAL
- en: '*conference* (pp. 757–788). Springer, Cham.'
  prefs: []
  type: TYPE_NORMAL
- en: '112'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus is a fundamental problem in distributed computing. This chapter will
    cover
  prefs: []
  type: TYPE_NORMAL
- en: the fundamentals of the consensus problem and discuss some history covering
    the
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine generals problem, building blocks of consensus, and how we can solve
    this
  prefs: []
  type: TYPE_NORMAL
- en: problem in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: As fault tolerance is a fundamental requirement in distributed systems, several
  prefs: []
  type: TYPE_NORMAL
- en: primitives introduce fault tolerance. Fault-tolerant broadcast algorithms allow
    for the
  prefs: []
  type: TYPE_NORMAL
- en: development of fault-tolerant applications. Consensus enables processes to reach
    a
  prefs: []
  type: TYPE_NORMAL
- en: common decision despite failures. Both topics are well researched in academia
    and the
  prefs: []
  type: TYPE_NORMAL
- en: industry.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into discussing consensus and agreement problems in detail, let’s
  prefs: []
  type: TYPE_NORMAL
- en: cover some building blocks in continuation of link abstractions from Chapt[er
    1](https://doi.org/10.1007/978-1-4842-8179-6_1) that are closely related to consensus
    and agreement problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcast Primitives**'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in Chapt[er 1, w](https://doi.org/10.1007/978-1-4842-8179-6_1)e learned
    about links that pass messages between a pair of processes in a point-to-point
    or one-to-one setting. This one-to-one communication
  prefs: []
  type: TYPE_NORMAL
- en: (also called unicast) is quite common and used in the client-server architecture.
    For
  prefs: []
  type: TYPE_NORMAL
- en: example, a web server making requests to a backend database can be seen as an
  prefs: []
  type: TYPE_NORMAL
- en: example of this type of two-sided connection. There is one sender and one specific
  prefs: []
  type: TYPE_NORMAL
- en: recipient, that is, the web server and backend database, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: However, in many cases where multiple nodes are involved, the client-server
    type
  prefs: []
  type: TYPE_NORMAL
- en: scheme is not adequate. Moreover, in many situations, one-to-one communication
  prefs: []
  type: TYPE_NORMAL
