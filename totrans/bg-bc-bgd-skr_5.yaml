- en: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal,
    Gautam Dhameja and Priyansu Sekhar PandaBeginning Blockchain[https://doi.org/10.1007/978-1-4842-3444-0_5](A440588_1_En_5_Chapter.xhtml)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 5. Blockchain Application Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1)Bangalore,
    Karnataka, India(2)Berlin, Berlin, GermanyIn the previous chapters we went into
    theoretical details about what blockchain is and how the Bitcoin and Ethereum
    blockchains work. We also looked at the different cryptographic and mathematical
    algorithms, theorems, and proofs that go into making the blockchain technology.In
    this chapter, we will start with how blockchain applications are different than
    the conventional applications, and then we will dive into how to build applications
    on blockchains. We will also look at setting up the necessary infrastructure needed
    to start developing decentralized applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Applications
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The popularity of blockchain technology is mostly driven by the fact that it
    can potentially solve various real-world problems because it provides more transparency
    and security (tamper-proof) than conventional technologies. There are a lot of
    blockchain use cases identified by several startups and community members aimed
    at solving these problems. To implement these use cases, we create applications
    that work on top of blockchains. In general, applications that interact with blockchains
    are referred to as “decentralized applications” or, in short, just DApps or dApps.To
    understand DApps better, let’s first revisit what a blockchain is. A blockchain
    or a distributed ledger is basically a special kind of database where the data
    is not stored at a centralized server, but it is copied at all the participating
    nodes in the network. Also, the data on blockchains is cryptographically signed,
    which proves the identity of the entity who wrote that data on the blockchain.
    To make use of this database to store and retrieve data, we create applications
    that are called DApps because these applications do not rely on a centralized
    database but on a blockchain-based decentralized data store. There is no single
    point of failure or control for these applications.Let’s take an example of a
    DApp. Let’s take a scenario of supply chain where several vendors and logistics
    partners are involved in the supply chain process of manufactured goods. To use
    blockchain technology for this supply chain use case, here’s what we would do:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We would need to set up blockchain nodes at each of these vendors so that they
    can participate in the consensus process on the data shared.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would need an interface so that all the participants and users can store,
    retrieve, verify, and evaluate data on the blockchain. This interface would be
    used by the manufacturer to enter the information about the goods manufactured;
    by the logistics partner to enter information about the transfer of goods; by
    the warehousing vendor to verify if the goods manufactured and the goods transferred
    are in sync, etc., etc. This interface would be our supply chain DApp.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个接口，以便所有参与者和用户都能在区块链上存储、检索、验证和评估数据。这个接口将供制造商使用，以输入生产的商品信息；供物流合作伙伴使用，以输入关于货物转移的信息；供仓储供应商使用，以验证生产的商品和转移的商品是否同步等等。这个接口将是我们的供应链DApp。
- en: Another example of a DApp would be a voting system based on blockchains. Using
    blockchain for voting, we would be able to make the whole process much more transparent
    and secure because each vote would be cryptographically signed. We would need
    to create an application that could get a list of candidates for whom voters could
    vote, and this application would also provide a simple interface to submit and
    record the votes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个DApp的例子是基于区块链的投票系统。使用区块链进行投票，我们能够使整个过程更加透明和安全，因为每一票都会被加密签名。我们需要创建一个应用程序，可以获取一份候选人名单，选民可以为这些候选人投票，这个应用程序还将提供一个简单的界面来提交和记录投票。
- en: Blockchain Application Development
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链应用开发
- en: Before we jump into code, let’s first understand some basic concepts around
    blockchain application development. Generally, we are used to concepts like objects,
    classes, functions, etc. when we develop conventional software applications. However,
    when it comes to blockchain applications, we need to understand a few more concepts
    like transactions, accounts and addresses, tokens and wallets, inputs, and outputs
    and balances. The handshake and request/response mechanism between a decentralized
    application and a blockchain are driven by these concepts.First, when developing
    an application based on blockchain, we need to identify how the application data
    would map to the blockchain data model. For example, when developing a DApp on
    the Ethereum blockchain, we need to understand how the application state can be
    represented in terms of Solidity data structures and how the application’s behavior
    can be expressed in terms of Ethereum smart contracts. As we know that all data
    on a blockchain is cryptographically signed by private keys of the users, we need
    to identify which entities in our application would have identities or addresses
    represented on the blockchain. In conventional applications this is generally
    not the case, because the data is not always signed. For blockchain application
    we need to define who would be the signers and what data they would sign. For
    example, in a voting DApp in which every voter cryptographically signs their vote,
    this is easy to identify. However, imagine a scenario where we need to migrate
    an existing conventional distributed systems application, having its data stored
    across multiple SQL tables and databases, to a DApp based on Ethereum blockchain.
    In this case we need to identify which entities in which table would have their
    identities and which entities would be attached to other identities.In the next
    few sections, we will explore Bitcoin and Ethereum application programming using
    simple code snippets to send some transactions. The purpose of this exercise is
    to become familiar with the blockchain APIs and common programming practices.
    For simplicity, we will be using public test networks for these blockchains and
    we will write code in JavaScript. The reason for selecting JavaScript is, at the
    time of this writing, we have stable JavaScript libraries available for both blockchains
    and it will be easier to understand the similarities and differences in the approaches
    we take while writing code. The code snippets are explained in detail after every
    logical step and can be understood even if the reader is not familiar with JavaScript
    programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，首先需要理解围绕区块链应用开发的一些基本概念。通常，当我们开发传统的软件应用时，我们会用到像对象、类、函数等概念。然而，当涉及到区块链应用时，我们需要了解一些更多的概念，比如交易、账户和地址、代币和钱包、输入和输出以及余额。去中心化应用与区块链之间的握手和请求/响应机制正是由这些概念驱动的。首先，当基于区块链开发应用时，我们需要确定应用数据如何映射到区块链数据模型。例如，在基于以太坊区块链开发DApp时，我们需要了解应用状态如何以Solidity数据结构表示，以及应用行为如何以以太坊智能合约为表达。我们知道，区块链上的所有数据都由用户的私钥以加密方式签署，因此我们需要确定我们应用中的哪些实体将在区块链上具有身份或地址表示。在传统应用中，通常并非如此，因为数据不总是被签署。对于区块链应用，我们需要定义谁将是签署者以及他们会签署哪些数据。例如，在一个每个选民都通过加密方式签署他们选票的投票DApp中，这是容易确定的。然而，想象一个场景，我们需要将一个现有的传统分布式系统应用迁移到一个基于以太坊区块链的DApp。在这种情况下，我们需要确定哪个表中的哪个实体将具有其身份，以及哪些实体将附属于其他身份。在接下来的几节中，我们将通过一些简单的代码片段来探索比特币和以太坊的应用编程，发送一些交易。这个练习的目的是熟悉区块链API和常见的编程实践。为了简单起见，我们将使用这些区块链的公共测试网络，并且我们将用JavaScript编写代码。选择JavaScript的原因是，在撰写本文时，我们已经为这两个区块链提供了稳定的JavaScript库，而且通过编写代码来理解我们所采取的方法的相似之处和不同之处会更容易。每个逻辑步骤之后都有详细的代码片段解释，即使读者不熟悉JavaScript编程，也能理解。
- en: Libraries and Tools
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库和工具
- en: Recall from Chapter [2](A440588_1_En_2_Chapter_split_000.xhtml), that there
    are a lot of cryptographic algorithms and mathematics used in blockchain technology.
    Before we send our transactions to blockchains from an application, we need to
    prepare them. The transaction preparation includes defining accounts and addresses,
    adding required parameters and values to the transaction objects, and signing
    using private keys, among a few other things. When developing applications, it’s
    better to use verified and tested libraries for transaction preparation instead
    of writing code from scratch. Some of the stable libraries for both Bitcoin and
    Ethereum are available open source, which can be used to prepare and sign transactions
    and to send them to the blockchain nodes/network. For the purpose of our code
    exercises, we will be using the bitcoinjs JavaScript library for interacting with
    the Bitcoin blockchain and the web3.js JavaScript library for interacting with
    the Ethereum blockchain. Both these libraries are available as node.js packages
    and can be downloaded and integrated using the npm commands.Important NoteThe
    code exercises in this chapter are based on node.js applications. This is to make
    sure that the code we write as part of this exercise has a container in which
    it can run and interact with the other prepackaged libraries (node modules) mentioned.
    It is nice to have some knowledge about node.js application development, and the
    reader is encouraged to follow a getting started tutorial on node.js and npm.Figure [5-1](#Fig1)
    shows how a DApp interacts with a blockchain.![A440588_1_En_5_Fig1_HTML.jpg](Images/A440588_1_En_5_Fig1_HTML.jpg)Figure
    5-1Blockchain application interaction
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第[2](A440588_1_En_2_Chapter_split_000.xhtml)章的内容，区块链技术中使用了大量的加密算法和数学。在我们从应用程序中将交易发送到区块链之前，我们需要准备好这些交易。交易准备包括定义账户和地址，向交易对象添加所需的参数和值，以及使用私钥进行签名等几个其他步骤。在开发应用程序时，最好使用经过验证和测试的交易准备库，而不是从头编写代码。一些适用于比特币和以太坊的稳定库是开源的，可以用来准备和签名交易，并将它们发送到区块链节点/网络。为了我们的代码练习，我们将使用bitcoinjs
    JavaScript库与比特币区块链互动，以及web3.js JavaScript库与以太坊区块链互动。这两个库都可以作为node.js包使用，并可以使用npm命令下载和集成。重要提示本章的代码练习基于node.js应用程序。这是为了确保我们作为本练习编写的代码有一个可以运行和与其他预包装库（node模块）互动的容器。了解一些关于node.js应用程序开发的知识是很好的，读者被鼓励跟随一个关于node.js和npm的入门教程。图[5-1](#Fig1)展示了DApp如何与区块链互动。![A440588_1_En_5_Fig1_HTML.jpg](Images/A440588_1_En_5_Fig1_HTML.jpg)图
    5-1区块链应用程序互动
- en: Interacting with the Bitcoin Blockchain
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与比特币区块链互动
- en: 'In this section we will send a transaction to the Bitcoin public test network
    from one address to another. Consider this a “Hello World” application for the
    Bitcoin blockchain. As mentioned before, we will be using the bitcoinjs JavaScript
    library for preparing and signing transactions. And for simplicity, instead of
    hosting a local Bitcoin node, we will use a public Bitcoin test network node hosted
    by a third-party provider block-explorer. Note that you can use any provider for
    your application and you can also host a local node. All you need to do is to
    point your application code to connect to your preferred node.Recall from previous
    chapters that the Bitcoin blockchain is primarily for enabling peer to peer payments.
    A Bitcoin transaction is mostly just a transfer of Bitcoins from one address to
    another. Here’s how we do this programmatically.The following (Figure [5-2](#Fig2))
    shows how this code interacts with the Bitcoin blockchain. Note: The figure is
    just a rough sketch and does not show the Block Explorer service architecture
    in detail.![A440588_1_En_5_Fig2_HTML.jpg](Images/A440588_1_En_5_Fig2_HTML.jpg)Figure
    5-2Application interacting with the Bitcoin blockchain using the Block Explorer
    APIThe following subheadings of this section are steps to follow, in that order,
    to send a transaction to the Bitcoin test network using JavaScript.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从一台机器的一个地址向另一台机器的地址发送一个比特币交易到比特币公共测试网络。这可以看作是针对比特币区块链的“Hello World”应用程序。如前所述，我们将使用bitcoinjs
    JavaScript库来准备和签名交易。为了简化，我们不会运行本地的比特币节点，而是使用第三方提供商block-explorer提供的公共比特币测试网络节点。请注意，您可以使用任何提供商为您应用程序提供服务，也可以托管本地节点。您需要做的就是让您的应用程序代码连接到您选择的节点。回想一下，比特币区块链主要用于实现点对点支付。比特币交易主要是将比特币从一台机器的一个地址转移到另一台机器的地址。以下是我们如何以编程方式实现这一点。
- en: Setup and Initialize the bitcoinjs Library in a node.js Application
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在node.js应用程序中设置并初始化bitcoinjs库
- en: 'Before we call the library-specific code for Bitcoin transactions, we will
    install and initialize the bitcoinjs library.After initializing a node.js applicaion
    using the npm init command, let’s create an entry point for our application, index.js,
    and custom JavaScript module to call the bitcoinjs library functions btc.js. Import
    btc.js in the index.js. Now, we are ready to follow the next steps.First, let’s
    install the node module for bitcoinjs:npm install --save bitcoinjs-libThen, in
    our Bitcoin module btc.js, we will initialize the bitcoinjs library using the
    require keyword:var btc = require(''bitcoinjs-lib'');Now we can use this btc variable
    to call library functions on the bitcoinjs library. Also, as part of the initialization
    process, we are initializing a couple of more variables:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用针对比特币交易的库特定代码之前，我们将安装并初始化bitcoinjs库。在使用npm init命令初始化node.js应用程序后，让我们创建一个应用程序的入口点，即index.js，以及自定义JavaScript模块来调用bitcoinjs库函数btc.js。在index.js中导入btc.js。现在，我们准备好了下一步。首先，让我们安装bitcoinjs的node模块：npm
    install --save bitcoinjs-lib然后，在我们的比特币模块btc.js中，我们使用require关键字初始化bitcoinjs库：var
    btc = require('bitcoinjs-lib');现在我们可以使用这个btc变量来调用比特币js库的库函数。此外，作为初始化过程的一部分，我们初始化了一些其他变量：
- en: 'The network to target : We are using the Bitcoin test network.var network =
    btc.networks.testnet;'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标网络：我们使用比特币测试网络。var network = btc.networks.testnet;
- en: 'The public node API endpoint to get and post transactions : We are using the
    Block Explorer API for Bitcoin test network. Note that you can replace this API
    endpoint with your preferred one.var blockExplorerTestnetApiEndpoint = ''https://testnet.blockexplorer.com/api/'';'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和发送交易的公共节点API端点：我们使用Block Explorer API进行比特币测试网络。请注意，您可以将此API端点替换为您喜欢的端点。var
    blockExplorerTestnetApiEndpoint = 'https://testnet.blockexplorer.com/api/';
- en: At this point, we are all set up to create a Bitcoin transaction using a node.js
    application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经准备好使用node.js应用程序创建一个比特币交易。
- en: Create Keypairs for the Sender and Receiver
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为发送者和接收者创建密钥对
- en: 'The first thing that we will need are the keypairs for the sender and the receivers.
    These are like user accounts identifying the users on the blockchain. So, let’s
    first create two keypairs  for Alice and Bob.var getKeys = function () {    var
    aliceKeys = btc.ECPair.makeRandom({        network: network    });    var bobKeys
    = btc.ECPair.makeRandom({        network: network    });    var alicePublic =
    aliceKeys.getAddress();    var alicePrivate = aliceKeys.toWIF();    var bobPublic
    = bobKeys.getAddress();    var bobPrivate = bobKeys.toWIF();    console.log(alicePublic,
    alicePrivate, bobPublic, bobPrivate);};What we did in the previous code snippet
    is, we used the ECPair class of the bitcoinjs library and called the makeRandom
    method on it to create random keypairs for the test network; note the parameter
    passed for network type.Now that we have created a couple of keypairs  , let’s
    use them to send Bitcoins from one to the other. In almost all the cryptography
    examples, Alice and Bob have been the favorite characters, as seen in the preceding
    keypair variables. However, every time we see a cryptography example, generally
    Alice is the one who encrypts/signs something and sends to Bob. For that reason,
    we feel Bob is under a lot of debt from Alice, so in our case we will help Bob
    repay some of that debt. We will do this example Bitcoin transaction from Bob
    to Alice.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先需要的是发送者和接收者的密钥对。这些就像用户账户，它们在区块链上标识用户。所以，让我们首先为爱丽丝和鲍勃创建两个密钥对。var getKeys
    = function () {    var aliceKeys = btc.ECPair.makeRandom({        network: network    });    var
    bobKeys = btc.ECPair.makeRandom({        network: network    });    var alicePublic
    = aliceKeys.getAddress();    var alicePrivate = aliceKeys.toWIF();    var bobPublic
    = bobKeys.getAddress();    var bobPrivate = bobKeys.toWIF();    console.log(alicePublic,
    alicePrivate, bobPublic, bobPrivate);};在上一个代码片段中，我们使用了比特币js库的ECPair类，并调用其makeRandom方法来为测试网络创建随机的密钥对；请注意传递给网络类型的参数。现在我们已经创建了一对密钥对，让我们用它们将比特币从一个人发送到另一个人。在几乎所有的密码学示例中，爱丽丝和鲍勃都是最受欢迎的角色，正如前面密钥对变量所看到的。然而，每次我们看到一个密码学示例时，通常爱丽丝是加密/签名某物并发送给鲍勃的那个人。因此，我们觉得鲍勃欠爱丽丝很多债务，所以在我们这个案例中，我们将帮助鲍勃偿还其中一部分债务。我们将通过鲍勃到爱丽丝的这个示例比特币交易来实现这一点。'
- en: Get Test Bitcoins in the Sender’s Wallet
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在发送者的钱包中获取测试比特币
- en: We have identified that Bob is going to be acting as the sender in this example
    Bitcoin transaction. Before he sends any Bitcoins to Alice, he needs to own them.
    As we know that this example transaction is targeting the Bitcoin test network,
    there is no real money involved but we still need some test Bitcoins in Bob’s
    wallet. A simple way to get test network Bitcoins is to ask on the Internet. There
    are a lot of websites on the Internet that host a simple web form to take the
    Bitcoin testnet addresses and then send test net Bitcoins to those. These services
    are called Bitcoin testnet faucets, and if you search online for that term you
    will get a lot of those in the search results. We are not listing or recommending
    any specific testnet faucet because they are generally not permanent. As soon
    as a faucet service provider has exhausted their test coins, or they don’t want
    to host the service anymore, they shut it down. But then new ones keep coming
    up all the time. A list of some of these faucet services is also available on
    the Bitcoin wiki testnet page.Another way of getting test net Bitcoins is to host
    a local Bitcoin node pointing to the test net and mine some. The block mining
    on the Bitcoin test network is not as difficult as that on the main network. This
    approach could well be the next level approach when you are building a production
    Bitcoin application and you need to test it frequently. Instead of asking for
    test coins every time you want to test your application, you can just mine them
    yourself.For the purposes of this simple example, we will just get some Bitcoins
    from a testnet faucet. In the previous code snippet, the value in the bobPublic
    variable is Bob’s Bitcoin testnet address. When we ran this snippet, it generated
    “msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2” as Bob’s address. It is also Bob’s base 58
    encoded public key. We will submit this value in one of the testnet faucet web
    forms and in return we will receive a transaction ID. If we look up that transaction
    ID on any of the Bitcoin testnet explorers, we will see that some other address
    has sent some test Bitcoins to Bob’s address we submitted in the form.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定在这个示例比特币交易中，Bob 将扮演发送者的角色。在他向 Alice 发送任何比特币之前，他需要拥有这些比特币。由于我们知道这个示例交易针对的是比特币测试网络，其中并没有涉及真实货币，但我们仍然需要一些测试比特币在
    Bob 的钱包里。获取测试网络比特币的一个简单方法就是在互联网上寻求帮助。互联网上有许多网站提供了一个简单的网络表单，用于接收比特币测试网络地址，然后向这些地址发送测试网络比特币。这些服务被称为比特币测试网络水龙头，如果你在网上搜索这个术语，你会在搜索结果中找到很多这样的服务。我们没有列出或推荐任何特定的测试网络水龙头，因为它们通常不是永久的。一旦水龙头服务提供商耗尽了他们的测试硬币，或者他们不再想提供服务，他们就会关闭它。但然后新的服务会不断出现。关于这些水龙头服务的列表也存在于比特币维基测试网络页面中。获取测试网络比特币的另一种方法是运行一个本地比特币节点，指向测试网络，并挖矿一些。比特币测试网络的区块挖掘难度不如主网络。当构建一个生产比特币应用程序并需要频繁测试时，这种方法可能是下一个级别的解决方案。而不是每次想要测试应用程序时都请求测试硬币，你可以自己挖矿。对于这个简单的示例，我们只需从测试网络水龙头获取一些比特币。在前面的代码片段中，bobPublic
    变量中的值是 Bob 的比特币测试网络地址。当我们运行这个片段时，它生成了“msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2”作为 Bob
    的地址。这也是 Bob 的 base 58 编码的公钥。我们将在其中一个测试网络水龙头网络表单中提交这个值，作为回报，我们将收到一个交易ID。如果我们在任何比特币测试网络浏览器中查找这个交易ID，我们会看到另一个地址向我们在表单中提交的
    Bob 的地址发送了一些测试比特币。
- en: Get the Sender’s Unspent Outputs
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取发送者的未花费输出
- en: 'Now that we know that we have some test Bitcoins in Bob’s wallet, we can spend
    them and give them to Alice through a Bitcoin transaction. Let’s recall from Chapter
    [3](A440588_1_En_3_Chapter.xhtml) how the Bitcoin transactions are made of inputs
    and outputs. You can spend your unspent outputs by adding them as inputs to the
    transactions where you want to spend them. To do that, first you need to query
    the network about the sender’s unspent outputs. Here’s how we will do that for
    Bob’s Bitcoin testnet address using the block explorer API. To get the unspent
    outputs, we will send an HTTP request to the UTXO endpoint with Bob’s address
    "msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2".var getOutputs = function () {    var url
    = blockExplorerTestnetApiEndpoint + ''addr/'' + msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2
    + ''/utxo'';    return new Promise(function (resolve, reject) {        request.get(url,
    function (err, res, body) {            if (err) {                reject(err);            }            resolve(body);        });    });};In
    the previous code snippet, we have used the node.js request module to send http
    requests using a node.js application. Feel free to use your favorite http library/module.
    This snippet is a JavaScript function that returns a promise that resolves into
    the response body from the API method. Here’s how the response looks:[    {        address:
    ''msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2'',        txid: ''db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958'',        vout:
    0,        scriptPubKey: ''76a914806094191cbd4fcd8b4169a70588adc51dc02d6888ac'',        amount:
    0.99992,        satoshis: 99992000,        height: 1258815,        confirmations:
    1011    },    {      address: ''msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2'',        txid:
    ''5b88d5fc4675bb86b0a3a7fc5a36df9c425c3880a7453e3afeb4934e6d1d928e'',        vout:
    1,        scriptPubKey: ''76a914806094191cbd4fcd8b4169a70588adc51dc02d6888ac'',        amount:
    0.99998,        satoshis: 99998000,        height: 1258814,        confirmations:
    1012    }]The response body returned by the call is a JSON array with two objects.
    Each of these objects represents an unspent output for Bob. Each output has txid,
    which is the transaction ID where this output is listed, the amount associated
    with output, and the vout, which means the sequence or index number of the output
    in that transaction. There is some other information in the JSON objects too,
    but that will not be used in the transaction preparation process.If we take the
    first object in the array, it basically says that the Bitcoin testnet address
    "msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2" has `99992000` unspent satoshis coming from
    the transaction `db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958`
    at the index `0`. Similarly, the second object represents `99998000` unspent satoshis
    coming from the transaction `5b88d5fc4675bb86b0a3a7fc5a36df9c425c3880a7453e3afeb4934e6d1d928e`
    at the index `1`.Don’t forget that "msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2" is Bob’s
    Bitcoin testnet, which we created in step 2 earlier. Now we know that Bob has
    this many satoshis, which he can spend in a new transaction.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '既然我们知道 Bob 的钱包里有一些测试比特币，我们就可以通过比特币交易将它们花掉并转给 Alice。让我们回顾一下第[3](A440588_1_En_3_Chapter.xhtml)章中比特币交易是如何由输入和输出组成的。你可以通过将未花费的输出作为输入添加到你想花费的交易中来花费你的未花费输出。为此，首先你需要查询网络关于发送者未花费输出的信息。下面是我们将通过
    block explorer API 为 Bob 的比特币测试网络地址这样做的方式。为了获取未花费输出，我们将向 UTXO 端点发送一个 HTTP 请求，带有
    Bob 的地址 "msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2"。var getOutputs = function () {    var
    url = blockExplorerTestnetApiEndpoint + ''addr/'' + msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2
    + ''/utxo'';    return new Promise(function (resolve, reject) {        request.get(url,
    function (err, res, body) {            if (err) {                reject(err);            }            resolve(body);        });    });};在前面的代码片段中，我们使用了
    node.js request 模块来发送使用 node.js 应用程序的 HTTP 请求。请随意使用你喜欢的 HTTP 库/模块。这个代码片段是一个 JavaScript
    函数，它返回一个解析为 API 方法响应体的承诺。响应看起来是这样的：[    {        address: ''msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2'',        txid:
    ''db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958'',        vout:
    0,        scriptPubKey: ''76a914806094191cbd4fcd8b4169a70588adc51dc02d6888ac'',        amount:
    0.99992,        satoshis: 99992000,        height: 1258815,        confirmations:
    1011    },    {        address: ''msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2'',        txid:
    ''5b88d5fc4675bb86b0a3a7fc5a36df9c425c3880a7453e3afeb4934e6d1d928e'',        vout:
    1,        scriptPubKey: ''76a914806094191cbd4fcd8b4169a70588adc51dc02d6888ac'',        amount:
    0.99998,        satoshis: 99998000,        height: 1258814,        confirmations:
    1012    }]调用返回的响应体是一个 JSON 数组，里面有两个对象。每个这些对象代表 Bob 的一个未花费输出。每个输出都有一个 txid，即这个输出列出的交易
    ID，与输出关联的金额，以及 vout，即在这个交易中的输出的序列或索引号。JSON 对象中还有一些其他信息，但在交易准备过程中不会使用。如果我们取数组中的第一个对象，它基本上说明比特币测试网络地址
    "msDkUzzd69idLLGCkDFDjVRz44jHcV3pW2" 来自交易 "db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958"
    的索引 "0" 有 `99992000` 个未花费的 Satoshis。同样，第二个对象表示来自交易 "5b88d5fc4675bb86b0a3a7fc5a36df9c425c3880a74'
- en: Prepare Bitcoin Transaction
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备比特币交易
- en: The next step is to prepare a Bitcoin transaction in which Bob can send the
    test coins to Alice. Preparing the transaction is basically defining its inputs,
    outputs, and amount.As we know from the previous step that Bob has two unspent
    outputs under his Bitcoin testnet address, let’s spend the first element of the
    outputs array. Let’s add this as an input to our transaction.var utxo = JSON.parse(body.toString());var
    transaction = new btc.TransactionBuilder(network);transaction.addInput(utxo[0].txid,
    utxo[0].vout);In the prceding code snippet, first we have parsed the response
    we received from the previous API call to get Bob’s unspent outputs.Then we have
    created a transaction builder object for the Bitcoin test network using the bitcoinjs
    library.In the last line, we have defined a transaction input. Note that this
    input is referring to the element at 0 index of the utxo array, which we received
    in the API call from the previous step. We have passed the transaction ID (txid)
    and vout from the unspent to the transaction.addInput method as input parameters.Basically,
    we are defining what we want to spend and where we got it from.Next, we add the
    transaction outputs. This is where we say how we want to spend what we added in
    the input. In the line following, we have added a transaction output by calling
    the addOutput method on the transaction builder object and passed in the target
    address and the amount. Bob wants to send 99990000 satoshis to Alice. Notice that
    we have used Alice’s Bitcoin testnet address as the function’s first parameter.transaction.addOutput(alicePublic,
    99990000);While we have used only one input and one output in this example transaction,
    a transaction can have multiple inputs and outputs. An important thing to note
    is that the total amount in inputs should not be less than the total amount in
    outputs. Most of the time, the amount in inputs is slightly more than the amount
    in outputs, and the difference is the transaction fee offered to the miners to
    include this transaction when they mine the next block.In this transaction, we
    have 2,000 satoshis as the transaction fee, which is the difference between input
    amount (99992000) and the output amount (99990000). Note that we don’t have to
    create any outputs for the transaction fee; the difference between the input and
    output total amounts is automatically taken as the transaction fee.Also, note
    that we cannot spend partial unspent outputs. If an unspent output has x amount
    of Bitcoins associated with it then we must spend all of the x Bitcoins when adding
    this unspent output as an input in a transaction. So, in case Bob doesn’t want
    to give all the 99,990,000 satoshis associated with his unspent output to Alice,
    then we need to give it back to Bob by adding another output to the transaction
    with an amount equal to the difference of total unspent amount and the amount
    Bob wants to give to Alice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备一笔比特币交易，以便鲍勃可以将测试币发送给爱丽丝。准备交易基本上就是定义它的输入、输出和金额。正如我们在上一步所知道的那样，鲍勃在他的比特币测试网络地址下有两个未花费的输出，让我们花费输出数组的第一个元素。把这个作为输入添加到我们的交易中。var
    utxo = JSON.parse(body.toString());var transaction = new btc.TransactionBuilder(network);transaction.addInput(utxo[0].txid,
    utxo[0].vout);在前面的代码片段中，首先我们解析了从前一个API调用中收到的响应，以获取鲍勃的未花费输出。然后我们使用bitcoinjs库为比特币测试网络创建了一个交易构建器对象。在最后一行，我们定义了一个交易输入。注意这个输入指的是utxo数组中0索引的元素，这是我们在上一步的API调用中收到的。我们将交易ID（txid）和未花费的vout从交易中作为输入参数传递给addInput方法。基本上，我们在定义我们要花费什么以及我们从哪里得到它。接下来，我们添加交易输出。这是我们说明我们想要如何花费添加到输入中的内容的地方。在下面的一行中，我们通过在交易构建器对象上调用addOutput方法并传入目标地址和金额，添加了一个交易输出。鲍勃想要将99990000萨索斯发送给爱丽丝。注意我们使用了爱丽丝的比特币测试网络地址作为函数的第一个参数。transaction.addOutput(alicePublic,
    99990000);虽然在这个例子交易中我们只使用了一个输入和一个输出，但一个交易可以有多个输入和输出。需要记住的重要一点是，输入中的总金额不应少于输出中的总金额。大多数时候，输入的金额略多于输出的金额，差异是提供给矿工的费用，以便他们在挖下一个区块时包含这个交易。在这个交易中，我们交易费用为2000萨索斯，这是输入金额（99992000）和输出金额（99990000）之间的差异。注意我们不必为交易费用创建任何输出；输入和输出总金额之间的差异自动作为交易费用。另外，请注意我们不能花费部分未花费的输出。如果一个未花费的输出与x金额的比特币相关联，那么在将这个未花费的输出作为交易输入时，我们必须花费所有的x比特币。所以，如果鲍勃不想将与他未花费输出关联的99,990,000萨索斯全部送给爱丽丝，那么我们需要通过在交易中添加另一个金额等于总未花费金额和鲍勃想给爱丽丝的金额之间的差异的输出，将它们还给鲍勃。
- en: Sign Transaction Inputs
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署交易输入
- en: Now, that we have defined the inputs and outputs in the transaction, we need
    to sign the inputs using Bob’s keys. The following line of code calls the sign
    function on the transaction builder object to cryptographically sign the transaction
    using Bob’s private key, but it takes the whole key pair object as an input parameter.transaction.sign(0,
    bobKeys);Note that the transaction.sign function takes the index of the input
    and the full key pair as input parameters. In this transaction, because we have
    only one input, the index we have passed is 0.At this stage, our transaction is
    prepared and signed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经定义了交易中的输入和输出，接下来我们需要使用鲍勃的密钥来签名输入。下面的代码行调用了交易构建对象上的签名函数，使用鲍勃的私钥对交易进行加密签名，但它将整个密钥对对象作为输入参数。`transaction.sign(0,
    bobKeys);`请注意，`transaction.sign`函数接受输入的索引和完整的密钥对作为输入参数。在这个交易中，因为我们只有一个输入，所以我们传递的索引是0。在这个阶段，我们的交易已经准备就绪并签名为止。
- en: Create Transaction Hex
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建交易十六进制字符串
- en: Now we will create a hex string from the transaction object.var transactionHex
    = transaction.build().toHex();The output of this line of code is the following
    string, which represents our prepared transaction; this step is needed because
    the send transaction API accepts the raw transaction as a string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从交易对象创建一个十六进制字符串。`var transactionHex = transaction.build().toHex();`此代码行的输出如下面的字符串，它表示我们准备好的交易；这一步是必需的，因为发送交易API接受原始交易作为一个字符串。
- en: Broadcast Transaction to the Network
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将交易广播到网络
- en: 'Finally, we use the hex string value we generated in the last step and send
    it to the block explorer public testnet node using the API,var txPushUrl = blockExplorerTestnetApiEndpoint
    + ''tx/send'';request.post({    url: txPushUrl,        json: {            rawtx:
    transactionHex        }    }, function (err, res, body) {        if (err) console.log(err);        console.log(res);        console.log(body);    });If
    the transaction is accepted by the block explorer public node, we will receive
    a transaction ID as the response of this API call,{    txid: "db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958"}Now
    that we have the transaction ID of our transaction, we can look it up on any of
    the online testnet explorers to see if and when it gets mined and how many confirmations
    it has.Putting it all together, here’s the complete code for sending a Bitcoin
    testnet transaction using JavaScript. The input parameters are the Bitcoin testnet
    keypairs we created in step 1.var createTransaction = function (aliceKeys, bobKeys)
    {    getOutputs(bobKeys.getAddress()).then(function (res) {        var utxo =
    JSON.parse(res.toString());        var transaction = new btc.TransactionBuilder(network);        transaction.addInput(utxo[0].txid,
    utxo[0].vout);        transaction.addOutput(alicekeys.getAddress(), 99990000);        transaction.sign(0,
    bobKeys);        var transactionHex = transaction.build().toHex();        var
    txPushUrl = blockExplorerTestnetApiEndpoint + ''tx/send'';        request.post({            url:
    txPushUrl,            json: {                rawtx: transactionHex            }        },
    function (err, res, body) {            if (err) console.log(err);            console.log(res);            console.log(body);        });    });};In
    this section we learned how we can programmatically send a transaction to the
    Bitcoin test network. Similarly, we can send transactions to the Bitcoin main
    network by using the main network as the target in the library functions and in
    the API endpoints. We also used the query APIs to get unspent outputs of a Bitcoin
    address. These functions can be used to create a simple Bitcoin wallet application
    to query and manage Bitcoin addresses and transactions.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们使用在上一步生成的十六进制字符串值，并通过API将其发送到区块链浏览器公共测试网节点，`txPushUrl = blockExplorerTestnetApiEndpoint
    + ''tx/send'';`。请求.post({    url: txPushUrl,        json: {            rawtx:
    transactionHex        }    }, 函数 (err, res, body) {        如果 (err) 控制台.log(err);        控制台.log(res);        控制台.log(body);    });如果区块链浏览器公共节点接受了交易，我们将收到作为此API调用响应的交易ID，{        txid:
    "db2e5966c5139c6e937203d567403867643482bbd9a6624752bbc583ca259958"}既然我们有了交易的交易ID，我们可以在任何在线测试网浏览器中查找它，以查看它何时被挖掘以及它有多少确认。综上所述，这是使用JavaScript发送比特币测试网交易的完整代码。输入参数是我们在第1步创建的比特币测试网密钥对。var
    createTransaction = 函数 (aliceKeys, bobKeys) {    获取输出(bobKeys.getAddress()).then(函数
    (res) {        var utxo = JSON.parse(res.toString());        var transaction =
    new btc.TransactionBuilder(网络);        交易.添加输入(utxo[0].txid, utxo[0].vout);        交易.添加输出(alicekeys.getAddress(),
    99990000);        交易.签名(0, bobKeys);        var transactionHex = 交易.建立().toHex();        var
    txPushUrl = blockExplorerTestnetApiEndpoint + ''tx/send'';        请求.post({            url:
    txPushUrl,            json: {                rawtx: transactionHex            }        },
    函数 (err, res, body) {            如果 (err) 控制台.log(err);            控制台.log(res);            控制台.log(body);        });    });};在这一节中，我们学习了如何程序化地将交易发送到比特币测试网络。同样，我们可以通过在库函数和API端点中使用主网络作为目标来发送交易到比特币主网络。我们还使用了查询API来获取比特币地址的未花费输出。这些功能可以用来创建一个简单的比特币钱包应用程序，以查询和管理比特币地址和交易。'
- en: Interacting Programmatically with Ethereum—Sending Transactions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊的程序化交互—发送交易
- en: 'The Ethereum blockchain has much more to offer in terms of blockchain application
    development as compared with the Bitcoin blockchain. The ability to execute logic
    on the blockchain using smart contracts is the key feature of Ethereum blockchain
    that allows developers to create decentralized applications. In this section we
    will learn how to programmatically interact with the Ethereum blockchain using
    JavaScript. We will look at the main aspects of Ethereum application programming
    from simple transactions to creating and calling smart contracts.As we did for
    interacting with the Bitcoin blockchain in the previous section, we will be using
    a JavaScript library and test network for interacting with Ethereum as well. We
    will use the web3 JavaScript library for Ethereum. This library wraps a lot of
    Ethereum JSON RPC APIs and provides easy to use functions to create Ethereum DApps
    using JavaScript. At the time of this writing, we are using a version greater
    than and compatible with version 1.0.0-beta.28 of the web3 JavaScript library.For
    the test network, we will be using the Ropsten test network for Ethereum blockchain.For
    simplicity, we will again use a public-hosted test network node for Ethereum so
    that we don’t have to host a local node while running these code snippets. However,
    all snippets should work with a locally hosted node as well. We are using the
    Ethereum APIs provided by the Infura service. Infura is a service that provides
    public-hosted Ethereum nodes so that developers can easily test their Ethereum
    apps. There is a small and free registration step needed before we can use the
    Infura API, so we will go to [https://infura.io](https://infura.io/) and do a
    registration. We will get an API key after registration. Using this API key, we
    can now call the Infura API.The following (Figure [5-3](#Fig3)) shows how this
    code interacts with the Ethereum blockchain. Note: The figure is just a rough
    sketch and does not show the Infura service architecture in detail.![A440588_1_En_5_Fig3_HTML.jpg](Images/A440588_1_En_5_Fig3_HTML.jpg)Figure
    5-3Application interacting with Ethereum blockchain using Infura API serviceThe
    following subsections of this section are steps to follow, in that order, to send
    a transaction to the Ethereum Ropsten test network using JavaScript.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链在区块链应用开发方面比比特币区块链提供更多功能。使用智能合约在区块链上执行逻辑是以太坊区块链的关键特性，这使得开发者能够创建去中心化应用。在本节中，我们将学习如何使用JavaScript程序化地与以太坊区块链交互。我们将从简单的交易到创建和调用智能合约，了解以太坊应用编程的主要方面。正如在上一节中为与比特币区块链交互所做的那样，我们也将使用一个JavaScript库和一个测试网络来交互
    with Ethereum. 我们将使用web3 JavaScript库来 interact with Ethereum. 这个库封装了很多以太坊JSON
    RPC API，并提供了使用JavaScript创建以太坊DApps的易于使用的函数。在撰写本文时，我们使用的是web3 JavaScript库的版本，该版本大于并兼容web3
    JavaScript库的1.0.0-beta.28版本。对于测试网络，我们将使用以太坊区块链的Ropsten测试网络。为了简化，我们再次使用一个公共托管的测试网络节点来
    interact with Ethereum，这样在运行这些代码片段时我们就不必托管一个本地节点。然而，所有片段也应与本地托管节点一起工作。我们使用Infura服务提供的以太坊API。Infura是一个提供公共托管以太坊节点的服务，以便开发者可以轻松测试他们的以太坊应用。在使用Infura
    API之前，我们需要完成一个简单且免费的注册步骤，因此我们将前往[https://infura.io](https://infura.io/)进行注册。注册后，我们将获得一个API密钥。使用这个API密钥，我们现在可以调用Infura
    API。以下（图[5-3](#Fig3)）显示了这段代码如何与以太坊区块链交互。注意：该图仅为草图，并未详细显示Infura服务架构。![A440588_1_En_5_Fig3_HTML.jpg](Images/A440588_1_En_5_Fig3_HTML.jpg)图5-3使用Infura
    API服务与以太坊区块链交互本节的以下小节是按顺序执行的步骤，以使用JavaScript将交易发送到以太坊Ropsten测试网络。
- en: Set Up Library and Connection
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置库和连接
- en: First, we install the web3 library in our node.js application. Note the specific
    version of library mentioned in the installation command. This is because version
    1.0.0 of the library has some more APIs and functions available and they reduce
    dependency on other external packages.npm install web3@1.0.0-beta.28Then, we initialize
    the library in our nodejs Ethereum module using the require keyword,var Web3 =
    require('web3');Now, we have a reference of the web3 library, but we need to instantiate
    it before we can use it. The following line of code creates a new instance of
    the Web3 object and it sets the Infura-hosted Ethereum Ropsten test network node
    as the provider for this Web3 instance.var web3 = new Web3(new Web3.providers.HttpProvider('https://ropsten.infura.io/<your
    Infura API key>'));
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在node.js应用程序中安装web3库。注意安装命令中提到的库的具体版本。这是因为库的1.0.0版本有一些更多的API和功能可用，它们减少了对其他外部包的依赖。`npm
    install web3@1.0.0-beta.28`然后，我们使用require关键字在我们的nodejs以太坊模块中初始化该库，`var Web3 =
    require('web3');`现在，我们有了web3库的引用，但在使用它之前需要实例化它。以下代码创建了Web3对象的实例，并将其设置为Infura托管的以太坊Ropsten测试网络节点，为这个Web3实例提供支持。`var
    web3 = new Web3(new Web3.providers.HttpProvider('https://ropsten.infura.io/<your
    Infura API key>'));`
- en: Set Up Ethereum Accounts
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置以太坊账户
- en: 'Now that we are all set up, let’s send a transaction to the Ethereum blockchain.
    In this transaction, we will send some Ether from one account to another. Recall
    from Chapter [4](A440588_1_En_4_Chapter.xhtml) that Ethereum does not use the
    UTXO model but it uses an account and balances model.Basically, the Ethereum blockchain
    manages state and assets in terms of accounts and balances just like banks do.
    There are no inputs and outputs here. You can simply send Ether from one account
    to another and Ethereum will make sure that the states are updated for these accounts
    on all nodes.To send a transaction to Ethereum that transfers Ether from one account
    to others, we will first need a couple of Ethereum accounts. Let’s start with
    creating two accounts for Alice and Bob.The following code snippet calls the account
    creation function of web3 library and creates two accounts.var createAccounts
    = function () {    var aliceKeys = web3.eth.accounts.create();    console.log(aliceKeys);    var
    bobKeys = web3.eth.accounts.create();    console.log(bobKeys);};And here’s the
    output that we get in the console window after running the previous snippet.{    address:
    ''0xAff9d328E8181aE831Bc426347949EB7946A88DA'',    privateKey: ''0x9fb71152b32cb90982f95e2b1bf2a5b6b2a53855eacf59d132a2b7f043cfddf5'',    signTransaction:
    [Function: signTransaction],    sign: [Function: sign],    encrypt: [Function:
    encrypt]}{    address: ''0x22013fff98c2909bbFCcdABb411D3715fDB341eA'',    privateKey:
    ''0xc6676b7262dab1a3a28a781c77110b63ab8cd5eae2a5a828ba3b1ad28e9f5a9b'',    signTransaction:
    [Function: signTransaction],    sign: [Function: sign],    encrypt: [Function:
    encrypt]}As you can see, along with the addresses and private keys, the output
    for each account creation function call also includes a few functions. For now,
    we will focus on the address and private key of the returned objects. The address
    is the Keccak-256 hash of the ECDSA public key of the generated private key. This
    address and private key combination represents an account on the Ethereum blockchain.
    You can send Ether to the address and you can spend that Ether using the private
    key of the corresponding address.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，让我们将交易发送到以太坊区块链。在这个交易中，我们将从一个账户发送一些以太币到另一个账户。回想一下第[4](A440588_1_En_4_Chapter.xhtml)章，以太坊不使用UTXO模型，而是使用账户和余额模型。基本上，以太坊区块链以账户和余额的形式管理状态和资产，就像银行一样。这里没有输入和输出。您可以简单地将以太币从
    one account 发送到 another account，以太坊将确保在所有节点上更新这些账户的状态。要向以太坊发送将以太币从 one account
    转移到 others 的交易，我们首先需要几个以太坊账户。让我们从为Alice和Bob创建两个账户开始。以下代码片段调用web3库的账户创建函数并创建两个账户。`var
    createAccounts = function () {    var aliceKeys = web3.eth.accounts.create();    console.log(aliceKeys);    var
    bobKeys = web3.eth.accounts.create();
- en: Get Test Ether in Sender’s Account
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在发送方账户中获取测试以太币
- en: Now, to create an Ethereum transaction which transfers Ether from one account
    to another, we first need some Ether in one of the accounts. Recall from the Bitcoin
    programming section that we used testnet faucets to get some test Bitcoins on
    the address we generated. We will do the same for Ethereum also. Remember that
    we are targeting the Ropsten test network for Ethereum, so we will search for
    a Ropsten faucet on the Internet. For this example, we submitted Alice’s address
    that we generated in the previous code snippet to an Ethereum Ropsten test network
    faucet and we received three ethers on that address.After receiving Ether on Alice’s
    address, let’s check the balance of this address to confirm if we really have
    the Ether or not. Though we can check the balance of this address using any of
    the Ethereum explorers online, let’s do it using code. The following code snippet
    calls the getBalance function passing Alice’s address as input parameter.var getBalance
    = function () {    web3.eth.getBalance('0xAff9d328E8181aE831Bc426347949EB7946A88DA').then(console.log);};And
    we get the following output as the balance of Alice’s address. That’s a huge number
    but that’s actually the value of the balance in wei. Wei is the smallest unit
    of Ether. One Ether equals 10^18 wei. So, the following value equals three Ether,
    which is what we received from the test network faucet.3000000000000000 000
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个将以太币从一方账户转移到另一方账户的以太坊交易，我们首先需要在其中一个账户中有一些以太币。回想一下，在比特币编程部分，我们使用了测试网络水龙头来获取我们在生成地址时的一些测试比特币。我们也将对以太坊做同样的事情。记住，我们的目标是针对以太坊的Ropsten测试网络，因此我们将在互联网上搜索一个Ropsten水龙头。作为一个例子，我们把在之前的代码片段中生成的是Alice的地址提交给了一个以太坊Ropsten测试网络水龙头，我们在那个地址上收到了三个以太币。在Alice的地址上收到以太币后，让我们检查这个地址的余额，以确认我们是否真的有以太币。虽然我们可以使用任何在线的以太坊浏览器来检查这个地址的余额，但让我们通过代码来完成。以下代码片段调用了getBalance函数，将Alice的地址作为输入参数。
- en: Prepare Ethereum Transaction
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备以太坊交易
- en: 'Now that we have some test Ether with Alice, let’s create an Ethereum transaction
    to send some of this Ether to Bob. Recall that there are no inputs and outputs
    and UTXO queries to be done in the case of Ethereum because it uses an account
    and balances-based system. So, all that we need to do in the transaction is to
    specify the “from” address (the sender’s address), the “to” address (the recipient
    address), and the amount of Ether to be sent, among a few other things.Also, recall
    that in the case of a Bitcoin transaction we did not have to specify the transaction
    fee; however, in the case of an Ethereum transaction we need to specify two related
    fields. One is gas limit and the other is gas Price. Recall from Chapter [4](A440588_1_En_4_Chapter.xhtml)
    that gas is the unit of transaction fee we need to pay to the Ethereum network
    to get our transactions confirmed and added to blocks. gas Price is the amount
    of Ether (in gwei) we want to pay per unit of gas. The maximum fee that we allow
    to be used for a transaction is the product of gas and gas Price.So, for this
    example transaction, we define a JSON object with the following fields. Here,
    “from” has Alice’s address and “to” has Bob’s address, and value is one Ether
    in wei. The gas Price we choose is 20 gwei and the maximum amount of gas we want
    to pay for this transaction is 42,000.Also, note that we have left the data field
    empty. We will come back to this later in the smart contract section.{    from:
    "0xAff9d328E8181aE831Bc426347949EB7946A88DA",    gasPrice: "20000000000",    gas:
    "42000",    to: ''0x22013fff98c2909bbFCcdABb411D3715fDB341eA'',    value: "1000000000000000000",    data:
    ""}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '既然我们现在已经在Alice这里有一些测试以太币，那么让我们创建一个以太坊交易，将其中一些以太币发送给Bob。回想一下，在以太坊中没有输入和输出以及UTXO查询，因为以太坊使用基于账户和余额的系统。所以，在交易中我们只需要做的是指定发送方的地址（即发送者的地址）、接收方地址以及要发送的以太币数量，还有一些其他的事情。另外，回想一下，在比特币交易中我们不需要指定交易费用；然而，在以太坊交易中，我们需要指定两个相关字段。一个是gas限制，另一个是gas价格。回想一下，从第[4](A440588_1_En_4_Chapter.xhtml)章我们知道，gas是我们需要支付给以太坊网络以使我们的交易得到确认并添加到区块的交易费用的单位。gas价格是我们希望每单位gas支付的以太币（以gwei为单位）的数量。我们允许用于交易的最多费用是gas和gas价格的乘积。所以，对于这个示例交易，我们定义了一个具有以下字段的JSON对象。在这里，“from”有Alice的地址，“to”有Bob的地址，value是1个以太币，单位是wei。我们选择的gas价格是20
    gwei，我们想要为这个交易支付的最大gas数量是42,000。另外，请注意，我们留下了数据字段为空。我们稍后会在智能合约部分回到这个问题。{    from:
    "0xAff9d328E8181aE831Bc426347949EB7946A88DA",    gasPrice: "20000000000",    gas:
    "42000",    to: ''0x22013fff98c2909bbFCcdABb411D3715fDB341eA'',    value: "1000000000000000000",    data:
    ""}'
- en: Sign Transaction
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署交易
- en: 'Now that we have created a transaction object with the required fields and
    values, we need to sign it using the private key of the account that is sending
    the Ether. In this case, the sender is Alice, so we will use Alice’s private key
    to sign the transaction. This is to cryptographically prove that it is actually
    Alice who is spending the Ether in her account.var signTransaction = function
    () {    var tx = {        from: "0xAff9d328E8181aE831Bc426347949EB7946A88DA",        gasPrice:
    "20000000000",        gas: "42000",        to: ''0x22013fff98c2909bbFCcdABb411D3715fDB341eA'',        value:
    "1000000000000000000",        data: ""    };    web3.eth.accounts.signTransaction(tx,
    ''0x9fb71152b32cb90982f95e2b1bf2a5b6b2a53855eacf59d132a2b7f043cfddf5'')    .then(function(signedTx){        console.log(signedTx.rawTransaction);    });};The
    preceding code snippet calls the signTransaction function with the transaction
    object we created in the step before and Alice’s private key that we got when
    we generated Alice’s account. Following is the output we get when we run the prceding
    code snippet.{    messageHash: ''0x91b345a38dc728dc06a43c49b92a6ac1e0e6d614c432a6dd37d809290a25aa6b'',    v:
    ''0x2a'',    r: ''0x14c20901a060834972a539d7b8ad1f23161c2144a2b66fbf567e37e963d64537'',    s:
    ''0x3d2a0a818633a11832a5c48708a198af909eaf4884a7856c9ac9ed216d9b029c'',    rawTransaction:
    ''0xf86c018504a817c80082a4109422013fff98c2909bbfccdabb411d3715fdb341ea880de0b6b3a7640000802aa014c20901a060834972a539d7b8ad1f23161c2144a2b66fbf567e37e963d64537a03d2a0a818633a11832a5c48708a198af909eaf4884a7856c9ac9ed216d9b029c''}In
    the output of the signTransaction function we receive a JSON object with a few
    properties. The important value for us is the rawTransaction value. This is the
    hex string representation of the signed transaction. This is very similar to how
    we created a hex string of the Bitcoin transaction in the Bitcoin section.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个带有所需字段和值的交易对象，接下来我们需要使用发送以太币的账户的私钥来签名它。在此例中，发送者是爱丽丝，因此我们将使用爱丽丝的私钥来签名交易。这样做是为了通过加密技术证明，确实是她本人正在使用她账户中的以太币。
- en: Send Transaction to the Ethereum Network
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将交易发送至以太坊网络
- en: 'The final step is to just send this signed raw transaction to the public-hosted
    Ethereum test network node, which we have set as the provider of our web3 object.The
    following code calls the sendSignedTransaction function to send the raw transaction
    to the Ethereum test network. The input parameter is the value of the rawTransaction
    string that we got in the previous step as part of signing the transaction.web3.eth.sendSignedTransaction(signedTx.rawTransaction).then(console.log);Notice
    the use of “then” in the prceding code snippet. This is interesting because the
    web3 library provides different levels of finality when working with Ethereum
    transactions, because an Ethereum transaction goes through several states after
    being submitted. In this function, call of sending a transaction to the network,
    then, is hit when the transaction receipt is created, and the transaction is complete.After
    a few seconds, when the JavaScript promise resolves, the following is what we
    get as an output.{    blockHash: ''0x26f1e1374d11d4524f692cdf1ce3aa6e085dcc181084642293429eda3954d30e'',    blockNumber:
    2514764,    contractAddress: null,    cumulativeGasUsed: 125030,    from: ''0xaff9d328e8181ae831bc426347949eb7946a88da'',    gasUsed:
    21000,    logs: [],    logsBloom: ''0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'',    status:
    ''0x1'',    to: ''0x22013fff98c2909bbfccdabb411d3715fdb341ea'',    transactionHash:
    ''0xd3f45394ac038c44c4fe6e0cdb7021fdbd672eb1abaa93eb6a1828df5edb6253'',    transactionIndex:
    3}The output has a lot of information, as we can see. The most important part
    is the transactionHash, which is the ID of the transaction on the network. It
    also gives us the blockHash, which is the ID of the block in which this transaction
    was included. Along with this, we also get information about how much gas was
    used for this transaction, among other details. If the gas used is less than the
    maximum gas we specified during transaction creation, the remaining gas is sent
    back to the sender’s address.In this section, we sent a simple transaction to
    the Ethereum blockchain using JavaScript. But this is just the beginning of Ethereum
    application programming. In the next section, we will also look at how to create
    and call smart contracts programmatically.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步就是将这个已签名的原始交易发送到公共托管的以太坊测试网络节点，我们将其设置为web3对象的提供者。以下代码调用sendSignedTransaction函数将原始交易发送到以太坊测试网络。输入参数是我们在前一步作为签署交易的一部分获取的原始交易字符串的值。web3.eth.sendSignedTransaction(signedTx.rawTransaction).then(console.log);注意
    preceding code snippet 中使用了“then”。这很有趣，因为web3库在处理以太坊交易时提供了不同级别的最终性，因为一个以太坊交易在提交后要经历几个状态。在这个函数中，调用发送交易到网络，然后，当交易收据创建时，交易完成。几秒钟后，当JavaScript承诺解决时，我们得到以下输出。{   blockHash:
    ''0x26f1e1374d11d4524f692cdf1ce3aa6e085dcc181084642293429eda3954d30e'',   blockNumber:
    2514764,   contractAddress: null,   cumulativeGasUsed: 125030,   from: ''0xaff9d328e8181ae831bc426347949eb7946a88da'',   gasUsed:
    21000,   logs: [],   logsBloom: ''0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'',   status:
    ''0x1'',   to: ''0x22013fff98c2909bbfccdabb411d3715fdb341ea'',   transactionHash:
    ''0xd3f45394ac038c44c4fe6e0cdb7021fdbd672eb1abaa93eb6a1828df5edb6253'',   transactionIndex:
    3}如我们所见，输出有很多信息。最重要的部分是transactionHash，这是网络上交易的ID。它还给出了blockHash，这是包含此交易的区块的ID。此外，我们还获得了关于此交易'
- en: Interacting Programmatically with Ethereum—Creating a Smart Contract
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化与以太坊交互—创建智能合约
- en: In this section, we will continue our Ethereum programming exercise, and we
    will create a simple smart contract on the Ethereum blockchain using the same
    web3 JavaScript library and the Infura service API.Because, no computer programming
    beginners’ tutorial is complete without a “Hello World” program, the smart contract
    we are going to create will be a simple smart contract returning the string “Hello
    World” when called.The contract creation process will be a special kind of transaction
    sent to the Ethereum blockchain, and these types of transactions are called “contract
    creation transactions.” These transactions do not mention a “to” address and the
    owner of the smart contract is the “from” address mentioned in the transaction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续我们的以太坊编程练习，并使用相同的web3 JavaScript库和Infura服务API在以太坊区块链上创建一个简单的智能合约。因为，没有计算机编程初学者教程会没有“Hello
    World”程序，我们将要创建的智能合约将是一个简单的智能合约，当调用时返回字符串“Hello World”。合约创建过程将是一种特殊类型的交易发送到以太坊区块链，这种类型的交易称为“合约创建交易”。这些交易不提及“to”地址，智能合约的所有者是交易中提到的“from”地址。
- en: Prerequisites
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this code exercise to create a smart contract, we will continue with the
    assumption that the web3 JavaScript library is installed and instantiated in a
    node.js app and we have registered for the Infura service, just like we did in
    the previous section.Following are the steps to create a smart contract on Ethereum
    using JavaScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个创建智能合约的代码练习中，我们将继续假设web3 JavaScript库已经在node.js应用程序中安装并实例化，并且我们已经为Infura服务注册，就像我们在上一节中做的那样。以下是使用JavaScript在以太坊上创建智能合约的步骤。
- en: Program the Smart Contract
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程智能合约
- en: Recall from Chapter [4](A440588_1_En_4_Chapter.xhtml) that the Ethereum smart
    contracts are written in Solidity programming language. While the web3 JavaScript
    library will help us deploy our contract on the Ethereum blockchain, we will still
    have to write and compile our smart contract in Solidity before we send it to
    the Ethereum network using web3\. So, let’s first create a sample contract using
    Solidity.There are a variety of tools available to code in Solidity. Most of the
    major IDEs and code editors have Solidity plugins for editing and compiling smart
    contracts. There is also a web-based Solidity editor called Remix. It’s available
    for free to use at [https://remix.ethereum.org/](https://remix.ethereum.org/)
    . Remix provides a very simple interface to code and compile smart contracts within
    your browser. In this exercise we will be using Remix to code and test our smart
    contract and then we will send the same contract to the Ethereum network using
    the web3 JavaScript library and the Infura API service.The following code snippet
    is written in the Solidity programming language and it is a simple smart contract
    that returns the string “Hello World” from its function Hello. It also has a constructor
    that sets the value of the message returned.pragma solidity ^0.4.0;contract HelloWorld
    {    string message;    function HelloWorld(){        message = "Hello World!";    }    function
    Hello() constant returns (string) {        return message;    }}Let’s head to
    Remix and paste this code in the editor window. The following images (Figures
    [5-4](#Fig4) and [5-5](#Fig5)) show how our sample smart contract looks in the
    Remix editor and what the output looks like when we clickeded the Create button
    on the right-side menu, under the Run tab. Also, note that by default, the Remix
    editor targets a JavaScript VM environment for smart contract compilation and
    it uses a test account with some ETH balance, for testing purposes. When we click
    the Create button, this contract is created using the selected account in the
    JavaScript VM environment.![A440588_1_En_5_Fig4_HTML.jpg](Images/A440588_1_En_5_Fig4_HTML.jpg)Figure
    5-4Editing smart contracts in Remix IDE![A440588_1_En_5_Fig5_HTML.jpg](Images/A440588_1_En_5_Fig5_HTML.jpg)Figure
    5-5Smart contract creation output in Remix IDEFollowing is the output generated
    by the create operation, and it shows us that the contract has been created because
    it has a contract address. The “from” value is the account address that was used
    to create the contract. It also shows us the hash of the contract creation transaction.status     0x1
    Transaction mined and execution succeedcontractAddress    0x692a70d2e424a56d2c6c27aa97d1a86395877b3afrom   0xca35b7d915458ef540ade6068dfe2f44e8fa733cto     HelloWorld.(constructor)gas    3000000
    gastransaction cost   205547 gasexecution cost     109539 gashash   0x9f3c21c21f263084b9f031966858a5d8e0648ed19c77d4d2291875b01d89a141input  0x6060604052341561000f57600080fd5b6040805190810160405280600c81526020017f48656c6c6f20576f726c642100000000000000000000000000000000000000008152506000908051906020019061005a929190610060565b50610105565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a157805160ff19168380011785556100cf565b828001600101855582156100cf579182015b828111156100ce5782518255916020019190600101906100b3565b5b5090506100dc91906100e0565b5090565b61010291905b808211156100fe5760008160009055506001016100e6565b5090565b90565b6101bc806101146000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063bcdfe0d514610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a72305820d6796e48540eced3646ea52c632364666e64094479451066317789a712aef4da0029 decoded
    input  {} decoded output      - logs   [] value  0 weiAt this point, we have a
    simple “Hello World” smart contract ready, and now the next step is to deploy
    it programmatically to the Ethereum blockchain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章[4](A440588_1_En_4_Chapter.xhtml)中提到，以太坊智能合约是用Solidity编程语言编写的。尽管web3 JavaScript库将帮助我们将合约部署到以太坊区块链上，但我们仍然需要在Solidity中编写并编译我们的智能合约，然后使用web3将其发送到以太坊网络。所以，我们首先使用Solidity创建一个示例合约。有许多工具可用于在Solidity中编码。大多数主流IDE和代码编辑器都有Solidity插件，用于编辑和编译智能合约。还有一个基于网页的Solidity编辑器，名为Remix。它可以在[https://remix.ethereum.org/](https://remix.ethereum.org/)免费使用。Remix提供了一个非常简单的界面，用于在浏览器中编写和编译智能合约。在这个练习中，我们将使用Remix来编写和测试我们的智能合约，然后我们将会使用web3
    JavaScript库和Infura API服务，将同样的合约发送到以太坊网络。
- en: Compile Contract and Get Details
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译合约并获取详情
- en: 'Let’s first get some details about our smart contract from Remix, which will
    be needed to deploy the contract to the Ethereum network using the web3 library.
    Click on the Compile tab in the right-side menu and then click the Details button.
    This pops up a new child window with details of the smart contract. What’s important
    for us are the ABI and the BYTECODE sections on the details popup window.Let’s
    copy the details in the ABI section using the copy value to clipboard button available
    next to the ABI header. Following is the value of the ABI data for our smart contract.[    {        "constant":
    true,        "inputs": [],        "name": "Hello",        "outputs": [            {                "name":
    "",                "type": "string"            }        ],        "payable": false,        "stateMutability":
    "view",        "type": "function"    },    {        "inputs": [],        "payable":
    false,        "stateMutability": "nonpayable",        "type": "constructor"    }]This
    is a JSON array and if we closely look at it, we see that it has JSON objects
    for each function in our contract including its constructor. These JSON objects
    have details about a function and its input and output. This array describes the
    smart contract interface.When we call this smart contract after it is deployed
    to the network, we will need this information to find out what functions the contract
    is exposing and what do we need to pass as an input to the function we wish to
    call.Now let’s get the data in the BYTECODE section of the details popup. Following
    is the data we copied for our contract.{    "linkReferences": {},    "object":
    "6060604052341561000f57600080fd5b6040805190810160405280600c81526020017f48656c6c6f20576f726c642100000000000000000000000000000000000000008152506000908051906020019061005a929190610060565b50610105565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a157805160ff19168380011785556100cf565b828001600101855582156100cf579182015b828111156100ce5782518255916020019190600101906100b3565b5b5090506100dc91906100e0565b5090565b61010291905b808211156100fe5760008160009055506001016100e6565b5090565b90565b6101bc806101146000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063bcdfe0d514610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a72305820877a5da4f7e05c4ad9b45dd10fb6c133a523541ed06db6dd31d59b35d51768a30029","opcodes":
    "PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
    REVERT JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1
    0xC DUP2 MSTORE PUSH1 0x20 ADD PUSH32 0x48656C6C6F20576F726C64210000000000000000000000000000000000000000
    DUP2 MSTORE POP PUSH1 0x0 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 PUSH2 0x5A
    SWAP3 SWAP2 SWAP1 PUSH2 0x60 JUMP JUMPDEST POP PUSH2 0x105 JUMP JUMPDEST DUP3
    DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2
    SWAP1 DIV SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 PUSH1 0x1F
    ADD PUSH1 0x20 SWAP1 DIV DUP2 ADD SWAP3 DUP3 PUSH1 0x1F LT PUSH2 0xA1 JUMPI DUP1
    MLOAD PUSH1 0xFF NOT AND DUP4 DUP1 ADD OR DUP6 SSTORE PUSH2 0xCF JUMP JUMPDEST
    DUP3 DUP1 ADD PUSH1 0x1 ADD DUP6 SSTORE DUP3 ISZERO PUSH2 0xCF JUMPI SWAP2 DUP3
    ADD JUMPDEST DUP3 DUP2 GT ISZERO PUSH2 0xCE JUMPI DUP3 MLOAD DUP3 SSTORE SWAP2
    PUSH1 0x20 ADD SWAP2 SWAP1 PUSH1 0x1 ADD SWAP1 PUSH2 0xB3 JUMP JUMPDEST JUMPDEST
    POP SWAP1 POP PUSH2 0xDC SWAP2 SWAP1 PUSH2 0xE0 JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST
    PUSH2 0x102 SWAP2 SWAP1 JUMPDEST DUP1 DUP3 GT ISZERO PUSH2 0xFE JUMPI PUSH1 0x0
    DUP2 PUSH1 0x0 SWAP1 SSTORE POP PUSH1 0x1 ADD PUSH2 0xE6 JUMP JUMPDEST POP SWAP1
    JUMP JUMPDEST SWAP1 JUMP JUMPDEST PUSH2 0x1BC DUP1 PUSH2 0x114 PUSH1 0x0 CODECOPY
    PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2
    0x41 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000
    SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0xBCDFE0D5 EQ PUSH2 0x46 JUMPI JUMPDEST
    PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x51 JUMPI PUSH1 0x0 DUP1
    REVERT JUMPDEST PUSH2 0x59 PUSH2 0xD4 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1
    PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1
    0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1
    0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x99 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5
    ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0x7E JUMP JUMPDEST POP POP POP
    POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0xC6 JUMPI
    DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT
    AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1
    0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xDC PUSH2 0x17C JUMP JUMPDEST
    PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND
    PUSH1 0x2 SWAP1 DIV DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20
    ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2
    DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO
    PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 ISZERO PUSH2 0x172 JUMPI DUP1
    PUSH1 0x1F LT PUSH2 0x147 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE
    SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x172 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1
    0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE
    SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x155 JUMPI DUP3 SWAP1
    SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP SWAP1 POP SWAP1
    JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1
    PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256
    DUP8 PUSH27 0x5DA4F7E05C4AD9B45DD10FB6C133A523541ED06DB6DD31D59B35D5 OR PUSH9
    0xA30029000000000000 ",    "sourceMap": "24:199:0:-;;;75:62;;;;;;;;106:24;;;;;;;;;;;;;;;;;;:7;:24;;;;;;;;;;;;:::i;:::-;;24:199;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;"}As
    we can see, the data in the BYTECODE section is a JSON object. This is basically
    the output of the compilation of the smart contract. Remix compiled our smart
    contract using the Solidity compiler and as a result we got the solidity byte
    code. Now closely examine this JSON and look at the “object” property and its
    value. This is a hex string that contains the byte code for our smart contract,
    and we will be sending it in the contract creation transaction in the data field—the
    same data field that we left blank in the previous example Ethereum transaction
    between Alice and Bob.Now we have all the details for our smart contract and we
    are ready to send it to the Ethereum network.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Deploy Contract to Ethereum Network
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将合约部署至以太坊网络
- en: 'Now that we have our smart contract and its details, we need to prepare a transaction
    that can deploy this contract to the Ethereum blockchain. This transaction preparation
    will be very similar to the transaction we prepared in the previous section, but
    it will have a few more properties that are needed to create contracts.First,
    we need to create an object of the web3.eth.Contract class, which can represent
    our contract. The following code snippet creates an instance for the said class
    with a JSON array as an input parameter. This is the same JSON array that we copied
    from the ABI section of the Remix popup window, showing the details about our
    smart contract.var helloworldContract = new web3.eth.Contract([{        "constant":
    true,        "inputs": [],        "name": "Hello",        "outputs": [{            "name":
    "",            "type": "string"        }],        "payable": false,        "stateMutability":
    "view",        "type": "function"    }, {        "inputs": [],        "payable":
    false,        "stateMutability": "nonpayable",        "type": "constructor"    }]);Now
    we need to send this contract to the Ethereum network using the Contract.deploy
    method of the web3 library. The following code snippet shows how to do this.helloworldContract.deploy({        data:
    ''0x6060604052341561000f57600080fd5b6040805190810160405280600c81526020017f48656c6c6f20576f726c642100000000000000000000000000000000000000008152506000908051906020019061005a929190610060565b50610105565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a157805160ff19168380011785556100cf565b828001600101855582156100cf579182015b828111156100ce5782518255916020019190600101906100b3565b5b5090506100dc91906100e0565b5090565b61010291905b808211156100fe5760008160009055506001016100e6565b5090565b90565b6101bc806101146000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063bcdfe0d514610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a72305820877a5da4f7e05c4ad9b45dd10fb6c133a523541ed06db6dd31d59b35d51768a30029''    })    .send({        from:
    ''0xAff9d328E8181aE831Bc426347949EB7946A88DA'',        gas: 4700000,        gasPrice:
    ''20000000000000''    },    function(error, transactionHash){        console.log(error);        console.log(transactionHash);    })    .then(function(contract){        console.log(contract);    });Note
    that the value of the field data inside the deploy function parameter object is
    the same value we received in the object field of the BYTECODE details in the
    previous step. Also notice that the string “0x” is added to this value in the
    beginning. So, the data passed in the deploy function is ‘0x’ + byte code of the
    contract.Inside the send function after the deploy, we have added the “from” address,
    which will be the owner of the contract and the transaction fee details of gas
    limit and gas Price. Finally, when the call is complete, the contract object is
    returned. This contract object will have the contract details along with the address
    of the contract, which can be used to call the function on the contract.Another
    way of sending the contract to the network would be to wrap the contract inside
    a transaction and send it directly. The following code snippet creates a transaction
    object with data as the contract bytecode, signs it using the private key of the
    address in the “from” field, and then sends it to the Ethereum blockchain.Note
    that we have not assigned a “to” address in this transaction object, as the address
    of the contract is unknown before the contract is deployed.var tx = {        from:
    "0x22013fff98c2909bbFCcdABb411D3715fDB341eA",        gasPrice: "20000000000",        gas:
    "4900000",        data: "0x6060604052341561000f57600080fd5b6040805190810160405280600c81526020017f48656c6c6f20576f726c642100000000000000000000000000000000000000008152506000908051906020019061005a929190610060565b50610105565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a157805160ff19168380011785556100cf565b828001600101855582156100cf579182015b828111156100ce5782518255916020019190600101906100b3565b5b5090506100dc91906100e0565b5090565b61010291905b808211156100fe5760008160009055506001016100e6565b5090565b90565b6101bc806101146000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063bcdfe0d514610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a72305820877a5da4f7e05c4ad9b45dd10fb6c133a523541ed06db6dd31d59b35d51768a30029"    };    web3.eth.accounts.signTransaction(tx,
    ''0xc6676b7262dab1a3a28a781c77110b63ab8cd5eae2a5a828ba3b1ad28e9f5a9b'')    .then(function
    (signedTx) {        web3.eth.sendSignedTransaction(signedTx.rawTransaction)        .then(console.log);    });When
    we execute this code snippet, we get the following output, which is the receipt
    of this transaction.{    blockHash: ''0xaba93b4561fc35e062a1ad72460e0b677603331bbee3379ce6c74fa5cf505d82'',    blockNumber:
    2539889,    contractAddress: ''0xd5a2d13723A34522EF79bE0f1E7806E86a4578E9'',    cumulativeGasUsed:
    205547,    from: ''0x22013fff98c2909bbfccdabb411d3715fdb341ea'',    gasUsed: 205547,    logs:
    [],    logsBloom: ''0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'',    status:
    ''0x1'',    to: null,    transactionHash: ''0xc333cbc5fc93b52871689aab22c48b910cb192b4875bea69212363030d36565a'',    transactionIndex:
    0}Notice the properties of the transaction receipt object. It has a value assigned
    to the contractAddress property, while the value of the “to” property is null.
    This means that this was a contract creation transaction that was successfully
    mined on the network and the contract created as part of this transaction is deployed
    at the address `0xd5a2d13723A34522EF79bE0f1E7806E86a4578E9`.We have successfully
    created an Ethereum smart contract programmatically.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经有了智能合约及其详细信息，我们需要准备一个交易，该交易可以将此合约部署到以太坊区块链上。这个交易准备将非常类似于我们在上一节中准备的交易，但它将具有创建合约所需的一些额外属性。首先，我们需要创建一个web3.eth.Contract类的实例，该实例可以表示我们的合约。以下代码片段创建了一个带有JSON数组作为输入参数的实例，这个JSON数组就是我们从Remix弹出窗口的ABI部分复制的，展示了我们智能合约的详细信息。var
    helloworldContract = new web3.eth.Contract([{                "constant": true,                "inputs":
    [],                "name": "Hello",                "outputs": [{                    "name":
    "",                    "type": "string"                }],                "payable":
    false,                "stateMutability": "view",                "type": "function"            },
    {                "inputs": [],                "payable": false,                "stateMutability":
    "nonpayable",                "type": "constructor"            }]);现在我们需要使用web3库的Contract.deploy方法将这个合约发送到以太坊网络。以下代码片段展示了如何做到这一点。helloworldContract.deploy({                data:
    ''0x6060604052341561000f57600080fd5b6040805190810160405280600c81526020017f48656c6c6f20576f726c642100000000000000000000000000000000000000008152506000908051906020019061005a929190610060565b50610105565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a157805160ff19168380011785556100cf565b828001600101855582156100cf579182015b828111156100ce5782518255916020019190600101906100b3565b5b5090506100dc91906100e0565b5090565b61010291905b808211156100fe5760008160009055506001016100e6565b5090565b90565b6101bc806101146000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063bcdfe0d514610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283'
- en: Interacting Programmatically with Ethereum—Executing Smart Contract Functions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式与以太坊交互——执行智能合约函数
- en: Now that we have deployed our smart contract to the Ethereum network, we can
    call its member functions. Following are the steps to call an Ethereum smart contract
    programmatically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的智能合约部署到了以太坊网络，我们可以调用它的成员函数。以下是以编程方式调用以太坊智能合约的步骤。
- en: Get Reference to the Smart Contract
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取智能合约的引用
- en: 'To execute a function of the smart contract, first we need to create an instance
    of the web3.eth.Contract class with the ABI and address of our deployed contract.
    The following code snippet shows how to do that.var helloworldContract = new web3.eth.Contract([{        "constant":
    true,        "inputs": [],        "name": "Hello",        "outputs": [{            "name":
    "",            "type": "string"        }],        "payable": false,        "stateMutability":
    "view",        "type": "function"    }, {        "inputs": [],        "payable":
    false,        "stateMutability": "nonpayable",        "type": "constructor"    }],
    ''0xd5a2d13723A34522EF79bE0f1E7806E86a4578E9'');In the prceding code snippet,
    we have created an instance of the web3.eth.Contract class by passing the ABI
    of the contract we created in the previous section, and we have also passed the
    address of the contract that we received after deploying the contract.This object
    can now be used to call functions on our contract.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行智能合约的一个函数，我们首先需要创建一个web3.eth.Contract类的实例，这个实例需要用到我们部署的合约的ABI和地址。下面的代码片段展示了如何做到这一点。
- en: Execute Smart Contract Function
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行智能合约函数
- en: 'Recall that we have only one public function  in our contract. This method
    is named Hello and it returns the string "Hello World!" when executed.To execute
    this method, we will call it using the contract.methods class in the web3 library.
    The follwing code snippet shows this.helloworldContract.methods.Hello().send({        from:
    ''0xF68b93AE6120aF1e2311b30055976d62D7dBf531''    }).then(console.log);In the
    prceding code snippet, we have added a value to the “from” address in the send
    function, and this address will be used to send the transaction that will in turn
    execute the function Hello on our smart contract.The full code for calling a smart
    contract is in the follwing code snippet.var callContract = function () {    var
    helloworldContract = new web3.eth.Contract([{        "constant": true,        "inputs":
    [],        "name": "Hello",        "outputs": [{            "name": "",            "type":
    "string"        }],        "payable": false,        "stateMutability": "view",        "type":
    "function"    }, {        "inputs": [],        "payable": false,        "stateMutability":
    "nonpayable",        "type": "constructor"    }], ''0xd5a2d13723A34522EF79bE0f1E7806E86a4578E9'');    helloworldContract.methods.Hello().send({        from:
    ''0xF68b93AE6120aF1e2311b30055976d62D7dBf531''    }).then(console.log);};Another
    way of executing this contract function will be by sending a raw transaction by
    signing it. It is similar to how we sent a raw Ethereum transaction to send Ether
    and to create a contract in the previous sections. In this case all we need to
    do is provide the contract address in the “to” field of the transaction object
    and the encoded ABI value of the function call in the data field.The following
    code snippet first creates a contract object and then gets the encoded ABI value
    of the smart contract function to be called. It then creates a transaction object
    based on these values and then signs and sends it to the network. Note that we
    have used the encodeABI function on the contract function to get the data payload
    value for the transaction. This is the input for the smart contract.var callContract
    = function () {    var helloworldContract = new web3.eth.Contract([{        "constant":
    true,        "inputs": [],        "name": "Hello",        "outputs": [{            "name":
    "",            "type": "string"        }],        "payable": false,        "stateMutability":
    "view",        "type": "function"    }, {        "inputs": [],        "payable":
    false,        "stateMutability": "nonpayable",        "type": "constructor"    }],
    ''0xd5a2d13723A34522EF79bE0f1E7806E86a4578E9'');    var payload = helloworldContract.methods.Hello().encodeABI();    var
    tx = {        from: "0xF68b93AE6120aF1e2311b30055976d62D7dBf531",        gasPrice:
    "20000000000",        gas: "4700000",        data: payload    };    web3.eth.accounts.signTransaction(tx,
    ''0xc6676b7262dab1a3a28a781c77110b63ab8cd5eae2a5a828ba3b1ad28e9f5a9b'')        .then(function
    (signedTx) {            web3.eth.sendSignedTransaction(signedTx.rawTransaction)            .then(console.log);    });};Important
    NoteWhen using a public-hosted node for Ethereum, we should use the raw transaction
    method for creating and executing smart contracts because the web3.eth.Contract
    submodule of the library uses either an unlocked or default account associated
    with the provider Ethereum node, but this is not supported by the public nodes
    (at the time of this writing).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下，在我们的合约中只有一个公共函数。这个方法名为Hello，当它被执行时返回字符串"Hello World!"。要执行这个方法，我们将使用web3库中的contract.methods类来调用它。下面的代码片段展示了这一点。helloworldContract.methods.Hello().send({
- en: Blockchain Concepts Revisited
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视区块链概念
- en: In the previous sections we programmatically sent transactions to both Bitcoin
    and Ethereum blockchains using JavaScript. Here are some of the common concepts
    that we can now revisit, looking at the process of handcrafting transactions using
    code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们用JavaScript程序化地向比特币和以太坊区块链发送交易。现在我们可以重新回顾一些常见概念，通过代码手写交易的过程。
- en: 'Transactions : Looking at the code we wrote and the output we got for sending
    transactions to Ethereum and Bitcoin, we can now say that blockchain transactions
    are the operations initiated from an account owner, which, if completed successfully,
    update the state of the blockchain. For example, in our transactions between Alice
    and Bob, we saw that the ownership of a certain amount of Bitcoins and Ether changed
    from Alice to Bob and vice versa, and this change of ownership was recorded in
    the blockchain, hence bringing it into a new state. In the case of Ethereum, transactions
    go further into contract creation and execution and these transactions also update
    the state of the blockchain. We created a transaction that in turn deployed a
    smart contract on the Ethereum blockchain. The state of the blockchain was updated
    because now we have a new contract account created in the blockchain.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易：通过我们编写并发送交易到以太坊和比特币时得到的输出，我们现在可以说，区块链交易是由账户所有者发起的操作，如果成功完成，将更新区块链的状态。例如，在我们的Alice和Bob之间的交易中，我们看到一定数量的比特币和以太币的所有权从Alice转移到Bob，反之亦然，这种所有权的变更记录在区块链上，因此使其进入新的状态。在以太坊的情况下，交易进一步涉及智能合约的创建和执行，这些交易也更新了区块链的状态。我们创建了一个交易，该交易进而部署了以太坊区块链上的智能合约。区块链的状态得到更新，因为现在我们在区块链上创建了一个新的合约账户。
- en: 'Inputs, Outputs, Accounts and Balances : We also saw how Bitcoin and Ethereum
    are different from each other in terms of managing the state. While Bitcoin uses
    the UTXO model, Ethereum uses the accounts and balances model. However, the underlying
    idea is both the blockchains record the ownership of assets, and transactions
    are used to change ownership of these assets.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入、输出、账户和余额：我们还看到了比特币和以太坊在管理状态方面的不同。虽然比特币使用UTXO模型，以太坊使用账户和余额模型。然而，背后的想法是两个区块链都记录资产的所有权，而交易用来改变这些资产的所有权。
- en: 'Transaction Fee : For every transaction we do on public blockchain networks,
    we must pay a transaction fee for our transactions to be confirmed by the miners.
    In Bitcoin this is automatically calculated, while in Ethereum we should mention
    the maximum fee we are willing to pay in terms of gas Price and gas limit.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易费用：在公共区块链网络上进行的每笔交易，我们必须为我们的交易支付交易费用，以便矿工确认。在比特币中这是自动计算的，而在以太坊中我们应该提到我们愿意支付的最大费用，以每单位气体价格和气体限制来表示。
- en: 'Signing : In both cases, we also saw that after creating a transaction object
    with the required values, we signed it using the sender’s public key. Cryptographic
    signing is a way of proving ownership of the assets. If the signature is incorrect,
    then the transaction becomes invalid.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名：在两种情况下，我们也都看到了，在创建带有所需值的交易对象后，我们使用发送者的公钥对其进行签名。加密签名是一种证明资产所有权的方法。如果签名不正确，那么交易就变得无效。
- en: 'Transaction broadcasting : After creating and signing the transactions, we
    sent them to the blockchain nodes. While we sent our example transactions to publicly
    hosted Bitcoin and Ethereum test network nodes, we are free to send our transactions
    to multiple nodes if we don’t trust all of them to process our transactions. This
    is called transaction broadcasting.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易广播：在创建并签名交易后，我们将它们发送到区块链节点。虽然我们例子中的交易是发送到公开托管的比特币和以太坊测试网络节点，但如果我们不信任所有节点来处理我们的交易，我们可以自由地将交易发送到多个节点。这被称为交易广播。
- en: To summarize, when interacting with blockchains, if we intend to update the
    state of the blockchain, we submit signed transactions; and to get these transactions
    confirmed, we need to pay some fee to the network.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当我们与区块链交互时，如果我们想要更新区块链的状态，我们需要提交已签名的交易；为了使这些交易得到确认，我们需要向网络支付一定的费用。
- en: Public vs. Private Blockchains
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共区块链与私有区块链
- en: Based on access control, blockchains can be classified as public and private.
    Public blockchains are also called permissionless blockchain and private blockchains
    are also called permissioned blockchains. The primary difference between the two
    is access control. Public or permissionless blockchains do not restrict addition
    of new nodes to the network and anyone can join the network. Private blockchains
    have a limited number of nodes in the network and not everyone can join the network.
    Examples of public blockchains are Bitcoin and Ethereum main nets. An example
    of a private blockchain can be a network of a few Ethereum nodes connected to
    each other but not connected to the main net. These nodes would be collectively
    called a private blockchain.Private blockchains are generally used by enterprises
    to exchange data among themselves and their partners and/or among their suborganizations.When
    we develop applications for blockchains, the type of blockchain, public or private,
    makes a difference because the rules of interaction with the blockchain may or
    may not be the same. This is called blockchain governance. The public blockchains
    have a predefined set of rules and the private ones can have a different set of
    rules per blockchain. A private blockchain for a supply chain may have different
    governance rules, while a private blockchain for protocol governance may have
    different rules. For example, the token, gas Price, transaction fee, endpoints,
    etc. may or may not be the same in the aforementioned private Ethereum ledger
    and the Ethereum main net. This can impact our applications too.In our code samples,
    we primarily focused on the public test networks of Bitcoin and Ethereum. While
    the basic concepts of interacting with private deployments of these blockchains
    will still be the same, there will be differences in how we configure our code
    to point to the private networks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于访问控制，区块链可以分为公共和私有。公共区块链也被称为无需许可的区块链，而私有区块链也被称为需要许可的区块链。两者的主要区别是访问控制。公共或无需许可的区块链不限制新节点加入网络，任何人都可以加入网络。私有区块链中的节点数量有限，并非任何人都可以加入网络。公共区块链的例子有比特币和以太坊主网。一个私有区块链的例子可能是一个由几个以太坊节点组成的网络，这些节点彼此相连，但未连接到主网。这些节点统称为私有区块链。私有区块链通常被企业用于在彼此及其合作伙伴以及子组织之间交换数据。当我们为区块链开发应用时，区块链的类型，公共还是私有，是有区别的，因为与区块链的交互规则可能相同也可能不同。这称为区块链治理。公共区块链有一套预定义的规则，而私有区块链可能有不同的规则。例如，供应链的私有区块链可能有不同的治理规则，而协议治理的私有区块链可能有不同的规则。上述私有以太坊账本和以太坊主网中的代币、燃料价格、交易费、端点等可能相同也可能不同。这也会影响我们的应用。在我们的代码示例中，我们主要关注比特币和以太坊的公共测试网络。尽管与这些区块链的私有部署交互的基本概念仍然相同，但在配置代码以指向私有网络方面将存在差异。
- en: Decentralized Application Architecture
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去中心化应用架构
- en: In general, the decentralized applications are meant to directly interact with
    the blockchain nodes without the need for any centralized components coming into
    picture. However, in practical scenarios, with legacy systems integrations and
    limited functionality and scaling of the current blockchain networks, sometimes
    we must make choices between full decentralization and scalability while designing
    our DApps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，去中心化应用旨在无需任何中心化组件即可直接与区块链节点进行交互。然而，在实际场景中，由于需要与遗留系统集成以及当前区块链网络的功能有限和可扩展性不足，在设计我们的DApps时，我们有时必须在完全去中心化和可扩展性之间做出选择。
- en: Public Nodes vs. Self-Hosted Nodes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共节点与自托管节点的对比
- en: 'Blockchains are decentralized networks of nodes. All nodes have the same copy
    of data and they agree on the state of data always. When we develop applications
    for blockchains, we can make our application talk to any of the nodes of the target
    network. There can be mainly two set-ups for this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是由节点组成的去中心化网络。所有节点都拥有数据的一致副本，并且始终同意数据的状态。当我们为区块链开发应用时，我们可以让我们的应用与目标网络中的任何一个节点进行通信。这主要有两种设置方式：
- en: 'Application and node both run locally: The application and the node both run
    on the local machine. This means we will need our application users to run a local
    blockchain node and point the application to connect with it. This model would
    be a purely decentralized model of running an application. An example of this
    model is the Ethereum-based Mist browser, which uses a local geth node.Figure [5-6](#Fig6)
    shows this setup.![A440588_1_En_5_Fig6_HTML.jpg](Images/A440588_1_En_5_Fig6_HTML.jpg)Figure
    5-6DApp connets to local node'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用和节点都运行在本地：应用和节点都运行在本地计算机上。这意味着我们将需要我们的应用用户运行一个本地区块链节点，并让应用指向与之连接。这种模型将是一个纯粹的去中心化应用运行模型。这个模型的一个例子是基于以太坊的Mist浏览器，它使用一个本地的geth节点。[图5-6](#Fig6)展示了这个设置。![A440588_1_En_5_Fig6_HTML.jpg](Images/A440588_1_En_5_Fig6_HTML.jpg)图5-6DApp连接到本地节点
- en: 'Public node: The application talks to a public node hosted by a third party.
    This way our users don’t have to host a local node. There are several advantages
    and disadvantages of this approach. While the users don’t have to pay for power
    and storage for running a local node, they need to trust a third party to broadcast
    their transactions to the blockchain. The Ethereum browser plugin metamask uses
    this model and connects with public hosted Ethereum nodes.Figure [5-7](#Fig7)
    shows this setup.![A440588_1_En_5_Fig7_HTML.jpg](Images/A440588_1_En_5_Fig7_HTML.jpg)Figure
    5-7DApp connets to public node'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共节点：应用与第三方提供的公共节点通信。这样我们的用户就不必运行本地节点。这种方法有几个优点和缺点。虽然用户不必为运行本地节点支付电源和存储费用，但他们需要信任第三方将他们的交易广播到区块链。以太坊浏览器插件MetaMask使用这种模型，并与公共托管的以太坊节点连接。
    [图5-7](#Fig7)展示了这个设置。![A440588_1_En_5_Fig7_HTML.jpg](Images/A440588_1_En_5_Fig7_HTML.jpg)图5-7DApp连接到公共节点
- en: Decentralized Applications and Servers
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去中心化应用与服务器
- en: 'Apart from the previously mentioned scenarios, there can be other setups too,
    depending upon specific use cases and requirements. There are a lot of scenarios
    when a server is needed between an app and the blockchain. For example: When you
    need to maintain a cache of the blockchain state for faster queries; when the
    app needs to send notifications (emails, push, SMS, etc.) to the users based on
    state updates on the blockchain; and when multiple ledgers are involved, and you
    need to run a back-end logic to transform data between the ledgers. Imagine the
    infrastructure being used by some of the big cryptocurrency exchanges where we
    get all the services like two-factor authentication, notifications, and payment
    gateways, among other things, and none of these services are available directly
    in any of the blockchains. In a broader sense, blockchains simply make sure of
    keeping the data layer tamper resistant and auditable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的场景外，根据特定的用例和需求，还可能有其他的设置。有很多场景需要在应用和区块链之间运行一个服务器。例如：当你需要维护一个区块链状态的缓存以加快查询速度时；当应用需要根据区块链上的状态更新向用户发送通知（电子邮件、推送、短信等）时；以及当涉及多个账本时，你需要运行后端逻辑以在账本之间转换数据。想象一下，一些大型加密货币交易所使用的基础设施，我们从这些服务中得到两因素认证、通知和支付网关等服务，而这些服务在任何一个区块链中都不直接可用。从更广泛的角度来看，区块链只是确保数据层不易受篡改且可审计。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learned about decentralized application development along
    with some code exercises about interacting programmatically with the Bitcoin and
    Ethereum blockchains. We also looked at some of the DApp architecture models and
    how they differ based on the use cases.In the next chapter we will set up a private
    Ethereum network and then we will develop a full-fledged DApp interacting with
    this private network, which will also use smart contracts for business logic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了去中心化应用开发，并通过一些代码练习了解了如何与比特币和以太坊区块链程序化交互。我们还查看了一些DApp架构模型，以及它们如何根据用例而有所不同。在下一章中，我们将搭建一个私有的以太坊网络，然后我们将开发一个完整的DApp，与这个私有网络交互，并使用智能合约处理业务逻辑。
- en: References
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: web3.js Documentation[http://web3js.readthedocs.io/en/1.0/index.html](http://web3js.readthedocs.io/en/1.0/index.html)
    .Solidity Documentation[https://solidity.readthedocs.org/](https://solidity.readthedocs.org/)
    .bitcoinjs Source Code Repository[https://github.com/bitcoinjs/bitcoinjs-lib](https://github.com/bitcoinjs/bitcoinjs-lib)
    .Infura Documentation[https://infura.io/docs](https://infura.io/docs) .Block Explorer
    API Documentation[https://blockexplorer.com/api-ref](https://blockexplorer.com/api-ref)
    .Designing the Architecture for your Ethereum Application[https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317](https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317)
    .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 官方文档[http://web3js.readthedocs.io/en/1.0/index.html](http://web3js.readthedocs.io/en/1.0/index.html)
    。Solidity 官方文档[https://solidity.readthedocs.org/](https://solidity.readthedocs.org/)
    。bitcoinjs 源代码仓库[https://github.com/bitcoinjs/bitcoinjs-lib](https://github.com/bitcoinjs/bitcoinjs-lib)
    。Infura 官方文档[https://infura.io/docs](https://infura.io/docs) 。区块浏览器 API 文档[https://blockexplorer.com/api-ref](https://blockexplorer.com/api-ref)
    。为您的以太坊应用设计架构[https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317](https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317)
    。
