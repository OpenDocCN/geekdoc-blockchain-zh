- en: © Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_3
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_3
- en: 3. The EVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 以太坊虚拟机（EVM）
- en: The Ethereum Virtual Machine (EVM) is a worldwide computer that anyone can use,
    for a small fee, payable in etherChris Dannen^(1 )(1)Brooklyn, New York, USAThe
    EVM is a single, global 256-bit “computer” in which all transactions are local
    on each node of the network, and executed in relative synchrony. It’s a globally
    accessible virtual machine, composed of lots of smaller computers.This giant computer,
    which anyone who has a node or wallet application can access, makes it simple
    to move arbitrarily large amounts of value (money) nearly instantly. Although
    anyone can use this global virtual machine, nobody can create counterfeit money
    inside it, or move funds without permission.If it seems wasteful to have the entire
    EVM, all those nodes, replicating the same transactions and slavishly maintaining
    the same state among thousands of individual computers, it’s important to have
    a proper basis for comparison for how financial services IT works today. The EVM
    is a paragon of simplicity and efficiency by comparison! More importantly, all
    that work isn’t for naught. In fact, as you’ll see in this chapter, it’s the evidence
    of this work that actually secures the network.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）是一个全球性的计算机，任何人都可以使用，只需支付一小笔以太币Chris Dannen^(1 )(1)美国纽约布鲁克林EVM是一个单一的全球性256位“计算机”，在网络的每个节点上，所有交易都是本地化的，并以相对同步的方式执行。这是一个全球可访问的虚拟机，由许多较小的计算机组成。这台巨型计算机，任何拥有节点或钱包应用的人都可以访问，使得几乎可以即时地移动任意数量的价值（货币）。虽然任何人都可以使用这个全球虚拟机，但没有人可以在其中创建假币，或未经许可移动资金。如果整个EVM，所有那些节点，复制相同的交易并在成千上万个个人计算机之间奴性地维护相同的状态，这似乎是浪费的，那么对比一下当今金融服务IT工作的适当基础是很重要的。与金融服务IT相比，EVM是简洁高效的典范！更重要的是，所有这些工作并不是白费力气。事实上，正如您将在本章中看到的那样，正是这项工作的证据实际上保护了网络。
- en: The Central Bank Network of Yesterday
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 昨天的中央银行网络
- en: 'Today, corporations, insurers, universities, and other large institutions spend
    incredible amounts of money building and maintaining software services and IT
    for their own employees, and all their lines of business. Their various inflows
    and outflows are reconciled by large commercial banks, which have their own architecture,
    policy, codebase, databases, and layers of infrastructure. This, of course, is
    all on top of the Fedwire , which is the Federal Reserve’s real-time gross settlement
    system, or RTGS.The Federal Reserve is the central bank of the United States.
    The Fedwire is used by all Federal Reserve member banks to settle final payments
    in electronic US dollars. Any qualified state-chartered bank may become a member
    of the system by buying shares in it. Fedwire is owned and operated by the 12
    Federal Reserve Banks themselves, and although it does charge fees, it isn’t operated
    for profit.This system processes unthinkable amounts of US dollars every day—trillions
    upon trillions. It has some great features, too: there’s an overdraft system covering
    all existing and approved accounts, and the system is famously reliable, even
    for remittances overseas. It has been in operation in some form or another for
    about 100 years.As you can imagine, maintaining the security and reliability of
    the Fedwire software is extremely expensive. Yet, the cost of building and maintaining
    layers on top of an RTGS is higher still, owing to its security requirements.
    Ultimately, these costs are passed on to corporations who use commercial banks,
    in the form of fees. Those companies have their own IT infrastructure costs. In
    the aggregate these costs ultimately drive up prices and fees for consumers.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，各大企业、保险公司、大学和其他大型机构都花费了大量资金来构建和维护软件服务以及为自己的员工和业务线提供的IT支持。它们的各种收入和支出由大型商业银行进行对账，这些银行有自己的架构、政策、代码库、数据库和基础设施层。当然，这还不算Fedwire系统，这是美联储的实时毛额结算系统，简称RTGS。美联储是美国的中央银行。Fedwire系统由所有美联储成员银行用于以电子美元进行最终支付结算。任何合格的州立特许银行都可以通过购买股份成为该系统的成员。Fedwire系统由12家美联储银行自己拥有和运营，尽管它收取费用，但它并非盈利性运营。这个系统每天处理着无法想象的美元金额——以万亿计。它还有一些很棒的特性：所有现有和批准的账户都有透支系统，而且该系统以其在海外汇款方面的可靠性而闻名。它或多或少以某种形式运行了大约100年。正如你所想象的那样，维护Fedwire软件的安全性和可靠性是极其昂贵的。然而，构建和维护在RTGS之上的各个层次的成本更高，这归因于其安全要求。最终，这些成本通过费用转嫁给了使用商业银行的企业。这些公司有自己的IT基础设施成本。总的来说，这些成本最终会推高消费者的价格和费用。
- en: What are Virtual Machines, Exactly?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟机？
- en: If you were unfamiliar with virtual machines at the outset of this book, you’ve
    probably gathered by now that a virtual machine (VM) , in the Ethereum context,
    is one giant global computer composed of constituent nodes, which are themselves
    computers too.Generally speaking, a virtual machine is an emulation of a computer
    system by another computer system. These emulations are based on the same computer
    architectures as the target of their emulation, but they’re usually reproducing
    that architecture on different hardware than it may have been intended for. Virtual
    machines can be created with hardware, software, or both. In the case of Ethereum,
    it’s both. Rather than securely network thousands of discrete machines, as with
    Fedwire, Ethereum takes the approach of securely operating one very large machine
    that can encompass the whole Earth.As you’ll see from the long list of Ethereum
    clients for various operating systems, the EVM is a collective emulation being
    run on thousands of machines that—on an individual level—may be running any one
    of dozens of versions of Windows, Linux, ethOS, and macOS (more about ethOS in
    Chapter [6](A433414_1_En_6_Chapter.html)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读本书之初对虚拟机不太熟悉，那么到现在你可能已经明白，在以太坊的语境中，虚拟机（VM）是一个由构成节点组成的一个巨大的全球计算机，这些节点本身也是计算机。一般来说，虚拟机是一个计算机系统通过另一个计算机系统进行仿真。这些仿真是基于与其仿真目标相同的计算机体系结构，但通常在与其可能设计用于的不同硬件上再现该体系结构。虚拟机可以使用硬件、软件或两者创建。在以太坊的情况下，两者都有。与Fedwire一样，以太坊没有安全地连接成千上万台离散的机器，而是采取了一种安全地运行一个非常庞大的机器的方法，该机器可以覆盖整个地球。从以太坊客户端的长列表中可以看出，EVM是在成千上万台机器上运行的集体仿真，在个别级别上，这些机器可能正在运行Windows、Linux、ethOS和macOS等几十种不同版本中的任何一种（有关ethOS的更多信息，请参见第[6](A433414_1_En_6_Chapter.html)章）。
- en: The Role of the Ethereum Protocol in Banking
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊协议在银行业中的角色
- en: It’s beyond the scope of this book to posit whether blockchain-based systems
    are appropriate for use by, or are indeed the replacement for, sovereign central
    banks. It’s much more likely that central banks themselves will adopt the technology.
    The commerical banks are certainly interested; you’ll find more information about
    the banks and enterprises involved in Ethereum development in Chapter [11](A433414_1_En_11_Chapter.html).The
    Fedwire system is a settlement system with a user experience tailored to state-chartered
    banks and their operators. It makes little or no concern for the end user of a
    retail bank, for example; that’s the job of the retail bank.Software developers
    will recognize Fedwire as a “platform for banks.” What the bank chooses to build
    on top of Fedwire (the customer experience, the online banking tools, the brick-and-mortar
    branches, the financial products, the cross-selling) is what distinguishes it
    from other banks on the Fedwire system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的范围不足以断言基于区块链的系统是否适合被主权中央银行使用，或者是否确实可以取代它们。更有可能的是，中央银行自身将采用这项技术。商业银行当然也感兴趣；您可以在第[11](A433414_1_En_11_Chapter.html)章找到更多关于参与以太坊开发的银行和企业的信息。Fedwire系统是一个结算系统，其用户体验专为州特许银行及其运营商量身定制。例如，对于零售银行的最终用户，它几乎没有任何关注或关心；这是零售银行的职责。软件开发人员将Fedwire视为“银行平台”。银行选择在Fedwire之上构建的内容（客户体验、在线银行工具、实体分支机构、金融产品、跨销售）是使其与Fedwire系统上的其他银行区别开来的因素。
- en: Anyone Can Make a Banking Platform
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何人都可以制作银行平台
- en: 'Ethereum is far more generalized. It allows anyone to spin up a network with
    as good or better security and reliability than Fedwire, and with the ability
    to make secure value transfers nearly instantly. But this is only where Ethereum
    starts. Developers can build any sort of financial products or business logic
    they want on top of this secure ledger, with automated and immutable scripts,
    and without needing to pay the overheads dumped on them by the traditional centralized
    hosting and banking infrastructure.But does it scale to the speed and size of
    a system like Fedwire? The answer is, yes, it can, but this will take several
    years. There are no direct or fixed limit neither for transaction sizes or block
    sizes. In Bitcoin, the size of the block is limited to 1MB, which works out to
    about 7 transactions per second. In Ethereum these limits increase and decrease
    in accordance with demand and network capacity.However, this does not mean that
    blocks can be unlimited size. Recall that units of work in the Ethereum network
    are priced in gas. Thus, larger, more complex smart contracts cost more gas to
    store and execute. The maximum amount of gas which can be spent per block is variable,
    but there is a maximum. Theoretically, one large transaction could consume the
    entire gas limit of a single block. But if there is continuous demand for higher
    gas limits, the system will increase the gas limit per block in increments of
    0.09 percent. (For more detail on how this works, see the Ethereum Yellow Paper,
    equations 40-42.) As of this writing, the gas limit is 4,041,325 gas per block.What
    does this mean for the financial services industry? Certainly not doom, but perhaps
    some unexpected competition. The impact could be an unbundling of banking services
    into ever smaller brands as the public Ethereum chain scales and is capable of
    processing more transactions, faster and faster. Laura Shin, author and host of
    the blockchain-centric podcast Unchained, interviewed Adam Ludwin of San Francisco
    blockchain startup Chain in 2016 and wrote this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊（Ethereum）更加通用。它允许任何人创建一个具有与 Fedwire 相同或更好的安全性和可靠性的网络，并且具有几乎即时进行安全价值转移的能力。但这只是以太坊的起点。开发者可以在这个安全账本上构建任何类型的金融产品或业务逻辑，使用自动化和不可变的脚本，而无需支付传统中心化托管和银行基础设施所带来的额外负担。但是它是否能够扩展到像
    Fedwire 这样的系统的速度和规模？答案是，是可以的，但这需要数年的时间。交易大小或区块大小都没有直接或固定的限制。在比特币中，区块的大小限制为1MB，大约相当于每秒7笔交易。在以太坊中，这些限制会根据需求和网络容量的变化而增加和减少。然而，这并不意味着区块可以无限大小。请记住，以太坊网络中的工作单位是以
    gas 为价格计价的。因此，更大、更复杂的智能合约需要更多的 gas 来存储和执行。每个区块可以花费的 gas 的最大金额是可变的，但是有一个最大值。理论上，一笔大型交易可以消耗单个区块的整个
    gas 限制。但如果对更高 gas 限制有持续需求，系统将以0.09%的增量增加每个区块的 gas 限制。（有关此操作原理的更多详细信息，请参阅以太坊黄皮书，方程式40-42。）截至撰写本文时，每个区块的
    gas 限制为4,041,325 gas。这对金融服务行业意味着什么？当然不是末日，但也许会出现一些意想不到的竞争。随着公共以太坊链的扩展，并且能够处理更多的交易，速度越来越快，可能会导致银行服务逐渐分拆为越来越小的品牌。2016年，主持以区块链为中心的播客《Unchained》的作家兼主持人
    Laura Shin 采访了旧金山区块链初创公司 Chain 的 Adam Ludwin，并撰写了这篇文章：
- en: As for who owns the network, in the current system, if you go to Chase to deposit
    $50 cash, Chase holds that money, which was issued by the Federal Reserve, on
    its network. But Ludwin said you could imagine, instead of banks running the network,
    Fedwire, the current system for electronically settling payments between member
    banks, being reconstructed on a blockchain for which banks hold keys to make transfers.That
    could then lead to nonfinancial institutions being custodians of such currency.
    “With small enough amounts, you don’t need a bank,” said Ludwin. “Could Google,
    could Apple, could Facebook be holding small amounts of digital cash? Does that
    change the model of who a custodian is or could be? And the answer is yes.” It
    could also open up more avenues for peer-to-peer lending, reducing consumers’
    reliance on banks for loans. [¹](#Fn1)
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谁拥有这个网络，在当前系统中，如果你去Chase存入$50现金，Chase持有那笔钱，这笔钱是由联邦储备发行的，并在其网络上交易。但Ludwin说，你可以想象，与其由银行运行网络，不如将Fedwire，即当前用于成员银行之间电子结算付款的系统，重建在一个区块链上，银行持有转账的密钥。这可能导致非金融机构成为这种货币的保管人。“对于足够小的金额，你不需要银行，”Ludwin说。“Google、苹果、Facebook可以持有少量的数字现金吗？这是否改变了保管人的模式或可能的保管人？答案是肯定的。”这也可能为点对点借贷开辟更多途径，减少消费者对银行贷款的依赖。
    [¹](#Fn1)
- en: What the EVM Does
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊虚拟机的功能
- en: 'By now, the EVM may be coming into focus: a generalized, secure, ownerless
    virtual machine that offers cheap Fedwire-like functionality with a bunch of other
    magic on top. How exactly does it do this?The EVM can run arbitrary computer programs
    (the smart contracts mentioned in Chapter [1](A433414_1_En_1_Chapter.html)) written
    in the Solidity language. These programs, given a particular input, will always
    produce the output the same way, with the same underlying state changes. This
    makes Solidity programs fully deterministic and guaranteed to execute, provided
    you’ve paid enough for the transaction; but we’ll talk about paying for gas later
    in this chapter.Solidity programs are capable of expressing all tasks accomplishable
    by computers, making them theoretically Turing complete. That means that the entire
    distributed network, every node, performs every program executed on the platform.
    When one user uploads a smart contract through their Ethereum node, it is included
    in the latest block and propagated around the network, where it is stored on every
    other node in the network.As we’ve discussed already, it’s the job of each and
    every node in the EVM to run the same code, as part of the block processing protocol.
    The nodes go through the block they are process and run any code enclosed within
    the transactions. Each node does this independently; it is not only highly parallelized,
    but highly redundant.Despite all appearances, this is an efficient way to balance
    a global ledge r in a trustworthy way. It’s important to remember just how much
    money, power, and human energy is spent for each bank everywhere to cobble together
    its own unique IT system or cocktail of systems for each of its lines of business.
    In an Ethereum-based banking system, all users (whether corporations or customers)
    get direct access to the same Fedwire-like system at no cost, with the ability
    to program transactions. Because the protocol is free and open source, anyone
    can fire up a node and connect. Unfortunately, the preceding explanation of the
    Fedwire system is often left out of cryptocurrency discussions, despite being
    necessary context to understanding the benefits of large public blockchains.You
    can find up-to-date community-written documentation for the Ethereum project in
    the Homestead Documentation Initiative ( [www.ethdocs.org/en/latest](http://www.ethdocs.org/en/latest)
    ). These docs are not endorsed by the Ethereum Foundation, but have grown into
    a popular resource for their plain-language explanation of technical concepts.For
    more-nuanced technical discussions and to view Ethereum Improvement Proposals
    (EIPs) , turn to the Ethereum wiki at [https://github.com/ethereum/wiki/wiki](https://github.com/ethereum/wiki/wiki)
    . On the wiki, you’ll find the Ethereum White Paper. If you have remaining questions
    about the way Ethereum works after reading this book, chances are the answer you
    seek is in the White Paper or the aforementioned Yellow Paper, which you’ll also
    find linked on the Ethereum wiki.Chapter [11](A433414_1_En_11_Chapter.html) provides
    an additional index of academic papers associated with the Ethereum project. These
    relate to the future of the project, including scalability and interoperability
    of the Ethereum public chain with private or corporate chains, among other topics.Global
    Singleton MachineThe EVM is a transaction singleton machine with shared state.
    In computing, this means it behaves like one giant data object, rather than what
    it is: a network of discrete machines, themselves singletons, in constant communication.
    (If you’re a nonprogrammer, you may remember from Chapter [1](A433414_1_En_1_Chapter.html)
    that an object is a little chunk of information that is formatted just so, and
    that contains attributes as well as methods for reading or changing those attributes.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: EVM Applications Are Called Smart Contracts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EVM应用被称为智能合约
- en: From the perspective of a software developer, the EVM is also a runtime environment
    for small programs that can be executed by the network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件开发者的角度来看，EVM也是一个可以执行网络中的小程序的运行时环境。
- en: The Name “Smart Contracts ”
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称“智能合约”
- en: 'Rather than bore you with the etymology of this word, let’s clear up one thing:
    in this context, contract refers to a specific kind of contract: a financial contract,
    also known more colloquially as a derivative, or option. Financial contracts are
    agreements to buy and sell at some point in the future, usually at a specified
    price. In the Ethereum context, smart contracts are agreements between accounts,
    to render a transfer of ether (that is, a payment) when certain conditions are
    met.The reason these contracts are “smart” is that they’re executed by machine,
    and the assets (ether or other tokens) are moved automatically. These contracts
    could be enforced even hundreds of years after they’ve been written, assuming
    the network is still running then—and even if a lot of bad actors try to interfere.
    The EVM is totally sandboxed and free from interference, and isolated from other
    networks too, making it impossible for a party to back out of a smart contract.
    In practical terms, this is because smart contracts are empowered to hold assets
    (ether or other tokens) in escrow and move them when the terms of the contract
    are met.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让你听我翻译这个词的词源，让我们澄清一件事：在这个上下文中，合约指的是一种特定类型的合约：金融合约，也更通俗地称为衍生品或期权。金融合约是一种同意在未来某个时间点以指定价格买入或卖出的协议。在以太坊的上下文中，智能合约是账户之间的协议，在满足某些条件时执行以太（即支付）。这些合约之所以“智能”，是因为它们由机器执行，并且资产（以太或其他代币）会自动转移。即使在编写合约数百年后，这些合约也可以执行，假设网络仍在运行中——即使有很多不良行为者试图干扰。EVM是完全沙箱化的，没有受到干扰，并且与其他网络隔离，使得某一方无法退出智能合约。在实际操作中，这是因为智能合约被赋予了托管资产（以太或其他代币）并在合约条款满足时移动它们的权力。
- en: The EVM Runs Bytecode
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EVM执行字节码
- en: The EVM has its own language, the EVM bytecode, to which your smart contracts
    compile. Solidity, which is a high-level language, is compiled into bytecode and
    uploaded onto the Ethereum blockchain by using a client application such as the
    Mist browser or a full node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: EVM（以太坊虚拟机）有自己的语言，即EVM字节码，您的智能合约会编译成该字节码。Solidity是一种高级语言，会被编译成字节码，并通过客户端应用程序（如Mist浏览器或完整节点）上传到以太坊区块链上。
- en: Understanding State Machines
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态机
- en: The EVM, as we’ve discussed several times so far, is a state machine. Instead
    of simply defining this concept and moving on, let’s take a moment to discuss
    exactly what a computer is before moving on to the ways that Ethereum advances
    the concept.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前多次讨论过的，EVM是一个状态机。与其简单地定义这个概念然后继续，让我们花一点时间讨论一下计算机究竟是什么，然后再讨论以太坊如何推进这个概念。
- en: Digital vs. Analog
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字与模拟
- en: 'Foundational to the concept of a stateful computer is the idea of a switch
    that can be on or off. The 1s and 0s always referred to as the lingua franca of
    machines refer to arrays of metaphorical switches, so to speak, put in a certain
    configuration in order to code for specific letters, numbers, or other keyboard
    symbols. All of the symbols on a keyboard (and more) can be represented with just
    eight switches, which is why computing memory is stacked in multiples of eight.
    The so-called character code for a comma, for example, is 0010 1100.In computer
    programming, letters and numbers can be used to write machine instructions colloquially
    known as code. American researcher and US Navy Rear Admiral Grace Hopper, shown
    in Figure [3-1](#Fig1), invented the first compiler , which automatically turned
    human-readable code into machine code (like the EVM’s bytecode), which is less
    abstract and therefore one step closer to the 1s and 0s we hear so much about.[²](#Fn2)![A433414_1_En_3_Fig1_HTML.jpg](A433414_1_En_3_Fig1_HTML.jpg)Figure
    3-1.Rear Admiral Grace Hopper was one of the first programmers to write code for
    Harvard’s Mark I computer in 1944\. (Credit: Wikipedia.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建状态计算机的基础概念是开关的概念，它可以开或关。常说的机器通用语1和0，实际上指的是一系列形象的开关，这些开关按特定配置排列以编码特定的字母、数字或其他键盘符号。键盘上的所有符号（以及更多符号）都可以仅用八个开关来表示，这就是为什么计算内存以八的倍数堆叠的原因。例如，逗号的所谓字符代码是0010
    1100。在计算机编程中，字母和数字可以用来编写俗称为代码的机器指令。美国研究员、美国海军少将格蕾丝·霍普尔在图[3-1](#Fig1)中展示，发明了第一个编译器，它可以自动将人类可读的代码转换成机器代码（如EVM的字节码），这种代码较不抽象，因此更接近我们常听说的1和0。[²](#Fn2)![A433414_1_En_3_Fig1_HTML.jpg](A433414_1_En_3_Fig1_HTML.jpg)图3-1.1944年，少将格蕾丝·霍普尔是最早为哈佛大学的马克一号计算机编写代码的程序员之一。（图片来源：维基百科。）
- en: “State-ments”
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “声明”
- en: 'Individual snippets of code, when considered by themselves, fall broadly into
    two buckets: expressions and statements. Expressions are used to evaluate a particular
    condition; statements (note the root word!) are used to write information into
    the computer’s memory. Together, expressions and statements let computers modify
    a database in a predictable way when specific conditions are met. This is the
    crux of automation, and it’s the reason we find computers so useful!Statements
    can evaluate to true or false, and depending on the code, this binary outcome
    can result in information being added, removed, or altered within one of the computer’s
    many, many memory addresses. (Because the Solidity language is strongly typed,
    there are no “truthy” and “falsey” statements as in JavaScript.) The clear distinction
    between true and false, yes and no, on and off, is what allows computers to safely
    make decisions in lieu of humans.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的代码片段，当单独考虑时，大致可分为两类：表达式和语句。 表达式用于评估特定条件； 语句（注意根词！）用于将信息写入计算机的内存中。 表达式和语句一起使计算机能够在满足特定条件时以可预测的方式修改数据库。
    这是自动化的关键，也是我们发现计算机如此有用的原因！ 语句可以评估为真或假，并且根据代码的不同，此二元结果可能导致信息被添加，删除或更改到计算机的众多内存地址之一。（由于Solidity语言是强类型的，因此没有类似于JavaScript中的“真值”和“假值”语句。）真和假之间的明确区别，是允许计算机安全地做出决策而不是人类的原因。
- en: Data’s Role in State
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据在状态中的作用
- en: 'Every time you change data in a computer’s memory, you can think of its zillions
    of internal switches (most of them virtualized in the same way we discussed earlier
    in this chapter) as being in a slightly different configuration. State generally
    refers to the present condition of the system: the objective series of changes
    in information, across various memory addresses of the machine, that led to the
    current contents of its memory.It’s important to distinguish between an attribute
    and state. State is something that can change easily and predictably. Let’s use
    the example of a car.Repainting a car is hard work, but it can be done. Paint
    color is an example of an attribute. In pseudocode, you might say the following
    about a car:bodyColor = redIn computer programming, this is called a key/value
    pair . The key, bodyColor, has a value assigned to it, which is red. To change
    the value of this key, your code makes a new statement of the value to be something
    else:bodyColor = greenAnd now your car has been repainted. It has a new color
    value.Now let’s say you instruct the computer that the color of this car will
    change frequently. In other words, you make the car’s color a variable. Well,
    it can be said that the variable (in this case, the color) can have a state, which
    is a value that changes. But an individual value, such as green, has no state;
    green is simply green.An odometer provides another example of a variable with
    a changeable state. The odometer’s value might be 1,000, a number that itself
    has no state; it’s just a number. Soon, the state of the odometer will change
    to a new value (1,001), but that will happen only if the cockpit of the car expresses
    commands that cause the motor and transmission to change state from neutral to
    first gear, and so on.Working familiarity with the concept of state transition
    will help nonprogrammers gain insight into the truly hard problems incumbent in
    the design of decentralized systems. The next several sections of this chapter
    provide a crash course.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你改变计算机内存中的数据时，你可以将其无数的内部开关（其中大多数是以与本章前面讨论的方式虚拟化的）视为略有不同的配置。状态通常指系统的当前状态：信息的客观变化序列，跨越机器的各种内存地址，导致其内存的当前内容。区分属性和状态非常重要。状态是一种可以轻松而可预测地改变的东西。让我们以汽车为例。重新漆车是一项艰苦的工作，但是可以做到。油漆颜色是属性的一个例子。在伪代码中，你可以这样说一辆车：bodyColor
    = red。在计算机编程中，这被称为键/值对。键bodyColor分配了一个值，即红色。要更改此键的值，您的代码会将新值声明为其他内容：bodyColor
    = green。现在你的车被重新喷漆了。它有了一个新的颜色值。现在假设你指示计算机，这辆车的颜色会经常改变。换句话说，你将汽车的颜色设置为一个变量。嗯，可以说变量（在本例中是颜色）可以有一个状态，即一个变化的值。但是，像绿色这样的单个值没有状态；绿色只是绿色而已。里程表提供了另一个具有可变状态的变量的例子。里程表的值可能是1,000，这个数字本身没有状态；它只是一个数字。很快，里程表的状态将更改为新值（1,001），但只有当汽车的驾驶舱表达出导致发动机和变速器从空档到一档等状态改变的命令时才会发生。熟悉状态转换概念将帮助非程序员洞察设计分散系统所面临的真正困难的问题。本章的接下来几节提供了一个快速入门。
- en: How the Guts of the EVM Work
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EVM 的内部工作原理
- en: 'If this is your first encounter with the internals of a computer, it’s important
    to remember that a computer is never truly “at rest” as long as it’s powered on.
    The computer itself is running a state function, constantly checking for changes
    to its state. It’s like an overeager intern who wonders thousands of times per
    second if any new work has landed on his desk.When new instructions are triggered,
    the computer runs code and may write new data to its memory. It’s important to
    note that each state change must be based on the last state change; a computer
    doesn’t just toss information into memory addresses willy-nilly.Should something
    go wrong—let’s say one of these instructions isn’t mathematically possible—the
    state of the machine will become invalid, and the program will exit or stop. In
    fact, the entire system may crash.Programs that constantly check for a certain
    condition are known as loops in programming, because they continue to run (to
    loop) until the specified condition is met. The EVM runs a loop continuously that
    attempts to execute whatever instructions are at the current program counter (whatever
    program is “on deck” to be processed). The program counter works like a delicatessen
    queue: each program takes a number and waits its turn.This loop has a few jobs:
    it calculates the cost of gas for each instruction; and it uses memory, if necessary,
    to execute the transaction if the preamble calculation succeeds. This loop repeats
    until the VM either finishes running all the code on deck, or it throws an exception,
    or error, and that transaction is rolled back.Thus far we’ve walked breezily through
    a century of computer science just to catch up to the EVM. Now we’ll begin to
    slow down and see how some of the parts work in action.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '如果这是你第一次接触计算机内部，重要的是要记住，只要计算机通电，它就永远不会真正“休息”。计算机本身正在运行一个状态函数，不断检查其状态是否有变化。这就像一个急切的实习生，每秒数千次地想知道是否有新的工作落在他的桌子上。当触发新的指令时，计算机会运行代码，并可能将新数据写入其内存。重要的是要注意，每个状态变化都必须基于上一个状态变化；计算机不会随意将信息扔进内存地址。如果出现问题——比如说某个指令在数学上是不可能的——机器的状态将变为无效，并且程序将退出或停止。事实上，整个系统可能会崩溃。不断检查特定条件的程序称为编程中的循环，因为它们会持续运行（循环）直到满足指定的条件。EVM不断运行一个循环，尝试执行当前程序计数器上的任何指令（即“正在处理的”程序）。程序计数器的工作原理类似于熟食店的队列：每个程序都会取一个号码然后等待轮到它。这个循环有几个任务：它计算每条指令的气体成本；如果需要，它会使用内存来执行事务，如果前提计算成功。这个循环重复，直到VM完成运行所有的待处理代码，或者抛出异常或错误，并且该事务被回滚。到目前为止，我们已经轻松地走过了一个世纪的计算机科学，只是为了赶上EVM。现在我们将开始放慢脚步，看看一些部件是如何运作的。  '
- en: The EVM Constantly Checks for Transactions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'EVM 不断检查交易  '
- en: State machines (machines with memory) can be thought of as beings who never
    sleep. As a state machine, the EVM has a constant history of all transactions
    within their memory banks, leading all the way back to the very first transaction.
    Unlike people, who have to deal with imperfect memory, a computer’s state (as
    it exists today) is the specific outcome of every single state-change that has
    taken place inside that machine since it was first switched on.The latest version
    of the machine’s state can be said to be this machine’s canonical “truth” about
    reality as it stands right now. In Ethereum, this truth deals with account balances,
    and the series of transactions that make your balance whatever it is today.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机（具有内存的机器）可以被认为是永不休息的存在。作为一个状态机，以太虚拟机（EVM）在它们的内存银行中具有所有交易的恒定历史，一直延伸到第一笔交易。与人不同，人们必须应对不完美的记忆，计算机的状态（如今的状态）是自它首次开机以来该机器内发生的每一个状态变化的具体结果。该机器最新版本的状态可以说是这台机器关于现实的权威“真相”，就目前而言。在以太坊中，这个真相涉及账户余额和使您的余额成为今天所处状态的一系列交易。
- en: Creating a Common Machine Narrative of What ­Happened
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个共同的机器叙事，描述发生了什么
- en: 'Transactions, therefore, represent a kind of machine narrative —a computationally
    valid arc between one state and another. As Gavin Wood’s Ethereum Yellow Paper
    says:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，交易代表了一种机器叙事——一个在一个状态和另一个状态之间的计算有效的弧。正如加文·伍德的以太坊黄皮书所言：
- en: There exist far more invalid state changes than valid state changes. Invalid
    state changes might, e.g., be things such as reducing an account balance without
    an equal and opposite increase elsewhere. A valid state transition is one which
    comes about through a transaction. [³](#Fn3)
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无效的状态变化远远多于有效的状态变化。无效的状态变化可能是诸如减少账户余额而没有在其他地方进行等量且相反的增加等事情。有效的状态转换是通过交易发生的状态转换。[³](#Fn3)
- en: As time advances, the system (as in Bitcoin) seeks to create a trustworthy history
    for ensuring that each subsequent state change is legitimate, and not an instruction
    inserted by a bad actor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，系统（比特币中的系统）寻求创建一个可信的历史，以确保每个后续的状态变化都是合法的，并且不是由恶意行为者插入的指令。
- en: Cryptographic Hashing
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密哈希
- en: 'The next section explains blocks: what’s in them, how they work, and how they
    make a chain. To properly understand that discussion, you first need to learn
    about cryptographic hashing algorithms and what they’re good for.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释区块：它们包含什么，它们如何工作以及它们如何构成链。为了正确理解该讨论，您首先需要了解加密哈希算法以及它们的作用。
- en: What Hash Functions (or Hash Algorithms ) Do
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是哈希函数（或哈希算法）
- en: Generally speaking, the purpose of hash functions, in the context of a blockchain,
    is to compare large datasets quickly and evaluate whether their contents are similar.
    A one-way algorithm processes the entire block’s transactions into 32 bytes of
    data—a hash, or string, of letters and numbers that contains no discernible information
    about the transactions within. The hash creates an unmistakable signature for
    a block, allowing the next block to build on top of it. Unlike the ciphertext
    that results from encryption, which can be decrypted, the result of a hash cannot
    be “un-hashed.”NoteThe hash of a given dataset is always the same. It is computationally
    infeasible that two datasets might resolve to similar hashes. Changing even one
    character of the dataset will completely jumble up the hash.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，在区块链的背景下，哈希函数的目的是快速比较大型数据集并评估它们的内容是否相似。 一种单向算法将整个区块的交易处理为32字节的数据——一个哈希，或者说是一串字母和数字的字符串，不包含有关其中交易的可辨识信息。
    哈希为区块创建了一个独特的签名，允许下一个区块在其上构建。 与加密结果的密文不同，后者可以解密，哈希的结果不能被“取消哈希化”。 注意：给定数据集的哈希始终相同。
    计算上，两个数据集可能解析为相似的哈希是不可行的。 改变数据集中的任何一个字符将完全打乱哈希。
- en: 'Blocks : The History of State Changes'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链：状态变化的历史
- en: Transactions and state changes in the Ethereum network are segmented into blocks,
    and then hashed. Each block is verified and validated before the next canonical
    block can be placed on “top” of it. In this way, nodes on the network do not need
    to individually evaluate the trustworthiness of every single block in the history
    of the Ethereum network, simply to compute the present balances of the accounts
    on the network. They merely verify that its “parent block” is the most recent
    canonical block. They do this quickly by looking to see that the new block contains
    the correct hash of its parent’s transactions and state.All the blocks strung
    together, and including the genesis block, an honorific describing the first block
    the network mined after coming online, are called the blockchain. In some circles,
    you will hear the blockchain referred to as a distributed ledger or distributed
    ledger technology (DLT).Ledger is an accurate description, as the chain contains
    every transaction in the history of the network, making it effectively a giant,
    balanced book of accounts. However, most so-called digital ledgers do not use
    proof of work to secure the network, as Bitcoin and Ethereum do.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊网络中，交易和状态变化被分割成区块，然后进行哈希处理。在“顶部”放置下一个规范区块之前，每个区块都会被验证和验证。通过这种方式，网络上的节点不需要单独评估以太坊网络历史上每个单独区块的可信度，仅仅是为了计算网络上账户的当前余额。他们只需验证其“父区块”是否是最近的规范区块。他们通过查看新区块是否包含其父区块的交易和状态的正确哈希来快速完成此操作。所有这些区块被串在一起，包括创世区块，这是网络上线后挖掘的第一个区块的荣誉描述，被称为区块链。在一些圈子中，你会听到人们将区块链称为分布式账本或分布式账本技术（DLT）。账本是一个准确的描述，因为该链包含了网络历史上的每一笔交易，使其实际上成为一个巨大的、平衡的账户簿。然而，大多数所谓的数字账本并不使用工作量证明来保护网络，就像比特币和以太坊那样。
- en: Understanding Block Time
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解区块时间
- en: In Bitcoin, a block is 10 minutes. This so-called block time is derived from
    constants hard-coded into Bitcoin’s issuance scheme, with a total of 21 million
    coins to be released from 2009 to 2024, and rewards halving every four years.[⁴](#Fn4)In
    Ethereum, block time is not a function of the issuance schedule of ether. Instead,
    block time is a variable that is kept as low as possible, for the sake of speedy
    transaction confirmation. It averages about 15 seconds as of this writing. Ethereum’s
    shorter block time is the beneficiary of blockchain research done after the launch
    of Bitcoin, which showed that shorter block times were not only technically feasible,
    but desirable in many ways. However, shorter block times do have some drawbacks
    that are explored more thoroughly in Chapter [6](A433414_1_En_6_Chapter.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，一个区块是 10 分钟。这个所谓的区块时间是从硬编码到比特币发行方案中导出的常量，总共有 2100 万枚硬币将在 2009 年至 2024
    年发行，并且每四年减半一次奖励。[⁴](#Fn4)在以太坊中，区块时间不是以太的发行计划的一个函数。相反，区块时间是一个变量，尽可能保持低，以便进行快速交易确认。截至本文撰写时，平均约为
    15 秒。以太坊较短的区块时间是比特币发布后进行的区块链研究的受益者，该研究表明较短的区块时间不仅在技术上可行，而且在许多方面都是可取的。然而，较短的区块时间确实具有一些缺点，在第
    [6](A433414_1_En_6_Chapter.html) 章中更详细地探讨了这些缺点。
- en: The Drawbacks of Short Blocks
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**短区块的缺点**'
- en: It’s important to note that Bitcoin’s long confirmation times make retail commerce
    and other practical applications difficult. When blocks are shorter and transactions
    move faster, user experience is better. However, shorter blocks and faster transactions
    make it more likely that a given node will get the order of transactions wrong,
    because it may not have heard about some transactions originating from far away
    (or heard about them late).To compensate for this, the miners who find blocks
    that are valid, but nonetheless not the winning block, are paid a reduced fee
    as consolation. In Ethereum, these blocks are called Uncles.What makes a block
    valid vs. the winner is the subject of Chapter [6](A433414_1_En_6_Chapter.html).To
    see the full Ethereum block protocol, visit [https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0](https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0)
    .For now, let’s continue with our overview of the EVM.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，比特币的长确认时间使得零售商业和其他实际应用变得困难。当区块更短，交易更快时，用户体验更好。然而，更短的区块和更快的交易使得某个节点更有可能将交易顺序弄错，因为它可能没有听说过一些来自遥远地方的交易（或者听说得很晚）。为了补偿这一点，找到有效但最终未成功的区块的矿工会获得一笔较低的费用作为安慰。在以太坊中，这些区块被称为叔叔。什么使一个区块有效与赢家的区别是第
    [6](A433414_1_En_6_Chapter.html) 章的主题。要查看完整的以太坊区块协议，请访问 [https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0](https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0)。现在，让我们继续概述以太坊虚拟机。
- en: “Solo Node” Blockchain
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “独立节点”区块链
- en: 'In theory, you could reconcile changes from many nodes with a single computer:
    a centralized server processing the order of transactions. Indeed, web applications
    such as Google Docs have sophisticated real-time engines that help them deal with
    conflicting changes made by multiple users, some of whom may be on faster connections
    than others, and still others who may be editing a document offline.As you’ll
    see when you spin up your own blockchain in Chapter [9](A433414_1_En_9_Chapter.html),
    it’s possible to use the Ethereum protocol with a single machine. It will process
    your transactions just fine, as long as one or more nodes are mining on the chain.
    But if someone knocks that machine offline, your chain is inaccessible, and transactions
    stop going through.For this reason, despite Ethereum being free and open software,
    the necessity for many, many nodes to create a resilient network causes developers
    to converge and work (for the most part) as one community, on a small number of
    public chains.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，你可以用一台单独的计算机来调和来自多个节点的更改：一个集中式服务器处理交易顺序。实际上，诸如 Google Docs 等 Web 应用程序拥有复杂的实时引擎，帮助它们处理多个用户所做的冲突更改，其中一些用户可能连接速度更快，还有些用户可能在离线编辑文档。当你在第
    [9](A433414_1_En_9_Chapter.html) 章中启动自己的区块链时，你会发现可以使用以太坊协议与一台单独的计算机。只要有一个或多个节点在链上进行挖矿，它就会很好地处理你的交易。但是，如果有人将该计算机断开网络，你的链就无法访问，交易也会停止进行。因此，尽管以太坊是免费和开放的软件，但许多节点创建一个弹性网络的必要性导致开发人员趋同，并且（在很大程度上）作为一个社区，在一小部分公共链上工作。
- en: Distributed Security
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式安全
- en: The distributed nature of the Ethereum Virtual Machine, and the fact that it
    is composed of many nodes around the world, means that it must be purpose-built
    to solve the diff-matching problem that can arise when there are many near-simultaneous
    changes to the same database, from many users, all over the world.[⁵](#Fn5)Indeed,
    solving this problem in a verifiable and trustworthy way is the purpose of the
    EVM as well as the Bitcoin virtual machine. The EVM’s resilience and security
    arise from the large number of machines mining on the network, incentivized by
    the earning of fees denominated in ether or bitcoins. We’ll go over this briefly
    before diving into a full explanation in Chapter [6](A433414_1_En_6_Chapter.html).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机的分布式特性，以及由世界各地的许多节点组成的事实，意味着它必须被专门构建以解决当有许多近乎同时的更改发生在来自世界各地的许多用户对同一数据库的情况下可能出现的差异匹配问题。的确，在一个可验证和可信赖的方式解决这个问题是
    EVM 以及比特币虚拟机的目的。EVM 的韧性和安全性来自于在网络上进行挖矿的大量机器，这些机器被激励通过以以太币或比特币计价的费用来赚取收益。在我们深入解释之前，我们将简要介绍一下这个问题，在第
    [6](A433414_1_En_6_Chapter.html) 章中进行全面解释。
- en: Mining’s Place in the State Transition Function
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挖矿在状态转换函数中的位置
- en: 'Mining is the process of using computational work to nominate a block—that
    miner’s version of recent transaction history—as the canonical block for this,
    the most recent block on the chain. How exactly this happens is the subject of
    Chapter [6](A433414_1_En_6_Chapter.html), but the point of bringing it up now
    is to show that mining incentive awards take place as part of the state-transition
    function. Mining achieves the consensus required to make valid state changes,
    and the miners are paid for contributing to the consensus building. This is how
    ether and bitcoin are “created.”Recall that each time a new block is created,
    it is downloaded, processed, and validated by node on the network. During processing,
    each node executes all the transactions contained therein. This is a long process
    with many steps, but we’ll summarize. Written out in English, the Ethereum state
    transition function can be defined as the following six steps.[⁶](#Fn6) For each
    transaction in a block, the EVM performs the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 挖矿是使用计算工作来提名一个区块——即最近交易历史的矿工版本——作为链上最新区块的规范区块的过程。究竟如何实现这一点是第[6](A433414_1_En_6_Chapter.html)章的主题，但现在提出这一点的目的是为了显示挖矿激励奖励是作为状态转换函数的一部分而发生的。挖矿实现了达成共识所需的条件，矿工们因为为共识建立做出贡献而得到报酬。这就是以太和比特币是如何“创造”的。回顾一下，每次创建新区块时，它都会被网络上的节点下载、处理和验证。在处理过程中，每个节点执行其中包含的所有交易。这是一个漫长的过程，有许多步骤，但我们会概括。以英文写出来，以太坊状态转换函数可以定义为以下六个步骤。[⁶](#Fn6)
    对于块中的每个交易，EVM执行以下操作：
- en: 1.Check whether the transaction is in the right format. Does it have the right
    number of values? Is the signature valid? Does the nonce—a transaction counter—on
    the transaction match the nonce on the account? If any of these are missing, return
    an error.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查交易是否以正确格式存在。它是否具有正确数量的值？签名是否有效？交易上的nonce——交易计数器——是否与账户上的nonce匹配？如果有任何缺失，则返回错误。
- en: 2.Calculate the transaction fee by multiplying the amount of work required (represented
    by STARTGAS, as you’ll see in table [3-1](#Tab1)) by the gas price. Then deduct
    the fee from the user’s account balance, and increment the sender’s nonce (transaction
    counter). If there’s not enough ether in the account, return an error.Table 3-1.Costs
    of Common EVM Operations
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算交易费用，将所需工作量（由STARTGAS表示，如表[3-1](#Tab1)所示）乘以燃气价格。然后从用户的账户余额中扣除费用，并增加发送方的nonce（交易计数器）。如果账户中的以太不足，则返回错误。表3-1.常见EVM操作的成本
- en: '| Operation Name | Gas Cost | Description |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 操作名称 | 燃气成本 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| step | 1 | Default amount per execution cycle |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| step | 1 | 每个执行周期的默认量 |'
- en: '| stop | 0 | Free |'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| stop | 0 | 免费 |'
- en: '| suicide | 0 | Free |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| suicide | 0 | 免费 |'
- en: '| sha3 | 20 | SHA-3 hash function |'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| sha3 | 20 | SHA-3哈希函数 |'
- en: '| sload | 20 | Gets from permanent storage |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| sload | 20 | 从永久存储中获取 |'
- en: '| sstore | 100 | Puts into permanent storage |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| sstore | 100 | 存储到永久存储 |'
- en: '| balance | 20 | Queries account balance |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| balance | 20 | 查询账户余额 |'
- en: '| create | 100 | Contract creation |'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| create | 100 | 合同创建 |'
- en: '| call | 20 | Initiating a read-only call |'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| call | 20 | 发起只读调用 |'
- en: '| memory | 1 | Every additional word when expanding memory |'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| memory | 1 | 扩展内存时的每个额外字 |'
- en: '| txdata | 5 | Every byte of data or code for a transaction |'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| txdata | 5 | 每个交易的数据或代码的每个字节 |'
- en: '| transaction | 500 | Base fee transaction |'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| transaction | 500 | 基础费用交易 |'
- en: '| contract creation | 53,000 | Changed in homestead from 21,000 |'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| contract creation | 53,000 | 从 Homestead 中的 21,000 改变 |'
- en: 3.Initialize the gas payment; from this point forward, take off a certain amount
    of gas per byte processed in the transaction.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.初始化 gas 支付；从这一点开始，每处理一个交易的字节就会消耗一定数量的 gas。
- en: 4.Transfer the value of the transaction—the amount being sent—to the receiving
    account.If the receiving account doesn’t exist yet, it will be created. (Offline
    Ethereum nodes can generate addresses, so the network may not hear of a given
    address until a transaction takes place.)If the receiving address is a contract
    address, run the contract’s code. This continues either until the code finishes
    executing or the gas payment runs out.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4.将交易的价值——发送的金额——转移到接收账户。如果接收账户尚不存在，则将创建它。（离线以太坊节点可以生成地址，因此网络可能在交易发生之前不会知道特定地址。）如果接收地址是合约地址，则运行合约的代码。这将继续执行，直到代码执行完毕或
    gas 用尽。
- en: 5.If the sending account doesn’t have enough ether to complete the transaction,
    or the gas runs out, all changes from this transaction are rolled back. A caveat
    are the fees, which still go to the miner and are not refunded.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5.如果发送账户没有足够的以太完成交易，或者 gas 用尽，那么此交易的所有更改都将被回滚。一个例外是费用，仍然会发送给矿工，而不会退还。
- en: 6.If the transaction throws an error for any other reason, refund the gas to
    the sender and send any fees associated with gas used to the miner.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6.如果交易因其他原因出错，将 gas 退还给发送者，并将任何与 gas 使用相关的费用发送给矿工。
- en: NoteSmart contract data is executed in Step 4 of the state transition function,
    as described above.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：智能合约数据在状态转换函数的第 4 步中执行，如上所述。
- en: Renting Time on the EVM
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在以太坊虚拟机上购买时间
- en: As you may be gathering, the EVM is a rather deliberate machine, albeit far
    more trustworthy and reliable than any network we have today. For every instruction
    the EVM executes, there must be a cost associated, to ensure the system isn’t
    jammed up by useless spam contracts.Every time an instruction executes, an internal
    counter keeps track of the fees incurred, which are charged to the user. Each
    time the user initiates a transaction, that user’s wallet reserves a small portion
    (selected by the user) to pay these fees.After a transaction has been broadcast
    to the network from a given node—let’s say Bob sends Alice some ether from his
    computer—the network propagates the transaction around so that all the nodes can
    include it in the latest block.Believe it or not, the explanation so far in this
    chapter barely scrapes the surface of the EVM’s internals. You’ll learn more in
    Chapters [5](A433414_1_En_5_Chapter.html) and [6](A433414_1_En_6_Chapter.html).
    For now, it will be useful to break down the fees, their role in transaction execution,
    and their impact on development patterns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，以太坊虚拟机（EVM）是一台非常谨慎的机器，尽管比起今天我们所拥有的任何网络，它更加值得信赖和可靠。对于每个以太坊虚拟机执行的指令，都必须有一个相关的成本，以确保系统不会被无用的垃圾合约堵塞。每次执行指令时，内部计数器会跟踪产生的费用，并将其收取给用户。每当用户发起交易时，该用户的钱包会预留一小部分（由用户选择）用于支付这些费用。在从给定节点向网络广播了交易之后——比如说，Bob从他的电脑向Alice发送了一些以太币——网络会将该交易传播到各个节点，以便它们都能将其包含在最新的区块中。信不信由你，到目前为止，在本章中所解释的内容几乎只是触及了以太坊虚拟机内部的表面。你将在[第
    5 章](A433414_1_En_5_Chapter.html)和[第 6 章](A433414_1_En_6_Chapter.html)中学到更多。现在，拆解费用、它们在交易执行中的作用以及对开发模式的影响将是有用的。
- en: Hello, Gas
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，Gas
- en: Gas is a unit of work used to measure how computationally expensive an Ethereum
    operation will be. Gas costs are paid with small amounts of ether.The purpose
    of gas is twofold. First, it guarantees a prepaid reward for the miners that execute
    code and secure the network, even if the execution fails for some reason. Second,
    it works around the halting problem and ensures that execution can’t go on longer
    than the time it prepaid for.Gas is a unit of work; it’s not a subcurrency, and
    you can’t hold or hoard it. It simply measures how much effort each step of a
    transaction will be, in computational terms.To be able to pay for gas costs ,
    you simply need to add ether to your account. You don’t have to acquire it separately;
    there is no gas token. Every operation possible on the EVM has an associated gas
    cost.NoteIt’s the combination of total gas used multiplied by gas price paid that
    results in the total fee accrued by a given transaction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Gas是一个用来衡量以太坊操作的计算成本的单位。Gas成本是用少量的以太币支付的。Gas的目的有两个。首先，它为执行代码和保护网络的矿工们提供了预付的奖励，即使执行由于某种原因失败。其次，它解决了停机问题，并确保执行时间不会超过预付的时间。Gas是一个工作单位；它不是一种子货币，你不能持有或囤积它。它只是衡量每个交易步骤在计算方面需要付出的努力有多大。为了能够支付Gas成本，你只需向你的账户添加以太币即可。你不必单独获取它；没有Gas代币。EVM上的每个操作都有一个相关的Gas成本。注意：总Gas使用量与支付的Gas价格相乘，将得到给定交易所产生的总费用。
- en: Why Is Gas So Important?
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么Gas如此重要？
- en: Gas costs ensure that computation time on the network is appropriately priced.
    This works differently in Bitcoin, where the fee is based on the size of the transaction
    in kilobytes. Because Solidity code can be arbitrarily complex, a short snippet
    of instructions could generate a lot of computational work, whereas a long snippet
    could generate less. That’s why fees in the EVM are based on the amount of work
    being done, not on the size of the transaction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Gas成本确保了网络上的计算时间得到了适当的定价。这在比特币中的工作方式不同，那里的费用是基于交易大小（以千字节计）的。由于Solidity代码可以是任意复杂的，一个简短的指令片段可能会生成大量的计算工作，而一个长的片段可能会生成较少的工作。这就是为什么EVM中的费用是基于正在进行的工作量而不是交易大小的原因。
- en: Why Isn’t Gas Priced in Ether?
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么Gas不以以太币计价？
- en: Because ether is traded publicly on cryptocurrency exchanges, it is subject
    to speculative periods of inflation and deflation. Using the gas unit of account
    for computational work is helpful because it separates the price of computation
    from the highly volatile price of the ether token.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为以太币在加密货币交易所上公开交易，所以受到投机性通货膨胀和紧缩周期的影响。使用Gas作为计算工作的单位很有帮助，因为它将计算价格与以太币代币的高度波动的价格分开。
- en: Fees as Regulation
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为监管的费用
- en: As you’ll see in Chapter [7](A433414_1_En_7_Chapter.html), networks such as
    Bitcoin and Ethereum use economic incentives and disincentives to render certain
    attack vectors moot. Fees fall into the category of disincentive.To begin with,
    it’s important to recognize that the operation of an Ethereum node represents
    some risk. There’s the cost of the hardware, plus the time and energy of the operator,
    and the network’s cost of downloading and verifying the proof of work and the
    block header. Thus it makes sense that a transaction fee be put in place to prevent
    pranksters from wasting the network’s capacity.Blocks that consume excessive amounts
    of gas are a big danger in Ethereum. They can take a long time to propagate because
    of their sheer size. How the system adapts to the demands of users, who may have
    legitimate uses for large smart contracts, will become clear later on in this
    chapter, and in Chapter [6](A433414_1_En_6_Chapter.html). The protocol helps cut
    off late blocks using various methodologies we’ll explore in Chapter [6](A433414_1_En_6_Chapter.html),
    and places a floating cap on operations, which currently sits at 65,536 per block.[⁷](#Fn7)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第[7](A433414_1_En_7_Chapter.html)章中所看到的，比特币和以太坊等网络使用经济激励和惩罚来使某些攻击向量无效。费用属于惩罚类别。首先，重要的是要认识到以太坊节点的运行代表了一定的风险。硬件成本、运营者的时间和精力以及网络下载和验证工作证明和区块头的成本都在其中。因此，设立交易费用是有道理的，以防止恶作剧者浪费网络的容量。在以太坊中，消耗过多气体的区块是一个很大的危险。由于它们的体积庞大，它们可能需要很长时间才能传播。系统如何适应用户的需求（用户可能对大型智能合约有合法的用途）将在本章后面以及第[6](A433414_1_En_6_Chapter.html)章中变得清楚。协议通过各种方法来截断晚到的区块，我们将在第[6](A433414_1_En_6_Chapter.html)章中探讨这些方法，并对操作进行浮动限制，目前每个区块的操作数为65,536个。[⁷](#Fn7)
- en: Working with Gas
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理气体
- en: In this section, you’ll explore the details of working with gas and then see
    how gas relates to scaling the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索与气体的工作细节，然后了解气体与系统扩展的关系。
- en: Gas Specifics
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 气体特性
- en: 'Let’s review some details about working with gas:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些关于处理气体的细节：
- en: Unfortunately, the term gas creates some confusion. Every transaction requires
    a STARTGAS value. This value is referred to as gasLimit in the Yellow Paper and
    often just as gas in Geth and Web3.js.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，术语“gas”造成了一些混淆。每个交易都需要一个STARTGAS值。这个值在黄皮书中被称为gasLimit，在Geth和Web3.js中通常被简称为gas。
- en: Every transaction also requires the user to specify a gas price.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个交易还需要用户指定一个气价。
- en: The amount stipulated in STARTGAS, multiplied by the gas price, is held in escrow
    while your transaction executes.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行交易时，由STARTGAS规定的数量乘以气价被存入托管。
- en: If the gas price you offer for a transaction is too low, nodes won’t process
    your transaction, and it will sit unprocessed on the network.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为交易提供的气价太低，节点将不会处理你的交易，它将无法处理在网络上。
- en: If your gas price is acceptable to the network, but the gas cost runs over what’s
    available in your wallet balance, the transaction fails and is rolled back; this
    failed transaction is recorded to the blockchain, and you get a refund of any
    STARTGAS not used in the transaction.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的Gas价格对网络来说是可以接受的，但Gas成本超出了您钱包余额中可用的数量，那么交易将失败并被回滚；这笔失败的交易将被记录到区块链中，并且您将获得未在交易中使用的任何STARTGAS的退款。
- en: Using excessive STARTGAS does not cause your transactions to be processed more
    quickly, and in some cases may make your transaction less appealing to miners.[⁸](#Fn8)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过多的STARTGAS并不能使您的交易更快处理，在某些情况下，可能会使您的交易对矿工不那么有吸引力。[⁸](#Fn8)
- en: How Gas Relates to Scaling the System
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gas与系统扩展的关系
- en: If you send a computationally difficult set of instructions to the EVM, the
    only person this hurts is you. The work will spend your ether, and stop when the
    ether you allocated to the transaction runs out. It has no effect on anyone else’s
    transactions. There is no way to jam up the EVM without paying a lot, in the form
    of transaction fees, to do it.Scaling is handled in a de facto way through the
    gas fee system. Miners are free to choose the transactions that pay the highest
    fee rates, and can also choose the block gas limit collectively. The gas limit
    determines how much computation can happen (and how much storage can be allocated)
    per block.In this way, the price of computation on the EVM stays flexible and
    responsive to the demand of the users of the system, as well as the costs incurred
    by the miners who do the important work of processing transactions, maintaining
    hardware, and paying electricity bills.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向EVM发送了一组计算难度很大的指令，受影响的仅是您自己。这项工作将花费您的以太币，并在您分配给交易的以太币用尽时停止。它不会影响其他人的交易。除非支付大量的交易费用，否则没有办法阻止EVM，以太币将以交易费用的形式支付。系统的扩展是通过Gas费用系统以事实方式处理的。矿工可以自由选择支付最高费率的交易，并且还可以集体选择区块的Gas上限。Gas限制确定每个区块可以发生多少计算（以及可以分配多少存储）。通过这种方式，EVM上的计算价格保持灵活，并能对系统用户的需求以及处理交易、维护硬件和支付电费等重要工作所产生的成本作出响应。
- en: Accounts, Transactions, and Messages
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 账户、交易和消息
- en: 'Recall from Chapter [2](A433414_1_En_2_Chapter.html) that Ethereum has two
    types of accounts:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](A433414_1_En_2_Chapter.html)中我们回顾了以太坊有两种类型的账户：
- en: Externally owned accounts
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部拥有账户
- en: Contracts accounts
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约账户
- en: Let’s look more deeply into exactly what each account type can do.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解每种账户类型可以做些什么。
- en: Externally Owned Accounts
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部拥有账户
- en: 'An externally owned account (EOA) is also known as an account controlled by
    a pair of private keys, which may be held by a person or an external server. These
    accounts cannot hold EVM code. Characteristics of an EOA include the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 外部拥有账户（EOA）也称为由一对私钥控制的账户，这些私钥可以由个人或外部服务器持有。这些账户不能持有EVM代码。EOA的特征包括以下内容：
- en: Contains a balance of ether
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含以太币余额
- en: Capable of sending transactions
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够发送交易
- en: Controlled by the account’s private keys
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受账户私钥控制
- en: Has no code associated with it
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有与之关联的代码
- en: A key/value database contained in each account, where keys and values are both
    32-byte strings
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个账户中包含的键/值数据库，其中键和值都是 32 字节的字符串
- en: Contract Accounts
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合同账户
- en: 'Contract accounts are not controlled by humans. They store instructions and
    are activated by external accounts or other contract accounts. Contract accounts
    have the following characteristics:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 合同账户不受人类控制。它们存储指令，并由外部账户或其他合同账户激活。合同账户具有以下特征：
- en: Have an ether balance
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有以太币余额
- en: Hold some contract code in memory
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中保存一些合同代码
- en: Can be triggered by humans (sending a transaction) or other contracts sending
    a message
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以由人类触发（发送交易）或其他合同发送消息来触发
- en: When executed, can perform complex operations
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行时可以执行复杂的操作
- en: Have their own persistent state and can call other contracts
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有自己的持久状态，并且可以调用其他合同
- en: Have no owner after being released to the EVM
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被释放到 EVM 后不再有所有者
- en: A key/value database contained in each account, where keys and values are both
    32-byte strings
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个账户中包含的键/值数据库，其中键和值都是 32 字节的字符串
- en: Transactions and Messages
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易和消息
- en: 'Transactions come from external accounts, which are usually controlled by human
    users. It’s a way for an external account to submit instructions to the EVM to
    perform some operation. In other words, it’s a way for an external account to
    get a message into the system. In computing terminology, a message is a chunk
    of data containing instructions. Programmers can think of messages as function
    calls.A transaction in the EVM is a cryptographically signed data package storing
    a message (as described previously), which tells the EVM to transfer ether, create
    a new contract, trigger an existing one, or perform some calculation. Contract
    addresses can be the recipients of transactions, just like users with external
    accounts. Recall the discussion of cryptographic communication from Chapter [2](A433414_1_En_2_Chapter.html),
    in which we discussed encrypted communications: a transaction is like a private
    communication between two users in an unsecured network, who are nevertheless
    able to “send” value to each other.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 交易来自外部账户，这些账户通常由人类用户控制。这是外部账户向 EVM 提交指令以执行某些操作的一种方式。换句话说，这是外部账户将消息发送到系统的一种方式。在计算术语中，消息是包含指令的数据块。程序员可以将消息视为函数调用。EVM
    中的交易是一个包含加密签名的数据包，存储着一个消息（如前文所述），告诉 EVM 转移以太币、创建新合同、触发现有合同或执行某些计算。合同地址可以是交易的接收方，就像具有外部账户的用户一样。回顾一下第
    [2](A433414_1_En_2_Chapter.html) 章中关于加密通信的讨论：交易就像是在不安全的网络中两个用户之间的私密通信，尽管如此，他们仍能向彼此“发送”价值。
- en: Characteristics of Transactions
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易的特征
- en: 'Transactions contain the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 交易包含以下内容：
- en: A recipient address; specifying no recipient (and attaching smart contract data)
    is the method for uploading new smart contracts. As you’ll see, a contract address
    is returned so that the user knows where to access this contract in the future.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者地址；指定没有接收者（并附带智能合约数据）是上传新智能合约的方法。正如您将看到的，合同地址会返回，以便用户知道将来在哪里访问该合同。
- en: A signature identifying the sender
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识发送者的签名
- en: A value field showing the amount being sent
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示发送数量的值字段
- en: An optional data field, for a message (if this is being sent to a contract address)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的数据字段，用于消息（如果将其发送到合同地址）
- en: A STARTGAS value, indicating the maximum number of computational steps the transaction
    are prepaid
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个STARTGAS值，指示交易可以预付的最大计算步骤数
- en: A GASPRICE value, representing the fee the sender is willing to pay for gas
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GASPRICE值，表示发送者愿意支付的燃气费用
- en: Characteristics of Messages
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息的特性
- en: 'A message is a chunk of data sent by a contract to another contract (never
    to or from a human). Messages are virtual objects that are never serialized and
    exist only in the EVM. When a miner is paid in the Ethereum network, this is accomplished
    by way of a message to increment the miner’s payment address; it does not constitute
    a transaction.A message is sent when a contract is being run by the EVM, and it
    executes the CALL or DELEGATECALL opcodes. You will learn about opcodes in the
    next section of this chapter.NoteBecause the Ethereum network is not connected
    to the HTTP Web, it does not use HTTP methods. Instead, it uses operation codes
    traditionally used to pass messages within the same localhost. This is what is
    meant by descriptions which include language such as “one global machine.” Bitcoin
    works similarly.Messages are sent to other contract accounts, which in turn run
    the code enclosed in the message. Thus, contracts can have relationships with
    each other.A message contains the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是合同发送到另一个合同的数据块（从不与人类之间发送或发送）。消息是虚拟对象，永远不会被序列化，仅存在于EVM中。当矿工在以太坊网络中获得支付时，通过消息的方式来增加矿工的支付地址；这并不构成一笔交易。当通过EVM运行合同时，发送消息并执行CALL或DELEGATECALL操作码。您将在本章的下一部分学习有关操作码的知识。注意因为以太坊网络与HTTP
    Web未连接，所以不使用HTTP方法，而是传统上使用操作码来传递消息，这是“全球唯一计算机”的描述。比特币工作方式类似。消息被发送到其他合同帐户，这些帐户随后运行消息中包含的代码。因此，合同可以彼此之间建立关系。消息包含以下内容：
- en: The sender address of the message
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息的发送者地址
- en: The recipient address of the message
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息的接收者地址
- en: The value field (indicating how much ether, if any, is being sent)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值字段（指示是否发送了多少以太币）
- en: An optional data field (containing input data for the contract)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的数据字段（包含合同的输入数据）
- en: A STARTGAS value limiting the amount of gas the message can use
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个STARTGAS值，限制消息可以使用的燃气量
- en: Estimating Gas Fees for Operations
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为操作估算燃气费
- en: Transactions need to provide enough STARTGAS to cover all computation and storage.
    However, but there are many operations in the EVM, and it’s hard to memorize what
    each one costs.Table [3-1](#Tab1) shows the costs of some common EVM operations.An
    up-to-date Google Doc containing the costs of various EVM operations can be found
    at [http://gas.eth.guide](http://gas.eth.guide) .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 交易需要提供足够的 STARTGAS 来 cover 所有计算和存储。然而，EVM 中有许多操作，很难记住每个操作的花费。表[3-1](#Tab1)显示了一些常见
    EVM 操作的成本。可在 [http://gas.eth.guide](http://gas.eth.guide) 找到包含各种 EVM 操作成本的最新 Google
    文档。
- en: Opcodes in the EVM
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EVM 中的操作码
- en: As you’ll see, some of these operations can be called as methods. One of the
    most confusing things about the blockchain paradigm is that it combines technical
    conventions from several domains of computer science and networking. One example
    is Ethereum’s (and Bitcoin’s) use of opcodes, or operation codes. Table [3-2](#Tab2)
    shows all the opcodes available on the EVM, and their respective functions.Table
    3-2.This is a complete list of EVM opcodes
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，其中一些操作可以作为方法调用。区块链范式最令人困惑的事情之一是它将来自计算机科学和网络几个领域的技术约定相结合。一个例子是以太坊（和比特币）对操作码的使用。表[3-2](#Tab2)显示了在
    EVM 上可用的所有操作码及其各自的功能。表 3-2.这是 EVM 操作码的完整列表
- en: '| 0s: Stop and Arithmetic Operations |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 0s：停止和算术操作 |'
- en: '| 0x00 | STOP | Halts execution. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 0x00 | STOP | 终止执行。 |'
- en: '| 0x01 | ADD | Addition operation. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | ADD | 加法操作。 |'
- en: '| 0x02 | MUL | Multiplication operation. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | MUL | 乘法操作。 |'
- en: '| 0x03 | SUB | Subtraction operation. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 0x03 | SUB | 减法操作。 |'
- en: '| 0x04 | DIV | Integer division operation. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | DIV | 整数除法操作。 |'
- en: '| 0x05 | SDIV | Signed integer. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 0x05 | SDIV | 有符号整数。 |'
- en: '| 0x06 | MOD | Modulo. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 0x06 | MOD | 模。 |'
- en: '| 0x07 | SMOD | Signed modulo. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 0x07 | SMOD | 有符号模数。 |'
- en: '| 0x08 | ADDMOD | Modulo. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 0x08 | ADDMOD | 模。 |'
- en: '| 0x09 | MULMOD | Modulo. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0x09 | MULMOD | 模。 |'
- en: '| 0x0a | EXP | Exponential operation. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0x0a | EXP | 指数运算。 |'
- en: '| 0x0b | SIGNEXTEND | Extend length of 2s (complement signed integer). |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 0x0b | SIGNEXTEND | 扩展 2 的长度（补码有符号整数）。 |'
- en: '| 10s: Comparison and Bitwise Logic Operations |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 10s：比较和位逻辑操作 |'
- en: '| 0x10 | LT | Lesser-than comparison. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | LT | 小于比较。 |'
- en: '| 0x11 | GT | Greater-than comparison. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 0x11 | GT | 大于比较。 |'
- en: '| 0x12 | SLT | Signed less-than comparison. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 0x12 | SLT | 有符号小于比较。 |'
- en: '| 0x13 | SGT | Signed greater-than comparison. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 0x13 | SGT | 有符号大于比较。 |'
- en: '| 0x14 | EQ | Equality comparison. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 0x14 | EQ | 等于比较。 |'
- en: '| 0x15 | ISZERO | Simple NOT operator. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0x15 | ISZERO | 简单的 NOT 运算符。 |'
- en: '| 0x16 | AND | Bitwise AND operation. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 0x16 | AND | 按位与操作。 |'
- en: '| 0x17 | OR | Bitwise OR operation. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 0x17 | OR | 按位或操作。 |'
- en: '| 0x18 | XOR | Bitwise XOR operation. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0x18 | XOR | 按位异或操作。 |'
- en: '| 0x19 | NOT | Bitwise NOT operation. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0x19 | NOT | 按位 NOT 操作。 |'
- en: '| 0x1a | BYTE | Retrieve single byte from word. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 0x1a | BYTE | 从字中检索单个字节。 |'
- en: '| 20s: SHA3 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 20s：SHA3 |'
- en: '| 0x20 | SHA3 | Compute Keccak-256 hash. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 0x20 | SHA3 | 计算 Keccak-256 哈希。 |'
- en: '| 30s: Environmental Information |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 30s：环境信息 |'
- en: '| 0x30 | ADDRESS | Get address of currently executing account. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 0x30 | ADDRESS | 获取当前执行账户的地址。 |'
- en: '| 0x31 | BALANCE | Get balance of the given account. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 0x31 | BALANCE | 获取给定账户的余额。 |'
- en: '| 0x32 | ORIGIN | Get execution origination address. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 0x32 | ORIGIN | 获取执行起始地址。 |'
- en: '| 0x33 | CALLER | Get caller address. This is the address of the account directly
    responsible for this execution. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0x33 | CALLER | 获取调用者地址。这是直接负责此执行的账户的地址。 |'
- en: '| 0x34 | CALLVALUE | Get deposited value by the instruction/transaction responsible
    for this execution. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 0x34 | CALLVALUE | 获取执行此操作的指令/事务存入的值。 |'
- en: '| 0x35 | CALLDATALOAD | Get input data of current environment. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 0x35 | CALLDATALOAD | 获取当前环境的输入数据。 |'
- en: '| 0x36 | CALLDATASIZE | Get size of input data in current environment. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 0x36 | CALLDATASIZE | 获取当前环境中输入数据的大小。 |'
- en: '| 0x37 | CALLDATACOPY | Copy input data in current environment to memory. Pertains
    to the input data passed with the message call instruction or transaction. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 0x37 | CALLDATACOPY | 将当前环境中的输入数据复制到内存中。与消息调用指令或事务传递的输入数据有关。 |'
- en: '| 0x38 | CODESIZE | Get size of code running in current environment. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 0x38 | CODESIZE | 获取当前环境中运行的代码的大小。 |'
- en: '| 0x39 | CODECOPY | Copy code running in current environment to memory. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 0x39 | CODECOPY | 将当前环境中运行的代码复制到内存中。 |'
- en: '| 0x3a | GASPRICE | Get price of gas in current environment. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0x3a | GASPRICE | 获取当前环境中的气体价格。 |'
- en: '| 0x3b | EXTCODESIZE | Get size of an account’s code. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0x3b | EXTCODESIZE | 获取账户代码的大小。 |'
- en: '| 0x3c | EXTCODECOPY | Copy an account’s code to memory. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0x3c | EXTCODECOPY | 将账户的代码复制到内存中。 |'
- en: '| 40s: Block Information |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 40s: 块信息 |'
- en: '| 0x40 | BLOCKHASH | Get the hash of one of the 256 most recent complete blocks.
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 0x40 | BLOCKHASH | 获取最近 256 个完整块之一的哈希。 |'
- en: '| 0x41 | COINBASE | Get the block’s beneficiary address. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0x41 | COINBASE | 获取块的受益人地址。 |'
- en: '| 0x42 | TIMESTAMP | Get the block’s timestamp. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 0x42 | TIMESTAMP | 获取块的时间戳。 |'
- en: '| 0x43 | NUMBER | Get the block’s number. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 0x43 | NUMBER | 获取块的编号。 |'
- en: '| 0x44 | DIFFICULTY | Get the block’s difficulty. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 0x44 | DIFFICULTY | 获取块的难度。 |'
- en: '| 0x45 | GASLIMIT | Get the block’s gas limit. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 0x45 | GASLIMIT | 获取块的燃气限制。 |'
- en: '| 50s: Stack, Memory, Storage, and Flow Operations |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 50s: 堆栈、内存、存储和流操作 |'
- en: '| 0x50 | POP | Remove item from stack. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 0x50 | POP | 从堆栈中移除项目。 |'
- en: '| 0x51 | MLOAD | Load word from memory. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 0x51 | MLOAD | 从内存中加载字。 |'
- en: '| 0x52 | MSTORE | Save word to memory. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 0x52 | MSTORE | 将字保存到内存中。 |'
- en: '| 0x53 | MSTORE8 | Save byte to memory. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 0x53 | MSTORE8 | 将字节保存到内存中。 |'
- en: '| 0x54 | SLOAD | Load word from storage. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 0x54 | SLOAD | 从存储器中加载字。 |'
- en: '| 0x55 | SSTORE | Save word to storage. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 0x55 | SSTORE | 将字保存到存储器中。 |'
- en: '| 0x56 | JUMP | Alter the program counter. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 0x56 | JUMP | 更改程序计数器。 |'
- en: '| 0x57 | JUMPI | Conditionally alter the program counter. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 0x57 | JUMPI | 有条件地更改程序计数器。 |'
- en: '| 0x58 | PC | Get the value of the program counter prior to the increment.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 0x58 | PC | 获取增量前的程序计数器的值。 |'
- en: '| 0x59 | MSIZE | Get the size of active memory in bytes. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 0x59 | MSIZE | 获取活动内存的字节数。 |'
- en: '| 0x5a | GAS | Get the amount of available gas, including the corresponding
    reduction. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 0x5a | GAS | 获取可用气体量，包括相应的减少量。 |'
- en: '| 0x5b | JUMPDEST | Mark a valid destination for jumps. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 0x5b | JUMPDEST | 标记跳转的有效目的地。 |'
- en: '| 60s and 70s: Push Operations |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 60s and 70s: 推送操作 |'
- en: '| 0x60 | PUSH1 | Place 1-byte item on stack. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 0x60 | PUSH1 | 将1字节项目推送到堆栈上。 |'
- en: '| 0x61 | PUSH2 | Place 2-byte item on stack. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 0x61 | PUSH2 | 将2字节项目推送到堆栈上。 |'
- en: '| 0x7f | PUSH32 | Place 32-byte (full word) item on stack. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 0x7f | PUSH32 | 将32字节（全字）项目推送到堆栈上。 |'
- en: '| 80s: Duplication Operations |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 80s: 复制操作 |'
- en: '| 0x80 | DUP1 | Duplicate first stack item. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | DUP1 | 复制第1个堆栈项。 |'
- en: '| 0x81 | DUP2 | Duplicate second stack item. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 0x81 | DUP2 | 复制第二个堆栈项。 |'
- en: '| 0x8f | DUP16 | Duplicate 16th stack item. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 0x8f | DUP16 | 复制第16个堆栈项。 |'
- en: '| 90s: Exchange Operations |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 90s: 交换操作 |'
- en: '| 0x90 | SWAP1 | Exchange first and second stack items. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 0x90 | SWAP1 | 交换第1个和第2个堆栈项。 |'
- en: '| 0x91 | SWAP2 | Exchange first and third stack items. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 0x91 | SWAP2 | 交换第1个和第3个堆栈项。 |'
- en: '| 0x9f | SWAP16 | Exchange 1st and 17th stack items. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0x9f | SWAP16 | 交换第1个和第17个堆栈项。 |'
- en: '| a0s: Logging Operations |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| a0s: 日志操作 |'
- en: '| 0xa0 | LOG0 | Append log record with no topics. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 0xa0 | LOG0 | 追加没有主题的日志记录。 |'
- en: '| 0xa1 | LOG1 | Append log record with one topic. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0xa1 | LOG1 | 追加具有一个主题的日志记录。 |'
- en: '| 0xa4 | LOG4 | Append log record with four topics. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 0xa4 | LOG4 | 追加具有四个主题的日志记录。 |'
- en: '| f0s: System Operations |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| f0s: 系统操作 |'
- en: '| 0xf0 | CREATE | Create a new account with associated code. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 0xf0 | CREATE | 创建一个带有相关代码的新账户。 |'
- en: '| 0xf1 | CALL | Message-call into an account. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 0xf1 | CALL | 向一个账户发送消息调用。 |'
- en: '| 0xf2 | CALLCODE | Message-call into this account with alternative account’s
    code. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 0xf2 | CALLCODE | 使用另一账户的代码进行消息调用。 |'
- en: '| 0xf3 | RETURN | Halt execution returning output data. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 0xf3 | RETURN | 终止执行并返回输出数据。 |'
- en: '| 0xf4 | DELEGATECALL | Message-call into this account with an alternative
    account’s code, but persisting the current values for sender and value. Halt execution;
    mark for deletion. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 0xf4 | DELEGATECALL | 使用另一账户的代码进行消息调用，但保留当前的发送者和价值。终止执行；标记待删除。 |'
- en: '| 0xff | SUICIDE | Halt execution and register account for later deletion.
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 0xff | SUICIDE | 终止执行并注册账户以便以后删除。 |'
- en: 'In traditional web development, the rough equivalent of an opcode would be
    a HTTP verb, also known as an HTTP method. These include GET, POST, HEAD, OPTIONS,
    PUT, DELETE, TRACE, and CONNECT. These semantics are reliable and well-known.In
    Ethereum and Bitcoin, things work differently. Because the network is also a global
    machine, the “methods” you use to make calls across the network are just machine-language
    codes, of the ilk used inside an individual computer.The following is a full list
    of EVM opcodes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的网页开发中，操作码的粗略等价物将是HTTP动词，也称为HTTP方法。这些包括GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE和CONNECT。这些语义是可靠且众所周知的。在以太坊和比特币中，情况则有所不同。因为网络本质上也是一台全球性的机器，你在网络中进行调用的“方法”只是机器语言代码，就像在单个计算机内部使用的那样。以下是EVM操作码的完整列表：
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: 'This chapter has provided a more complete vision of the EVM as a database,
    and how changes are made to its state. Although the design rationale should be
    clearer to you now, there’s still a lot left to discuss. If you’d like to read
    more ancillary documentation about how the EVM executes programs, you’ll find
    a list of resources at [http://evm.eth.guide](http://evm.eth.guide) .The question
    to tackle next: what does it mean to run programs on the EVM? The answer lies
    in writing and deploying smart contracts, which work in concert to form distributed
    applications.As we discussed in this chapter, each contract has its own address
    with storage, where it can hold any arbitrary code. When a transaction hits this
    address, or the contract is called by another contract, its code springs to life
    inside every node on the EVM, leading to further message passing or ether transactions.The
    instructions that make up smart contracts are stored in EVM bytecode. But before
    they are compiled into bytecode, they are written by a human, in the Solidity
    programming language. That language is the subject of the next chapter.Footnotes[1](#Fn1_source)Forbes,
    “Central Banks Explore Blockchains: Why Digital Dollars, Pounds Or Yuan Could
    Be A Reality In 5 Years,” [www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8](http://www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8)
    , 2016.[2](#Fn2_source)Wikipedia, “Grace Hopper,” [https://en.wikipedia.org/wiki/Grace_Hopper](https://en.wikipedia.org/wiki/Grace_Hopper)
    , 2016.[3](#Fn3_source)Gavwood.com, “Ethereum: A Secure Decentralised Generalised
    Transaction Ledger”, [http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf)
    , 2016.[4](#Fn4_source)Bitcoin Wiki, “Controlled Supply,” [https://en.bitcoin.it/wiki/Controlled_supply](https://en.bitcoin.it/wiki/Controlled_supply)
    , 2016.[5](#Fn5_source)Google Code, “Diff-Match Patch,” [https://code.google.com/p/google-diff-match-patch/](https://code.google.com/p/google-diff-match-patch/)
    , 2016.[6](#Fn6_source)Ethereum White Paper, “Ethereum State Transition Function,”
    [https://​github.​com/​ethereum/​wiki/​wiki/​White-Paper#ethereum-state-transition-function](https://github.com/ethereum/wiki/wiki/White-Paper#ethereum-state-transition-function),
    2016.[7](#Fn7_source)GitHub, “Ethereum White Paper,” [https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)
    , 2016.[8](#Fn8_source)ConsenSys Media, “Ethereum, Gas, Fuel and Fees,” [https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6)
    , 2016.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章提供了关于以太坊虚拟机（EVM）作为数据库的更完整的视角，以及其状态如何更改。虽然设计理念现在应该对您更清晰了，但仍有很多内容需要讨论。如果您想阅读关于EVM如何执行程序的更多辅助文档，您可以在[http://evm.eth.guide](http://evm.eth.guide)找到资源列表。下一个需要解决的问题是：在EVM上运行程序意味着什么？答案在于编写和部署智能合约，这些合约协同工作形成分布式应用程序。正如我们在本章中讨论的，每个合约都有自己的地址和存储空间，可以容纳任意代码。当一个交易到达这个地址，或者合约被另一个合约调用时，其代码在EVM上的每个节点内部生效，导致进一步的消息传递或以太交易。构成智能合约的指令存储在EVM字节码中。但在编译成字节码之前，它们是由人类用Solidity编程语言编写的。这门语言将成为下一章的主题。脚注[1](#Fn1_source)Forbes，“央行探索区块链：为什么5年内数字美元、英镑或人民币可能成为现实”，[www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8](http://www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8)，2016。[2](#Fn2_source)Wikipedia，“格雷斯·霍波”，[https://en.wikipedia.org/wiki/Grace_Hopper](https://en.wikipedia.org/wiki/Grace_Hopper)，2016。[3](#Fn3_source)Gavwood.com，“以太坊：安全去中心化的广义交易分类帐”，[http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf)，2016。[4](#Fn4_source)Bitcoin
    Wiki，“受控供应”，[https://en.bitcoin.it/wiki/Controlled_supply](https://en.bitcoin.it/wiki/Controlled_supply)，2016。[5](#Fn5_source)Google
    Code，“Diff-Match Patch”，[https://code.google.com/p/google-diff-match-patch/](https://code.google.com/p/google-diff-match-patch/)，2016。[6](#Fn6_source)以太坊白皮书，“以太坊状态转换函数”，[https://​github.​com/​ethereum/​wiki/​wiki/​White-Paper#ethereum-state-transition-function](https://github.com/ethereum/wiki/wiki/White-Paper#ethereum-state-transition-function)，2016。[7](#Fn7_source)GitHub，“以太坊白皮书”，[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)，2016。[8](#Fn8_source)ConsenSys
    Media，“以太坊、燃气、燃料和费用”，[https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6)，2016。
