- en: © Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_3
  prefs: []
  type: TYPE_NORMAL
- en: 3. The EVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine (EVM) is a worldwide computer that anyone can use,
    for a small fee, payable in etherChris Dannen^(1 )(1)Brooklyn, New York, USAThe
    EVM is a single, global 256-bit “computer” in which all transactions are local
    on each node of the network, and executed in relative synchrony. It’s a globally
    accessible virtual machine, composed of lots of smaller computers.This giant computer,
    which anyone who has a node or wallet application can access, makes it simple
    to move arbitrarily large amounts of value (money) nearly instantly. Although
    anyone can use this global virtual machine, nobody can create counterfeit money
    inside it, or move funds without permission.If it seems wasteful to have the entire
    EVM, all those nodes, replicating the same transactions and slavishly maintaining
    the same state among thousands of individual computers, it’s important to have
    a proper basis for comparison for how financial services IT works today. The EVM
    is a paragon of simplicity and efficiency by comparison! More importantly, all
    that work isn’t for naught. In fact, as you’ll see in this chapter, it’s the evidence
    of this work that actually secures the network.
  prefs: []
  type: TYPE_NORMAL
- en: The Central Bank Network of Yesterday
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Today, corporations, insurers, universities, and other large institutions spend
    incredible amounts of money building and maintaining software services and IT
    for their own employees, and all their lines of business. Their various inflows
    and outflows are reconciled by large commercial banks, which have their own architecture,
    policy, codebase, databases, and layers of infrastructure. This, of course, is
    all on top of the Fedwire , which is the Federal Reserve’s real-time gross settlement
    system, or RTGS.The Federal Reserve is the central bank of the United States.
    The Fedwire is used by all Federal Reserve member banks to settle final payments
    in electronic US dollars. Any qualified state-chartered bank may become a member
    of the system by buying shares in it. Fedwire is owned and operated by the 12
    Federal Reserve Banks themselves, and although it does charge fees, it isn’t operated
    for profit.This system processes unthinkable amounts of US dollars every day—trillions
    upon trillions. It has some great features, too: there’s an overdraft system covering
    all existing and approved accounts, and the system is famously reliable, even
    for remittances overseas. It has been in operation in some form or another for
    about 100 years.As you can imagine, maintaining the security and reliability of
    the Fedwire software is extremely expensive. Yet, the cost of building and maintaining
    layers on top of an RTGS is higher still, owing to its security requirements.
    Ultimately, these costs are passed on to corporations who use commercial banks,
    in the form of fees. Those companies have their own IT infrastructure costs. In
    the aggregate these costs ultimately drive up prices and fees for consumers.'
  prefs: []
  type: TYPE_NORMAL
- en: What are Virtual Machines, Exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you were unfamiliar with virtual machines at the outset of this book, you’ve
    probably gathered by now that a virtual machine (VM) , in the Ethereum context,
    is one giant global computer composed of constituent nodes, which are themselves
    computers too.Generally speaking, a virtual machine is an emulation of a computer
    system by another computer system. These emulations are based on the same computer
    architectures as the target of their emulation, but they’re usually reproducing
    that architecture on different hardware than it may have been intended for. Virtual
    machines can be created with hardware, software, or both. In the case of Ethereum,
    it’s both. Rather than securely network thousands of discrete machines, as with
    Fedwire, Ethereum takes the approach of securely operating one very large machine
    that can encompass the whole Earth.As you’ll see from the long list of Ethereum
    clients for various operating systems, the EVM is a collective emulation being
    run on thousands of machines that—on an individual level—may be running any one
    of dozens of versions of Windows, Linux, ethOS, and macOS (more about ethOS in
    Chapter [6](A433414_1_En_6_Chapter.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The Role of the Ethereum Protocol in Banking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s beyond the scope of this book to posit whether blockchain-based systems
    are appropriate for use by, or are indeed the replacement for, sovereign central
    banks. It’s much more likely that central banks themselves will adopt the technology.
    The commerical banks are certainly interested; you’ll find more information about
    the banks and enterprises involved in Ethereum development in Chapter [11](A433414_1_En_11_Chapter.html).The
    Fedwire system is a settlement system with a user experience tailored to state-chartered
    banks and their operators. It makes little or no concern for the end user of a
    retail bank, for example; that’s the job of the retail bank.Software developers
    will recognize Fedwire as a “platform for banks.” What the bank chooses to build
    on top of Fedwire (the customer experience, the online banking tools, the brick-and-mortar
    branches, the financial products, the cross-selling) is what distinguishes it
    from other banks on the Fedwire system.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone Can Make a Banking Platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ethereum is far more generalized. It allows anyone to spin up a network with
    as good or better security and reliability than Fedwire, and with the ability
    to make secure value transfers nearly instantly. But this is only where Ethereum
    starts. Developers can build any sort of financial products or business logic
    they want on top of this secure ledger, with automated and immutable scripts,
    and without needing to pay the overheads dumped on them by the traditional centralized
    hosting and banking infrastructure.But does it scale to the speed and size of
    a system like Fedwire? The answer is, yes, it can, but this will take several
    years. There are no direct or fixed limit neither for transaction sizes or block
    sizes. In Bitcoin, the size of the block is limited to 1MB, which works out to
    about 7 transactions per second. In Ethereum these limits increase and decrease
    in accordance with demand and network capacity.However, this does not mean that
    blocks can be unlimited size. Recall that units of work in the Ethereum network
    are priced in gas. Thus, larger, more complex smart contracts cost more gas to
    store and execute. The maximum amount of gas which can be spent per block is variable,
    but there is a maximum. Theoretically, one large transaction could consume the
    entire gas limit of a single block. But if there is continuous demand for higher
    gas limits, the system will increase the gas limit per block in increments of
    0.09 percent. (For more detail on how this works, see the Ethereum Yellow Paper,
    equations 40-42.) As of this writing, the gas limit is 4,041,325 gas per block.What
    does this mean for the financial services industry? Certainly not doom, but perhaps
    some unexpected competition. The impact could be an unbundling of banking services
    into ever smaller brands as the public Ethereum chain scales and is capable of
    processing more transactions, faster and faster. Laura Shin, author and host of
    the blockchain-centric podcast Unchained, interviewed Adam Ludwin of San Francisco
    blockchain startup Chain in 2016 and wrote this:'
  prefs: []
  type: TYPE_NORMAL
- en: As for who owns the network, in the current system, if you go to Chase to deposit
    $50 cash, Chase holds that money, which was issued by the Federal Reserve, on
    its network. But Ludwin said you could imagine, instead of banks running the network,
    Fedwire, the current system for electronically settling payments between member
    banks, being reconstructed on a blockchain for which banks hold keys to make transfers.That
    could then lead to nonfinancial institutions being custodians of such currency.
    “With small enough amounts, you don’t need a bank,” said Ludwin. “Could Google,
    could Apple, could Facebook be holding small amounts of digital cash? Does that
    change the model of who a custodian is or could be? And the answer is yes.” It
    could also open up more avenues for peer-to-peer lending, reducing consumers’
    reliance on banks for loans. [¹](#Fn1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What the EVM Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, the EVM may be coming into focus: a generalized, secure, ownerless
    virtual machine that offers cheap Fedwire-like functionality with a bunch of other
    magic on top. How exactly does it do this?The EVM can run arbitrary computer programs
    (the smart contracts mentioned in Chapter [1](A433414_1_En_1_Chapter.html)) written
    in the Solidity language. These programs, given a particular input, will always
    produce the output the same way, with the same underlying state changes. This
    makes Solidity programs fully deterministic and guaranteed to execute, provided
    you’ve paid enough for the transaction; but we’ll talk about paying for gas later
    in this chapter.Solidity programs are capable of expressing all tasks accomplishable
    by computers, making them theoretically Turing complete. That means that the entire
    distributed network, every node, performs every program executed on the platform.
    When one user uploads a smart contract through their Ethereum node, it is included
    in the latest block and propagated around the network, where it is stored on every
    other node in the network.As we’ve discussed already, it’s the job of each and
    every node in the EVM to run the same code, as part of the block processing protocol.
    The nodes go through the block they are process and run any code enclosed within
    the transactions. Each node does this independently; it is not only highly parallelized,
    but highly redundant.Despite all appearances, this is an efficient way to balance
    a global ledge r in a trustworthy way. It’s important to remember just how much
    money, power, and human energy is spent for each bank everywhere to cobble together
    its own unique IT system or cocktail of systems for each of its lines of business.
    In an Ethereum-based banking system, all users (whether corporations or customers)
    get direct access to the same Fedwire-like system at no cost, with the ability
    to program transactions. Because the protocol is free and open source, anyone
    can fire up a node and connect. Unfortunately, the preceding explanation of the
    Fedwire system is often left out of cryptocurrency discussions, despite being
    necessary context to understanding the benefits of large public blockchains.You
    can find up-to-date community-written documentation for the Ethereum project in
    the Homestead Documentation Initiative ( [www.ethdocs.org/en/latest](http://www.ethdocs.org/en/latest)
    ). These docs are not endorsed by the Ethereum Foundation, but have grown into
    a popular resource for their plain-language explanation of technical concepts.For
    more-nuanced technical discussions and to view Ethereum Improvement Proposals
    (EIPs) , turn to the Ethereum wiki at [https://github.com/ethereum/wiki/wiki](https://github.com/ethereum/wiki/wiki)
    . On the wiki, you’ll find the Ethereum White Paper. If you have remaining questions
    about the way Ethereum works after reading this book, chances are the answer you
    seek is in the White Paper or the aforementioned Yellow Paper, which you’ll also
    find linked on the Ethereum wiki.Chapter [11](A433414_1_En_11_Chapter.html) provides
    an additional index of academic papers associated with the Ethereum project. These
    relate to the future of the project, including scalability and interoperability
    of the Ethereum public chain with private or corporate chains, among other topics.Global
    Singleton MachineThe EVM is a transaction singleton machine with shared state.
    In computing, this means it behaves like one giant data object, rather than what
    it is: a network of discrete machines, themselves singletons, in constant communication.
    (If you’re a nonprogrammer, you may remember from Chapter [1](A433414_1_En_1_Chapter.html)
    that an object is a little chunk of information that is formatted just so, and
    that contains attributes as well as methods for reading or changing those attributes.)'
  prefs: []
  type: TYPE_NORMAL
- en: EVM Applications Are Called Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the perspective of a software developer, the EVM is also a runtime environment
    for small programs that can be executed by the network.
  prefs: []
  type: TYPE_NORMAL
- en: The Name “Smart Contracts ”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than bore you with the etymology of this word, let’s clear up one thing:
    in this context, contract refers to a specific kind of contract: a financial contract,
    also known more colloquially as a derivative, or option. Financial contracts are
    agreements to buy and sell at some point in the future, usually at a specified
    price. In the Ethereum context, smart contracts are agreements between accounts,
    to render a transfer of ether (that is, a payment) when certain conditions are
    met.The reason these contracts are “smart” is that they’re executed by machine,
    and the assets (ether or other tokens) are moved automatically. These contracts
    could be enforced even hundreds of years after they’ve been written, assuming
    the network is still running then—and even if a lot of bad actors try to interfere.
    The EVM is totally sandboxed and free from interference, and isolated from other
    networks too, making it impossible for a party to back out of a smart contract.
    In practical terms, this is because smart contracts are empowered to hold assets
    (ether or other tokens) in escrow and move them when the terms of the contract
    are met.'
  prefs: []
  type: TYPE_NORMAL
- en: The EVM Runs Bytecode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EVM has its own language, the EVM bytecode, to which your smart contracts
    compile. Solidity, which is a high-level language, is compiled into bytecode and
    uploaded onto the Ethereum blockchain by using a client application such as the
    Mist browser or a full node.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding State Machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EVM, as we’ve discussed several times so far, is a state machine. Instead
    of simply defining this concept and moving on, let’s take a moment to discuss
    exactly what a computer is before moving on to the ways that Ethereum advances
    the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Digital vs. Analog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Foundational to the concept of a stateful computer is the idea of a switch
    that can be on or off. The 1s and 0s always referred to as the lingua franca of
    machines refer to arrays of metaphorical switches, so to speak, put in a certain
    configuration in order to code for specific letters, numbers, or other keyboard
    symbols. All of the symbols on a keyboard (and more) can be represented with just
    eight switches, which is why computing memory is stacked in multiples of eight.
    The so-called character code for a comma, for example, is 0010 1100.In computer
    programming, letters and numbers can be used to write machine instructions colloquially
    known as code. American researcher and US Navy Rear Admiral Grace Hopper, shown
    in Figure [3-1](#Fig1), invented the first compiler , which automatically turned
    human-readable code into machine code (like the EVM’s bytecode), which is less
    abstract and therefore one step closer to the 1s and 0s we hear so much about.[²](#Fn2)![A433414_1_En_3_Fig1_HTML.jpg](A433414_1_En_3_Fig1_HTML.jpg)Figure
    3-1.Rear Admiral Grace Hopper was one of the first programmers to write code for
    Harvard’s Mark I computer in 1944\. (Credit: Wikipedia.)'
  prefs: []
  type: TYPE_NORMAL
- en: “State-ments”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Individual snippets of code, when considered by themselves, fall broadly into
    two buckets: expressions and statements. Expressions are used to evaluate a particular
    condition; statements (note the root word!) are used to write information into
    the computer’s memory. Together, expressions and statements let computers modify
    a database in a predictable way when specific conditions are met. This is the
    crux of automation, and it’s the reason we find computers so useful!Statements
    can evaluate to true or false, and depending on the code, this binary outcome
    can result in information being added, removed, or altered within one of the computer’s
    many, many memory addresses. (Because the Solidity language is strongly typed,
    there are no “truthy” and “falsey” statements as in JavaScript.) The clear distinction
    between true and false, yes and no, on and off, is what allows computers to safely
    make decisions in lieu of humans.'
  prefs: []
  type: TYPE_NORMAL
- en: Data’s Role in State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every time you change data in a computer’s memory, you can think of its zillions
    of internal switches (most of them virtualized in the same way we discussed earlier
    in this chapter) as being in a slightly different configuration. State generally
    refers to the present condition of the system: the objective series of changes
    in information, across various memory addresses of the machine, that led to the
    current contents of its memory.It’s important to distinguish between an attribute
    and state. State is something that can change easily and predictably. Let’s use
    the example of a car.Repainting a car is hard work, but it can be done. Paint
    color is an example of an attribute. In pseudocode, you might say the following
    about a car:bodyColor = redIn computer programming, this is called a key/value
    pair . The key, bodyColor, has a value assigned to it, which is red. To change
    the value of this key, your code makes a new statement of the value to be something
    else:bodyColor = greenAnd now your car has been repainted. It has a new color
    value.Now let’s say you instruct the computer that the color of this car will
    change frequently. In other words, you make the car’s color a variable. Well,
    it can be said that the variable (in this case, the color) can have a state, which
    is a value that changes. But an individual value, such as green, has no state;
    green is simply green.An odometer provides another example of a variable with
    a changeable state. The odometer’s value might be 1,000, a number that itself
    has no state; it’s just a number. Soon, the state of the odometer will change
    to a new value (1,001), but that will happen only if the cockpit of the car expresses
    commands that cause the motor and transmission to change state from neutral to
    first gear, and so on.Working familiarity with the concept of state transition
    will help nonprogrammers gain insight into the truly hard problems incumbent in
    the design of decentralized systems. The next several sections of this chapter
    provide a crash course.'
  prefs: []
  type: TYPE_NORMAL
- en: How the Guts of the EVM Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this is your first encounter with the internals of a computer, it’s important
    to remember that a computer is never truly “at rest” as long as it’s powered on.
    The computer itself is running a state function, constantly checking for changes
    to its state. It’s like an overeager intern who wonders thousands of times per
    second if any new work has landed on his desk.When new instructions are triggered,
    the computer runs code and may write new data to its memory. It’s important to
    note that each state change must be based on the last state change; a computer
    doesn’t just toss information into memory addresses willy-nilly.Should something
    go wrong—let’s say one of these instructions isn’t mathematically possible—the
    state of the machine will become invalid, and the program will exit or stop. In
    fact, the entire system may crash.Programs that constantly check for a certain
    condition are known as loops in programming, because they continue to run (to
    loop) until the specified condition is met. The EVM runs a loop continuously that
    attempts to execute whatever instructions are at the current program counter (whatever
    program is “on deck” to be processed). The program counter works like a delicatessen
    queue: each program takes a number and waits its turn.This loop has a few jobs:
    it calculates the cost of gas for each instruction; and it uses memory, if necessary,
    to execute the transaction if the preamble calculation succeeds. This loop repeats
    until the VM either finishes running all the code on deck, or it throws an exception,
    or error, and that transaction is rolled back.Thus far we’ve walked breezily through
    a century of computer science just to catch up to the EVM. Now we’ll begin to
    slow down and see how some of the parts work in action.'
  prefs: []
  type: TYPE_NORMAL
- en: The EVM Constantly Checks for Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: State machines (machines with memory) can be thought of as beings who never
    sleep. As a state machine, the EVM has a constant history of all transactions
    within their memory banks, leading all the way back to the very first transaction.
    Unlike people, who have to deal with imperfect memory, a computer’s state (as
    it exists today) is the specific outcome of every single state-change that has
    taken place inside that machine since it was first switched on.The latest version
    of the machine’s state can be said to be this machine’s canonical “truth” about
    reality as it stands right now. In Ethereum, this truth deals with account balances,
    and the series of transactions that make your balance whatever it is today.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Common Machine Narrative of What ­Happened
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transactions, therefore, represent a kind of machine narrative —a computationally
    valid arc between one state and another. As Gavin Wood’s Ethereum Yellow Paper
    says:'
  prefs: []
  type: TYPE_NORMAL
- en: There exist far more invalid state changes than valid state changes. Invalid
    state changes might, e.g., be things such as reducing an account balance without
    an equal and opposite increase elsewhere. A valid state transition is one which
    comes about through a transaction. [³](#Fn3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As time advances, the system (as in Bitcoin) seeks to create a trustworthy history
    for ensuring that each subsequent state change is legitimate, and not an instruction
    inserted by a bad actor.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic Hashing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next section explains blocks: what’s in them, how they work, and how they
    make a chain. To properly understand that discussion, you first need to learn
    about cryptographic hashing algorithms and what they’re good for.'
  prefs: []
  type: TYPE_NORMAL
- en: What Hash Functions (or Hash Algorithms ) Do
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, the purpose of hash functions, in the context of a blockchain,
    is to compare large datasets quickly and evaluate whether their contents are similar.
    A one-way algorithm processes the entire block’s transactions into 32 bytes of
    data—a hash, or string, of letters and numbers that contains no discernible information
    about the transactions within. The hash creates an unmistakable signature for
    a block, allowing the next block to build on top of it. Unlike the ciphertext
    that results from encryption, which can be decrypted, the result of a hash cannot
    be “un-hashed.”NoteThe hash of a given dataset is always the same. It is computationally
    infeasible that two datasets might resolve to similar hashes. Changing even one
    character of the dataset will completely jumble up the hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks : The History of State Changes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transactions and state changes in the Ethereum network are segmented into blocks,
    and then hashed. Each block is verified and validated before the next canonical
    block can be placed on “top” of it. In this way, nodes on the network do not need
    to individually evaluate the trustworthiness of every single block in the history
    of the Ethereum network, simply to compute the present balances of the accounts
    on the network. They merely verify that its “parent block” is the most recent
    canonical block. They do this quickly by looking to see that the new block contains
    the correct hash of its parent’s transactions and state.All the blocks strung
    together, and including the genesis block, an honorific describing the first block
    the network mined after coming online, are called the blockchain. In some circles,
    you will hear the blockchain referred to as a distributed ledger or distributed
    ledger technology (DLT).Ledger is an accurate description, as the chain contains
    every transaction in the history of the network, making it effectively a giant,
    balanced book of accounts. However, most so-called digital ledgers do not use
    proof of work to secure the network, as Bitcoin and Ethereum do.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Block Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Bitcoin, a block is 10 minutes. This so-called block time is derived from
    constants hard-coded into Bitcoin’s issuance scheme, with a total of 21 million
    coins to be released from 2009 to 2024, and rewards halving every four years.[⁴](#Fn4)In
    Ethereum, block time is not a function of the issuance schedule of ether. Instead,
    block time is a variable that is kept as low as possible, for the sake of speedy
    transaction confirmation. It averages about 15 seconds as of this writing. Ethereum’s
    shorter block time is the beneficiary of blockchain research done after the launch
    of Bitcoin, which showed that shorter block times were not only technically feasible,
    but desirable in many ways. However, shorter block times do have some drawbacks
    that are explored more thoroughly in Chapter [6](A433414_1_En_6_Chapter.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Drawbacks of Short Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s important to note that Bitcoin’s long confirmation times make retail commerce
    and other practical applications difficult. When blocks are shorter and transactions
    move faster, user experience is better. However, shorter blocks and faster transactions
    make it more likely that a given node will get the order of transactions wrong,
    because it may not have heard about some transactions originating from far away
    (or heard about them late).To compensate for this, the miners who find blocks
    that are valid, but nonetheless not the winning block, are paid a reduced fee
    as consolation. In Ethereum, these blocks are called Uncles.What makes a block
    valid vs. the winner is the subject of Chapter [6](A433414_1_En_6_Chapter.html).To
    see the full Ethereum block protocol, visit [https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0](https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0)
    .For now, let’s continue with our overview of the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: “Solo Node” Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In theory, you could reconcile changes from many nodes with a single computer:
    a centralized server processing the order of transactions. Indeed, web applications
    such as Google Docs have sophisticated real-time engines that help them deal with
    conflicting changes made by multiple users, some of whom may be on faster connections
    than others, and still others who may be editing a document offline.As you’ll
    see when you spin up your own blockchain in Chapter [9](A433414_1_En_9_Chapter.html),
    it’s possible to use the Ethereum protocol with a single machine. It will process
    your transactions just fine, as long as one or more nodes are mining on the chain.
    But if someone knocks that machine offline, your chain is inaccessible, and transactions
    stop going through.For this reason, despite Ethereum being free and open software,
    the necessity for many, many nodes to create a resilient network causes developers
    to converge and work (for the most part) as one community, on a small number of
    public chains.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distributed nature of the Ethereum Virtual Machine, and the fact that it
    is composed of many nodes around the world, means that it must be purpose-built
    to solve the diff-matching problem that can arise when there are many near-simultaneous
    changes to the same database, from many users, all over the world.[⁵](#Fn5)Indeed,
    solving this problem in a verifiable and trustworthy way is the purpose of the
    EVM as well as the Bitcoin virtual machine. The EVM’s resilience and security
    arise from the large number of machines mining on the network, incentivized by
    the earning of fees denominated in ether or bitcoins. We’ll go over this briefly
    before diving into a full explanation in Chapter [6](A433414_1_En_6_Chapter.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mining’s Place in the State Transition Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mining is the process of using computational work to nominate a block—that
    miner’s version of recent transaction history—as the canonical block for this,
    the most recent block on the chain. How exactly this happens is the subject of
    Chapter [6](A433414_1_En_6_Chapter.html), but the point of bringing it up now
    is to show that mining incentive awards take place as part of the state-transition
    function. Mining achieves the consensus required to make valid state changes,
    and the miners are paid for contributing to the consensus building. This is how
    ether and bitcoin are “created.”Recall that each time a new block is created,
    it is downloaded, processed, and validated by node on the network. During processing,
    each node executes all the transactions contained therein. This is a long process
    with many steps, but we’ll summarize. Written out in English, the Ethereum state
    transition function can be defined as the following six steps.[⁶](#Fn6) For each
    transaction in a block, the EVM performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.Check whether the transaction is in the right format. Does it have the right
    number of values? Is the signature valid? Does the nonce—a transaction counter—on
    the transaction match the nonce on the account? If any of these are missing, return
    an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.Calculate the transaction fee by multiplying the amount of work required (represented
    by STARTGAS, as you’ll see in table [3-1](#Tab1)) by the gas price. Then deduct
    the fee from the user’s account balance, and increment the sender’s nonce (transaction
    counter). If there’s not enough ether in the account, return an error.Table 3-1.Costs
    of Common EVM Operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Operation Name | Gas Cost | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| step | 1 | Default amount per execution cycle |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| stop | 0 | Free |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| suicide | 0 | Free |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| sha3 | 20 | SHA-3 hash function |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| sload | 20 | Gets from permanent storage |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| sstore | 100 | Puts into permanent storage |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| balance | 20 | Queries account balance |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| create | 100 | Contract creation |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| call | 20 | Initiating a read-only call |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| memory | 1 | Every additional word when expanding memory |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| txdata | 5 | Every byte of data or code for a transaction |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| transaction | 500 | Base fee transaction |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| contract creation | 53,000 | Changed in homestead from 21,000 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 3.Initialize the gas payment; from this point forward, take off a certain amount
    of gas per byte processed in the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.Transfer the value of the transaction—the amount being sent—to the receiving
    account.If the receiving account doesn’t exist yet, it will be created. (Offline
    Ethereum nodes can generate addresses, so the network may not hear of a given
    address until a transaction takes place.)If the receiving address is a contract
    address, run the contract’s code. This continues either until the code finishes
    executing or the gas payment runs out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.If the sending account doesn’t have enough ether to complete the transaction,
    or the gas runs out, all changes from this transaction are rolled back. A caveat
    are the fees, which still go to the miner and are not refunded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.If the transaction throws an error for any other reason, refund the gas to
    the sender and send any fees associated with gas used to the miner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NoteSmart contract data is executed in Step 4 of the state transition function,
    as described above.
  prefs: []
  type: TYPE_NORMAL
- en: Renting Time on the EVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may be gathering, the EVM is a rather deliberate machine, albeit far
    more trustworthy and reliable than any network we have today. For every instruction
    the EVM executes, there must be a cost associated, to ensure the system isn’t
    jammed up by useless spam contracts.Every time an instruction executes, an internal
    counter keeps track of the fees incurred, which are charged to the user. Each
    time the user initiates a transaction, that user’s wallet reserves a small portion
    (selected by the user) to pay these fees.After a transaction has been broadcast
    to the network from a given node—let’s say Bob sends Alice some ether from his
    computer—the network propagates the transaction around so that all the nodes can
    include it in the latest block.Believe it or not, the explanation so far in this
    chapter barely scrapes the surface of the EVM’s internals. You’ll learn more in
    Chapters [5](A433414_1_En_5_Chapter.html) and [6](A433414_1_En_6_Chapter.html).
    For now, it will be useful to break down the fees, their role in transaction execution,
    and their impact on development patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Gas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gas is a unit of work used to measure how computationally expensive an Ethereum
    operation will be. Gas costs are paid with small amounts of ether.The purpose
    of gas is twofold. First, it guarantees a prepaid reward for the miners that execute
    code and secure the network, even if the execution fails for some reason. Second,
    it works around the halting problem and ensures that execution can’t go on longer
    than the time it prepaid for.Gas is a unit of work; it’s not a subcurrency, and
    you can’t hold or hoard it. It simply measures how much effort each step of a
    transaction will be, in computational terms.To be able to pay for gas costs ,
    you simply need to add ether to your account. You don’t have to acquire it separately;
    there is no gas token. Every operation possible on the EVM has an associated gas
    cost.NoteIt’s the combination of total gas used multiplied by gas price paid that
    results in the total fee accrued by a given transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Why Is Gas So Important?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gas costs ensure that computation time on the network is appropriately priced.
    This works differently in Bitcoin, where the fee is based on the size of the transaction
    in kilobytes. Because Solidity code can be arbitrarily complex, a short snippet
    of instructions could generate a lot of computational work, whereas a long snippet
    could generate less. That’s why fees in the EVM are based on the amount of work
    being done, not on the size of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Why Isn’t Gas Priced in Ether?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because ether is traded publicly on cryptocurrency exchanges, it is subject
    to speculative periods of inflation and deflation. Using the gas unit of account
    for computational work is helpful because it separates the price of computation
    from the highly volatile price of the ether token.
  prefs: []
  type: TYPE_NORMAL
- en: Fees as Regulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ll see in Chapter [7](A433414_1_En_7_Chapter.html), networks such as
    Bitcoin and Ethereum use economic incentives and disincentives to render certain
    attack vectors moot. Fees fall into the category of disincentive.To begin with,
    it’s important to recognize that the operation of an Ethereum node represents
    some risk. There’s the cost of the hardware, plus the time and energy of the operator,
    and the network’s cost of downloading and verifying the proof of work and the
    block header. Thus it makes sense that a transaction fee be put in place to prevent
    pranksters from wasting the network’s capacity.Blocks that consume excessive amounts
    of gas are a big danger in Ethereum. They can take a long time to propagate because
    of their sheer size. How the system adapts to the demands of users, who may have
    legitimate uses for large smart contracts, will become clear later on in this
    chapter, and in Chapter [6](A433414_1_En_6_Chapter.html). The protocol helps cut
    off late blocks using various methodologies we’ll explore in Chapter [6](A433414_1_En_6_Chapter.html),
    and places a floating cap on operations, which currently sits at 65,536 per block.[⁷](#Fn7)
  prefs: []
  type: TYPE_NORMAL
- en: Working with Gas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll explore the details of working with gas and then see
    how gas relates to scaling the system.
  prefs: []
  type: TYPE_NORMAL
- en: Gas Specifics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s review some details about working with gas:'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the term gas creates some confusion. Every transaction requires
    a STARTGAS value. This value is referred to as gasLimit in the Yellow Paper and
    often just as gas in Geth and Web3.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every transaction also requires the user to specify a gas price.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount stipulated in STARTGAS, multiplied by the gas price, is held in escrow
    while your transaction executes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the gas price you offer for a transaction is too low, nodes won’t process
    your transaction, and it will sit unprocessed on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your gas price is acceptable to the network, but the gas cost runs over what’s
    available in your wallet balance, the transaction fails and is rolled back; this
    failed transaction is recorded to the blockchain, and you get a refund of any
    STARTGAS not used in the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using excessive STARTGAS does not cause your transactions to be processed more
    quickly, and in some cases may make your transaction less appealing to miners.[⁸](#Fn8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Gas Relates to Scaling the System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you send a computationally difficult set of instructions to the EVM, the
    only person this hurts is you. The work will spend your ether, and stop when the
    ether you allocated to the transaction runs out. It has no effect on anyone else’s
    transactions. There is no way to jam up the EVM without paying a lot, in the form
    of transaction fees, to do it.Scaling is handled in a de facto way through the
    gas fee system. Miners are free to choose the transactions that pay the highest
    fee rates, and can also choose the block gas limit collectively. The gas limit
    determines how much computation can happen (and how much storage can be allocated)
    per block.In this way, the price of computation on the EVM stays flexible and
    responsive to the demand of the users of the system, as well as the costs incurred
    by the miners who do the important work of processing transactions, maintaining
    hardware, and paying electricity bills.
  prefs: []
  type: TYPE_NORMAL
- en: Accounts, Transactions, and Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from Chapter [2](A433414_1_En_2_Chapter.html) that Ethereum has two
    types of accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: Externally owned accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contracts accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look more deeply into exactly what each account type can do.
  prefs: []
  type: TYPE_NORMAL
- en: Externally Owned Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An externally owned account (EOA) is also known as an account controlled by
    a pair of private keys, which may be held by a person or an external server. These
    accounts cannot hold EVM code. Characteristics of an EOA include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains a balance of ether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capable of sending transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlled by the account’s private keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has no code associated with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key/value database contained in each account, where keys and values are both
    32-byte strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Contract accounts are not controlled by humans. They store instructions and
    are activated by external accounts or other contract accounts. Contract accounts
    have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Have an ether balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold some contract code in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be triggered by humans (sending a transaction) or other contracts sending
    a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executed, can perform complex operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have their own persistent state and can call other contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have no owner after being released to the EVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key/value database contained in each account, where keys and values are both
    32-byte strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions and Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transactions come from external accounts, which are usually controlled by human
    users. It’s a way for an external account to submit instructions to the EVM to
    perform some operation. In other words, it’s a way for an external account to
    get a message into the system. In computing terminology, a message is a chunk
    of data containing instructions. Programmers can think of messages as function
    calls.A transaction in the EVM is a cryptographically signed data package storing
    a message (as described previously), which tells the EVM to transfer ether, create
    a new contract, trigger an existing one, or perform some calculation. Contract
    addresses can be the recipients of transactions, just like users with external
    accounts. Recall the discussion of cryptographic communication from Chapter [2](A433414_1_En_2_Chapter.html),
    in which we discussed encrypted communications: a transaction is like a private
    communication between two users in an unsecured network, who are nevertheless
    able to “send” value to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transactions contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A recipient address; specifying no recipient (and attaching smart contract data)
    is the method for uploading new smart contracts. As you’ll see, a contract address
    is returned so that the user knows where to access this contract in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signature identifying the sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value field showing the amount being sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional data field, for a message (if this is being sent to a contract address)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A STARTGAS value, indicating the maximum number of computational steps the transaction
    are prepaid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GASPRICE value, representing the fee the sender is willing to pay for gas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A message is a chunk of data sent by a contract to another contract (never
    to or from a human). Messages are virtual objects that are never serialized and
    exist only in the EVM. When a miner is paid in the Ethereum network, this is accomplished
    by way of a message to increment the miner’s payment address; it does not constitute
    a transaction.A message is sent when a contract is being run by the EVM, and it
    executes the CALL or DELEGATECALL opcodes. You will learn about opcodes in the
    next section of this chapter.NoteBecause the Ethereum network is not connected
    to the HTTP Web, it does not use HTTP methods. Instead, it uses operation codes
    traditionally used to pass messages within the same localhost. This is what is
    meant by descriptions which include language such as “one global machine.” Bitcoin
    works similarly.Messages are sent to other contract accounts, which in turn run
    the code enclosed in the message. Thus, contracts can have relationships with
    each other.A message contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The sender address of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipient address of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value field (indicating how much ether, if any, is being sent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional data field (containing input data for the contract)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A STARTGAS value limiting the amount of gas the message can use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating Gas Fees for Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transactions need to provide enough STARTGAS to cover all computation and storage.
    However, but there are many operations in the EVM, and it’s hard to memorize what
    each one costs.Table [3-1](#Tab1) shows the costs of some common EVM operations.An
    up-to-date Google Doc containing the costs of various EVM operations can be found
    at [http://gas.eth.guide](http://gas.eth.guide) .
  prefs: []
  type: TYPE_NORMAL
- en: Opcodes in the EVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ll see, some of these operations can be called as methods. One of the
    most confusing things about the blockchain paradigm is that it combines technical
    conventions from several domains of computer science and networking. One example
    is Ethereum’s (and Bitcoin’s) use of opcodes, or operation codes. Table [3-2](#Tab2)
    shows all the opcodes available on the EVM, and their respective functions.Table
    3-2.This is a complete list of EVM opcodes
  prefs: []
  type: TYPE_NORMAL
- en: '| 0s: Stop and Arithmetic Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00 | STOP | Halts execution. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | ADD | Addition operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | MUL | Multiplication operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x03 | SUB | Subtraction operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | DIV | Integer division operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x05 | SDIV | Signed integer. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x06 | MOD | Modulo. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x07 | SMOD | Signed modulo. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x08 | ADDMOD | Modulo. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x09 | MULMOD | Modulo. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0a | EXP | Exponential operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0b | SIGNEXTEND | Extend length of 2s (complement signed integer). |'
  prefs: []
  type: TYPE_TB
- en: '| 10s: Comparison and Bitwise Logic Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10 | LT | Lesser-than comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x11 | GT | Greater-than comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x12 | SLT | Signed less-than comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x13 | SGT | Signed greater-than comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14 | EQ | Equality comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x15 | ISZERO | Simple NOT operator. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x16 | AND | Bitwise AND operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x17 | OR | Bitwise OR operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x18 | XOR | Bitwise XOR operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x19 | NOT | Bitwise NOT operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1a | BYTE | Retrieve single byte from word. |'
  prefs: []
  type: TYPE_TB
- en: '| 20s: SHA3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x20 | SHA3 | Compute Keccak-256 hash. |'
  prefs: []
  type: TYPE_TB
- en: '| 30s: Environmental Information |'
  prefs: []
  type: TYPE_TB
- en: '| 0x30 | ADDRESS | Get address of currently executing account. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x31 | BALANCE | Get balance of the given account. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x32 | ORIGIN | Get execution origination address. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x33 | CALLER | Get caller address. This is the address of the account directly
    responsible for this execution. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x34 | CALLVALUE | Get deposited value by the instruction/transaction responsible
    for this execution. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x35 | CALLDATALOAD | Get input data of current environment. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x36 | CALLDATASIZE | Get size of input data in current environment. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x37 | CALLDATACOPY | Copy input data in current environment to memory. Pertains
    to the input data passed with the message call instruction or transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x38 | CODESIZE | Get size of code running in current environment. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x39 | CODECOPY | Copy code running in current environment to memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x3a | GASPRICE | Get price of gas in current environment. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x3b | EXTCODESIZE | Get size of an account’s code. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x3c | EXTCODECOPY | Copy an account’s code to memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 40s: Block Information |'
  prefs: []
  type: TYPE_TB
- en: '| 0x40 | BLOCKHASH | Get the hash of one of the 256 most recent complete blocks.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x41 | COINBASE | Get the block’s beneficiary address. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x42 | TIMESTAMP | Get the block’s timestamp. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x43 | NUMBER | Get the block’s number. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x44 | DIFFICULTY | Get the block’s difficulty. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x45 | GASLIMIT | Get the block’s gas limit. |'
  prefs: []
  type: TYPE_TB
- en: '| 50s: Stack, Memory, Storage, and Flow Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x50 | POP | Remove item from stack. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x51 | MLOAD | Load word from memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x52 | MSTORE | Save word to memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x53 | MSTORE8 | Save byte to memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x54 | SLOAD | Load word from storage. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x55 | SSTORE | Save word to storage. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x56 | JUMP | Alter the program counter. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x57 | JUMPI | Conditionally alter the program counter. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x58 | PC | Get the value of the program counter prior to the increment.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x59 | MSIZE | Get the size of active memory in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x5a | GAS | Get the amount of available gas, including the corresponding
    reduction. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x5b | JUMPDEST | Mark a valid destination for jumps. |'
  prefs: []
  type: TYPE_TB
- en: '| 60s and 70s: Push Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x60 | PUSH1 | Place 1-byte item on stack. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x61 | PUSH2 | Place 2-byte item on stack. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x7f | PUSH32 | Place 32-byte (full word) item on stack. |'
  prefs: []
  type: TYPE_TB
- en: '| 80s: Duplication Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80 | DUP1 | Duplicate first stack item. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x81 | DUP2 | Duplicate second stack item. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x8f | DUP16 | Duplicate 16th stack item. |'
  prefs: []
  type: TYPE_TB
- en: '| 90s: Exchange Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0x90 | SWAP1 | Exchange first and second stack items. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x91 | SWAP2 | Exchange first and third stack items. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x9f | SWAP16 | Exchange 1st and 17th stack items. |'
  prefs: []
  type: TYPE_TB
- en: '| a0s: Logging Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0xa0 | LOG0 | Append log record with no topics. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xa1 | LOG1 | Append log record with one topic. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xa4 | LOG4 | Append log record with four topics. |'
  prefs: []
  type: TYPE_TB
- en: '| f0s: System Operations |'
  prefs: []
  type: TYPE_TB
- en: '| 0xf0 | CREATE | Create a new account with associated code. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xf1 | CALL | Message-call into an account. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xf2 | CALLCODE | Message-call into this account with alternative account’s
    code. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xf3 | RETURN | Halt execution returning output data. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xf4 | DELEGATECALL | Message-call into this account with an alternative
    account’s code, but persisting the current values for sender and value. Halt execution;
    mark for deletion. |'
  prefs: []
  type: TYPE_TB
- en: '| 0xff | SUICIDE | Halt execution and register account for later deletion.
    |'
  prefs: []
  type: TYPE_TB
- en: 'In traditional web development, the rough equivalent of an opcode would be
    a HTTP verb, also known as an HTTP method. These include GET, POST, HEAD, OPTIONS,
    PUT, DELETE, TRACE, and CONNECT. These semantics are reliable and well-known.In
    Ethereum and Bitcoin, things work differently. Because the network is also a global
    machine, the “methods” you use to make calls across the network are just machine-language
    codes, of the ilk used inside an individual computer.The following is a full list
    of EVM opcodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter has provided a more complete vision of the EVM as a database,
    and how changes are made to its state. Although the design rationale should be
    clearer to you now, there’s still a lot left to discuss. If you’d like to read
    more ancillary documentation about how the EVM executes programs, you’ll find
    a list of resources at [http://evm.eth.guide](http://evm.eth.guide) .The question
    to tackle next: what does it mean to run programs on the EVM? The answer lies
    in writing and deploying smart contracts, which work in concert to form distributed
    applications.As we discussed in this chapter, each contract has its own address
    with storage, where it can hold any arbitrary code. When a transaction hits this
    address, or the contract is called by another contract, its code springs to life
    inside every node on the EVM, leading to further message passing or ether transactions.The
    instructions that make up smart contracts are stored in EVM bytecode. But before
    they are compiled into bytecode, they are written by a human, in the Solidity
    programming language. That language is the subject of the next chapter.Footnotes[1](#Fn1_source)Forbes,
    “Central Banks Explore Blockchains: Why Digital Dollars, Pounds Or Yuan Could
    Be A Reality In 5 Years,” [www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8](http://www.forbes.com/sites/laurashin/2016/10/12/central-banks-explore-blockchains-why-digital-dollars-pounds-or-yuan-could-be-a-reality-in-5-years/#5ef54e7176d8)
    , 2016.[2](#Fn2_source)Wikipedia, “Grace Hopper,” [https://en.wikipedia.org/wiki/Grace_Hopper](https://en.wikipedia.org/wiki/Grace_Hopper)
    , 2016.[3](#Fn3_source)Gavwood.com, “Ethereum: A Secure Decentralised Generalised
    Transaction Ledger”, [http://gavwood.com/paper.pdf](http://gavwood.com/paper.pdf)
    , 2016.[4](#Fn4_source)Bitcoin Wiki, “Controlled Supply,” [https://en.bitcoin.it/wiki/Controlled_supply](https://en.bitcoin.it/wiki/Controlled_supply)
    , 2016.[5](#Fn5_source)Google Code, “Diff-Match Patch,” [https://code.google.com/p/google-diff-match-patch/](https://code.google.com/p/google-diff-match-patch/)
    , 2016.[6](#Fn6_source)Ethereum White Paper, “Ethereum State Transition Function,”
    [https://​github.​com/​ethereum/​wiki/​wiki/​White-Paper#ethereum-state-transition-function](https://github.com/ethereum/wiki/wiki/White-Paper#ethereum-state-transition-function),
    2016.[7](#Fn7_source)GitHub, “Ethereum White Paper,” [https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)
    , 2016.[8](#Fn8_source)ConsenSys Media, “Ethereum, Gas, Fuel and Fees,” [https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc#.ozbhydyz6)
    , 2016.'
  prefs: []
  type: TYPE_NORMAL
