- en: 5   Technology on Ethereum
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5节 以太坊技术
- en: The simplest way to describe Bitcoin is to say that it is cryptocurrency or
    digital money. Bitcoin was released in January 2009, so for approximately nine
    years it has been used to transfer money in a peer-to-peer blockchain network.
    There is no central or world bank entity that controls the flow or functionality
    of Bitcoin; it is a decentralized digital currency. When compared to Bitcoin,
    Ethereum differs mainly in that it adds the functionality of the smart contract
    to its base cryptocurrency, known as ether. What does smart contract mean? Well,
    think of it as digital money that has logic associated with it. A smart contract
    can be set up to transfer value from one entity or account to another, and to
    do this if—and only if—certain conditions are met. Here’s an example. Suppose
    you want to purchase a piece of real estate from someone. For those of you who
    have had the privilege of doing this, you know that there are almost too many
    third parties involved in the purchase, including real estate agents and brokers,
    lawyers, title searchers, home inspectors, surveyors, mortgage banks, and escrow
    agents. These external parties are what typically make the process incredibly
    slow and, of course, add cost. An Ethereum solution would have logic (or code)
    that could automatically transfer the ownership (title) from seller to buyer and
    the funds from buyer to seller after a deal is agreed upon in a far simpler way
    without needing as many third parties involved. See [Table 5-1](ch5.xhtml#ch5tab1)
    for more Ethereum to Bitcoin comparison items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 描述比特币最简单的方式就是称它为加密货币或数字货币。比特币于2009年1月发布，因此在大约九年的时间里，它被用于点对点的区块链网络中转账。没有中心或世界银行实体控制比特币的流动或功能；它是一种去中心化的数字货币。与比特币相比，以太坊的主要区别在于它在其基础加密货币（称为以太）中添加了智能合约的功能。智能合约是什么意思呢？好吧，可以把它想象成带有逻辑的数字货币。可以设置智能合约，在满足某些条件时，将价值从一个实体或账户转移到另一个实体或账户。这是一个例子。假设你想从某人那里购买一块地产。对于那些有幸这样做过的人，你们知道购买过程中涉及太多的第三方，包括房地产经纪人、经纪人、律师、产权调查员、家庭检查员、测量师、抵押银行和托管代理人。这些外部方通常使得流程变得极其缓慢，当然也会增加成本。以太坊解决方案将有逻辑（或代码），可以以更简单的方式自动在卖方和买方之间转移所有权（产权）以及买方和卖方之间的资金，在交易达成协议后，而无需涉及那么多第三方。参见[表5-1](ch5.xhtml#ch5tab1)以获取更多以太坊与比特币比较项目。
- en: '**TABLE 5-1** **Comparison of Ethereum to Bitcoin (Source: bitinfocharts.com)**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1** **以太坊与比特币比较（来源：bitinfocharts.com）**'
- en: '![Images](tab5-1.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab5-1.jpg)'
- en: Ethereum was created to serve as a platform for building blockchain-based, or
    decentralized, applications. It is developed by the Ethereum Foundation, a Swiss
    nonprofit, with contributions from great minds around the globe. Ethereum is well
    positioned for applications that need to be built quickly and that interact efficiently
    and securely in a blockchain ecosystem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊被创建来作为构建基于区块链的，或去中心化应用程序的平台。它是由瑞士的一家非营利组织以太坊基金会开发的，全球各地的优秀人才为其做出了贡献。以太坊非常适合需要快速构建且在区块链生态系统中高效、安全交互的应用程序。
- en: 'Ethereum uses blockchain technology, which is a transaction record that is
    independently verified by others and held on a distributed ledger. The same technology
    underpins Bitcoin. However, the Bitcoin blockchain is predominantly designed to
    do one thing: facilitate Bitcoin transactions. Ethereum, on the other hand, is
    designed to act as a programmable infrastructure. This means that Ethereum is
    a more adaptable and flexible development platform.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用区块链技术，这是一种由他人独立验证并保存在分布式账本上的交易记录。同样的技术支撑着比特币。然而，比特币区块链主要设计用于做一件事：促进比特币交易。另一方面，以太坊被设计为可编程的基础设施。这意味着以太坊是一个更适应、更灵活的开发平台。
- en: The Ethereum platform is often referred to as a Turing-complete virtual machine
    built upon the foundational functionality of blockchain. Ethereum allows one to
    construct smart contracts and applications with their own arbitrary rules for
    ownership, transaction formats, and state transition logic. A bare-bones version
    of a value application can be written in two lines of code, and other protocols
    such as currencies and reputation systems can be built in under twenty.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊平台通常被称为建立在区块链基础功能之上的图灵完备虚拟机。以太坊允许构建具有自己任意规则的所有权、交易格式和状态转换逻辑的智能合约和应用程序。一个简化的价值应用可以在两行代码中编写，其他协议，如货币和声誉系统可以在二十行以内构建。
- en: Ethereum has its own token, called ether, which provides the primary form of
    liquidity allowing for exchange of value across the network. Ether also provides
    the mechanism for paying and earning transaction fees that arise from supporting
    and using the network. Ether has been the subject of speculation, and, as with
    Bitcoin, the price of ether has seen wide fluctuations. In the past two years,
    the price per ether ranged from US$10 to over US$400\. It’s now back to around
    US$300, but it has shown classic speculative characteristics. It is worth noting
    that ether is the financial incentive that pushes and fosters decentralization
    (and attracting miners), which makes the platform more secure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 拥有自己的代币，称为以太币（ether），它提供了网络内价值交换的主要流动性形式。以太币还提供了支付和使用网络产生的交易费用的机制。以太币曾遭到投机，和比特币一样，以太币的价格也经历了剧烈波动。在过去的两年里，每个以太币的价格从
    10 美元涨到了超过 400 美元。现在又回到了大约 300 美元，但它已经表现出了典型的投机特性。值得注意的是，以太币是推动和促进去中心化（以及吸引矿工）的金融激励，这使得平台更加安全。
- en: Ethereum contains smart contracts. A smart contract is simply any agreement
    that can execute certain functions without human intervention. A smart contract
    in Ethereum is a cryptographically secured box containing logic and value. The
    logic has specific conditions that have to be met in order to release the value.
    It is the addition of logic and state that makes Ethereum a more powerful platform
    than what is available with other cryptocurrencies, including Bitcoin (and its
    scripting functionality). An example of a smart contract for insurance could automatically
    pay out to the insured entity based on a data feed showing that a payable event
    had occurred.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 包含智能合约。智能合约实质上是指任何可以无需人类干预而执行某些功能的协议。Ethereum 中的智能合约是一个包含逻辑和价值的加密安全箱。逻辑有特定的条件必须满足才能释放价值。正是逻辑和状态的增加使得
    Ethereum 比其他加密货币（包括比特币）更具 powerful。一个保险智能合约的例子可以自动向被保险实体支付，基于数据流显示已发生可支付事件。
- en: Smart contracts enable decentralized applications (dapps). Centralized applications
    are really centralized services. For example, when we interact with a third-party
    app on our smartphone, the app will communicate with centralized servers and services.
    A dapp can look exactly the same in terms of the user interface, but the backend
    services are replaced with smart contracts that run on the decentralized Ethereum
    network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约能够实现去中心化应用（dapps）。中心化应用实际上是中心化服务。例如，当我们与智能手机上的第三方应用互动时，该应用将会与中心化服务器和服务进行通信。一个
    dapp 在用户界面看起来可能完全一样，但后端服务被运行在去中心化 Ethereum 网络上的智能合约所替代。
- en: Ethereum also has decentralized autonomous organizations (DAOs). A DAO is a
    new form of entity or organization that can, for example, replace articles of
    incorporation and shareholder agreements with smart contracts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 也有去中心化自治组织（DAO）。DAO 是一种新型的实体或组织形式，例如，可以用智能合约来替代公司章程和股东协议。
- en: Dapps and DAOs can also have their own digital tokens that serve a variety of
    functionality by acting as an internal currency. The development of dapps and
    DAOs is now being funded by selling these digital tokens in what is known as a
    token sale or an initial coin offering (ICO).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: dapps 和 DAOs 也可以拥有自己的数字代币，这些代币作为内部货币，通过充当内部货币来实现各种功能。dapps 和 DAOs 的发展目前正通过出售这些数字代币来筹集资金，这被称为代币销售或首次代币发行（ICO）。
- en: Ethereum Accounts
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ethereum 账户
- en: 'Within Ethereum, the current state is made up of objects that are commonly
    called accounts. The internal fuel on Ethereum is ether, and it is used to pay
    transaction fees (more on this later in the chapter). Ethereum can be viewed as
    a transaction-based state machine, starting with the genesis state and incrementally
    executing transactions that morph the state into a final state. The final state
    is what is considered the canonical “version” of the world of Ethereum. The state
    includes anything that can currently be represented by a computer, such as account
    balances, reputations, trust arrangements, and data representing information in
    the physical world. Transactions therefore represent a valid transition between
    two states. Each account within Ethereum has a 20-byte address (or identity) and
    the object is made up of four attributes or fields, which are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，当前状态由通常称为账户的对象组成。以太坊内部的燃料是以太币，它用来支付交易费用（关于这一点本书稍后会介绍）。以太坊可以被看作是基于交易的态机，从创世态开始，逐步执行交易，使态机转变为最终态。最终态被认为是以太坊世界的标准“版本”。态机包括任何当前可以由计算机表示的内容，比如账户余额、声誉、信任安排以及代表物理世界中信息的数据。因此，交易代表了两态之间的有效过渡。以太坊中的每个账户都有一个20字节的地址（或身份），该对象由四个属性或字段组成，这些是：
- en: •   **Nonce**   Counter that is used to ensure each and every transaction can
    be processed once and once only
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh:   •   **Nonce**   用于确保每一笔交易只能处理一次的计数器
- en: •   **Ether balance**   The account’s current value
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh:   •   **以太币余额**   账户的当前余额
- en: •   **Contract code**   An optional container for logic
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh:   •   **合约代码**   可选的逻辑容器
- en: •   **Storage**   Empty by default
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh:   •   **存储**   默认情况下为空
- en: There are two types of accounts, externally owned accounts (EOAs) and contract
    accounts. EOAs, also known as normal accounts, have an ether balance, contain
    no logic, and are controlled by private keys. Contract accounts also have an ether
    balance but are controlled by their accompanying contract code (logic). All action
    on the Ethereum platform is set in motion by transactions fired from externally
    owned (normal) accounts. An externally owned account sends messages by creating,
    signing, and submitting a transaction. When a contract account receives a message,
    its code activates and executes as instructed by the input parameters of the transaction.
    The code (or logic) can read and write to the internal storage and send additional
    messages or create contracts. The use of the term *contract* in Ethereum should
    not be confused with its typical everyday use such as needing fulfillment, completion,
    or compliance per se. It is used to indicate logic bound inside the Ethereum execution
    environment that is executed in a defined way (by contract) when “poked” by a
    message or transaction (more on transactions later in this chapter), and that
    controls its internal state (variables), which includes its ether value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种账户类型，外部拥有账户（EOAs）和合约账户。EOAs，也称为普通账户，拥有以太币余额，没有逻辑，由私钥控制。合约账户也有以太币余额，但由伴随的合约代码（逻辑）控制。以太坊平台上的所有操作都是由外部拥有（普通）账户发起的交易触发的。一个外部拥有账户通过创建、签名并提交交易来发送消息。当合约账户接收到一条消息时，其代码会被激活并根据交易的输入参数执行。代码（或逻辑）可以读写内部存储并发送额外消息或创建合约。以太坊中“合约”一词的使用不应该与日常生活中的典型用途混淆，比如需要履行、完成或遵守本身。它用来表示被绑定在以太坊执行环境内的逻辑，当接收到消息或交易（关于交易的内容稍后在本书中介绍）的“刺激”时，以定义的方式（由合约）来执行，并控制其内部状态（变量），这包括它的以太币价值。
- en: Ether the Cryptocurrency
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh:   •   **以太币：加密货币**
- en: Ether (ETH) is the name of the cryptocurrency that fuels the distributed application
    Ethereum platform. It is used as the form of payment made by the clients of the
    network to the actual machines that execute the requested tasks. As we mentioned
    earlier, ether is the financial incentive that pushes and fosters decentralization
    and therefore attracts miners. Additional miners make the platform more secure
    and viable. Ether is also the incentive ensuring that quality applications are
    created, because inefficient code will usually cost more, and that the network
    remains highly available and functional, because owners are compensated for their
    contributed resources (computing power and storage).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币（ETH）是推动分布式应用以太坊平台的加密货币。它作为网络客户端支付给实际执行请求任务的机器的形式。如我们早先提到的，以太币是推动和促进去中心化的金融激励，因此吸引矿工。更多的矿工使平台更加安全和可行。以太币也是确保创建高质量应用程序的激励，因为低效的代码通常成本更高，并使网络保持高可用性和功能性，因为所有者为其贡献的资源（计算能力和存储）得到补偿。
- en: As with a fiat currency, ether comes in size denominations that have their own
    name, shown in [Table 5-2](ch5.xhtml#ch5tab2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与法定货币一样，以太币有不同的面额，有自己的名称，如[表 5-2](ch5.xhtml#ch5tab2)所示。
- en: '**TABLE 5-2** **Ether Denominations**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2  以太币面额**'
- en: '![Images](tab5-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![ Images](tab5-2.jpg)'
- en: 'In short, ether has two purposes: it is used to pay the fees associated with
    a transaction, and it provides the Ethereum platform with the liquidity to exchange
    value between the types of digital assets housed on the platform.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以太坊有两个用途：一是用于支付交易相关的费用，二是为以太坊平台提供流动性，以便在平台上交换各种数字资产。
- en: Genesis Block
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创世区块
- en: Ether (ETH) was first issued in order to get the Ethereum project and platform
    launched and off the ground. The launch of the platform used the crowdfunding
    approach and took bitcoin in exchange for ether. The fundraising started in mid-2014
    and approximately 60 million (actually 60,102,216 ETH) ether units were issued
    at the price of 1,000–2,000 ether per bitcoin (BTC). Of the total amount sold,
    9.9 percent were allocated to the organization to compensate early contributors
    and pay ETH-denominated expenses before the genesis block on July 30, 2015\. Another
    9.9 percent of the total amount sold will be maintained as a long-term reserve.
    This means that the total amount released prior to the launch was close to 72
    million. The bitcoin received from the sale was used to pay salaries/bounties
    to developers and invested into various for-profit and nonprofit projects in the
    blockchain ecosystem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币（ETH）最初发行是为了启动以太坊项目和平台。平台的启动采用了众筹方法，以比特币换取以太币。众筹始于2014年年中，大约有6000万（实际上是60,102,216
    ETH）以太币单位以每比特币（BTC）1,000-2,000以太币的价格发行。出售的总额中，9.9％分配给组织，以补偿早期贡献者，并在2015年7月30日的创世区块之前支付以ETH计价的费用。出售总额中的另外9.9％将作为长期储备维持。这意味着在启动前的总发行量接近7200万。出售所得的比特币用于支付开发人员的工资/赏金，并投资于区块链生态系统的各种盈利和非盈利项目。
- en: Post-Genesis Block
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创世区块后
- en: Once the Ethereum platform was launched, the way to issue ether was defined
    and set in order to secure the future success and health of the platform. It was
    defined that the ether units to be released per year will be 26 percent of the
    initial 60 million raised during the fundraising phase. Ether is issued at a rate
    of 5 ETH per block on a blocktime target of 12 seconds. This means that the amount
    of ether released per year will be a constant 15.6 million ether units, and so
    by July 2020 around 52 percent of the total currency issued will have been mined.
    See Figure 5-1 for a depiction of the issuance model (at launch) at per year for
    the first five years.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊平台一旦启动，发行以太币的方式就被确定并设定，以确保平台的未来成功和健康发展。规定每年释放的以太币单位将是筹集资金阶段最初筹集的6000万个的26%。以太币的发行速度为每个区块5
    ETH，目标区块时间为12秒。这意味着每年释放的以太币数量将是一个固定的1560万个，所以到2020年7月，大约有52%的总量将被挖出。见图 5-1 描述的以太币发行模型（在启动时）第一五年每年。
- en: '![Images](fig5-1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig5-1.jpg)'
- en: '**FIGURE 5-1   Ether (ETH) issuance model**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-1   以太坊（ETH）发行模型**'
- en: The issuance model for ether is similar to bitcoin, where the inflation is front
    loaded into the first few years and deflation occurs down the road. The big difference
    is that bitcoin is capped and no further issuance will occur. This may not matter
    as much given the Bitcoin Cash (BCC) spinoff, but with ether there will continue
    to be an issuance of 15.6 million units each and every year, which is marginal
    but nonetheless an increase in the fuel supply.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的发行模式与比特币相似，通货膨胀在前几年被前置，之后会出现通货紧缩。一个大区别是比特币是有限的，不会再发行。鉴于比特币现金（BCC）的分拆，这可能不那么重要，但以太坊每年将继续发行1560万单位，这是一个边缘但无可否认的燃料供应增加。
- en: Obtaining Ether
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取以太币
- en: There are multiple options to obtain ether, the fuel that drives transactions
    in Ethereum. You can
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 获取以太坊燃料（以太）有多种方法，你可以
- en: 1.   Buy it
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 购买它
- en: 2.   Mine it
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 挖矿它
- en: 3.   Accept it as payment
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 接受它作为支付
- en: In terms of mining, this can be done within a private environment or on the
    public test network (testnet). This is simple enough, but to mine within the production
    live environment (mainnet) requires significant dedicated GPU time and horsepower
    set up locally and connected to the Internet or to similarly powerful infrastructure
    available in the cloud (e.g., AWS, GCP, Azure, etc.). To purchase ether you will
    need to get it via an exchange. As different regions have different exchanges,
    you will need to perform a search in order to find the latest and greatest information
    on the best exchange for you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖矿方面，这可以在私人环境内或公共测试网络上（testnet）完成。这很简单，但在生产环境中（mainnet）挖矿需要大量的本地 GPU 时间和高性能，并连接到互联网或云中类似强大的基础设施（例如
    AWS、GCP、Azure 等）。要购买以太币，你需要通过交易所获取。由于不同地区有不同的交易所，你需要进行搜索以找到关于最适合你的最佳交易所的最新和最佳信息。
- en: Mining in Ethereum
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊的挖矿
- en: The Ethereum blockchain is similar to the blockchain for Bitcoin. The main differences
    are in the design of the blocks. The Ethereum blocks contain a copy of both the
    transaction list and the most recent state (see Figure 5-2). The Ethereum blocks
    also contain values for the block number and the difficulty.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链与比特币的区块链类似。主要区别在于区块的设计。以太坊区块包含交易列表和最近状态的副本（见图 5-2）。以太坊区块还包含块号和难度值。
- en: '![Images](fig5-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图像](fig5-2.jpg)'
- en: '**FIGURE 5-2   Ethereum blockchain transaction list and state**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-2   以太坊区块链交易列表和状态**'
- en: 'In its basic form, the Ethereum validation algorithm is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊验证算法的最基本形式如下：
- en: '1.   Check the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 检查以下内容：
- en: •   Prior block reference exists and is valid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • 先前块的引用存在且有效。
- en: •   Timestamp of the current block is later than the prior block referenced
    and also less than 15 minutes later than the prior block timestamp.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: • 当前块的时间戳晚于先前引用的块，并且比先前块的时间戳晚于15分钟。
- en: •   The block number, difficulty, transaction root, uncle root, and gas limit
    are valid.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: • 块号、难度、交易根、叔父根和燃料限制有效。
- en: •   The proof-of-work on the block is valid.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: • 块上的工作量证明有效。
- en: •   If any of the above is not true, then return an error.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果上述任何一点不正确，则返回一个错误。
- en: 2.   Set the zero-index state (i.e., S[0])equal to the state at the end of the
    previously referenced block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将零索引状态（即 S[0]）设置为先前引用块的末尾状态。
- en: 3.   Set TX list equal to the block’s list ofn transactions. Loop through the
    transaction list and apply the transaction to the appropriate state, i.e., for
    all i in 0...n-1, set S[i+1] = APPLY(S[i],TX[i]). If any call to APPLY returns
    an error, or if the total gas consumed in the block up until this point exceeds
    the GASLIMIT, return an error.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将 TX 列表设置为块的 n 个交易列表。遍历交易列表并将交易应用于适当的状态，即对于所有 i 在 0...n-1，设置 S[i+1] = APPLY(S[i],TX[i])。如果任何对
    APPLY 的调用返回一个错误，或者如果块到目前为止消耗的总燃料超过了 GASLIMIT，返回一个错误。
- en: 4.   Set S_FINAL equal toS[n], but adding the block reward paid to the miner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将 S_FINAL 设置为 S[n]，但向矿工支付的区块奖励。
- en: 5.   Verify that the Merkle tree root of the state S_FINAL is equal to the final
    state root provided in the block header. If it is, the block is valid; otherwise,
    it is not valid.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 验证状态 S_FINAL 的 Merkle 树根是否等于块头中提供的最终状态根。如果是，则区块有效；否则，无效。
- en: It is important to note that while it looks like the entire state is stored
    with each block—an inefficient use of storage—this isn’t so in reality. The states
    are stored in a tree structure, and after every block only a minority of the tree
    needs to be changed. Typically between two adjacent blocks the majority of the
    tree will be the same, and an optimization opportunity and technique is utilized.
    The data can be stored once and referenced twice using pointers (i.e., hashes
    of subtrees). This concept and approach with a tree is known as a Patricia tree.
    This combined with a modified Merkle tree allows for nodes to be inserted, deleted,
    and changed very efficiently. On the storage front, because all of the state information
    is part of the last block, there is no need to store the entire blockchain history,
    which results in a 5–20x savings in space when compared to the approach that Bitcoin
    uses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然看起来整个状态都会随着每个区块存储——这是一种存储效率低下的使用方式——实际上并非如此。状态存储在一个树状结构中，每过一个区块只有树中的少数部分需要改变。通常在两个相邻区块之间，树的大部分将会相同，从而提供了优化机会和技术。数据可以一次存储并两次通过指针引用（即子树散列值）。这种在树上的概念和方法被称为帕特里夏树。这结合了修改后的默克尔树，使得节点可以非常高效地插入、删除和更改。在存储方面，由于所有状态信息都是最后一个区块的一部分，因此无需存储整个区块链历史，与比特币使用的做法相比，这可以在空间上节省5-20倍。
- en: A frequently asked question is where or when the code contained in a contract
    gets executed. The answer is that the execution of contract code is part of the
    definition of the state transition function (see later in this chapter), which
    is part of the block validation algorithm. Therefore when a transaction is added
    into a block, the code execution spawned by that very transaction will be executed
    by all nodes when they download and validate that same block.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题是智能合约中的代码将在哪里或何时执行。答案是智能合约代码的执行是状态转换函数定义（在本章后面部分将详细介绍）的一部分，而状态转换函数是区块验证算法的一部分。因此，当一个交易被添加到一个区块中时，由该交易触发的代码执行将在所有节点下载并验证同一个区块时执行。
- en: GHOST Implementation
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 幽灵实现（GHOST）
- en: The Greedy Heaviest Observed SubTree (or GHOST) protocol was introduced in 2013
    to blockchain platforms to combat the way that quick-blocktime blockchains, like
    Ethereum, suffer from a high frequency of stale blocks. Stale blocks are those
    that were propagated to the network and verified by some nodes as being correct
    but are eventually discarded because later, chronologically speaking, blocks get
    mined and propagated before the earlier ones do.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心观察最重子树协议（Greedy Heaviest Observed SubTree，简称GHOST）于2013年引入区块链平台，旨在解决快速区块时间的区块链（如以太坊）高频率产生无效区块的问题。无效区块是那些被传播到网络并被一些节点验证为正确，但最终因为更晚产生的区块先被挖出和传播而被抛弃的区块。
- en: The GHOST protocol also combats the issue known as centralization bias—an example
    of which is, if miner X is a mining pool with 35 percent hash power and miner
    Y has 15 percent hash power, miner X will have a risk of producing a stale block
    65 percent of the time and miner Y will have a risk of producing a stale block
    85 percent of the time. So, if the block interval is short enough for the stale
    rate to be high, miner X will be substantially more efficient than miner Y simply
    by virtue of their pool size. In other words, the larger the pool and the smaller
    the block interval, the more often they are going to get a head start on other
    miners by producing the block themselves and then immediately starting the race
    for the next block.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幽灵协议也解决了被称为中心化偏差的问题——一个例子是，如果矿工X是一个拥有35%算力的矿池，而矿工Y有15%的算力，矿工X产生无效区块的风险将有65%的时间，而矿工Y将有85%的时间。因此，如果区块间隔足够短，使得无效率很高，矿工X仅仅凭借其矿池的大小就会比矿工Y有效得多。换句话说，矿池越大，区块间隔越短，他们就越有可能通过自己生产区块并立即开始下一区块的比赛，从而在其他矿工之前获得先机。
- en: With these two effects combined, blockchains producing blocks very quickly are
    highly likely to lead to a consolidated mining pool with a large enough percentage
    of the network hash power to take over the mining process. In Bitcoin, the probability
    of finding a block at the same time is more likely because the blocktime is 10
    minutes and propagating a block to 50 percent of the network takes approximately
    12 seconds. But in Ethereum, which has a much shorter blocktime (the target being
    12 seconds), there is a need to reduce the incentive for pooled mining. This is
    where GHOST comes in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种效果结合在一起，导致区块生产速度非常快的区块链很可能导致一个集中的矿池，拥有足够大的网络哈希功率百分比，从而接管挖矿过程。在比特币中，同时找到一个块的概率更高，因为块时间是10分钟，将块传播到网络的50%大约需要12秒。但在以太坊中，块时间更短（目标为12秒），需要减少池化挖矿的激励。这就是GHOST发挥作用的地方。
- en: GHOST solves the first issue of network security loss by including stale blocks
    in the calculation of which chain is the “longest.” So the longest chain does
    not just take into account the parent and further ancestors of a block, but also
    the stale descendants of the block’s ancestors (“uncles”) are added to the calculation
    of which block has the largest total proof-of-work backing it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: GHOST通过在计算哪条链是“最长”时包含过期区块来解决网络安全性损失的第一个问题。所以最长链不仅考虑块的父节点和更远的祖先，还包括块祖先的过期后代（“叔叔”）在计算哪个区块有最大的总工作量证明支持。
- en: GHOST solves the second issue of centralization bias by providing block rewards
    to stales. In Ethereum a stale block receives 87.5 percent of its base reward,
    and the nephew (child of the uncle) that includes the stale block receives the
    remaining 12.5 percent. Transaction fees, however, are not awarded to uncles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GHOST通过为过期区块提供区块奖励来解决中心化偏好的第二个问题。在以太坊中，过期区块获得其基础奖励的87.5%，而侄节点（叔叔节点的子节点）将获得剩余的12.5%。然而，交易费用不会授予叔叔节点。
- en: The Ethereum version of GHOST is a simplified version that only goes down (or
    back) seven levels of the block chain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊版本的GHOST是一个简化版本，只向下（或回溯）七层区块链。
- en: •   A block must specify a parent and its number of uncles (zero or more).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: •   区块必须指定一个父节点及其叔叔节点数（零个或多个）。
- en: '•   An uncle included in a block must have the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: •   区块中包含的每个叔叔节点必须具备以下特性：
- en: •   It must be a direct child of the new block and less than seven blocks below
    it in terms of height.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: •   它必须是新区块的直接子节点，并且在高度上不超过七个区块。
- en: •   It cannot be the direct ancestor of the block being formed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: •   它不能是正在形成的区块的直接祖先。
- en: •   It must be a valid block header; it does not have to be a pre-verified or
    even a valid block.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: •   它必须是一个有效的区块头；它不必是预验证甚至是有效的区块。
- en: •   It must be different from all uncles included in previous blocks and all
    other uncles included in the same block (non-double-inclusion).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: •   它必须与之前的区块中的所有叔叔节点以及同一区块中的其他叔叔节点不同（非重复包含）。
- en: •   For every uncle included in the block, the miner gets an additional 3.125
    percent and the miner of the uncle receives 93.75 percent of a standard block
    reward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: •   对于区块中包含的每个叔叔节点，矿工将获得额外的3.125%奖励，叔叔节点的矿工将获得标准区块奖励的93.75%。
- en: This restricted version of GHOST (uncles includable only back seven generations)
    is used in Ethereum for two reasons. First, having an unlimited number of levels
    would include too many complications into the calculation of which uncles for
    a given block are valid. Second, unlimited levels with compensation removes the
    incentive for a miner to mine on the main chain as opposed to the chain of a malicious
    actor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GHOST的简化版本（仅回溯七代才能包含叔叔节点）在以太坊中有两个用途。首先，如果层数无限，就会使计算给定区块中哪些叔叔节点有效变得过于复杂。其次，无限层级加上补偿会消除矿工相对于恶意行为者的链进行采矿的激励。
- en: How Fees Protect
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 费用如何保护
- en: Every transaction that is published to the blockchain needs to be downloaded
    and verified by the network nodes. This feature (or burden) needs to be regulated
    in some way to prevent waste and abuse. In Bitcoin, the default approach is to
    have voluntary fees, where the miners set minimum fees and act as the gatekeepers.
    This market-driven approach uses the supply of miners and demand of transaction
    senders to make a market for the fee. But the issue here is that transaction processing
    on a blockchain is not a true market because it is not as simple as a single miner
    providing a transaction-processing service to a single sender. In actuality, every
    transaction that the miner includes in a validated and committed block needs to
    be processed by every node in the blockchain network. This means that the majority
    of the cost of processing a transaction is spread to the whole network, while
    it is the miner that makes the decision to include it or not that gets the reward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将交易发布到区块链时，网络节点都需要下载并验证这些交易。这一特性（或负担）需要以某种方式进行规范，以防止浪费和滥用。在比特币中，默认的方法是自愿费用，矿工设定最低费用并充当看门人。这种市场驱动的方法利用矿工的供应和交易发送者的需求来形成费用市场。但问题是，区块链上的交易处理不是一个真正的市场，因为它不像一个矿工为单个发送者提供交易处理服务那么简单。实际上，矿工在验证并提交的区块中包含的每个交易都需要区块链网络中的每个节点进行处理。这意味着交易处理的大部分成本都分摊到整个网络，而决定是否包含该交易的矿工则获得奖励。
- en: Mining Issues
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 挖矿问题
- en: The mining algorithm in the Bitcoin network has the verifying nodes (miners)
    compute a SHA256 calculation on slightly modified versions of the block header.
    Simultaneously repeating this calculation millions of times over and over again,
    eventually one miner comes up with a version whose hash is less than the target.
    This presents a vulnerability to two forms of centralization. Let’s examine this
    further.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络中的挖矿算法要求验证节点（矿工）对区块头的小幅修改版本进行SHA256计算。同时，这些节点会反复进行数百万次的计算，最终某个矿工会找到一个散列值低于目标的版本。这为两种形式的中心化提供了漏洞。让我们进一步探讨这个问题。
- en: '**Centralization** The first issue is that the hardware that the miners used
    became dominated by ASICs (application-specific integrated circuits). These are
    computer chips designed to be much more efficient at Bitcoin mining. By definition
    this stopped making mining a level playing field and meant that it became necessary
    to invest higher amounts in order to buy these specialized chips in order to compete.
    The second issue is that most Bitcoin miners do not actually perform block validation
    locally; they use a centralized mining pool to provide them with the block headers.
    The word “centralized” in the mining pool name should give it away, but in any
    case there is potentially a much worse problem than the specialized chip issue.
    The top three mining pools are all in China, and they indirectly control roughly
    50 percent of processing power in the Bitcoin network. The miners still have the
    ability to switch mining pools, and this does present a mitigation strategy in
    the event of collusion when a pool or coalition attempts a 51 percent attack.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心化** 第一个问题是，矿工使用的硬件被ASICs（应用特定集成电路）所主导。这些计算机芯片被设计为在比特币挖矿方面更加高效。按照定义，这使得挖矿不再是公平竞争的领域，这意味着为了竞争，有必要投入更多资金来购买这些专用芯片。第二个问题是，大多数比特币矿工实际上并不在本地下perform块验证；他们使用中心化的挖矿池来提供块头。挖矿池名称中的“中心化”一词应该能揭示问题，但无论如何，与专用芯片问题相比，这里可能存在一个更糟糕的问题。最大的三个挖矿池都在中国，它们间接控制着比特币网络大约50％的处理能力。矿工仍然有能力切换挖矿池，这在池或联盟尝试51％攻击时确实提供了一种缓解策略。'
- en: '**Ethereum Handles Centralization** Ethereum is set up to use an algorithm
    where miners are required to fetch random data from the state, compute some randomly
    selected transactions from the prior N blocks in the blockchain, and return the
    hash of the result. This has a couple of benefits. First, smart contracts can
    include any kind of computation, so an Ethereum ASIC would essentially be a CPU
    for general computation, or GPU. Second, mining in Ethereum requires access to
    the entire blockchain, forcing miners to store the entire blockchain and at least
    be capable of verifying every transaction. This more importantly removes the need
    for centralized mining pools and the risk and issue of centralization.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊处理集中化** 以太坊设置为使用一种算法，矿工需要从状态中获取随机数据，计算之前N个区块链块中随机选择的交易，并返回结果的哈希。这有两个好处。首先，智能合约可以包括任何类型的计算，因此以太坊ASIC本质上是一个CPU或GPU。其次，以太坊的挖矿需要访问整个区块链，迫使矿工存储整个区块链，至少能够验证每笔交易。更重要的是，这消除了对集中挖矿池的需求和集中化的风险和问题。'
- en: Ethereum Work
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊工作
- en: Ethereum has essentially one way for work to begin and that is via a transaction.
    A transaction in Ethereum is a cryptographically signed data packet that contains
    a message sent from an externally owned account. Let’s take a closer look at the
    transaction and message objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊本质上只有一种工作开始的方式，那就是通过交易。以太坊中的交易是一个经过加密签名的数据包，其中包含从外部账户发送的消息。让我们更深入地看看交易和消息对象。
- en: Transactions
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易
- en: 'There are essentially three types of transactions that can be found on Ethereum:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上在以太坊上有三种交易类型：
- en: •   A transfer of value from one entity to another
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个实体到另一个实体的价值转移
- en: •   The creation of a smart contract
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的创建
- en: •   The invocation of a smart contract
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的调用
- en: 'A transaction is made up of attributes, or fields, which are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交易由属性或字段组成，这些是：
- en: •   **From**   A signed address for the sending account. It is signed in order
    to prove that the sender intended to send the transaction to the recipient.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自**   发送账户的已签名地址。它被签名，以证明发送者有意将交易发送给接收者。'
- en: •   **To**   The destination address of the transaction, this is left undefined
    for a transaction that creates a contract.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**至**   交易的目的地地址，对于创建合约的交易，这个地址是不定义的。'
- en: •   **Value**   The amount of value to be transferred (always expressed in wei).
    For a transaction that creates a contract this field will typically hold the endowment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**值**   要转移的价值量（总是以wei表示）。对于创建合约的交易，此字段通常将持有资金。'
- en: •   **Gas**   This is sometimes referred to as the Start Gas field. It is the
    amount of fuel to use for the transaction and represents the maximum number of
    computational steps for the transaction. Any unused fuel will be refunded to the
    sender. See more on this field below.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**燃料**   有时被称为开始燃料字段。这是用于交易的燃料量，代表交易的最大计算步骤数。任何未使用的燃料将退还给发送者。关于此字段请参考下文。'
- en: •   **Gas Price**   The price of gas for this transaction (specified in wei—more
    on this later in the chapter). This defaults to the mean network fuel price and
    represents the fee the sender pays per computational step. See more on this field
    below.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gas价格**   此交易的燃料价格（以wei为单位——本章后面会详细介绍）。这默认为网络平均燃料价格，表示发送者每执行一个计算步骤支付的费用。关于此字段请参考下文。'
- en: •   **Data**   This can be omitted or defined as a byte string containing data
    for the message. For a transaction that creates a contract, this may contain the
    initialization logic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**   这个字段可以省略，或者定义为一个包含消息数据的字节字符串。对于创建合约的交易，这可能包含初始化逻辑。'
- en: •   **Nonce**   This can be used to overwrite pending transactions that use
    the same nonce.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nonce**   这个字段可以用来覆盖使用相同nonce的待处理交易。'
- en: As you can see, the first three fields are those that are needed for any financial
    transaction that transfers value. The Data field has many purposes depending on
    the type of transaction—as we’ve already mentioned this can be initialization
    logic or data. It all depends on what is needed to fulfill the transaction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前三个字段是任何转移价值的金融交易所需的。数据字段根据交易类型有许多用途——如我们前面提到的，这可以是初始化逻辑或数据。这取决于完成交易需要什么。
- en: Network Fuel (Gas)
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络燃料（燃料）
- en: In order to process transactions there needs to be sufficient fuel (ether) in
    the account from which the transactions are being sent. Ether is needed to pay
    the execution cost for the Ethereum client that performs the transaction work
    on behalf of the sender, committing the result to the Ethereum blockchain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理交易，发送交易账户中需要有足够的燃料（以太币）。以太币是用来支付执行交易的以太坊客户端的费用，并为发送者将结果提交到以太坊区块链。
- en: Interestingly, it is the Gas and Gas Price attributes on the transaction that
    are key components to the denial-of-service (DoS) prevention design built into
    the Ethereum network. To combat infinite loops or computational waste (whether
    intentional or not), each transaction is required to specify a limit to the number
    of computational steps a transaction can take to complete. The unit of computation
    in Ethereum is known as gas, and each operation in Ethereum has an associated
    gas cost that depends on how intensive it is from a computing power perspective
    (see [Table 5-3](ch5.xhtml#ch5tab3) for the gas cost associated with the majority
    of Ethereum’s opcodes/instructions).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，交易中的燃料（Gas）和燃料价格（Gas Price）属性是内置到以太坊网络中的拒绝服务（DoS）预防设计的的关键组成部分。为了对抗无限循环或计算浪费（无论是有意还是无意），每个交易都必须指定一个限制，即交易可以完成的最大计算步骤数。以太坊中的计算单位被称为燃料，以太坊中的每个操作都有与之相关的燃料成本，这取决于它从计算能力角度有多密集（有关以太坊大多数操作码/指令的燃料成本，请参见[表5-3](ch5.xhtml#ch5tab3)）。
- en: '**TABLE 5-3** **Ethereum Opcode (Instruction) Cost**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-3** **以太坊操作码（指令）成本**'
- en: '![Images](tab5-3.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab5-3.jpg)'
- en: '![Images](tab5-3a.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab5-3a.jpg)'
- en: '![Images](tab5-3b.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab5-3b.jpg)'
- en: Some operations cost higher amounts of gas simply because they are computationally
    resource intensive. In addition to compute power fee, there is also a fee of 5
    gas for every byte in the transaction data. As we’ve stated earlier, the intent
    of the fee structure in this model is to ensure that senders pay proportionately
    for every resource consumed, be it computation, bandwidth, and/or storage. So
    it stands to reason that resource-intensive contracts and messages must have an
    appropriately proportionate gas fee.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作消耗更多的燃料（Gas）是因为它们在计算资源上非常密集。除了计算力费用之外，交易数据中的每个字节还必须支付5个燃料费。如我们之前所述，这种模型中费用结构的意图是确保发送者按比例支付每个使用的资源，无论是计算力、带宽还是存储。因此，资源密集型的合约和消息必须有一个与之成比例的燃料费。
- en: Messages
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息
- en: 'An Ethereum contract has the ability to send a message to another contract
    (it can do this multiple times). A transaction initiated by an externally owned
    account can contain values in the Data field that will go into a message. Within
    Ethereum a message is a virtual object that is never serialized per se and exists
    within the execution environment only. It is made up of the following fields:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊合约有能力向另一个合约发送消息（可以多次进行）。由外部账户发起的交易可以在数据字段中包含值，这些值将传递给消息。在以太坊中，消息是一个虚拟对象，本身永远不会被序列化，只存在于执行环境中。它由以下字段组成：
- en: •   **Sender**   The sender of the message (implicit)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **发送者（Sender）**   消息的发送者（隐含）'
- en: •   **Recipient**   The recipient of the message
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **接收者（Recipient）**   消息的接收者'
- en: •   **Amount**   The amount of ether to transfer alongside the message
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **金额（Amount）**   与消息一起传输的以太币数量'
- en: •   **Data (optional)**   An optional data field
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **数据（可选）（Data (optional)）**   一个可选的数据字段'
- en: •   **Start Gas**   A value
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **开始燃料（Start Gas）**   一个值'
- en: As you can see, essentially a message is very similar to a transaction. The
    difference is that it is produced by a contract and not an external actor (although
    it can be caused by one). When the code inside a contract executes and calls the
    `CALLopcode` function, it creates and executes a message. Similar to a transaction,
    the message is sent to the recipient account running its code. So you can see
    that contracts can interact with other contracts the same way that external actors
    accounts can. An important thing to note is that the gas allowance specified by
    a contract or transaction is the governing amount for the transaction and any
    and all dependent executions. So, for example, if account A sends (commits) a
    transaction to account B with 100 gas, B performs operations that consume 70 gas
    and then sends a message to C. C then performs operations that consume 25 gas
    before returning. Then B can use another 5 gas before running out of fuel (Out-of-Gas
    exception).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，本质上消息非常类似于交易。区别在于它是由智能合约生成的，而不是外部参与者（尽管它可以由一个外部参与者触发）。当智能合约内的代码执行并调用`CALLopcode`函数时，它创建并执行一个消息。与交易类似，该消息被发送到运行其代码的接收方账户。因此，你可以看到智能合约与其他合约的交互方式与外部参与者账户的交互方式是一样的。需要注意的是，智能合约或交易指定的燃料限制是交易及其所有依赖执行的主导金额。所以，例如，如果账户A向账户B发送（提交）一个带有100燃料的交易，B执行消耗70燃料的操作，然后向C发送一个消息。C在返回之前执行消耗25燃料的操作。然后B可以在耗尽燃料之前（耗尽燃料异常）再使用5燃料。
- en: The Ethereum Block
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊区块
- en: The block in Ethereum is the collection of relevant pieces of information (known
    as the block header), H, together with information corresponding to the comprised
    transactions, T, and a set of other block headers, U, that are known to have a
    parent equal to the present block’s parent’s parent (such blocks are known as
    ommers2).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的区块是相关信息的集合（称为区块头部），H，以及与包含的交易对应的信息，T，以及一组其他区块头部，U，这些区块头部已知其父节点等于当前区块父节点的父节点（这样的区块被称为ommers2）。
- en: 'Below are the fields that exist in the block header:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在区块头部存在的字段：
- en: •   **parentHash**   The Keccak 256-bit hash of the parent block’s header, in
    its entirety; formally Hp.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: •   **parentHash**   该区块父区块头的整个Keccak 256位哈希值；正式表示为Hp。
- en: •   **ommersHash**   The Keccak 256-bit hash of the ommers list portion of this
    block; formally Ho.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: •   **ommersHash**   该区块ommers列表部分的Keccak 256位哈希值；正式表示为Ho。
- en: •   **beneficiary**   The 160-bit address to which all fees collected from the
    successful mining of this block are transferred; formally Hc.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: •   **beneficiary**   所有从成功挖出此区块中收取的费用转到的160位地址；正式表示为Hc。
- en: •   **stateRoot**   The Keccak 256-bit hash of the root node of the state trie
    (Merkle Patricia Tree or radix tree), after all transactions are executed and
    finalizations applied; formally Hr.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: •   **stateRoot**   在所有交易执行并应用最终确定后，状态trie（Merkle Patricia Tree或基数树）的根节点的Keccak
    256位哈希值；正式表示为Hr。
- en: •   **transactionsRoot**   The Keccak 256-bit hash of the root node of the trie
    structure populated with each transaction in the transactions list portion of
    the block; formally Ht.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: •   **transactionsRoot**   该区块交易列表部分的trie结构根节点的Keccak 256位哈希值；正式表示为Ht。
- en: •   **receiptsRoot**   The Keccak 256-bit hash of the root node of the trie
    structure populated with the receipts of each transaction in the transactions
    list portion of the block; formally He.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: •   **receiptsRoot**   该区块交易列表部分填充的每个交易收据的trie结构根节点的Keccak 256位哈希值；正式表示为He。
- en: •   **logsBloom**   The Bloom filter composed from indexable information (logger
    address and log topics) contained in each log entry from the receipt of each transaction
    in the transactions list; formally Hb.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: •   **logsBloom**   由包含在每笔交易收据中的每个日志条目中的可索引信息（日志器地址和日志主题）组成的Bloom过滤器；正式表示为Hb。
- en: •   **difficulty**   A scalar value corresponding to the difficulty level of
    this block. This can be calculated from the previous block’s difficulty level
    and the timestamp; formally Hd.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: •   **difficulty**   与该区块难度级别相对应的标量值。这可以从上一个区块的难度级别和时间戳计算得出；正式表示为Hd。
- en: •   **number**   A scalar value equal to the number of ancestor blocks. The
    genesis block has a number of zero; formally Hi.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: •   **number**   等于祖先区块数量的标量值。创世区块的编号为零；正式表示为Hi。
- en: •   **gasLimit**   A scalar value equal to the current limit of gas expenditure
    per block; formally Hl.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: •   **gasLimit**   等于每块燃料消耗限制的标量值；正式表示为Hl。
- en: •   **gasUsed**   A scalar value equal to the total gas used in transactions
    in this block; formally Hg.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: •   **gasUsed**   等于在此区块中交易中使用的总gas的标量值；正式地，Hg。
- en: •   **timestamp**   A scalar value equal to the reasonable output of Unix’s
    time() at this block’s inception; formally Hs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: •   **时间戳**   一个与该区块创建时Unix时间()的合理输出相等的标量值；正式地，Hs。
- en: •   **extraData**   An arbitrary byte array containing data relevant to this
    block. This must be 32 bytes or fewer; formally Hx.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: •   **extraData**   包含与该区块相关的数据的任意字节数组。这个必须不超过32个字节；正式地，Hx。
- en: •   **mixHash**   A 256-bit hash that proves, combined with the nonce, that
    a sufficient amount of computation has been carried out on this block; formally
    Hm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: •   **mixHash**   一个证明与nonce结合，在该区块上进行了足够计算的256位哈希；正式地，Hm。
- en: •   **nonce**   A 64-bit hash that proves, combined with the mix-hash, that
    a sufficient amount of computation has been carried out on this block; formally
    Hn.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: •   **nonce**   一个证明与mix-hash结合，在该区块上进行了足够计算的64位哈希；正式地，Hn。
- en: The other two components in the block are simply a list of block headers (of
    the same format as above) and a series of the transactions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 区块中的其他两个组件简单地说就是一个区块头的列表（与上面相同的格式）和一个交易系列。
- en: State Transition Function (STF)
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态转换函数（STF）
- en: As with Bitcoin and other cryptocurrencies, the ledger of Ethereum is essentially
    the result of a state transition function (STF), which takes the state of the
    network prior to a transaction and, upon executing the transaction, produces a
    new state as the result. See Figure 5-3 for a graphical depiction of Ethereum
    state transition function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币和其他加密货币一样，以太坊的账本本质上是一个状态转换函数（STF）的结果，该函数在交易执行前获取网络状态，并执行交易后产生新的状态作为结果。参见图5-3以太坊状态转换函数的图形描述。
- en: '![Images](fig5-3.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图像](fig5-3.jpg)'
- en: '**FIGURE 5-3   Ethereum state transition function (STF)**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5-3  以太坊状态转换函数（STF）**'
- en: 'The specifics of the Ethereum STF (i.e., APPLY(S,TX) -> S’) are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊STF（即APPLY(S,TX) -> S’）的具体内容如下：
- en: '1.   Check the following, and if any are not true, then return an error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   检查以下内容，如果任何不正确，则返回错误：
- en: •   Transaction is well-formed and has the correct number of values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: •   交易格式正确且值的数量正确。
- en: •   Signature is valid.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: •   签名是有效的。
- en: •   Nonce matches the nonce in the sender’s account.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: •   非once与发送者账户中的nonce匹配。
- en: •   If any of the above is not true, return an error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: •   如果以上任何一点不正确，则返回错误。
- en: 2.   Calculate the fee for the transaction as Start Gas * Gas Price, and derive
    the sender’s account address from the signature. Subtract the calculated transaction
    fee from the sender’s account balance and increment the sender’s nonce. In the
    event that there is an insufficient amount in the sender’s account, return an
    error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   计算交易的费用为Start Gas * Gas Price，并从签名中推导出发送者账户地址。从发送者的账户余额中减去计算的交易费用，并增加发送者的nonce。如果发送者账户中金额不足，则返回错误。
- en: 3.   Initially set Gas equal to Start Gas, and take off a certain quantity of
    gas per byte to pay for the bytes in the transaction (this is the storage fee).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   最初将Gas设置为Start Gas，并从中扣除一定数量的gas来支付交易中的字节（这是存储费用）。
- en: 4.   Transfer the transaction value from the sender’s account to the receiving
    account. If the receiving account does not yet exist, create it. If the receiving
    account is a contract, run the contract’s code either to completion or until the
    execution runs out of gas (Out-of-Gas exception).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   将交易值从发送者账户转移到接收账户。如果接收账户尚不存在，则创建它。如果接收账户是一个合约，则运行合约代码，直到执行耗尽燃料（Out-of-Gas异常）。
- en: 5.   If the value transfer failed because the sender did not have enough money,
    or the code execution ran out of gas, revert all state changes except the payment
    of the fees, and add the fees to the miner’s account. Otherwise, refund the fees
    for all remaining gas to the sender, and send the fees paid for gas consumed to
    the miner.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   如果价值转移失败，是因为发送者没有足够的钱，或者代码执行耗尽了燃料，那么除了支付费用外，回滚所有状态更改，并将费用添加到矿工的账户中。否则，将剩余的所有燃料费用退还给发送者，并将消耗燃料的费用发送给矿工。
- en: 'Now let’s work through an example. Suppose that a contract’s storage starts
    off empty, and a transaction is sent with 10 ether value, 4,000 gas, 0.001 ether
    gas price, and 32 bytes of data, with bytes 0–15 representing the number 4 and
    bytes 16–31 representing the string “`KITTEN-AND-WOLF`”. The process for the state
    transition function in this particular example is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过一个例子来工作。假设一个合同的存储开始为空，发送一个带有10个以太币价值，4000个气体，0.001个以太币气体价格和32个字节数据的交易，字节0-15表示数字4，字节16-31表示字符串“`KITTEN-AND-WOLF`”。在这个特定示例中的状态转换函数的过程如下：
- en: 1.   Check that the transaction is valid and well formed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 检查交易是否有效且格式正确。
- en: 2.   Check that the transaction sender has at least (4,000 * 0.001) 4 ether.
    If it does, then subtract 4 ether from the sender’s account.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 检查交易发送者至少有（4,000 * 0.001）4个以太币。如果有，那么从发送者的账户中减去4个以太币。
- en: 3.   Initialize gas = 4,000; assuming the transaction is 120 bytes long and
    the byte fee is 5, subtract 600 from the gas, and that will leave 3,400 gas remaining.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 初始化气体=4000；假设交易长度为120字节，字节费用为5，从气体中减去600，剩下的气体为3400。
- en: 4.   Subtract 10 more ether from the sender’s account, and add it to the contract’s
    account.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 从发送者的账户中再减去10个以太币，并添加到合同的账户中。
- en: 5.   Run the code. The code checks if the contract’s storage at index 4is used;
    if it is available, it sets the value to KITTEN-AND-WOLF. Imagine this takes 1,177
    gas, so the remaining amount of gas is 3,400 – 1,177 = 2,223.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码。代码检查合同存储在索引4处是否使用；如果可用，它将值设置为KITTEN-AND-WOLF。想象这需要1177个气体，所以剩余的气体为3400
    - 1177 = 2223。
- en: 6.   Refund (2,223 * 0.001) 2.223 ether back to the sender’s account, and return
    the resulting state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 退款（2,223 * 0.001）2.223个以太币回到发送者的账户，并返回结果状态。
- en: If there was no contract at the receiving end of the transaction, then the total
    transaction fee would simply be equal to the provided Gas Price multiplied by
    the length of the transaction in bytes, and the data sent with the transaction
    would be irrelevant. It is important to note that messages work the same way as
    transactions in terms of reverting—that is, if a message execution runs out of
    gas, the message’s execution and all dependent executions triggered by the execution
    will revert, but the parent executions do not need to. This makes it okay for
    a contract to call another contract, so if X calls Y with F gas then X’s execution
    is guaranteed to lose at most F gas. For the CREATE opcode, which is used to create
    a contract, its execution process is similar to the CALL opcode, except that the
    output of the execution determines the code (logic) of a newly created contract.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在交易的接收端有合同，那么总交易费用将简单地等于提供的气体价格乘以交易的字节长度，发送的交易数据将无关紧要。重要的是要注意消息在回滚方面与交易的方式相同——也就是说，如果一个消息执行耗尽了气体，消息的执行以及由执行触发的所有依赖执行都将回滚，但父执行不需要。这使得合同调用另一个合同是可以的，所以如果X用F个气体调用Y，那么X的执行保证最多损失F个气体。对于用于创建合同的CREATE操作码，其执行过程与CALL操作码类似，不同之处在于执行的结果确定了新创建合同的代码（逻辑）。
- en: Code Execution
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码执行
- en: 'The EVM code that is contained in Ethereum contracts is a low-level, stack-based
    bytecode language. The code is a series of bytes that represent operations. Typically,
    code execution inside the EVM is an infinite loop of carrying out the operation
    at the current program counter (i.e., index beginning at zero) and incrementing
    this counter by 1 until one of three things happens: end of code, an exception,
    a STOP or RETURN instruction is encountered. While the operation is executing,
    it has access to four areas for reading and in most cases storing of data:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum合同中的EVM代码是一种低级、基于栈的字节码语言。代码是一系列代表操作的字节。通常，在EVM中的代码执行是一个无限循环，执行当前程序计数器（即从零开始的索引）处的操作，并将此计数器加1，直到发生以下三种情况之一：代码结束，异常，遇到STOP或RETURN指令。在操作执行时，它有四个区域用于读取数据，在大多数情况下用于存储数据：
- en: •   **Stack**   This utilizes the LIFO (last-in-first-out) principle. Data is
    pushed to the top of the stack or data is popped from the top of the stack. This
    is reset when computation ends.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: • 栈 它采用LIFO（后进先出）原则。数据推送到栈顶或从栈顶弹出数据。计算结束时重置。
- en: •   **Memory**   This is an infinitely expandable byte array. This is reset
    when computation ends.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: • 内存 这是一个无限可扩展的字节数组。计算结束时会重置。
- en: •   **Storage** This is the contract’s key/value store. This persists when computation
    ends.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: •   **存储** 这是合约的键/值存储。它在计算结束后持久化。
- en: •   **Other**   The executing code can read the value, sender, and data of the
    message. It can also access the block header data and optionally return a byte
    array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: •   **其他**    执行代码可以读取消息的值、发送者和数据。它还可以访问区块头数据，并可选择返回一个字节数组。
- en: 'The EVM execution model is straightforward. While EVM is running, its complete
    computational state can be defined by the following tuple (collection or row)
    of data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机执行模型很简单。当EVM运行时，其完整的计算状态可以用以下数据元组（集合或行）来定义：
- en: '`block_state, transaction, message, code, memory, stack, pc, gas`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`block_state, transaction, message, code, memory, stack, pc, gas`'
- en: where `block_state` is the top-level or global state containing all accounts,
    including balances and the storage. At the beginning of every step of execution,
    the current instruction is found by taking the `pc` (Program Counter) byte of
    `code`(or 0 if `pc` is set to a value greater than the length of the `code` item),
    and each opcode (or instruction) has its own definition in terms of how it operates
    on the tuple. For example, the `ADD`operation pops two items off the top of the
    stack, adds them together, and pushes their sum value to the top of the stack.
    It then reduces `gas`by 3 and increments `pc`by 1, and `SSTORE`(save word to storage)
    pops the top two items off the top of the stack and inserts the second item into
    the contract’s storage at the index specified by the first item. It then reduces
    `gas`by 20,000 and increments `pc`by 1.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`block_state`是包含所有账户（包括余额和存储）的顶层或全局状态。在执行的每一步开始时，通过取`code`（或`pc`设置为一个大于`code`项目长度的值时为0）的`pc`（程序计数器）字节来找到当前指令，每个操作码（或指令）都有它自己的定义，定义了它是如何操作这个元组的。例如，`ADD`操作从栈顶弹出两个项目，将它们相加，并将它们的和值推送到栈顶。然后它将`gas`减少3，并将`pc`增加1，`SSTORE`（将单词保存到存储中）从栈顶弹出两个项目，并将第二个项目插入到由第一个项目指定的合约存储中的索引位置。然后它将`gas`减少20,000，并将`pc`增加1。
- en: Turing Complete
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图灵完备
- en: 'The Ethereum virtual machine (EVM) is said to be Turing complete. What does
    that mean? It means that the EVM code can encode any conceivable computation and
    this includes looping. There are two ways that the EVM code can loop. The first
    way the EVM can loop is via two direct instructions: JUMP, which allows the execution
    to jump back to a previous location in the code, and JUMPI, which allows the execution
    to carry out conditional jumping (using if/then/else or while statements). The
    second way the EVM can loop is through recursive calls. For example, contract
    A can call contract B, which in turn calls contract A, and so on. This presents
    a problem whereby a malicious actor on the network can effectively shut down nodes
    and the network’s associated mining by deploying contracts that contain logic
    that executes infinite loops. This issue is known in computer science as the halting
    problem, which is the inability to determine whether the program will finish running
    or continue to run forever. Ethereum deals with this issue using simple economics.
    When a transaction is committed to the blockchain, it contains a field, Gas (or
    Start Gas), that specifies the maximum number of computational steps that the
    transaction is allowed to take. Once this threshold is exceeded the computation
    is reverted, but the fees are still paid to the miner. The same mechanism is in
    place for messages. Let’s work through some malicious actor scenarios to see how
    the design of the Ethereum platform handles them.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）被认为是可以进行图灵完备计算的。这是什么意思呢？这意味着EVM代码可以编码任何可想象的计算，这包括循环。EVM代码循环有两种方法。第一种方法是使用两个直接指令：JUMP，它允许执行跳回到代码中的前一个位置，JUMPI，它允许执行带有if/then/else或while语句的条件跳转。第二种方法是通过递归调用。例如，合约A可以调用合约B，而合约B又可以反过来调用合约A，依此类推。这带来了一个问题，即网络上的恶意行为者可以部署包含无限循环逻辑的合约，从而有效地关闭节点和网络相关的挖矿。这个问题在计算机科学中被称为停机问题，即无法确定程序是否会完成运行还是永远运行下去。以太坊通过简单的经济学原理来解决这个问题。当一个交易被提交到区块链上时，它包含一个字段，Gas（或Start
    Gas），它指定了该交易可以执行的最大计算步骤数。一旦超过这个阈值，计算就会回滚，但矿工的费用仍然要支付。对于消息，同样的机制也适用。让我们通过一些恶意行为者的场景来看看以太坊平台是如何处理这些问题的。
- en: •   The malicious actor builds and deploys a contract that contains an infinite
    loop. They send a transaction that activates the loop. The miner processes the
    transaction, which kicks off the infinite loop. Even though it runs out of gas
    and stops before completing fully, the transaction is still considered valid from
    the miner’s perspective, and they claim the fee from the attacker for each computational
    step.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意参与者构建并部署了一个包含无限循环的合约。他们发送一个激活循环的交易。矿工处理该交易，启动无限循环。即使它在耗尽燃料前就停止了，从矿工的角度看，这个交易仍然被认为是有效的，他们会从攻击者那里收取每个计算步骤的费用。
- en: •   The malicious actor again tries to create a very long infinite loop forcing
    the miner to keep computing for a long time. By the time computation finishes,
    more blocks will have come out, and it will not be possible for the miner to include
    the transaction in the block they are processing in order to claim the fee. This
    is where the Start Gas field, which limits the number of computational steps an
    execution can take, will be need to be set sufficiently and unusually high, giving
    the miner sufficient clues to the malicious intent of the transaction and a chance
    to reject it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意参与者再次尝试创建一个非常长的无限循环，迫使矿工长时间进行计算。当计算完成时，将产生更多区块，矿工将无法将交易包含在他们正在处理的区块中，以收取费用。这时，启动燃料字段，限制执行可以采取的计算步骤数量，需要设置得足够高且不寻常，为矿工提供足够的线索来判断交易的恶意意图，并有机会拒绝它。
- en: '•   The malicious actor reviews contract code that is something like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意参与者审查的合约代码类似于：
- en: '`send(A, contract.storage[A]); contract.storage[A] = 0;`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`send(A, contract.storage[A]); contract.storage[A] = 0;`'
- en: The malicious actor sends a transaction with enough gas to run the first step
    only—in other words, to withdraw an amount. But the part that sets the amount
    to zero does not execute. The network (and specifically the contract author) does
    not need to be concerned about handling and protecting against such assaults,
    because when the transaction runs out of gas, the changes will be reverted. Note
    that the miner will still get paid the gas that was used to process the first
    instruction, so the malicious actor still pays.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意参与者发送了一个仅运行第一步的交易——换句话说，就是提取一定金额。但将金额设置为零的部分没有执行。网络（特别是合约作者）不需要担心处理和防范此类攻击，因为当交易耗尽燃料时，更改将被撤销。注意，矿工仍然会得到用于处理第一个指令的燃料费，所以恶意参与者仍然需要支付。
- en: •   A contract is created and deployed to work in the following way. It references
    seven data feeds and takes the average data value of the seven as a way to calculate
    a risk factor. A malicious actor finds a way to compromise one of the seven data
    feeds and changes its functionality so that it runs an infinite loop instead,
    the idea being to force any attempts to calculate a risk factor from the contract
    to run out of gas. However, the Ethereum feature of being able to set a gas limit
    on the message will prevent this scenario from causing a problem. Note that the
    function that combines the seven values into an average will still need to deal
    with one or more feeds from failing to respond and act appropriately.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并部署了一个按以下方式工作的合约。它引用了七个数据源，并取七个数据的平均值作为计算风险因子的方式。恶意参与者找到了一种妥协其中一个数据源的方法，并改变其功能，使其运行无限循环，从而迫使任何尝试从合约中计算风险因子的尝试耗尽燃料。然而，以太坊设置消息燃料限制的功能将防止这种情况造成问题。请注意，将七个值组合成平均值的功能仍然需要处理一个或多个数据源未响应的情况并做出适当反应。
- en: In short, the halting problem and associated Turing completeness are surprisingly
    easy to manage with the Ethereum design and architecture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，停机问题和相关的图灵完备性在以太坊的设计和架构下出奇地容易管理。
- en: Scalability
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可扩展性
- en: There is a concern about the scalability of the Ethereum platform. After all,
    it is based on blockchain, and the design is such that it has to replicate transactions
    and blocks to every node in the network, so just how scalable can it be? Let’s
    recap on what scalability is. It’s the capability of a system, network, or process
    to handle a growing amount of work, or its potential to be enlarged to accommodate
    that growth. At the time of writing, the Bitcoin blockchain size is around 159
    GB and can grow by 1 MB approximately every 10 minutes. If the Bitcoin network
    had to process one of the major credit card companies’ number of transactions
    it would potentially grow by 1 MB every 3 seconds or approximately 1 GB per hour
    or 8 TB per year. Each node would need to have some serious resource capabilities
    in order to process that amount of data at the speed necessary to handle the requests.
    The Ethereum blockchain size is 57 GB and would also suffer from the same growth
    pattern. It would be even more complicated by the fact that Ethereum is an application
    platform containing applications and code and not solely a cryptocurrency. Ethereum
    has some relief in that the full nodes only need to store the state and not the
    complete history. However, this relief is combined with a huge increase in blockchain
    size, so you will start to see fewer and fewer full nodes and more and more simplified
    payment verification (SPV) nodes, increasing the risk of centralization. The risk
    is that the full nodes could collude and cheat the platform by adjusting the reward
    in their favor. The SPV (or light) nodes would not detect the issue immediately.
    Aside from the spinoff of Bitcoin Cash (BCC), there are a few suggestions on how
    to alleviate the future scaling issue for Bitcoin. For the Ethereum platform,
    there are two strategies in place to help deal with the issue of scaling. First,
    because of the mining algorithm every miner is forced to be a full node. Second,
    after processing each transaction, an intermediate state tree root is saved to
    the blockchain. In the event of a centralization event, as long as there is a
    single honest miner on the network the issue can be addressed via a verification
    process. So if a malicious miner publishes an invalid block, the verifying node
    would run the same computation and see that the state generated does not match
    the state provided and reject the transaction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对以太坊平台的可扩展性表示担忧。毕竟，它基于区块链技术，设计上必须将交易和区块复制到网络中的每个节点，那么它的可扩展性究竟能达到何种程度呢？让我们回顾一下可扩展性的定义。它是一个系统、网络或处理大量工作能力的能力，或者说是其扩展以适应这种增长潜力的能力。在撰写本文时，比特币区块链的大小约为159
    GB，每10分钟大约增长1 MB。如果比特币网络要处理一家主要信用卡公司的交易量，它可能会每3秒增长1 MB，大约每小时增长1 GB或每年增长8 TB。每个节点都需要具备一些处理如此大量数据所需的重要资源能力。以太坊区块链的大小为57
    GB，也会遭受同样的增长模式。更复杂的是，以太坊是一个包含应用程序和代码的应用平台，而不仅仅是加密货币。以太坊的缓解之处在于完整节点只需存储状态，而不必存储完整历史。然而，这种缓解与区块链大小的巨大增加相结合，因此你会开始看到越来越少的全节点和越来越多的简化支付验证（SPV）节点，增加了中心化的风险。风险在于完整节点可能会勾结，通过调整奖励来欺骗平台。SPV（或轻量级）节点不会立即发现这个问题。除了比特币现金（BCC）的分叉之外，还有一些建议可以减轻比特币未来可扩展性问题。对于以太坊平台，已经实施了两种策略来应对可扩展性问题。首先，由于挖矿算法，每个矿工都被强制成为一个完整节点。其次，在处理每个交易后，会保存一个中间状态树根到区块链上。在中心化事件发生的情况下，只要网络上有一个诚实的矿工，问题就可以通过验证过程得到解决。所以如果一个恶意矿工发布了一个无效区块，验证节点会运行相同的计算，并看到生成的状态与提供的状态不匹配，从而拒绝该交易。
- en: The switch to Casper, a proof-of-stake (PoS) consensus algorithm, is also said
    to improve, among other things, the scalability issues that are associated with
    the current proof-of-work (PoW) consensus approach. In PoW-based blockchains,
    the consensus algorithm rewards nodes that solve cryptographic puzzles. The winning
    miners validate transactions and create new blocks. In PoS-based blockchains,
    a set of validators take turns proposing and voting on the next block, and the
    weight of each validator’s vote depends on the size of their stake (or deposit).
    This PoS approach is said to be advantageous over PoW in terms of security, a
    reduced risk of centralization, and energy efficiency.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到Casper，一个权益证明（PoS）共识算法，也据说可以改善与当前工作量证明（PoW）共识方法相关的可扩展性问题。在基于PoW的区块链中，共识算法奖励解决加密谜题的节点。获胜的矿工验证交易并创建新区块。在基于PoS的区块链中，一组验证者轮流提出和投票下一个区块，每个验证者的投票权重取决于他们押注的大小（或存款）。这种PoS方法据说在安全性、减少中心化风险和能源效率方面优于PoW。
- en: 'Infrastructure: Storage and Communication'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基础设施：存储和通信
- en: At their core, all successful computer platforms need to *calculate*, *persist*,
    and *communicate* data in the most efficient and secure manner. The Ethereum Virtual
    Machine (EVM) covers the calculate (or compute) aspect, so let’s take a look at
    what is used for persistence and communication.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成功的计算机平台的核心都需要以最有效和最安全的方式进行数据的*计算*、*持久化*和*通信*。以太坊虚拟机（EVM）涵盖了计算（或计算）方面，那么让我们来看看用于持久化和通信的方面。
- en: •   **Decentralized file storage (persistence)**   Swarm is peer-to-peer (p2p)
    file sharing that is paid for with micropayments of ETH. Within Swarm, data files
    are broken down into chunks, distributed, and stored across the network participating
    nodes. The applications and smart contracts that need to store and retrieve data
    compensate the nodes that persist and serve the data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: •  **去中心化文件存储（持久性）**  Swarm是一个点对点（p2p）的文件共享系统，使用ETH的微支付进行支付。在Swarm中，数据文件被分解成块，分布并存储在参与网络的节点上。需要存储和检索数据的应用程序和智能合约会补偿那些持久化和提供数据的节点。
- en: •   **Communication**   Whisper is an encrypted messaging protocol allowing
    nodes to send messages directly to each other while hiding the sender and receiver
    and the message from third-party snoopers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: •  **通信**  Whisper是一种加密的通信协议，允许节点直接彼此发送消息，同时隐藏发送者、接收者和消息，使其免受第三方窥探者的干扰。
- en: INFURA
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: INFURA
- en: INFURA is a scalable, standards-based, globally distributed cluster and API
    endpoint for Ethereum, IPFS (InterPlanetary File System), and other emerging decentralization
    infrastructures. Its mission is to provide secure, stable, robust, balanced, fault
    tolerant, and easily scalable Ethereum and IPFS nodes. In essence, INFURA is a
    shared infrastructure layer acting as a bridge to the blockchain. For Ethereum
    dapp developers, INFURA eliminates the requirement to install, configure, and
    maintain Ethereum nodes. Specifically for IPFS, which enables distributed storage,
    this can be accessed seamlessly without the hassle of managing the infrastructure.
    Figure 5-4 shows the high-level architecture for INFURA.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: INFURA是一个可扩展的、基于标准、全球分布式的集群和API端点，用于以太坊、IPFS（星际文件系统）和其他新兴的去中心化基础设施。其使命是提供安全的、稳定的、健壮的、平衡的、容错性好且易于扩展的以太坊和IPFS节点。本质上，INFURA是一个共享的基础设施层，作为连接区块链的桥梁。对于以太坊dapp开发者来说，INFURA消除了安装、配置和维护以太坊节点的需要。特别是对于IPFS，它实现了分布式存储，可以无缝地访问，而无需管理基础架构的麻烦。图5-4展示了INFURA的高级架构。
- en: '![Images](fig5-4.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig5-4.jpg)'
- en: '**FIGURE 5-4   INFURA**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5-4   INFURA**'
- en: 'Here are highlights of INFURA capabilities:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是INFURA能力的亮点：
- en: •   Exposes TLS (Transport Layer Security)-enabled endpoints to seamlessly access
    IPFS from decentralized applications running software locally.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: •  向运行本地软件的去中心化应用程序暴露支持TLS（传输层安全）的端点，以无缝地访问IPFS。
- en: •   Presents TLS-enabled endpoints for Ethereum that support CORS (Cross-Origin
    Resource Sharing) and provides capabilities that available in the JSON-RPC API
    (including `web3` and `eth` methods).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: •  为支持CORS（跨源资源共享）的以太坊提供TLS-enabled端点，并提供可在JSON-RPC API（包括`web3`和`eth`方法）中使用的功能。
- en: •   Broadcasts signed raw transactions to Ethereum blockchain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: •  将签名原始交易广播到以太坊区块链。
- en: •   Provides Ferryman, a reverse proxy that helps with caching, throttling,
    logging, scaling, and reliability, and provides intelligent request routing to
    a number of specialized backend clients such as EthereumH, Geth, Nethereum, Parity,
    Strato, or any other client that performs certain operations in an optimized way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: •   提供Ferryman，一个反向代理，帮助缓存、节流、日志记录、扩展和可靠性，并为智能请求路由到多个专用后端客户端，如EthereumH、Geth、Nethereum、Parity、Strato或任何其他以优化方式执行某些操作的客户端。
- en: •   Works on Ethereum Main Net (ETH), Ethereum Testnet (Morden), and the Ethereum
    ConsenSysNet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: •   在以太坊主网（ETH）、以太坊测试网（Morden）和以太坊ConsenSysNet上运行。
- en: 'Below are the steps necessary to start using INFURA:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开始使用INFURA所需的步骤：
- en: 1.   Sign up for an INFURA access token at [https://infura.io/register.html](https://infura.io/register.html).
    Though the service is free, requests do need to be identified to the RPC provider
    endpoints.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在[https://infura.io/register.html](https://infura.io/register.html)注册一个INFURA访问令牌。尽管这项服务是免费的，但请求需要被RPC提供者端点识别。
- en: 2.   Choose a network. This can be production or one of the many test networks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 选择一个网络。这可以是生产环境，也可以是众多测试网络之一。
- en: 3.   Issue requests to INFURA. A list of available requests can be found at
    [https://infura.io/docs/#supported-json-rpc-methods](https://infura.io/docs/#supported-json-rpc-methods).
    (Note that if you omit the access token, calls will probably still work, but they
    are subject to more restrictive throttling and filtering of available JSON-RPC
    API calls.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 向INFURA发起请求。可用的请求列表可以在[https://infura.io/docs/#supported-json-rpc-methods](https://infura.io/docs/#supported-json-rpc-methods)找到。请注意，如果你省略了访问令牌，调用可能仍然可以工作，但它们受到更严格的限制和过滤可用JSON-RPC
    API调用。
- en: 4.   Or you can use the REST(ish) API that is documented at [http://docs.infura.apiary.io/](http://docs.infura.apiary.io/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 或者你可以使用在[http://docs.infura.apiary.io/](http://docs.infura.apiary.io/)文档化的REST（ish）API。
- en: Decentralized Applications
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去中心化应用
- en: A decentralized application (dapp) is like any other modern web-architected
    application, typically consisting of a user interface (UI) whose functionality
    is supported by backend services (reading and writing to persistent storage, processing,
    complex logic). These backend services typically make use of the Ethereum platform
    and in particular the smart contracts that are deployed to it. See Figure 5-5
    for an example dapp.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用（dapp）就像其他现代网络架构应用一样，通常由一个用户界面（UI）组成，其功能由后端服务（读写持久存储、处理、复杂逻辑）支持。这些后端服务通常使用以太坊平台，特别是部署在其上的智能合约。参见图5-5一个示例dapp。
- en: '![Images](fig5-5.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig5-5.jpg)'
- en: '**FIGURE 5-5   Ethereum dapp**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5-5   以太坊dapp**'
- en: Profile of a Dapp
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 去中心化应用轮廓
- en: 'While it is still early days in the lifetime of Ethereum and the decentralized
    applications that are built upon it, it is nonetheless becoming clear that applications
    that are popping up appear to fit the following profile:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以太坊及其建立在之上的去中心化应用的生命周期还很短，但越来越明显，出现的应用似乎符合以下轮廓：
- en: •   **Decentralized**   The complete record of the operation must be stored
    on a public blockchain that is designed to prevent pitfalls of centralization
    (see earlier in the chapter for more on Ethereum’s approach to this).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: •   **去中心化**   操作的完整记录必须存储在公共区块链上，该区块链旨在防止中心化的陷阱（在本章前面有更多关于以太坊方法的讨论）。
- en: •   **Incentivized**   The validating miners of the blockchain are incentivized
    with rewards of cryptographic tokens or value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: •   **激励**   区块链的验证矿工通过加密令牌或价值奖励。
- en: •   **Open source**   Ideally, it should be governed by autonomy and all changes
    must be decided by the consensus, or a majority, of its users. Its code base should
    be available for scrutiny.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: •   **开源**   理想情况下，它应由自主性治理，所有更改必须由其用户的共识或多数决定。其代码库应可供审查。
- en: •   **Protocol**   The application community must agree on a cryptographic algorithm
    to show proof of value (either via proof-of-work or proof-of-stake, or a combination
    thereof).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: •   **协议**   应用社区必须就一个加密算法达成一致，以展示价值证明（无论是通过工作量证明或权益证明，或两者的结合）。
- en: In retrospect, the very first dapp was Bitcoin. We think of Bitcoin as a cryptocurrency
    only, but it is a distributed ledger that provides the transfer of value without
    intermediaries or governing authorities and satisfies all of the above profile
    entries.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾起来，第一个dapp是以太坊。我们认为比特币只是一种加密货币，但它是一个分布式账本，提供无需中介或 governing 当局的价值转移，并满足上述所有轮廓条目。
- en: There are now many examples of Ethereum-based dapps. If you navigate to the
    State of the Dapps website ([https://dapps.ethercasts.com/](https://dapps.ethercasts.com/))
    you will see there are more than 700 dapps in various states of development. Some
    of the most successful in terms of market cap are Augur (prediction market), Golem
    (distributed computation), and Melonport (asset management portal).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多基于以太坊的dapps例子。如果你访问Dapps的状态网站([https://dapps.ethercasts.com/](https://dapps.ethercasts.com/))，你会发现有超过700个dapps处于不同的发展阶段。在市值方面最成功的一些例子包括Augur（预测市场）、Golem（分布式计算）和Melonport（资产管理门户）。
- en: Decentralized Autonomous Organizations
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去中心化自治组织
- en: A decentralized autonomous organization (DAO) uses the same or similar thought
    processes applied to Bitcoin where it did away with central governing middlemen,
    and extends that to the corporate structure. The idea is that companies and other
    organizations can exist and operate without hierarchical management. A DAO attempts
    to codify (put into code) the rules that a company operates under. These rules
    include what projects are to be funded, how to accept investment, how to pay back
    investors, and how to amend and extend the governing rules (which most likely
    would be to fork the DAO code or make a new DAO and transfer value from old to
    new). Figure 5-6 shows an example DAO topology. Basically, a DAO works the same
    way as a typical company, but its rules are digitally encoded and automatically
    enforced and executed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化自治组织（DAO）使用与比特币相同或类似的思维过程，消除了中心化的中介，并将这种模式扩展到企业结构中。这个想法是，公司和其它组织可以不存在或运行在层级管理之外。DAO试图将公司运行的规则编码（写入代码）。这些规则包括哪些项目应该获得资助、如何接受投资、如何偿还投资者以及如何修改和扩展治理规则（这很可能意味着分叉DAO代码或创建新的DAO，并将价值从旧转移到新）。图5-6展示了一个DAO拓扑示例。基本上，DAO的工作方式与典型公司相同，但其规则是数字编码的，可以自动强制执行和执行。
- en: '![Images](fig5-6.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig5-6.jpg)'
- en: '**FIGURE 5-6   Decentralized autonomous organization (DAO)**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5-6   去中心化自治组织（DAO）**'
- en: The biggest issue with a DAO is that when something unforeseen is encountered,
    its structure and current code base may not facilitate a fix or change to overcome
    or address the situation. It is still something worthwhile to keep an eye on and
    even participate in, so the kinks can be worked out and iterated on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的DAO问题是，当遇到无法预见的情况时，其结构和当前的代码库可能不支持修复或更改以克服或解决这种情况。不过，关注并参与其中仍然是有价值的，这样可以通过解决问题和进行迭代来完善。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: With its state transition function, Ethereum provides an open-ended platform
    by design, and is well suited to serve as a framework for financial and nonfinancial
    decentralized applications. Regulation is still up in the air on this. How it
    may even apply to a global decentralized platform is unclear. Current laws and
    regulations will catch up and apply to these platforms. However, it is still important
    to work through any legal and regulatory impacts of particular applications. Businesses
    operating in regulated industries should seek guidance from their regulators before
    integrating critical, customer-facing, or data-handling processes with platforms
    like Ethereum. Large strides have been made in the financial services arena with
    private and consortium varieties of blockchain, and clearly this is an indication
    that financial institutions are playing in and watching the space very closely.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊通过其状态转换函数，提供了一个开放性的平台，非常适合作为金融和非金融去中心化应用的框架。关于监管，目前还在讨论中。它甚至可能适用于全球去中心化平台，这一点还不清楚。现有的法律和规定将会追赶上并适用于这些平台。然而，探讨特定应用的法律和监管影响仍然很重要。在受监管的行业运营的企业，在将关键的、面向客户的或数据处理过程与以太坊等平台集成之前，应寻求监管机构的指导。在金融服务领域，私有和联盟类型的区块链已经取得了重大进展，这清楚地表明金融机构正在密切关注这一领域。
