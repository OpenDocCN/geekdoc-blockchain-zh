["```\n(seq                                      *1*\n  (def 'value 0x00)                       *2*\n  (def 'dummy 0xbc23ecab)                 *3*\n  (returnlll                              *4*\n    (function dummy                       *5*\n      (seq\n        (mstore value(calldataload 0))    *6*\n        (return value 32)))))             *7*\n```", "```\ncontract Dummy {\n    function dummy(bytes32 _value) returns (bytes32) {\n        return _value;\n    }\n}\n```", "```\ndef init():\n    self.storage[msg.sender] = 10000\n\ndef balance_query(address):\n    return(self.storage[address])\n\ndef transfer(to, amount):\n    if self.storage[msg.sender] >= amount:\n        self.storage[msg.sender] -= amount\n        self.storage[to] += amount\n```", "```\npragma solidity ^0.4.24;\ncontract AuthorizedToken {\n\n  enum UserType {TokenHolder, Admin, Owner}        *1*\n\n  struct AccountInfo {                             *2*\n    address account;\n    string firstName;\n    string lastName;\n    UserType userType;\n  }\n\n  mapping (address => uint256) \n     public tokenBalance;                          *3*\n  mapping (address => AccountInfo) \n     public registeredAccount;                     *3*\n  mapping (address => bool) \n     public frozenAccount;                         *3*\n\n  address public owner;                            *3*\n\n  uint256 public constant maxTranferLimit = 15000;\n\n  event Transfer(address indexed from, \n     address indexed to, uint256 value);           *4*\n  event FrozenAccount(address target, \n     bool frozen);                                 *4*\n\n  modifier onlyOwner {                             *5*\n    require(msg.sender == owner);\n    _;\n  }\n\n  constructor(uint256 _initialSupply) public {     *6*\n    owner = msg.sender;\n\n    mintToken(owner, _initialSupply);   \n  }\n\n  function transfer(address _to, uint256 _amount) \n    public {                                            *7*\n    require(checkLimit(_amount));\n    //... \n    emit Transfer(msg.sender, _to, _amount);\n  }  \n  function registerAccount(address account, \n    string firstName,                                   *7*\n    string lastName, bool isAdmin) public onlyOwner {\n    //...\n  }\n\n  function checkLimit(uint256 _amount) private          *7*\n    returns (bool) { \n    if (_amount < maxTranferLimit) \n        return true;\n    return false;\n  }\n\n  function validateAccount(address _account) \n    internal                                            *7*\n    returns (bool) { \n    if (frozenAccount[_account] && tokenBalance[_account] > 0) \n        return true;\n    return false;\n  }\n\n  function mintToken(address _recipient, \n    uint256  _mintedAmount)                             *8*\n    onlyOwner public  { \n    tokenBalance[_recipient] += _mintedAmount;\n    emit Transfer(owner, _recipient, _mintedAmount);\n    }\n\n  function freezeAccount(address target, \n    bool freeze)                                \n    onlyOwner public  { \n    frozenAccount[target] = freeze; \n    emit FrozenAccount(target, freeze);\n  }\n}\n```", "```\nbool isComplete = false;\n```", "```\ncontract IntConversions {\n    int256 bigNumber = 150000000000;\n\n    int32 mediumNegativeNumber = -450000;\n    uint16 smallPositiveNumber = 15678;\n    int16 newSmallNumber = bigNumber;           *1*\n    uint64 newMediumPositiveNumber = \n      mediumNegativeNumber;                     *2*\n    uint32 public newMediumNumber = \n      smallPositiveNumber;                      *3*\n    int256 public newBigNumber = \n      mediumNegativeNumber;                     *4*\n}\n```", "```\nTypeError: type int256 isnâ€™t implicitly convertible to expected type int16\n```", "```\n    int16 public newSmallNumber = \n       int16(bigNumber);                       *1*\n    uint64 public newMediumPositiveNumber =\n       uint64(mediumNegativeNumber);           *2*\n```", "```\naddress ownerAddress = 0x10abb5EfEcdC09581f8b7cb95791FE2936790b4E;\n```", "```\ncontract AddressExamples {\n    address ownerAddress = 0x10abb5EfEcdC09581f8b7cb95791FE2936790b4E;\n\n    function getOwnerBalance() public returns (uint)  {\n        uint balance = ownerAddress.balance;\n        return balance;\n    }\n}\n```", "```\ndestinationAddress.transfer(10);        *1*\n```", "```\nif (!destinationAddress.send(10))\n    revert();                       *1*\n```", "```\nrequire(destinationAddress.send(10));       *1*\n```", "```\ndestinationContractAddress.call(\"contractName\", \n   \"functionName\");                             *1*\n```", "```\ndestinationContractAddress.call.value(10)(\n   \"contractName\", \"functionName\");              *1*\n```", "```\nif (!destinationContractAddress.call.value(10)(\"contractName\"\n , \"functionName\"))\n    revert();                 *1*\n```", "```\nenum  InvestmentLevel {High, Medium, Low}\n```", "```\nInvestmentLevel level = InvestmentLevel.Medium;\n```", "```\nInvestmentLevel level = InvestmentLevel.Medium;\n...\nint16 levelValue = int16(level);\n```", "```\nint16 levelValue = level;         *1*\n```", "```\npragma solidity ^0.4.0;\ncontract ReferenceTypesSample {\n    uint[] storageArray;                              *1*\n\n    function f(uint[] fArray) {}                      *2*\n    function g(uint[] storage gArray) internal {}     *3*\n    function h(uint[] memory hArray) internal  {}     *4*\n}\n```", "```\nfunction f(uint[] fArray)  {\n     uint[] localArray = storageArray;       *1*\n}\n```", "```\nfunction f(uint[] fArray)  {           *1*\n     uint[] localArray = fArray;       *2*\n}\n```", "```\nfunction f(uint[] fArray)  {     *1*\n    storageArray= fArray;        *2*\n}\n```", "```\nfunction f(uint[] fArray)  {                    *1*\n     g(storageArray);                           *2*\n}\nfunction g(uint[] storage gArray) internal {}   *3*\n```", "```\nfunction f(uint[] fArray)  {                    *1*\n    h(storageArray);                            *2*\n}\nfunction h(uint[] memory hArray) internal {}    *3*\n```", "```\nfunction f(){\n   int32[5] memory fixedSlots;\n   fixedSlots[0] = 5;\n   //...        \n}\n```", "```\nfunction f(){\n   int32[5] memory fixedSlots = [int32(5), 9, 1, 3, 4];\n}\n```", "```\nfunction f(){\n   int32[] unlimitedSlots;\n}\n```", "```\nunlimitedSlots.push(6);\nunlimitedSlots.push(4);\n```", "```\nfunction f(){\n   int32[] unlimitedSlots;       *1*\n   //...\n\n   unlimitedSlots.length = 5;    *2*\n}\n```", "```\nfunction f(){\n  int32[] memory unlimitedSlots;       *1*\n  //...\n  unlimitedSlots = new int32[](5);     *2*\n}\n```", "```\nstring name = \"Roberto\";\n```", "```\ncontract Voting {\n\n    enum UserType {Voter, Admin, Owner}\n\n    enum MajorityType {SimpleMajority, AbsoluteMajority, SuperMajority\n , unanimity}\n\n    struct UserInfo {\n        address account;\n        string name;\n        string surname;\n\n        UserType uType;\n    }\n\n    struct Candidate {\n        address account;\n        string description;\n    }\n\n    struct VotingSession {\n        uint sessionId;\n        string description;\n        MajorityType majorityType;\n        uint8 majorityPercent;\n        Candidate[] candidates;\n        mapping (address => uint) votes;\n    }\n\n    uint numVotingSessions;\n    mapping (uint => VotingSession) votingSessions;\n\n    //...\n}\n```", "```\n    function addCandidate(uint votingSessionId, \n    address candidateAddress, \n    string candidateDescription) {\n        Candidate memory candidate =\n        Candidate({account:candidateAddress,\n     description:candidateDescription});\n\n        votingSessions[votingSessionId].candidates.push(candidate);\n    }\n```", "```\nmapping(address => int) public coinBalance;\n```", "```\nint missingAddressBalance = \ncoinBalance[0x6C15291028D082...];     *1*\n```", "```\npragma solidity ^0.4.0;\ncontract StateVariablesAccessibility {\n    mapping (address => bool) \n    private frozenAccounts;                             *1*\n    uint isContractLocked;                              *2*\n    mapping (address => bool) public tokenBalance;      *3*\n\n    ...\n}\n```", "```\npragma solidity ^0.4.0;\ncontract ConstantStateVariables {\n    uint constant maxTokenSupply = 10000000;           *1*\n    string constant contractVersion =\"2.1.5678\";       *1*\n    bytes32 constant contractHash = \n        keccak256(contractVersion, maxTokenSupply);    *2*\n    ...\n }\n```", "```\n    function process1(int _x, int _y, int _z, bool _flag) {\n    ...\n    }\n```", "```\n    function process2(int _x, int, int, bool _flag) {\n        if (_flag)\n           stateVariable = _x;\n    }\n```", "```\n    function calculate1(int _x, int _y, int _z, bool _flag) \n        returns (int _alpha, int _beta, int _gamma) {          *1*\n        _alpha = _x + _y;                                      *2*\n        _beta = _y + _z;                                       *2*\n        if (_flag)\n            _gamma = _alpha / _beta;                           *2*\n        else \n            _gamma = _z;                                       *2*\n    }\n```", "```\n    function calculate2(int _x, int _y, int _z, bool _flag) \n        returns (int, int, int) {                           *1*\n        int _alpha = _x + _y;                               *2*\n        int _beta = _y + _z;                                *2*\n        if (_flag)\n             return (_alpha, _beta, _alpha / _beta);        *3*\n\n        return (_alpha, _beta, _z);                         *3*\n    }\n```", "```\ncontract SimpleCoin {\n    function transfer(address _to, uint256 _amount) \n        public {}                                           *1*\n\n    function checkLimit(uint256 _amount) private \n        returns (bool) {}                                   *2*\n\n    function validateAccount(address avcount) internal \n        returns (bool) {}                                   *3*\n\n    function freezeAccount(address target, bool freeze) \n        external {}                                         *4*\n}\n```", "```\ncontract TaxCalculator {\n    function calculateAlpha(int _x, int _y, int _z) \n         public returns (int _alpha)  {\n        _alpha = _x + calculateGamma(_y, _z);       *1*\n    }\n\n    function calculateGamma(int _y, int _z) \n         internal returns (int _gamma) {            *2*\n        _gamma  = _y *3 +7*_z;\n    }\n}\n```", "```\ncontract GammaCalculator {                              *1*\n    function calculateGamma(int _y, int _z) \n        external returns (int _gamma) {\n        _gamma  = _y *3 +7*_z;\n    }\n}\n\ncontract TaxCalculator2 {\n\n    GammaCalculator gammaCalculator;\n\n    function TaxCalculator(address _gammaCalculatorAddress) {\n        gammaCalculator = GammaCalculator(_\n           gammaCalculatorAddress);                     *2*\n    }\n\n    function calculateAlpha(int _x, int _y, int _z) \n\n        public returns (int _alpha) {\n        _alpha = _x + gammaCalculator.calculateGamma(\n           _y, _z);                                     *3*\n    }\n}\n```", "```\ncontract TaxCalculator3 {\n   function calculateAlpha(int _x, int _y, int _z) \n      public returns (int _alpha) {\n       _alpha = _x + this.calculateGamma(_y, _z);      *1*\n   }\n\n   function calculateGamma(int _y, int _z) \n      public returns (int _gamma) {                    *2*\n       _gamma  = _y *3 +7*_z;\n   }\n}\n```", "```\ncontract TaxCalculator4 {\n   function calculateAlpha(int _x, int _y, int _z)\n      public returns (int _alpha) {\n       _alpha = _x + this.calculateGamma(\n          {_z:_z, _y:_y});                       *1*\n  }\n\n  function calculateGamma(int _y, int _z) \n     public returns (int _gamma) {\n       _gamma  = _y *3 +7*_z;\n    }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract AuthorizedToken {\n\n    //...\n\n    mapping (address => uint256) public tokenBalance; \n    mapping (address => bool) public frozenAccount;\n\n    address public owner;                                 *1*\n    uint256 public constant maxTranferLimit = 50000;\n\n    //...\n\n    function transfer(address _to, uint256 _amount) public { \n        require(checkLimit(_amount));\n        //... \n        tokenBalance[msg.sender] -= _amount;              *2*\n        tokenBalance[_to] += _amount;                     *2*\n        Transfer(msg.sender, _to, _amount);\n    }  \n\n    //...\n\n    function checkLimit(uint256 _amount) private pure\n        returns (bool) { \n        if (_amount < maxTranferLimit)                    *3*\n            return true;\n        return false;\n    }\n\n    function validateAccount(address _account) internal view\n        returns (bool) { \n        if (frozenAccount[_account] \n            && tokenBalance[_account] > 0)                *1*\n            return true;\n        return false;\n    }\n\n    //...\n\n    function freezeAccount(address target, bool freeze)\n        onlyOwner public  { \n        frozenAccount[target] = freeze;                   *4*\n        FrozenAccount(target, freeze);\n    }\n}\n```", "```\ncontract StockPriceOracle {\n   uint quoteFee = 500;                                *1*\n   mapping (string => uint) private stockPrices;  \n\n   //...\n\n   function getStockPrice(string _stockTicker) \n        payable returns (uint _stockPrice) {\n        if (msg.value == quoteFee)                     *2*\n        {\n            //...\n            _stockPrice = stockPrices[_stockTicker];\n        }\n        else \n            revert();                                  *3*\n    }\n}\n```", "```\naddress stockPriceOracleAddress = 0x10abb5EfEcdC09581f8b7cb95791FE2936790b4E;\nuint256 quoteFee = 500;\nstring memory stockTicker = \"MSFT\";\n\nif (!stockPriceOracleAddress.call.value(quoteFee)\n    (bytes4(sha3(\"getStockPrice()\")), \n     _stockTicker))                      *1*\n    revert();                            *2*\n```", "```\ncontract A1 {\n    function () payable {}\n}\n```", "```\ncontract A2 {\n    function () payable  {\n        revert();\n    }\n}\n```", "```\ncontract SimpleCoin {\n    mapping (address => uint256) public coinBalance;       \n    //...\n}\n```", "```\nuint256 myBalance = simpleCoinInstance.coinBalance(myAccountAddress);\n```", "```\ncontract SimpleCoin {\n    mapping (address => uint256) public coinBalance;       \n    //...\n\n    function isAccountUsed(address _account) \n        internal view returns (bool) {\n        if (this.coinBalance(_account) > 0)       *1*\n            return true;\n        return false;\n    }\n}\n```", "```\ncontract FunctionModifiers {\n    address owner;\n    address[] users;\n    mapping (address => bool) frozenUser;\n\n    function FunctionModifiers () {\n        owner = msg.sender;                    *1*\n    }\n\n    modifier onlyOwner {                       *2*\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier isActive(address _account) {\n        require(!frozenUser[_account]);\n        _;\n    }\n\n    function addUser (address _userAddress) \n        onlyOwner public {                     *3*\n        users.push(_userAddress);\n    }\n\n    function refund(address addr) \n        onlyOwner isActive(addr) public {      *4*\n        //...\n    }\n}\n```", "```\n   function refund(address addr) onlyOwner isActive(addr) public {\n        //...\n   }\n```", "```\ncontract DeleteExample {\n    function deleteExample() returns (int32[5]) {\n        int32[5] memory fixedSlots = [int32(5), 9, 1, 3, 4];\n        //...\n        delete fixedSlots;         *1*\n        return fixedSlots;\n    }\n}\n```", "```\ncontract TaxCalculator {\n    function calculateAlpha(int _x) \n        public returns (int _alpha)  {\n        var _gammaParams =  [int(5), 9];               *1*\n        var _gamma = calculateGamma(_gammaParams[0], \n          _gammaParams[1]);                            *2*\n        _alpha = _x + _gamma;\n    }\n\n    function calculateGamma(int _y, int _z)  \n        private returns (int _gamma) {\n            _gamma  = _y *3;\n    }\n}\n```", "```\ncontract Calculator {\n    function calculate(uint _x) \n        public returns (uint _a, uint _b, \n          bool _ok) {                     *1*\n\n        //...\n        _a = _x * 2;                      *2*\n        _b = _x** 3;                      *2*\n\n        _ok == (_a * _b) < 10000;         *2*\n    }\n}\n```", "```\nvar (_alpha, _beta, _success) = \n    calculatorInstance.calculate(5);        *1*\n```", "```\nvar (_alpha, _beta, ) = \n    calculatorInstance.calculate(5);      *1*\nvar (_alpha, _beta, _gamma, _ok) = \n    calculatorInstance.calculate(5);      *2*\n```", "```\nstruct Factors {\n    uint alpha;\n    uint beta;\n}\n```", "```\nvar factors = Factors({alpha:0, beta:0}); \n(factors.alpha, factors.beta, ) = \n   calculatorInstance.calculate(5);        *1*\n```", "```\npragma solidity ^0.4.16;\ncontract SimpleCoin {\n    mapping (address => uint256) public coinBalance; \n    //...\n    event Transfer(address indexed from, \n          address indexed to, uint256 value);           *1*\n    //...\n\n    function transfer(address _to, uint256 _amount) public {\n        //...\n        coinBalance[msg.sender] -= _amount;  \n        coinBalance[_to] += _amount;   \n        emit Transfer(msg.sender, _to, _amount);        *2*\n    }\n    //...\n}\n```", "```\nevent Transfer(address indexed from, address indexed to, uint256 value);\n```", "```\npragma solidity ^0.4.0;\n\ncontract SimpleCoin {\n  mapping (address => uint256) public coinBalance;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  constructor(uint256 _initialSupply) public {\n    coinBalance[msg.sender] = _initialSupply;   \n  }\n\n  function transfer(address _to, uint256 _amount) public {\n    require(coinBalance[msg.sender] > _amount);\n    require(coinBalance[_to] + _amount >= coinBalance[_to] );\n    coinBalance[msg.sender] -= _amount;  \n    coinBalance[_to] += _amount;   \n    emit Transfer(msg.sender, _to, _amount);  \n  }\n}\n```", "```\nmapping (address => mapping (address => uint256)) public allowance;\n```", "```\nallowance[address1][address2] = 200;   *1*\nallowance[address1][address3] = 150;   *2*\n```", "```\nfunction authorize(address _authorizedAccount, uint256 _allowance) \n    public returns (bool success) {   \n    allowance[msg.sender][_authorizedAccount] = \n      _allowance;                                 *1*\n    return true;\n}\n```", "```\nfunction transferFrom(address _from, address _to, uint256 _amount) \n    public returns (bool success) { \n    require(_to != 0x0);                         *1*\n    require(coinBalance[_from] > _amount);       *2*\n    require(coinBalance[_to] + \n       _amount >= coinBalance[_to] );            *3*\n    require(_amount <= \n        allowance[_from][msg.sender]);           *4*\n\n    coinBalance[_from] -= _amount;               *5*\n    coinBalance[_to] += _amount;                 *6*\n    allowance[_from][msg.sender] -= _amount;     *7*\n\n    emit Transfer(_from, _to, _amount);          *8*\n\n    return true;\n}\n```", "```\nconstructor(uint256 _initialSupply) {\n    coinBalance[msg.sender] = _initialSupply;   \n}\n```", "```\nconstructor(uint256 _initialSupply) public {\n    owner = msg.sender;                      *1*\n    coinBalance[owner] = _initialSupply;     *2*\n}\n```", "```\nfunction mint(address _recipient, uint256  _mintedAmount) public {\n    require(msg.sender == owner);                                  *1*\n    coinBalance[_recipient] += _mintedAmount;                      *2*\n    emit Transfer(owner, _recipient, \n       _mintedAmount);\n}\n```", "```\nconstructor(uint256 _initialSupply) public {\n    owner = msg.sender;\n    mint(owner, _initialSupply);       *1*\n}\n```", "```\nmapping (address => bool) public frozenAccount;\n```", "```\nevent FrozenAccount(address target, bool frozen);\n```", "```\nfunction freezeAccount(address target, bool freeze) public{\n    require(msg.sender == owner);                            *1*\n\n    frozenAccount[target] = freeze;                          *2*\n\n    emit FrozenAccount(target, freeze);                      *3*\n}\n```", "```\nmodifier onlyOwner {\n    if (msg.sender != owner) revert();      *1*\n\n    _;\n}\n```", "```\nfunction mint(address _recipient, uint256  _mintedAmount) \n    onlyOwner public {                                      *1*\n    coinBalance[_recipient] += _mintedAmount; \n    emit Transfer(owner, _recipient, _mintedAmount); \n}\n\nfunction freezeAccount(address target, bool freeze) \n    onlyOwner public {                                      *1*\n    frozenAccount[target] = freeze;  \n    emit FrozenAccount(target, freeze);\n}\n```", "```\npragma solidity ^0.4.24;\ncontract SimpleCoin {\n  mapping (address => uint256) public coinBalance;\n  mapping (address => mapping (address => uint256)) public allowance;\n  mapping (address => bool) public frozenAccount;\n  address public owner;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event FrozenAccount(address target, bool frozen);\n\n  modifier onlyOwner {\n    if (msg.sender != owner) revert();\n    _;\n  }\n\n  constructor(uint256 _initialSupply) public {\n    owner = msg.sender;\n\n    mint(owner, _initialSupply);\n  }\n\n  function transfer(address _to, uint256 _amount) public {\n    require(_to != 0x0); \n    require(coinBalance[msg.sender] > _amount);\n    require(coinBalance[_to] + _amount >= coinBalance[_to] );\n    coinBalance[msg.sender] -= _amount;  \n    coinBalance[_to] += _amount;  \n\n    emit Transfer(msg.sender, _to, _amount);  \n  }\n\n  function authorize(address _authorizedAccount, uint256 _allowance) \n    public returns (bool success) {\n    allowance[msg.sender][_authorizedAccount] = _allowance; \n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _amount) \n    public returns (bool success) {\n    require(_to != 0x0);  \n    require(coinBalance[_from] > _amount); \n    require(coinBalance[_to] + _amount >= coinBalance[_to] ); \n    require(_amount <= allowance[_from][msg.sender]);  \n\n    coinBalance[_from] -= _amount; \n    coinBalance[_to] += _amount; \n    allowance[_from][msg.sender] -= _amount;\n    emit Transfer(_from, _to, _amount);\n    return true;\n  }\n\n  function mint(address _recipient, uint256  _mintedAmount) \n    onlyOwner public { \n\n    coinBalance[_recipient] += _mintedAmount; \n    emit Transfer(owner, _recipient, _mintedAmount); \n  }\n\n  function freezeAccount(address target, bool freeze) \n    onlyOwner public { \n\n    frozenAccount[target] = freeze;  \n    emit FrozenAccount(target, freeze);\n  }\n}\n```", "```\ncontract SimpleCrowdsale {    \n    function invest(address _beneficiary) \n       public payable {}                      *1*\n    function finalize() onlyOwner public {}   *2*\n    function refund() public {}               *3*\n}\n```", "```\nuint256 public startTime;                 *1*\nuint256 public endTime;                   *2*\nuint256 public weiTokenPrice;             *3*\nuint256 public weiInvestmentObjective;    *4*\n\nmapping (address => uint256) \n   public investmentAmountOf;             *5*\nuint256 public investmentReceived;        *6*\nuint256 public investmentRefunded;        *7*\n\nbool public isFinalized;                  *8*\nbool public isRefundingAllowed;           *9*\naddress public owner;                     *10*\nSimpleCoin public crowdsaleToken;         *11*\n```", "```\nconstructor(uint256 _startTime, uint256 _endTime, \n    uint256 _weiTokenPrice, uint256 _etherInvestmentObjective) public\n{\n    require(_startTime >= now);                        *1*\n    require(_endTime >= _startTime);                   *1*\n    require(_weiTokenPrice != 0);                      *1*\n    require(_etherInvestmentObjective != 0);           *1*\n\n    startTime = _startTime;                            *2*\n    endTime = _endTime;                                *2*\n    weiTokenPrice = _weiTokenPrice;                    *2*\n    weiInvestmentObjective =                           *2*\n _etherInvestmentObjective * 1000000000000000000;    *2*\n\n    crowdsaleToken = new SimpleCoin(0);                *3*\n    isFinalized = false;\n    isRefundingAllowed = false;\n    owner = msg.sender;                                *4*\n}\n```", "```\nevent LogInvestment(address indexed investor, uint256 value);\nevent LogTokenAssignment(address indexed investor, uint256 numTokens);\n\nfunction invest() public payable {                     *1*\n    require(isValidInvestment(msg.value));             *2*\n\n    address investor = msg.sender;\n    uint256 investment = msg.value;\n\n    investmentAmountOf[investor] += investment;        *3*\n    investmentReceived += investment;                  *3*\n\n    assignTokens(investor, investment);                *4*\n    emit LogInvestment(investor, investment);          *5*\n}\n\nfunction isValidInvestment(uint256 _investment) \n    internal view returns (bool) {                     *6*\n    bool nonZeroInvestment = _investment != 0;         *7*\n    bool withinCrowdsalePeriod = \n       now >= startTime && now <= endTime;             *8*\n\n    return nonZeroInvestment && withinCrowdsalePeriod;\n}\n\nfunction assignTokens(address _beneficiary, \n    uint256 _investment) internal {\n\n    uint256 _numberOfTokens = \n       calculateNumberOfTokens(_investment);           *9*\n\n    crowdsaleToken.mint(_beneficiary, \n       _numberOfTokens);                               *10*\n}\n\nfunction calculateNumberOfTokens(uint256 _investment) \n    internal returns (uint256) {\n    return _investment / weiTokenPrice;                *11*\n}\n```", "```\ncontract ReleasableSimpleCoin {\n    bool public released = false;                     *1*\n\n    ...                                                 *2*\n\n    function release() onlyOwner {                    *3*\n        released = true;\n    }\n\n    function transfer(address _to, uint256 _amount) public {\n        require(_to != 0x0); \n        require(coinBalance[msg.sender] > _amount);\n        require(coinBalance[_to] + _amount >= coinBalance[_to] );\n\n        if (released ) {                              *4*\n            coinBalance[msg.sender] -= _amount;  \n            coinBalance[_to] += _amount;   \n            emit Transfer(msg.sender, _to, _amount); \n\n            return true; \n        }\n        revert();                                     *5*\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) \n        public returns (bool success) {\n\n        require(_to != 0x0);  \n        require(coinBalance[_from] > _amount); \n        require(coinBalance[_to] + _amount >= coinBalance[_to] ); \n        require(_amount <= allowance[_from][msg.sender]);  \n\n        if (released ) {                              *4*\n            coinBalance[_from] -= _amount; \n            coinBalance[_to] += _amount; \n            allowance[_from][msg.sender] -= _amount;\n            emit Transfer(_from, _to, _amount);\n\n            return true;\n        }\n        revert();                                     *5*\n\n    }\n\n    ...                                                 *5*\n\n}\n```", "```\npragma solidity ^0.4.18;\nimport \"./Listing5_8_SimpleCoin.sol\";                       *1*\ncontract ReleasableSimpleCoin is SimpleCoin {               *2*\n    bool public released = false;                           *3*\n\n    modifier isReleased() {                                 *4*\n        if(!released) {\n revert();\n        }\n\n        _;\n    }\n\n    constructor(uint256 _initialSupply) \n        SimpleCoin(_initialSupply) public {}                *5*\n\n    function release() onlyOwner public {                   *6*\n        released = true;\n    }\n\n    function transfer(address _to, uint256 _amount) \n        isReleased public {                                 *7*\n        super.transfer(_to, _amount);                       *8*\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount)  \n        isReleased public returns (bool) {                  *7*\n        super.transferFrom(_from, _to, _amount);            *8*\n    }  \n}\n```", "```\n    Contract ReleasableSimpleCoin is SimpleCoin\n    ```", "```\n    function ReleasableSimpleCoin(uint256 _initialSupply)\n      SimpleCoin(_initialSupply)  {}\n    ```", "```\n    function transfer(address _to, uint256 _amount) isReleased public { ...\n    ```", "```\n    super.transfer(_to, _amount);\n    ```", "```\nReleasableSimpleCoin public crowdsaleToken;\n```", "```\ncrowdsaleToken = new ReleasableSimpleCoin(0);\n```", "```\nfunction finalize() onlyOwner public {                *1*\n    if (isFinalized) revert();                        *2*\n\n    bool isCrowdsaleComplete = now > endTime;         *3*\n    bool investmentObjectiveMet = \n       investmentReceived >= weiInvestmentObjective;  *3*\n\n    if (isCrowdsaleComplete)\n    {     \n        if (investmentObjectiveMet)\n            crowdsaleToken.release();                 *4*\n        else \n            isRefundingAllowed = true;                *5*\n\n        isFinalized = true;\n    }               \n}\n```", "```\n  modifier onlyOwner {\n    if (msg.sender != owner) revert();\n\n    _;\n  }\n```", "```\nevent Refund(address investor, uint256 value);\n\nfunction refund() public {\n    if (!isRefundingAllowed) revert();                   *1*\n\n    address investor = msg.sender;\n    uint256 investment = investmentAmountOf[investor];\n    if (investment == 0) revert();                       *2*\n    investmentAmountOf[investor] = 0;                    *3*\n    investmentRefunded += investment;\n    emit Refund(msg.sender, investment);\n\n    if (!investor.send(investment)) revert();            *4*\n}\n```", "```\npragma solidity ^0.4.18;\ncontract Ownable {\n    address public owner;                *1*\n\n    constructor() public {\n        owner = msg.sender;              *2*\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);    *3*\n        _;\n    }\n}\n```", "```\nSimpleCoin is Ownable {\n... \n}\n\nSimpleCrowdsale is Ownable {\n... \n}\n```", "```\npragma solidity ^0.4.24;\n\nimport \"./Listing6_3_ReleasableSimpleCoin.sol\";       *1*\nimport \"./Listing6_4_Ownable.sol\";                    *1*\n\ncontract SimpleCrowdsale is Ownable {\n    uint256 public startTime;\n    uint256 public endTime; \n    uint256 public weiTokenPrice;\n    uint256 public weiInvestmentObjective;\n\n    mapping (address => uint256) public investmentAmountOf;\n    uint256 public investmentReceived;\n    uint256 public investmentRefunded;\n\n    bool public isFinalized;\n    bool public isRefundingAllowed; \n\n    ReleasableSimpleCoin public crowdsaleToken; \n\n    constructor(uint256 _startTime, uint256 _endTime, \n      uint256 _weiTokenPrice, \n      uint256 _weiInvestmentObjective) \n      payable public\n    {\n        require(_startTime >= now);\n        require(_endTime >= _startTime);\n        require(_weiTokenPrice != 0);\n        require(_weiInvestmentObjective != 0);\n\n        startTime = _startTime;\n        endTime = _endTime;\n\n        weiTokenPrice = _weiTokenPrice;\n        weiInvestmentObjective = _weiInvestmentObjective;\n\n        crowdsaleToken = new ReleasableSimpleCoin(0);\n        isFinalized = false;\n    } \n\n    event LogInvestment(address indexed investor, uint256 value);\n    event LogTokenAssignment(address indexed investor, uint256 numTokens);\n    event Refund(address investor, uint256 value);\n\n    function invest() public payable {\n        require(isValidInvestment(msg.value)); \n\n        address investor = msg.sender;\n        uint256 investment = msg.value;\n\n        investmentAmountOf[investor] += investment; \n        investmentReceived += investment; \n\n        assignTokens(investor, investment);\n        emit LogInvestment(investor, investment);      \n    }\n\n    function isValidInvestment(uint256 _investment) \n        internal view returns (bool) {\n        bool nonZeroInvestment = _investment != 0;\n        bool withinCrowdsalePeriod = now >= startTime && now <= endTime; \n\n        return nonZeroInvestment && withinCrowdsalePeriod;\n    }\n\n    function assignTokens(address _beneficiary, \n        uint256 _investment) internal {\n\n        uint256 _numberOfTokens = calculateNumberOfTokens(_investment); \n\n        crowdsaleToken.mint(_beneficiary, _numberOfTokens);\n    }\n\n    function calculateNumberOfTokens(uint256 _investment) \n        internal returns (uint256) {\n        return _investment / weiTokenPrice; \n    }\n\n    function finalize() onlyOwner public {\n        if (isFinalized) revert();\n\n        bool isCrowdsaleComplete = now > endTime; \n        bool investmentObjectiveMet = \n    investmentReceived >= weiInvestmentObjective;\n\n        if (isCrowdsaleComplete)\n        {     \n            if (investmentObjectiveMet)\n\n                crowdsaleToken.release();\n            else \n                isRefundingAllowed = true;\n\n            isFinalized = true;\n        }               \n    }\n\n    function refund() public {\n        if (!isRefundingAllowed) revert();\n\n        address investor = msg.sender;\n        uint256 investment = investmentAmountOf[investor];\n        if (investment == 0) revert();\n        investmentAmountOf[investor] = 0;\n        investmentRefunded += investment;\n        emit Refund(msg.sender, investment);\n\n        if (!investor.send(investment)) revert();\n    }    \n}\n```", "```\nbool withinCrowdsalePeriod = now >= startTime && now <= endTime; \n```", "```\nbool withinCrowdsalePeriod = true;\n```", "```\nbool isCrowdsaleComplete = now > endTime; \n```", "```\nbool isCrowdsaleComplete = true;\n```", "```\n2003526559, 2003526600, 2000000000000000, 15000\n```", "```\nfunction transfer(address _to, uint256 _amount) public {\n    ...\n\n    if (released) {                             *1*\n        coinBalance[msg.sender] -= _amount;  \n        coinBalance[_to] += _amount;   \n        emit Transfer(msg.sender, _to, _amount);  \n    }\n}\n```", "```\nif (isCrowdsaleComplete)\n{     \n    if (investmentObjectiveMet)\n        crowdsaleToken.release();\n    else \n        isRefundingAllowed = true;\n\n    isFinalized = true;\n}    \n```", "```\nfunction calculateNumberOfTokens(uint256 _investment) \n    internal returns (uint256) {\n    return _investment / weiTokenPrice;         *1*\n}\n```", "```\n    struct Tranche {\n        uint256 weiHighLimit;      *1*\n        uint256 weiTokenPrice;     *2*\n    }\n    ```", "```\n    mapping(uint256 => Tranche) public trancheStructure;\n    ```", "```\n    trancheStructure[0] = Tranche(3000 ether, 0.002 ether);\n    trancheStructure[1] = Tranche(10000 ether, 0.003 ether);\n    trancheStructure[2] = Tranche(15000 ether, 0.004 ether);\n    trancheStructure[3] = Tranche(1000000000 ether, 0.005 ether);\n    ```", "```\n    uint256 currentTrancheLevel;\n    ```", "```\n    currentTrancheLevel = 0;\n    ```", "```\nfunction calculateNumberOfTokens(uint256 investment) \n    internal returns (uint256) {\n    updateCurrentTrancheAndPrice();          *1*\n    return investment / weiTokenPrice; \n}\n\nfunction updateCurrentTrancheAndPrice()      *2*\n    internal {\n    uint256 i = currentTrancheLevel;\n\n    while(trancheStructure[i].weiHighLimit \n       < investmentReceived)                 *3*\n        ++i;\n\n    currentTrancheLevel = i;\n\n    weiTokenPrice = \n      trancheStructure[currentTrancheLevel]\n         .weiTokenPrice;                     *4*\n}\n```", "```\npragma solidity ^0.4.24;\n\nimport \"./Listing6_5_SimpleCrowdsale.sol\";\n\ncontract TranchePricingCrowdsale \n   is SimpleCrowdsale  {                                *1*\n\n   struct Tranche {\n     uint256 weiHighLimit;\n     uint256 weiTokenPrice;\n   }\n\n   mapping(uint256 => Tranche) \n      public trancheStructure;                          *2*\n   uint256 public currentTrancheLevel;                  *3*\n\n   constructor(uint256 _startTime, uint256 _endTime, \n      uint256 _etherInvestmentObjective) \n      SimpleCrowdsale(_startTime, _endTime,\n      1, _etherInvestmentObjective)                     *4*\n   payable public\n   {\n      trancheStructure[0] = Tranche(3000 ether, \n         0.002 ether);                                  *5*\n      trancheStructure[1] = Tranche(10000 ether, \n         0.003 ether);                                  *5*\n      trancheStructure[2] = Tranche(15000 ether, \n         0.004 ether);                                  *5*\n      trancheStructure[3] = Tranche(1000000000 ether, \n         0.005 ether);                                  *5*\n\n      currentTrancheLevel = 0;                          *5*\n   } \n\n   function calculateNumberOfTokens(\n      uint256 investment)                               *6*\n      internal returns (uint256) {\n      updateCurrentTrancheAndPrice();\n      return investment / weiTokenPrice; \n   }\n\n   function updateCurrentTrancheAndPrice()              *7*\n      internal {\n      uint256 i = currentTrancheLevel;\n\n      while(trancheStructure[i].weiHighLimit < investmentReceived) \n        ++i;\n\n      currentTrancheLevel = i;\n\n      weiTokenPrice = trancheStructure[currentTrancheLevel].weiTokenPrice;\n   }\n}\n```", "```\n    contract TranchePricingCrowdsale is SimpleCrowdsale\n    ```", "```\n    TranchePricingCrowdsale(uint256 _startTime, uint256 _endTime, \n            uint256 _weiTokenPrice, uint256 _etherInvestmentObjective) \n            SimpleCrowdsale(_startTime, _endTime,\n               _weiTokenPrice, _etherInvestmentObjective)\n        payable public\n        {\n            trancheStructure[0] = Tranche(3000 ether, 0.002 ether);\n            ...\n    ```", "```\npragma solidity ^0.4.24;\nimport \"./Listing5_8_SimpleCoin.sol\";\ncontract ReleasableSimpleCoin is SimpleCoin { \n    ...                                             *1*\n\n    bool public paused = false;                     *2*\n\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function pause() onlyOwner \n        whenNotPaused public {                      *3*\n        paused = true;\n    }\n\n    function unpause() \n        onlyOwner whenPaused public {               *3*\n        paused = false;\n    }\n\n    ...                                             *4*\n\n    function transfer(address _to, uint256 _amount) \n        isReleased whenNotPaused public {           *5*\n        super.transfer(_to, _amount); \n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) \n        isReleased whenNotPaused \n        public returns (bool) {                     *5*\n        super.transferFrom(_from, _to, _amount); \n    }  \n}\n```", "```\npragma solidity ^0.4.24;\nimport \"./Listing6_4_Ownable.sol\";\ncontract Pausable is Ownable { \n    bool public paused = false;            *1*\n\n    modifier whenNotPaused() {             *2*\n        require(!paused);\n        _;\n    }\n\n    modifier whenPaused() {                *2*\n        require(paused);\n        _;\n    }\n\n    function pause() onlyOwner \n        whenNotPaused public {             *3*\n        paused = true;\n    }\n\n    function unpause() onlyOwner \n        whenPaused public {                *3*\n        paused = false;\n    }\n}\n```", "```\ncontract ReleasableSimpleCoin \n    is SimpleCoin, Pausable {       *1*\n   ...\n}\n```", "```\ncontract SimpleCrowdsale is Pausable {\n...\n}\n```", "```\npragma solidity ^0.4.24;\nimport \"./Listing6_4_Ownable.sol\";\ncontract Destructible is Ownable {\n\n   constructor() payable public { } \n\n   function destroyAndSend(address _recipient) onlyOwner public {\n      selfdestruct(_recipient);                                      *1*\n   }\n}\n```", "```\ncontract ReleasableSimpleCoin is SimpleCoin, \n   Pausable, Destructible {                   *1*\n\n   ...\n}\n\ncontract SimpleCrowdsale is Pausable, \n Destructible {                             *1*\n   ...\n}\n```", "```\npragma solidity ^0.4.24;\nimport \"./Listing6_5_SimpleCrowdsale.0.5.sol\";\n\ncontract CappedCrowdsale is SimpleCrowdsale {\n   uint256 fundingCap;                                  *1*\n\n   constructor(uint256 _startTime, uint256 _endTime, \n      uint256 _weiTokenPrice, uint256 _etherInvestmentObjective, \n      uint256 _fundingCap)\n      SimpleCrowdsale(_startTime, _endTime, \n      _weiTokenPrice, _etherInvestmentObjective)        *2*\n      payable public \n   {\n      require(_fundingCap > 0);\n      fundingCap = _fundingCap;\n   }\n\n   function isValidInvestment(uint256 _investment)      *3*\n      internal view returns (bool) {\n      bool nonZeroInvestment = _investment != 0;        *4*\n      bool withinCrowdsalePeriod = \n         now >= startTime && now <= endTime;            *5*\n\n      bool isInvestmentBelowCap = investmentReceived + \n         _investment < fundingCap;                      *5*\n\n      return nonZeroInvestment && withinCrowdsalePeriod \n         && isInvestmentBelowCap;\n   }\n}\n```", "```\ncontract SimpleCrowdsale is Ownable {\n    ...\n    function isValidInvestment(uint256 _investment) \n        internal view returns (bool) {\n        bool nonZeroInvestment = _investment != 0;        *1*\n        bool withinCrowdsalePeriod = now >= startTime \n           && now <= endTime;\n\n        return nonZeroInvestment && withinCrowdsalePeriod \n           && isFullInvestmentWithinLimit(\n           _investment);                                  *2*\n    }\n\n    function isFullInvestmentWithinLimit(uint256 _investment)\n        internal view returns (bool) {\n        return true;                                      *3*\n    }\n    ...    \n}\n```", "```\npragma solidity ^0.4.18;\nimport \"./Listing7_A_SimpleCrowdsale_forCapped.sol\";         *1*\n\ncontract CappedCrowdsale is SimpleCrowdsale {\n     uint256 fundingCap;\n\n     function CappedCrowdsale(uint256 _startTime, uint256 _endTime, \n     uint256 _weiTokenPrice, uint256 _etherInvestmentObjective, \n     uint256 _fundingCap) SimpleCrowdsale(_startTime, _endTime,\n     _weiTokenPrice, _etherInvestmentObjective)\n     payable public \n    {\n        require(_fundingCap > 0);\n        fundingCap = _fundingCap;\n    }\n\n    function isFullInvestmentWithinLimit(uint256 _investment) \n        internal view returns (bool) {\n        bool check = investmentReceived + _investment\n < fundingCap;                                     *2*\n        return check;\n    }\n}\n```", "```\npragma solidity ^0.4.24;\nimport \"./Listing7_B_TranchePricingCrowdsale_forCapped.sol\";\n\ncontract CappedTranchePricingCrowdsale is TranchePricingCrowdsale {\n   uint256 fundingCap;                                                *1*\n\n   constructor(uint256 _startTime, uint256 _endTime, \n      uint256 _etherInvestmentObjective, \n      uint256 _fundingCap)\n      TranchePricingCrowdsale(_startTime, _endTime, \n      _etherInvestmentObjective)\n      payable public \n   {\n      require(_fundingCap > 0);\n      fundingCap = _fundingCap;\n   }\n\n   function isFullInvestmentWithinLimit(uint256 _investment) \n      internal view returns (bool) {\n      bool check = investmentReceived + _investment \n         < fundingCap;                                                *2*\n      return check;\n   }\n}\n```", "```\ncontract FundingLimitStrategy{\n    function isFullInvestmentWithinLimit(uint256 _investment, \n        uint256 _fullInvestmentReceived)     \n        public view returns (bool);         *1*\n}\n```", "```\ncontract CappedFundingStrategy is FundingLimitStrategy {\n    uint256 fundingCap;                                   *1*\n\n    constructor(uint256 _fundingCap) public {\n        require(_fundingCap > 0);\n\n        fundingCap = _fundingCap;\n    }\n\n    function isFullInvestmentWithinLimit(\n        uint256 _investment, \n        uint256 _fullInvestmentReceived)                  *2*\n        public view returns (bool) {\n\n        bool check = _fullInvestmentReceived + _investment < fundingCap; \n        return check;\n    }\n}\n```", "```\ncontract UnlimitedFundingStrategy is FundingLimitStrategy {\n    function isFullInvestmentWithinLimit(\n        uint256 _investment, \n        uint256 _fullInvestmentReceived) \n        public view returns (bool) {\n        return true;                     *1*\n    }\n}\n```", "```\ncontract SimpleCrowdsale {\n    function calculateNumberOfTokens(uint256 investment) \n       internal returns (uint256) ;                      *1*\n}\n```", "```\ncontract FixedPricingCrowdsale is SimpleCrowdsale {     \n\n    constructor(uint256 _startTime, uint256 _endTime, \n        uint256 _weiTokenPrice, uint256 _etherInvestmentObjective, \n        uint256 _fundingCap)\n        SimpleCrowdsale(_startTime, _endTime, \n        _weiTokenPrice, _etherInvestmentObjective)\n        payable public {\n    }\n\n    function calculateNumberOfTokens(uint256 investment) \n        internal returns (uint256) {\n        return investment / weiTokenPrice;          *1*\n    }    \n}\n```", "```\ncontract SimpleCrowdsale is Ownable {\n    //...\n\n    FundingLimitStrategy internal\n        fundingLimitStrategy;                          *1*\n\n    //...\n    constructor(...) public {\n        ...\n        fundingLimitStrategy =\n createFundingLimitStrategy();               *2*\n    }\n\n    //...\n\n    function createFundingLimitStrategy()\n        internal returns (FundingLimitStrategy);       *3*\n\n    function isValidInvestment(uint256 _investment) \n        internal view returns (bool) {\n        bool nonZeroInvestment = _investment != 0;\n        bool withinCrowdsalePeriod = now >= startTime && now <= endTime; \n\n        return nonZeroInvestment && withinCrowdsalePeriod\n           && fundingLimitStrategy.\n isFullInvestmentWithinLimit(\n _investment,\n investmentReceived);                  *4*\n    }\n\n    //...\n}\n```", "```\npragma solidity ^0.4.24;\nimport \"./Listing7_C_FundingStrategies.sol\";\nimport \"./Listing7_E_PricingStrategies.sol\";\n\ncontract UnlimitedFixedPricingCrowdsale is FixedPricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n    uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n    FixedPricingCrowdsale(_startTime, _endTime,                *1*\n    _weiTokenPrice, _etherInvestmentObjective)\n    payable public  {\n\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new UnlimitedFundingStrategy();                 *2*\n    }\n}\n\ncontract CappedFixedPricingCrowdsale is FixedPricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n    uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n    FixedPricingCrowdsale(_startTime, _endTime,                *1*\n    _weiTokenPrice, _etherInvestmentObjective)\n    payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new CappedFundingStrategy(10000);               *2*\n    }\n}\n\ncontract UnlimitedTranchePricingCrowdsale is TranchePricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n    uint256 _etherInvestmentObjective)\n    TranchePricingCrowdsale(_startTime, _endTime,              *1*\n    _etherInvestmentObjective)\n    payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new UnlimitedFundingStrategy();                 *2*\n    }\n}\n\ncontract CappedTranchePricingCrowdsale is TranchePricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n    uint256 _etherInvestmentObjective)\n    TranchePricingCrowdsale(_startTime, _endTime,              *1*\n    _etherInvestmentObjective)\n    payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new CappedFundingStrategy(10000);               *2*\n    }\n}\n```", "```\ncontract SimpleCrowdsale is Ownable {\n    ... \n\n    ReleasableSimpleCoin public\n        crowdsaleToken;                           *1*\n    ...\n\n    function SimpleCrowdsale(uint256 _startTime, uint256 _endTime, \n    uint256 _weiTokenPrice, uint256 _etherInvestmentObjective) \n    payable public\n    {\n        ...\n        crowdsaleToken =\n new ReleasableSimpleCoin(0);           *2*\n    } \n\n...\n\n    function assignTokens(address _beneficiary, \n        uint256 _investment) internal {\n\n        uint256 _numberOfTokens = calculateNumberOfTokens(_investment); \n\n        crowdsaleToken.mint(_beneficiary,\n        _numberOfTokens);                         *3*\n    }\n\n    ...\n\n    function finalize() onlyOwner public {\n        ...\n\n        if (isCrowdsaleComplete)\n        {     \n            if (investmentObjectiveMet)\n                crowdsaleToken.release();         *4*\n            else \n                isRefundingAllowed = true;\n\n            isFinalized = true;\n        }               \n    }\n\n    ...  \n}\n```", "```\nmint(address _beneficiary, uint256 _numberOfTokens);\n\nrelease();\n```", "```\nfunction transfer(address _to, uint256 _amount);\n```", "```\ninterface ReleasableToken {\n    function mint(address _beneficiary, uint256 _numberOfTokens) external;\n    function release() external;\n    function transfer(address _to, uint256 _amount) external;\n}\n```", "```\ncontract ReleasableSimpleCoin is ReleasableToken {     *1*\n    ...\n}\n```", "```\ncontract ReleasableComplexCoin is ReleasableToken {\n    ...\n}\n```", "```\ncontract SimpleCrowdsale is Ownable {\n    ...\n    ReleasableToken  public crowdsaleToken;          *1*\n    ...\n\n    constructor(uint256 _startTime, uint256 _endTime, \n        uint256 _weiTokenPrice, uint256 _etherInvestmentObjective) \n        payable public {\n        ...    \n        crowdsaleToken = createToken();              *2*\n        ...\n    } \n\n    ...\n\n    function createToken() \n        internal returns (ReleasableToken) {\n            return new ReleasableSimpleCoin(0);      *3*\n        }\n\n    ...   \n}\n```", "```\ncontract ReleasableComplexCoin is ReleasableToken {\n...    \n}\n```", "```\ncontract UnlimitedFixedPricingCrowdsaleWithComplexCoin \n    is UnlimitedFixedPricingCrowdsale {\n\n    constructor(uint256 _startTime, \n    uint256 _endTime, \n    uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n    UnlimitedFixedPricingCrowdsale(_startTime, _endTime, \n    _weiTokenPrice, _etherInvestmentObjective)\n    payable public  {\n    }\n\n    function createToken()\n internal returns (ReleasableToken) {\n return new ReleasableComplexCoin();        *1*\n        }\n}\n```", "```\n    interface ReleasableToken {\n        function mint(address _beneficiary, uint256 _numberOfTokens) external;\n\n        function release() external;\n        function transfer(address _to, uint256 _amount) external;\n    }\n    ```", "```\n    contract ReleasableSimpleCoin is ReleasableToken {\n        ...\n    }\n    ```", "```\ncontract Parent1 {\n\n    int256 public stateVar1;\n    bool public stateVar2;\n\n    function initialize() public {}\n    function Parent1(int256 param1, bool param2) public {}\n\n    function operation1(int256 opParam1) public returns (int256) {}\n\n}\n\ncontract ParentA {\n\n    int256 public stateVarA;\n    int16 public stateVarB;\n\n    function initialize() public {}\n    function ParentA(int256 paramA, int16 paramB) public {}\n\n    function operationA(bool opParamA) public {}\n}\n\ncontract Child is Parent1, ParentA {        *1*\n\n}\n```", "```\nfunction Child(int256 p1, bool p2, int256 pA, int16 pB) \n    Parent1(p1, p2) ParentA(pA, pB) {\n}\n```", "```\ncontract Child is Parent1, ParentA { \n    ...\n    function operationA(bool opParamA) public {     *1*\n    ...\n    }\n}\n```", "```\ncontract Child is Parent1, ParentA {\n    ...\n    function operationA(bool opParamA) public {\n        ParentA.operationA(opParamA);             *1*\n    }\n}\n```", "```\ncontract Child is Parent1, ParentA { \n    ... \n\n    function initialize() public {\n        ...\n        super.initialize();        *1*\n\n    }\n\n    ...\n}\n```", "```\ncontract AbstractContract {\n    int256 public stateVar;\n\n    constructor(int256 param1)  public {\n        stateVar = param1;\n    }\n\n    function operation1(int256 opParam1, bool opParam2)\n        returns (int256) {\n        if (opParam2) return opParam1;\n    }\n\n    function operationA(int256 opParamA);       *1*\n}\n```", "```\ninterface SampleInterface {\n    function operation1(int256 param1, bool param2) external;\n\n    function operationA(int16 paramA) external;\n}\n```", "```\ncontract SampleContract is SampleInterface {\n    function operation1(int256 param1, bool param2) {\n                                                      *1*\n    }\n\n    function operationA(int16 paramA) {\n                                                      *2*\n    }\n}\n```", "```\nlibrary SafeMath {                                    *1*\n    //Taken from: https://github.com/OpenZeppelin/\n    function mul(uint256 a, uint256 b)\n        public pure returns (uint256) {               *2*\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        assert(c / a == b);                           *3*\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) \n        public pure returns (uint256) {               *2*\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) \n        public pure returns (uint256) {               *4*\n        assert(b <= a);                               *5*\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) \n        public pure returns (uint256) {               *4*\n        uint256 c = a + b;\n        assert(c >= a);                               *5*\n        return c;\n    }\n}\n```", "```\npragma solidity ^0.4.24;\nimport './Listing7_6_SafeMath.sol';\n\ncontract Calculator {\n    function calculateTheta(uint256 a, uint256 b) public returns (uint256) {\n        uint256 delta = SafeMath.sub(a, b);                               *1*\n        uint256 beta = SafeMath.add(delta, \n           1000000);                                                      *1*\n        uint256 theta = SafeMath.mul(beta, b);                            *1*\n\n        uint256 result = SafeMath.div(theta, a);                          *1*\n\n        return result;\n    }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract SafeMathProxy {                                  *1*\n    function mul(uint256 a, uint256 b) \n        public pure returns (uint256);                    *2*\n    function div(uint256 a, uint256 b)  \n        public pure returns (uint256);                    *2*\n    function sub(uint256 a, uint256 b) \n        public pure returns (uint256);                    *2*\n    function add(uint256 a, uint256 b) \n        public pure returns (uint256);                    *2*\n}\n\ncontract Calculator {\n\n    SafeMathProxy safeMath;   \n\n    constructor(address _libraryAddress) public           *3*\n\n    {\n        require(_libraryAddress != 0x0);\n        safeMath = SafeMathProxy(_libraryAddress);        *4*\n    }\n\n    function calculateTheta(uint256 a, uint256 b) \n        public returns (uint256) {\n\n        uint256 delta = safeMath.sub(a, b);               *5*\n        uint256 beta = safeMath.add(delta, \n           1000000);                                      *5*\n        uint256 theta = safeMath.mul(beta, b);            *5*\n\n        uint256 result = safeMath.div(theta, a);          *5*\n\n        return result;\n    }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract ERC20 {\n    uint256 public totalSupply;\n    function balanceOf(address _owner) \n       public view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) \n       public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) \n       public returns (bool success);\n    function approve(address _spender, uint256 _value) \n       public returns (bool success);\n    function allowance(address _owner, address _spender) \n       public view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, \n       address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, \n       address indexed _spender, uint256 _value); \n}\n```", "```\npragma solidity ^0.4.24;\n\nimport \"./Listing6_4_Ownable.sol\";\nimport \"./Listing7_9_ERC20.sol\";\n\ncontract SimpleCoin is Ownable, ERC20 {\n\n   mapping (address => uint256) \n      internal coinBalance;                                                *1*\n   mapping (address => mapping \n      (address => uint256)) internal allowances;                           *1*\n   mapping (address => bool) public frozenAccount;\n\n   event Transfer(address indexed from, address indexed to, uint256 value);\n   event Approval(address indexed authorizer, address indexed authorized, \n      uint256 value);                                                      *2*\n   event FrozenAccount(address target, bool frozen);\n\n   constructor(uint256 _initialSupply) public {\n      owner = msg.sender;\n\n      mint(owner, _initialSupply);\n   }\n\n   function balanceOf(address _account)                                    *3*\n      public view returns (uint256 balance) {\n      return coinBalance[_account];\n   }\n\n   function transfer(address _to, uint256 _amount) public returns (bool) {\n      require(_to != 0x0); \n      require(coinBalance[msg.sender] > _amount);\n      require(coinBalance[_to] + _amount >= coinBalance[_to]);\n      coinBalance[msg.sender] -= _amount;  \n      coinBalance[_to] += _amount;   \n      emit Transfer(msg.sender, _to, _amount); \n      return true;\n   }\n\n   function approve(address _authorizedAccount, uint256 _allowance) \n      public returns (bool success) {\n      allowances[msg.sender][_authorizedAccount] = _allowance; \n      emit Approval(msg.sender, \n         _authorizedAccount, _allowance);                                  *4*\n      return true;\n   }\n\n   function transferFrom(address _from, address _to, uint256 _amount) \n      public returns (bool success) {\n      require(_to != 0x0);  \n      require(coinBalance[_from] > _amount); \n      require(coinBalance[_to] + _amount >= coinBalance[_to]); \n      require(_amount <= allowances[_from][msg.sender]);  \n      coinBalance[_from] -= _amount; \n      coinBalance[_to] += _amount; \n      allowances[_from][msg.sender] -= _amount;\n      emit Transfer(_from, _to, _amount);\n      return true;\n   }\n\n   function allowance(address _authorizer, \n      address _authorizedAccount)                                          *5*\n      public view returns (uint256) {\n      return allowances[_authorizer][_authorizedAccount];\n   }\n\n   function mint(address _recipient, uint256  _mintedAmount) \n      onlyOwner public { \n\n      coinBalance[_recipient] += _mintedAmount; \n      emit Transfer(owner, _recipient, _mintedAmount); \n   }\n\n   function freezeAccount(address target, bool freeze) \n      onlyOwner public { \n\n      frozenAccount[target] = freeze;  \n      emit FrozenAccount(target, freeze);\n   }\n}\n```", "```\nstring public constant name = \"Token Name\";\nstring public constant symbol = \"SYM\";\nuint8 public constant decimals = 18;         *1*\n```", "```\nC:\\Program Files\\geth>geth --testnet\n```", "```\ngeth --testnet â€“-bootnodes \"enode://145a93c5b1151911f1a232e04dd1a76708\n dd12694f952b8a180ced40e8c4d25a908a292bed3521b98bdd843147116a52ddb645\n d34fa51ae7668c39b4d1070845@188.166.147.175:30303,enode://2609b7ee28b\n 51f2f493374fee6a2ab12deaf886c5daec948f122bc83716aca27840253d191b9e63\n a6e7ec77643e69ae0d74182d6bb64fd30421d45aba82c13bd@13.84.180.240:3030\n 3,enode://94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487\n f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f\n 09@188.166.147.175:30303\" --verbosity=4\n```", "```\n--syncmode \"fast\" --cache=1024\n```", "```\nC:\\Program Files\\geth>geth attach ipc:\\\\.\\pipe\\geth.ipc\n```", "```\npragma solidity ^0.4.24;\ncontract SimpleCoin {\n   mapping (address => uint256) public coinBalance;\n\n   event Transfer(address indexed from, address indexed to, uint256 value);\n\n   constructor(uint256 _initialSupply) public {\n      coinBalance[msg.sender] = _initialSupply;   \n   }\n\n   function transfer(address _to, uint256 _amount) public {\n      require(coinBalance[msg.sender] > _amount);\n      require(coinBalance[_to] + _amount >= coinBalance[_to] );\n      coinBalance[msg.sender] -= _amount;  \n      coinBalance[_to] += _amount;   \n      emit Transfer(msg.sender, _to, _amount);  \n   }  \n}\n```", "```\nC:\\Ethereum\\SimpleCoin>..\\solidity-windows\\solc.exe \n --bin -o bin --combined-json abi,bin SimpleCoin.sol \n```", "```\n{\"contracts\":{\"SimpleCoin.sol:SimpleCoin\" :{\"abi\":\"[{\\\"constant\\\":false,\\\n\"inputs\\\":[{\\\"name\\\":\\\"_to\\\",\\ \"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"_amount\\\",\\\n\"type\\\":\\\"uint256\\\"}],\\\"name\\\" :\\\"transfer\\\",\\\"outputs\\\":[],\\\"payable\\\n\":false,\\\"type\\\":\\\"function\\\"}, {\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"\\\"\n,\\\"type\\\":\\\"address\\\"}],\\\"name\\\" :\\\"coinBalance\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\"\n,\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\" :false,\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\"\n:[{\\\"name\\\":\\\"_initialSupply\\\",\\\"type\\\" :\\\"uint256\\\"}],\\\"payable\\\":false,\\ \n\"type\\\":\\\"constructor\\\"},{\\\"anonymous\\\" :false,\\\"inputs\\\":[{\\\"indexed\\\":true\n,\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"}, {\\\"indexed\\\":true,\\\"name\\\":\\\"to\\\",\\\n\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\ \"name\\\":\\\"value\\\",\\\"type\\\":\\\n\"uint256\\\"}],\\\"name\\\":\\\"Transfer\\\",\\\"type\\\": \\\"event\\\"}]\",\"bin\":\" 60806040523\n4801561001057600080fd5b50604051602080610399833981018060405281019080805190602\n00190929190505050806000803373ffffffffffffffffffffffffffffffffffffffff1673fff\nfffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505\n0610313806100866000396000f30060806040526004361061004c576000357c0100000000000\n000000000000000000000000000000000000000000000900463ffffffff168063a9059cbb146\n10051578063fabde80c1461009e575b600080fd5b34801561005d57600080fd5b5061009c600\n480360381019080803573ffffffffff...(shortened for brevity)\"}}, \"version\"\n:\"0.4.24+commit.6ae8fb59.Windows.msvc\" }\n```", "```\nvar initialSupply = 10000;                                *1*\n\nvar simpleCoinAbi =                                       *2*\n\n[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\"\n:\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false\n,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}]\n,\"name\":\"coinBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\"\n:false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\"\n:\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false\n,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true\n,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\"\n:\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}];    //abi interface from\n solc output\n\nvar SimpleCoinContractFactory = \n   web3.eth.contract(simpleCoinAbi);                     *3*\n\nvar simpleCoinInstance = \n   SimpleCoinContractFactory.new(                        *4*\n   initialSupply,\n   {\n     from: web3.eth.accounts[0], \n     data:                                               *5*\n'0x608060405234801561001057600080fd5b506040516020806103998339\n8101806040528101908080519060200190929190505050806000803373ffffffffffffffffff\nffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020\n019081526020016000208190555050610313806100866000396000f300608060405260043610\n61004c576000357c010000000000000000000000000000000000000000000000000000000090\n0463ffffffff168063a9059cbb14610051578063fabde80c1461009e575b600080fd5b348015\n61005d57600080fd5b5061009c600480360381019080803573ffffffff ...(shortened for\nbrevity)', \n     gas: '3000000'      \n   }, function (e, contract){                            *6*\n    console.log(e, contract);\n    if (typeof contract.address !== 'undefined') {\n         console.log('Contract mined! address: ' \n         + contract.address + ' transactionHash: ' \n         + contract.transactionHash);\n    }\n });\n```", "```\nError: authentication needed: password or unlock undefined\n```", "```\n> web3.eth.accounts\n[\"0xedde06bc0e45645e2f105972bdefc220ed37ae10\",\n \"0x4e6c301547 68b6bc3da693b1b28c6bd14302b578\",\n \"0x70e36be8ab 8f6cf66c0c953cf9c63ab63f3fef02\",\n \"0xc99048e9b9 8d3fcf8b5f0d5644794b562f9a2ea4\",\n \"0x47e3d3948f 46144afa7df2c1aa67f6b1b1e35cf1\",\n \"0x70ff99d4bc 8054b2e09269bcbfdddf8e1ae7d155\"]\n```", "```\n>personal.unlockAccount(\n\"0xedDE06bC0e45645e2f105972BDefC220ED37Ae10\", \nPASSWORD_OF_YOUR_ACCOUNT_0)\n```", "```\n\ngeth --unlock <YOUR_ACCOUNT_ADDRESS> --password <YOUR_PASSWORD>\n```", "```\nContract mined! address: 0x4291f37 a727d32e5620a0a4ed61d27ffdad757af\n transactionHash: 0x2b s7d2a015ca3397c1ec2b2d8e14b6c8ca7e3c06340d759a10d0e535\n 843532fe6\n```", "```\n> simpleCoinInstance\n{\n  abi: [{\n      constant: false,\n      inputs: [{...}, {...}],\n      name: \"transfer\",\n      outputs: [],\n      payable: false,\n      type: \"function\"\n  }, {\n      constant: true,\n\n      inputs: [{...}],\n      name: \"coinBalance\",\n      outputs: [{...}],\n      payable: false,\n      type: \"function\"\n  }, {\n      inputs: [{...}],\n      payable: false,\n      type: \"constructor\"\n  }, {\n      anonymous: false,\n      inputs: [{...}, {...}, {...}],\n      name: \"Transfer\",\n      type: \"event\"\n  }],\n  address: \"0x4291f37a727d32e5620a0a4ed61d27ffdad757af\",\n  transactionHash: \"0x2b7d2a015ca3397c1ec2b2d8e14b6c8ca7e3c06340d759a10d0e53\n5843532fe6\",\n  Transfer: function(),\n  allEvents: function(),\n  coinBalance: function(),\n  transfer: function()\n}\n```", "```\naddress: \"0x4291f37a727d32e5620a0a4ed61d27ffdad757af\"\n```", "```\n>simpleCoinInstance.coinBalance(eth.accounts[0])\n10000\n```", "```\n>simpleCoinInstance.coinBalance(eth.accounts[0])\n0\n```", "```\n> simpleCoinInstance.transfer(eth.accounts[2], 150,\n     {from:eth.accounts[0],gas:200000});\n```", "```\nError: authentication needed: password or unlock\n```", "```\n>personal.unlockAccount(eth.accounts[0], 'PASSWORD_OF_ACCOUNT_0')\n```", "```\n\"0xccd8211bde9ac8075a6d43fc51d705cf60db5c7f0a25769cf7c8cff94103af7e\"\n```", "```\n>personal.unlockAccount(eth.accounts[2], PASSWORD_OF_ACCOUNTS[2])\n>simpleCoinInstance. transfer(eth.accounts[1], \n50, {from:eth.accounts[2],gas:200000});\n```", "```\nC:\\Program Files\\geth>geth attach ipc:\\\\.\\pipe\\geth.ipc\n```", "```\n0x4291f37a727d32e5620a0a4ed61d27ffdad757af\n```", "```\nvar remoteSimpleCoinAddress = \"0x4291f37a727d32e5620a0a4ed61d27ffdad757af\";\nvar simpleCoinAbi =\n      [{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},\n{\"name\":\"_amount\",\"type\":\"uint256\"}],\n\"name\":\"transfer\",\"outputs\" :[],\"payable\":false,\"type\":\"function\"},\n{\"constant\":true,\"inputs\" :[{\"name\":\"\",\"type\":\"address\"}],\n\"name\":\"coinBalance\",\"outputs\" :[{\"name\":\"\",\"type\":\"uint256\"}],\n\"payable\":false,\"type\" :\"function\"},\n{\"inputs\":[{\"name\": \"_initialSupply\",\"type\":\"uint256\"}],\n\"payable\":false,\"type\": \"constructor\"},{\"anonymous\":false,\n\"inputs\":[{\"indexed\":true, \"name\":\"from\",\"type\":\"address\"},\n{\"indexed\":true,\"name\":\"to\", \"type\":\"address\"},\n{\"indexed\":false,\"name\":\"value\", \"type\":\"uint256\"}],\n\"name\":\"Transfer\",\"type\": \"event\"}];                       *1*\nvar SimpleCoinContractProxy = \n   web3.eth. contract(simpleCoinAbi);                      *2*\nvar simpleCoinInstance =                                   *3*\n     SimpleCoinContractProxy. at(remoteSimpleCoinAddress);\n```", "```\ncontract SimpleCoinProxy {\n    function transfer(address _to, uint256 _amount) public;\n}\n\ncontract MyContract {\n    SimpleCoinProxy simpleCoinProxy;\n\n    function MyContract(address _simpleCoinAddress)\n    {\n        require(_simpleCoinAddress != 0x0);\n        simpleCoinProxy = SimpleCoinProxy(_simpleCoinAddress); \n    }\n\n    function transferSimpleCoin(address _to, uint256 _amount) {\n        simpleCoinProxy.transfer(_to, _amount) ;\n    }\n}\n```", "```\n>simpleCoinInstance. coinBalance(\n\"0xedde06bc0e45645e2f105972bdefc220ed37ae10\")\n```", "```\nC:\\Ethereum>md SimpleCoinWithNode\nC:\\Ethereum>cd SimpleCoinWithNode\nC:\\Ethereum\\SimpleCoinWithNode>npm init\n```", "```\nname: (SimpleCoinWithNode): simple_coin\nVersion: (1.0.0) 1.0.0\n```", "```\nIs this ok? (yes) yes\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>npm install web3@0.20.4\n```", "```\nsimple_coin@1.0.0 C:\\Ethereum\\SimpleCoinOnNodeJS\n`-- web3@0.20.4\n  +-- bignumber.js@2.0.7  (git+https://github.com/frozeman/bignumber.js\n-nolookahead.git#57692b 3ecfc98bbdd6b3a516cb2353652ea49934)\n  +-- crypto-js@3.1.8\n  `-- xmlhttprequest@1.8.0\n\nnpm WARN simple_coin@1.0.0 No description\nnpm WARN simple_coin@1.0.0 No repository field.\n```", "```\nC:\\Program Files\\geth>geth --testnet --rpc \n--rpcapi=\"db,eth,net,web3,personal,web3\"\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node\n```", "```\n> \n```", "```\n>const Web3 = require('web3');\n>web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));\n>web3.eth.getAccounts(console.log);\n```", "```\n> null [ '0xedde06bc0e45645e2f105972bdefc220ed37ae10',\n  '0x4e6c30154768b6bc3da693b1b28c6bd14302b578',\n  '0x70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02',\n  '0xc99048e9b98d3fcf8b5f0d5644794b562f9a2ea4' ]\n```", "```\n>.exit\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>npm install solc@0.4.24\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode\\SimpleCoin.sol\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node\n```", "```\n>const fs = require('fs');          *1*\n>const solc = require('solc');      *2*\n>const Web3 = require('web3');      *3*\n```", "```\n>const web3 = new Web3(\nnew Web3.providers.HttpProvider(\n\"http://localhost:8545\"));\n```", "```\n>const initialSupply = 10000;\n```", "```\n>const account2 = web3.eth.accounts[1];\n>const sender = account2;\n>const senderPassword = 'account2';\n```", "```\n>const source = fs.readFileSync(\n'c:/Ethereum/SimpleCoinWithNode/SimpleCoin.sol', \n'utf8');\n```", "```\n>const compiledContract = solc.compile(source, 1);\n```", "```\n>const abi = compiledContract.contracts[':SimpleCoin'].interface;\n>const bytecode = '0x' + \ncompiledContract.contracts[':SimpleCoin'].bytecode;\n```", "```\n>const gasEstimate = web3.eth.estimateGas({ data: bytecode }) + 100000;\n```", "```\n>const SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\n```", "```\n>web3.personal.unlockAccount(sender, senderPassword);\n```", "```\n>const simpleCoinInstance = SimpleCoinContractFactory.new(initialSupply, {\n    from: sender,\n    data: bytecode,\n    gas: gasEstimate\n   }, function (e, contract){\n    console.log(e, contract);\n    if (typeof contract.address !== 'undefined') {\n         console.log('Contract mined! address: ' \n         + contract.address \n         + ' transactionHash: ' \n         + contract.transactionHash);\n    }\n });\n```", "```\nINFO [08-20|09:50:17] Imported new chain segment blocks=1\n txs=3  mgas=1.493 elapsed=6.016ms  mgasps=248.107  number=1521353 hash=\n acbacb...7212ed\n\nINFO [08-20|09:50:18] Submitted contract creation fullhash=\n 0xb1a204653ba5f0cf5b2953eba15b3a55d3c73a358a1823f327f9cc02c4fc8a2e contract\n =0xa9d460c5aba794db20d005f54e8eefa80b76ff2e\nINFO [08-20|09:50:26] Imported new chain segment blocks=1\n txs=0  mgas=0.000elapsed=2.527ms  mgasps=0.000    number=1521354 hash\n =2e95c3...7f9f9b\n```", "```\nContract mined! address: 0xa9d460c5aba794db20d005f54e8eefa80b76ff2e\n transactionHash: 0xb1a204653ba5f0cf5b2953eba15b3a55d3c73a358a1823f327f9cc0\n 2c4fc8a2e\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode\\deploySimpleCoin.js\n```", "```\nconst fs = require('fs');\nconst solc = require('solc');\nconst Web3 = require('web3'); \nconst web3 = new Web3(new\n     Web3.providers.HttpProvider(\"http://localhost:8545\")); \n\nconst account2 = web3.eth.accounts[1];\nconst sender = account2;\nconst senderPassword = 'PASSWORD OF ACCOUNT 2';\nconst initialSupply = 10000;\n\nconst source =\n     fs.readFileSync('c:/Ethereum/SimpleCoinWithNode/SimpleCoin.sol',\n     'utf8');\nconst compiledContract = solc.compile(source, 1);\nconst abi = compiledContract.contracts[':SimpleCoin'].interface;\nconst bytecode = '0x' + compiledContract.contracts[':SimpleCoin'].bytecode;\nconst gasEstimate = web3.eth.estimateGas({ data: bytecode }) + 100000;\n\nconst SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\n\nweb3.personal.unlockAccount(sender, senderPassword);\n\nconst simpleCoinInstance = SimpleCoinContractFactory.new(initialSupply, {\n    from: sender,\n    data: bytecode,\n\n    gas: gasEstimate\n   }, function (e, contract){\n    console.log(e, contract);\n    if (typeof contract.address !== 'undefined') {\n         console.log('Contract mined! address: ' + contract.address + '\n     transactionHash: ' + contract.transactionHash);\n    }\n });\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node deploySimpleCoin.js\n```", "```\nContract mined! address: 0x664e5f1df05e11bbf0c72c7c28419e1f8ed5821e\n transactionHash: 0x7191139eb5f164da7effbe9e5795fbd28fc212bfd629422da87dbebb\n eb13484c\n```", "```\n>const fs = require('fs');\n>const solc = require('solc');\n>const Web3 = require('web3');\n>const web3 = new\n        Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));\n```", "```\nconst source = fs.readFileSync(\n'c:/Ethereum/SimpleCoinWithNode/SimpleCoin.sol', \n'utf8');\nconst compiledContract = solc.compile(source, 1);\nconst abi = compiledContract.contracts[':SimpleCoin'].interface;\n\nconst SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\n```", "```\nconst contractAddress =\n'0xa9d460c5aba794db20d005f54e8eefa80b76ff2e'; \n//replace appropriately \n```", "```\nconst simpleCoinInstance = SimpleCoinContractFactory.at(contractAddress);\n```", "```\n>const account2 = web3.eth.accounts[1]; \n>const account3 = web3.eth.accounts[2]; \n```", "```\n>var account2Balance = simpleCoinInstance.coinBalance(account2);\n>var account3Balance = simpleCoinInstance.coinBalance(account3);\n```", "```\n>console.log('BALANCES BEFORE transferring tokens');\n>console.log('Account 2 balance: ' + account2Balance);\n>console.log('Account 3 balance: ' + account3Balance);\n```", "```\n>web3.personal.unlockAccount(account2, \"account2\");\n```", "```\n>var transactionHash = simpleCoinInstance.transfer(\naccount3, 20, {from:account2,gas:200000});\nconsole.log(\n'SUBMITTED transfer() transaction. Transaction hash: ' \n+ transactionHash);\n```", "```\n>var transactionReceipt = null;\n>while (transactionReceipt == null)\n{\n     transactionReceipt = web3.eth.getTransactionReceipt(transactionHash);\n}\n```", "```\n>console.log('COMPLETED transfer() transaction. Transaction: ' +\ntransactionHash + 'has been consolidated on block: ' +\ntransactionReceipt.blockNumber);\n```", "```\n>account2Balance = simpleCoinInstance.coinBalance(account2);\n>account3Balance = simpleCoinInstance.coinBalance(account3);\n```", "```\n>console.log('BALANCES AFTER transferring tokens');\n>console.log('Account 2 balance: ' + account2Balance);;\n>console.log('Account 3 balance: ' + account3Balance);\n```", "```\nconst fs = require('fs');\nconst solc = require('solc');\nconst Web3 = require('web3'); \nconst web3 = new Web3(new\n     Web3.providers.HttpProvider(\"http://localhost:8545\")); \n\nconst source = fs.readFileSync(\n'c:/Ethereum/SimpleCoinWithNode/SimpleCoin.sol', \n'utf8');\nconst compiledContract = solc.compile(source, 1);\nconst abi = compiledContract.contracts[':SimpleCoin'].interface;\n\nconst SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\nconst contractAddress = \n'0xa9d460c5aba794db20d005f54e8eefa80b76ff2e'; \n//replace appropriately \n\nconst simpleCoinInstance = SimpleCoinContractFactory.at(contractAddress);\n\nconst account2 = web3.eth.accounts[1]; //account2\nconst account3 = web3.eth.accounts[2]; //account3\n\nvar account2Balance = simpleCoinInstance.coinBalance(account2);\nvar account3Balance = simpleCoinInstance.coinBalance(account3);\n\nconsole.log('Account 2 balance: ' + account2Balance);\nconsole.log('Account 3 balance: ' + account3Balance);\n\nweb3.personal.unlockAccount(account2, \"PASSWORD OF ACCOUNT 2\");\n\nvar transactionHash = simpleCoinInstance.transfer(\naccount3, 20, {from:account2,gas:200000});\nconsole.log(\n'SUBMITTED transfer() transaction. Transaction hash: ' \n+ transactionHash);\n\nvar transactionReceipt = null;\nwhile (transactionReceipt == null)\n{\n     transactionReceipt = web3.eth.getTransactionReceipt(transactionHash);\n}\n\nconsole.log(\n'COMPLETED transfer() transaction. Transaction: ' \n+ transactionHash + 'has been consolidated on block: ' +\n     transactionReceipt.blockNumber);\n\naccount2Balance = simpleCoinInstance.coinBalance(account2);\naccount3Balance = simpleCoinInstance.coinBalance(account3);\n\nconsole.log('BALANCES AFTER transferring tokens');\nconsole.log('Account 2 balance: ' + account2Balance);\nconsole.log('Account 3 balance: ' + account3Balance);\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node transferTokens.js\n```", "```\nEthereum\n|---geth               *1*\n|---keystore           *2*\n|---testnet            *3*\n     |---geth          *4*\n     |---keystore      *4*\n|---rinkeby            *5*\n     |---geth          *4*\n     |---keystore      *4*\n```", "```\ngeth\n|---chaindata    *1*\n|---ethash       *2*\n|---nodes        *3*\n```", "```\n{\n    \"config\": {                   *1*\n        \"chainId\": 10101010,      *2*\n        \"homesteadBlock\": 0,      *3*\n        \"eip155Block\": 0,         *3*\n        \"eip158Block\": 0          *3*\n    },\n    \"difficulty\": \"4000\",         *4*\n    \"gasLimit\": \"3141592\",        *5*\n    \"alloc\": {                    *6*\n\n    }\n}\n```", "```\nC:\\program files\\geth>geth --networkid 10101010 \n--identity \"PrivateNetMaster\" --rpc \n--rpcapi=\"db,eth,net,web3,personal,web3\" \n--datadir \"C:\\privatenet\" --port \"30303\" --nodiscover \n--maxpeers 0 init C:\\privatenetdev\\genesis.json\n```", "```\nC:\\program files\\geth>geth --networkid 10101010 \n--identity \"PrivateNetMaster\" --rpc \n--rpcapi=\"db,eth,net,web3,personal,web3\" \n--datadir \"C:\\privatenet\" --port \"30303\" \n--nodiscover --maxpeers 0\n```", "```\nC:\\Program Files\\Geth>geth attach ipc:\\\\.\\pipe\\geth.ipc\nWelcome to the Geth JavaScript console!\n\ninstance: Geth/PrivateNetMaster/v1.7.3-stable-4bb3c89d/windows-amd64/go1.9\nat block: 1 (Mon, 26 Jun 2017 09:31:42 BST)\n datadir: C:\\privatenet\n modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0\n txpool:1.0 web3:1.0\n```", "```\n>personal.newAccount(\"PASSWORD OF ETHERBASE ACCOUNT\")\n\"0x3f9e54337cce348607b76200fc19f3f6e3e8e358\"\n```", "```\n>miner.setEtherbase(\"0x3f9e54337cce348607b76200fc19f3f6e3e8e358\")\n```", "```\n>personal.newAccount(\"PASSWORD OF ACCOUNT 2\")\n\"0x336a008e3a3b099bcd125cd54fc193070fe1d177\"\n```", "```\n>miner.start() \n```", "```\n> eth.getBalance(eth.coinbase).toNumber();\n0\n```", "```\n>eth.getBalance(eth.coinbase).toNumber();\n5000000000000000000\n```", "```\n>miner.stop()\n```", "```\n> personal.unlockAccount(eth.coinbase, \"PASSWORD OF ETHERBASE ACCOUNT\");\n> eth.sendTransaction({from:eth.coinbase, \nto:eth.accounts[1], value: web3.toWei(2.0, \"ether\")})\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node deploySimpleCoin.js\n```", "```\nContract mined! address: 0x4291f37a727d32e5620a0a4ed61d27ffdad757af\n transactionHash: 0x2b7d2a015ca3397c1ec2b2d8e14b6c8ca7e3c06340d759a10d0e5358\n 43532fe6\n```", "```\nINFO [06-26|09:19:52] Submitted contract creation fullhash=\n 0x2db88eadcd908f8c66294f2d427825e46bf820f089277f436ed5165f739efbbd\n contract=0xd144854e0d90e49726fab8e613115c217ee5262c\n```", "```\n> miner.start()\n```", "```\nContract mined! address: 0xd144854e0d90e49726fab8e613115c217ee5262c\n transactionHash: 0x2db88eadcd908f8c66294f2d427825e46bf820f089277f436ed5165f\n 739efbbd\n```", "```\n...\n\n  address: \"0xd144854e0d90e49726fab8e613115c217ee5262c\",\n  transactionHash:\n \"0x2db88eadcd908f8c66294f2d427825e46bf820f089277f436ed5165f739efbbd\",\n  Transfer: function(),\n\n  allEvents: function(),\n  coinBalance: function(),\n  transfer: function()\n}\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode\\>npm install -g ganache-cli@6.1.8\n```", "```\nc:\\>ganache-cli\n```", "```\nconst fs = require('fs');\nconst solc = require('solc');\n\nconst Web3 = require('web3');\nconst web3 = new Web3(\nnew Web3.providers.HttpProvider(\"http://localhost:8545\"));\n\nconst account2 = web3.eth.accounts[1];\nconst sender = account2;\n\nconst initialSupply = 10000;\n\nconst source = fs.readFileSync(\n'c:/Ethereum/SimpleCoin/SimpleCoin.sol', 'utf8');\nconst compiledContract = solc.compile(source, 1);\nconst abi = compiledContract.contracts[':SimpleCoin'].interface;\nconst bytecode = '0x' + compiledContract.contracts[':SimpleCoin'].bytecode;\nconst gasEstimate = web3.eth.estimateGas({ data: bytecode }) + 100000;\n\nconst SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\n\nconst simpleCoinInstance = SimpleCoinContractFactory.new(initialSupply, {\n    from: sender,\n    data: bytecode,\n    gas: gasEstimate\n   }, function (e, contract){\n    console.log(e, contract);\n    if (typeof contract.address !== 'undefined') {\n         console.log('Contract mined! address: ' \n         + contract.address \n         + ' transactionHash: ' + contract.transactionHash);\n    }\n });\n```", "```\nC:\\>ganache-cli\n```", "```\nC:\\Ethereum\\SimpleCoinWithNode>node deployingSimpleCoinOnGanache.js\n```", "```\nListening on localhost:8545\neth_accounts\neth_estimateGas\neth_sendTransaction\n\n  Transaction: 0x25a3ee4ef5f71e72ab1800a78782d42676aec61503eaab1ef8beaf\n2e54993038\n  Contract created: 0xdc6d598f56cf80201d95b4e9494e83bab8aa479e\n  Gas usage: 509317\n  Block Number: 1\n  Block Time: Wed Feb 21 2018 01:49:20 GMT+0000 (GMT Standard Time)\n\neth_newBlockFilter\neth_getFilterChanges\neth_getTransactionReceipt\neth_getCode\neth_uninstallFilter \n```", "```\nContract mined! address: 0xedaa9632746aa82b0f1f73185c38a437643116af\n transactionHash: 0xfa4d8a6e526d53ace153b2619c47f9e29359125dbf28e4d97d8f5af0\n cdd051d7\n```", "```\nContract mined! address: 0xedaa9632746aa82b0f1f73185c38a437643116af\n transactionHash: 0xfa4d8a6e526d53ace153b2619c47f9e29359125dbf28e4d97d8f5af0\n cdd051d7\n```", "```\nvar web3 = new Web3(\nnew Web3.providers.HttpProvider(\"http://localhost:8545\"));\n\nvar abi = \"[{\\\"constant\\\":false,\\\"inputs\\\":[{\\\"name\\\":\\\"_to\\\",\\\"type\\\":\\\n\"address\\\"},{\\\"name\\\":\\\"_amount\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\n\"transfer\\\",\\\"outputs\\\":[],\\\"payable\\\":false,\\\"type\\\":\\\"function\\\"},{\\\n\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\n\":\\\"coinBalance\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\n\"payable\\\":false,\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"name\\\":\\\n\"_initialSupply\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"type\\\":\\\n\"constructor\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":true,\\\"name\\\n\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true,\\\"name\\\":\\\"to\\\",\\\"type\\\n\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"name\\\":\\\"value\\\",\\\"type\\\":\\\"uint256\\\n\"}],\\\"name\\\":\\\"Transfer\\\",\\\"type\\\":\\\"event\\\"}]\";\nvar SimpleCoinContractFactory = web3.eth.contract(JSON.parse(abi));\nvar simpleCoinContractInstance = SimpleCoinContractFactory.at(\n'0xedaa9632746aa82b0f1f73185c38a437643116af');                   *1*\nvar accounts = web3.eth.accounts;\n\nfunction refreshAccountsTable() {                                *2*\n     var innerHtml = \n        \"<tr><td>Account</td><td>Balance</td>\";                  *3*\n\n     for (var i = 0; i < accounts.length; i++) {                 *4*\n            var account = accounts[i];\n            var balance = \n                simpleCoinContractInstance\n                 .coinBalance(account);                          *5*\n            innerHtml = innerHtml + \n              \"<tr><td>\" + \n              account + \"</td><td>\" \n              + balance + \"</td></tr>\";\n     }\n\n     $(\"#accountsBalanceTable\").html(innerHtml);\n}\n\nfunction transferCoins() {                                       *6*\n     var sender = $(\"#from\").val();\n     var recipient = $(\"#to\").val();\n     var tokensToTransfer = $(\"#amount\").val();\n     simpleCoinContractInstance.transfer(                        *7*\n        recipient, \n        tokensToTransfer, \n        {from:sender,gas:200000},\n        function(error, result){\n           if(!error)\n              refreshAccountsTable();                            *8*\n           else\n              console.error(error);\n        }\n     );\n}\n\n$( document ).ready(function() {                                 *9*\n     refreshAccountsTable();\n});\n```", "```\nC:\\Ethereum\\SimpleCoinWebUI>npm install -g bower\n```", "```\nC:\\Ethereum\\SimpleVotingWebUI>bower install web3#0.20.6\nC:\\Ethereum\\SimpleVotingWebUI>bower install jquery\n```", "```\nbower_components\n   |--web3\n   |--jquery\n```", "```\n<html>\n<head>   \n   <script src=\"bower_components/web3/dist/web3.min.js\"></script>\n\n   <script src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n   <script src=\"./simplecoin.js\"></script>\n</head>\n<body>\n   <table>\n      <tr><b>SimpleCoin</b></tr>\n       <tr><table border=\"0\" cellpadding=\"0\" width=\"200\"\n     id='accountsBalanceTable'> </table></tr>\n       <tr/>\n       <tr/>\n       <tr>Transfer coins</tr>\n       <tr>\n            <table border=\"0\" cellpadding=\"0\" width=\"200\" id='transferCoins'> \n               <tr>\n                 <td>From:</td><td><input type=\"text\" id=\"from\" width=\"400\"\n     /></td>\n                 <td>To:</td><td><input type=\"text\" id=\"to\" width=\"400\"\n     /></td>\n                 <td>Amount:</td><td><input type=\"text\" id=\"amount\" /></td>\n                 <td><button onclick=\"transferCoins()\">Transfer</button></td>\n               </tr>\n            </table>\n       </tr>\n   </table>\n</body>\n</html>\n```"]