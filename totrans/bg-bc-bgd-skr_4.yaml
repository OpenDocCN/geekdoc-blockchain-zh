- en: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal,
    Gautam Dhameja and Priyansu Sekhar PandaBeginning Blockchain[https://doi.org/10.1007/978-1-4842-3444-0_4](A440588_1_En_4_Chapter.xhtml)
  prefs: []
  type: TYPE_NORMAL
- en: 4. How Ethereum Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1)Bangalore,
    Karnataka, India(2)Berlin, Berlin, GermanyThe era of blockchain applications has
    just begun. Ethereum is here to be the defacto blockchain platform for building
    decentralized applications. We already learned in the previous chapters that public
    blockchain use cases are not just limited to cryptocurrencies, and the possibilities
    are only limited by your imagination! Ethereum has already made inroads in many
    business sectors and works best not only for public blockchain use cases, but
    also for the private ones. Ethereum has already set a benchmark for blockchain
    platforms and must be studied well to be able to envision how usable decentralized
    applications can be built with or without using Ethereum. Today, it is possible
    to build blockchain applications with minimal knowledge of cryptography, game
    theory, mathematics or complex coding, and computer science fundamentals, thanks
    to Ethereum.In Chapter [3](A440588_1_En_3_Chapter.xhtml), we learned how Bitcoin
    works by taking a deep dive into the protocol as well as the Bitcoin application.
    We witnessed how the cryptocurrency aspect is so much interwoven into the Bitcoin
    protocol. We learned that Bitcoin is not Bitcoin on blockchain, rather a Bitcoin
    blockchain. In this chapter, we will learn how Ethereum has successfully built
    an abstract foundation layer that is capable of empowering various different blockchain
    use cases on the same blockchain platform.
  prefs: []
  type: TYPE_NORMAL
- en: From Bitcoin to Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously, blockchain technology  came along with Bitcoin back in 2009\. After
    Bitcoin stood the test of time, people believed in the potential of blockchain.
    The use cases now have gone beyond banking and finance sectors and have enveloped
    other industries such as supply chain, retail, e-commerce, healthcare, energy,
    and government sectors as well. This is because different flavors of blockchain
    have come up and address specific business problems. Nonetheless, there are public
    blockchain platforms such as Ethereum that allow different decentralized use cases
    to be built on the same public Ethereum platform.With Bitcoins, decentralized
    peer-to-peer transaction of cryptocurrency was possible. People realized that
    blockchain could be used to transact and keep track of anything of value, not
    just cryptocurrency. People started exploring if the same Bitcoin network could
    be used for any other use case. To give you an example, “proof of existence” is
    one such use case where the hash of a document was injected in the Bitcoin blockchain
    network so that anyone could later verify that such a ducument was existant in
    so and so point in time. Vitalik Buterin introduced the Ethereum blockchain platform
    that could facilitate transactions of not just money, but also shares, lands,
    digital content, vehicles, and many others that have some intrinsic value. Take
    a look at Figure [4-1](#Fig1).![A440588_1_En_4_Fig1_HTML.jpg](Images/A440588_1_En_4_Fig1_HTML.jpg)Figure
    4-1Multiple decentralized applications on one Ethereum platformLike Bitcoin, Ethereum  is
    a public blockchain platform with a different design philosophy. The most innovative
    approach was to build an abstraction layer so that transactions from different
    applications are generalized to the program code that can run on all the Ethereum
    nodes. Even in Ethereum, the miners generate Ether, a tradeable cryptocurrency
    because of which the public blockchain network is self-sustainable. Any application
    that is running on Ethereum has to pay transaction fees that eventually the miners
    get for running the nodes and sustaining the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum as a Next-Gen Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the Bitcoin blockchain, the developer community tried building different
    decentralized applications with a completely new blockchain, or were trying to
    modify Bitcoin Core to increase the set of functionalities. Either way, it was
    complicated as well as time consuming. A different design with an alternative
    protocol was probably the need of the hour then, which is why the Ethereum blockchain
    platform! The purpose was to facilitate development of many blockchain applications
    on one Ethereum platform rather than building dedicated blockchains for each application
    separately. Ethereum enabled rapid development of decentralized applications that
    could interact among themselves, ensuring adequate security. As mentioned in the
    previous section, Ethereum does this by building an abstract foundation layer.
    Unlike Bitcoin, Ethereum supported Turing-complete language so anyone could write
    smart contracts that could virtually do anything and everything on a programming
    perspective. Also, Ethereum is stateful by design and keeps track of the acount
    states, which is very different from Bitcoin where everything remains as a transaction
    and there is no internal persistent memory for scripts. With the help of an abstract
    foundation layer, the underlying complexities are hidden from the developers and
    not just that; the developers get the flexibility of designing their own state
    transition functions for direct transfer of value and information, and transaction
    formats.In an effort to meet the objective, the core innovation of Ethereum was
    the Ethereum Virtual Machine (EVM). The support for Turing-complete languages
    through the EVM makes it easy for the developers to create blockchain applications.
    Just the way a Java Virtual Machine (JVM) is required to run Java code, EVM is
    required to run the smart contracts. For now, just keep in mind that smart contracts
    are the Ethereum scripts written in a Turing-complete language that automatically
    gets executed in case a predefined event occurs. The “ScriptSig” and “ScriptPubKey”
    in Bitcoins are the basic versions of smart contracts so to speak. We learned
    in the previous chapter that in Bitcoins, the instruction set was very limited.
    In Ethereum, however, one could code almost any program that would run on the
    EVM on each and every node in the Ethereum blockchain network. The decentralized
    applications in Ethereum are called DApps. Ethereum being a global decentralized
    computer system with no centralized server, DApps are the applications that run
    without downtime, fraud, or any sort of regulations. A peer-to-peer electronic
    cash system such as Bitcoin is very easy to build on Ethereum as a DApp. Similarly,
    any other asset with some intrinsic value, such as land, cars, houses, votes,
    etc., could easily be transacted through their respective DAaps on Ethereum in
    the form of tokens.Unlike traditional software development and deployment, DApps
    do not need to be hosted on a back-end server. The “code” is embedded as payload
    in transactions, so to speak, that are then sent to the mining nodes in the Ethereum
    network. Such transactions would be considered by the mining ecosystem because
    of the ETH (Ether) paid as “gas Price.” Like in Bitcoin, these transactions get
    broadcast to other miners in the network that they are accessible to. The transaction
    then eventually gets into a block and becomes an eternal part of the blockchain
    when consensus is reached. Developers have the liberty to code up any solution
    and deploy that in the Ethereum network. The network executes that, all by itself,
    and validates and produces the outputs as well. Well, had it been without any
    cost, the network wouldn’t have been sustainable. There is a gas Price associated
    with each blockchain transaction, and writing some garbage code and deploying
    that into the Ethereum network could be an expensive affair!
  prefs: []
  type: TYPE_NORMAL
- en: Design Philosophy of Ethereum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ethereum borrows many concepts from Bitcoin Core as it stood the test of time,
    but is designed with a different philosophy. Ethereum development has been done
    following certain principles as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplistic design: The Ethereum blockchain is designed to be as simple as possible
    so that it is easy to understand and develop decentralized applications on. The
    complexities in the implementation are kept to a bare minimum at the consensus
    level and are managed at a level above it. As a result, high-level language compilation
    or serialization/deserialization of arguments, etc. are not a concern for the
    developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Freedom of development: The Ethereum platform is designed to encourage any
    sort of decentralization on its blockchain platform and does not discremenate
    or favor any specific kinds of use cases. This freedom is given to an extent that
    a developer can code up an infinite loop in a smart contract and deploy it. Obviously,
    the loop will run as long as they are paying the transaction fee (gas Price),
    and the loop eventually terminates when it runs out of gas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No notion of features: In an effort to make the system more generalized, Ethereum
    does not have built-in features for the developers to use. Instead, Ethereum provides
    support for Turing-complete language and lets the users develop their own features
    the way they want to. Starting from basic features such as “locktime,” as in Bitcoin
    till full blown use cases, everything can be coded up in Ethereum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the Ethereum Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned about the objective behind Ethereum blockchain and its design philosophy.
    To be able to understand and appreciate this next-gen blockchain and build decentralized
    applications on it, we will learn about the core components of Ethereum in great
    detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ethereum blockchain data structure is pretty similar to that of Bitcoin’s,
    except that there is a lot more information contained in the block header to make
    it more robust and help maintain the state properly. We will learn more about
    the Ethereum states in the following sections. Let us focus more on the blockchain
    data structure and the header in this section. In Bitcoins, there was only one
    Merkle root in the block header for all the transactions in a block. In Ethereum,
    there are two more Merkle roots, so there are three Merkle roots in total as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'stateRoot: It helps maintain the global state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'transactionsRoot: It is to track and ensure integrity of all the transactions
    in a block, similar to Bitcoin’s Merkle root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'receiptsRoot: It is the root hash of the receipts trie corresponding to the
    transactions in a block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will take a look at these Merkle roots in their respective sections of block
    header information. For better comprehension, take a look at Figure [4-2](#Fig2).![A440588_1_En_4_Fig2_HTML.jpg](Images/A440588_1_En_4_Fig2_HTML.jpg)Figure
    4-2The blockchain data structure of EthereumEvery block usually comprises block
    header, transactions list, uncles list, and optional extraData. Let us now take
    a look at the header fields to understand what they mean and their purpose for
    being in the header. While you do so, keep in mind that there could be slight
    variants of these names in different places, or the order in which they are presenbted
    could be different in different places. We suggest that you build a proper understanding
    of these fields so that any different terminology that you might come across won’t
    bother you much.Section-1: Block metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'parentHash: Keccak 256-bit hash of the parent block’s header, like that of
    Bitcoin’s style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'timestamp: The Unix timestamp current block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'number: Block number of the current block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beneficiary: The 160-bit address of “author” account responsible for creating
    the current block to which all the fees from successfully mining a block are collected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section-2: Data references'
  prefs: []
  type: TYPE_NORMAL
- en: 'transactionsRoot: The Keccak 256-bit root hash (Merkle root) of the transactions
    trie populated with all the transactions in this block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ommersHash: It is otherwise known as “uncleHash.” It is the hash of the uncles
    segment of the block, i.e., Keccak 256-bit hash of the ommers list portion of
    this block (blocks that are known to have a parent equal to the present block’s
    parent’s parent).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'extraData: Arbitrary byte array containing data relevant to this block. The
    size of this data is limited to 32 bytes (256-bits). As of this writing, there
    is a possibility that this field might become “extraDataHash”, which will point
    to the “extraData” contained inside the block. extraData could be raw data, charged
    at the same amount of gas as that of transaction data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section-3: Transaction execution information'
  prefs: []
  type: TYPE_NORMAL
- en: 'stateRoot: The Keccak 256-bit root hash (Merkle root) of the final state after
    validating and executing all transactions of this block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'receiptsRoot: The Keccak 256-bit root hash (Merkle root) of the receipts trie
    populated with the recipients of each transaction in this block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'logBloom: The accumulated Bloom filter for each of the transactions’ receipts’
    Blooms, i.e., the “OR” of all of the Blooms for the transactions in the block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasUsed: The total amount of gas used through each of the transactions in this
    block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasLimit: The maximum amount of gas that this block may utilise (dynamic value
    depending on the activity in the network)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section-4: Consensus-subsystem information'
  prefs: []
  type: TYPE_NORMAL
- en: 'difficulty: The difficulty limit for this block calculated from the previous
    block’s difficulty and timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mixHash: The 256-bits mix hash combined with the ‘nonce’ for the PoW of this
    block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'nonce: The nonce is a 64-bit hash that is combined with mixHash and can be
    used as a PoW verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ethereum accounts, unlike Bitcoins, are not in the form of unspent transaction
    outputs (UTXOs). In the Bitcoin chapter, we learned that Bitcoins are actually
    present in the form of transactions that have an owner (owner’s public key, 20-byte
    address) and a value. The owner can spend the transaction if they have the valid
    private key for the transaction they are trying to spend. Bitcoin therefore is
    a state transition system where “state” refers to the collection of all UTXOs.
    Every time a block is mined, a state change happens because each block contains
    a bunch of transactions where each transaction cosumes UTXO(s) and produces UTXO(s).
    Note here that the state is not encoded inside the blocks. So, there is no notion
    of an account balance as such in Bitcoin’s design. Ethereum on the other hand
    is stateful, and its basic unit is the account. Each account has a state associated
    with it and also has a 20-byte (160 bits) address through which it gets identified
    and referenced. The purpose of blockchain in Ethereum is to keep track of the
    state changes. There are broadly two types of Ethereum accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Externally Owned Accounts (EOAs) : These accounts are also known as “simple
    accounts” that are usually owned by users or devices who control these accounts
    using Private Keys. The EOAs can send transactions to other EOAs or Contract Accounts
    by signing with a private key. The transaction between two EOAs is usually to
    transfer any form of value. On the other hand, when an EOA makes a transaction
    to a Contract Account, the purpose is to activate the “code” inside the Contract
    Account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contract Accounts: These are controlled only by the code contained in them.
    This code inside the Contract Accounts is referred to as “smart contracts  .”
    They are usually activated when a transaction is sent to the Contract Account
    by the EOAs or by other Contract Accounts. Even though the Contract Accounts are
    capable of executing complex business logics through the code they contain, they
    can’t initiate new transactions on their own and always depend on the EOAs. All
    they can do is respond to other transactions (obviously by making transactions)
    as per the logic coded in their “code.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the following three scenarios (Figures [4-3](#Fig3) to [4-5](#Fig5))
    to get a better understanding on the communication between the EOAs and Contract
    Accounts.EOA to EOA transaction:![A440588_1_En_4_Fig3_HTML.jpg](Images/A440588_1_En_4_Fig3_HTML.jpg)Figure
    4-3EOA to EOA transactionEOA to Contract Account Transaction:![A440588_1_En_4_Fig4_HTML.jpg](Images/A440588_1_En_4_Fig4_HTML.jpg)Figure
    4-4EOA to Contract Account transactionEOA to Contract Account to other Contract
    Account transaction:![A440588_1_En_4_Fig5_HTML.jpg](Images/A440588_1_En_4_Fig5_HTML.jpg)Figure
    4-5EOA to Contract Account to Contract Account transactionJust so the previous
    representations are not confusing, please be aware that the Contract Accounts
    are internal and the communications between them, too. Unlike EOA accounts where
    EOAs make a transaction that gets injected in the blockchain, Contract Accounts
    and the transactions between them are internal phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of UTXOs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We must understand that Bitcoin’s design perspective was to maintain anonymity
    to an extent possible. When we compare it with Ethereum, the following advantages
    of UTXOs seem to have a lot of significance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Better privacy: In Bitcoins, it is advisible to use a new address while receiving
    transactions, which helps reinforce anonymity. Even with sophisticated statistical
    or machine learning techniques, it is difficult to link the accounts together,
    though not impossible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Potentially more scalable: The discussion pertaining to scalability is usually
    very subjective and depends on the context, use case at hand, and many other factors.
    The intention here is to just mention UTXO’s inherent potential to scale. It is
    very easy to execute the transactions in parallel. Also, when an owner or other
    nodes maintaining the Merkle proof of ownership data for some coins lose this
    data, only the owner is impacted. On the contrary, when Merkle tree data for some
    account is lost, then any operation on that account would not be feasible, even
    sending to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of Accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even though Ethereum in a way is an extention to Bitcoin, it is imagined with
    a whole new design with its own set of pros–cons tradeoff. Let us take a look
    at the following advantages of Ethereum accounts compared with Bitcoin design:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Significant space saving: In Bitcoins, when multiple transactions are clubbed
    together to make one transaction (e.g., if you have to make a 5BTC transaction
    and you never received one transaction with at least 5BTC that you could use in
    this case, then you have to bundle multiple transactions so the total exceeds
    5BTC), that many references to those individual transactions must be made. Also,
    all those transactions must have different addresses, so as many transactions,
    that many addresses also! In Ethereum accounts, however, just one reference to
    an account is good enough. Even though Ethereum uses Merkle Patricia tree (MPT)  ,
    which is a bit more space intensive than Merkle tree, you end up saving a significant
    amount of space for complex transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple to code: Along with UTXOs and scripts that are not Turing-complete,
    it is difficult to design complex systems. UTXOs can either be spent or unspent;
    there is no other state possible in between. Which makes it difficult to code
    up complex business logics. Even if the scripts are empowered to do more, it gets
    more complicated as compared with just using accounts. Since the objective of
    Ethereum is to go beyond cryptocurrency and accommodate different kinds of use
    cases (through DApps), an accounts-based system is almost inevitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lightweight client reference: Unlike Bitcoin clients, Ethereum client applications
    can easily and quickly access all the data related to an account by scanning down
    the state tree in a specific direction. In the UTXO model, there are usually multiple
    references to multiple transactions associated to any specific transaction under
    consideration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We learned that every account has a state associated with it. We also looked
    at the two kinds of accounts that exist with Ethereum, one is a Contract Account
    and the other is an Externally Owned Account or EOA. Regardless of the account
    type, they are tracked by the “stateRoot” Merkle root in the block header and
    may appear as shown in Figure [4-6](#Fig6).![A440588_1_En_4_Fig6_HTML.jpg](Images/A440588_1_En_4_Fig6_HTML.jpg)Figure
    4-6Zooming in to account state representationAs you can see in the figure, irrespective
    of whether the account is an EOA or or a Contract Account, it has the following
    four components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Account balance: Total “Ether” balance in the account. More precisely, number
    of Wei owned by the address (1ETH = 10^(18) Wei)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CodeHash: This is the hash of the “code.” Every Contract Account has “code”
    in it that gets executed on the EVM. The hash of this code is stored in this CodeHash
    field. For the EOA accounts, however, there is no “code,” so the CodeHash field
    contains the hash of empty string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'StorageRoot: It is the 256-bit root hash of Merkle tree that encodes the storage
    contents of an account. The MPT encodes the hash of the storage content. Keeping
    the root hash of this tree in the StorageRoot field helps track the content of
    an account and also helps ensure its integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nonce: It is a counter that ensures each transaction is processed only once.
    For EOAs, this number represents the number of transactions from the account’s
    address. For Contract Accounts, it represents the number of contracts created
    by this account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it is the “state” trie that is responsible to keep track of the state changes
    of Ethereum blockchain. However, what is a bit tricky is that the state is not
    directly stored in each block, rather in the form of Recursive Length Prefix (RLP)-encoded
    state data in MPT at every Ethereum node. So, to maintain the global state, the
    Ethereum blockchain includes “state roots” in each and every block that store
    the root hash of the hash tree (Merkle root) representing the system state at
    the time the block was created.As per the Ethereum Yellow Paper, the “World State”
    is a mapping between addresses (160-bit identifiers) and account states. So, the
    World State has the information of all the accounts in blockchain, but is not
    stored in each block. Each block only modifies parts of the state. In a way, the
    World State is generated processing each block since the genesis block. Certain
    Ethereum nodes can choose to maintain all historical states by keeping all the
    historical transactions, that is, state transitions and their outputs. This allows
    clients to query the state of the blockchain at any time, even for the historic
    ones, without having to recalculate everything from the beginning. Retrieving
    the state information is similar to an aggregate query in SQL where data is readily
    available; just aggregation is required. So, old state data can easily be discarded
    (this is known as “pruning”) because they can be computed back when required.
    Well, the state data by design is implicit dada, which means state information
    should only be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Trie Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We learned the three types of tries that have their roots in the block header.
    These roots are basically the pointers to those three tries. Though we looked
    at the one-liner explanations of these tries in previous sections, let us just
    revisit them with a slightly different choice of words
  prefs: []
  type: TYPE_NORMAL
- en: 'State trie: It represents the entire state (the global state) after accessing
    the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transaction trie: It represents all the transactions in a block keyed by index
    (i.e., key:0 for the first transaction to execute, key:1 for the second transaction,
    etc.). Recollect the MPT fundamentals we covered earlier and try to correlate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Receipt trie: It represents the "receipts" corresponding to each transaction.
    A receipt for a transaction is an RLP-encoded data structure as shown following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ medstate, gas_used, logbloom, logs ]Let’s now dig deeper into the Receipt
    trie as we havn’t covered the basics yet on this. Take a look at all the fields
    in the Receipt trie’s RLP-encoded data structure and follow through the following
    descriptions for those fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'medstate: It is the State trie root after processing the transaction. A successful
    transaction updates the Ethereum state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gas_used: It is the total amount of gas used for processing the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'logs: It is a list of items of the form-'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[address, [topic1, topic2...], data]'
  prefs: []
  type: TYPE_NORMAL
- en: These list items are produced by the LOG0, LOG1… opcodes during the execution
    of the transaction. The “address” field is the address of the contract that produced
    the log, the “topic” fields are up to four 32-byte values, and the “data” field
    is an arbitrarily sized byte array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logbloom: It is a Bloom filter made up of the addresses and topics of all logs
    in the transaction. This is different from the one present in the block header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merkle Patricia Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ethereum, the accounts are mapped with their respective states. The mapping
    between all the Ethereum accounts, including EOAs and Contract Accounts with their
    states, is collectively referred to as World States. To store this mapping data,
    the datastructure used in Ethereum is the MPT. So, MPT is the principal data structure
    used in Ethereum which is otherwise known as Merkle Patricia trie. We learned
    about the Merkle trees in the Bitcoin chapter, which already takes us half way
    through in understanding MPT. MPT is actually derived by taking elements from
    both Merkle tree and Patricia tree.Recollect from the Bitcoin chapter that Merkle
    trees are the binary hash trees where the leaf nodes contain the hash of the data
    blocks and every nonleaf node contains the hashes of their child nodes. When such
    a data structure is implemented, it becomes easy to check if a certain transaction
    was a part of a block. Only by using very little information from the entire block,
    that is, by using just the Merkle branch instead of the entire tree, providing
    proof of membership was quite easy. Merkle trees facilitate efficient and secure
    verification of the contents in decentralized systems. Instead of downloading
    every transaction and every block, the light clients can only download the chain
    of block headers, that is, 80-byte chunks of data for each block that contain
    only five things: hash of the previous block header, timestamp, mining difficulty,
    nonce value that satisfied PoW, and the root hash of the Merkle tree containing
    all the transactions for that block. While it is quite useful and interesting,
    note here that apart from validating the proof of membership for a transaction
    in a block, there is nothing much you could do. One particular limitation is that
    no information can be proved about the current state (e.g., total digital asset
    holdings, name registrations, status of financial contracts). Even to check how
    many Bitcoins you hold, quite a lot of querying and validating is involved.Patricia
    trees on the other hand are a form of Radix trees. The name PATRICIA stands for
    “Practical Algorithm to Retrieve Information Coded In Alphanumeric.” A Patricia
    tree facilitates efficient insert/delete operations. The key-value lookups in
    the Patricia tree are very efficient. Keys are always encoded in the path. So,
    “key” is the path that you take from the root till the leaf node where the “value”
    is stored. Keys are usually the strings that help descend down the path where
    each character indicates which child node to follow to reach the leaf node and
    find the value stored in it.So, the MPTs provide a cryptographically authenticated
    data structure used to store all (key, value) bindings in Ethereum. They are fully
    deterministic, meaning that a Patricia tree with the same (key, value) bindings
    will surely be the same down to the last byte. The insert, lookup, and delete
    operations are quite efficient with O(log(n)) complexity. Due to the Merkle part
    in MPT, hash of a node is used as the pointer to the node and the MPT is constructed
    accordingly, whereKey == SHA3(RLP(value))While the Merkle part provides a tamperproof
    and deterministic tree structure, the Patricia part provides an efficient information
    retrieval feature. So, if you notice carefully, the root node in MPT becomes a
    cryptographic fingerprint of the entire data structure. In the Ethereum P2P network,
    when transactions are broadcast over the wire, they are assembled by every mining
    node that received them. The nodes then form a Tree (a.k.a. trie) and compute
    the root hash to include in the Block header. While the transactions are stored
    locally in the tree, they are sent to other nodes or clients after they are serialized
    to lists. The receiving parties have to deserialize them back to form the transaction
    tree to verify against the root hash. Also note that in Ethereum, MPTs are a little
    modified for better fitment with Ethereum implementation. Instead of binary, hexadecimal
    is used—X characters from a 16 character “alphabet.” Hence nodes in the tree or
    trie have 16 child nodes (the 16 character hex alphabet) and a maximum depth of
    X. Just to let you know, a hex character is referred to as a “nibble” in many
    places.The basic idea of an MPT in Ethereum is that for a single operation, it
    will only modify the minimum amount of nodes to recalculate the root hash. This
    way the storage and complexities are kept minimal.'
  prefs: []
  type: TYPE_NORMAL
- en: RLP Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must have noticed that we mentioned RLP encoding in previous sections. We
    will give you a heads-up on what it is all about in this section. RLP stands for
    Recursive Length Prefix. It is a serialization method used in Ethereum for blocks,
    transactions, and wire protocol messages while sending data over the wire and
    also for account state data while saving the state in Patricia tree. In general,
    when complex data structures need to be stored or transmitted and then get reconstructed
    at the receiving end for processing, object serialization is a good practice.
    RLP in that sense is similar to JSON and XML, but RLP is believed to be more minimalistic,
    space efficient, simple to implement, and guarantees absolute byte-perfect consistency.
    This is why RLP was chosen to be the main serialization technique for Ethereum.
    Its sole purpose is to store nested arrays of raw bytes. It does not try to define
    any specific data types either, such as Booleans, floats, doubles, integers, etc.,
    and is only designed to store structure in the form of nested arrays. Key/value
    maps are not explicitly supported by RLP. So, it is advisible to represent such
    maps as [[k1, v1], [k2, v2], …], where k1, k2… are in lexicographic order (sorted
    using the standard ordering for strings). Alternatively, use the higher-level
    [Patricia tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree) encoding
    that has an inherent RLP encoding scheme.Please keep in mind that RLP is used
    only to encode the structure of the data and is completely unaware of the type
    of object being encoded. While it helps reduce the size of the encoding array
    of raw bytes, the decoding end must be aware of the type of object it is trying
    to decode.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Transaction and Message Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we looked at the block structure and the different
    fields in the block’s header. For a transaction to be qualified by the miners
    or Ethereum nodes, it has to have a standardized structure. A typical Ethereum
    transaction (e.g., what you pass through sendRawTransaction()that we will see
    later in this book) consists of the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'nonce: It is an integer, just a counter equal to the number of transactions
    sent by the sender account, i.e., transaction sequence number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasPrice: Price you are willing to pay in terms of the number of Wei to be
    paid per unit of gas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasLimit: The maximum amount of gas that should be used in executing this transaction,
    which also limits the maximum number of computational steps the transaction execution
    is allowed to take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To: Recipient’s 160-bits address or Contract’s address. For the transaction
    that is used to create a contract (it means contract’s address does not exist
    yet), it is kept empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value: Total Ether (number of Wei) to be transferred to the recipient by the
    transaction sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'V, r, s: values corresponding to the ECDSA signature of the transaction; also
    represent the sender of this transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'init: This is not really an optional field, only used with transactions used
    for creating contracts. This field can contain an unlimited size byte array specifying
    the EVM-code for the account initialisation procedure.The opcode “init” is used
    only once for initializing the new Contract Account and gets discarded after that.
    It returns the body of the account code after associating it with the Contract
    Account. Keep in mind that this association is a permanent phenomenon and never
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data: An optional field that can contain a message to be sent to a contract
    or simple account. It has no special function as such by default, but the EVM
    has an opcode —using which, a contract can access this data field and perform
    necessary computations and place them in storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note carefully that the aforementioned fields are supplied in the order specified
    and are all RLP encoded, except for the field names. So, an Ethereum transaction
    actually means a signed data package with these fields. The gasPrice and gasLimit
    fields are important to prevent denial of service attack. In order to prevent
    accidental or deliberate attempts of infinite loops or other computational wastage
    in code, each transaction is required to set a limit on how many computational
    steps for code execution it can use.Ethereum transactions are actually the "state
    transition functions" because a successful transaction changes the state. Also,
    the result of these transactions can be stored, as we already looked at in the
    “Account State” section previously.Ethereum messages on the other hand are like
    transactions, but are triggered only by Contract Accounts and not by EOAs. Also,
    messages are only meant to be between the Contract Accounts, due to which they
    are also referred to as "internal transactions." So, contracts have the ability
    to send messages to other contracts.Typically, a message is produced when a contract,
    while executing its code, encounters the “CALL” or “DELEGATECALL” opcodes. So,
    messages are more like function calls that exist in the Ethereum execution environment.
    It is also important to note that messages are always raw and never serialized
    or deserialized. A message contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sender: The sender of the message as an implicit option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recipient: The recipient contract address to send to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value: The amount of Wei to transfer to the contract address along with the
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data: Optional field, but can contain input data for the recipient contract
    provided by the sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasLimit: The value that limits the maximum amount of gas the code execution
    can consume when triggered by the message. It is also termed “startGas.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We looked at the transaction and messages. An Ethereum transaction can be from
    an EOA to an EOA, or from an EOA to a Contract Account. There exists another situation
    where a transaction from an EOA is initiated to create a Contract Account (recollect
    the “init” field that we just covered). Now, just think about what exactly a transaction
    is? It is definitely the bridge between the external world and the Ethereum blockchain,
    but what more? If you zoom in to a transaction, you will see that it is an instruction,
    initiated by the EOA by signing it, which gets serialized and submitted to the
    blockchain. Take a look at Figure [4-7](#Fig7).![A440588_1_En_4_Fig7_HTML.jpg](Images/A440588_1_En_4_Fig7_HTML.jpg)Figure
    4-7Transaction initiation—zoomed inNow what happens after a transaction is injected
    into the blockchain? Well, it starts executing at every Ethereum node if found
    valid. While this transaction is undergoing execution, Ethereum is designed to
    keep tabs on the “substate” to track the flow of execution. This is because, if
    a transaction does not complete due to “running out of gas,” then the entire execution
    so far has to be reverted. Also, information collected during the execution is
    required immediately after the transaction completion. So, the substate contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Self-destruct set: a set of accounts (if any) that will be discarded after
    the transaction completion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log series: archived and indexable “checkpoints” of the EVM’s code execution
    to track the contract calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refund balance: It is the amount to be refunded to the sender account post
    transaction execution. Storage in Ethereum is quite expensive, so there is an
    SSTORE instruction in Ethereum that is used as a refund counter. The refund counter
    starts at zero (no refund state) and gets incremented every time the transaction
    or contract deletes something from the storage. Please note that this refund amount
    is different and in addition to the unused gas that gets refunded to the sender.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the earlier versions of Ethereum, whether a transaction or contract executes
    successfully or fails in between, the entire gas used to get consumed. This was
    not always making sense. If an execution stopped due to some authorization/permission
    issue or any other issue, the execution would stop and the remaining gas would
    still be consumed. The last Byzantium update introduced the “revert” code like
    an exception handling. In case a contract has to stop, “revert” could be used
    to revert state changes, return a reason for failure, and credit the remaining
    gas back to the sender. Post successful execution of the transactions or contracts,
    a state transition happens that we will dive deeper into in the followiung section.Just
    the way we looked at blockchaininfo to see a live Bitcoin transaction, if you
    take a look at [https://etherscan.io](https://etherscan.io/) for Ethereum you
    will find the following information:![A440588_1_En_4_Figa_HTML.jpg](Images/A440588_1_En_4_Figa_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum State Transaction Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we learned about Ethereum transactions and messages.
    We are now aware that a state transition happens whenever a transaction is through—successfully.
    So, the state transition function in Ethereum is:APPLY(S,Tx) -> S''    \\where
    S is old state and S'' is the new stateTake a look at Figure [4-8](#Fig8).![A440588_1_En_4_Fig8_HTML.jpg](Images/A440588_1_En_4_Fig8_HTML.jpg)Figure
    4-8Ethereum state transition functionSo, the state transition function when Tx
    is applied to state S to result in changed state S’ can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the transaction to see if it is well formed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has the right number of values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature is valid.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The nonce matches the nonce in the sender’s account.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of preceding points is not valid, return an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calculate the fee and settle the accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the transaction fee as gasLimit * gasPrice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the sending address from the signature.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtract the fee from the sender’s account balance and increment the sender’s
    nonce.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is not enough balance to spend, return an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initialize GAS = gasLimit, and take off a certain quantity of gas per byte to
    pay for the bytes as a transaction fee.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the transaction value (could be anything of value) from the sender’s
    account to the receiving account. Note here that the transaction could be for
    anything of some intrinsic value such as land, vehicle, ERC20 tokens, etc., but
    the gas Price has to be in Ether so that the miners would accept the transaction.
    If the receiving account does not yet exist, create it.If the receiving account
    is a contract and not an EOA, then run the contract’s code either to completion
    or until the execution runs out of gas. Note here that the contract code gets
    executed on every node’s EVM as part of the block validation process so that the
    block, hence the contract’s output post execution, becomes a part of the main
    blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value transfer failed because the sender did not have enough money, or
    the code execution ran out of gas, revert all state changes (thanks to MPT implementation)
    except the payment of the fees, and add the fees to the miner’s account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, refund the fees for all remaining gas back to the sender, and send
    the fees paid already for gas consumed to the miner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas and Transaction Cost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transactions on Ethereum run on “gas,” the fundamental unit of computation
    in Ethereum. Every transaction, whether to an EOA or to a contract, must have
    the gasLimit and gasPrice to compute the fee. This fee is paid to the miners to
    compensate them for their resource contributions and work they perform. Obviously,
    miners have the choice of including the transaction and collecting the fee, similar
    to that of Bitcoin.Usually, a computational step costs just one gas, but some
    of the compute- or storage-intensive operations cost more. For every byte of transaction
    data, around five gas is required. Take a look at these sample examples: adding
    two numbers (with EVM opcode ADD) requires approximately three gas; multiplying
    two numbers (with EVM opcode MUL) requires approximately five gas; calculating
    a hash (SHA3) requires around 30 gas (compute-intensive, you see). Storage cost
    is also computed in similar fashion, but quite expensive for good reasons. As
    per the design, a transaction can include an unlimited amount of data. It costs
    68 gas per byte of nonzero transaction data. To store a 256-bit word in a “Contract,”
    approximately 20,000 gas is required. You could find more opcodes and their corresponding
    prices in the Ethereum yellow paper. The cost then would be to just multiply the
    gas required with the gasPrice. Unlike Bitcoin, Ethereum cost computation is more
    complex. It takes into account the costs of bandwidth, storage, and computation.
    Having such a fee computation mechanism prevents the Ethereum network from an
    attacker who might just want to inject an infinite loop for computation (leading
    to denial-of-service attacks) or consume more and more space by storing meaningless
    data.The total Ether a transaction would cost actually depends on the amount of
    gas consumed by the transaction, multiplied by the price of one unit of gas specified
    in the transaction by the transaction initiator. Miners on the other hand have
    a strategy for calculating the gas Price to charge, which should be the least
    amount the sender of a transaction must specify so that the transaction does not
    get rejected by the miner. So, how do you calculate the total cost of a transaction?
    Not the approximate one, but the actual cost? The total “Ether” cost of a transaction
    is based on two factors: gasUsed and gasPrice. Total cost = gasUsed * gasPrice.
    The gasUsed component is the total gas consumed while excuting the EVM opcodes
    for the instructions, and gasPrice is the one specified by the user.If the total
    amount of gas used by the computational steps (including the transaction, the
    message, and any submessages that may be triggered) is less than or equal to the
    gasLimit, then the transaction is processed by the miner. However, if the total
    gas exceeds the gasLimit, then all changes are reverted (though it is a valid
    transaction), except that the fee can still be collected by the miner. So, what
    happens to the excess gas? All the unused gas after transaction execution is reimbursed
    to the sender as Ether. Senders do not need to worry about overspending, as they
    are only charged for the gas consumed. This definitely means that it is important
    as well as safe to send transactions with a gas limit well above the estimates.
    It is also recommended not to pay very high gas Price and use the average gas
    price from [https://ethgasstation.info/](https://ethgasstation.info/) .Let us
    go through each and every step when a transaction is made in an Ethereun network
    to build a concrete understanding of the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Every transaction must define a “gasLimit” that it is willing to spend (gasLimit
    is also termed “startGas”), and the fee that it is willing to pay per unit of
    gas (gasPrice). At the start of execution, Ether worth of gasLimit * gasPrice
    is removed from the transaction sender’s account. Remember that this is not really
    the total cost of a transaction (should be a bit more than that in an ideal case).
    Only after the transaction, its actual cost is concluded (gasUsed * gasPrice)
    that’s adjusted from this (gasLimit * gasPrice), which was initially deducted
    from sender’s account and the balance amount is credited back to the sender. In
    the beginning of a transaction itself, the amount (gasLimit * gasPrice) is deducted
    because there could be a possibility that the sender could go bankrupt while the
    transaction they initiated is midway through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All operations during transaction execution, including database reads and writes,
    messages, and every computational step taken by the E VM such as addition, subtraction,
    hash, etc. consume a certain quantity of gas that is predefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal transaction is one that executes successfully without exceeding the
    gasLimit specified. For such transactions, there should be some gas remaining,
    say, “gas_rem”. After a successful transaction execution, the transaction sender
    receives a refund of “gas_rem * gasPrice” and the miner of the block receives
    a reward of “(gasLimit - gas_rem) * gasPrice”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a transaction runs out of gas before successful completion, then all executions
    revert, but the transaction is nevertheless valid. In such situations, the only
    outcome of the transaction is that the entire amount “gasLimit * gasPrice” is
    allocated to the miner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of Contract Accounts, when a contract sends a message to the other
    contract for subexecution, it also has the option to set a gasLimit. This option
    is specifically intended for the subexecution arising out of that message, because
    there is a possibility that the called contract has an infinite loop. If the subexecution
    runs out of gas, then the subexecution is reverted, which protects against such
    infinite loops or deliberate attempts of DoS attacks. The gas is consumed anyway
    and allocated to the miner. Also note that when a message is triggered by a contract,
    only the instructions cost gas, but data in a message do not cost any gas. This
    is because the data from the parent contract need not be copied again, and could
    be just referrenced through a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first Ethereum release (Frontier) had a default gas Price of 0.05e12 WEI
    (i.e., smallest denomination of Ether). In the second Ethereum release (Homestead),
    default gas Price was reduced to 0.02e12 WEI. You must be wondering why gas and
    Ether are decoupled from each other and not a single unit of measurement, which
    would have made it much simpler. Well, it is deliberately designed this way because
    units of gas align well with computation units having a natural cost (e.g., cost
    per computation), while the price of Ether generally fluctuates as a result of
    market forces.We already know that every Ethereum node participating in the network
    runs the EVM as part of the block verification protocol. This means that all the
    nodes execute the same set of transactions and contracts (redundantly parallel,
    but essential for consensus). While this redundency naturally makes it expensive,
    there is an incentive not to use the blockchain for computation that can be done
    offchain (Game Theory!).Typically, 21,000 gas is charged for any transaction as
    a "base fee" to cover the cost of an elliptic curve operation to compute the sender
    address from the signature, and also for the disk space of storing the transaction.
    There are ways to estimate gas requirements for transactions and contracts. Example:
    “estimateGas” is a Web3 function to estimate gas requirement for a given function.
    Also, to estimate the total cost, gas price oracle is a helper function in “geth”
    client and “web3.eth.getGasPrice” is a Web3 native function to find an approximate
    gas Price. Following is an example code that can be used in “Truffle”:var MyContract
    = artifacts.require("./MyTest.sol");// getGasPrice returns the gas price in WeiMyContract.web3.eth.getGasPrice(function(error,
    result){    var gasPrice = Number(result);    console.log("Current gasPrice is
    " + gasPrice + " wei");    // Get the Contract instance    MyContract.deployed().then(function(instance)
    {        // Retrieve gas estimation for the function giveAwayDividend()        return
    instance.giveAwayDividend.estimateGas(1);    }).then(function(result) {        var
    gas = Number(result);        console.log("Total gas estimation = " + gas + " units");        console.log("Total
    Transaction Cost estimation in Wei = " + (gas * gasPrice) + " wei");        console.log("Total
    Transaction Cost estimation in Ether = " + MyContract.web3.fromWei((gas * gasPrice),
    ''ether'') + " Ether");    });});Example code for transaction cost estimationWhile
    writing smart contracts in Solidity, many prefer to use “constant” functions to
    compute certain things offchain or just make an RPC query to your local blockchain.
    Since such constant functions do not change the blockchain state, they are in
    a way free of cost as they do not consume gas. If the constant functions are used
    inside of any transaction, then it is highly likely that gas expense would be
    required.Let us now learn about the block’s gas limit. Recollect that Bitcoin
    had a predefined limit of 1MB block size and Bitcoin cash had a 2MB block size.
    Miners would accumulate as many transactions as could fit in those blocks. Ethereum,
    however, has a very different way of limiting the block size. In Ethereum, the
    block size is controlled by the block gas limit. Different transactions have different
    gas limits; so, depending on the block gas limit, a certain number of transactions
    are clubbed together so that total transactions gas limit is less than the block
    gas limit. Different miners can have different sets of transactions that they
    are willing to put in a block. The block gas limit is dynamically calculated.
    The Ethereum protocol allows the miner of a block to adjust the block gas limit
    by a factor of 1/1024 (0.0976%) in either direction. Miners on the Ethereum network
    use a mining program, such as “ethminer.” The ethminer  is an Ethereum GPU mining
    worker, which connects to either geth or Parity Ethereum client node. Both geth
    and Parity have options that miners can change.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike Bitcoin, which is just a cryptocurrency, Ethereum is so much more–thanks
    to the smart contracts. We got a glimpse of what a smart contract might be in
    the previous sections while learning about Contract Accounts. While we will get
    into the development aspects of smart contracts in the following chapters, we
    will have a detailed exploration of what they really are in this section.Let us
    start with why it is named so? Please be aware that there is nothing “smart” in
    a smart contract that is out-of-the-box. It is smart when you code smart logic
    into it, and it is the beauty of Ethereum that enables you to do so. Let us just
    summarize our learning so far on the Ethereum smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts reside inside the Ethereum blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have their own account, hence address and balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are capable of sending messages and receiving transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They get activated when they receive a transaction, and can be deactivated as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like other transactions, an execution fee and storage fee are applicable for
    them as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code in Ethereum, including the smart contracts, is compiled to a low
    level, stack-based bytecode language, referred to as EVM code, that runs on EVM.
    The popular high-level languages used to write smart contracts are Solidity, Serpent,
    and LLL, where their respective compilers convert the high-level code into the
    EVM byte code. We looked at how contracts could be added into the blockchain by
    any external agent such as EOA. Since computation and storage in Ethereum are
    very expensive, it is advisible that the logic should be written in as simple
    and optimized fashion as possible. When a smart contract is deployed to the Ethereum
    blockchain network, it is possible for anyone to call the functions of the smart
    contract. The functions usually have security features coded up that prevent unauthorized
    access; nevertheless, attempts can be made though they won’t succeed.If you try
    to imagine a smart contract inside of a block in an Ethereum blockchain, it might
    appear as in Figure [4-9](#Fig9).![A440588_1_En_4_Fig9_HTML.jpg](Images/A440588_1_En_4_Fig9_HTML.jpg)Figure
    4-9Ethereum smart contract with respect to blocksLet us now take an example of
    a voting application. A smart contract is written that has an address (Contract
    Account address) and is a part of some block in the blockchain, depending on when
    it was created. The voters can make transactions to that address (votes). The
    contract code is written such that it will increment the vote count with every
    transaction received and terminates itself after some time, publishing the voting
    result (Ethereum state change). Take a look at Figure [4-10](#Fig10) to have a
    diagramatic representation for a high-level understanding.![A440588_1_En_4_Fig10_HTML.jpg](Images/A440588_1_En_4_Fig10_HTML.jpg)Figure
    4-10An application with smart contract logic
  prefs: []
  type: TYPE_NORMAL
- en: Contract Creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recollect that we learned about the contract creation transaction, whose only
    purpose is to create a contract. It is a bit different kind of transaction compared
    with the other types. So, before the contract creation transaction is fired up
    to create a Contract Account, it must first initialize the four properties that
    all types of accounts have:'
  prefs: []
  type: TYPE_NORMAL
- en: The “nonce” should be set to zero initially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “Account Balance” should be set with the value (amount of Ether) transferred
    by the sender, and the same amount must be deducted from the sender’s account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “StorageRoot” should be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contract’s “codeHash” should be set with the Keccak 256-bit hash of an empty
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After initializing the account, the account can be created using the init code
    sent with the transaction that does the real work. There could be a whole bunch
    of actions defined in init code, and it’s execution can effect several events
    that are not internal to the execution state, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The account’s ‘storage’ can be altered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further accounts can be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further message calls can be triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum Virtual Machine and Code Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ethereum is a programmable blockchain that allows users to create their own
    operations of any arbitrary complexity through Turing-complete languages. The
    EVM is the execution engine of Ethereum that serves as the runtime environment
    for smart contracts. It is the primary innovation of Ethereum that makes it unique
    compared with other blockchain systems. It is the EVM on the basis of which the
    smart contract technology is supposed to get to the next level of innovation,
    and the game is on. EVM also plays a critical role in transaction execution, changing
    the state of Ethereum, and achieving consensus. The design goals of EVM are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplicity: The idea was to make EVM as simple as possible with the low-level
    constructs. This is why the number of low-level opcodes is kept to a minimum,
    and so are the data types to the extent that complex logics could still be written
    conveniently using these constructs. Total 160 instructions, out of which 65 are
    logically distinct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Absolute determinism: Ensuring that the execution of instructions with the
    same set of inputs should produce the same set of outputs (deterministic!) helps
    maintain the integrity of the EVM without any ambiguity. Determinism along with
    the concept of “computational step” helps estimate gas expense with close approximation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Space optimization: In decentralized systems, space saving is a biggest concern.
    This is why the EVM assembly is kept as compact as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuned for native operations: EVM is tuned for some native operations such as
    the specific types of arithmatic operations used for cryptography (modular arithmatic),
    reading blocks or transaction data, interacting with “states,” etc. Another such
    example is: 256-bit (32 bytes) word length to store cryptographic hashes, where
    EVM operates on the same 256-bits integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easy security: In a way, gas Price helps ensure that the EVM is nonexploitable.
    If there was no cost, attackers could just keep attacking the system in every
    possible way. While almost every operation on EVM requires some gas cost, it should
    be easy to come up with good gas cost model on EVM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We learned that every participating node in the Ethereum network runs EVM locally,
    executes all transactions and smart contracts, and saves the final state locally.
    It is the EVM that writes code (smart contracts) and data to blockchain and executes
    instructions (opcodes) of transaction code and smart contract code written in
    a Turing-complete language. That is to say, EVM serves as a runtime environment
    (RTE) for Ethereum smart contracts and ensures secured execution of the code.
    Obviously, when the code or transactions are validated through their respective
    digital signatures, they are executed on EVM. So, only after successful execution
    of instructions through EVM, the Ethereum state can change.Unless one connects
    the EVM with the rest of the network to participate in the P2P network, it can
    be isolated from the main network. In an isolated and sandboxed environment, EVM
    could be used to test smart contracts. It facilitates in building better, robust,
    and production ready-smart contracts.To build a better understanding of how smart
    contracts work leveraging the EVM, we should understand how data is organized,
    stored, and manipulated in any EVM language such as Solidity, Serpent, and ones
    that might come in future. You might want to consider EVM more like a database
    engine. Though we will not get deeper into the Solidity programming fundamentals,
    we will see how it interacts with the EVM in this section. Take a look at Figure
    [4-11](#Fig11).![A440588_1_En_4_Fig11_HTML.jpg](Images/A440588_1_En_4_Fig11_HTML.jpg)Figure
    4-11Smart contract deployment and usageLet us now understand memory management
    with EVM. Take a look at the following three strategies that the EVM follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage (persistent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value storage mapping (i.e., 256- bit to 256-bit word mapping). This means
    both keys and values are 256 bits (i.e., 32 bytes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From within a contract, it is not possible to enumarate storage.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At any given point in time, the state of the contract can be determined by the
    contract level variables called “state variables” that are always in “storage,”
    and it cannot be updated at runtime. This means that the structure of the storage
    is set only once during the contract creation and cannot be altered. However,
    their content can be changed with “sendTransaction” calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read/update of storage is an expensive affair.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Contracts cannot read, write, or update to any other storage that is not owned
    by them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSTORE/SLOAD are the frequently used instructions. Example: SSTORE instruction
    pops the top two items off the stack, considers the first item as the index, and
    inserts the second item into the contract’s storage at that index location.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory (volatile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is similar to RAM requirement in a general computer system for any code or
    application execution and used to store temporary values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract can use any amount of memory during execution by paying for it, and
    that memory space is cleaned up after execution completes. The outputs during
    execution could be pushed to the persistent storage that can be reused in future
    executions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory is actually a byte-array that is contiguous, unlike storage. It is allocated
    in 256-bit (32 bytes) chunks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts with no space and takes on space in the units of 32-byte chunks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Without the “memory” keyword, smart contract languages such as Solidity are
    expected to declare variables in storage for persistence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory cannot be used at the smart contract level; it can only be used in methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments are almost always in memory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MSTORE/MLOAD are the frequently used instructions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EVM is stack based, hence follows LIFO (Last-in, First-Out), where stack is
    used to perform computations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack entries are also 256-bit words used to mimic 256-bit pseudo registers.
    They are used to hold local variables of “value” type and to pass parameters to
    instructions or functions, memory operations, and other algorithmic operations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows a maximum of 1024 element and is almost free to use.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the stack operations are limited to top of the stacks. The execution
    is pretty similar to the way Bitcoin script was executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When EVM is running and the byte code is injected with a transaction for execution,
    its full computational state can be defined by the following tuple: [block_state,
    transaction, message, code, memory, stack, pc, gas].You must be able to make out
    all these fields now. They have the three kinds of memory we discussed (the block_state
    field represents the global state and is for storage). The PC field is like a
    pointer for an instruction in the stack to be executed.In Ethereum, an Application
    Binary Interface (ABI) is an abstraction that is not part of the [core Ethereum
    protocol](https://github.com/ethereum/yellowpaper), but is used to access the
    byte code in a smart contract as standard practice. Though it is possible for
    anyone to define their own ABI for their contracts and comply with it to get the
    desired output, it is easier to use Solidity. The purpose of ABI is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How and what functions inside smart contracts should be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Binary format in which information should be passed to smart contract functions
    as inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Binary format in which you expect the output of function execution after
    calling that function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ABI specifications, it is easy (though may not be necessary) for two programs
    written in two different languages to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned the core components to understand how Ethereum really works. There
    are some inherent limitations to Ethereum such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The EVM is slow; it is not advisible to be used for large computations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation and storage on the blockchain is expensive; it is advisible to use
    offchain computations and use IPFS/Swarm for storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability is an issue; there are different techniques to address it, but they
    are subjective to the business case you are dealing with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private blockchains are more likely to flourish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us take a look at the Ethereum tech stack to understand at a high-level
    the Ethereum ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not only a distributed storage platform of static files in a P2P fashion,
    but also a distribution service. Swarm ensures adequate decentralization and redundant
    storage of Ethereum’s blockchain data, DApp code, etc. Unlike WWW, the uploads
    to Swarm are not centralized to one web server. It is designed to have zero downtime
    and is DDOS resistant and fault tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: Whisper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a communications protocol that allows DApps to communicate with each other.
    It provides a distributed yet private messaging functionality. It supports singlecast,
    multicast, and broadcast of messages.
  prefs: []
  type: TYPE_NORMAL
- en: DApp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DApp usually has two components, a front-end and a back-end component. The
    back-end code runs on the actual blockchain coded up in smart contracts. The front-end
    code and user interfaces could be written in any language such as HTML, CSS, and
    JavaScript, as long as it can make calls to its back end. Also, the front end
    can be hosted in a decentralized storage like SWARM or IPFS instead of a centralized
    web server.User interface components will be cached on some kind of decentralized
    BitTorrent-like cloud and pulled in by the ÐApp Browser as needed. Like any App
    store, it is possible to browse the distributed DApps catalog in the browser.
    The end user can install any DApp of interest in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: Development Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are so many development components used to develop decentralized applications
    on Ethereum and interact with them. Following are a few popular ones, but there
    are many more such for you to explore. We will just take a look at what they are
    and dive deeper into these topics in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Web3.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a very important element in developing DApps.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Truffle provides the building blocks to create, compile, deploy, and test blockchain
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Mist Wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We learned in the previous chapters that a wallet is required to interact with
    blockchain applications and the same applies to Ethereum as well. To store, accept,
    and send Ether, the users need a wallet. Mist Wallet is a UI-based solution that
    can be used to connect to the Ethereum blockchain. Using Mist wallet, one can
    create accounts, design and deploy contracts, transfer Ether across accounts,
    and view transaction details.Internally, Mist is dependent on the “geth” client
    (i.e., GoEthereum Client) to perform all the operations seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we covered the core components of Ethereum blockchain and understood
    the design considerations. We were able to differentiate Ethereum design with
    that of the Bitcoin blockchain and understood how Ethereum blockchain facilitates
    development of different use cases on a single platform. We took a deep dive into
    the smart contracts and how the Ethereum Virtual Machine (EVM) executes it in
    a decentralized fashion.We will explore more into the development aspect of blockchain
    in general in Chapter [5](A440588_1_En_5_Chapter.xhtml) and then build a solid
    understanding of Ethereum development in Chapter [6](A440588_1_En_6_Chapter.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ethereum White Paper[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)
    .Ethereum Yellow Paper[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)
    .How Ethereum Works[https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369](https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369)
    .Patricia Tree[https://dl.acm.org/citation.cfm?id=321481](https://dl.acm.org/citation.cfm?id=321481)
    .Merkling in Ethereum[https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/).Gas
    and Transactions in Ethereum[http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html](http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html)
    .Technical Introduction to Events and Logs in Ethereum[https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)
    .Ethereum Internals[https://github.com/comaeio/porosity/wiki/Ethereum-Internals](https://github.com/comaeio/porosity/wiki/Ethereum-Internals)
    .
  prefs: []
  type: TYPE_NORMAL
