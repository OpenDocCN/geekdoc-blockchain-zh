- en: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal,
    Gautam Dhameja and Priyansu Sekhar PandaBeginning Blockchain[https://doi.org/10.1007/978-1-4842-3444-0_4](A440588_1_En_4_Chapter.xhtml)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018 Bikramaditya
    Singhal, Gautam Dhameja and Priyansu Sekhar Panda 入门区块链[https://doi.org/10.1007/978-1-4842-3444-0_4](A440588_1_En_4_Chapter.xhtml)
- en: 4. How Ethereum Works
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 以太坊是如何工作的
- en: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1)Bangalore,
    Karnataka, India(2)Berlin, Berlin, GermanyThe era of blockchain applications has
    just begun. Ethereum is here to be the defacto blockchain platform for building
    decentralized applications. We already learned in the previous chapters that public
    blockchain use cases are not just limited to cryptocurrencies, and the possibilities
    are only limited by your imagination! Ethereum has already made inroads in many
    business sectors and works best not only for public blockchain use cases, but
    also for the private ones. Ethereum has already set a benchmark for blockchain
    platforms and must be studied well to be able to envision how usable decentralized
    applications can be built with or without using Ethereum. Today, it is possible
    to build blockchain applications with minimal knowledge of cryptography, game
    theory, mathematics or complex coding, and computer science fundamentals, thanks
    to Ethereum.In Chapter [3](A440588_1_En_3_Chapter.xhtml), we learned how Bitcoin
    works by taking a deep dive into the protocol as well as the Bitcoin application.
    We witnessed how the cryptocurrency aspect is so much interwoven into the Bitcoin
    protocol. We learned that Bitcoin is not Bitcoin on blockchain, rather a Bitcoin
    blockchain. In this chapter, we will learn how Ethereum has successfully built
    an abstract foundation layer that is capable of empowering various different blockchain
    use cases on the same blockchain platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1) 班加罗尔，卡纳塔克邦，印度(2)
    柏林，柏林，德国区块链应用的时代才刚刚开始。以太坊旨在成为构建去中心化应用程序的事实上的区块链平台。我们在前面的章节中已经了解到，公共区块链用例不仅限于加密货币，而且可能性只受限于你的想象力！以太坊已经在许多商业领域取得了突破，并且不仅适用于公共区块链用例，也适用于私有用例。以太坊已经为区块链平台设定了基准，必须好好研究才能想象出如何使用或不使用以太坊构建可用的去中心化应用程序。如今，感谢以太坊，即使对密码学、博弈论、数学或复杂编码、计算机科学基础了解甚少，也完全可以构建区块链应用程序。在第[3](A440588_1_En_3_Chapter.xhtml)章中，我们通过深入研究协议以及比特币应用程序来了解比特币是如何工作的。我们见证了加密货币方面是如何与比特币协议紧密交织在一起的。我们了解到比特币不是在区块链上的比特币，而是一个比特币区块链。在本章中，我们将学习以太坊如何在同一区块链平台上成功构建一个能够赋能各种不同区块链用例的抽象基础层。
- en: From Bitcoin to Ethereum
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从比特币到以太坊
- en: Obviously, blockchain technology  came along with Bitcoin back in 2009\. After
    Bitcoin stood the test of time, people believed in the potential of blockchain.
    The use cases now have gone beyond banking and finance sectors and have enveloped
    other industries such as supply chain, retail, e-commerce, healthcare, energy,
    and government sectors as well. This is because different flavors of blockchain
    have come up and address specific business problems. Nonetheless, there are public
    blockchain platforms such as Ethereum that allow different decentralized use cases
    to be built on the same public Ethereum platform.With Bitcoins, decentralized
    peer-to-peer transaction of cryptocurrency was possible. People realized that
    blockchain could be used to transact and keep track of anything of value, not
    just cryptocurrency. People started exploring if the same Bitcoin network could
    be used for any other use case. To give you an example, “proof of existence” is
    one such use case where the hash of a document was injected in the Bitcoin blockchain
    network so that anyone could later verify that such a ducument was existant in
    so and so point in time. Vitalik Buterin introduced the Ethereum blockchain platform
    that could facilitate transactions of not just money, but also shares, lands,
    digital content, vehicles, and many others that have some intrinsic value. Take
    a look at Figure [4-1](#Fig1).![A440588_1_En_4_Fig1_HTML.jpg](Images/A440588_1_En_4_Fig1_HTML.jpg)Figure
    4-1Multiple decentralized applications on one Ethereum platformLike Bitcoin, Ethereum  is
    a public blockchain platform with a different design philosophy. The most innovative
    approach was to build an abstraction layer so that transactions from different
    applications are generalized to the program code that can run on all the Ethereum
    nodes. Even in Ethereum, the miners generate Ether, a tradeable cryptocurrency
    because of which the public blockchain network is self-sustainable. Any application
    that is running on Ethereum has to pay transaction fees that eventually the miners
    get for running the nodes and sustaining the whole network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，区块链技术是随着比特币在2009年一同出现的。在比特币经过了时间的考验之后，人们开始相信区块链的潜力。现在的应用案例已经超越了银行和金融领域，并涵盖了供应链、零售、电子商务、医疗、能源和政府等其他行业。这是因为不同的区块链解决方案已经被提出，并且解决了具体的商业问题。尽管如此，像以太坊这样的公共区块链平台允许在同一个公共以太坊平台上构建不同的去中心化用例。通过比特币，实现了加密货币的去中心化点对点交易。人们意识到区块链可以用来交易和跟踪任何有价值的东西，不仅仅是加密货币。人们开始探索是否可以使用同样的比特币网络来处理其他用例。举个例子，“存在证明”就是这样一个用例，在该用例中，文档的散列值被注入到比特币区块链网络中，这样任何人都可以后来验证该文档在某个时间点是存在的。Vitalik
    Buterin引入了以太坊区块链平台，该平台可以促进不仅仅是货币的交易，还有股票、土地、数字内容、车辆等许多具有内在价值的其他东西。请参阅图[4-1](#Fig1)
    ![A440588_1_En_4_Fig1_HTML.jpg](Images/A440588_1_En_4_Fig1_HTML.jpg)图4-1一个以太坊平台上的多个去中心化应用与比特币一样，以太坊也是一个具有不同设计哲学的公共区块链平台。最创新的方法是建立一个抽象层，以便来自不同应用程序的交易可以泛化为可以在所有以太坊节点上运行的程序代码。即使在以太坊中，矿工也会生成一种可交易的加密货币以太币，正是因为这种加密货币，公共区块链网络才能自给自足。在以太坊上运行的任何应用程序都必须支付交易费用，最终这些费用会分给运行节点并维持整个网络的矿工。
- en: Ethereum as a Next-Gen Blockchain
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊作为新一代区块链
- en: With the Bitcoin blockchain, the developer community tried building different
    decentralized applications with a completely new blockchain, or were trying to
    modify Bitcoin Core to increase the set of functionalities. Either way, it was
    complicated as well as time consuming. A different design with an alternative
    protocol was probably the need of the hour then, which is why the Ethereum blockchain
    platform! The purpose was to facilitate development of many blockchain applications
    on one Ethereum platform rather than building dedicated blockchains for each application
    separately. Ethereum enabled rapid development of decentralized applications that
    could interact among themselves, ensuring adequate security. As mentioned in the
    previous section, Ethereum does this by building an abstract foundation layer.
    Unlike Bitcoin, Ethereum supported Turing-complete language so anyone could write
    smart contracts that could virtually do anything and everything on a programming
    perspective. Also, Ethereum is stateful by design and keeps track of the acount
    states, which is very different from Bitcoin where everything remains as a transaction
    and there is no internal persistent memory for scripts. With the help of an abstract
    foundation layer, the underlying complexities are hidden from the developers and
    not just that; the developers get the flexibility of designing their own state
    transition functions for direct transfer of value and information, and transaction
    formats.In an effort to meet the objective, the core innovation of Ethereum was
    the Ethereum Virtual Machine (EVM). The support for Turing-complete languages
    through the EVM makes it easy for the developers to create blockchain applications.
    Just the way a Java Virtual Machine (JVM) is required to run Java code, EVM is
    required to run the smart contracts. For now, just keep in mind that smart contracts
    are the Ethereum scripts written in a Turing-complete language that automatically
    gets executed in case a predefined event occurs. The “ScriptSig” and “ScriptPubKey”
    in Bitcoins are the basic versions of smart contracts so to speak. We learned
    in the previous chapter that in Bitcoins, the instruction set was very limited.
    In Ethereum, however, one could code almost any program that would run on the
    EVM on each and every node in the Ethereum blockchain network. The decentralized
    applications in Ethereum are called DApps. Ethereum being a global decentralized
    computer system with no centralized server, DApps are the applications that run
    without downtime, fraud, or any sort of regulations. A peer-to-peer electronic
    cash system such as Bitcoin is very easy to build on Ethereum as a DApp. Similarly,
    any other asset with some intrinsic value, such as land, cars, houses, votes,
    etc., could easily be transacted through their respective DAaps on Ethereum in
    the form of tokens.Unlike traditional software development and deployment, DApps
    do not need to be hosted on a back-end server. The “code” is embedded as payload
    in transactions, so to speak, that are then sent to the mining nodes in the Ethereum
    network. Such transactions would be considered by the mining ecosystem because
    of the ETH (Ether) paid as “gas Price.” Like in Bitcoin, these transactions get
    broadcast to other miners in the network that they are accessible to. The transaction
    then eventually gets into a block and becomes an eternal part of the blockchain
    when consensus is reached. Developers have the liberty to code up any solution
    and deploy that in the Ethereum network. The network executes that, all by itself,
    and validates and produces the outputs as well. Well, had it been without any
    cost, the network wouldn’t have been sustainable. There is a gas Price associated
    with each blockchain transaction, and writing some garbage code and deploying
    that into the Ethereum network could be an expensive affair!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着比特币区块链的发展，开发者社区尝试用全新的区块链构建不同的去中心化应用，或者试图修改比特币核心以增加功能集合。不管怎样，这既复杂又耗时。当时可能急需一种不同的设计以及替代协议，这也是以太坊区块链平台出现的原因！目的是在一个以太坊平台上开发许多区块链应用，而不是为每个应用单独建立一个专用区块链。以太坊能够迅速开发出可以相互作用的去中心化应用，确保了足够的安全性。正如前一部分提到的，以太坊通过构建一个抽象的基础层来实现这一点。与比特币不同，以太坊支持图灵完备语言，因此任何人都可以编写智能合约，从编程角度看，它们几乎可以做到任何事情。此外，以太坊的设计是有状态的，并跟踪账户状态，这与比特币的做法大相径庭，在比特币中，所有事物都保留为交易，脚本没有内部持久化内存。借助抽象的基础层，底层复杂性被隐藏在开发者面前，不仅如此，开发者还获得了设计自己的状态转换函数的自由，以便直接传输价值和信息以及交易格式。为了实现这一目标，以太坊的核心创新就是以太坊虚拟机（EVM）。通过EVM支持图灵完备语言，使开发者轻松创建区块链应用。就像运行Java代码需要Java虚拟机（JVM）一样，运行智能合约需要EVM。现在，只需记住，智能合约是在图灵完备语言中编写的以太坊脚本，在预定义事件发生时自动执行。比特币中的“ScriptSig”和“ScriptPubKey”可以说是智能合约的基本版本。我们在前一章了解到，比特币的指令集非常有限。然而，在以太坊中，几乎可以编写在任何节点上运行的EVM上的任何程序。以太坊中的去中心化应用被称为DApps。作为一个没有中心服务器的全球去中心化计算机系统，DApps是在没有停机、欺诈或任何形式的监管的情况下运行的应用程序。像比特币这样的点对点电子现金系统很容易在以太坊上作为DAApp构建。同样，具有某些内在价值的任何其他资产，如土地、汽车、房屋、选票等，都可以通过各自的DAapps以代币形式轻松地在以太坊上交易。与传统的软件开发和部署不同，DApps不需要托管在后台服务器上。"代码"作为交易的有效负载嵌入其中，然后发送到以太坊网络中的挖矿节点。由于支付了"燃料价格"ETH（以太），这样的交易将被挖矿生态系统考虑。就像在比特币中一样，这些交易会被广播到网络中的其他矿工，使他们可以访问。当达成共识时，交易最终会被放入区块中，并成为区块链的一部分。开发者可以自由编写任何解决方案并在以太坊网络上部署。网络会自动执行那个解决方案，并验证和生成输出。嗯，如果没有成本，网络是不可持续的。每个区块链交易都有一个"燃料价格"，在以太坊网络上编写一些垃圾代码并部署可能会很昂贵！
- en: Design Philosophy of Ethereum
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊的设计哲学
- en: 'Ethereum borrows many concepts from Bitcoin Core as it stood the test of time,
    but is designed with a different philosophy. Ethereum development has been done
    following certain principles as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊从经过时间考验的比特币核心中借鉴了许多概念，但设计理念不同。以太坊的开发遵循以下原则：
- en: 'Simplistic design: The Ethereum blockchain is designed to be as simple as possible
    so that it is easy to understand and develop decentralized applications on. The
    complexities in the implementation are kept to a bare minimum at the consensus
    level and are managed at a level above it. As a result, high-level language compilation
    or serialization/deserialization of arguments, etc. are not a concern for the
    developers.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简约设计：以太坊区块链被设计得尽可能简单，以便于理解和开发去中心化应用。在共识层面的实现复杂性被降至最低，并在其上层进行管理。因此，开发人员无需担心高级语言编译或参数的序列化/反序列化等问题。
- en: 'Freedom of development: The Ethereum platform is designed to encourage any
    sort of decentralization on its blockchain platform and does not discremenate
    or favor any specific kinds of use cases. This freedom is given to an extent that
    a developer can code up an infinite loop in a smart contract and deploy it. Obviously,
    the loop will run as long as they are paying the transaction fee (gas Price),
    and the loop eventually terminates when it runs out of gas.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自由：以太坊平台旨在鼓励在其区块链平台上进行任何形式的去中心化，并不区分或偏爱任何特定的用例。这种自由度之大，以至于开发者可以在智能合约中编写一个无限循环并部署它。显然，只要他们支付交易费（gas价格），循环就会一直运行，当它耗尽gas时，循环最终会终止。
- en: 'No notion of features: In an effort to make the system more generalized, Ethereum
    does not have built-in features for the developers to use. Instead, Ethereum provides
    support for Turing-complete language and lets the users develop their own features
    the way they want to. Starting from basic features such as “locktime,” as in Bitcoin
    till full blown use cases, everything can be coded up in Ethereum.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有特性的概念：为了使系统更加通用，以太坊没有为开发者内置特性。相反，以太坊支持图灵完备语言，并让用户按照自己的意愿开发他们自己的特性。从比特币中的“locktime”等基本特性，到完整的用例，一切都可以在以太坊中编码。
- en: Enter the Ethereum Blockchain
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入以太坊区块链
- en: We learned about the objective behind Ethereum blockchain and its design philosophy.
    To be able to understand and appreciate this next-gen blockchain and build decentralized
    applications on it, we will learn about the core components of Ethereum in great
    detail in this section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了以太坊区块链背后的目标和其设计哲学。为了能够理解并欣赏这个下一代区块链，并在其上构建去中心化应用，我们将在本节中详细学习以太坊的核心组件。
- en: Ethereum Blockchain
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊区块链
- en: 'The Ethereum blockchain data structure is pretty similar to that of Bitcoin’s,
    except that there is a lot more information contained in the block header to make
    it more robust and help maintain the state properly. We will learn more about
    the Ethereum states in the following sections. Let us focus more on the blockchain
    data structure and the header in this section. In Bitcoins, there was only one
    Merkle root in the block header for all the transactions in a block. In Ethereum,
    there are two more Merkle roots, so there are three Merkle roots in total as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链数据结构与比特币的非常相似，不同之处在于区块头包含了更多信息，使其更加健壮，并能正确维护状态。我们将在后面的章节中了解更多关于以太坊状态的内容。在本节中，让我们更多地关注区块链数据结构和头部。在比特币中，区块头中只有一个Merkle根，用于一个区块中的所有交易。而在以太坊中，还有两个Merkle根，总共有三个Merkle根，如下所示：
- en: 'stateRoot: It helps maintain the global state.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'stateRoot: 它帮助维护全局状态。'
- en: 'transactionsRoot: It is to track and ensure integrity of all the transactions
    in a block, similar to Bitcoin’s Merkle root.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'transactionsRoot: 它是用来跟踪和确保一个区块中所有交易的完整性的，与比特币的Merkle根类似。'
- en: 'receiptsRoot: It is the root hash of the receipts trie corresponding to the
    transactions in a block'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'receiptsRoot: 它是与区块中的交易相对应的收据树的根哈希。'
- en: 'We will take a look at these Merkle roots in their respective sections of block
    header information. For better comprehension, take a look at Figure [4-2](#Fig2).![A440588_1_En_4_Fig2_HTML.jpg](Images/A440588_1_En_4_Fig2_HTML.jpg)Figure
    4-2The blockchain data structure of EthereumEvery block usually comprises block
    header, transactions list, uncles list, and optional extraData. Let us now take
    a look at the header fields to understand what they mean and their purpose for
    being in the header. While you do so, keep in mind that there could be slight
    variants of these names in different places, or the order in which they are presenbted
    could be different in different places. We suggest that you build a proper understanding
    of these fields so that any different terminology that you might come across won’t
    bother you much.Section-1: Block metadata'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看区块头信息中各个Merkle根的部分。为了更好的理解，请参考图[4-2](#Fig2)。![A440588_1_En_4_Fig2_HTML.jpg](Images/A440588_1_En_4_Fig2_HTML.jpg)图4-2以太坊的区块链数据结构每个区块通常包括区块头、交易列表、叔叔列表和可选的extraData。现在让我们看看这些头部字段，以了解它们的含义和为什么存在于头部。同时请注意，这些字段在不同地方可能会有轻微的变体，或者它们的呈现顺序可能会不同。我们建议你正确理解这些字段，这样当你遇到不同的术语时，就不会感到困扰。
- en: 'parentHash: Keccak 256-bit hash of the parent block’s header, like that of
    Bitcoin’s style'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'parentHash: 父区块头的Keccak 256位**哈希**，类似于比特币的风格。'
- en: 'timestamp: The Unix timestamp current block'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'timestamp: 当前区块的**Unix时间戳**。'
- en: 'number: Block number of the current block'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'number: 当前区块的**区块号**。'
- en: 'Beneficiary: The 160-bit address of “author” account responsible for creating
    the current block to which all the fees from successfully mining a block are collected'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Beneficiary: 负责创建当前区块的“author”账户的160位**地址**，所有成功挖出区块的手续费都会收集到这个账户。'
- en: 'Section-2: Data references'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'Section-2: 数据引用'
- en: 'transactionsRoot: The Keccak 256-bit root hash (Merkle root) of the transactions
    trie populated with all the transactions in this block'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'transactionsRoot: 本区块中所有交易组成的交易树（trie）的Keccak 256位**Merkle根哈希**。'
- en: 'ommersHash: It is otherwise known as “uncleHash.” It is the hash of the uncles
    segment of the block, i.e., Keccak 256-bit hash of the ommers list portion of
    this block (blocks that are known to have a parent equal to the present block’s
    parent’s parent).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ommersHash: 它也被称为“uncleHash”。这是区块的叔叔段（uncles segment）的哈希，即本区块（已知其父区块的父区块等于当前区块的父区块）的ommer列表部分的Keccak
    256位哈希。'
- en: 'extraData: Arbitrary byte array containing data relevant to this block. The
    size of this data is limited to 32 bytes (256-bits). As of this writing, there
    is a possibility that this field might become “extraDataHash”, which will point
    to the “extraData” contained inside the block. extraData could be raw data, charged
    at the same amount of gas as that of transaction data.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'extraData: 包含与本区块相关的任意字节数组数据。此数据的大小限制为32字节（256位）。截至当前撰写，此字段可能会变成“extraDataHash”，指向区块内的“extraData”。extraData可以是原始数据，费用与交易数据相同。'
- en: 'Section-3: Transaction execution information'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'Section-3: 交易执行信息'
- en: 'stateRoot: The Keccak 256-bit root hash (Merkle root) of the final state after
    validating and executing all transactions of this block'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'stateRoot: 验证并执行本区块的所有交易后的最终状态的Keccak 256位**Merkle根哈希**。'
- en: 'receiptsRoot: The Keccak 256-bit root hash (Merkle root) of the receipts trie
    populated with the recipients of each transaction in this block'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'receiptsRoot: 本区块中每笔交易的收据组成的收据树（trie）的Keccak 256位**Merkle根哈希**。'
- en: 'logBloom: The accumulated Bloom filter for each of the transactions’ receipts’
    Blooms, i.e., the “OR” of all of the Blooms for the transactions in the block'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'logBloom: 每个交易收据的Bloom过滤器的累积，即本区块中所有交易的收据Bloom的“OR”操作。'
- en: 'gasUsed: The total amount of gas used through each of the transactions in this
    block'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gasUsed: 本区块中每笔交易的**消耗的气体总量**。'
- en: 'gasLimit: The maximum amount of gas that this block may utilise (dynamic value
    depending on the activity in the network)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gasLimit: 本区块可能使用的**最大气体量**（取决于网络活动的动态值）。'
- en: 'Section-4: Consensus-subsystem information'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Section-4: 共识子系统信息'
- en: 'difficulty: The difficulty limit for this block calculated from the previous
    block’s difficulty and timestamp'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'difficulty: 根据前一个区块的难度和时间戳计算出的本区块的**难度限制**。'
- en: 'mixHash: The 256-bits mix hash combined with the ‘nonce’ for the PoW of this
    block'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'mixHash: 结合了本区块的PoW的“nonce”的256位**混合哈希**。'
- en: 'nonce: The nonce is a 64-bit hash that is combined with mixHash and can be
    used as a PoW verification.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nonce：nonce是一个64位的哈希值，与mixHash组合在一起，可以用作工作量证明（PoW）的验证。
- en: Ethereum Accounts
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊账户
- en: 'The Ethereum accounts, unlike Bitcoins, are not in the form of unspent transaction
    outputs (UTXOs). In the Bitcoin chapter, we learned that Bitcoins are actually
    present in the form of transactions that have an owner (owner’s public key, 20-byte
    address) and a value. The owner can spend the transaction if they have the valid
    private key for the transaction they are trying to spend. Bitcoin therefore is
    a state transition system where “state” refers to the collection of all UTXOs.
    Every time a block is mined, a state change happens because each block contains
    a bunch of transactions where each transaction cosumes UTXO(s) and produces UTXO(s).
    Note here that the state is not encoded inside the blocks. So, there is no notion
    of an account balance as such in Bitcoin’s design. Ethereum on the other hand
    is stateful, and its basic unit is the account. Each account has a state associated
    with it and also has a 20-byte (160 bits) address through which it gets identified
    and referenced. The purpose of blockchain in Ethereum is to keep track of the
    state changes. There are broadly two types of Ethereum accounts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊账户与比特币账户不同，不是以未花费交易输出（UTXO）的形式存在。在比特币章节中，我们了解到比特币实际上存在于具有所有者（所有者的公钥，20字节地址）和价值的形式的交易中。如果所有者拥有尝试花费的交易的有效私钥，则所有者可以花费交易。因此，比特币实际上是一个状态转换系统，其中“状态”指的是所有UTXO的集合。每次挖掘出一个区块时，都会发生状态改变，因为每个区块都包含一堆交易，每个交易都消耗和产生UTXO。注意，状态并不是编码在区块内部的。因此，在比特币的设计中，没有账户余额的概念。另一方面，以太坊是有状态的，其基本单位是账户。每个账户都与一个状态相关联，并且通过一个20字节的（160位）地址来识别和引用。以太坊区块链的目的是跟踪状态改变。以太坊账户大致可以分为两种类型：
- en: 'Externally Owned Accounts (EOAs) : These accounts are also known as “simple
    accounts” that are usually owned by users or devices who control these accounts
    using Private Keys. The EOAs can send transactions to other EOAs or Contract Accounts
    by signing with a private key. The transaction between two EOAs is usually to
    transfer any form of value. On the other hand, when an EOA makes a transaction
    to a Contract Account, the purpose is to activate the “code” inside the Contract
    Account.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部拥有账户（EOA）：这些账户也被称为“简单账户”，通常由使用私钥控制这些账户的用户或设备所拥有。EOA可以通过私钥签名向其他EOA或合约账户发送交易。两个EOA之间的交易通常是转移任何形式的价值。另一方面，当EOA向合约账户发送交易时，目的是激活合约账户内的“代码”。
- en: 'Contract Accounts: These are controlled only by the code contained in them.
    This code inside the Contract Accounts is referred to as “smart contracts  .”
    They are usually activated when a transaction is sent to the Contract Account
    by the EOAs or by other Contract Accounts. Even though the Contract Accounts are
    capable of executing complex business logics through the code they contain, they
    can’t initiate new transactions on their own and always depend on the EOAs. All
    they can do is respond to other transactions (obviously by making transactions)
    as per the logic coded in their “code.”'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约账户：这些账户只受其中所包含的代码控制。合约账户内的这种代码被称为“智能合约”。它们通常是在由外部拥有账户（EOA）或其他合约账户发送交易给合约账户时被激活的。尽管合约账户能够通过它们所包含的代码执行复杂的业务逻辑，但它们不能自行发起新的交易，总是依赖于EOA。它们所能做的只是根据编码在它们“代码”中的逻辑响应其他交易（显然是通过发起交易）。
- en: Take a look at the following three scenarios (Figures [4-3](#Fig3) to [4-5](#Fig5))
    to get a better understanding on the communication between the EOAs and Contract
    Accounts.EOA to EOA transaction:![A440588_1_En_4_Fig3_HTML.jpg](Images/A440588_1_En_4_Fig3_HTML.jpg)Figure
    4-3EOA to EOA transactionEOA to Contract Account Transaction:![A440588_1_En_4_Fig4_HTML.jpg](Images/A440588_1_En_4_Fig4_HTML.jpg)Figure
    4-4EOA to Contract Account transactionEOA to Contract Account to other Contract
    Account transaction:![A440588_1_En_4_Fig5_HTML.jpg](Images/A440588_1_En_4_Fig5_HTML.jpg)Figure
    4-5EOA to Contract Account to Contract Account transactionJust so the previous
    representations are not confusing, please be aware that the Contract Accounts
    are internal and the communications between them, too. Unlike EOA accounts where
    EOAs make a transaction that gets injected in the blockchain, Contract Accounts
    and the transactions between them are internal phenomena.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下三个场景（图[4-3](#Fig3)至[4-5](#Fig5)），以更好地了解EOA与合约账户之间的通信。EOA到EOA交易：![A440588_1_En_4_Fig3_HTML.jpg](Images/A440588_1_En_4_Fig3_HTML.jpg)图4-3EOA到EOA交易EOA到合约账户交易：![A440588_1_En_4_Fig4_HTML.jpg](Images/A440588_1_En_4_Fig4_HTML.jpg)图4-4EOA到合约账户交易EOA到合约账户再到其他合约账户交易：![A440588_1_En_4_Fig5_HTML.jpg](Images/A440588_1_En_4_Fig5_HTML.jpg)图4-5EOA到合约账户到合约账户交易为了不让之前的表示混淆，请注意，合约账户是内部的，它们之间的通信也是内部的。与EOA账户不同，在EOA账户中，EOA执行的交易会被注入区块链，而合约账户及其之间的交易是内部现象。
- en: Advantages of UTXOs
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UTXO的优势
- en: 'We must understand that Bitcoin’s design perspective was to maintain anonymity
    to an extent possible. When we compare it with Ethereum, the following advantages
    of UTXOs seem to have a lot of significance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须明白，比特币的设计初衷是在可能的情况下保持匿名性。当我们把它与以太坊相比较时，UTXO的以下优势似乎具有很大的意义：
- en: 'Better privacy: In Bitcoins, it is advisible to use a new address while receiving
    transactions, which helps reinforce anonymity. Even with sophisticated statistical
    or machine learning techniques, it is difficult to link the accounts together,
    though not impossible.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的隐私：在比特币中，接收交易时建议使用新地址，这有助于加强匿名性。即使使用复杂的统计或机器学习技术，也很难将账户联系起来，尽管并非不可能。
- en: 'Potentially more scalable: The discussion pertaining to scalability is usually
    very subjective and depends on the context, use case at hand, and many other factors.
    The intention here is to just mention UTXO’s inherent potential to scale. It is
    very easy to execute the transactions in parallel. Also, when an owner or other
    nodes maintaining the Merkle proof of ownership data for some coins lose this
    data, only the owner is impacted. On the contrary, when Merkle tree data for some
    account is lost, then any operation on that account would not be feasible, even
    sending to it.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的可扩展性更强：关于可扩展性的讨论通常非常主观，取决于上下文、手头上的用例以及许多其他因素。这里的目的只是提到UTXO固有的可扩展潜力。并行执行交易非常容易。另外，当某个所有者或其他维护特定币的Merkle所有权证明的节点丢失了这些数据时，只有所有者受到影响。相反，当某个账户的Merkle树数据丢失时，对该账户的任何操作都将无法进行，即使是向其发送操作。
- en: Advantages of Accounts
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 账户的优势
- en: 'Even though Ethereum in a way is an extention to Bitcoin, it is imagined with
    a whole new design with its own set of pros–cons tradeoff. Let us take a look
    at the following advantages of Ethereum accounts compared with Bitcoin design:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以太坊在某种程度上是比特币的扩展，但它有着全新的设计，有自己的利弊权衡。让我们来看看与比特币设计相比，以太坊账户的以下优势：
- en: 'Significant space saving: In Bitcoins, when multiple transactions are clubbed
    together to make one transaction (e.g., if you have to make a 5BTC transaction
    and you never received one transaction with at least 5BTC that you could use in
    this case, then you have to bundle multiple transactions so the total exceeds
    5BTC), that many references to those individual transactions must be made. Also,
    all those transactions must have different addresses, so as many transactions,
    that many addresses also! In Ethereum accounts, however, just one reference to
    an account is good enough. Even though Ethereum uses Merkle Patricia tree (MPT)  ,
    which is a bit more space intensive than Merkle tree, you end up saving a significant
    amount of space for complex transactions.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的空间节省：在比特币中，当多个交易组合在一起形成一个交易时（例如，如果你必须进行5BTC交易，但你从未收到至少5BTC的交易以供使用，那么你必须捆绑多个交易，使其总金额超过5BTC），必须对那些个体交易进行多次引用。另外，所有这些交易都必须具有不同的地址，所以与多少个交易，就有多少个地址！然而，在以太坊账户中，对账户的一个引用就足够了。尽管以太坊使用Merkle
    Patricia树（MPT），这比Merkle树占用更多的空间，但对于复杂交易，你最终节省了大量的空间。
- en: 'Simple to code: Along with UTXOs and scripts that are not Turing-complete,
    it is difficult to design complex systems. UTXOs can either be spent or unspent;
    there is no other state possible in between. Which makes it difficult to code
    up complex business logics. Even if the scripts are empowered to do more, it gets
    more complicated as compared with just using accounts. Since the objective of
    Ethereum is to go beyond cryptocurrency and accommodate different kinds of use
    cases (through DApps), an accounts-based system is almost inevitable.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码简单：除了UTXO和不可完成图灵机的脚本外，很难设计复杂的系统。UTXO要么被花费，要么未花费；不可能有其他状态。这使得编写复杂的业务逻辑变得困难。即使脚本被赋予更多的权力，与仅使用账户相比，它变得更复杂。由于以太坊的目标是超越加密货币并适应不同类型的用例（通过DApps），基于账户的系统几乎不可避免。
- en: 'Lightweight client reference: Unlike Bitcoin clients, Ethereum client applications
    can easily and quickly access all the data related to an account by scanning down
    the state tree in a specific direction. In the UTXO model, there are usually multiple
    references to multiple transactions associated to any specific transaction under
    consideration.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级客户端参考：与比特币客户端不同，以太坊客户端应用程序可以通过扫描特定方向的账户状态树轻松快速地访问与账户相关的所有数据。在UTXO模型中，通常会有多个引用与任何特定交易相关的多个交易。
- en: Account State
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 账户状态
- en: 'We learned that every account has a state associated with it. We also looked
    at the two kinds of accounts that exist with Ethereum, one is a Contract Account
    and the other is an Externally Owned Account or EOA. Regardless of the account
    type, they are tracked by the “stateRoot” Merkle root in the block header and
    may appear as shown in Figure [4-6](#Fig6).![A440588_1_En_4_Fig6_HTML.jpg](Images/A440588_1_En_4_Fig6_HTML.jpg)Figure
    4-6Zooming in to account state representationAs you can see in the figure, irrespective
    of whether the account is an EOA or or a Contract Account, it has the following
    four components:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，每个账户都与其关联的状态。我们还查看了以太坊存在的两种账户类型，一种是合约账户，另一种是外部所有账户或EOA。无论账户类型如何，它们都由块头中的“状态根”Merkle根跟踪，可能如图[4-6](#Fig6)所示。![A440588_1_En_4_Fig6_HTML.jpg](Images/A440588_1_En_4_Fig6_HTML.jpg)图4-6缩放账户状态表示
- en: 'Account balance: Total “Ether” balance in the account. More precisely, number
    of Wei owned by the address (1ETH = 10^(18) Wei)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户余额：账户中的“以太”总余额。更精确地说，地址拥有的 Wei 数量（1ETH = 10^(18) Wei）
- en: 'CodeHash: This is the hash of the “code.” Every Contract Account has “code”
    in it that gets executed on the EVM. The hash of this code is stored in this CodeHash
    field. For the EOA accounts, however, there is no “code,” so the CodeHash field
    contains the hash of empty string.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码哈希：这是“代码”的哈希。每个合约账户中都有在EVM上执行的“代码”。此代码的哈希存储在此CodeHash字段中。对于EOA账户， however，没有“代码”，所以CodeHash字段包含空字符串的哈希。
- en: 'StorageRoot: It is the 256-bit root hash of Merkle tree that encodes the storage
    contents of an account. The MPT encodes the hash of the storage content. Keeping
    the root hash of this tree in the StorageRoot field helps track the content of
    an account and also helps ensure its integrity.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储根：它是编码账户存储内容的Merkle树的256位根哈希。MPT编码存储内容的哈希。保留此树的根哈希在存储根字段中有助于跟踪账户内容，也有助于确保其完整性。
- en: 'Nonce: It is a counter that ensures each transaction is processed only once.
    For EOAs, this number represents the number of transactions from the account’s
    address. For Contract Accounts, it represents the number of contracts created
    by this account.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nonce：这是一个确保每个交易只被处理一次的计数器。对于 EOAs，这个数字代表账户地址的交易数量。对于合约账户，它代表这个账户创建的合约数量。
- en: So, it is the “state” trie that is responsible to keep track of the state changes
    of Ethereum blockchain. However, what is a bit tricky is that the state is not
    directly stored in each block, rather in the form of Recursive Length Prefix (RLP)-encoded
    state data in MPT at every Ethereum node. So, to maintain the global state, the
    Ethereum blockchain includes “state roots” in each and every block that store
    the root hash of the hash tree (Merkle root) representing the system state at
    the time the block was created.As per the Ethereum Yellow Paper, the “World State”
    is a mapping between addresses (160-bit identifiers) and account states. So, the
    World State has the information of all the accounts in blockchain, but is not
    stored in each block. Each block only modifies parts of the state. In a way, the
    World State is generated processing each block since the genesis block. Certain
    Ethereum nodes can choose to maintain all historical states by keeping all the
    historical transactions, that is, state transitions and their outputs. This allows
    clients to query the state of the blockchain at any time, even for the historic
    ones, without having to recalculate everything from the beginning. Retrieving
    the state information is similar to an aggregate query in SQL where data is readily
    available; just aggregation is required. So, old state data can easily be discarded
    (this is known as “pruning”) because they can be computed back when required.
    Well, the state data by design is implicit dada, which means state information
    should only be calculated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，负责跟踪以太坊区块链状态变化的“state”trie。然而，有点棘手的是，状态并不是直接存储在每一个区块中，而是以每个以太坊节点的 Recursive
    Length Prefix (RLP) 编码状态数据的形式存储在 MPT 中。因此，为了维护全局状态，以太坊区块链在每个区块中都包括“state roots”，存储该区块创建时哈希树（Merkle
    root）的根哈希。根据以太坊白皮书，"World State" 是地址（160位标识符）和账户状态之间的映射。所以，World State 拥有区块链中所有账户的信息，但不是存储在每一个区块中。每个区块只修改状态的一部分。在某种意义上，World
    State 是在处理每个区块从创世区块开始生成的。某些以太坊节点可以选择通过保留所有历史交易来维护所有历史状态，即状态转换及其输出。这允许客户端随时查询区块链的状态，甚至是历史的，而无需从头重新计算一切。检索状态信息类似于
    SQL 中的聚合查询，其中数据随时可用；只需进行聚合。所以，旧状态数据可以很容易地被丢弃（这被称为“修剪”），因为它们在需要时可以重新计算。嗯，状态数据按设计是隐含数据，这意味着状态信息应该只计算。
- en: Trie Usage
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Trie 使用
- en: We learned the three types of tries that have their roots in the block header.
    These roots are basically the pointers to those three tries. Though we looked
    at the one-liner explanations of these tries in previous sections, let us just
    revisit them with a slightly different choice of words
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了三种在区块头中有根的 trie。这些根基本上是指向这三种 trie 的指针。虽然我们在之前的段落中查看了这些 trie 的单行解释，让我们用略有不同的措辞重新访问它们
- en: 'State trie: It represents the entire state (the global state) after accessing
    the block.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态 trie：它代表访问区块后的整个状态（全局状态）。
- en: 'Transaction trie: It represents all the transactions in a block keyed by index
    (i.e., key:0 for the first transaction to execute, key:1 for the second transaction,
    etc.). Recollect the MPT fundamentals we covered earlier and try to correlate.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易 trie：它代表了一个区块中的所有交易，按索引键（即，键：0 用于第一个要执行的交易，键：1 用于第二个交易等）。回想一下我们之前覆盖的 MPT
    基本原理，并尝试进行关联。
- en: 'Receipt trie: It represents the "receipts" corresponding to each transaction.
    A receipt for a transaction is an RLP-encoded data structure as shown following:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收据 trie：它代表每个交易的“收据”。交易的收据是一个如下的 RLP 编码数据结构：
- en: '[ medstate, gas_used, logbloom, logs ]Let’s now dig deeper into the Receipt
    trie as we havn’t covered the basics yet on this. Take a look at all the fields
    in the Receipt trie’s RLP-encoded data structure and follow through the following
    descriptions for those fields:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[medstate, gas_used, logbloom, logs] 让我们现在更深入地探讨一下 Receipt trie，因为我们还没有在这个问题上覆盖基础知识。查看
    Receipt trie 的 RLP 编码数据结构中的所有字段，并按照以下描述跟进这些字段：'
- en: 'medstate: It is the State trie root after processing the transaction. A successful
    transaction updates the Ethereum state.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'medstate: 它是处理交易后的状态 trie 根。成功的交易会更新以太坊状态。'
- en: 'gas_used: It is the total amount of gas used for processing the transaction.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gas_used：它是处理交易所使用的总气体量。
- en: 'logs: It is a list of items of the form-'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: logs：它是以如下形式的项的列表：
- en: '[address, [topic1, topic2...], data]'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[地址, [主题1, 主题2...], 数据]'
- en: These list items are produced by the LOG0, LOG1… opcodes during the execution
    of the transaction. The “address” field is the address of the contract that produced
    the log, the “topic” fields are up to four 32-byte values, and the “data” field
    is an arbitrarily sized byte array.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些列表项是在交易执行期间由LOG0、LOG1…操作码产生的。 “address”字段是产生日志的合约地址，“topic”字段是四个32字节的值，而“data”字段是一个任意大小的字节数组。
- en: 'Logbloom: It is a Bloom filter made up of the addresses and topics of all logs
    in the transaction. This is different from the one present in the block header.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logbloom：它由交易中所有日志的地址和主题组成的一个布隆过滤器。这与区块头中的那个是不同的。
- en: Merkle Patricia Tree
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Merkle Patricia Tree
- en: 'In Ethereum, the accounts are mapped with their respective states. The mapping
    between all the Ethereum accounts, including EOAs and Contract Accounts with their
    states, is collectively referred to as World States. To store this mapping data,
    the datastructure used in Ethereum is the MPT. So, MPT is the principal data structure
    used in Ethereum which is otherwise known as Merkle Patricia trie. We learned
    about the Merkle trees in the Bitcoin chapter, which already takes us half way
    through in understanding MPT. MPT is actually derived by taking elements from
    both Merkle tree and Patricia tree.Recollect from the Bitcoin chapter that Merkle
    trees are the binary hash trees where the leaf nodes contain the hash of the data
    blocks and every nonleaf node contains the hashes of their child nodes. When such
    a data structure is implemented, it becomes easy to check if a certain transaction
    was a part of a block. Only by using very little information from the entire block,
    that is, by using just the Merkle branch instead of the entire tree, providing
    proof of membership was quite easy. Merkle trees facilitate efficient and secure
    verification of the contents in decentralized systems. Instead of downloading
    every transaction and every block, the light clients can only download the chain
    of block headers, that is, 80-byte chunks of data for each block that contain
    only five things: hash of the previous block header, timestamp, mining difficulty,
    nonce value that satisfied PoW, and the root hash of the Merkle tree containing
    all the transactions for that block. While it is quite useful and interesting,
    note here that apart from validating the proof of membership for a transaction
    in a block, there is nothing much you could do. One particular limitation is that
    no information can be proved about the current state (e.g., total digital asset
    holdings, name registrations, status of financial contracts). Even to check how
    many Bitcoins you hold, quite a lot of querying and validating is involved.Patricia
    trees on the other hand are a form of Radix trees. The name PATRICIA stands for
    “Practical Algorithm to Retrieve Information Coded In Alphanumeric.” A Patricia
    tree facilitates efficient insert/delete operations. The key-value lookups in
    the Patricia tree are very efficient. Keys are always encoded in the path. So,
    “key” is the path that you take from the root till the leaf node where the “value”
    is stored. Keys are usually the strings that help descend down the path where
    each character indicates which child node to follow to reach the leaf node and
    find the value stored in it.So, the MPTs provide a cryptographically authenticated
    data structure used to store all (key, value) bindings in Ethereum. They are fully
    deterministic, meaning that a Patricia tree with the same (key, value) bindings
    will surely be the same down to the last byte. The insert, lookup, and delete
    operations are quite efficient with O(log(n)) complexity. Due to the Merkle part
    in MPT, hash of a node is used as the pointer to the node and the MPT is constructed
    accordingly, whereKey == SHA3(RLP(value))While the Merkle part provides a tamperproof
    and deterministic tree structure, the Patricia part provides an efficient information
    retrieval feature. So, if you notice carefully, the root node in MPT becomes a
    cryptographic fingerprint of the entire data structure. In the Ethereum P2P network,
    when transactions are broadcast over the wire, they are assembled by every mining
    node that received them. The nodes then form a Tree (a.k.a. trie) and compute
    the root hash to include in the Block header. While the transactions are stored
    locally in the tree, they are sent to other nodes or clients after they are serialized
    to lists. The receiving parties have to deserialize them back to form the transaction
    tree to verify against the root hash. Also note that in Ethereum, MPTs are a little
    modified for better fitment with Ethereum implementation. Instead of binary, hexadecimal
    is used—X characters from a 16 character “alphabet.” Hence nodes in the tree or
    trie have 16 child nodes (the 16 character hex alphabet) and a maximum depth of
    X. Just to let you know, a hex character is referred to as a “nibble” in many
    places.The basic idea of an MPT in Ethereum is that for a single operation, it
    will only modify the minimum amount of nodes to recalculate the root hash. This
    way the storage and complexities are kept minimal.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，账户与其各自的状态相对应。所有以太坊账户之间的映射，包括EOAs和合约账户及其状态，统称为世界状态。为了存储这种映射数据，以太坊中使用的一种数据结构是MPT。所以，MPT是以太坊主要的的数据结构，它也被称为默克尔帕特里夏树。我们在比特币那一章中学过默克尔树，这已经让我们对MPT有了半数理解。MPT实际上是通过对默克尔树和帕特里夏树这两个元素进行组合而得来的。回想一下比特币那一章，默克尔树是一种二进制哈希树，其中叶节点包含数据块的哈希，每个非叶节点包含其子节点的哈希。当实现这样的数据结构时，就可以很容易地检查某个交易是否是一个块的一部分。只需使用整个块中的很少信息，也就是只使用默克尔支线而不是整个树，提供成员资格证明就相当容易。默克尔树促进了在去中心化系统中高效和安全地验证内容。不需要下载每一笔交易和每一个区块，轻客户端只需要下载区块头链，也就是每个区块包含的80字节数据，里面只有五样东西：前一个区块头的哈希、时间戳、挖矿难度、满足PoW的非ce值，以及包含该块所有交易的默克尔树的根哈希。虽然这很有用且有趣，但请注意，除了验证块中交易的成员资格证明之外，你什么也做不了。一个特别的限制是，无法证明关于当前状态的信息（例如，总数字货币持有量、名称注册、金融合同状态）。即使要检查你持有多少比特币，也需要进行大量的查询和验证。另一方面，帕特里夏树是基数树的一种形式。PATRICIA的名字代表“Practical
    Algorithm to Retrieve Information Coded In Alphanumeric.”。帕特里夏树促进了高效的插入/删除操作。在帕特里夏树中的键值查找非常高效。键总是编码在路径中。所以，“键”是你从根节点到存储“值”的叶节点的路径。键通常是帮助沿着路径下降的字符串，其中每个字符表示要跟随的子节点，以到达叶节点并找到存储在其中的值。因此，MPT提供了一种用于存储以太坊中所有（键，值）绑定的经过密码学验证的数据结构。它们是完全确定性的，这意味着具有相同（键，值）绑定的帕特里夏树肯定会一致到最后的字节。具有O(log(n))复杂性的插入、查找和删除操作相当高效。由于MPT中的默克尔部分，节点的哈希用作节点指针，并相应地构建MPT，其中键等于SHA3(RLP(值))。虽然默克尔部分提供了一个防篡改和确定性的树结构，但帕特里夏部分提供了有效的信息检索特性。所以，如果你仔细观察，MPT的根节点变成了整个数据结构的密码学指纹。在以太坊P2P网络中，当交易在网络上广播时，收到它们的每个挖矿节点都会将它们组装起来。节点然后形成一个树（也称为字典树）并计算根哈希以包含在区块头中。虽然交易在本地树中存储，但在它们被序列化为列表后发送到其他节点或客户端。接收方必须将它们反序列化以形成交易树，以针对根哈希进行验证。还要注意，在以太坊中，MPT为了更好地适应以太坊实现进行了少许修改。
    instead of binary, hexadecimal is used—X characters from a 16 character “alphabet.”
    Hence nodes in the tree or trie have 16 child nodes (the 16 character hex alphabet)
    and a maximum depth of X. Just to let you know, a hex character is referred to
    as a “nibble” in many places.以16个字符的“字母表”中的X个字符代替二进制。所以树或字典中的节点有16个子节点（16个字符的十六进制字母表）和X的最大深度。需要知道的是，在许多地方，十六进制字符被称为“nibble”。在以太坊中，MPT的基本思想是对于单一操作，它只会修改最小数量的节点来重新计算根哈希。这样可以将存储和复杂度保持在最小。
- en: RLP Encoding
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RLP编码
- en: You must have noticed that we mentioned RLP encoding in previous sections. We
    will give you a heads-up on what it is all about in this section. RLP stands for
    Recursive Length Prefix. It is a serialization method used in Ethereum for blocks,
    transactions, and wire protocol messages while sending data over the wire and
    also for account state data while saving the state in Patricia tree. In general,
    when complex data structures need to be stored or transmitted and then get reconstructed
    at the receiving end for processing, object serialization is a good practice.
    RLP in that sense is similar to JSON and XML, but RLP is believed to be more minimalistic,
    space efficient, simple to implement, and guarantees absolute byte-perfect consistency.
    This is why RLP was chosen to be the main serialization technique for Ethereum.
    Its sole purpose is to store nested arrays of raw bytes. It does not try to define
    any specific data types either, such as Booleans, floats, doubles, integers, etc.,
    and is only designed to store structure in the form of nested arrays. Key/value
    maps are not explicitly supported by RLP. So, it is advisible to represent such
    maps as [[k1, v1], [k2, v2], …], where k1, k2… are in lexicographic order (sorted
    using the standard ordering for strings). Alternatively, use the higher-level
    [Patricia tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree) encoding
    that has an inherent RLP encoding scheme.Please keep in mind that RLP is used
    only to encode the structure of the data and is completely unaware of the type
    of object being encoded. While it helps reduce the size of the encoding array
    of raw bytes, the decoding end must be aware of the type of object it is trying
    to decode.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你们可能已经注意到，在之前的章节中我们提到了RLP编码。在本节中，我们将提前告诉你这是关于什么。RLP代表递归长度前缀。它是以太坊中用于区块、交易和网络协议消息的序列化方法，在通过网络发送数据以及在Patricia树中保存状态时用于账户状态数据。通常，当需要存储或传输复杂的数据结构，并在接收端重新构建以进行处理时，对象序列化是一个好的实践。在这种意义上，RLP与JSON和XML相似，但RLP被认为更加极简主义，空间效率高，实现简单，并保证绝对的字节完美一致性。这就是为什么RLP被选为以太坊的主要序列化技术。它的唯一目的是存储嵌套的字节原始数组。它不尝试定义任何特定的数据类型，例如布尔值、浮点数、双精度数、整数等，并且仅设计用于存储嵌套数组的形式结构。RLP不显式支持键/值映射。因此，建议将此类映射表示为[[k1,
    v1], [k2, v2], …]，其中k1, k2…按字典顺序排序（使用字符串的标准排序）。或者，使用更高层次的[Patricia树](https://github.com/ethereum/wiki/wiki/Patricia-Tree)编码，该编码内嵌有RLP编码方案。请记住，RLP仅用于编码数据的结构，并且完全不知道被编码对象的类型。虽然它有助于减小编码字节的数组大小，但解码端必须知道它试图解码的对象类型。
- en: Ethereum Transaction and Message Structure
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊交易和消息结构
- en: 'In the previous section, we looked at the block structure and the different
    fields in the block’s header. For a transaction to be qualified by the miners
    or Ethereum nodes, it has to have a standardized structure. A typical Ethereum
    transaction (e.g., what you pass through sendRawTransaction()that we will see
    later in this book) consists of the following fields:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们研究了区块结构以及区块头中的不同字段。为了使交易能够被矿工或以太坊节点确认，它必须具有一个标准化的结构。一个典型的以太坊交易（例如，我们在这本书后面会看到的通过sendRawTransaction()传递的交易）包括以下字段：
- en: 'nonce: It is an integer, just a counter equal to the number of transactions
    sent by the sender account, i.e., transaction sequence number.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nonce：这是一个整数，只是发送者账户发送的交易数的计数器，即交易序列号。
- en: 'gasPrice: Price you are willing to pay in terms of the number of Wei to be
    paid per unit of gas'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gasPrice：你愿意支付的每单位gas的 Wei数量
- en: 'gasLimit: The maximum amount of gas that should be used in executing this transaction,
    which also limits the maximum number of computational steps the transaction execution
    is allowed to take'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gasLimit：执行此交易时应使用的最大gas量，这也限制了交易执行允许采取的最大计算步骤数
- en: 'To: Recipient’s 160-bits address or Contract’s address. For the transaction
    that is used to create a contract (it means contract’s address does not exist
    yet), it is kept empty.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'To: 接收者的160位地址或合约地址。对于用于创建合约的交易（这意味着合约地址尚不存在），它保持为空。'
- en: 'Value: Total Ether (number of Wei) to be transferred to the recipient by the
    transaction sender'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Value: 交易发送者要通过交易转移给接收者的总以太币（ Wei的数量）'
- en: 'V, r, s: values corresponding to the ECDSA signature of the transaction; also
    represent the sender of this transaction'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V, r, s：对应于交易ECDSA签名的值；同时也代表这个交易的发送者
- en: 'init: This is not really an optional field, only used with transactions used
    for creating contracts. This field can contain an unlimited size byte array specifying
    the EVM-code for the account initialisation procedure.The opcode “init” is used
    only once for initializing the new Contract Account and gets discarded after that.
    It returns the body of the account code after associating it with the Contract
    Account. Keep in mind that this association is a permanent phenomenon and never
    changes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'init: 这实际上不是一个可选字段，只在与用于创建合约的交易一起使用时使用。此字段可以包含一个无限大小的字节数组，用于指定账户初始化程序的EVM代码。"init"操作码仅在新合约账户初始化时使用一次，之后就会被丢弃。它在与合约账户关联后返回账户代码的主体。请记住，这种关联是一种永久现象，永远不会改变。'
- en: 'Data: An optional field that can contain a message to be sent to a contract
    or simple account. It has no special function as such by default, but the EVM
    has an opcode —using which, a contract can access this data field and perform
    necessary computations and place them in storage.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Data: 可选字段，可以包含发送给合约或简单账户的消息。默认情况下，它没有特殊功能，但EVM有一个操作码——使用该操作码，合约可以访问此数据字段并进行必要的计算并将它们放入存储中。'
- en: 'Note carefully that the aforementioned fields are supplied in the order specified
    and are all RLP encoded, except for the field names. So, an Ethereum transaction
    actually means a signed data package with these fields. The gasPrice and gasLimit
    fields are important to prevent denial of service attack. In order to prevent
    accidental or deliberate attempts of infinite loops or other computational wastage
    in code, each transaction is required to set a limit on how many computational
    steps for code execution it can use.Ethereum transactions are actually the "state
    transition functions" because a successful transaction changes the state. Also,
    the result of these transactions can be stored, as we already looked at in the
    “Account State” section previously.Ethereum messages on the other hand are like
    transactions, but are triggered only by Contract Accounts and not by EOAs. Also,
    messages are only meant to be between the Contract Accounts, due to which they
    are also referred to as "internal transactions." So, contracts have the ability
    to send messages to other contracts.Typically, a message is produced when a contract,
    while executing its code, encounters the “CALL” or “DELEGATECALL” opcodes. So,
    messages are more like function calls that exist in the Ethereum execution environment.
    It is also important to note that messages are always raw and never serialized
    or deserialized. A message contains the following fields:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述字段是按照指定顺序提供的，并且除了字段名称外都是RLP编码的。所以，以太坊交易实际上是一个带有这些字段的签名数据包。gasPrice和gasLimit字段对于防止服务拒绝攻击很重要。为了防止意外或故意的无限循环或其他计算资源浪费，每个交易都必须设置一个对代码执行可以使用的计算步骤的限制。以太坊交易实际上是“状态转换函数”，因为成功的交易会改变状态。此外，我们已经在之前的“账户状态”一节中查看了这些交易的结果可以被存储。另一方面，以太坊消息类似于交易，但仅由合约账户触发，而不是由EOA触发。此外，消息仅限于合约账户之间，因此也被称为“内部交易”。所以，合约具有向其他合约发送消息的能力。通常，当合约在执行其代码时遇到“CALL”或“DELEGATECALL”操作码时，会产生消息。因此，消息在以太坊执行环境中更像是一种函数调用。值得注意的是，消息总是原始的，从不进行序列化或反序列化。消息包含以下字段：
- en: 'Sender: The sender of the message as an implicit option'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sender: 消息的隐式发送者选项'
- en: 'Recipient: The recipient contract address to send to'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Recipient: 要发送到的接收合约地址'
- en: 'Value: The amount of Wei to transfer to the contract address along with the
    message'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Value: 随消息一起传输到合约地址的Wei数量'
- en: 'Data: Optional field, but can contain input data for the recipient contract
    provided by the sender'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Data: 可选字段，但可以包含发送者提供给接收合约的输入数据'
- en: 'gasLimit: The value that limits the maximum amount of gas the code execution
    can consume when triggered by the message. It is also termed “startGas.”'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gasLimit: 限制在消息触发时代码执行可以消耗的最大气体量。它也被称为“startGas。”'
- en: 'We looked at the transaction and messages. An Ethereum transaction can be from
    an EOA to an EOA, or from an EOA to a Contract Account. There exists another situation
    where a transaction from an EOA is initiated to create a Contract Account (recollect
    the “init” field that we just covered). Now, just think about what exactly a transaction
    is? It is definitely the bridge between the external world and the Ethereum blockchain,
    but what more? If you zoom in to a transaction, you will see that it is an instruction,
    initiated by the EOA by signing it, which gets serialized and submitted to the
    blockchain. Take a look at Figure [4-7](#Fig7).![A440588_1_En_4_Fig7_HTML.jpg](Images/A440588_1_En_4_Fig7_HTML.jpg)Figure
    4-7Transaction initiation—zoomed inNow what happens after a transaction is injected
    into the blockchain? Well, it starts executing at every Ethereum node if found
    valid. While this transaction is undergoing execution, Ethereum is designed to
    keep tabs on the “substate” to track the flow of execution. This is because, if
    a transaction does not complete due to “running out of gas,” then the entire execution
    so far has to be reverted. Also, information collected during the execution is
    required immediately after the transaction completion. So, the substate contains
    the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了交易和消息。以太坊交易可以从一个EOA（普通用户账户）到另一个EOA，或者从一个EOA到合约账户。还存在另一种情况，即由EOA发起的交易用于创建合约账户（回想一下我们刚刚讲过的“init”字段）。现在，想想一个交易到底是什么？它无疑是外部世界与以太坊区块链之间的桥梁，但还有更多吗？如果你放大一个交易，你会看到它是由EOA签名后发起的指令，然后序列化并提交到区块链。看看图[4-7](#Fig7)
    ![A440588_1_En_4_Fig7_HTML.jpg](Images/A440588_1_En_4_Fig7_HTML.jpg)图4-7 交易发起—放大现在交易注入区块链后会发生什么？嗯，如果交易有效，它会在每个以太坊节点上开始执行。在交易执行期间，以太坊设计用来跟踪“子状态”以追踪执行流程。这是因为，如果一个交易由于“燃料耗尽”而没有完成，那么到目前为止的整个执行都需要回滚。此外，交易完成后的立即时间内需要收集执行期间的信息。所以，子状态包含以下内容：
- en: 'Self-destruct set: a set of accounts (if any) that will be discarded after
    the transaction completion'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自毁设置：在交易完成后将被丢弃的一组账户（如果有的话）。
- en: 'Log series: archived and indexable “checkpoints” of the EVM’s code execution
    to track the contract calls'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志系列：以太坊虚拟机代码执行的归档且可索引的“检查点”，用于追踪合约调用。
- en: 'Refund balance: It is the amount to be refunded to the sender account post
    transaction execution. Storage in Ethereum is quite expensive, so there is an
    SSTORE instruction in Ethereum that is used as a refund counter. The refund counter
    starts at zero (no refund state) and gets incremented every time the transaction
    or contract deletes something from the storage. Please note that this refund amount
    is different and in addition to the unused gas that gets refunded to the sender.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退款余额：交易执行后需要退回到发送者账户的金额。在以太坊中存储费用相当昂贵，因此有一个SSTORE指令用作退款计数器。退款计数器从零开始（无退款状态），并在每次交易或合约从存储中删除项目时递增。请注意，这个退款金额与发送者未使用的燃料费退款是不同的，而且是额外的。
- en: In the earlier versions of Ethereum, whether a transaction or contract executes
    successfully or fails in between, the entire gas used to get consumed. This was
    not always making sense. If an execution stopped due to some authorization/permission
    issue or any other issue, the execution would stop and the remaining gas would
    still be consumed. The last Byzantium update introduced the “revert” code like
    an exception handling. In case a contract has to stop, “revert” could be used
    to revert state changes, return a reason for failure, and credit the remaining
    gas back to the sender. Post successful execution of the transactions or contracts,
    a state transition happens that we will dive deeper into in the followiung section.Just
    the way we looked at blockchaininfo to see a live Bitcoin transaction, if you
    take a look at [https://etherscan.io](https://etherscan.io/) for Ethereum you
    will find the following information:![A440588_1_En_4_Figa_HTML.jpg](Images/A440588_1_En_4_Figa_HTML.jpg)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊的早期版本中，无论交易或合约成功执行还是失败，整个燃料都会被消耗。这并不总是有意义的。如果由于某些授权/权限问题或其他问题导致执行停止，执行会停止，但剩余的燃料仍会被消耗。拜占庭更新引入了“revert”代码，类似于异常处理。如果合约需要停止，可以使用“revert”来撤销状态变化，返回失败原因，并将剩余燃料信用回发送者。在成功执行交易或合约后，会发生一个我们将在下一节深入探讨的状态转换。就像我们查看区块链info以查看比特币交易的实时状态一样，如果你查看[https://etherscan.io](https://etherscan.io/)获取以太坊信息，你会找到以下内容：![A440588_1_En_4_Figa_HTML.jpg](Images/A440588_1_En_4_Figa_HTML.jpg)
- en: Ethereum State Transaction Function
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊状态交易函数
- en: 'In the previous section, we learned about Ethereum transactions and messages.
    We are now aware that a state transition happens whenever a transaction is through—successfully.
    So, the state transition function in Ethereum is:APPLY(S,Tx) -> S''    \\where
    S is old state and S'' is the new stateTake a look at Figure [4-8](#Fig8).![A440588_1_En_4_Fig8_HTML.jpg](Images/A440588_1_En_4_Fig8_HTML.jpg)Figure
    4-8Ethereum state transition functionSo, the state transition function when Tx
    is applied to state S to result in changed state S’ can be defined as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了以太坊交易和消息。我们现在知道，每当交易成功时，都会发生状态转换。所以，以太坊的状态转换函数是：APPLY(S,Tx) -> S'     \\
    其中S是旧状态，S'是新的状态。看看图 [4-8](#Fig8) 。![A440588_1_En_4_Fig8_HTML.jpg](Images/A440588_1_En_4_Fig8_HTML.jpg)图
    4-8 以太坊状态转换函数所以，当Tx应用于状态S以产生变化的状态S'时，状态转换函数可以定义如下：
- en: Validate the transaction to see if it is well formed.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证交易是否形成良好。
- en: Has the right number of values
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有正确的数值。
- en: The signature is valid.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名是有效的。
- en: The nonce matches the nonce in the sender’s account.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对齐数与发送者账户中的非对齐数一致。
- en: If any of preceding points is not valid, return an error.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果上述任何一点无效，返回一个错误。
- en: Calculate the fee and settle the accounts.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算费用并结账。
- en: Compute the transaction fee as gasLimit * gasPrice.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算交易费用为gasLimit * gasPrice。
- en: Determine the sending address from the signature.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从签名中确定发送地址。
- en: Subtract the fee from the sender’s account balance and increment the sender’s
    nonce.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从发送者的账户余额中减去费用，并增加发送者的非对齐数。
- en: If there is not enough balance to spend, return an error.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有足够的余额来花费，返回一个错误。
- en: Initialize GAS = gasLimit, and take off a certain quantity of gas per byte to
    pay for the bytes as a transaction fee.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化GAS = gasLimit，并从中减去一定数量的燃料作为交易费用。
- en: Transfer the transaction value (could be anything of value) from the sender’s
    account to the receiving account. Note here that the transaction could be for
    anything of some intrinsic value such as land, vehicle, ERC20 tokens, etc., but
    the gas Price has to be in Ether so that the miners would accept the transaction.
    If the receiving account does not yet exist, create it.If the receiving account
    is a contract and not an EOA, then run the contract’s code either to completion
    or until the execution runs out of gas. Note here that the contract code gets
    executed on every node’s EVM as part of the block validation process so that the
    block, hence the contract’s output post execution, becomes a part of the main
    blockchain.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将交易价值（可以是任何有价值的东西）从发送者的账户转移到接收者账户。注意这里，交易可能是任何具有内在价值的东西，如土地、车辆、ERC20代币等，但燃料价格必须是以太币，以便矿工接受交易。如果接收账户尚不存在，则创建它。如果接收账户是一个合约而不是EOA，那么运行合约的代码，要么运行完成，要么执行耗尽燃料。注意这里，合约代码会在每个节点的EVM上作为区块验证过程的一部分执行，以便区块（从而合约执行后输出）成为主区块链的一部分。
- en: If the value transfer failed because the sender did not have enough money, or
    the code execution ran out of gas, revert all state changes (thanks to MPT implementation)
    except the payment of the fees, and add the fees to the miner’s account.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果因为发送者钱不够或者代码执行耗尽燃料而转账失败，除了支付费用外，撤销所有状态更改（感谢MPT实现），并将费用添加到矿工账户。
- en: Otherwise, refund the fees for all remaining gas back to the sender, and send
    the fees paid already for gas consumed to the miner.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将剩余的所有燃料费用退还给发送者，并将已经支付给燃料的费用发送给矿工。
- en: Gas and Transaction Cost
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 燃料和交易成本
- en: 'Transactions on Ethereum run on “gas,” the fundamental unit of computation
    in Ethereum. Every transaction, whether to an EOA or to a contract, must have
    the gasLimit and gasPrice to compute the fee. This fee is paid to the miners to
    compensate them for their resource contributions and work they perform. Obviously,
    miners have the choice of including the transaction and collecting the fee, similar
    to that of Bitcoin.Usually, a computational step costs just one gas, but some
    of the compute- or storage-intensive operations cost more. For every byte of transaction
    data, around five gas is required. Take a look at these sample examples: adding
    two numbers (with EVM opcode ADD) requires approximately three gas; multiplying
    two numbers (with EVM opcode MUL) requires approximately five gas; calculating
    a hash (SHA3) requires around 30 gas (compute-intensive, you see). Storage cost
    is also computed in similar fashion, but quite expensive for good reasons. As
    per the design, a transaction can include an unlimited amount of data. It costs
    68 gas per byte of nonzero transaction data. To store a 256-bit word in a “Contract,”
    approximately 20,000 gas is required. You could find more opcodes and their corresponding
    prices in the Ethereum yellow paper. The cost then would be to just multiply the
    gas required with the gasPrice. Unlike Bitcoin, Ethereum cost computation is more
    complex. It takes into account the costs of bandwidth, storage, and computation.
    Having such a fee computation mechanism prevents the Ethereum network from an
    attacker who might just want to inject an infinite loop for computation (leading
    to denial-of-service attacks) or consume more and more space by storing meaningless
    data.The total Ether a transaction would cost actually depends on the amount of
    gas consumed by the transaction, multiplied by the price of one unit of gas specified
    in the transaction by the transaction initiator. Miners on the other hand have
    a strategy for calculating the gas Price to charge, which should be the least
    amount the sender of a transaction must specify so that the transaction does not
    get rejected by the miner. So, how do you calculate the total cost of a transaction?
    Not the approximate one, but the actual cost? The total “Ether” cost of a transaction
    is based on two factors: gasUsed and gasPrice. Total cost = gasUsed * gasPrice.
    The gasUsed component is the total gas consumed while excuting the EVM opcodes
    for the instructions, and gasPrice is the one specified by the user.If the total
    amount of gas used by the computational steps (including the transaction, the
    message, and any submessages that may be triggered) is less than or equal to the
    gasLimit, then the transaction is processed by the miner. However, if the total
    gas exceeds the gasLimit, then all changes are reverted (though it is a valid
    transaction), except that the fee can still be collected by the miner. So, what
    happens to the excess gas? All the unused gas after transaction execution is reimbursed
    to the sender as Ether. Senders do not need to worry about overspending, as they
    are only charged for the gas consumed. This definitely means that it is important
    as well as safe to send transactions with a gas limit well above the estimates.
    It is also recommended not to pay very high gas Price and use the average gas
    price from [https://ethgasstation.info/](https://ethgasstation.info/) .Let us
    go through each and every step when a transaction is made in an Ethereun network
    to build a concrete understanding of the flow:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊上的交易依赖于“燃料”（gas），这是以太坊计算的基本单位。每笔交易，无论是对EOA（外部账户）还是对合约，都必须有燃料限制（gasLimit）和燃料价格（gasPrice）来计算费用。这笔费用支付给矿工，以补偿他们的资源贡献和工作。显然，矿工可以选择包含交易并收取费用，这与比特币类似。通常，一个计算步骤只需一个燃料单位，但一些计算或存储密集型操作会花费更多。对于每个交易数据字节，大约需要五个燃料单位。举例来说：进行两个数字的加法（使用EVM
    opcode ADD）大约需要三个燃料单位；两个数字的乘法（使用EVM opcode MUL）大约需要五个燃料单位；计算一个哈希（SHA3）大约需要30个燃料单位（计算密集型，你看到了）。存储成本也是以类似方式计算，但对于合理的原因相当昂贵。根据设计，交易可以包含无限量的数据。每个非零交易数据的字节需要68个燃料单位。在“合约”中存储一个256位的词大约需要20,000个燃料单位。你可以在以太坊黄皮书[https://ethgasstation.info/](https://ethgasstation.info/)中找到更多操作码及其相应的价格。然后，成本就是将所需的燃料乘以燃料价格。与比特币不同，以太坊的计算成本更为复杂。它考虑了带宽、存储和计算的成本。拥有这样的费用计算机制可以防止以太坊网络遭受攻击者可能只是想注入无限循环进行计算（导致服务拒绝攻击）或通过存储无意义数据来消耗越来越多的空间。交易的总以太币成本实际上取决于交易消耗的燃料量，乘以交易发起者指定的燃料单位价格。另一方面，矿工有一个计算燃料价格的策略，即矿工收取的最少燃料单位价格，使得交易不会被矿工拒绝。那么，你如何计算交易的总成本呢？不是近似值，而是实际成本？交易的总“以太币”成本基于两个因素：燃料使用量（gasUsed）和燃料价格（gasPrice）。总成本
    = 燃料使用量 * 燃料价格。燃料使用量是在执行EVM操作码时消耗的燃料总量，而燃料价格是用户指定的。如果计算步骤（包括交易、消息以及可能触发的任何子消息）消耗的总燃料量小于或等于燃料限制，那么交易将由矿工处理。然而，如果总燃料超过燃料限制，那么所有更改都将被回滚（尽管这是一个有效的交易），不过矿工仍然可以收取费用。那么，超出部分的燃料会发生什么？在交易执行后，所有未使用的燃料将以以太币的形式退还给发送者。发送者不需要担心超支，因为他们只被收取消耗的燃料费用。这绝对意味着估算时留出充足的燃料上限是非常重要且安全的。建议不要支付过高的燃料价格，而应使用[https://ethgasstation.info/](https://ethgasstation.info/)的平均燃料价格。让我们深入了解在以太坊网络上发起交易时的每一个步骤，以建立对流程的清晰理解：
- en: Every transaction must define a “gasLimit” that it is willing to spend (gasLimit
    is also termed “startGas”), and the fee that it is willing to pay per unit of
    gas (gasPrice). At the start of execution, Ether worth of gasLimit * gasPrice
    is removed from the transaction sender’s account. Remember that this is not really
    the total cost of a transaction (should be a bit more than that in an ideal case).
    Only after the transaction, its actual cost is concluded (gasUsed * gasPrice)
    that’s adjusted from this (gasLimit * gasPrice), which was initially deducted
    from sender’s account and the balance amount is credited back to the sender. In
    the beginning of a transaction itself, the amount (gasLimit * gasPrice) is deducted
    because there could be a possibility that the sender could go bankrupt while the
    transaction they initiated is midway through.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个交易都必须定义一个“gasLimit”，它愿意花费多少gas（gasLimit也称为“startGas”），以及它愿意支付每单位gas的费用（gasPrice）。在执行开始时，交易发送者账户中的Ether价值为gasLimit
    * gasPrice的gas被移除。记住，这并不是交易的总成本（在理想情况下应该比这个数字稍多）。只有在交易之后，其实际成本才确定（gasUsed * gasPrice）从这个（gasLimit
    * gasPrice）中调整，最初从发送者账户中扣除，并将余额退回到发送者。在交易开始时，这个数额（gasLimit * gasPrice）就被扣除，因为发送者有可能会在交易进行到一半时破产。
- en: All operations during transaction execution, including database reads and writes,
    messages, and every computational step taken by the E VM such as addition, subtraction,
    hash, etc. consume a certain quantity of gas that is predefined.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交易执行期间的所有操作，包括数据库的读写、消息，以及E VM进行的加法、减法、散列等每一步计算，都会消耗一定数量的预定义gas。
- en: A normal transaction is one that executes successfully without exceeding the
    gasLimit specified. For such transactions, there should be some gas remaining,
    say, “gas_rem”. After a successful transaction execution, the transaction sender
    receives a refund of “gas_rem * gasPrice” and the miner of the block receives
    a reward of “(gasLimit - gas_rem) * gasPrice”.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常的交易是指在不超出指定的gasLimit的情况下成功执行的交易。对于这样的交易，应该还剩下一些gas，比如说“gas_rem”。在成功执行交易后，交易发送者会收到“gas_rem
    * gasPrice”的退款，而区块矿工会收到“（gasLimit - gas_rem）* gasPrice”的奖励。
- en: If a transaction runs out of gas before successful completion, then all executions
    revert, but the transaction is nevertheless valid. In such situations, the only
    outcome of the transaction is that the entire amount “gasLimit * gasPrice” is
    allocated to the miner.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个交易在成功完成之前耗尽了gas，那么所有的执行都会回滚，但交易仍然是有效的。在这种情况下，交易的唯一结果是整个金额“gasLimit * gasPrice”被分配给矿工。
- en: In the case of Contract Accounts, when a contract sends a message to the other
    contract for subexecution, it also has the option to set a gasLimit. This option
    is specifically intended for the subexecution arising out of that message, because
    there is a possibility that the called contract has an infinite loop. If the subexecution
    runs out of gas, then the subexecution is reverted, which protects against such
    infinite loops or deliberate attempts of DoS attacks. The gas is consumed anyway
    and allocated to the miner. Also note that when a message is triggered by a contract,
    only the instructions cost gas, but data in a message do not cost any gas. This
    is because the data from the parent contract need not be copied again, and could
    be just referrenced through a pointer.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在合约账户的情况下，当一个合约向另一个合约发送消息以进行子执行时，它也有选项设置一个gasLimit。这个选项特别旨在那个消息产生的子执行中，因为有可能被调用合约有一个无限循环。如果子执行耗尽了gas，那么子执行会被回滚，这可以防止无限循环或故意的DoS攻击。无论如何，gas都会被消耗，并分配给矿工。另外请注意，当一个合约触发了消息时，只有指令会消耗gas，而消息中的数据不会消耗任何gas。这是因为从父合约复制的数据不需要再复制，只需通过指针引用即可。
- en: 'The first Ethereum release (Frontier) had a default gas Price of 0.05e12 WEI
    (i.e., smallest denomination of Ether). In the second Ethereum release (Homestead),
    default gas Price was reduced to 0.02e12 WEI. You must be wondering why gas and
    Ether are decoupled from each other and not a single unit of measurement, which
    would have made it much simpler. Well, it is deliberately designed this way because
    units of gas align well with computation units having a natural cost (e.g., cost
    per computation), while the price of Ether generally fluctuates as a result of
    market forces.We already know that every Ethereum node participating in the network
    runs the EVM as part of the block verification protocol. This means that all the
    nodes execute the same set of transactions and contracts (redundantly parallel,
    but essential for consensus). While this redundency naturally makes it expensive,
    there is an incentive not to use the blockchain for computation that can be done
    offchain (Game Theory!).Typically, 21,000 gas is charged for any transaction as
    a "base fee" to cover the cost of an elliptic curve operation to compute the sender
    address from the signature, and also for the disk space of storing the transaction.
    There are ways to estimate gas requirements for transactions and contracts. Example:
    “estimateGas” is a Web3 function to estimate gas requirement for a given function.
    Also, to estimate the total cost, gas price oracle is a helper function in “geth”
    client and “web3.eth.getGasPrice” is a Web3 native function to find an approximate
    gas Price. Following is an example code that can be used in “Truffle”:var MyContract
    = artifacts.require("./MyTest.sol");// getGasPrice returns the gas price in WeiMyContract.web3.eth.getGasPrice(function(error,
    result){    var gasPrice = Number(result);    console.log("Current gasPrice is
    " + gasPrice + " wei");    // Get the Contract instance    MyContract.deployed().then(function(instance)
    {        // Retrieve gas estimation for the function giveAwayDividend()        return
    instance.giveAwayDividend.estimateGas(1);    }).then(function(result) {        var
    gas = Number(result);        console.log("Total gas estimation = " + gas + " units");        console.log("Total
    Transaction Cost estimation in Wei = " + (gas * gasPrice) + " wei");        console.log("Total
    Transaction Cost estimation in Ether = " + MyContract.web3.fromWei((gas * gasPrice),
    ''ether'') + " Ether");    });});Example code for transaction cost estimationWhile
    writing smart contracts in Solidity, many prefer to use “constant” functions to
    compute certain things offchain or just make an RPC query to your local blockchain.
    Since such constant functions do not change the blockchain state, they are in
    a way free of cost as they do not consume gas. If the constant functions are used
    inside of any transaction, then it is highly likely that gas expense would be
    required.Let us now learn about the block’s gas limit. Recollect that Bitcoin
    had a predefined limit of 1MB block size and Bitcoin cash had a 2MB block size.
    Miners would accumulate as many transactions as could fit in those blocks. Ethereum,
    however, has a very different way of limiting the block size. In Ethereum, the
    block size is controlled by the block gas limit. Different transactions have different
    gas limits; so, depending on the block gas limit, a certain number of transactions
    are clubbed together so that total transactions gas limit is less than the block
    gas limit. Different miners can have different sets of transactions that they
    are willing to put in a block. The block gas limit is dynamically calculated.
    The Ethereum protocol allows the miner of a block to adjust the block gas limit
    by a factor of 1/1024 (0.0976%) in either direction. Miners on the Ethereum network
    use a mining program, such as “ethminer.” The ethminer  is an Ethereum GPU mining
    worker, which connects to either geth or Parity Ethereum client node. Both geth
    and Parity have options that miners can change.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的第一个版本（Frontier）默认的燃气价格是0.05e12 WEI（即以太币的最小单位）。在第二个版本（Homestead）中，默认的燃气价格降低到了0.02e12
    WEI。你可能会好奇为什么燃气和以太币不是相互关联的单一单位，这样可以简化很多。然而，这是故意这样设计的，因为燃气的单位很好地与具有自然成本（例如，每项计算的成本）的计算单位对齐，而以太币的价格通常会因市场力量而波动。我们已经知道，参与网络的每一个以太坊节点都会在区块验证协议中运行EVM。这意味着所有节点都会执行相同的一组交易和合约（虽然冗余但对于共识是必要的）。尽管这种冗余自然会使其变得昂贵，但存在一种激励，不将可以离链完成的计算放在区块链上（博弈论！！！）。通常，任何交易都会收取21,000燃气作为“基本费用”，以覆盖从签名计算发送者地址的椭圆曲线操作的成本，以及存储交易的磁盘空间。有方法可以估算交易和合约所需的燃气。例如：“estimateGas”是一个用于估算给定函数燃气需求的Web3函数。“geth”客户端的燃气价格预言机是一个助手函数，而“web3.eth.getGasPrice”是一个Web3原生函数，用于查找近似的燃气价格。以下是一个可以在“Truffle”中使用的示例代码：
- en: Ethereum Smart Contracts
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ethereum 智能合约
- en: 'Unlike Bitcoin, which is just a cryptocurrency, Ethereum is so much more–thanks
    to the smart contracts. We got a glimpse of what a smart contract might be in
    the previous sections while learning about Contract Accounts. While we will get
    into the development aspects of smart contracts in the following chapters, we
    will have a detailed exploration of what they really are in this section.Let us
    start with why it is named so? Please be aware that there is nothing “smart” in
    a smart contract that is out-of-the-box. It is smart when you code smart logic
    into it, and it is the beauty of Ethereum that enables you to do so. Let us just
    summarize our learning so far on the Ethereum smart contracts:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币不同，比特币只是加密货币，而以太坊由于智能合约而变得更加丰富。在之前的章节中，我们在学习合约账户时对智能合约可能是什么有了一个初步的了解。在接下来的章节中，我们将进入智能合约的开发方面，但在这个部分我们将详细探讨它们究竟是什么。首先，让我们来了解一下为什么这样命名？请注意，智能合约中并没有“智能”的东西。当您将智能逻辑编码到其中时，它才是智能的，这也是以太坊的魅力所在，它使您能够这样做。让我们简要总结一下到目前为止关于以太坊智能合约的学习：
- en: Smart contracts reside inside the Ethereum blockchain.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约位于以太坊区块链内。
- en: They have their own account, hence address and balance.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有自己的账户，因此有地址和余额。
- en: They are capable of sending messages and receiving transactions.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们能够发送消息并接收交易。
- en: They get activated when they receive a transaction, and can be deactivated as
    well.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在接收到交易时激活，也可以被禁用。
- en: Like other transactions, an execution fee and storage fee are applicable for
    them as well.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像其他交易一样，对它们也适用执行费和存储费。
- en: All the code in Ethereum, including the smart contracts, is compiled to a low
    level, stack-based bytecode language, referred to as EVM code, that runs on EVM.
    The popular high-level languages used to write smart contracts are Solidity, Serpent,
    and LLL, where their respective compilers convert the high-level code into the
    EVM byte code. We looked at how contracts could be added into the blockchain by
    any external agent such as EOA. Since computation and storage in Ethereum are
    very expensive, it is advisible that the logic should be written in as simple
    and optimized fashion as possible. When a smart contract is deployed to the Ethereum
    blockchain network, it is possible for anyone to call the functions of the smart
    contract. The functions usually have security features coded up that prevent unauthorized
    access; nevertheless, attempts can be made though they won’t succeed.If you try
    to imagine a smart contract inside of a block in an Ethereum blockchain, it might
    appear as in Figure [4-9](#Fig9).![A440588_1_En_4_Fig9_HTML.jpg](Images/A440588_1_En_4_Fig9_HTML.jpg)Figure
    4-9Ethereum smart contract with respect to blocksLet us now take an example of
    a voting application. A smart contract is written that has an address (Contract
    Account address) and is a part of some block in the blockchain, depending on when
    it was created. The voters can make transactions to that address (votes). The
    contract code is written such that it will increment the vote count with every
    transaction received and terminates itself after some time, publishing the voting
    result (Ethereum state change). Take a look at Figure [4-10](#Fig10) to have a
    diagramatic representation for a high-level understanding.![A440588_1_En_4_Fig10_HTML.jpg](Images/A440588_1_En_4_Fig10_HTML.jpg)Figure
    4-10An application with smart contract logic
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 中的所有代码，包括智能合约，都被编译成一种低级的基于栈的字节码语言，称为 EVM 代码，在 EVM 上运行。用于编写智能合约的流行高级语言有
    Solidity、Serpent 和 LLL，各自的编译器将这些高级代码转换为 EVM 字节码。我们来看一下任何外部代理（如 EOA）如何将合约添加到区块链中。由于
    Ethereum 中的计算和存储非常昂贵，因此建议逻辑应该尽可能简单和优化地编写。当智能合约部署到以太坊区块链网络时，任何人都能够调用智能合约的函数。这些函数通常编有安全特性，以防止未授权访问；尽管如此，仍然可以尝试，但不会成功。如果你试图想象一个智能合约在以太坊区块链中的一个区块内，它可能如图
    [4-9](#Fig9) 所示。![A440588_1_En_4_Fig9_HTML.jpg](Images/A440588_1_En_4_Fig9_HTML.jpg)图
    4-9 与区块相关的以太坊智能合约
- en: Contract Creation
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合约创建
- en: 'Recollect that we learned about the contract creation transaction, whose only
    purpose is to create a contract. It is a bit different kind of transaction compared
    with the other types. So, before the contract creation transaction is fired up
    to create a Contract Account, it must first initialize the four properties that
    all types of accounts have:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们学过关于智能合约创建交易的内容，这种交易的唯一目的就是创建一个合约。与其它类型的交易相比，它是一种略有不同的交易。所以，在合约创建交易被触发以创建一个合约账户之前，它必须首先初始化所有类型的账户都具有的四个属性：
- en: The “nonce” should be set to zero initially.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “nonce”最初应设置为零。
- en: The “Account Balance” should be set with the value (amount of Ether) transferred
    by the sender, and the same amount must be deducted from the sender’s account.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Account Balance”应设置为发送者转移的以太币（金额），发送者的账户必须扣除相同金额。
- en: The “StorageRoot” should be empty.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “StorageRoot”应该是空的。
- en: The contract’s “codeHash” should be set with the Keccak 256-bit hash of an empty
    string.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约的“codeHash”应设置为空字符串的 Keccak 256 位哈希。
- en: 'After initializing the account, the account can be created using the init code
    sent with the transaction that does the real work. There could be a whole bunch
    of actions defined in init code, and it’s execution can effect several events
    that are not internal to the execution state, such as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化账户后，可以使用与执行交易一起发送的 init code 创建账户，执行真正的工作。init code 中可能定义了一组操作，其执行可以影响不属于执行状态的几个事件，例如：
- en: The account’s ‘storage’ can be altered.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户的“存储”可以被更改。
- en: Further accounts can be created.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以创建更多的账户。
- en: Further message calls can be triggered.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以触发进一步的消息调用。
- en: Ethereum Virtual Machine and Code Execution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊虚拟机和代码执行
- en: 'Ethereum is a programmable blockchain that allows users to create their own
    operations of any arbitrary complexity through Turing-complete languages. The
    EVM is the execution engine of Ethereum that serves as the runtime environment
    for smart contracts. It is the primary innovation of Ethereum that makes it unique
    compared with other blockchain systems. It is the EVM on the basis of which the
    smart contract technology is supposed to get to the next level of innovation,
    and the game is on. EVM also plays a critical role in transaction execution, changing
    the state of Ethereum, and achieving consensus. The design goals of EVM are as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是一个可编程区块链，它允许用户通过图灵完备语言创建他们自己的任意复杂度的操作。EVM 是以太坊的执行引擎，为智能合约提供运行时环境。这是以太坊相对于其他区块链系统的主要创新之处。基于
    EVM，智能合约技术预计将达到下一个创新水平，游戏即将开始。EVM 在交易执行、改变以太坊状态和实现共识方面也发挥着关键作用。EVM 的设计目标如下：
- en: 'Simplicity: The idea was to make EVM as simple as possible with the low-level
    constructs. This is why the number of low-level opcodes is kept to a minimum,
    and so are the data types to the extent that complex logics could still be written
    conveniently using these constructs. Total 160 instructions, out of which 65 are
    logically distinct'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化：想法是以尽可能简单的低级构造来设计 EVM。这就是为什么将低级操作码的数量保持在最小值，数据类型也是如此，尽管理论上可以使用这些构造方便地编写复杂逻辑。总共有
    160 条指令，其中 65 条是逻辑上不同的
- en: 'Absolute determinism: Ensuring that the execution of instructions with the
    same set of inputs should produce the same set of outputs (deterministic!) helps
    maintain the integrity of the EVM without any ambiguity. Determinism along with
    the concept of “computational step” helps estimate gas expense with close approximation.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对确定性：确保具有相同输入的指令执行产生相同输出（确定性！）有助于不带任何歧义地维护 EVM 的完整性。确定性以及“计算步骤”的概念有助于估算气体的消耗。
- en: 'Space optimization: In decentralized systems, space saving is a biggest concern.
    This is why the EVM assembly is kept as compact as possible.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间优化：在去中心化系统中，节省空间是最重要的问题。这就是为什么将 EVM 汇编尽可能紧凑。
- en: 'Tuned for native operations: EVM is tuned for some native operations such as
    the specific types of arithmatic operations used for cryptography (modular arithmatic),
    reading blocks or transaction data, interacting with “states,” etc. Another such
    example is: 256-bit (32 bytes) word length to store cryptographic hashes, where
    EVM operates on the same 256-bits integer.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对原生操作进行优化：EVM 对某些原生操作进行了优化，例如用于密码学的特定类型的算术操作（模运算），读取区块或交易数据，与“状态”互动等。另一个这样的例子是：256
    位（32 字节）的单词长度用于存储密码学哈希值，其中 EVM 在相同的 256 位整数上操作。
- en: 'Easy security: In a way, gas Price helps ensure that the EVM is nonexploitable.
    If there was no cost, attackers could just keep attacking the system in every
    possible way. While almost every operation on EVM requires some gas cost, it should
    be easy to come up with good gas cost model on EVM'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的安全性：在某种程度上，燃料价格有助于确保 EVM 不可滥用。如果没有成本，攻击者可以以每种可能的方式不断攻击系统。尽管在 EVM 上的几乎每个操作都需要一些燃料成本，但应该很容易为
    EVM 制定好的燃料成本模型。
- en: 'We learned that every participating node in the Ethereum network runs EVM locally,
    executes all transactions and smart contracts, and saves the final state locally.
    It is the EVM that writes code (smart contracts) and data to blockchain and executes
    instructions (opcodes) of transaction code and smart contract code written in
    a Turing-complete language. That is to say, EVM serves as a runtime environment
    (RTE) for Ethereum smart contracts and ensures secured execution of the code.
    Obviously, when the code or transactions are validated through their respective
    digital signatures, they are executed on EVM. So, only after successful execution
    of instructions through EVM, the Ethereum state can change.Unless one connects
    the EVM with the rest of the network to participate in the P2P network, it can
    be isolated from the main network. In an isolated and sandboxed environment, EVM
    could be used to test smart contracts. It facilitates in building better, robust,
    and production ready-smart contracts.To build a better understanding of how smart
    contracts work leveraging the EVM, we should understand how data is organized,
    stored, and manipulated in any EVM language such as Solidity, Serpent, and ones
    that might come in future. You might want to consider EVM more like a database
    engine. Though we will not get deeper into the Solidity programming fundamentals,
    we will see how it interacts with the EVM in this section. Take a look at Figure
    [4-11](#Fig11).![A440588_1_En_4_Fig11_HTML.jpg](Images/A440588_1_En_4_Fig11_HTML.jpg)Figure
    4-11Smart contract deployment and usageLet us now understand memory management
    with EVM. Take a look at the following three strategies that the EVM follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，以太坊网络中的每个参与节点都在本地运行 EVM，执行所有交易和智能合约，并在本地保存最终状态。EVM 将代码（智能合约）和数据写入区块链，并执行交易代码和用图灵完备语言编写的智能合约代码的指令（操作码）。也就是说，EVM
    为以太坊智能合约提供了一个运行时环境（RTE），并确保了代码的安全执行。显然，当通过它们各自的数字签名验证代码或交易时，它们将在 EVM 上执行。因此，只有在
    EVM 上成功执行指令后，以太坊状态才能更改。除非将 EVM 与其他网络连接以参与 P2P 网络，否则它可能会与主网络隔离。在一个隔离的沙盒环境中，EVM
    可用于测试智能合约。它有助于构建更好的、健壮的、生产准备就绪的智能合约。为了更好地理解智能合约如何利用 EVM 工作，我们应该了解如何在任何 EVM 语言（如
    Solidity、Serpent 和未来可能出现的一些语言）中组织、存储和操作数据。您可能希望将 EVM 视为一种数据库引擎。尽管我们不会深入探讨 Solidity
    编程的基本原理，但我们将在此部分中了解它如何与 EVM 交互。请参阅图 [4-11](#Fig11)。![A440588_1_En_4_Fig11_HTML.jpg](Images/A440588_1_En_4_Fig11_HTML.jpg)图
    4-11 智能合约的部署和使用现在让我们了解 EVM 中的内存管理。请查看 EVM 遵循以下三种策略：
- en: Storage (persistent)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储（持久性）
- en: Key-value storage mapping (i.e., 256- bit to 256-bit word mapping). This means
    both keys and values are 256 bits (i.e., 32 bytes).
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储映射（即 256 位到 256 位单词映射）。这意味着键和值都是 256 位（即 32 字节）。
- en: From within a contract, it is not possible to enumarate storage.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从合约内部，无法枚举存储。
- en: At any given point in time, the state of the contract can be determined by the
    contract level variables called “state variables” that are always in “storage,”
    and it cannot be updated at runtime. This means that the structure of the storage
    is set only once during the contract creation and cannot be altered. However,
    their content can be changed with “sendTransaction” calls.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意时刻，合同的状态可以由称为“状态变量”的合同级变量确定，这些变量始终在“存储”中，且不能在运行时更新。这意味着存储的结构仅在合同创建时设置一次，并且不能更改。然而，它们的内容可以通过“sendTransaction”调用进行更改。
- en: Read/update of storage is an expensive affair.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的读/更新是一项昂贵的操作。
- en: Contracts cannot read, write, or update to any other storage that is not owned
    by them.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约无法读取、写入或更新不属于它们的任何其他存储。
- en: 'SSTORE/SLOAD are the frequently used instructions. Example: SSTORE instruction
    pops the top two items off the stack, considers the first item as the index, and
    inserts the second item into the contract’s storage at that index location.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSTORE/SLOAD 是常用的指令。示例：SSTORE 指令从栈中弹出两个项目，将第一个项目视为索引，并将第二个项目插入到合同的存储中该索引位置。
- en: Memory (volatile)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存（易失性）
- en: It is similar to RAM requirement in a general computer system for any code or
    application execution and used to store temporary values.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它类似于通用计算机系统中任何代码或应用程序执行的RAM要求，用于存储临时值。
- en: A contract can use any amount of memory during execution by paying for it, and
    that memory space is cleaned up after execution completes. The outputs during
    execution could be pushed to the persistent storage that can be reused in future
    executions.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约在执行过程中可以使用任意数量的内存，通过付费来实现，执行完成后，该内存空间会被清理。执行期间的输出可以推送到可以用于未来执行的持久存储中。
- en: Memory is actually a byte-array that is contiguous, unlike storage. It is allocated
    in 256-bit (32 bytes) chunks.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存实际上是一个连续的字节数组，与存储不同。它以256位（32字节）的块分配。
- en: Starts with no space and takes on space in the units of 32-byte chunks.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以没有空格开始，以32字节块为单位占用空间。
- en: Without the “memory” keyword, smart contract languages such as Solidity are
    expected to declare variables in storage for persistence.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有“memory”关键字，智能合约语言（如Solidity）预期要在存储中声明变量以持久化。
- en: Memory cannot be used at the smart contract level; it can only be used in methods.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在智能合约层面不能使用内存；它只能在方法中使用。
- en: Function arguments are almost always in memory.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数几乎总是存储在内存中。
- en: MSTORE/MLOAD are the frequently used instructions.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSTORE/MLOAD是频繁使用的指令。
- en: Stack
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: EVM is stack based, hence follows LIFO (Last-in, First-Out), where stack is
    used to perform computations.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EVM是基于栈的，因此遵循后进先出（Last-in, First-Out）的原则，栈用于执行计算。
- en: Stack entries are also 256-bit words used to mimic 256-bit pseudo registers.
    They are used to hold local variables of “value” type and to pass parameters to
    instructions or functions, memory operations, and other algorithmic operations.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈条目也是256位单词，用于模仿256位的伪寄存器。它们用于持有“值”类型的局部变量，并将参数传递给指令或函数、内存操作和其他算法操作。
- en: Allows a maximum of 1024 element and is almost free to use.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许最多有1024个元素，并且几乎免费使用。
- en: Most of the stack operations are limited to top of the stacks. The execution
    is pretty similar to the way Bitcoin script was executed.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈操作的大部分限制在栈顶。执行方式与比特币脚本的执行方式相当相似。
- en: 'When EVM is running and the byte code is injected with a transaction for execution,
    its full computational state can be defined by the following tuple: [block_state,
    transaction, message, code, memory, stack, pc, gas].You must be able to make out
    all these fields now. They have the three kinds of memory we discussed (the block_state
    field represents the global state and is for storage). The PC field is like a
    pointer for an instruction in the stack to be executed.In Ethereum, an Application
    Binary Interface (ABI) is an abstraction that is not part of the [core Ethereum
    protocol](https://github.com/ethereum/yellowpaper), but is used to access the
    byte code in a smart contract as standard practice. Though it is possible for
    anyone to define their own ABI for their contracts and comply with it to get the
    desired output, it is easier to use Solidity. The purpose of ABI is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当EVM正在运行，并且通过交易注入字节码以执行时，其完整的计算状态可以由以下元组定义：[区块状态，交易，消息，代码，内存，栈，pc，gas]。你现在必须能够识别出所有这些字段。它们是我们讨论过的三种内存（区块状态字段代表全局状态，用于存储）。PC字段类似于要执行的栈中指令的指针。在以太坊中，应用程序二进制接口（ABI）是一种抽象，不是[核心以太坊协议](https://github.com/ethereum/yellowpaper)的一部分，但用作访问智能合约中的字节码的标准做法。虽然任何人都可以为他们的合约定义自己的ABI并遵守它以获得所需的输出，但使用Solidity更容易。ABI的目的如下：
- en: How and what functions inside smart contracts should be called
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在智能合约内部调用哪些函数以及如何调用
- en: The Binary format in which information should be passed to smart contract functions
    as inputs
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该以二进制格式传递给智能合约函数作为输入的信息
- en: The Binary format in which you expect the output of function execution after
    calling that function
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用该函数后，期望的函数执行输出二进制格式
- en: With ABI specifications, it is easy (though may not be necessary) for two programs
    written in two different languages to interact with each other.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有了ABI规范，两种用不同语言编写的程序之间交互起来很容易（尽管可能不必要）。
- en: Ethereum Ecosystem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊生态系统
- en: 'We learned the core components to understand how Ethereum really works. There
    are some inherent limitations to Ethereum such as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了理解以太坊如何真正工作的核心组件。以太坊有一些固有的限制，如下所示：
- en: The EVM is slow; it is not advisible to be used for large computations.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EVM很慢；不建议用于大型计算。
- en: Computation and storage on the blockchain is expensive; it is advisible to use
    offchain computations and use IPFS/Swarm for storage.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链上的计算和存储是昂贵的；建议使用离链计算，并使用 IPFS/Swarm 进行存储。
- en: Scalability is an issue; there are different techniques to address it, but they
    are subjective to the business case you are dealing with.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性是一个问题；有多种技术可以解决它，但它们取决于你正在处理的商业案例。
- en: Private blockchains are more likely to flourish.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有区块链更有可能蓬勃发展。
- en: Now let us take a look at the Ethereum tech stack to understand at a high-level
    the Ethereum ecosystem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看以太坊技术堆栈，以高级别了解以太坊生态系统。
- en: Swarm
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swarm
- en: It is not only a distributed storage platform of static files in a P2P fashion,
    but also a distribution service. Swarm ensures adequate decentralization and redundant
    storage of Ethereum’s blockchain data, DApp code, etc. Unlike WWW, the uploads
    to Swarm are not centralized to one web server. It is designed to have zero downtime
    and is DDOS resistant and fault tolerant.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅是分布式存储平台，以 P2P 方式存储静态文件，而且还是分发服务。Swarm 确保了以太坊区块链数据、DApp 代码等的充分去中心化和冗余存储。与
    WWW 不同，Swarm 上的上传不是集中到一个 web 服务器。它旨在实现零停机时间，并且具有 DDoS 抵抗和容错性。
- en: Whisper
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Whisper
- en: It is a communications protocol that allows DApps to communicate with each other.
    It provides a distributed yet private messaging functionality. It supports singlecast,
    multicast, and broadcast of messages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个允许 DApps 相互通信的通信协议。它提供了分布式但私有的消息功能。它支持单播、多播和广播消息。
- en: DApp
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DApp
- en: A DApp usually has two components, a front-end and a back-end component. The
    back-end code runs on the actual blockchain coded up in smart contracts. The front-end
    code and user interfaces could be written in any language such as HTML, CSS, and
    JavaScript, as long as it can make calls to its back end. Also, the front end
    can be hosted in a decentralized storage like SWARM or IPFS instead of a centralized
    web server.User interface components will be cached on some kind of decentralized
    BitTorrent-like cloud and pulled in by the ÐApp Browser as needed. Like any App
    store, it is possible to browse the distributed DApps catalog in the browser.
    The end user can install any DApp of interest in their browser.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: DApp 通常有两个组件，前端和后端组件。后端代码在实际的区块链上运行，由智能合约编写。前端代码和用户界面可以用任何语言编写，比如 HTML、CSS 和
    JavaScript，只要它能调用其后端。另外，前端可以托管在去中心化存储上，如 SWARM 或 IPFS，而不是中心化的 web 服务器。用户界面组件将缓存在某种去中心化的
    BitTorrent 类似云上，并根据需要由 ÐApp 浏览器拉取。就像任何应用商店一样，用户可以在浏览器中浏览分布式 DApp 目录。最终用户可以在他们的浏览器中安装任何感兴趣的
    DApp。
- en: Development Components
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发组件
- en: There are so many development components used to develop decentralized applications
    on Ethereum and interact with them. Following are a few popular ones, but there
    are many more such for you to explore. We will just take a look at what they are
    and dive deeper into these topics in the following chapters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开发组件用于在以太坊上开发去中心化应用程序并与之交互。以下是一些流行组件，但还有更多供您探索。我们只需了解它们是什么，并在接下来的章节中深入探讨这些主题。
- en: Web3.js
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web3.js
- en: This is a very important element in developing DApps.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开发 DApp 的重要元素。
- en: Truffle
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Truffle
- en: Truffle provides the building blocks to create, compile, deploy, and test blockchain
    applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 提供了创建、编译、部署和测试区块链应用程序的构建块。
- en: Mist Wallet
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mist 钱包
- en: We learned in the previous chapters that a wallet is required to interact with
    blockchain applications and the same applies to Ethereum as well. To store, accept,
    and send Ether, the users need a wallet. Mist Wallet is a UI-based solution that
    can be used to connect to the Ethereum blockchain. Using Mist wallet, one can
    create accounts, design and deploy contracts, transfer Ether across accounts,
    and view transaction details.Internally, Mist is dependent on the “geth” client
    (i.e., GoEthereum Client) to perform all the operations seamlessly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中了解到，与区块链应用程序交互需要一个钱包，这对于以太坊也适用。为了存储、接收和发送以太币，用户需要一个钱包。Mist 钱包是一个基于
    UI 的解决方案，可以用来连接以太坊区块链。使用 Mist 钱包，可以创建账户、设计和部署合约、跨账户传输以太币，以及查看交易详情。内部依赖“geth”客户端（即
    GoEthereum 客户端）来无缝执行所有操作。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the core components of Ethereum blockchain and understood
    the design considerations. We were able to differentiate Ethereum design with
    that of the Bitcoin blockchain and understood how Ethereum blockchain facilitates
    development of different use cases on a single platform. We took a deep dive into
    the smart contracts and how the Ethereum Virtual Machine (EVM) executes it in
    a decentralized fashion.We will explore more into the development aspect of blockchain
    in general in Chapter [5](A440588_1_En_5_Chapter.xhtml) and then build a solid
    understanding of Ethereum development in Chapter [6](A440588_1_En_6_Chapter.xhtml).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以太坊区块链的核心组件，并了解了设计考量。我们能够区分以太坊设计与比特币区块链的不同，并理解了以太坊区块链如何在一个平台上促进不同用例的开发。我们深入探讨了智能合约以及以太坊虚拟机（EVM）如何以去中心化方式执行它。我们将在第[5](A440588_1_En_5_Chapter.xhtml)章中更深入地探讨区块链的一般开发方面，然后在第[6](A440588_1_En_6_Chapter.xhtml)章中建立对以太坊开发的坚实基础。
- en: References
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Ethereum White Paper[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)
    .Ethereum Yellow Paper[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)
    .How Ethereum Works[https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369](https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369)
    .Patricia Tree[https://dl.acm.org/citation.cfm?id=321481](https://dl.acm.org/citation.cfm?id=321481)
    .Merkling in Ethereum[https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/).Gas
    and Transactions in Ethereum[http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html](http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html)
    .Technical Introduction to Events and Logs in Ethereum[https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)
    .Ethereum Internals[https://github.com/comaeio/porosity/wiki/Ethereum-Internals](https://github.com/comaeio/porosity/wiki/Ethereum-Internals)
    .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊白皮书[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)。以太坊黄皮书[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)。以太坊是如何工作的[https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369](https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369)。Patricia树[https://dl.acm.org/citation.cfm?id=321481](https://dl.acm.org/citation.cfm?id=321481)。以太坊中的Merkle证明[https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)。以太坊中的燃料和交易[http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html](http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html)。以太坊事件和日志的技术简介[https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)。以太坊内部[https://github.com/comaeio/porosity/wiki/Ethereum-Internals](https://github.com/comaeio/porosity/wiki/Ethereum-Internals)。
