["```\npragma solidity ^0.4.22;\n\ncontract SimpleVoting {\n\n    struct Voter {\n        bool isRegistered;\n        bool hasVoted;  \n        uint votedProposalId;   \n    }\n\n    struct Proposal {\n        string description;   \n        uint voteCount; \n    }\n\n    enum WorkflowStatus {\n        RegisteringVoters, \n        ProposalsRegistrationStarted,\n        ProposalsRegistrationEnded,\n        VotingSessionStarted,\n        VotingSessionEnded,\n        VotesTallied\n    }\n\n    WorkflowStatus public workflowStatus;\n    address public administrator;\n    mapping(address => Voter) public voters;\n    Proposal[] public proposals;\n    uint private winningProposalId;\n\n    modifier onlyAdministrator() {\n       require(msg.sender == administrator, \n\n       \"the caller of this function must be the administrator\");\n       _;\n    }\n\n    modifier onlyRegisteredVoter() {\n        require(voters[msg.sender].isRegistered, \n           \"the caller of this function must be a registered voter\");\n       _;\n    }\n\n    modifier onlyDuringVotersRegistration() {\n        require(workflowStatus == WorkflowStatus.RegisteringVoters, \n           \"this function can be called only before proposals registration\n has started\");\n       _;\n    }\n\n    modifier onlyDuringProposalsRegistration() {\n        require(workflowStatus == \n            WorkflowStatus.ProposalsRegistrationStarted, \n           \"this function can be called only during proposals\n registration\");\n       _;\n    }\n\n    modifier onlyAfterProposalsRegistration() {\n        require(workflowStatus == WorkflowStatus.ProposalsRegistrationEnded, \n           \"this function can be called only after proposals registration\n has ended\");\n       _;\n    }\n\n    modifier onlyDuringVotingSession() {\n        require(workflowStatus == WorkflowStatus.VotingSessionStarted, \n           \"this function can be called only during the voting session\");\n       _;\n    }\n\n    modifier onlyAfterVotingSession() {\n        require(workflowStatus == WorkflowStatus.VotingSessionEnded,  \n           \"this function can be called only after the voting session\n has ended\");\n       _;\n    }\n\n    modifier onlyAfterVotesTallied() {\n        require(workflowStatus == WorkflowStatus.VotesTallied,  \n           \"this function can be called only after votes have been\n tallied\");\n       _;\n    }\n\n     event VoterRegisteredEvent (\n            address voterAddress\n     ); \n\n     event ProposalsRegistrationStartedEvent ();\n\n     event ProposalsRegistrationEndedEvent ();\n\n     event ProposalRegisteredEvent( \n         uint proposalId\n     );\n\n     event VotingSessionStartedEvent ();\n\n     event VotingSessionEndedEvent ();\n\n     event VotedEvent (\n         address voter,\n         uint proposalId\n     );\n\n     event VotesTalliedEvent ();\n\n     event WorkflowStatusChangeEvent (\n        WorkflowStatus previousStatus,\n        WorkflowStatus newStatus\n    );\n\n    constructor() public {\n        administrator = msg.sender;\n        workflowStatus = WorkflowStatus.RegisteringVoters;\n    }\n\n    function registerVoter(address _voterAddress) \n        public onlyAdministrator onlyDuringVotersRegistration {\n\n        require(!voters[_voterAddress].isRegistered, \n           \"the voter is already registered\");\n\n        voters[_voterAddress].isRegistered = true;\n        voters[_voterAddress].hasVoted = false;\n        voters[_voterAddress].votedProposalId = 0;\n\n        emit VoterRegisteredEvent(_voterAddress);\n    }\n\n    function startProposalsRegistration() \n        public onlyAdministrator onlyDuringVotersRegistration {\n        workflowStatus = WorkflowStatus.ProposalsRegistrationStarted;\n\n        emit ProposalsRegistrationStartedEvent();\n        emit WorkflowStatusChangeEvent(\n            WorkflowStatus.RegisteringVoters, workflowStatus);\n    }\n\n    function endProposalsRegistration() \n        public onlyAdministrator onlyDuringProposalsRegistration {\n        workflowStatus = WorkflowStatus.ProposalsRegistrationEnded;\n\n        emit ProposalsRegistrationEndedEvent();\n        emit WorkflowStatusChangeEvent(\n            WorkflowStatus.ProposalsRegistrationStarted, workflowStatus);\n    }\n\n    function registerProposal(string proposalDescription) \n        public onlyRegisteredVoter onlyDuringProposalsRegistration {\n        proposals.push(Proposal({\n            description: proposalDescription,\n            voteCount: 0\n        }));\n\n        emit ProposalRegisteredEvent(proposals.length - 1);\n    }\n\n     function getProposalsNumber() public view\n         returns (uint) {\n         return proposals.length;\n     }\n\n     function getProposalDescription(uint index) public view \n         returns (string) {\n         return proposals[index].description;\n     }    \n\n    function startVotingSession() \n        public onlyAdministrator onlyAfterProposalsRegistration {\n        workflowStatus = WorkflowStatus.VotingSessionStarted;\n\n        emit VotingSessionStartedEvent();\n        emit WorkflowStatusChangeEvent(\n            WorkflowStatus.ProposalsRegistrationEnded, workflowStatus);\n    }\n\n    function endVotingSession() \n        public onlyAdministrator onlyDuringVotingSession {\n        workflowStatus = WorkflowStatus.VotingSessionEnded;\n\n        emit VotingSessionEndedEvent();\n        emit WorkflowStatusChangeEvent(\n            WorkflowStatus.VotingSessionStarted, workflowStatus);        \n    }\n    function vote(uint proposalId) \n        onlyRegisteredVoter \n        onlyDuringVotingSession public {\n        require(!voters[msg.sender].hasVoted, \n            \"the caller has already voted\");\n\n        voters[msg.sender].hasVoted = true;\n        voters[msg.sender].votedProposalId = proposalId;\n\n        proposals[proposalId].voteCount += 1;\n\n        emit VotedEvent(msg.sender, proposalId);\n    }\n\n    function tallyVotes() onlyAdministrator onlyAfterVotingSession public {\n        uint winningVoteCount = 0;\n        uint winningProposalIndex = 0;\n\n        for (uint i = 0; i < proposals.length; i++) {\n            if (proposals[i].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[i].voteCount;\n                winningProposalIndex = i;\n            }\n        }\n\n        winningProposalId = winningProposalIndex;\n        workflowStatus = WorkflowStatus.VotesTallied;\n\n        emit VotesTalliedEvent();\n        emit WorkflowStatusChangeEvent(\n            WorkflowStatus.VotingSessionEnded, workflowStatus);     \n    }\n\n    function getWinningProposalId() onlyAfterVotesTallied public view\n       returns (uint) {\n        return winningProposalId;\n    }\n\n    function getWinningProposalDescription() \n       onlyAfterVotesTallied public view\n       returns (string) {\n        return proposals[winningProposalId].description;\n    }  \n\n    function getWinningProposaVoteCounts() onlyAfterVotesTallied public view\n       returns (uint) {\n        return proposals[winningProposalId].voteCount;\n    }   \n\n    function isRegisteredVoter(address _voterAddress) public view\n        returns (bool) {\n        return voters[_voterAddress].isRegistered;\n     }\n\n     function isAdministrator(address _address) public view \n         returns (bool) {\n         return _address == administrator;\n     }     \n\n     function getWorkflowStatus() public view\n         returns (WorkflowStatus) {\n         return workflowStatus;       \n     }\n}\n```"]