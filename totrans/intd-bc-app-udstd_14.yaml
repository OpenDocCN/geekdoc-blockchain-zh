- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_14](https://doi.org/10.1007/978-1-4842-7480-4_14)
  prefs: []
  type: TYPE_NORMAL
- en: 14. Using a MATLAB Smart Farm Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: This project illustrates how to effectively control mutual exclusive access
    to a shared resource. To implement exclusivity in this manner, the project is
    created in MATLAB using the Simulink framework. The name of the project is *Smart
    Farm*. In this project, a fleet of autonomous robots performs a series of farming
    tasks, including preparing the soil, watering the plants, and producing the harvested
    plants.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Description of the Smart Farm Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project addresses a case study of distributed, mutual exclusive access to
    a shared resource. The context is a *smart farm*, where a fleet of autonomous
    robots prepares the soil, waters the plants, harvests plant production, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Each robot moves cyclically between the fields and the main farm buildings and
    stores. The geography of the farm is such that there are two main production fields
    (named North and South), reachable from the main farm premises by a rural road
    that passes over a small bridge on a river (see Figure [14-1](#Fig1)). Only one
    robot at a time can use the bridge, which means that robots need to negotiate
    exclusive access to the bridge by means of V2V communication, with no centralized
    control center.![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig1_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-1
  prefs: []
  type: TYPE_NORMAL
- en: Bridge on a river
  prefs: []
  type: TYPE_NORMAL
- en: Each robot can be seen as cycling through different modes of operation, represented
    in Figure [14-2](#Fig2). When a robot needs to move to a field or to the farm
    building, it enters Ask4Bridge mode, in which it asks for access to the bridge,
    communicating this request to the other robots, which are in the Ask4Bridge or
    Bridge modes.
  prefs: []
  type: TYPE_NORMAL
- en: The main objective of the project is to define the distributed communication
    protocol that allows exclusive access to the bridge, in order to avoid collisions
    over the bridge.![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig2_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-2
  prefs: []
  type: TYPE_NORMAL
- en: Modes of operation
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Project Requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The system must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Requirement 1*: The system is composed of a non-predetermined number of identical
    robots communicating with each other via a wireless connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement 2*: Each robot follows the cyclic modes of operation behavior
    described in Figure [14-2](#Fig2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement 3*: No two robots can access the bridge at the same time (mutual
    exclusion, safety).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement* 4: A robot that is not granted bridge access waits until the
    bridge is cleared, and only then issues a new access request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement* 5: If a robot issues a bridge access request, sooner or later,
    it is granted access (*liveness*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement 6:* If access to the bridge is granted to a robot coming from
    the North field, and there are at least two other robots R1 and R2 coming—R1 also
    from the North, and R2 from the farm or from South—then the next access cannot
    be granted to R1, coming again from North. The same applies to the symmetrical
    cases of a robot crossing the bridge from South or from the farm (*fairness*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement 7*: The system is based on a totally distributed algorithm, without
    any element of centralization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requirement 8*: The robots do not refer to a common clock, but each clock
    is autonomous and not synchronized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1.2 Solution Hints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The robots can be seen as nodes of a distributed system, which will be modeled
    using the given specification formalism. Typically each node will be modeled as
    an *extended finite state machine* of some form, and the nodes will exchange data
    using the mechanisms offered by the formalism to let different state machines
    communicate.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes (robots) are identified with a number, and their identifier can be
    used to send point-to-point communications when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: As a suggestion, you can organize the solution based on a 2PC (two-phase commit
    protocol) algorithm (standard or linear), in which you need to define a coordinator,
    sending its proposal to the others.
  prefs: []
  type: TYPE_NORMAL
- en: A robot R1 asking for access to the bridge is acting as the coordinator at each
    run. Hence, it broadcasts the access request to the other robots. A robot receiving
    this request from R1, when working in any mode other than Ask4Bridge or Bridge,
    simply replies agree. A robot in Bridge mode will reply instead with abort, since
    it currently occupies the bridge. A robot R2 receiving this request from R1, when
    in mode Ask4Bridge*,* replies abort if its identifier is lower than that of R1;
    otherwise, it replies agree*.* But in this case, R2 has also to abort the algorithm
    run that it had launched when it entered Ask4Bridge mode  .
  prefs: []
  type: TYPE_NORMAL
- en: A robot leaving the Bridge mode broadcasts the information that the bridge is
    free to the other nodes, so that the ones in Ask4Bridge mode can retry their requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a node should be able to start its own 2PC run *and* listening to
    messages incoming from other robots engaged in other 2PC (two-phase commit protocol)
    runs at the same time. This requires the use of some concurrent threads, or *statechart*
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, you should focus on the 2PC scheme by considering a fixed
    set of three or four robots and accurately studying their interactions, ignoring
    the liveness and fairness requirements and considering only three operating modes
    *(*Ask4Bridge, Field Action, and Bridge).
  prefs: []
  type: TYPE_NORMAL
- en: In the second phase, you extend the model to consider the other operating modes,
    possibly a larger number of robots and/or the liveness/fairness requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in general, the tools (in order to be able to simulate or formally
    verify the model) need to instantiate a fixed number of objects (nodes) by physically
    copying and pasting.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Implementing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project is designed with three robots that move cyclically between the fields
    and the main agricultural buildings and stores. The geography of the farm is such
    that there are two main production fields (named North and South). The movements
    of robots satisfy the three basic requirements of concurrency control in distributed
    system using mutual exclusion, as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, the system is based on a totally distributed algorithm,
    without any element of centralization. The robots do not refer to a common clock,
    but each clock is autonomous and not synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is implemented in MATLAB and the robots are designed with the help
    of the Simulink tool. The following MATLAB dependencies are needed for implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robotics System Toolbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation Toolbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section covers the built-in features that are available in Simulink
    and used in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 Environment Models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The built-in Robotics Visualizer in MATLAB enables you to simulate and prototype
    algorithms in a 2D mobile robotics environment. The multi-robot ecosystem also
    enables for the development and prototype of algorithms in a 2D multi-robot mobile
    robotic environment. These functions are accessible through the MATLAB and Simulink
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.2 Sensor Models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, the Lidar Sensor simulates 2D line-of-sight sensors  for visualization
    and algorithm prototyping. This feature is available in MATLAB and the Simulink
    interface (see Figure [14-3](#Fig3)).![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig3_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-3
  prefs: []
  type: TYPE_NORMAL
- en: The sensor
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.3 Multi-Robot Lidar Sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the features listed previously, the Multi-Robot Lidar Sensor  was
    utilized to mimic two-dimensional line-of-sight detectors for the multi-robot
    environment. This sensor will test for a line-of sight for an occupancy map as
    well as other for robots using a finite radius in the environment. This feature
    is available in the MATLAB and Simulink interface.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 The System Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project implements the two-phase commit protocol technology for the movement
    of the robots.
  prefs: []
  type: TYPE_NORMAL
- en: Only one process can run the crucial section (CS) at a time under the system
    architecture. Mutual exclusions cannot be implemented in a distributed network
    using shared variables or a local kernel. The only way to create distributed mutual
    exclusion is using message forwarding. Unforeseen communication latency and partial
    information of the system status are dealt with via distributed system algorithms
    (see Figure [14-4](#Fig4)).![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig4_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-4
  prefs: []
  type: TYPE_NORMAL
- en: Multi-sensor
  prefs: []
  type: TYPE_NORMAL
- en: To avoid collisions between the robots that are crossing the bridge, the architecture
    is designed in a such a way that, when a robot needs to move to a field or to
    the farm building, it enters the Ask4Bridge mode  . There, it asks for access
    to the bridge, communicating this request to the robots that are in Ask4Bridge
    mode. The distributed communication protocol (two-phase commit protocol) allows
    exclusive access, to avoid collisions over the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is defined as a set of actions in the aforementioned architecture.
    Depending on the application criteria, each transaction is given a deadline. The
    operations are considered to be firm and genuine and have the same severity level.
    A transaction with a past-due date will be canceled right away.
  prefs: []
  type: TYPE_NORMAL
- en: When a transaction is ready to “commit,” the two-phase commit protocol kicks
    in. A solitary coordinating machine initiates it (in this case, Robot 1). Robots
    2 and 3 are the other players, and they will wait for orders from the supervisor
    (Robot 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique ensures that transactions are atomic: either the whole transaction
    is reflected in the system’s final state, or none of this is. The transaction
    will be terminated if even a single individual is unable to submit. To put it
    another way, each employee has “veto” power over a transaction. The two-phase
    commit protocol’s fundamental flow is depicted in Figure [14-5](#Fig5).![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig5_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig5_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-5
  prefs: []
  type: TYPE_NORMAL
- en: System architecture of the smart farm
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 System Modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the modeling is done with the help of MATLAB. Using the Simulink tool, I
    have developed a State flow model for the movement of the robots. To move the
    robots, the program uses the Robotics System Toolbox and the Navigation Toolbox.
    (To perform this task, note that the free plug-in is available in MATLAB.)
  prefs: []
  type: TYPE_NORMAL
- en: 14.4.1 Robot Visualizer and Lidar Sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Robot Visualizer  is used to develop the robot architecture. Additionally,
    using the Lidar Sensor for each robot, the movement of the robots can be verified.
    The Lidar Sensor may also mimic two-dimensional line-of-sight sensors, as shown
    in Figure [14-6](#Fig6).![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig6_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-6
  prefs: []
  type: TYPE_NORMAL
- en: Two-phase commit protocol(2PC)
  prefs: []
  type: TYPE_NORMAL
- en: 14.4.2 Obstacle Avoidance Logic and *2* PC Protocol Concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent robots from colliding while moving from one state to another, the
    project uses the 2PC protocol concept  for transition. To implement this concept,
    the project includes a different mode of movement for robots (based on vote).
    If one robot wants to move to a different state, it asks for Ask4Bridge mode  .
    Then the coordinator determines whether any other robots have requested the same
    mode. If not, it allows further movement. To prevent robots from colliding while
    they’re moving, the project also uses obstacle avoidance logic, which is available
    in MATLAB.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4.3 Architecture of North and South Farm and Storehouse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a feature in MATLAB called the *multi-robot environment* that’s used
    to construct different fields, such as the North and South Farm and the Store.
    In this platform, you could build “n” number of robots and track their movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a built-in feature that’s available in the Navigation Toolbox plugin
    in MATLAB. The MATLAB definition of the multi-robot environment is as follows:
    “The Multi-Robot Environment enables you to simulate and prototype algorithms
    in a two-dimensional multi-robot mobile robotics situation.” (See Figure [14-7](#Fig7).)![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig7_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig7_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-7
  prefs: []
  type: TYPE_NORMAL
- en: Robot Visualizer and Lidar Sensor
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 Implementing the Two-Phase Commit Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a transaction is ready to “commit,” the 2PC protocol kicks in. A single
    supervisor system initiates it (Robot 1, in the initial stage).
  prefs: []
  type: TYPE_NORMAL
- en: The 2PC protocol has two phases, as shown here (assume in the initial stage,
    that Robot 1 is the coordinator and Robots 2 and 3 are participants).
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1:** The supervisor, Robot 1, asks each individual if they have finished
    their tasks for the transaction and are prepared to commit. Each member gives
    a yes or no answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2:** All of the answers are counted by the organizer. If all of the
    workers said yes, the transaction will be completed. It will abort if this does
    not happen. The supervisor sends a message to each employee with the final commits
    choice and gets a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This technique assures that actions are atomic: either the whole action is
    reflected in the system’s final state, or none of this is. If even a single party
    is unable to commit, the transaction will be canceled. To put it another way,
    each party has *veto power* over a transaction.![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig8_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig8_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-8
  prefs: []
  type: TYPE_NORMAL
- en: Obstacle avoidance logic
  prefs: []
  type: TYPE_NORMAL
- en: It also assures the long-term viability of transactions. Before answering “yes”
    in Step 1, each party double-checks that all of a transaction’s writes have been
    durably written to storage. This allows the supervisor to make a final decision
    regarding a transaction without being concerned about a participant’s failure
    if they voted “yes” (see Figure [14-8](#Fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.1 Requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This project satisfies three basic requirements of concurrency control in distributed
    systems when using mutual exclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutual exclusion and safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fairness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enabling several processes to access a common resource or data source is done
    in a mutually exclusive way:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no common variables in a distributed system that may be utilized to
    construct mutual exclusion and synchronization primitives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only way to share information is through data transfer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This three basic requirements are met as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutual exclusion, safety:** Only one process can run the crucial portion
    at any given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liveness:** (There is no deadlock or hunger.) Two or more parties should
    not have to wait indefinitely for communications that will never arrive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fairness:** Every process is given an equal opportunity to complete the key
    portion. In principle, fairness implies that crucial section execution requests
    are carried out in the sequence in which they arrive in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to from the previous requirements, we have also implemented the
    following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The system is composed of a non-predetermined number of identical robots communicating
    with each other via a wireless connection with the help of a Lidar Sensor and
    obstacle avoidance logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each robot follows the cyclic modes of operation behavior with the help of the
    Robot Visualizer tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A robot that is not granted bridge access waits until the bridge is cleared,
    and only then issues a new access request, with the help of 2PC protocol concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is based on a totally distributed algorithm, without any element
    of centralization, with the help of the 2PC protocol concept.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.2 Problems Encountered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While implementing this project, the following problems appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a lack of scalability due to the hindering characteristics of the two-phase
    commit protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two-phase commit protocol’s biggest issue is that it is a hindering protocol.
    Some parties cannot complete their operations if the supervisor fails permanently.
    It will stall until a commit or rollback is received after a player has submitted
    an agreement message to the supervisor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once a participant has acknowledged that it is ready to commit, it must be able
    to commit the transaction afterward, even if it crashed in between. This requires
    checkpointing to persistence storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The very worst situation occurs when the supervisor is also a participant and
    votes on the protocol’s conclusion. Then perhaps a crash to the supervisor wipes
    out both it and a member, ensuring that the protocol will stay blocked, despite
    the fact that only one loss occurred. 2PC is still a common consensus protocol
    due to its low communication complexity. However, in the event of a failure, the
    difficulty can rise to O if every node volunteers to be the recovery node O(n2)O(n2)O(n2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless  , the fact that 2PC might block due to a supervisor failing is
    a serious issue that severely reduces availability. If a transaction may be turned
    back at any moment, the protocol can recover as nodes time out, but if commit
    choices must be treated as permanent, a single failure can bring the entire system
    to a halt. Furthermore, a three-phase commit protocol has been developed that
    eliminates the blocking issues of 2PC at the cost of an additional message delay
    (see Figure [14-9](#Fig9)).![../images/520777_1_En_14_Chapter/520777_1_En_14_Fig9_HTML.jpg](../images/520777_1_En_14_Chapter/520777_1_En_14_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-9
  prefs: []
  type: TYPE_NORMAL
- en: Model architecture of the north and south farm and storehouse
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In distributed computer systems, the committing protocols provide global atomicity.
    This ensures that transactions across a computer network do not end up on all
    nodes in the network, or on none at all if all nodes fail.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed computing is a method of collaborating on a project using networked,
    standalone computers. A central computer splits the task and delivers it to the
    client computer to finish, according to this paradigm. This approach can withstand
    single client failures, thanks to commit mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of the *two-phase commit protocol* is that if the coordinator fails,
    all client resources are potentially frozen indefinitely. A timeout transition
    is used in committed three-phase protocols to compensate for this shortcoming.
    A timeout transition allows resources to be released at a predetermined time if
    the coordinating computer fails.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve covered an essential protocol that may be utilized in the design of distributed
    systems in this chapter. With two phases—the commit request phase and the commit
    phase—two-phase commit methods assure atomicity. Computer coordination sends a
    request to every other client computer on the network during the commit request
    phase, then waits for a response message from each client. Step 2 is done if all
    messages are received; if there is a client error and not all messages are received,
    Step 1 is performed. All clients are notified of the disruption.
  prefs: []
  type: TYPE_NORMAL
- en: Using MATLAB this way is a perfect example of a distributed system. The robots’
    movement is designed with the help of MATLAB tools. Two-phase commit protocol
    was used for the transaction of messages in the distributed system. This project
    is a case study of distributed mutual exclusive access to a shared resource. The
    setting was a smart farm, where a fleet of autonomous robots conducts activities
    such as soil preparation, plant watering, harvesting plant production, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers an example of an advanced project with more features
    of a distributed system. The project is called *Platoon* .
  prefs: []
  type: TYPE_NORMAL
