- en: © Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_4
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 克里斯·丹南 2017克里斯·丹南《介绍以太坊和Solidity》10.1007/978-1-4842-2535-6_4
- en: 4. Solidity Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. Solidity编程
- en: Chris Dannen^(1 )(1)Brooklyn, New York, USASolidity is a new programming language
    used to write programs called smart contracts, which can be run by the EVM. This
    new language is a hodgepodge of conventions from networking, assembly language,
    and web developmentImagine you’re on a beach in another country. You took a trip
    here on a whim and breezed past the currency exchange booth in the airport, figuring
    you could use your credit or debit card while visiting—no need for cash. In your
    rush, you forgot to bring sunglasses. A vendor walking along the beach has a pair
    that happen to be your style. In fact, they’re better than the pairs you remember
    passing in the duty-free area of the airport. Alas, he doesn’t have a credit card
    reader—just his Android phone—and you don’t have any local currency. He gives
    you a little card with an e-mail address and a phone number, in case you’d like
    to buy the glasses later.Think about this scenario for a moment, and you’ll see
    the power of protocol-based digital currency. Why can you send this man a text
    message or an e-mail, or even call him on the phone, but you can’t send him money
    the same way?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 克里斯·丹南^(1 )(1)美国纽约布鲁克林Solidity是一种新的编程语言，用于编写称为智能合约的程序，可以由以太坊虚拟机（EVM）运行。这种新语言是来自网络、汇编语言和Web开发的传统的大杂烩。想象一下，你在另一个国家的海滩上。你一时冲动来到这里，并且在机场匆匆走过货币兑换柜台，想着在访问期间可以使用信用卡或借记卡——不需要现金。在你匆忙中，你忘记带太阳镜了。一个在海滩上走动的小贩有一副恰好是你的款式的太阳镜。事实上，它们比你记得在机场免税区经过的那几副还要好。不幸的是，他没有信用卡读卡器——只有他的安卓手机——而你也没有当地货币。他给了你一张小卡片，上面写着一个电子邮件地址和一个电话号码，以防你以后想买眼镜。稍微想想这种情况，你就会明白基于协议的数字货币的威力。为什么你可以给这个人发短信或电子邮件，甚至给他打电话，但你不能用同样的方式给他发钱？
- en: Primer
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'The preceding chapter described how the EVM transitions state, and in this
    chapter you’ll see what kind of instructions the EVM can process as it makes state
    transitions.In general, a computing environment is an infinite loop that repeatedly
    carries out whatever operation is current in the system’s program counter. (Jumping
    the queue in the program counter is where the JUMP opcodes derive their name.)
    The program counter iterates one by one until the end of that particular program
    is reached. The machine exits the execution loop only if it encounters (throws)
    an error, or hits an instruction designating the machine to STOP or RETURN a result
    or value.These operations have access to three types of space in which to store
    data:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章描述了 EVM 如何转换状态，在本章中，您将了解到 EVM 可以处理什么样的指令，以及它在进行状态转换时。总的来说，计算环境是一个无限循环，重复执行系统程序计数器中当前的操作。（在程序计数器中跳过队列是
    JUMP 操作码名称的由来。）程序计数器逐个迭代，直到达到特定程序的结尾。只有当遇到（抛出）错误，或者遇到指示机器停止或返回结果或值的指令时，机器才会退出执行循环。这些操作可以访问三种类型的空间来存储数据：
- en: The stack , a container in which values can be added or removed (pushed or popped).
    Stack values are defined within a method.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈，一个容器，可以添加或移除值（推入或弹出）。栈值在方法内定义。
- en: Dynamic memory , also known as the heap, an infinitely expandable byte array.
    This resets when the program finishes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存，也称为堆，是一个可以无限扩展的字节数组。当程序结束时，它会重置。
- en: A key/value store for account balances and, in the case of contract addresses,
    Solidity code.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个键/值存储用于账户余额，以及在合约地址的情况下，Solidity 代码。
- en: Solidity contracts can also access certain attributes about the incoming message,
    such as the value, sender, and data of the incoming message, as well as the data
    from the block header.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 合约也可以访问关于传入消息的某些属性，例如传入消息的价值、发送者和数据，以及区块头中的数据。
- en: Global Banking Made (Almost) Real
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球银行业变得（几乎）真实
- en: The banks of the world have computer systems that, while upgraded and mostly
    modern, are the descendants of machines that predate the Internet and certainly
    the World Wide Web. As a result, they’re architected to be silos. There is no
    single global banking network, but rather an interconnected mass of national systems
    and private banking software stacks, all with their own quirks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的银行都拥有计算机系统，尽管已经升级并且大部分是现代化的，但它们仍是互联网甚至万维网出现之前的机器的后代。因此，它们的架构被设计成是孤立的。没有单一的全球银行网络，而是一堆相互连接的国家系统和私人银行软件堆栈，每个都有自己的怪癖。
- en: Extra-Large Infrastructure
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外大型基础设施
- en: A system such as Ethereum has nodes all over the world, being operated by private
    individuals who are paid for their activity in the form of mining fees, denominated
    in ether. How this works is the subject of Chapter [6](A433414_1_En_6_Chapter.html).
    The system is highly decentralized.As a result, cryptocurrency protocols have
    the power to elevate financial transactions to the level of convenience we now
    enjoy with our telecommunications. So, how does a decentralized system of peer-to-peer
    nodes run “programs,” anyway?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统，比如以太坊，有着遍布全球的节点，由私人个体运营，他们以以太币形式的挖矿费用为自己的活动获得报酬。这是[第6章](A433414_1_En_6_Chapter.html)的主题。该系统高度去中心化。因此，加密货币协议有能力将金融交易提升到我们现在享受的与电信一样的便利水平。那么，去中心化的对等节点系统如何“运行”“程序”呢？
- en: Worldwide Currency?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全球货币？
- en: As you can see, the idea of a universal cryptocurrency seems to rest on the
    assumption that every human on Earth will eventually download a cryptocurrency
    wallet onto their cell phone. However, such a pipe dream is not the roadmap for
    Ethereum. Instead, the Ethereum Core developers have chosen to make it easy for
    third parties to create complementary currencies, or custom tokens, that will
    be branded and used for special purposes (similar to credit card rewards points
    today). These third parties (whether existing corporations, startups, municipalities,
    universities, or nongovernmental organizations) could rely upon the public chain,
    or large permissioned chains, to push around many different types of tokens, much
    the way that the global banking system is equipped to handle many different currencies.It’s
    unlikely that most people’s first experience with ether will be for the sake of
    cryptocurrency experimentation. It’s more likely they will end up holding digital
    tokens or points as part of a brand loyalty program, university program, or employer-sponsored
    system. Sports stadiums, theme parks, city summer camps, shopping malls, large
    office parks—anywhere there’s a community exchanging money, a complementary currency
    might make sense.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，普遍加密货币的理念似乎是建立在这样一个假设上：地球上的每个人最终都会在他们的手机上下载一个加密货币钱包。然而，这样的白日梦并非以太坊的路线图。相反，以太坊核心开发者选择了让第三方轻松创建辅助货币，或自定义代币，这些代币将被品牌化并用于特殊目的（类似于今天的信用卡奖励积分）。这些第三方（无论是现有的公司、初创公司、市政当局、大学还是非政府组织）可以依靠公共链或大型许可链来推动许多不同类型的代币，就像全球银行系统能够处理许多不同货币一样。大多数人第一次接触以太币的可能性不大是出于加密货币实验的目的。更有可能的是，他们最终会持有数字代币或积分作为品牌忠诚计划、大学计划或雇主赞助计划的一部分。体育场馆、主题公园、城市夏令营、购物中心、大型办公园区——任何地方都有一个社区在交换货币，辅助货币可能是合理的。
- en: Complementary Currency
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助货币
- en: 'Why would a country ever need more than one form of money? In the decades leading
    up to the establishment of the Federal Reserve, the United States’ present-day
    central bank, many local currencies circulated. These paper bills generally represented
    gold on deposit somewhere, and were thus local by nature; a certificate for gold
    is worth little if the redeeming institution is thousands of miles away. In the
    period before widespread, systematic private money systems (a period of American
    history known as the Wildcat banking era), many printing houses made their primary
    incomes from printing money with various anticounterfeiting features to rival
    their competing printing houses.Benjamin Franklin was one such printer who enriched
    himself on the printing of complementary currencies. In fact, he was known for
    his anticounterfeiting measures that went above and beyond. According to the Smithsonian
    Institution, he once printed an official issuance of local Pennsylvania currency
    with the name of the state spelled wrong, in the hopes of foiling counterfeiters
    who assumed those bills must be fake.[¹](#Fn1) Many of Franklin’s colonial bills
    bore the words to counterfeit is death.[²](#Fn2)The term complementary currency
    refers to a medium of exchange functioning alongside national fiat currency, meeting
    a need the national coin cannot. These currencies generally have four purposes[³](#Fn3):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个国家为什么需要不止一种货币？在建立美国现今的中央银行——美联储的几十年之前，许多地方货币在流通。这些纸币通常代表着某处的金库，因此具有地方性；如果兑现机构在数千英里之外，那么金的凭证就毫无价值。在广泛的、系统性的私人货币系统普及之前（美国历史上被称为野猫银行时代），许多印刷厂主要通过印刷带有各种防伪特征的货币来与竞争对手的印刷厂竞争。本杰明·富兰克林就是这样一个印刷商，他通过印刷辅助货币而致富。事实上，他以超越寻常的防伪措施而闻名。根据史密森尼学会的说法，他一次印刷了一张宾夕法尼亚地方货币，其中州名拼写错误，希望能够破坏那些认为那些钞票一定是假的伪钞者。富兰克林的许多殖民时期的钞票上都印有“伪造即死”的字样。辅助货币这一术语指的是一种在国家法定货币旁辅助运转的交换媒介，满足了国家货币无法满足的需求。这些货币通常有四个目的：
- en: To promote local economic development within a small community
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进小社区内的地方经济发展
- en: To build social capital in that community
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社区中建立社会资本
- en: To nurture more-sustainable lifestyles
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培育更可持续的生活方式
- en: To meet needs that mainstream money does not
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足主流货币无法满足的需求
- en: Solidity programming allows anyone to create a complementary currency, with
    a simple token contract. Those tokens can have whatever parameters the situation
    calls for, as you’ll see when you deploy a token contract in Chapter [5](A433414_1_En_5_Chapter.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity编程允许任何人创建一个辅助货币，只需一个简单的代币合约。这些代币可以具备任何场景需要的参数，当你在第[5](A433414_1_En_5_Chapter.html)章部署代币合约时，就会看到。
- en: The Promise of Solidity
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Solidity的承诺
- en: Solidity is a high-level contract-oriented language with similarities to JavaScript
    and C languages. It allows you to develop contracts and compile to EVM bytecode.
    It is currently the flagship language of Ethereum. Although it’s the most popular
    language library to be written for the EVM, it was not the first and probably
    will not be the last.There are four languages in the Ethereum protocol at the
    same level of abstraction, but the community has slowly converged on Solidity,
    which has edged out Serpent (similar to Python), Lisp-Like Language (LLL), and
    Mutan, the latter of which is deprecated.Learning Solidity enables you to move
    tokens of value in any Ethereum-based system. And because Ethereum and Solidity
    itself are free and open source technology, clever minds will likely alter and
    re-release it, or deploy it privately. In fact, several groups have already done
    just that; you’ll learn about these third parties and their approaches in later
    Chapter [11](A433414_1_En_11_Chapter.html).You can find the official Solidity
    documentation at [http://solidity.readthedocs.io/en/develop/index.html](http://solidity.readthedocs.io/en/develop/index.html)
    . However, other sites also offer useful Solidity docs. For convenience, all the
    most popular Solidity documentation is linked under the [http://solidity.eth.guide](http://solidity.eth.guide)
    subdomain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是一种高级的面向合约的语言，与 JavaScript 和 C 语言相似。它允许你开发合约并编译为 EVM 字节码。目前，它是以太坊的旗舰语言。虽然它是为
    EVM 编写的最流行的语言库，但它并不是第一个，也可能不是最后一个。以太坊协议中有四种语言处于同一抽象级别，但社区逐渐收敛于 Solidity，这使得 Serpent（类似于
    Python）、Lisp-Like Language (LLL) 和已被弃用的 Mutan 落后于它。学习 Solidity 使您能在任何基于以太坊的系统中传递价值令牌。由于以太坊和
    Solidity 本身是免费且开源技术，聪明的头脑很可能会修改并重新发布它，或者私下部署它。事实上，已经有几个团体做到了这一点；您将在第 11 章中了解这些第三方及其方法。您可以在
    [http://solidity.readthedocs.io/en/develop/index.html](http://solidity.readthedocs.io/en/develop/index.html)
    找到官方的 Solidity 文档。但其他网站也提供了有用的 Solidity 文档。为了方便起见，所有最受欢迎的 Solidity 文档都链接在 [http://solidity.eth.guide](http://solidity.eth.guide)
    子域名下。
- en: Browser Compiler
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器编译器
- en: The most common way to test Solidity is by using the browser-based compiler.
    It can be found at [http://ethereum.github.io/browser-solidity](http://ethereum.github.io/browser-solidity)
    . For quick reference, you’ll also find it at [http://compiler.eth.guide](http://compiler.eth.guide)
    .If you’ve read this far, you might already be curious about how to learn Solidity
    yourself. Although it’s certainly easier to begin programming in Solidity if you
    already know another programming language, don’t let this discourage you if you’re
    a nonprogrammer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Solidity 最常见的方式是使用基于浏览器的编译器。可以在 [http://ethereum.github.io/browser-solidity](http://ethereum.github.io/browser-solidity)
    找到它。为了快速查阅，你也可以在 [http://compiler.eth.guide](http://compiler.eth.guide) 找到它。如果你已经读到这里，你可能已经对如何学习
    Solidity 感到好奇了。虽然如果你已经掌握其他编程语言，开始在 Solidity 中编程会更容易，但如果你是非程序员，也不要因此感到泄气。
- en: Learning to Program the EVM
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 EVM 编程
- en: Sometimes it’s easier to learn a new habit than to break an old one. Many conventions
    in distributed application programming will strike today’s web and native application
    programmers as odd or quirky. Plus, they may already be professionally or personally
    invested in other languages or subject areas. So don’t feel like the whole world
    has a head start on you if you’re just starting out. It is still early days in
    the world of Ethereum.NoteKey programming terms will be defined as we go, and
    you’ll pick up a lot from the context. Try looking through a JavaScript book aimed
    at beginners ([http://​www.​apress.​com/​us/​book/​9781484217863](http://www.apress.com/us/book/9781484217863))
    for a deeper explanation of some of the core concepts in this chapter.New coders
    can approach Ethereum without preexisting assumptions. Better yet, they’ll find
    a system they can (admittedly, after some time) understand from top to bottom.
    Not all hackers, nor even software engineers, know the intricacies of the underlying
    networks in the layers below their application hosting provider.In conventional
    web applications, you have many individual servers with databases, communicating
    and sharing data over a network. This data may be manipulated by applications
    that live on still other servers. Even more servers may be in the mix to balance
    surges in demand.NoteA server is a computer that acts in a dedicated role, as
    part of a certain kind of service you want to offer people via the Web. Some servers
    hold data (think of spreadsheets of information, such as customer names and addresses)
    in what are known as databases. Some servers run applications that other computers
    can access over the network.In Ethereum, the network is the database, and this
    network can run applications available to everyone on it. So you end up learning
    quite a bit about all three.Watching a blockchain explorer report new transactions
    is something of a marvel when you know what’s happening underneath. Although learning
    Ethereum may seem like a lot of work, it would be much more work to understand
    today’s Web with a similar breadth and depth.The following subsections present
    other reasons you should begin experimenting with Solidity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，学习一个新习惯比改掉一个旧习惯更容易。分布式应用程序编程中的许多惯例可能会让今天的Web和本地应用程序程序员感到奇怪或古怪。此外，他们可能已经在其他语言或主题领域投入了职业或个人兴趣。因此，如果你刚刚开始，不要觉得整个世界都领先于你。在以太坊的世界里，现在依然是早期阶段。在我们继续的过程中，会定义关键编程术语，并且你将从上下文中学到很多。尝试查看一本面向初学者的JavaScript书籍（[http://​www.​apress.​com/​us/​book/​9781484217863](http://www.apress.com/us/book/9781484217863)），深入了解本章核心概念。新手编程人员可以在没有预先假设的情况下接触以太坊。更好的是，他们会发现一个系统，他们（诚然，需要一些时间）可以从头到尾理解。并非所有的黑客，甚至软件工程师，都了解其应用托管提供程序下面层的网络的复杂性。在传统的Web应用程序中，你有许多带有数据库的个体服务器，它们通过网络进行通信和共享数据。这些数据可能会被其他服务器上的应用程序操纵。甚至可能还有更多的服务器混合在一起来平衡需求的激增。一个服务器是一台按照特定的角色行事的计算机，作为通过Web提供给人们的某种服务的一部分。一些服务器在所谓的数据库中保存数据（考虑信息的电子表格，比如客户姓名和地址）。一些服务器运行其他计算机可以通过网络访问的应用程序。在以太坊中，网络就是数据库，这个网络可以运行所有人都可以使用的应用程序。所以你最终会对这三个方面有相当多的了解。当你知道底层发生了什么时，观察区块链浏览器报告新的交易是一种奇迹。虽然学习以太坊可能看起来是很多工作，但要理解今天的Web的广度和深度将需要更多的工作。以下小节提出了你应该开始尝试使用Solidity的其他原因。
- en: Easy Deployment
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单部署
- en: In Ethereum, you don’t necessarily have much of the hassle of deploying and
    scaling a normal web application. All the required smart contracts for the back-end
    of distributed app, also known as a dapp, can be neatly bundled up in a few documents
    and sent to the EVM, and boom—your program is available instantly to anyone on
    Earth who installs an Ethereum wallet or command-line node. Today, developers
    may want to build “hybrid” Ethereum dapps that are accessible through normal Web
    browsers, in which case adding ether payments is just adding more work. But by
    the time the network is complete in 2-3 years, it will be able to far easier to
    host all the components of an application using the Ethereum protocol.NoteIn business
    jargon, time to value, or TTV, is the amount of time that passes from the moment
    the customer requests something to the moment the customer gets it. This something
    can be tangible or intangible. But a low TTV suggests that it is easy to think
    up a product or service and deliver it quickly to the people who want to use it.In
    Ethereum, it is fast and inexpensive (if not yet easy) to develop and deploy unalterable,
    always-up, uncensorable applications that move real value over arbitrary distances.
    And everything is free, except the gas costs generated by your programs, and your
    own time (and computer). For software engineers, service providers, system administrators,
    and product managers, the long-term impact of working in the Ethereum ecosystem
    means less brittle systems, faster product iterations, and far less time developing
    infrastructure to support new applications or services. In short, this may amount
    to a drastic reduction in TTV for enterprise software vendors and in-house teams
    alike.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，你不一定需要费心部署和扩展一个普通的 Web 应用程序。所有需要的智能合约都可以整洁地打包在几个文件中，然后发送到以太虚拟机（EVM），嗖地一声——你的程序就立即对安装了以太坊钱包或命令行节点的地球上的任何人可用了。今天，开发者可能想要构建“混合”以太坊
    dapp，这些 dapp 可以通过普通的 Web 浏览器访问，这种情况下添加以太支付只是增加了更多工作量。但到了网络完全成熟的2-3年后，使用以太坊协议托管应用程序的所有组件将变得更加容易。请注意：在业务术语中，价值时间（TTV）是指从客户提出请求到客户获得请求物品的时间。这个物品可以是有形的或无形的。但是低
    TTV 意味着很容易想出一个产品或服务并迅速交付给想要使用它的人。在以太坊中，开发和部署不可更改、始终可用、无法审查的应用程序，以实时价值在任意距离上移动，是快速且廉价的（尽管还不容易）。一切都是免费的，除了由你的程序生成的燃气成本，以及你自己的时间（和计算机）。对于软件工程师、服务提供商、系统管理员和产品经理来说，在以太坊生态系统中工作的长期影响意味着更少脆弱的系统、更快的产品迭代，以及大大减少为支持新应用程序或服务开发基础设施的时间。简而言之，这可能会大幅减少企业软件供应商和内部团队的
    TTV。
- en: The Case for Writing Business Logic in Solidity
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Solidity中编写业务逻辑的理由
- en: Because of its novel characteristics, the fate of Ethereum in 2017 and beyond
    doesn’t necessarily rest on the mainstream popularity or adoption of today’s Ethereum
    clients. Instead, it relies on popularity with developers, brands, corporations,
    organizations, governments, and other institutions that are in a position to create
    an Ethereum token for their community, and perhaps even their own branded wallet.They
    might do so in the interest of quickly and safely rolling out cool new products
    and services with ultra-low overhead. This also goes for large marketing campaigns,
    which must be deployed faster and faster today to keep up with the speed of Internet
    meme culture. The frictionless nature of the payments in cryptonetworks makes
    it easier than ever to build a seamless sales and marketing experience for customers,
    with payments built in.A complementary currency is also a highly valuable tool
    for use in rewards programs, membership clubs, and large retail districts. Customers
    who hold money in the form of a branded coin are apt to spend more regularly on
    that brand, just as frequent flyers today stay loyal to the airline miles and
    credit-card point schemes that give them the best bang for the buck.Today, loyalty
    programs can be obscure and even slightly scammy. But the transparency of a blockchain-based
    loyalty coin would make it as good as any other form of cryptocurrency—meaning
    it might be traded on exchanges or accepted by other parties as payment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其新颖的特性，以太坊在2017年及以后的命运并不完全取决于当今以太坊客户端的主流普及或采用。相反，它依赖于受开发者、品牌、企业、组织、政府和其他有能力为其社区创建以太坊代币的人的欢迎程度，甚至是他们自己的品牌钱包。他们可能出于快速、安全地推出超低开销的新产品和服务的利益而这么做。这也适用于大型营销活动，今天必须比以往更快地部署，以跟上互联网迷因文化的速度。加密网络中支付的无摩擦性使得为客户建立无缝的销售和营销体验比以往任何时候都更容易，其中包含支付功能。补充货币也是用于奖励计划、会员俱乐部和大型零售区的非常有价值的工具。以品牌硬币形式持有资金的客户往往更经常在该品牌上消费，就像今天的常旅客忠于给予他们最大回报的航空里程和信用卡积分计划一样。今天，忠诚计划可能会有些模糊甚至有点欺诈。但基于区块链的忠诚代币的透明性将使其与任何其他形式的加密货币一样优秀——这意味着它可能会在交易所上交易或被其他方接受作为支付。
- en: Code, Deploy, Relax
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码，部署，放松
- en: Many Ethereum-enabled applications might be used through the Mist wallet, or
    another Ethereum-native application running a node under the hood. For developers
    of client applications, adding compatibility with new Ethereum-based tokens is
    trivial, meaning that a high degree of overlap and intercompatibility will exist
    between Ethereum wallets and tokens, just as there are many IMAP- and POP-compatible
    e-mail clients today.It’s also possible to create an Ethereum program today that
    is accessible through the regular old Web, with a little bit of work. However,
    deployment will be made increasingly easy with the use of new third-party frameworks,
    examples of which are provided in Chapter [8](A433414_1_En_8_Chapter.html).However,
    this isn’t to say that conventional web apps will go away. Many individuals and
    organizations have enormous resources invested in legacy web apps. That said,
    the Ethereum network makes it far easier and cheaper to roll out and operate applications
    at large scale, as you’ll see, tempting more and more teams to consider decentralizing
    their applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多以太坊启用的应用程序可以通过Mist钱包或另一个在幕后运行节点的以太坊原生应用程序使用。对于客户端应用程序的开发人员来说，添加对新的基于以太坊的代币的兼容性是微不足道的，这意味着以太坊钱包和代币之间将存在高度重叠和互操作性，就像今天有许多IMAP和POP兼容的电子邮件客户端一样。今天也可以通过一点工作创建一个可以通过常规旧Web访问的以太坊程序。然而，使用新的第三方框架将使部署变得越来越容易，其中一些示例在第[8](A433414_1_En_8_Chapter.html)章中提供。但是，这并不意味着传统的Web应用程序会消失。许多个人和组织在传统Web应用程序中投入了巨大的资源。也就是说，以太坊网络使得在大规模上推出和运行应用程序变得更加容易和便宜，正如你将看到的，这诱使越来越多的团队考虑去中心化他们的应用程序。
- en: Design Rationale
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原理
- en: 'The Solidity programming language has a syntax like JavaScript, but it is specially
    designed to compile into bytecode for the Ethereum Virtual Machine. As noted in
    Chapter [3](A433414_1_En_3_Chapter.html), the EVM runs code that is fully deterministic;
    the same algorithms with the same inputs will always yield the same results. You
    can prove this mathematically, as you’ll see later in this chapter.Solidity is
    statically typed, supports inheritance, libraries, and complex user-defined types,
    among other features. Conscientious use of types can help programmers understand
    how their programs will execute. A list of types in Solidity is presented at the
    end of this chapter.NoteData types are exactly what they sound like. A programmer
    has the option of telling the machine what type of data to expect: for example,
    will it be a number or a string of letters? Loosely typed languages don’t require
    the programmer to be specific; strongly typed languages do.Interestingly, in Solidity
    you can write assembly code inline. If you prefer to do a certain operation by
    using one of the EVM’s opcodes, listed in Chapter [3](A433414_1_En_3_Chapter.html),
    you can do so inline in your Solidity contracts. Just write assembly {...} with
    your code in place of a Solidity statement.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 编程语言的语法类似于 JavaScript，但它专门设计用于编译成以太坊虚拟机的字节码。正如在第 [3](A433414_1_En_3_Chapter.html)
    章中所指出的，EVM 运行的代码是完全确定性的；相同的算法在相同的输入下总是产生相同的结果。你可以通过数学证明这一点，正如你将在本章后面看到的。Solidity
    是静态类型的，支持继承、库和复杂的用户定义类型等特性。有意识地使用类型可以帮助程序员了解他们的程序将如何执行。Solidity 中的类型列表在本章末尾给出。注意数据类型正是它们听起来的样子。程序员可以选择告诉机器期望的数据类型：例如，它将是一个数字还是一串字母？松散类型的语言不要求程序员具体说明；而强类型的语言则需要。有趣的是，在
    Solidity 中你可以内联编写汇编代码。如果你喜欢使用 EVM 列在第 [3](A433414_1_En_3_Chapter.html) 章中的操作码之一执行特定操作，你可以在你的
    Solidity 合约中内联执行。只需写上 `assembly {...}`，在其中放置你的代码，以取代 Solidity 语句。
- en: Writing Loops in Solidity
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Solidity 中编写循环
- en: Loops are foundational to control flow in programming—that is, the codification
    of if-this-then-that contingencies or do-this-while-doing-that concurrencies.
    In most programming languages, loops are initiated with similar syntax. Solidity
    adheres to all the same syntactical regularities as JavaScript and C when it comes
    to loops.An iterator loop is an object that enables a programmer to move through
    a container or list. Sometimes, iterators are used to instruct the computer to
    perform the same operation a certain number of times, or on a number of elements
    in the code.A general-purpose loop has the same syntax in JavaScript, C, and Solidity.
    It instructs the computer to count up from 0 to 10:for (i = 0; i < 10; i++) {...}If
    you looked carefully at the list of opcodes in the preceding chapter, you may
    have noticed that the EVM allows looping in two ways. You can write loops in Solidity,
    or you can create them using JUMP and JUMPI instructions. This jumps ahead a specified
    number of steps in the program counter. Recall that the program counter keeps
    track of the number and order of computational steps in a given program as it
    is being executed on the EVM.This is just one way that Solidity and EVM opcodes
    can be used together to create a contract that is mostly expressive and readable,
    but also cheap to run. It’s important to point out that because of the way gas
    price is calculated, some functionality might be easier to enforce or less expensive
    to execute if written using opcodes, and this can be especially useful if you’re
    writing your own language library.If you’ve never looked seriously at code before,
    and this loop concept is hard to grasp, don’t sweat it now; the following sections
    provide more context.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是编程中控制流的基础，即对“如果-那么”的编码化和对“在做这个的同时做那个”的并发的规范化。在大多数编程语言中，循环都以类似的语法启动。在循环方面，Solidity
    遵循与 JavaScript 和 C 相同的语法规则。迭代器循环是一种使程序员能够遍历容器或列表的对象。有时，迭代器用于指示计算机执行相同操作一定次数，或在代码中的一些元素上执行操作。通用循环在
    JavaScript、C 和 Solidity 中具有相同的语法。它指示计算机从 0 计数到 10：`for (i = 0; i < 10; i++) {...}`。如果你仔细查看了前一章中的操作码列表，你可能会注意到
    EVM 允许两种方式的循环。你可以在 Solidity 中编写循环，也可以使用 JUMP 和 JUMPI 指令创建循环。这会在程序计数器中向前跳跃指定的步数。请记住，程序计数器会跟踪在
    EVM 上执行给定程序时计算步骤的数量和顺序。这只是 Solidity 和 EVM 操作码可以结合使用以创建一个大部分具有表达力和可读性，但运行成本又较低的合约的一种方式。需要指出的是，由于天然气价格的计算方式，某些功能可能更容易强制执行或更便宜地执行，如果使用操作码编写的话，这尤其有用，特别是如果你正在编写自己的语言库。如果你以前从未认真看过代码，并且这个循环概念很难理解，那么现在不要着急；接下来的章节会提供更多的背景信息。
- en: Expressiveness and Security
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达力与安全性
- en: The adjective expressive is used in computer science to mean code that is easy
    for a human programmer to write and to understand. Expressive languages are the
    bridge between human thought patterns and machine execution patterns. For a language
    to be expressive, its various constructs must be intuitively readable, and its
    boilerplate code (such as keywords, special variables, and opcodes) must use human-readable
    words that help programmers remember what they represent.Expressive languages
    must be compiled down into something more machine-friendly before they can be
    run, and this requires work on the part of the computer. After all, expressive
    languages tend to be harder to reason about (harder to predict the behavior of),
    whereas more-restricted, lower-level, less-abstract languages make that reasoning
    easier.The final frontier is smart contracts that can be easily formally verified,
    but also written in an expressive high-level language such as Solidity. This problem
    begs for automation, and indeed, automated formal verification is now on the horizon—a
    fact that computer scientists must be excited about, and that Ethereum developers
    will unknowingly benefit from.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，形容词“表达性”（expressive）用来指代容易让人类程序员编写和理解的代码。表达性语言是人类思维模式和机器执行模式之间的桥梁。要使一种语言具有表达性，它的各种构造必须直观易读，并且其样板代码（如关键词、特殊变量和操作码）必须使用人类可读的单词，以帮助程序员记住它们所代表的含义。表达性语言在运行之前必须被编译成更适合机器的形式，这需要计算机的工作。毕竟，表达性语言往往更难推理（更难预测行为），而更受限制、更低级别、更不抽象的语言则使得推理更容易。最后的前沿是可以轻松进行形式验证的智能合约，同时也可以用表达性高级语言（如Solidity）编写。这个问题需要自动化解决，事实上，自动化形式验证现在已经在望——这是计算机科学家必定会为之兴奋的事实，以及以太坊开发人员将无意中受益于此。
- en: The Importance of Formal Proofs
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形式证明的重要性
- en: 'If you learn Solidity programming, you may encounter the curiosity of other
    developers, who will get right to the point: how do you prevent someone writing
    an infinite loop and locking up the machine?Far from being a niche argument, this
    is the most relevant issue related to software engineering’s role in the world
    today: can human beings make a free, openly accessible virtual computer that other
    human beings can’t sabotage? If the answer is yes, then it stands in stark defiance
    of the theory of the tragedy of the commons.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学习Solidity编程，你可能会遇到其他开发者的好奇，他们会直截了当地问：你如何防止某人写入无限循环并锁住机器？这绝非一个小众的争论，这是与当今世界软件工程角色相关的最重要问题：人类能否制造一个自由、开放可访问的虚拟计算机，其他人无法破坏？如果答案是肯定的，那么它就是对“共有资源悲剧”理论的鲜明反驳。
- en: Historical Impact of a Shared Global Resource
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享全球资源的历史影响
- en: 'In economics, the tragedy of the commons is the idea that a shared resource
    can’t last. Eventually, users acting in their own self-interests will deplete
    the resource, because it comes at no cost to themselves to do so. A scenario like
    this, whereby someone can enrich themselves or act profligately while externalizing
    the costs to other people, is known as a moral hazard.Here’s an example: In New
    York City in late 2016, the municipal government installed computing terminals
    on the streets of Lower Manhattan. These terminals offered free Wi-Fi to passing
    pedestrians. However, these terminals also came with a small touchscreen allowing
    walk-up Internet access. No sooner were these shared resources up and running
    before people were pulling up chairs, watching YouTube or pornography, and loitering
    for hours.[⁴](#Fn4) Program administrators were forced to quickly restrict the
    onscreen Internet access, and now the terminals serve mostly as just Wi-Fi hotspots.Thus,
    the notion of an extremely inexpensive public computer such as the EVM is nothing
    short of fantastic. It can be accessed by anyone, with any computer, anywhere,
    and will run programs far into the future. Nobody owns it and nobody can tamper
    with it. It can even store your money for you.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在经济学中，公地悲剧是一个共享资源无法长久存在的概念。最终，以自身利益为出发点的用户会耗尽资源，因为对他们来说这没有任何成本。这种情景，即某人可以在外部化成本的同时充实自己或挥霍浪费资源，被称为道德风险。举个例子：2016年底，纽约市政府在曼哈顿下城的街道上安装了计算终端。这些终端为路过的行人提供免费的Wi-Fi。然而，这些终端也配备了一个小触摸屏，可以提供即时的上网服务。就在这些共享资源刚刚投入使用之后，人们便纷纷拉椅子坐下，观看YouTube或色情内容，徘徊数小时。[⁴](#Fn4)项目管理人员不得不迅速限制屏幕上的互联网访问，现在这些终端主要用作Wi-Fi热点。因此，像以太坊虚拟机这样的极为廉价的公共计算机观念简直是太棒了。任何人，任何计算机，任何地方都可以访问它，并将来可以长期运行程序。它没有任何所有者，也没有人能篡改它。它甚至可以为你存储资金。
- en: How Attackers Bring Down Communities
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击者如何摧毁社区
- en: Decentralized economies represent a nascent threat to all sorts of private vested
    interests around the world, especially in developing economies, where powerful
    people would prefer the world continue on without a solution to the tragedy of
    the commons (and thus, remain at the mercy of the latest autocrat or crazy mob).
    The security of the Ethereum network is the subject of Chapter [7](A433414_1_En_7_Chapter.html).
    But Ethereum’s defenses are everywhere, even in the programming language itself,
    so it bears mention here.For this discussion, you can think of a network as a
    community of people connecting with each other via computer. An attacker is someone
    who hates this group, and seeks to cause them grief at any expense.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化经济代表着对全球各种私人既得利益的一种新兴威胁，尤其是在发展中国家，那里的有权势的人更希望世界继续存在着“公地悲剧”（因此，仍然任由最新的专制者或疯狂的暴民摆布）。以太坊网络的安全性是第
    [7](A433414_1_En_7_Chapter.html) 章的主题。但以太坊的防御措施无处不在，甚至包括编程语言本身，因此在这里提及是必要的。在本讨论中，你可以将网络视为通过计算机互相连接的人群社区。攻击者是指那些憎恶这个群体，并试图以任何代价使他们感到痛苦的人。
- en: Hypothetical Attack Written in Solidity
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用 Solidity 编写的假想攻击
- en: Imagine that an attacker wants to lock up the EVM with a super memory-intensive
    smart contract, written in Solidity. The attacker is willing to pay the gas costs,
    however large. (This is a real scenario, as you’ll see in Chapter [7](A433414_1_En_7_Chapter.html).)
    Keep in mind that for the purposes of this example, the contract could also be
    written in any language created for the EVM, such as Serpent or even the lower-level
    EVM code, not just Solidity.According to Rice’s theorem , the behavioral properties
    of some computer programs are mathematically undecidable, meaning it is not possible
    to write another computer program that can definitively predict whether Solidity
    code you show it will ever terminate.[⁵](#Fn5) Thus, there is no way to write
    any kind of effective “gatekeeper” program that will swat down a hypothetically
    memory-hungry smart contract written by the attacker in this scenario.NoteSmart
    contracts are distinct from distributed applications, or dapps, even though both
    are distributed and application-like. A dapp is a GUI application that uses Ethereum
    smart contracts on the back end, in lieu of a conventional database and web application
    hosting provider. Dapps may be accessed through the Mist browser or over the Web.The
    EVM deals with this reality in various ways, including a hard limit on the number
    of computational steps per block, its deterministic language, and gas costs. Nevertheless,
    gray areas will always be explored by attackers if a financial incentive exists,
    and at $1 billion market capitalization, there’s significant incentive to crack
    the EVM and steal ether.Although gray areas can’t be engineered away at once,
    they can be dealt with in a series of protocol forks over time. As far as accidentally
    destructive programs, it’s up to the Ethereum community to develop patterns and
    practices that are conducive to straightforward, easy-to-prove contracts that
    can develop into boilerplate standards. Chapter [5](A433414_1_En_5_Chapter.html)
    covers some of these best practices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Automated Proofs to the Rescue?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动证明能否解救困境？
- en: Although it’s not possible to create a gatekeeper that kicks out bad programs,
    it is increasingly feasible to produce provably correct programs by using a machine-checkable
    proof—an automated program that mathematically proves other programs.Because smart
    contracts move money, they make great lab rats for automated mathematical proofs.
    The goal of this area of computer science and mathematics research is to ensure,
    in a systematic way, that source code satisfies a certain formal specification.
    It’s a way for independent auditors to come in and mathematically verify that
    the program is actually doing what it’s supposed to do.Automating the proving
    process is a boon for businesses but won’t do much for the average programmer
    learning Solidity. Proofs merely show you whether what you intended to happen
    actually did happen in the program. If your program doesn’t prove out, there is
    no way for an automated system to tell you how to write it better.Nevertheless,
    the point of exploring this topic is to signal that Ethereum networks may indeed
    one day carry high volumes of automated money-moving bots pushing around trillions
    of dollars safely; and that developing these bots may not be as slow, risky, and
    obscure a process as it is today.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不可能创建一个可以排除不良程序的门卫，但通过使用可机器检验的证明——一种数学上证明其他程序的自动化程序，生产可证明正确的程序变得越来越可行。由于智能合约涉及资金流动，它们成为自动化数学证明的极好实验对象。这一计算机科学和数学研究领域的目标是以系统化的方式确保源代码满足某些形式化规范。这是独立审计员进来并数学验证程序实际上是否正在执行其预期功能的一种方法。自动化证明过程对企业是一个福音，但对于学习
    Solidity 的普通程序员来说并没有太大帮助。证明仅仅向你展示你的意图是否实际上在程序中发生了。如果你的程序不能证明出来，自动化系统就没有办法告诉你如何更好地编写它。尽管如此，探讨这个话题的目的是为了表明以太坊网络确实有一天可能会承载大量自动化资金流动的机器人，推动着数万亿美元的安全流动；并且开发这些机器人可能并不像今天一样缓慢、风险高、晦涩难懂。
- en: Determinism in Practice
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践中的确定性
- en: Combining the concepts from the preceding sections, you can see that in some
    ways, the whole idea of Turing completeness may be an idealized concept of limited
    usefulness when designing a public system in the real world.Thus, it could also
    be said that in practice, the EVM is not really Turing complete, because the bounded
    nature of execution in Solidity contracts could soon make it possible to theoretically
    predict the behavior of any program the EVM will run.Bitcoin escapes none of these
    issues. The gray areas that exist between expressive languages and machine languages
    exist for Bitcoin’s scripting language too, which is also compiled down at runtime
    into machine code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结合前面章节的概念，你可以看到，在某些方面，图灵完备性的整个概念可能是一个理想化的概念，在设计现实世界中的公共系统时具有有限的用处。因此，可以说，在实践中，以太坊虚拟机并不真正是图灵完备的，因为在
    Solidity 合约中的执行的有限性可能很快就能使理论上预测以太坊虚拟机将运行的任何程序的行为成为可能。比特币也没有摆脱这些问题。存在于表达性语言和机器语言之间的灰色地带也存在于比特币的脚本语言中，该语言在运行时也编译成机器代码。
- en: Lost in Translation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译中迷失
- en: Interestingly, the question of proofs has a lot to do with the concept of expressiveness,
    discussed earlier in this chapter. A human can perform a mathematical proof on
    only a high-level, abstract language—that is, a human-readable programming language
    such as Solidity. Performing such a proof on assembly code or machine code would
    be next to impossible for even the most dedicated mathematical minds.The compilation
    process—the transmission of human-readable code into lower-level machine code—sacrifices
    a lot of (human interpretable) information about how to reason about the program.
    It also sacrifices information that would be useful to an automated theorem prover.
    Thus, some ambiguity is always introduced into the process. Today, you can never
    be fully sure that even a mathematically proven smart contract written in Solidity
    will still be provable after being compiled.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，证明的问题与先前在本章中讨论的表达性概念有很大关系。人类只能在高级别的抽象语言上执行数学证明，即人类可读的编程语言，如 Solidity。在汇编代码或机器码上执行这样的证明，即使是最专注的数学思维，也几乎不可能。编译过程——将人类可读代码传输为较低级别的机器码——牺牲了大量（人类可解释的）关于如何推理程序的信息。它还牺牲了对自动定理证明器有用的信息。因此，始终会引入一些模糊性到这个过程中。今天，即使是用
    Solidity 编写的经数学证明的智能合约在编译后仍然是可证的，你也无法完全确定。
- en: Testing, Testing, Testing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试，测试，测试
- en: The way to prevent ambiguous code from losing your money is to test vigorously.
    The Ethereum network comes with a testnet called Ropsten that uses play ether,
    which costs nothing and can be drawn from a faucet quickly in a sandbox-like environment.In
    reality, Ropsten is no different from the main chain. It is simply a different
    chain that was designated for testing. Like the Titanic and its sister ship the
    Britannic, they are identical except for the names, as is every other chain someone
    spins up. There is nothing special or sanctified about these chains; you will
    create chains just like them in Chapter [8](A433414_1_En_8_Chapter.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 防止模糊代码让您损失资金的方法是进行大量测试。以太坊网络配备了一个称为 Ropsten 的测试网络，使用虚拟以太币，这些以太币不花钱，并且可以在类似沙箱的环境中快速地从水龙头中提取。实际上，Ropsten
    与主链没有任何区别。它只是一个被指定用于测试的不同链。就像泰坦尼克号和它的姐妹船不同名字一样，它们是相同的，正如其他任何由某人启动的链一样。这些链没有什么特别或神圣的地方；你将在第
    [8](A433414_1_En_8_Chapter.html) 章中创建与它们完全相同的链。
- en: Command Line Optional !
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行可选！
- en: 'Keep in mind that most of the important functions of Ethereum can be done in
    the Mist wallet: sending and receiving ether, tracking tokens, and deploying contracts.
    Using Geth (or the other command-line clients) is a good choice for developers
    who intend to learn to write dapps. Chapter [6](A433414_1_En_6_Chapter.html) deals
    more with Geth.In this section, we will look briefly at a real smart contract,
    to explore one simple example of how a smart contract can be used.NoteIf you can’t
    read or write code, don’t worry. A tutorial on syntax and structure follows this
    example that will help you reason about what the code is doing. In the next chapter,
    we’ll deploy a standard Ethereum token, with zero coding required.You’ll learn
    how to deploy a contract like this in Chapter [5](A433414_1_En_5_Chapter.html).
    You’ll be pleased to learn that there are only three requirements for deploying
    a simple contract in Solidity:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 的大部分重要功能都可以在 Mist 钱包中完成：发送和接收以太币、跟踪代币以及部署合约。对于打算学习编写 DApp 的开发者来说，使用
    Geth（或其他命令行客户端）是一个不错的选择。第 [6](A433414_1_En_6_Chapter.html) 章更详细地介绍了 Geth。在本节中，我们将简要地查看一个真实的智能合约，以探索一个简单示例，展示智能合约的使用方式。如果你不会阅读或编写代码，不要担心。在这个例子之后会有一个关于语法和结构的教程，帮助你理解代码在做什么。在下一章中，我们将部署一个标准的以太坊代币，而无需编写任何代码。你将在第
    [5](A433414_1_En_5_Chapter.html) 章学习如何部署这样的合约。你会高兴地发现，使用 Solidity 部署一个简单的合约只有三个要求：
- en: 1.A text editor such as TextEdit on macOS, Gedit on Ubuntu, or Notepad on Windows.
    Be sure to switch to plain-text mode, which strips away all fonts, underlining,
    bold, hyperlinks, and italics. (Never use rich text to write code!)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.诸如 macOS 上的 TextEdit、Ubuntu 上的 Gedit 或 Windows 上的 Notepad 之类的文本编辑器。请确保切换到纯文本模式，以删除所有字体、下划线、粗体、超链接和斜体。（永远不要使用富文本编写代码！）
- en: 2.The Mist wallet, covered in Chapter [2](A433414_1_En_2_Chapter.html).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2.在第 [2](A433414_1_En_2_Chapter.html) 章中介绍的 Mist 钱包。
- en: '3.The Browser Solidity Compiler located at [https://ethereum.github.io/browser-solidity/](https://ethereum.github.io/browser-solidity/)
    or available at the following shortlink:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.位于 [https://ethereum.github.io/browser-solidity/](https://ethereum.github.io/browser-solidity/)
    的浏览器 Solidity 编译器，或者通过以下短链接获取：
- en: http://compiler.eth.guideAs we’ll demonstrate in Chapter [5](A433414_1_En_5_Chapter.html),
    all that you need to do to “upload” a contract is to copy-paste your Solidity
    code from your text editing application into the Solidity Browser Compiler. From
    there, you’ll compile the code into bytecode, and copy-paste that bytecode into
    Mist. It’s really very easy, but let’s not get bogged down in the logistics just
    yet. Instead, we’ll examine the behavior of the sample smart contract below, so
    you can begin to grasp the potential of an automated contract which sends and
    receives money. The following example was originally written by Cyrus Adkisson
    (fivedogit on GitHub), a Kentuckian software engineer and Ethereum enthusiast
    now living in New York. It has been adapted for this book.You’ll name this contract
    PiggyBank, using CapsCase (rather than camelCase) per the Solidity naming conventions.
    You can find those naming conventions, and the rest of the Solidity style guide,
    at [http://solidity.readthedocs.io/en/develop/style-guide.html](http://solidity.readthedocs.io/en/develop/style-guide.html)
    .Now, let’s look at PiggyBank.sol:contract PiggyBank {       address creator;       uint
    deposits;// Declaring this function as public makes it accessible to other users
    and smart contracts.       function PiggyBank() public       {           creator
    = msg.sender;           deposits = 0;       }// Check whether any ether has been
    deposited. When it is deposited, the number of deposits go up and the total count
    is returned       function deposit() payable returns (uint)       {           if(msg.value
    > 0)                deposits = deposits + 1;           return getNumberOfDeposits();       }       function
    getNumberOfDeposits() constant returns (uint)       {           return deposits;       }//
    When the external account that instantiated this contract calls it again, it terminates
    and sends back its balance.       function kill()       {           if (msg.sender
    == creator)               selfdestruct(creator);       }}You can find more examples
    of Solidity scripts for programmers of all skill levels and abilities at [http://solidity.eth.guide](http://solidity.eth.guide)
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: http://compiler.eth.guide正如我们将在第 [5](A433414_1_En_5_Chapter.html) 章中演示的那样，“上传”合约所需的全部工作就是将你的
    Solidity 代码从文本编辑应用程序复制粘贴到 Solidity 浏览器编译器中。从那里，你将代码编译成字节码，然后将该字节码复制粘贴到 Mist 中。这真的非常简单，但让我们暂时不要被细节问题困扰。相反，我们将检查下面的示例智能合约的行为，以便你开始领会自动发送和接收资金的合约的潜力。以下示例最初由肯塔基州软件工程师和以太坊爱好者
    Cyrus Adkisson（GitHub 上的 fivedogit）撰写。它已经为本书做了调整。你将命名此合约为 PiggyBank，使用 CapsCase（而不是
    camelCase），符合 Solidity 命名约定。你可以在[http://solidity.readthedocs.io/en/develop/style-guide.html](http://solidity.readthedocs.io/en/develop/style-guide.html)找到这些命名约定以及其他
    Solidity 风格指南。现在，让我们看看 PiggyBank.sol：contract PiggyBank {       address creator;       uint
    deposits;// 将此函数声明为 public 使其对其他用户和智能合约可访问。       function PiggyBank() public       {           creator
    = msg.sender;           deposits = 0;       }// 检查是否存入了任何以太。存入时，存款数会增加，并返回总计数       function
    deposit() payable returns (uint)       {           if(msg.value > 0)                deposits
    = deposits + 1;           return getNumberOfDeposits();       }       function
    getNumberOfDeposits() constant returns (uint)       {           return deposits;       }//
    当实例化此合约的外部账户再次调用它时，它会终止并将余额发送回。       function kill()       {           if (msg.sender
    == creator)               selfdestruct(creator);       }}你可以在[http://solidity.eth.guide](http://solidity.eth.guide)找到适用于各种技能水平和能力的程序员的更多
    Solidity 脚本示例。
- en: Formatting Solidity Files
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化 Solidity 文件
- en: One major detail is missing from the preceding contract example. Every Solidity
    file should have (but does not require) a version pragma, a statement indicating
    which Solidity version this contract was written in. Over time, this should prevent
    older contracts from being rejected by future versions of the compiler.The version
    pragma for this file is 0.4.7, so you should add the following to the file header:pragma
    solidity ^0.4.7;For more information on the structure of Solidity files, see [http://solidity.readthedocs.io/en/develop/layout-of-source-files.html](http://solidity.readthedocs.io/en/develop/layout-of-source-files.html)
    .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前述合约示例缺少一个重要细节。每个 Solidity 文件都应该（但不是必须）有一个版本声明，即指示该合约是使用哪个 Solidity 版本编写的语句。随着时间的推移，这应该可以防止较旧的合约被未来版本的编译器拒绝。此文件的版本声明为
    0.4.7，因此您应该将以下内容添加到文件头部：`pragma solidity ^0.4.7;`。有关 Solidity 文件结构的更多信息，请参阅 [http://solidity.readthedocs.io/en/develop/layout-of-source-files.html](http://solidity.readthedocs.io/en/develop/layout-of-source-files.html)
    。
- en: Tips for Reading Code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读代码的提示
- en: 'Here are seven facts that will make this contract more legible for beginners:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有七个事实，这将使这个合约对初学者更易读：
- en: Computers read code from top to bottom, left to right, just like English speakers.
    Putting one line before another generally means the computer will see that instruction
    first.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机从上到下、从左到右读取代码，就像英语讲者一样。通常，将一行放在另一行之前意味着计算机将首先看到该指令。
- en: Typically, programs take an input and return some kind of output. Computable
    functions (mathematical functions that can be performed by a computer) are defined
    as functions that can be written as algorithms.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，程序接受一个输入并返回某种输出。可计算函数（计算机可以执行的数学函数）被定义为可以编写为算法的函数。
- en: Algorithms take in data, perform an operation on it, and return some kind of
    output. Programs are algorithms with other algorithms nested in them.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法接受数据，对其进行操作，并返回某种输出。程序是具有其他算法嵌套在其中的算法。
- en: 'An algorithm is like a machine: you can reuse it many times. Thus, writing
    algorithmic instructions—programming—will strike you as being a lot like writing
    Mad Libs, which the computer will later autocomplete with information that a user
    (or in Ethereum, a contract) gives it, via a transaction or message call. Sometimes
    this information is just a number (for example, 5 ether).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法就像一台机器：您可以多次重复使用它。因此，编写算法指令——编程——会让您觉得很像写填空游戏，稍后计算机将使用用户（或以太坊中的合约）提供的信息（通过交易或消息调用）自动填写信息。有时，这些信息只是一个数字（例如，5
    以太）。
- en: Operators are the symbols between the English words, such as the equal sign,
    plus sign, and minus sign. These work mostly as you’d expect, with a few exceptions.
    You’ll see Solidity operators in Table [4-1](#Tab1).Table 4-1.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符是英文单词之间的符号，例如等号、加号和减号。这些通常按照您的预期工作，但也有一些例外。您可以在[表4-1](#Tab1)中查看 Solidity
    运算符。
- en: '| Precedence | Description | Operator |'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 优先级 | 描述 | 运算符 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Postfix increment and decrement | ++, -- |'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 后缀递增和递减 | ++, -- |'
- en: '| Function-like call | <func>(<args...>) |'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 函数调用 | <func>(<args...>) |'
- en: '| Array subscripting | <array>[<index>] |'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 数组下标 | <array>[<index>] |'
- en: '| Member access | <object>.<member> |'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 成员访问 | <object>.<member> |'
- en: '| Parentheses | (<statement>) |'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 括号 | (<statement>) |'
- en: '| 2 | Prefix increment and decrement | ++, -- |'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | 前缀递增和递减 | ++, -- |'
- en: '| Unary plus and minus | +, - |'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 一元加和减 | +, - |'
- en: '| Unary operations | delete |'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 一元操作 | delete |'
- en: '| Logical NOT | ! |'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 逻辑非 | ! |'
- en: '| Bitwise NOT | ∼ |'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 位非 | ∼ |'
- en: '| 3 | Exponentiation | ** |'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | 指数运算 | ** |'
- en: '| 4 | Multiplication, division, and modulo | *, /, % |'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | 乘法、除法和取模 | *, /, % |'
- en: '| 5 | Addition and subtraction | +, - |'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | 加法和减法 | +, - |'
- en: '| 6 | Bitwise shift operators | <<, >> |'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 6 | 位移操作符 | <<, >> |'
- en: '| 7 | Bitwise AND | & |'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 7 | 位与 | & |'
- en: '| 8 | Bitwise XOR | ^ |'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 8 | 位异或 | ^ |'
- en: '| 9 | Bitwise OR | &#124; |'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 9 | 位或 | &#124; |'
- en: '| 10 | Inequality operators | <, >, <=, >= |'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 10 | 不等运算符 | <, >, <=, >= |'
- en: '| 11 | Equality operator, does-not-equal operator | ==, != |'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11 | 相等运算符，不相等运算符 | ==, != |'
- en: '| 12 | Logical AND | && |'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 12 | 逻辑与 | && |'
- en: '| 13 | Logical OR | &#124;&#124; |'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 13 | 逻辑或 | &#124;&#124; |'
- en: '| 14 | Ternary operator | <conditional> ? <if-true> : <if-false> |'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 14 | 三元运算符 | <conditional> ? <if-true> : <if-false> |'
- en: '| 15 | Assignment operators | =, &#124;=, ^=, &=, <<=, >>=, +=, -=, *=, /=,
    %= |'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 15 | 赋值运算符 | =, &#124;=, ^=, &=, <<=, >>=, +=, -=, *=, /=, %= |'
- en: '| 16 | Comma operator | , |'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 16 | 逗号操作符 | , |'
- en: Types are the nouns of computer programming. So when you see a type, you know
    what is allowed in that space of the Mad Lib. A common type in Solidity is an
    address.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型是计算机编程中的名词。因此，当你看到一个类型时，你知道在 Mad Lib 的那个空间中允许什么。在 Solidity 中的一个常见类型是地址。
- en: 'The original use of computers was to do math quickly. For decades, the people
    who used computers were mostly physicists who wanted to crunch hard math problems
    in order to figure out answers to questions such as this: What time and day is
    the best to launch Apollo 11, so that it has the shortest distance to travel to
    the Moon?The EVM is much closer to this original kind of computer, but it’s suited
    to thinking about sophisticated accounting and fiscal reconciliation, as you might
    learn to do in business school by programming spreadsheets in Microsoft Excel.
    Recall that databases are merely spreadsheets themselves, and computer programs
    manipulate these databases. Thus, when you declare something, you are telling
    the computer to put it in the spreadsheet—specifically, to put it in the stack.The
    computer will figure out, on its own, how much memory to have ready to store the
    values in any temporary, or so-called dynamic, computations—small, pivotal logical
    statements used to compute contingencies such as if-then. (It’s important to define
    the stack and heap in order to see that this is where the danger of memory-hog
    programs lies: in asking the computer to use more dynamic memory than it has to
    spare.)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机最初的用途是快速进行数学计算。几十年来，使用计算机的人主要是物理学家，他们想要解决一些难题，比如：什么时间和日期最适合发射阿波罗11号，以便它到达月球的距离最短？EVM
    更接近于这种最初的计算机，但它更适合思考复杂的会计和财务对账，就像你可能通过在 Microsoft Excel 中编写电子表格来学习一样。记住，数据库本身就是电子表格，计算机程序操作这些数据库。因此，当你声明某些内容时，你在告诉计算机把它放入电子表格中——具体地说，是放入堆栈中。计算机将自行确定需要准备多少内存来存储任何临时的、或者所谓的动态计算的值——用于计算诸如
    if-then 这样的情况的关键逻辑语句。（重要的是要定义堆栈和堆，以便看到内存占用过多的危险在哪里：即要求计算机使用超出其可用的动态内存。）
- en: Statements and Expressions in Solidity
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Solidity 中的语句和表达式
- en: As you’ll see, there are functions all over the place in Solidity. However,
    they’re used in different ways.Some functions produce a value, such as a number,
    or an answer to a true/false question. What exactly this value can be is determined
    by Solidity’s types, mentioned earlier; the true/false value is called a Boolean.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，Solidity 中到处都是函数。然而，它们以不同的方式使用。一些函数产生一个值，比如一个数字，或者对一个真/假问题的回答。这个值究竟是什么由
    Solidity 的类型决定，之前提到过；真/假值称为布尔值。
- en: What Is an Expression?
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是表达式？
- en: Functions that produce a value are known as expression functions . Because expressions
    evaluate to a value of one type or another, in programming they can be used in
    place of values.Other functions are declarative, and lead to the creation of a
    dedicated space in the computer’s memory, which will be used each time it runs
    this routine. These declarative functions are important because they are crucial
    to writing statements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 产生值的函数被称为表达式函数。因为表达式评估为某种类型的值，所以在编程中它们可以用来代替值。其他函数是声明式的，并导致在计算机内存中创建专用空间，每次运行此例程时将使用该空间。这些声明式函数很重要，因为它们对编写语句至关重要。
- en: What Is a Statement?
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是语句？
- en: Speaking in grossly general terms, a statement tells the computer to perform
    an action. The computer uses expressions to figure out how to take this action,
    and when. Thus, computer programs are composed of statements, and statements are
    often composed of expressions (or other statements).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略而言，语句告诉计算机执行动作。计算机使用表达式来弄清楚如何以及何时执行此操作。因此，计算机程序由语句组成，语句通常由表达式（或其他语句）组成。
- en: Functions , Public and Private
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数，公共和私有
- en: 'In JavaScript and Solidity, you can use semicolons to chain statements, and
    tell the computer that another statement is coming up in the code:function first();
    function second()In Solidity, you can also declare whether you want certain functions
    to be available outside that program. These designations are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript和Solidity中，您可以使用分号来链接语句，并告诉计算机代码中即将出现另一个语句：function first(); function
    second()在Solidity中，您还可以声明您是否希望某些函数在该程序外部可用。这些指定如下：
- en: 'public: Visible externally and internally (an accessor function for storage/state
    variables is created)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: public：外部和内部可见（为存储/状态变量创建一个访问器函数）
- en: 'private: Visible only in the current contract (default)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有：仅在当前合约中可见（默认）
- en: NoteFunctions written in Solidity code are not public by default. You must declare
    them as public when you make them, or they will not be available to contracts
    outside of the one they’re in.Although this is just an introduction to code literacy,
    it should be enough for you to begin to decode what some of the smart contracts
    we’ll discuss later are doing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Solidity代码中编写的函数默认不是公共的。您必须在创建它们时将它们声明为公共，否则它们将无法在其外部合约中使用。虽然这只是对代码识字的简介，但应该足以让您开始解码我们稍后将讨论的某些智能合约在做什么。
- en: Value Types
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: When writing Solidity code, you can tell the computer what type of value to
    expect in each algorithmic instruction. This section describes the types of values
    the EVM can interpret.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Solidity代码时，您可以告诉计算机在每个算法指令中期望什么类型的值。本节描述了EVM可以解释的值类型。
- en: Booleans
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: Known in code as bool, the Booleans are true/false expressions that evaluate
    to true or false.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中称为布尔值，布尔值是评估为true或false的true/false表达式。
- en: Signed and Unsigned Integers
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有符号整数和无符号整数
- en: Known in code as int and uint, these are numbers. They can be negative if they
    have a sign, or minus, indicating they are signed. Unsigned integers are thus
    positive numbers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中称为 int 和 uint，它们是数字。如果具有符号，则可以为负数，或者带有减号，表示它们是有符号的。因此，无符号整数是正数。
- en: Addresses
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址
- en: The address type holds a 20-byte value, which is the size of an Ethereum address
    (40 hex characters, or 160 bits). Address types also have member types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 地址类型保存一个 20 字节的值，这是以太坊地址的大小（40 个十六进制字符，或 160 位）。地址类型也有成员类型。
- en: Members of Addresses
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址的成员
- en: These two members allow you to query the balance of an account, or to transfer
    ether to an account. Be careful with transfer in smart contracts. It’s better
    to use a pattern where the recipient is allowed to withdraw the money, than to
    have a contract initiating transfers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个成员允许您查询账户的余额，或者向账户转账以太。在智能合约中使用转账时要小心。最好使用允许收款人提取资金的模式，而不是由合约发起转账。
- en: balance
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余额
- en: transfer
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账
- en: Address-Related Keywords
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与地址相关的关键字
- en: 'Keywords come with the Solidity language. They are methods, so to speak, for
    using the language in predetermined ways. You can use these keywords in your code
    to accomplish common tasks needed in smart contracts. These include the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是 Solidity 语言的一部分。它们是一种方法，可以说，用于以预定的方式使用语言。您可以在代码中使用这些关键字来完成智能合约中需要的常见任务。这些包括以下内容：
- en: '<address>.balance (uint256): Returns the balance of the [address](http://solidity.readthedocs.io/en/develop/types.html)
    in wei'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<address>.balance (uint256): 返回 wei 中[地址](http://solidity.readthedocs.io/en/develop/types.html)的余额'
- en: '<address>.send(uint256 amount) returns (bool): Sends given amount of wei to
    [address](http://solidity.readthedocs.io/en/develop/types.html), and returns false
    on failure'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<address>.send(uint256 amount) 返回 (bool): 将指定数量的 wei 发送到[地址](http://solidity.readthedocs.io/en/develop/types.html)，失败时返回
    false'
- en: 'this(current contract’s type): Explicitly converts to the address'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: this(当前合约的类型)：显式转换为地址
- en: 'selfdestruct(address recipient): Destroys the current contract, sending its
    funds to the given [address](http://solidity.readthedocs.io/en/develop/types.html)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'selfdestruct(address recipient): 销毁当前合约，将其资金发送到给定的[地址](http://solidity.readthedocs.io/en/develop/types.html)'
- en: NoteIt is possible to query the balance of the current contract by using the
    keyword this.balance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：可以使用关键字 this.balance 查询当前合约的余额。
- en: Less-Common Value Types
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不常见的值类型
- en: 'Several other value types may be useful if you’re already an advanced or intermediate
    programmer:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经是高级或中级程序员，则还有其他几种值类型可能会有用：
- en: Dynamically sized byte arrays
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态大小的字节数组
- en: Fixed-point numbers
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定点数
- en: Rational and integer literals
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有理数和整数字面量
- en: String literals
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: Hexadecimal literals
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制字面量
- en: Enums
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Complex (Reference) Types
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂（引用）类型
- en: 'Generally speaking, types in Solidity are allotted 256 bits of memory in the
    EVM’s storage; that’s 2,048 characters. Types that are any longer than that can
    incur more-significant gas costs to move around. You’ll need to choose carefully
    when assigning persistent storage in the EVM’s stack. Here are the complex types
    that exceed 256 bits:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Solidity 中的类型在以太坊虚拟机的存储中被分配了 256 位的内存；即 2,048 个字符。比这更长的类型可能会产生更大的燃料成本来移动。您需要仔细选择在以太坊虚拟机的堆栈中分配永久存储的类型。以下是超过
    256 位的复杂类型：
- en: Arrays
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Array literals / inline arrays
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组字面量 / 内联数组
- en: Structs
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Mappings
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Arrays, structs, and other complex types have a data location that can be used
    by Solidity programmers to manipulate whether they are stored dynamically in memory
    or persistently stored. This can help you manage fees.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、结构体和其他复杂类型具有数据位置，Solidity 程序员可以使用该位置来操作它们是动态存储在内存中还是永久存储。这可以帮助您管理费用。
- en: Global Special Variables, Units, and Functions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局特殊变量、单位和函数
- en: Global special variables can be called by any Solidity smart contract on the
    EVM; they’re built in to the language. Most of them return information about the
    Ethereum chain. Units of time and ether are also globally available. Literal numbers
    can take a suffix of wei, finney, szabo or ether and will auto-convert between
    subdenominations of Ether. Ether currency numbers without a suffix are assumed
    to be Wei.Time-related suffixes can be used after literal numbers to convert between
    units of time. Here, seconds are the base unit, and units are treated as general
    units. Owing to the existence of leap years, be careful when using these suffixes
    to calculate time, as not all years have 365 days, and not days have 24 hours.
    1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours
    1 weeks = 7 days 1 years = 365 days
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 全局特殊变量可以被以太坊虚拟机上的任何 Solidity 智能合约调用；它们是内置于语言中的。它们中的大多数返回有关以太坊链的信息。时间单位和以太币也是全局可用的。字面数字可以带有
    wei、finney、szabo 或 ether 后缀，并且可以在以太的子单位之间自动转换。没有后缀的以太币数字被视为 Wei。时间相关的后缀可以用于字面数字后，以在时间单位之间进行转换。这里，秒是基本单位，并且单位被视为一般单位。由于闰年的存在，请注意在使用这些后缀计算时间时要小心，因为不是所有年份都有
    365 天，也不是所有天都有 24 小时。1 == 1 秒 1 分钟 == 60 秒 1 小时 == 60 分钟 1 天 == 24 小时 1 周 = 7
    天 1 年 = 365 天
- en: Block and Transaction Properties
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块和交易属性
- en: Note that these global variables are only available in Solidity smart contracts.
    These shouldn’t be confused with JavaScript Dapp API calls that you can make in
    Geth, which you’ll learn about in Chapter [6](A433414_1_En_6_Chapter.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些全局变量仅在 Solidity 智能合约中可用。这些不应与您在 Geth 中可以进行的 JavaScript Dapp API 调用混淆，您将在第
    [6](A433414_1_En_6_Chapter.html) 章中了解有关此内容。
- en: 'block.blockhash(uint blockNumber) returns (bytes32): Hash of the given block,
    works for only the 256 most recent blocks'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'block.blockhash(uint 区块编号) 返回 (字节32): 给定区块的哈希，仅适用于最近的 256 个区块'
- en: 'block.coinbase (address): Current block miner’s address'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'block.coinbase (地址): 当前区块的矿工地址'
- en: 'block.difficulty (uint): Current block difficulty'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'block.difficulty (整数): 当前区块难度'
- en: 'block.gaslimit (uint): Current block gas limit'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: block.gaslimit（uint）：当前区块的燃气限制
- en: 'block.number (uint): Current block number'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: block.number（uint）：当前区块编号
- en: 'block.timestamp (uint): Current block timestamp'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: block.timestamp（uint）：当前区块时间戳
- en: 'msg.data (bytes): Complete call data'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: msg.data（bytes）：完整的调用数据
- en: 'msg.gas (uint): Remaining gas'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: msg.gas（uint）：剩余的燃气
- en: 'msg.sender (address): Sender of the message (current call)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: msg.sender（address）：消息的发送者（当前调用）
- en: 'msg.sig (bytes4): First 4 bytes of the call data (function identifier)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: msg.sig（bytes4）：调用数据的前4个字节（函数标识符）
- en: 'msg.value (uint): Number of wei sent with the message'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: msg.value（uint）：随消息发送的wei数量
- en: 'now (uint): Current block timestamp (alias for block.timestamp)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: now（uint）：当前区块时间戳（别名为block.timestamp）
- en: 'tx.gasprice (uint): Gas price of the transaction'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tx.gasprice（uint）：交易的燃气价格
- en: 'tx.origin (address): Sender of the transaction (full call chain) Note that
    the values of all members of msg (that is, msg.sender and msg.value) can change
    for each external function call, even if they are library functions. If you desire
    implementation of library functions with access restrictions on the use of msg.sender,
    then you’ll need to manually supply the value of msg.sender as an argument.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tx.origin（address）：交易的发送者（完整的调用链）请注意，所有msg的成员的值（即msg.sender和msg.value）在每次外部函数调用时都可能更改，即使它们是库函数。如果您希望对msg.sender的使用进行访问限制的库函数的实现，那么您将需要手动提供msg.sender的值作为参数。
- en: Operators Cheat Sheet
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符速查表
- en: Table [4-1](#Tab1) shows the operators you can use in Solidity expressions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表格[4-1](#Tab1)展示了你可以在Solidity表达式中使用的操作符。
- en: Global Functions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局函数
- en: 'In general in Solidity, special functions are mainly be used to provide information
    about the blockchain, but some can also perform mathematical and cryptographic
    functions. They are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在Solidity中，特殊函数主要用于提供关于区块链的信息，但有些也可以执行数学和密码学函数。它们如下：
- en: 'keccak256(...) returns (bytes32): Computes the Ethereum-SHA-3 (Keccak-256)
    hash of the (tightly packed) arguments'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: keccak256(...)返回（bytes32）：计算（紧密打包的）参数的以太坊-SHA-3（Keccak-256）哈希
- en: 'sha3(...) returns (bytes32): An alias to keccak256()'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sha3(...)返回（bytes32）：keccak256（）的别名
- en: 'sha256(...) returns (bytes32): Computes the SHA-256 hash of the (tightly packed)
    arguments. “Tightly packed” means that the arguments are concatenated without
    padding. To see how to add padding to arguments, see the following URL: [http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions)
    .'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sha256(...)返回（bytes32）：计算（紧密打包的）参数的SHA-256哈希。“紧密打包”意味着参数是在不添加填充的情况下连接的。要查看如何向参数添加填充，请参阅以下URL：[http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions)
    。
- en: 'ripemd160(...) returns (bytes20): Computes the RIPEMD-160 hash of the (tightly
    packed) arguments'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ripemd160(...)返回（bytes20）：计算（紧密打包的）参数的RIPEMD-160哈希
- en: 'ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): Recovers
    address associated with the public key from elliptic curve signature, returns
    0 on error'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)：从椭圆曲线签名中恢复与公钥关联的地址，在错误时返回0
- en: 'addmod(uint x, uint y, uint k) returns (uint): Computes (x + y) % k, where
    the addition is performed with arbitrary precision and does not wrap around at
    2**256'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: addmod(uint x, uint y, uint k) returns (uint)：计算（x + y）% k，其中加法精确计算且不会在2**256处截断
- en: 'mulmod(uint x, uint y, uint k) returns (uint): Computes (x * y) % k, where
    the multiplication is performed with arbitrary precision and does not wrap around
    at 2**256'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mulmod(uint x, uint y, uint k) returns (uint)：计算（x * y）% k，其中乘法精确计算且不会在2**256处截断
- en: 'this (current contract''s type): The current contract, explicitly convertible
    to its address It’s also worth mentioning contract-related variables that can
    be useful in writing Solidity contracts:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: this（当前合同的类型）：当前合同，可明确转换为其地址。还值得一提的是，在编写Solidity合同时可能有用的与合同相关的变量：
- en: 'super: The contract one level higher in the inheritance hierarchy. For more
    information about inheritance, see the link in the section below.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: super：继承层次结构中较高一级的合同。有关继承的更多信息，请参见下文中的链接。
- en: 'selfdestruct(address recipient): Destroys the current contract, sending its
    funds to the given address'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: selfdestruct(address recipient)：销毁当前合同，将其资金发送到给定地址
- en: 'assert(bool condition): throws if the condition is not met.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: assert(bool condition)：如果条件不满足，则抛出异常。
- en: 'revert(): abort execution and revert state changes'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: revert()：中止执行并恢复状态更改
- en: Exceptions and Inheritance
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常和继承
- en: Some situations automatically cause exceptions . To see them all, go to [http://exceptions.eth.guide](http://exceptions.eth.guide)
    . The Solidity language also supports multiple inheritance. Even if a contract
    inherits from multiple other contracts, only a single contract is created on the
    blockchain, the code from the base contracts is always copied into the final contract.
    Details about the general inheritance system can be found at [http://solidity.readthedocs.io/en/develop/contracts.html#inheritance](http://solidity.readthedocs.io/en/develop/contracts.html#inheritance)
    .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 某些情况会自动引发异常。要查看所有情况，请访问[http://exceptions.eth.guide](http://exceptions.eth.guide)。Solidity语言还支持多重继承。即使合同从多个其他合同继承，区块链上也只创建一个合同，基础合同中的代码始终会复制到最终合同中。有关一般继承系统的详细信息，请参阅[http://solidity.readthedocs.io/en/develop/contracts.html#inheritance](http://solidity.readthedocs.io/en/develop/contracts.html#inheritance)。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you took the first steps toward understanding the impact of
    programs written for the EVM. You also took a critical look at the way these programs
    can achieve a meaningful degree of Turing completeness without sacrificing the
    security of the network.We’ve only touched briefly on the formal mathematics that
    make these programs so exciting for enterprise information technology. But with
    any luck, you’ve seen enough to motivate you to dig deeper into the Ethereum White
    Paper and Yellow Paper and see for yourself how the EVM reaches provable consensus.In
    Chapter [5](A433414_1_En_5_Chapter.html), you’ll deploy your first token contract
    on the EVM. You’ll also learn the social and cultural history of monetary instruments,
    and what it means for your understanding of the potential of Ethereum.Footnotes[1](#Fn1_source)Smithsonian
    Education, “Revolutionary Money,” [http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html](http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html)
    , 2016.[2](#Fn2_source)Wikipedia, “Counterfeit Money,” [https://en.wikipedia.org/wiki/Counterfeit_money](https://en.wikipedia.org/wiki/Counterfeit_money)
    , 2016.[3](#Fn3_source)Investopedia, “Complementary Currency,” [www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp](http://www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp)
    , 2016.[4](#Fn4_source)New York Times, “Internet Browsers to Be Disabled on New
    York’s Free Wi-Fi Kiosks,” [www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0](http://www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0)
    , 2016.[5](#Fn5_source)Wikipedia, “Rice’s Theorem,” [https://en.wikipedia.org/wiki/Rice%27s_theorem](https://en.wikipedia.org/wiki/Rice%27s_theorem)
    , 2016.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你迈出了理解为 EVM 编写的程序影响的第一步。您还对这些程序如何在不牺牲网络安全的情况下实现一定程度的图灵完备性进行了批判性审视。我们只是简要涉及了使这些程序对企业信息技术如此令人兴奋的形式化数学。但幸运的是，您已经看到足够的动力，深入研究以太坊白皮书和黄皮书，并亲自了解
    EVM 如何达到可证实的共识。在第[5](A433414_1_En_5_Chapter.html)章中，您将在 EVM 上部署您的第一个令牌合约。您还将了解货币工具的社会和文化历史，以及这对您对以太坊潜力的理解意味着什么。脚注[1](#Fn1_source)史密森尼教育，“革命性货币”，[http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html](http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html)，2016年。[2](#Fn2_source)维基百科，“伪造货币”，[https://en.wikipedia.org/wiki/Counterfeit_money](https://en.wikipedia.org/wiki/Counterfeit_money)，2016年。[3](#Fn3_source)Investopedia，“互补货币”，[www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp](http://www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp)，2016年。[4](#Fn4_source)《纽约时报》，“纽约的免费
    Wi-Fi 亭将停用互联网浏览器”，[www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0](http://www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0)，2016年。[5](#Fn5_source)维基百科，“赖斯定理”，[https://en.wikipedia.org/wiki/Rice%27s_theorem](https://en.wikipedia.org/wiki/Rice%27s_theorem)，2016年。
