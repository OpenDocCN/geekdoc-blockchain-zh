- en: © Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_4
  prefs: []
  type: TYPE_NORMAL
- en: 4. Solidity Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chris Dannen^(1 )(1)Brooklyn, New York, USASolidity is a new programming language
    used to write programs called smart contracts, which can be run by the EVM. This
    new language is a hodgepodge of conventions from networking, assembly language,
    and web developmentImagine you’re on a beach in another country. You took a trip
    here on a whim and breezed past the currency exchange booth in the airport, figuring
    you could use your credit or debit card while visiting—no need for cash. In your
    rush, you forgot to bring sunglasses. A vendor walking along the beach has a pair
    that happen to be your style. In fact, they’re better than the pairs you remember
    passing in the duty-free area of the airport. Alas, he doesn’t have a credit card
    reader—just his Android phone—and you don’t have any local currency. He gives
    you a little card with an e-mail address and a phone number, in case you’d like
    to buy the glasses later.Think about this scenario for a moment, and you’ll see
    the power of protocol-based digital currency. Why can you send this man a text
    message or an e-mail, or even call him on the phone, but you can’t send him money
    the same way?
  prefs: []
  type: TYPE_NORMAL
- en: Primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding chapter described how the EVM transitions state, and in this
    chapter you’ll see what kind of instructions the EVM can process as it makes state
    transitions.In general, a computing environment is an infinite loop that repeatedly
    carries out whatever operation is current in the system’s program counter. (Jumping
    the queue in the program counter is where the JUMP opcodes derive their name.)
    The program counter iterates one by one until the end of that particular program
    is reached. The machine exits the execution loop only if it encounters (throws)
    an error, or hits an instruction designating the machine to STOP or RETURN a result
    or value.These operations have access to three types of space in which to store
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack , a container in which values can be added or removed (pushed or popped).
    Stack values are defined within a method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory , also known as the heap, an infinitely expandable byte array.
    This resets when the program finishes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key/value store for account balances and, in the case of contract addresses,
    Solidity code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solidity contracts can also access certain attributes about the incoming message,
    such as the value, sender, and data of the incoming message, as well as the data
    from the block header.
  prefs: []
  type: TYPE_NORMAL
- en: Global Banking Made (Almost) Real
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The banks of the world have computer systems that, while upgraded and mostly
    modern, are the descendants of machines that predate the Internet and certainly
    the World Wide Web. As a result, they’re architected to be silos. There is no
    single global banking network, but rather an interconnected mass of national systems
    and private banking software stacks, all with their own quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Extra-Large Infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A system such as Ethereum has nodes all over the world, being operated by private
    individuals who are paid for their activity in the form of mining fees, denominated
    in ether. How this works is the subject of Chapter [6](A433414_1_En_6_Chapter.html).
    The system is highly decentralized.As a result, cryptocurrency protocols have
    the power to elevate financial transactions to the level of convenience we now
    enjoy with our telecommunications. So, how does a decentralized system of peer-to-peer
    nodes run “programs,” anyway?
  prefs: []
  type: TYPE_NORMAL
- en: Worldwide Currency?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, the idea of a universal cryptocurrency seems to rest on the
    assumption that every human on Earth will eventually download a cryptocurrency
    wallet onto their cell phone. However, such a pipe dream is not the roadmap for
    Ethereum. Instead, the Ethereum Core developers have chosen to make it easy for
    third parties to create complementary currencies, or custom tokens, that will
    be branded and used for special purposes (similar to credit card rewards points
    today). These third parties (whether existing corporations, startups, municipalities,
    universities, or nongovernmental organizations) could rely upon the public chain,
    or large permissioned chains, to push around many different types of tokens, much
    the way that the global banking system is equipped to handle many different currencies.It’s
    unlikely that most people’s first experience with ether will be for the sake of
    cryptocurrency experimentation. It’s more likely they will end up holding digital
    tokens or points as part of a brand loyalty program, university program, or employer-sponsored
    system. Sports stadiums, theme parks, city summer camps, shopping malls, large
    office parks—anywhere there’s a community exchanging money, a complementary currency
    might make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Complementary Currency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why would a country ever need more than one form of money? In the decades leading
    up to the establishment of the Federal Reserve, the United States’ present-day
    central bank, many local currencies circulated. These paper bills generally represented
    gold on deposit somewhere, and were thus local by nature; a certificate for gold
    is worth little if the redeeming institution is thousands of miles away. In the
    period before widespread, systematic private money systems (a period of American
    history known as the Wildcat banking era), many printing houses made their primary
    incomes from printing money with various anticounterfeiting features to rival
    their competing printing houses.Benjamin Franklin was one such printer who enriched
    himself on the printing of complementary currencies. In fact, he was known for
    his anticounterfeiting measures that went above and beyond. According to the Smithsonian
    Institution, he once printed an official issuance of local Pennsylvania currency
    with the name of the state spelled wrong, in the hopes of foiling counterfeiters
    who assumed those bills must be fake.[¹](#Fn1) Many of Franklin’s colonial bills
    bore the words to counterfeit is death.[²](#Fn2)The term complementary currency
    refers to a medium of exchange functioning alongside national fiat currency, meeting
    a need the national coin cannot. These currencies generally have four purposes[³](#Fn3):'
  prefs: []
  type: TYPE_NORMAL
- en: To promote local economic development within a small community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build social capital in that community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To nurture more-sustainable lifestyles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To meet needs that mainstream money does not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solidity programming allows anyone to create a complementary currency, with
    a simple token contract. Those tokens can have whatever parameters the situation
    calls for, as you’ll see when you deploy a token contract in Chapter [5](A433414_1_En_5_Chapter.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Promise of Solidity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Solidity is a high-level contract-oriented language with similarities to JavaScript
    and C languages. It allows you to develop contracts and compile to EVM bytecode.
    It is currently the flagship language of Ethereum. Although it’s the most popular
    language library to be written for the EVM, it was not the first and probably
    will not be the last.There are four languages in the Ethereum protocol at the
    same level of abstraction, but the community has slowly converged on Solidity,
    which has edged out Serpent (similar to Python), Lisp-Like Language (LLL), and
    Mutan, the latter of which is deprecated.Learning Solidity enables you to move
    tokens of value in any Ethereum-based system. And because Ethereum and Solidity
    itself are free and open source technology, clever minds will likely alter and
    re-release it, or deploy it privately. In fact, several groups have already done
    just that; you’ll learn about these third parties and their approaches in later
    Chapter [11](A433414_1_En_11_Chapter.html).You can find the official Solidity
    documentation at [http://solidity.readthedocs.io/en/develop/index.html](http://solidity.readthedocs.io/en/develop/index.html)
    . However, other sites also offer useful Solidity docs. For convenience, all the
    most popular Solidity documentation is linked under the [http://solidity.eth.guide](http://solidity.eth.guide)
    subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: Browser Compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to test Solidity is by using the browser-based compiler.
    It can be found at [http://ethereum.github.io/browser-solidity](http://ethereum.github.io/browser-solidity)
    . For quick reference, you’ll also find it at [http://compiler.eth.guide](http://compiler.eth.guide)
    .If you’ve read this far, you might already be curious about how to learn Solidity
    yourself. Although it’s certainly easier to begin programming in Solidity if you
    already know another programming language, don’t let this discourage you if you’re
    a nonprogrammer.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to Program the EVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it’s easier to learn a new habit than to break an old one. Many conventions
    in distributed application programming will strike today’s web and native application
    programmers as odd or quirky. Plus, they may already be professionally or personally
    invested in other languages or subject areas. So don’t feel like the whole world
    has a head start on you if you’re just starting out. It is still early days in
    the world of Ethereum.NoteKey programming terms will be defined as we go, and
    you’ll pick up a lot from the context. Try looking through a JavaScript book aimed
    at beginners ([http://​www.​apress.​com/​us/​book/​9781484217863](http://www.apress.com/us/book/9781484217863))
    for a deeper explanation of some of the core concepts in this chapter.New coders
    can approach Ethereum without preexisting assumptions. Better yet, they’ll find
    a system they can (admittedly, after some time) understand from top to bottom.
    Not all hackers, nor even software engineers, know the intricacies of the underlying
    networks in the layers below their application hosting provider.In conventional
    web applications, you have many individual servers with databases, communicating
    and sharing data over a network. This data may be manipulated by applications
    that live on still other servers. Even more servers may be in the mix to balance
    surges in demand.NoteA server is a computer that acts in a dedicated role, as
    part of a certain kind of service you want to offer people via the Web. Some servers
    hold data (think of spreadsheets of information, such as customer names and addresses)
    in what are known as databases. Some servers run applications that other computers
    can access over the network.In Ethereum, the network is the database, and this
    network can run applications available to everyone on it. So you end up learning
    quite a bit about all three.Watching a blockchain explorer report new transactions
    is something of a marvel when you know what’s happening underneath. Although learning
    Ethereum may seem like a lot of work, it would be much more work to understand
    today’s Web with a similar breadth and depth.The following subsections present
    other reasons you should begin experimenting with Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: Easy Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ethereum, you don’t necessarily have much of the hassle of deploying and
    scaling a normal web application. All the required smart contracts for the back-end
    of distributed app, also known as a dapp, can be neatly bundled up in a few documents
    and sent to the EVM, and boom—your program is available instantly to anyone on
    Earth who installs an Ethereum wallet or command-line node. Today, developers
    may want to build “hybrid” Ethereum dapps that are accessible through normal Web
    browsers, in which case adding ether payments is just adding more work. But by
    the time the network is complete in 2-3 years, it will be able to far easier to
    host all the components of an application using the Ethereum protocol.NoteIn business
    jargon, time to value, or TTV, is the amount of time that passes from the moment
    the customer requests something to the moment the customer gets it. This something
    can be tangible or intangible. But a low TTV suggests that it is easy to think
    up a product or service and deliver it quickly to the people who want to use it.In
    Ethereum, it is fast and inexpensive (if not yet easy) to develop and deploy unalterable,
    always-up, uncensorable applications that move real value over arbitrary distances.
    And everything is free, except the gas costs generated by your programs, and your
    own time (and computer). For software engineers, service providers, system administrators,
    and product managers, the long-term impact of working in the Ethereum ecosystem
    means less brittle systems, faster product iterations, and far less time developing
    infrastructure to support new applications or services. In short, this may amount
    to a drastic reduction in TTV for enterprise software vendors and in-house teams
    alike.
  prefs: []
  type: TYPE_NORMAL
- en: The Case for Writing Business Logic in Solidity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of its novel characteristics, the fate of Ethereum in 2017 and beyond
    doesn’t necessarily rest on the mainstream popularity or adoption of today’s Ethereum
    clients. Instead, it relies on popularity with developers, brands, corporations,
    organizations, governments, and other institutions that are in a position to create
    an Ethereum token for their community, and perhaps even their own branded wallet.They
    might do so in the interest of quickly and safely rolling out cool new products
    and services with ultra-low overhead. This also goes for large marketing campaigns,
    which must be deployed faster and faster today to keep up with the speed of Internet
    meme culture. The frictionless nature of the payments in cryptonetworks makes
    it easier than ever to build a seamless sales and marketing experience for customers,
    with payments built in.A complementary currency is also a highly valuable tool
    for use in rewards programs, membership clubs, and large retail districts. Customers
    who hold money in the form of a branded coin are apt to spend more regularly on
    that brand, just as frequent flyers today stay loyal to the airline miles and
    credit-card point schemes that give them the best bang for the buck.Today, loyalty
    programs can be obscure and even slightly scammy. But the transparency of a blockchain-based
    loyalty coin would make it as good as any other form of cryptocurrency—meaning
    it might be traded on exchanges or accepted by other parties as payment.
  prefs: []
  type: TYPE_NORMAL
- en: Code, Deploy, Relax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Ethereum-enabled applications might be used through the Mist wallet, or
    another Ethereum-native application running a node under the hood. For developers
    of client applications, adding compatibility with new Ethereum-based tokens is
    trivial, meaning that a high degree of overlap and intercompatibility will exist
    between Ethereum wallets and tokens, just as there are many IMAP- and POP-compatible
    e-mail clients today.It’s also possible to create an Ethereum program today that
    is accessible through the regular old Web, with a little bit of work. However,
    deployment will be made increasingly easy with the use of new third-party frameworks,
    examples of which are provided in Chapter [8](A433414_1_En_8_Chapter.html).However,
    this isn’t to say that conventional web apps will go away. Many individuals and
    organizations have enormous resources invested in legacy web apps. That said,
    the Ethereum network makes it far easier and cheaper to roll out and operate applications
    at large scale, as you’ll see, tempting more and more teams to consider decentralizing
    their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Design Rationale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Solidity programming language has a syntax like JavaScript, but it is specially
    designed to compile into bytecode for the Ethereum Virtual Machine. As noted in
    Chapter [3](A433414_1_En_3_Chapter.html), the EVM runs code that is fully deterministic;
    the same algorithms with the same inputs will always yield the same results. You
    can prove this mathematically, as you’ll see later in this chapter.Solidity is
    statically typed, supports inheritance, libraries, and complex user-defined types,
    among other features. Conscientious use of types can help programmers understand
    how their programs will execute. A list of types in Solidity is presented at the
    end of this chapter.NoteData types are exactly what they sound like. A programmer
    has the option of telling the machine what type of data to expect: for example,
    will it be a number or a string of letters? Loosely typed languages don’t require
    the programmer to be specific; strongly typed languages do.Interestingly, in Solidity
    you can write assembly code inline. If you prefer to do a certain operation by
    using one of the EVM’s opcodes, listed in Chapter [3](A433414_1_En_3_Chapter.html),
    you can do so inline in your Solidity contracts. Just write assembly {...} with
    your code in place of a Solidity statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Loops in Solidity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops are foundational to control flow in programming—that is, the codification
    of if-this-then-that contingencies or do-this-while-doing-that concurrencies.
    In most programming languages, loops are initiated with similar syntax. Solidity
    adheres to all the same syntactical regularities as JavaScript and C when it comes
    to loops.An iterator loop is an object that enables a programmer to move through
    a container or list. Sometimes, iterators are used to instruct the computer to
    perform the same operation a certain number of times, or on a number of elements
    in the code.A general-purpose loop has the same syntax in JavaScript, C, and Solidity.
    It instructs the computer to count up from 0 to 10:for (i = 0; i < 10; i++) {...}If
    you looked carefully at the list of opcodes in the preceding chapter, you may
    have noticed that the EVM allows looping in two ways. You can write loops in Solidity,
    or you can create them using JUMP and JUMPI instructions. This jumps ahead a specified
    number of steps in the program counter. Recall that the program counter keeps
    track of the number and order of computational steps in a given program as it
    is being executed on the EVM.This is just one way that Solidity and EVM opcodes
    can be used together to create a contract that is mostly expressive and readable,
    but also cheap to run. It’s important to point out that because of the way gas
    price is calculated, some functionality might be easier to enforce or less expensive
    to execute if written using opcodes, and this can be especially useful if you’re
    writing your own language library.If you’ve never looked seriously at code before,
    and this loop concept is hard to grasp, don’t sweat it now; the following sections
    provide more context.
  prefs: []
  type: TYPE_NORMAL
- en: Expressiveness and Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The adjective expressive is used in computer science to mean code that is easy
    for a human programmer to write and to understand. Expressive languages are the
    bridge between human thought patterns and machine execution patterns. For a language
    to be expressive, its various constructs must be intuitively readable, and its
    boilerplate code (such as keywords, special variables, and opcodes) must use human-readable
    words that help programmers remember what they represent.Expressive languages
    must be compiled down into something more machine-friendly before they can be
    run, and this requires work on the part of the computer. After all, expressive
    languages tend to be harder to reason about (harder to predict the behavior of),
    whereas more-restricted, lower-level, less-abstract languages make that reasoning
    easier.The final frontier is smart contracts that can be easily formally verified,
    but also written in an expressive high-level language such as Solidity. This problem
    begs for automation, and indeed, automated formal verification is now on the horizon—a
    fact that computer scientists must be excited about, and that Ethereum developers
    will unknowingly benefit from.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Formal Proofs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you learn Solidity programming, you may encounter the curiosity of other
    developers, who will get right to the point: how do you prevent someone writing
    an infinite loop and locking up the machine?Far from being a niche argument, this
    is the most relevant issue related to software engineering’s role in the world
    today: can human beings make a free, openly accessible virtual computer that other
    human beings can’t sabotage? If the answer is yes, then it stands in stark defiance
    of the theory of the tragedy of the commons.'
  prefs: []
  type: TYPE_NORMAL
- en: Historical Impact of a Shared Global Resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In economics, the tragedy of the commons is the idea that a shared resource
    can’t last. Eventually, users acting in their own self-interests will deplete
    the resource, because it comes at no cost to themselves to do so. A scenario like
    this, whereby someone can enrich themselves or act profligately while externalizing
    the costs to other people, is known as a moral hazard.Here’s an example: In New
    York City in late 2016, the municipal government installed computing terminals
    on the streets of Lower Manhattan. These terminals offered free Wi-Fi to passing
    pedestrians. However, these terminals also came with a small touchscreen allowing
    walk-up Internet access. No sooner were these shared resources up and running
    before people were pulling up chairs, watching YouTube or pornography, and loitering
    for hours.[⁴](#Fn4) Program administrators were forced to quickly restrict the
    onscreen Internet access, and now the terminals serve mostly as just Wi-Fi hotspots.Thus,
    the notion of an extremely inexpensive public computer such as the EVM is nothing
    short of fantastic. It can be accessed by anyone, with any computer, anywhere,
    and will run programs far into the future. Nobody owns it and nobody can tamper
    with it. It can even store your money for you.'
  prefs: []
  type: TYPE_NORMAL
- en: How Attackers Bring Down Communities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decentralized economies represent a nascent threat to all sorts of private vested
    interests around the world, especially in developing economies, where powerful
    people would prefer the world continue on without a solution to the tragedy of
    the commons (and thus, remain at the mercy of the latest autocrat or crazy mob).
    The security of the Ethereum network is the subject of Chapter [7](A433414_1_En_7_Chapter.html).
    But Ethereum’s defenses are everywhere, even in the programming language itself,
    so it bears mention here.For this discussion, you can think of a network as a
    community of people connecting with each other via computer. An attacker is someone
    who hates this group, and seeks to cause them grief at any expense.
  prefs: []
  type: TYPE_NORMAL
- en: Hypothetical Attack Written in Solidity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that an attacker wants to lock up the EVM with a super memory-intensive
    smart contract, written in Solidity. The attacker is willing to pay the gas costs,
    however large. (This is a real scenario, as you’ll see in Chapter [7](A433414_1_En_7_Chapter.html).)
    Keep in mind that for the purposes of this example, the contract could also be
    written in any language created for the EVM, such as Serpent or even the lower-level
    EVM code, not just Solidity.According to Rice’s theorem , the behavioral properties
    of some computer programs are mathematically undecidable, meaning it is not possible
    to write another computer program that can definitively predict whether Solidity
    code you show it will ever terminate.[⁵](#Fn5) Thus, there is no way to write
    any kind of effective “gatekeeper” program that will swat down a hypothetically
    memory-hungry smart contract written by the attacker in this scenario.NoteSmart
    contracts are distinct from distributed applications, or dapps, even though both
    are distributed and application-like. A dapp is a GUI application that uses Ethereum
    smart contracts on the back end, in lieu of a conventional database and web application
    hosting provider. Dapps may be accessed through the Mist browser or over the Web.The
    EVM deals with this reality in various ways, including a hard limit on the number
    of computational steps per block, its deterministic language, and gas costs. Nevertheless,
    gray areas will always be explored by attackers if a financial incentive exists,
    and at $1 billion market capitalization, there’s significant incentive to crack
    the EVM and steal ether.Although gray areas can’t be engineered away at once,
    they can be dealt with in a series of protocol forks over time. As far as accidentally
    destructive programs, it’s up to the Ethereum community to develop patterns and
    practices that are conducive to straightforward, easy-to-prove contracts that
    can develop into boilerplate standards. Chapter [5](A433414_1_En_5_Chapter.html)
    covers some of these best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Proofs to the Rescue?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it’s not possible to create a gatekeeper that kicks out bad programs,
    it is increasingly feasible to produce provably correct programs by using a machine-checkable
    proof—an automated program that mathematically proves other programs.Because smart
    contracts move money, they make great lab rats for automated mathematical proofs.
    The goal of this area of computer science and mathematics research is to ensure,
    in a systematic way, that source code satisfies a certain formal specification.
    It’s a way for independent auditors to come in and mathematically verify that
    the program is actually doing what it’s supposed to do.Automating the proving
    process is a boon for businesses but won’t do much for the average programmer
    learning Solidity. Proofs merely show you whether what you intended to happen
    actually did happen in the program. If your program doesn’t prove out, there is
    no way for an automated system to tell you how to write it better.Nevertheless,
    the point of exploring this topic is to signal that Ethereum networks may indeed
    one day carry high volumes of automated money-moving bots pushing around trillions
    of dollars safely; and that developing these bots may not be as slow, risky, and
    obscure a process as it is today.
  prefs: []
  type: TYPE_NORMAL
- en: Determinism in Practice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Combining the concepts from the preceding sections, you can see that in some
    ways, the whole idea of Turing completeness may be an idealized concept of limited
    usefulness when designing a public system in the real world.Thus, it could also
    be said that in practice, the EVM is not really Turing complete, because the bounded
    nature of execution in Solidity contracts could soon make it possible to theoretically
    predict the behavior of any program the EVM will run.Bitcoin escapes none of these
    issues. The gray areas that exist between expressive languages and machine languages
    exist for Bitcoin’s scripting language too, which is also compiled down at runtime
    into machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Lost in Translation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interestingly, the question of proofs has a lot to do with the concept of expressiveness,
    discussed earlier in this chapter. A human can perform a mathematical proof on
    only a high-level, abstract language—that is, a human-readable programming language
    such as Solidity. Performing such a proof on assembly code or machine code would
    be next to impossible for even the most dedicated mathematical minds.The compilation
    process—the transmission of human-readable code into lower-level machine code—sacrifices
    a lot of (human interpretable) information about how to reason about the program.
    It also sacrifices information that would be useful to an automated theorem prover.
    Thus, some ambiguity is always introduced into the process. Today, you can never
    be fully sure that even a mathematically proven smart contract written in Solidity
    will still be provable after being compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Testing, Testing, Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way to prevent ambiguous code from losing your money is to test vigorously.
    The Ethereum network comes with a testnet called Ropsten that uses play ether,
    which costs nothing and can be drawn from a faucet quickly in a sandbox-like environment.In
    reality, Ropsten is no different from the main chain. It is simply a different
    chain that was designated for testing. Like the Titanic and its sister ship the
    Britannic, they are identical except for the names, as is every other chain someone
    spins up. There is nothing special or sanctified about these chains; you will
    create chains just like them in Chapter [8](A433414_1_En_8_Chapter.html).
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Optional !
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keep in mind that most of the important functions of Ethereum can be done in
    the Mist wallet: sending and receiving ether, tracking tokens, and deploying contracts.
    Using Geth (or the other command-line clients) is a good choice for developers
    who intend to learn to write dapps. Chapter [6](A433414_1_En_6_Chapter.html) deals
    more with Geth.In this section, we will look briefly at a real smart contract,
    to explore one simple example of how a smart contract can be used.NoteIf you can’t
    read or write code, don’t worry. A tutorial on syntax and structure follows this
    example that will help you reason about what the code is doing. In the next chapter,
    we’ll deploy a standard Ethereum token, with zero coding required.You’ll learn
    how to deploy a contract like this in Chapter [5](A433414_1_En_5_Chapter.html).
    You’ll be pleased to learn that there are only three requirements for deploying
    a simple contract in Solidity:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.A text editor such as TextEdit on macOS, Gedit on Ubuntu, or Notepad on Windows.
    Be sure to switch to plain-text mode, which strips away all fonts, underlining,
    bold, hyperlinks, and italics. (Never use rich text to write code!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.The Mist wallet, covered in Chapter [2](A433414_1_En_2_Chapter.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3.The Browser Solidity Compiler located at [https://ethereum.github.io/browser-solidity/](https://ethereum.github.io/browser-solidity/)
    or available at the following shortlink:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: http://compiler.eth.guideAs we’ll demonstrate in Chapter [5](A433414_1_En_5_Chapter.html),
    all that you need to do to “upload” a contract is to copy-paste your Solidity
    code from your text editing application into the Solidity Browser Compiler. From
    there, you’ll compile the code into bytecode, and copy-paste that bytecode into
    Mist. It’s really very easy, but let’s not get bogged down in the logistics just
    yet. Instead, we’ll examine the behavior of the sample smart contract below, so
    you can begin to grasp the potential of an automated contract which sends and
    receives money. The following example was originally written by Cyrus Adkisson
    (fivedogit on GitHub), a Kentuckian software engineer and Ethereum enthusiast
    now living in New York. It has been adapted for this book.You’ll name this contract
    PiggyBank, using CapsCase (rather than camelCase) per the Solidity naming conventions.
    You can find those naming conventions, and the rest of the Solidity style guide,
    at [http://solidity.readthedocs.io/en/develop/style-guide.html](http://solidity.readthedocs.io/en/develop/style-guide.html)
    .Now, let’s look at PiggyBank.sol:contract PiggyBank {       address creator;       uint
    deposits;// Declaring this function as public makes it accessible to other users
    and smart contracts.       function PiggyBank() public       {           creator
    = msg.sender;           deposits = 0;       }// Check whether any ether has been
    deposited. When it is deposited, the number of deposits go up and the total count
    is returned       function deposit() payable returns (uint)       {           if(msg.value
    > 0)                deposits = deposits + 1;           return getNumberOfDeposits();       }       function
    getNumberOfDeposits() constant returns (uint)       {           return deposits;       }//
    When the external account that instantiated this contract calls it again, it terminates
    and sends back its balance.       function kill()       {           if (msg.sender
    == creator)               selfdestruct(creator);       }}You can find more examples
    of Solidity scripts for programmers of all skill levels and abilities at [http://solidity.eth.guide](http://solidity.eth.guide)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Solidity Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One major detail is missing from the preceding contract example. Every Solidity
    file should have (but does not require) a version pragma, a statement indicating
    which Solidity version this contract was written in. Over time, this should prevent
    older contracts from being rejected by future versions of the compiler.The version
    pragma for this file is 0.4.7, so you should add the following to the file header:pragma
    solidity ^0.4.7;For more information on the structure of Solidity files, see [http://solidity.readthedocs.io/en/develop/layout-of-source-files.html](http://solidity.readthedocs.io/en/develop/layout-of-source-files.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Tips for Reading Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are seven facts that will make this contract more legible for beginners:'
  prefs: []
  type: TYPE_NORMAL
- en: Computers read code from top to bottom, left to right, just like English speakers.
    Putting one line before another generally means the computer will see that instruction
    first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, programs take an input and return some kind of output. Computable
    functions (mathematical functions that can be performed by a computer) are defined
    as functions that can be written as algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms take in data, perform an operation on it, and return some kind of
    output. Programs are algorithms with other algorithms nested in them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An algorithm is like a machine: you can reuse it many times. Thus, writing
    algorithmic instructions—programming—will strike you as being a lot like writing
    Mad Libs, which the computer will later autocomplete with information that a user
    (or in Ethereum, a contract) gives it, via a transaction or message call. Sometimes
    this information is just a number (for example, 5 ether).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators are the symbols between the English words, such as the equal sign,
    plus sign, and minus sign. These work mostly as you’d expect, with a few exceptions.
    You’ll see Solidity operators in Table [4-1](#Tab1).Table 4-1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Precedence | Description | Operator |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | Postfix increment and decrement | ++, -- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Function-like call | <func>(<args...>) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Array subscripting | <array>[<index>] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Member access | <object>.<member> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Parentheses | (<statement>) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | Prefix increment and decrement | ++, -- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Unary plus and minus | +, - |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Unary operations | delete |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Logical NOT | ! |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Bitwise NOT | ∼ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 | Exponentiation | ** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 | Multiplication, division, and modulo | *, /, % |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 | Addition and subtraction | +, - |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 | Bitwise shift operators | <<, >> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 | Bitwise AND | & |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 | Bitwise XOR | ^ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 | Bitwise OR | &#124; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 | Inequality operators | <, >, <=, >= |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 | Equality operator, does-not-equal operator | ==, != |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 | Logical AND | && |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 | Logical OR | &#124;&#124; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 | Ternary operator | <conditional> ? <if-true> : <if-false> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 | Assignment operators | =, &#124;=, ^=, &=, <<=, >>=, +=, -=, *=, /=,
    %= |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 | Comma operator | , |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Types are the nouns of computer programming. So when you see a type, you know
    what is allowed in that space of the Mad Lib. A common type in Solidity is an
    address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The original use of computers was to do math quickly. For decades, the people
    who used computers were mostly physicists who wanted to crunch hard math problems
    in order to figure out answers to questions such as this: What time and day is
    the best to launch Apollo 11, so that it has the shortest distance to travel to
    the Moon?The EVM is much closer to this original kind of computer, but it’s suited
    to thinking about sophisticated accounting and fiscal reconciliation, as you might
    learn to do in business school by programming spreadsheets in Microsoft Excel.
    Recall that databases are merely spreadsheets themselves, and computer programs
    manipulate these databases. Thus, when you declare something, you are telling
    the computer to put it in the spreadsheet—specifically, to put it in the stack.The
    computer will figure out, on its own, how much memory to have ready to store the
    values in any temporary, or so-called dynamic, computations—small, pivotal logical
    statements used to compute contingencies such as if-then. (It’s important to define
    the stack and heap in order to see that this is where the danger of memory-hog
    programs lies: in asking the computer to use more dynamic memory than it has to
    spare.)'
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Expressions in Solidity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ll see, there are functions all over the place in Solidity. However,
    they’re used in different ways.Some functions produce a value, such as a number,
    or an answer to a true/false question. What exactly this value can be is determined
    by Solidity’s types, mentioned earlier; the true/false value is called a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Expression?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions that produce a value are known as expression functions . Because expressions
    evaluate to a value of one type or another, in programming they can be used in
    place of values.Other functions are declarative, and lead to the creation of a
    dedicated space in the computer’s memory, which will be used each time it runs
    this routine. These declarative functions are important because they are crucial
    to writing statements.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Statement?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking in grossly general terms, a statement tells the computer to perform
    an action. The computer uses expressions to figure out how to take this action,
    and when. Thus, computer programs are composed of statements, and statements are
    often composed of expressions (or other statements).
  prefs: []
  type: TYPE_NORMAL
- en: Functions , Public and Private
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript and Solidity, you can use semicolons to chain statements, and
    tell the computer that another statement is coming up in the code:function first();
    function second()In Solidity, you can also declare whether you want certain functions
    to be available outside that program. These designations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'public: Visible externally and internally (an accessor function for storage/state
    variables is created)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'private: Visible only in the current contract (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoteFunctions written in Solidity code are not public by default. You must declare
    them as public when you make them, or they will not be available to contracts
    outside of the one they’re in.Although this is just an introduction to code literacy,
    it should be enough for you to begin to decode what some of the smart contracts
    we’ll discuss later are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Value Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing Solidity code, you can tell the computer what type of value to
    expect in each algorithmic instruction. This section describes the types of values
    the EVM can interpret.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Known in code as bool, the Booleans are true/false expressions that evaluate
    to true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Signed and Unsigned Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Known in code as int and uint, these are numbers. They can be negative if they
    have a sign, or minus, indicating they are signed. Unsigned integers are thus
    positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The address type holds a 20-byte value, which is the size of an Ethereum address
    (40 hex characters, or 160 bits). Address types also have member types.
  prefs: []
  type: TYPE_NORMAL
- en: Members of Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These two members allow you to query the balance of an account, or to transfer
    ether to an account. Be careful with transfer in smart contracts. It’s better
    to use a pattern where the recipient is allowed to withdraw the money, than to
    have a contract initiating transfers.
  prefs: []
  type: TYPE_NORMAL
- en: balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address-Related Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keywords come with the Solidity language. They are methods, so to speak, for
    using the language in predetermined ways. You can use these keywords in your code
    to accomplish common tasks needed in smart contracts. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '<address>.balance (uint256): Returns the balance of the [address](http://solidity.readthedocs.io/en/develop/types.html)
    in wei'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<address>.send(uint256 amount) returns (bool): Sends given amount of wei to
    [address](http://solidity.readthedocs.io/en/develop/types.html), and returns false
    on failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'this(current contract’s type): Explicitly converts to the address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'selfdestruct(address recipient): Destroys the current contract, sending its
    funds to the given [address](http://solidity.readthedocs.io/en/develop/types.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoteIt is possible to query the balance of the current contract by using the
    keyword this.balance.
  prefs: []
  type: TYPE_NORMAL
- en: Less-Common Value Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several other value types may be useful if you’re already an advanced or intermediate
    programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically sized byte arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rational and integer literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex (Reference) Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generally speaking, types in Solidity are allotted 256 bits of memory in the
    EVM’s storage; that’s 2,048 characters. Types that are any longer than that can
    incur more-significant gas costs to move around. You’ll need to choose carefully
    when assigning persistent storage in the EVM’s stack. Here are the complex types
    that exceed 256 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array literals / inline arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays, structs, and other complex types have a data location that can be used
    by Solidity programmers to manipulate whether they are stored dynamically in memory
    or persistently stored. This can help you manage fees.
  prefs: []
  type: TYPE_NORMAL
- en: Global Special Variables, Units, and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global special variables can be called by any Solidity smart contract on the
    EVM; they’re built in to the language. Most of them return information about the
    Ethereum chain. Units of time and ether are also globally available. Literal numbers
    can take a suffix of wei, finney, szabo or ether and will auto-convert between
    subdenominations of Ether. Ether currency numbers without a suffix are assumed
    to be Wei.Time-related suffixes can be used after literal numbers to convert between
    units of time. Here, seconds are the base unit, and units are treated as general
    units. Owing to the existence of leap years, be careful when using these suffixes
    to calculate time, as not all years have 365 days, and not days have 24 hours.
    1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours
    1 weeks = 7 days 1 years = 365 days
  prefs: []
  type: TYPE_NORMAL
- en: Block and Transaction Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these global variables are only available in Solidity smart contracts.
    These shouldn’t be confused with JavaScript Dapp API calls that you can make in
    Geth, which you’ll learn about in Chapter [6](A433414_1_En_6_Chapter.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'block.blockhash(uint blockNumber) returns (bytes32): Hash of the given block,
    works for only the 256 most recent blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'block.coinbase (address): Current block miner’s address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'block.difficulty (uint): Current block difficulty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'block.gaslimit (uint): Current block gas limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'block.number (uint): Current block number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'block.timestamp (uint): Current block timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'msg.data (bytes): Complete call data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'msg.gas (uint): Remaining gas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'msg.sender (address): Sender of the message (current call)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'msg.sig (bytes4): First 4 bytes of the call data (function identifier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'msg.value (uint): Number of wei sent with the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'now (uint): Current block timestamp (alias for block.timestamp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'tx.gasprice (uint): Gas price of the transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'tx.origin (address): Sender of the transaction (full call chain) Note that
    the values of all members of msg (that is, msg.sender and msg.value) can change
    for each external function call, even if they are library functions. If you desire
    implementation of library functions with access restrictions on the use of msg.sender,
    then you’ll need to manually supply the value of msg.sender as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators Cheat Sheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Table [4-1](#Tab1) shows the operators you can use in Solidity expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Global Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general in Solidity, special functions are mainly be used to provide information
    about the blockchain, but some can also perform mathematical and cryptographic
    functions. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'keccak256(...) returns (bytes32): Computes the Ethereum-SHA-3 (Keccak-256)
    hash of the (tightly packed) arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sha3(...) returns (bytes32): An alias to keccak256()'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sha256(...) returns (bytes32): Computes the SHA-256 hash of the (tightly packed)
    arguments. “Tightly packed” means that the arguments are concatenated without
    padding. To see how to add padding to arguments, see the following URL: [http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ripemd160(...) returns (bytes20): Computes the RIPEMD-160 hash of the (tightly
    packed) arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): Recovers
    address associated with the public key from elliptic curve signature, returns
    0 on error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'addmod(uint x, uint y, uint k) returns (uint): Computes (x + y) % k, where
    the addition is performed with arbitrary precision and does not wrap around at
    2**256'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mulmod(uint x, uint y, uint k) returns (uint): Computes (x * y) % k, where
    the multiplication is performed with arbitrary precision and does not wrap around
    at 2**256'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'this (current contract''s type): The current contract, explicitly convertible
    to its address It’s also worth mentioning contract-related variables that can
    be useful in writing Solidity contracts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'super: The contract one level higher in the inheritance hierarchy. For more
    information about inheritance, see the link in the section below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'selfdestruct(address recipient): Destroys the current contract, sending its
    funds to the given address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'assert(bool condition): throws if the condition is not met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'revert(): abort execution and revert state changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions and Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some situations automatically cause exceptions . To see them all, go to [http://exceptions.eth.guide](http://exceptions.eth.guide)
    . The Solidity language also supports multiple inheritance. Even if a contract
    inherits from multiple other contracts, only a single contract is created on the
    blockchain, the code from the base contracts is always copied into the final contract.
    Details about the general inheritance system can be found at [http://solidity.readthedocs.io/en/develop/contracts.html#inheritance](http://solidity.readthedocs.io/en/develop/contracts.html#inheritance)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you took the first steps toward understanding the impact of
    programs written for the EVM. You also took a critical look at the way these programs
    can achieve a meaningful degree of Turing completeness without sacrificing the
    security of the network.We’ve only touched briefly on the formal mathematics that
    make these programs so exciting for enterprise information technology. But with
    any luck, you’ve seen enough to motivate you to dig deeper into the Ethereum White
    Paper and Yellow Paper and see for yourself how the EVM reaches provable consensus.In
    Chapter [5](A433414_1_En_5_Chapter.html), you’ll deploy your first token contract
    on the EVM. You’ll also learn the social and cultural history of monetary instruments,
    and what it means for your understanding of the potential of Ethereum.Footnotes[1](#Fn1_source)Smithsonian
    Education, “Revolutionary Money,” [http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html](http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html)
    , 2016.[2](#Fn2_source)Wikipedia, “Counterfeit Money,” [https://en.wikipedia.org/wiki/Counterfeit_money](https://en.wikipedia.org/wiki/Counterfeit_money)
    , 2016.[3](#Fn3_source)Investopedia, “Complementary Currency,” [www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp](http://www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp)
    , 2016.[4](#Fn4_source)New York Times, “Internet Browsers to Be Disabled on New
    York’s Free Wi-Fi Kiosks,” [www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0](http://www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0)
    , 2016.[5](#Fn5_source)Wikipedia, “Rice’s Theorem,” [https://en.wikipedia.org/wiki/Rice%27s_theorem](https://en.wikipedia.org/wiki/Rice%27s_theorem)
    , 2016.
  prefs: []
  type: TYPE_NORMAL
