- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_4](https://doi.org/10.1007/978-1-4842-7480-4_4)
  prefs: []
  type: TYPE_NORMAL
- en: 4. Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin blockchain model has proved to be a paradigm valid for cryptocurrencies,
    which has led to increased interest and study about blockchain in various fields
    of application.
  prefs: []
  type: TYPE_NORMAL
- en: Vitalik Buterin realized the potential of the blockchain model early on. He
    saw it as much more than a platform for cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: A passion for Bitcoin led him to found, at the age of 17, together with Mihai
    Alisie, *Bitcoin Magazine*, a site and print magazine covering topics related
    to Bitcoin. Vitalik quickly realized that blockchain technology could do much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, he declared that Bitcoin needed a language of scripting for the development
    and creation of *decentralized applications.*
  prefs: []
  type: TYPE_NORMAL
- en: Failing to convince the community, he began developing a new distributed information
    platform, based on technology blockchain. Thus, Ethereum was born on July 30,
    2015, and it introduced a new feature called *smart contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: A new generation of blockchain was inaugurated, and to date it’s still the most
    prominent—Blockchain 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the image shown in Figure [4-1](#Fig1), in which Bitcoin and Ethereum
    are compared. On the left is Bitcoin, to which top of the stack is the Wallet
    application through which money transfer operations are made. To the right is
    Ethereum, which changed the blockchain into a computational system framework or
    architecture and opened a full world of opportunities in the decentralized realm.
    Note that Ethereum supports smart contracts and the machine virtual EVM on which
    these run. Smart contracts, in turn, enable decentralized applications that accomplish
    more of a transfer of value. In this way, a level of logic and calculation is
    added to the blockchain.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-1
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin vs. Ethereum stacks
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum users can not only transfer digital money through transactions, but
    they can develop smart contracts that allow them to perform transactions under
    certain conditions. For all intents and purposes, they can set conditions on the
    ways in which the value is transferred. Understandably, the idea of “programmable
    money” has attracted users, developers, and companies all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, developers can implement and create applications that operate in
    the distributed network of the Ethereum blockchain, the DAPPs (decentralized applications).
  prefs: []
  type: TYPE_NORMAL
- en: With Ethereum, the blockchain becomes a decentralized IT platform where, in
    addition to transferring digital money, it is possible to distribute new applications
    and interact with other users of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone can write a new application to run on the network blockchain, instead
    of on a centralized server. This does not only require overcoming any kind of
    censorship by a central authority, but is also immune to changes and allows all
    users to check the code before interacting with it.
  prefs: []
  type: TYPE_NORMAL
- en: With Ethereum, blockchains are certainly not limited to the financial sector;
    they can also include electoral systems, registration of domain names, crowdfunding
    platforms, and intellectual properties, to name just a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Ethereum is a revolutionary and far-sighted project, which in addition
    to being recognized as one of the best online investments, brought world fame
    to the young founder of the Ethereum network. This invention was awarded the prestigious
    World Technology Award in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter goes into detail about the components and techniques that define
    the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Blockchain as a State Transition System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Ethereum blockchain* is an open-source public blockchain. The model implemented
    by Ethereum can be summarized by three definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptographically secure:** The information security present in the ledger
    is guaranteed by complex mathematical algorithms and difficult to break cryptography.
    In other terms, it is almost impossible to cheat the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactional singleton machine:** There is, by construction paradigm, a
    single canonical instance of the machine responsible for all transactions that
    are generated in the system. There is one global truth that everyone believes
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**With shared-state:** The state stored in this machine is shared and accessible
    by all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, the Ethereum blockchain paradigm is that of a cryptographically secure,
    shared-state transactional singleton machine. The Ethereum blockchain is essentially
    a state machine based on transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A state machine  is a graph of states and transitions.
  prefs: []
  type: TYPE_NORMAL
- en: A state describes a period of time in the life of an object and is represented
    by vertices or *nodes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transition connects two states together and is represented with a oriented
    arc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exit from a state defines the response of the object to the occurrence of
    an event. An event is the recurrence of a phenomenon placed in time and in space.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, a state machine is an automaton which, based on a series of input data,
    changes its internal state. (See Figure [4-2](#Fig2).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-2
  prefs: []
  type: TYPE_NORMAL
- en: Example of a finite state machine
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, you can deduce:'
  prefs: []
  type: TYPE_NORMAL
- en: The status of the blockchain as the set of transactions present in the ledger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event in the blockchain such as the creation of a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction function in the blockchain that takes on a state and new transaction
    and generates a new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let S be a state, TX a transaction, and APPLY the function of state transition.
    It can be formally defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '*APPLY (S; TX) -> S0 or ERROR*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Ethereum’s state machine begins with a state of genesis, analogous
    to an empty list before transactions have been made on the network.
  prefs: []
  type: TYPE_NORMAL
- en: To cause a transition from one state to another, a transaction must be valid.
    When the various transactions are performed, this state of genesis passes from
    time to time to a subsequent state. (See Figure [4-3](#Fig3).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-3
  prefs: []
  type: TYPE_NORMAL
- en: Transitions of states based on transactions
  prefs: []
  type: TYPE_NORMAL
- en: At any point in the junction, the final state represents the overall state of
    Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: The overall status of Ethereum contains transactions. Such transactions are
    grouped into blocks. Each block contains a number of transactions and is chained
    to the previous block. See Figure [4-4](#Fig4).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-4
  prefs: []
  type: TYPE_NORMAL
- en: Transaction flow
  prefs: []
  type: TYPE_NORMAL
- en: From a technical point of view, the general ledger can be viewed as a state
    transition system in which there is a state that contains all of the general ledger
    transactions, as well as a transition function that takes a state and a transaction
    and returns a new state.
  prefs: []
  type: TYPE_NORMAL
- en: In a conventional banking system, for example, state is a balance sheet, a transaction
    is a request to shift X from account A to account B, and the state transition
    function decreases the value of X in account A and increases the value of X in
    account B.
  prefs: []
  type: TYPE_NORMAL
- en: The state transition function then gives an error if A’s account has less than
    X at the start. Let TX = Send 70 from Luca to Sara.
  prefs: []
  type: TYPE_NORMAL
- en: '*APPLY ((Luca: e50; Sara: e50); TX) = ERROR*'
  prefs: []
  type: TYPE_NORMAL
- en: Or, *let TX = Send e20 from Luca to Sara*
  prefs: []
  type: TYPE_NORMAL
- en: '*APPLY ((Luke: e50; Sara: e50); TX) = Luke: e30; Sara: e70*'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Ethereum Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Ethereum, the state is a buildup of objects called *accounts* that play
    a central role. There are two types of accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: Externally owned accounts (EOA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the EOAs are user accounts and are controlled by private keys and
    have no code associated with them. But contract accounts are controlled by their
    contract code and have an associated code. (See Figure [4-5](#Fig5).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-5
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum account
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 The Account State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This account status is made up of four elements that are present regardless
    of the account type: (See Figure [4-6](#Fig6).)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonce (number only used once):** If the account is owned by a third party,
    this number indicates how many transactions have been sent from the account address.
    The nonce is then the number of contracts created by the account if it is a contract
    account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balance:** This is the Wei number that this address owns. One ether is equal
    to 10^18.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MemoryRoot:** A 256-bit hash of the root node of a Merkle tree Patricia (refer
    to Chapter [2](520777_1_En_2_Chapter.xhtml)). This tree encodes the hash of the
    storage account of this account and is empty by default. For contract accounts,
    this is smart contract storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeHash:** This is the hash code of an EVM (Ethereum Virtual Machine) account.
    For the contract account, this is the code that is hashed and stored as a codeHash.
    For external owned accounts, the codeHash is the hash of the empty string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6
  prefs: []
  type: TYPE_NORMAL
- en: Account status in Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 Externally Owned Accounts (EOAs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Externally owned accounts  :'
  prefs: []
  type: TYPE_NORMAL
- en: Have an Ether balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can send to the transactions (they either transfer or activate the code of a
    contract).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are controlled by the private key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not have an associated code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that every account is defined by a key pair—a private key and a public
    key. Like Bitcoin, Ethereum also uses ECDSA (Elliptic Curve Digital Signature
    Algorithm). Ethereum also uses the curve dictated by standard secp256k1.
  prefs: []
  type: TYPE_NORMAL
- en: You should already know how private keys and respective public keys work. However,
    Ethereum differs from Bitcoin by the generation of an *Ethereum* *address* *.*
  prefs: []
  type: TYPE_NORMAL
- en: These, like Bitcoin, are derived from the public key. However, to this the hash
    function Keccak 256 is applied. From the result of this function, you have the
    *public key hash* *.* From this you take the 20 bytes farther to the right and
    you will get the Ethereum address. All Ethereum addresses start with the 0x prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Accounts are indexed based on their address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an external ownership account has no cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EOA uses transactions (or messages, as you’ll see) to interact with the Ethereum
    blockchain network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can send transactions to transfer digital money to other accounts of external
    property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be send to a transaction to a contract account to invoke a smart contract  .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2.3 Contract Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A contract account  represents a smart contract, which means:'
  prefs: []
  type: TYPE_NORMAL
- en: It has an address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an Ether balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an associated code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is controlled by the associated code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the code is triggered/invoked by transactions or messages (calls)
    received from other accounts (EOAs or contract accounts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once executed, it performs operations of arbitrary complexity (Turing complete)
    and manipulates its own persistent archive; it can have its own permanent state
    it can call other contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contract address is generated by hashing the SHA-3, also called Keccak-256,
    the address of the sender’s account and their nonce, and taking the rightmost
    20 bytes of this result. Contract accounts have a cost both in creation and in
    use (execution), because they use computational resource and network storage  .
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.4 Differences Between Externally Owned and Contract Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, it is good to clarify that to participate in the Ethereum network,
    an external ownership account is required. Furthermore, any type of message sent
    through the Ethereum network has a cost because it uses computational and archiving
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: That means an external owned account can send or deliver the messages to other
    account owned externally or to other contract creating accounts. (See Figure [4-7](#Fig7).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-7
  prefs: []
  type: TYPE_NORMAL
- en: Transaction from EOA
  prefs: []
  type: TYPE_NORMAL
- en: That means a message between two external owned accounts is simply a transfer
    of value.
  prefs: []
  type: TYPE_NORMAL
- en: However, a message from an owned account external to a contract account activates
    the contract account code, allowing it to perform various actions (examples include
    transfer tokens, write to internal memory, mint new tokens, run some calculations,
    create a brand-new contracts, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, through a message from an ownership account external to a contract
    account invokes a smart contract. (See Figure [4-8](#Fig8).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-8
  prefs: []
  type: TYPE_NORMAL
- en: Transaction example of account contracts
  prefs: []
  type: TYPE_NORMAL
- en: Unlike externally owned accounts, the contract accounts won’t be able to start
    new transactions. On the contrary, the accounts of the contracts can generate
    transactions only in response to different transactions received (from an external
    ownership account or another contract account). You will find out more about contract
    calls in the section entitled “Transaction and Message.”
  prefs: []
  type: TYPE_NORMAL
- en: Hence, any action that occurs on the Ethereum blockchain is always activated
    by transactions activated by externally regulated accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '4.2.5 Storing Key: Encrypted Keystore'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every private key/address pair is encoded in a keyfile and the keyfiles are
    JSON text files. Additionally, the critical component of the keyfile, the private
    key of the account, is always encrypted with the password entered during the account
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: The keyfile is located in the keystore subdirectory of the data directory Ethereum
    node that created the account or imported it.
  prefs: []
  type: TYPE_NORMAL
- en: The keystore uses the elliptic curve secp256k1 as defined in the standards for
    efficient Encryption, implemented by the libsecp256k library and found at github.com/ethereum/go-ethereum/accounts.
    Accounts are stored on disk in the Web3 secret storage format.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating an encrypted keystore for Ethereum accounts, you can use this
    account manager for all cycle requirements account life. This includes the basic
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of new accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elimination of existing ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating of access credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export of existing accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import to another device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the keystore defines the encryption level used to store accounts, there
    is no global master password capable of granting access to everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, each account is managed individually and is stored on disk in its individually
    encrypted format, ensuring separation is much cleaner and uses more rigorous credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'This individuality means that any operation that requires access to an account
    must provide authentication credentials required for that particular account in
    the form of a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new account, the caller must provide a passphrase with which
    to encrypt the account. This passphrase will be required for any subsequent access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deleting an existing account, the caller must provide a passphrase to verify
    account ownership.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When updating an existing account, the caller must provide both the current
    and the new passphrase. After completing the operation, the account will no longer
    be accessible via the previous passphrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When exporting an existing account, the caller must provide both a current passphrase
    to decrypt the account, and a passphrase to reencode it before returning the key
    file to the user. This is necessary to allow the movement of the accounts between
    machines and applications without sharing credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When importing a new account, the caller must provide both the encryption passphrase
    of the keyfile to be imported and a new passphrase with which to store the account.
    This is necessary to allow the storage of accounts with different credentials
    than those used to move them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore  , there are no recovery mechanisms for the loss of a passphrase.
    The cryptographic properties of the encrypted keystore ensure that the account
    credentials cannot be brutally forced in any way. For account management, various
    Wallet apps are available to manage them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 World State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The world state of the Ethereum blockchain is a mapping between the Ethereum
    address (160-bit identifiers) and the account state.
  prefs: []
  type: TYPE_NORMAL
- en: This mapping is maintained through a data structure called the Modified Merkle
    Patricia tree. Let’s see what it is.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Trie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Trie  , also called a *digital tree* or *prefix tree* , is a data structure
    ordered tree used to store a dynamic set or array associative where the keys are
    generally strings.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the position of a node in the tree defined the key that it is associated
    with. Nodes do not keep a copy of their own key, instead they depend on the position
    of the node in the tree. (See Figure [4-9](#Fig9).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-9
  prefs: []
  type: TYPE_NORMAL
- en: Example of a Trie
  prefs: []
  type: TYPE_NORMAL
- en: The root of the tree is associated with the empty string, and all the descendants
    of a node share the prefix associated with that node. Not all nodes necessarily
    represent a significant key, which typically is found instead in the leaves and
    possibly in some internal nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 The Radix Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the Radix tree  , also called a compact prefix tree or radix trie,
    is one data structure that represents a Trie in which space is optimized. In this
    tree, unlike the Trias, each leaf node is an only child and is joined with the
    parent node. (See Figure [4-10](#Fig10).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-10
  prefs: []
  type: TYPE_NORMAL
- en: Example of Radix tree
  prefs: []
  type: TYPE_NORMAL
- en: Here the result is that the number of children of each internal node is at most
    the value r, a positive integer assigned to the radix variable of the radix tree.
    The value is a power of 2x, where x is greater than or equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: This makes radix trees much more efficient for sets where the keys are long
    strings, and for shared sets of keys with long prefixes. Thus, if radix equals
    2, you get a binary Radix tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let k be the length of the keys. Radix trees allow searching, insertion, and
    elimination in time O (k) This doesn’t seem to be an advantage, but they can perform
    these operations with fewer comparisons and require many fewer nodes than balanced
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Radix trees are useful for building associative arrays of keys that
    can be expressed as strings. They’ve particular application in IP routing, where
    the ability to contain large ranges of values with few numbers of exceptions is
    especially suited to the hierarchical organization of IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Patricia Trie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a Patricia trie  is a type of Radix tree where the radix equals 2\.
    (See Figure [4-11](#Fig11).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-11
  prefs: []
  type: TYPE_NORMAL
- en: Tree radix, radix = 2
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it is a binary radix tree (radix = 2), where each node has two
    child nodes. So at each cross of the tree, for each node (which is not leaf) you
    have in front of a binary choice (two branches). This means that each bit of the
    key is compared individually and each node is a two-way branch (that’s the left
    and right).
  prefs: []
  type: TYPE_NORMAL
- en: A Patricia trie is a special variant of the binary radix tree (radix = 2), where
    instead of explicitly storing every bit of every key, the nodes only store the
    position of the first bit that distinguishes two subtrees from each other.
  prefs: []
  type: TYPE_NORMAL
- en: During the intersection, the algorithm examines the indexed bit of the search
    key and chooses the appropriate right or left subtree. Among the notable features
    of Patricia trie is that it inserts only a single node for each stored key, making
    Patricia much more compact than a standard binary trie. We provide an example
    for a better understanding of a Patricia trie. Suppose you put three keys – smiled,
    smiles, and smile – in a Patricia Trie.
  prefs: []
  type: TYPE_NORMAL
- en: The binary representation of these three keys is shown in Figure [4-12](#Fig12).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-12
  prefs: []
  type: TYPE_NORMAL
- en: Example by Patricia trie
  prefs: []
  type: TYPE_NORMAL
- en: We note that smile is a prefix of smiled and smiles.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the binary representation, we can see that the former bit that differs
    (from left to right) is 0 (highlighted in red in the second line). For this reason,
    smiled will be the left child of smile. Likewise, smiles will be smiled’ s right
    child because they share the same prefix up to a bit whose value is 1 (highlighted
    in red in the third line). The resulting Patricia trie after entering the three
    keys is shown in Figure [4-13](#Fig13).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-13
  prefs: []
  type: TYPE_NORMAL
- en: Example of a Patricia trie
  prefs: []
  type: TYPE_NORMAL
- en: Also, because the actual keys are no longer stored explicitly, you need to do
    a full comparison of the keys on the record indexed to confirm a match. About
    this, Patricia has a particular resemblance to indexing using a hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4 Ethereum Modified Merkle Patricia Trie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explains how Ethereum changed the Merkle Patricia trie.
  prefs: []
  type: TYPE_NORMAL
- en: In the modified Merkle Patricia tree, the keys of the tree are represented by
    Ethereum addresses (20-byte, 160-bit addresses), represented in hexadecimal notation
    (16 characters). The values from the account state correspond to that Ethereum
    address.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a cryptographically secure Merkle tree, each node is referenced
    by its hash, and the root of the tree acts as a cryptographic imprint of the whole
    tree. In other words, the deterministic cryptographic hash of each node is used,
    precisely, as a pointer to the node itself.
  prefs: []
  type: TYPE_NORMAL
- en: This provides a form of cryptographic authentication to the data. If the root
    hash of a certain trie is publicly known, then anyone can provide evidence that
    the trie has a given value at a specific path providing the nodes go up every
    step of the way. It is impossible for an attacker providing proof of a pair (path,
    value) that they do not exist since the root hash is based on all the underlying
    hashes, so any changes would change the root hash. This is the *Merkle* part of
    the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are three different types of nodes in the Modified Merkle
    Patricia trie:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension Node:** Contains a part of the common key for multiple nodes (encoded
    path) and contains a reference to a subsequent node (key), or the hash of the
    next node. Therefore, a constituted knot from these two fields (encoded path,
    key).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch Node:** Contains pointers to different nodes that have the same key
    prefix. A branch node has 17 fields, one for each character of the hexadecimal
    alphabet (16 characters) and a value field, to contain the final target value
    in case the path has been completely crossed, i.e., if a pair exists (key: Ethereum
    Address, value: Account State) where the key (Ethereum Address) terminates in
    the branch node. This node consists of 17 fields (v0 ... v15, value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf Node:** Contains a value and the remainder of the key (called key-end).
    A key to a leaf node (and therefore your Ethereum Address) is the concatenation
    of a prefix from all of its parents and the key-end of the leaf node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extension node only ever has one child node. For this reason, the child node
    is only ever a branch node. In fact if it pointed to a leaf node, they would be
    combined into a single leaf knot. If it pointed to an extension node, these would
    be combined into a single extension node. In Figure [4-14](#Fig14), you can see
    the structure of the various types of nodes.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-14
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Modified Merkle Patricia trie
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the value field hosts the account balance. But in reality, it
    hosts the result of the RLP function (serialization function) applied to the Account
    State (which contains the four fields). Instead, the hash function used for nodes
    is SHA 3.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both extension nodes and leaf nodes consist of two fields, a
    field dedicated to the path of the address and a field dedicated to the value.
    In the case of the extension node, this value is the hash of the node it points
    to. In the case of the leaf node, it is the account being serialized.
  prefs: []
  type: TYPE_NORMAL
- en: But how does Ethereum distinguish between the two nodes?
  prefs: []
  type: TYPE_NORMAL
- en: 'It adds a prefix. This is the field that in the figure is called prefix . Assume
    that a single hexadecimal character equals the unit of 1 nibbe. So, one nibbe
    is equivalent to 4 bits. Therefore, these prefixes are used:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 is an extension node that has an even number of nibbes in the field referred
    to the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 is an extension node that has an odd number of nibbes in the field referred
    to the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 is a leaf node that has an even number of nibbes in the field referred to
    path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 is a leaf node that has an odd number of nibbes in the field referred to the
    path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it important to distinguish between an extension node and a leaf node?
  prefs: []
  type: TYPE_NORMAL
- en: Because if it is an extension node then the value is a pointer to a branch node
    (that is, its hash). While if it is a leaf node then the value is the same as
    the account state serialized through the RLP function.
  prefs: []
  type: TYPE_NORMAL
- en: All Merkle Tries in Ethereum are Ethereum Merkle Patricia Trie. This structure
    is maintained through a flat key/value DB.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.5 Storage Root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hash 256-bit root node or base node of a Merkle Patricia tree encodes the
    content of the account storage in the trie as a mapping from the Keccak hash to
    256 bit to integer values encoded in 256-bit RLP. This, then, in the case of contract
    accounts, is the storage of the smart contract. Figure [4-15](#Fig15) illustrates
    the concept.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-15
  prefs: []
  type: TYPE_NORMAL
- en: Storage root  is the root of or base of a Merkle Patricia Trie for storage of
    the account
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.6 Why Merkle Trees?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The power to store all this information efficiently in Merkle trees  is incredibly
    useful in Ethereum, and for those we call *light nodes* . A blockchain is handled
    by a group of nodes. Generally, there are two types of nodes: full nodes and light
    nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: A full node synchronizes the blockchain by archiving the entire chain, from
    the originating block to the last block, and performs all operations contained
    therein. Miners usually keep full nodes for the mining process.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to download a full node without mining. Regardless, each
    full node contains the entire blockchain. But as long as a node does not need
    to execute every transaction or query historical data, it’s not really necessary
    to store the entire blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the concept of a lightweight node comes in. Instead of downloading
    and storing the entire chain and executing all of the light node’s transactions,
    they only download the chain of headers, from the originating block to the current
    one, without executing any transactions or retrieving any state. Since the light
    nodes have access to the block headers, which contain the hashes of three Merkle
    Patricia trie trees, they can still easily generate and receive verifiable responses
    to transactions, events, balances, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Ethereum Virtual Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine, often abbreviated EVM, is the computing center
    that allows the execution of complex codes (smart contracts) on top of the Ethereum
    platform. It is therefore a virtual machine, i.e. software capable of emulating
    a physical machine in all respects, through a virtualization process in which
    physical resources (CPU, RAM, hard disk, ...) are assigned to the applications
    that are run on the virtual machine (including its operating system). It plays
    a role similar to what the Java Virtual Machine (JVM) plays for Java, that is,
    a safe environment, isolated and protected from the rest of the running processes
    or files on the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: A crash or malfunction of the EVM does not cause side effects in the host computer’s
    file system and operating system processes. EVM also acts as a guarantor for the
    network nodes, which “offer” their own physical infrastructure for the storage
    and processing of potentially harmful smart contracts. The open and permissionless
    nature of the Ethereum blockchain (like that of Bitcoin), in fact, allows anyone
    to be part of it and deploy potentially malicious smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 What Is a Gas?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very important concept in Ethereum is that of commissions. Consider that every
    node runs EVM as part of the verification and validation protocol. Every transaction
    and each smart contract is executed on the EVM for each node on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly this is not to optimize the efficiency of the calculation. This parallel
    processing is redundantly parallel. The goal is to offer a more efficient method
    of reaching consensus without the need for trusted third party. The fact that
    the *executions of smart contracts and transactions* are redundantly replicated
    through knots makes them very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: This creates an incentive not to use the blockchain for computation, which can
    be performed off the platform. Any calculation that occurs because of a transaction
    on the Ethereum network comes at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: Note that *gas* is the name of the execution commission that the senders of
    the transactions have to pay for each task carried out on the blockchain Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: The name gas is developed by the fact that this tax acts like crypto-fuel, driving
    the motion of smart contracts and of *transactions* *.* The gas and ether are
    purposefully dissociated since the gas units align to the calculation units having
    a natural cost, while the price of the ether generally fluctuates due to market
    forces. The gas is the unit used to count the fees required for a certain computation.
  prefs: []
  type: TYPE_NORMAL
- en: The price of gas is the amount of Ether we are ready to spend on every unit
    of gas and is counted in the gwei. Note that the Wei is the smallest unit of Ether,
    where 10^18 Wei denotes one Ether. One gwei is 1,000,000,000 Wei. With every computation/transaction,
    a sender sets a gasLimit and that means the gas cost or price *(*gasprice*)*.
    In this case, the gas limit refers to the full amount of gas that we are willing
    to spend on a particular computation or transaction. The Gas cost refers to the
    amount of Gwei we are ready to pay. The product of the gas cost and the gas limit
    represent the amount of Ether that the sender is ready to pay for the execution
    of a computation or transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will consider an example of a sender with a limit of gas cost. Suppose
    the sender gives the gas limit as 50,000 and a gas price of 20 gwei. This means
    that the sender is ready to spend a high amount of 50000 x 20 gwei = 1,000,000,000,000,000
    Wei = 0\. 001 Ether to execute that computation or transaction. (See Figure [4-16](#Fig16).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-16
  prefs: []
  type: TYPE_NORMAL
- en: Example of payment of commissions for a transaction
  prefs: []
  type: TYPE_NORMAL
- en: If a user has a large amount of Ether in their balance account to cover this,
    the transaction or computation can be executed. The sender is then refunded for
    the amount of gas not used during the final stage of the transaction or computation.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-17
  prefs: []
  type: TYPE_NORMAL
- en: Example of reimbursement for unused gas at the end of a computation
  prefs: []
  type: TYPE_NORMAL
- en: If the sender will not give the gas needed to perform a transaction, the transaction
    will run out and would not be considered valid. In this case, the processing of
    the transaction would stop and any path changes that would be reverted in order
    to return to the Ethereum state prior to the computation. Also, a failed transaction
    would be logged to show which operation was attempted and where it failed. And
    since the car has already spent resources to perform the calculations before running
    out of gas, no amount is refunded to the sender. (See Figure [4-18](#Fig18).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-18
  prefs: []
  type: TYPE_NORMAL
- en: Example of a failed transaction due to a lack of gas
  prefs: []
  type: TYPE_NORMAL
- en: Note that the whole price spent by the sender for gas is sent to the address
    of the miner. As miners are spending their resources to run the calculations and
    identify the computations, they receive the gas tax as granted. (See Figure [4-19](#Fig19).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-19
  prefs: []
  type: TYPE_NORMAL
- en: Example of a miner receiving a commission
  prefs: []
  type: TYPE_NORMAL
- en: So, it is clear that the higher the price of gas, the higher the mark the miner
    will get from computation. In this way, miners are free to select which computations
    to validate and which to avoid. To direct senders to a gas price they deem acceptable,
    miners have the option of advertising a cheaper cost for which they are willing
    to perform transactions. Miners will include transactions with the highest fees,
    so the more a user is willing to pay for gas, the more their transaction will
    quickly be included in a block. It is possible to see the gas required for each
    operation on this sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Gas for Storing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not only is gas used to pay for the calculation steps, but it is also used to
    pay for memory usage. The rates for archiving have some nuanced aspects. For example,
    since a major memory increases the size of the Ethereum state database on all
    nodes, there is an incentive to keep the amount of data small archived.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, if a transaction has a phase when it cancels an entry in the
    storage space, the execution commission of that transaction is canceled and a
    refund is granted to free up storage space. In addition, the storage costs are
    very high. When we develop a smart contract we have three ways to access memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stack: Access to the volatile stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory: Access to volatile storage or memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: Access to non-volatile storage. The most expensive is non-volatile
    storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure [4-20](#Fig20) shows a table with the gas required for each memory operation.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-20
  prefs: []
  type: TYPE_NORMAL
- en: List of gas costs for each operation on the memory
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, storing data constantly on Ethereum is extremely costly. There
    is no point in using Ethereum to keep data. Only the data needed for the current
    operations should be stored; delegate archiving to another solution.
  prefs: []
  type: TYPE_NORMAL
- en: However, a great method would be to archive in Ethereum only the root or the
    base hash of the Merkle tree as proof of data tampering on an external service.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the smart contracts in terms of consumption or
    computation of gas to control operating price.
  prefs: []
  type: TYPE_NORMAL
- en: There are several APIs for estimating transaction costs as well as of smart
    contracts. But this goes beyond the objectives of this book. Ultimately, all operations,
    both computational and archiving, have a price explained in the gas units. When
    a user submits a transaction, they provide an ETH price per gas unit and the number
    of units of gas that they are willing to spend. The lower the code in the terms
    of gas, the more efficient it will be in terms of materials needed to execute
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 The Purpose of Gas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important aspect of how Ethereum runs is that every single operation performed
    by the network is performed together from every full node. But you have seen that
    the calculation steps on the Ethereum virtual machine can be more costly.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the Ethereum smart contracts are used for elementary activities, such
    as the execution of a simple business strategy, or verifying digital signs and
    another cryptographic objects, rather than for more complex uses such as file
    archiving, email machine learning, and in general operations that can strain the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The imposition of tariffs prevents users from overcharging. Note that the Ethereum
    is a complete or full Turing language and in a nutshell, it is capable of simulating
    any algorithm. This also allows you to create loops and it makes Ethereum sensitive
    to the problem of avoiding programs that are performed indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of tariffs, an attacker could effectively try to distract the
    network by running an unlimited loop within an action or an operation without
    any repercussions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Transactions and Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined the Ethereum blockchain as machine states based on transactions.
    Therefore, a transaction is an event that can change the state of the Ethereum
    blockchain. A transaction can be created for different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Digital money transfer between EOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution of a smart contract in the Ethereum blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a function on a distributed smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction can only be created and transmitted by EOs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Transaction Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Ethereum transaction is an array of bytes. The matrix is divided into fields,
    as shown in Figure [4-21](#Fig21).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-21
  prefs: []
  type: TYPE_NORMAL
- en: Transaction structure
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are maintained through the modified Merkle logic Patricia tree,
    which was discussed extensively in the section dedicated to the world state.
  prefs: []
  type: TYPE_NORMAL
- en: In this logic, the keys are represented by the Transaction IDs and the values
    are precisely the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Transaction Digital Signature Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the steps taken to sign a transaction, following the EIP (Ethereum Improvement
    Proposal) scheme proposed, after the hard fork that hit Ethereum, by Vitalik Buterin
    who protects against possible replay attacks. Using the old scheme also works;
    however the founder suggests using the new one to protect yourself from replay
    attacks. It is possible to see here :![../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: This was proposed by the founder of Ethereum, with the list of IDs of all chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a transaction is created, it is serialized via the function RLP:'
  prefs: []
  type: TYPE_NORMAL
- en: '*L*[*1*] *(T) = RLP (T (T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p;
    chainID; (); ()))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dove p = T*[*i*] *se T*[*t*] *= 0, altrimenti p = T*[*d.*]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once serialized, the cryptographic hash function called SHA-3 is applied, also
    called Keccak-256:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h*[*1*] *(T) = KEC (L (T))*'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, you can apply the signature
  prefs: []
  type: TYPE_NORMAL
- en: '*ECDSASIGN (h (T); privKey) = (T*[*w;*] *T*[*r*]*; T*[*s*]*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In which:'
  prefs: []
  type: TYPE_NORMAL
- en: T[w] is a recovery identifier and it is doubled plus 35 or 36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T[r] is the randomPart of the digital signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T[s] is the sign of the digital signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, T[r] and T[s] constitute the outputs of the ECDSA digital signature
    (randomPart; sign), while T[w] is calculated according to EIP155, and has a dual
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Protects from replay attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to retrieve information for the quick recovery of the public key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, the sender’s address is not present in the transaction. Once this is
    done, the T[w], T[r], and T[s] fields are added to the transaction, getting *T(T*[*n*]*;
    T*[*p*]*; T*[*g;*] *T*[*t*]*; T*[*v*]*; p; T*[*w*]*; T*[*r*]*; T*[*s*]*)*
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the RLP serialization function is applied to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*L*[*2*] *(T)= RLP(T(T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p; T*[*w*]*;
    T*[*r*]*; T*[*s*]*))*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And once again applied to the SHA-3 hash function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h*[*2*] *(KEC (L*[*s*] *(T))*'
  prefs: []
  type: TYPE_NORMAL
- en: What you finally get is the Transaction ID.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.3 Recovery Public Key from Digital Signature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a digital signature  , Ethereum, like Bitcoin, uses both the ECDSA algorithm
    that the standard secp256k1.
  prefs: []
  type: TYPE_NORMAL
- en: We deal here with the digital signature scheme in proposal EIP-155\. In this
    example we will refer to the Ethereum Mainnet chain. But the procedure is the
    same for each chain that uses this scheme, just change the chainId to the appropriate
    one.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is no field for the sender’s address of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: This information is in fact obtained. And it is for this reason that you have
    the variable v which gives you information about parity and the finiteness of
    curve point in which randomPart is the x value. The formula for calculating v
    is
  prefs: []
  type: TYPE_NORMAL
- en: '*v = chainId 2 + ((y mod 2) + 35)*'
  prefs: []
  type: TYPE_NORMAL
- en: chainID is the ID of the chain used. For Ethereum Mainnet the value of this
    variable is 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: y is the y coordinate of curve point in which randomPart is the x value of the
    curve. It is part of the ECDSA signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the formula proposed for the calculation of v, you see that the interesting
    part is y mod 2\. Which assumes the role of recovery identifier?
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used to speed up the process of retrieving the signer’s public key. In
    fact, if the information is correct, this operation has two possible results:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: -> the y coordinate is an even value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: -> the y coordinate is an odd value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consequently, we find that ((y mod 2) + 35) can have two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '35: -> the y coordinate is an even value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '36: -> the y coordinate is an odd value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a fixed value for the X coordinate and truncating the information relative
    to the Y coordinate, it is possible to have several possible pairs of points (x;
    y) with the same x.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the signature, then, we would have to retrieve the public key, perform
    a loop, in which at each iteration, compare whether one of the possible pairs
    matches the signature.
  prefs: []
  type: TYPE_NORMAL
- en: Possible pairs match the signature. So, let’s see the public key of the sender.
    We briefly explain how the ECDSA algorithm calculates the random part of a digital
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: Given the curve secp256k1. Let G be the generator point defined by the standard
    secp256k1. Let n be the order of point G of the curve Then, we need to understand
    a that random number is generated in between the interval of [1, n-1]. And we
    call this randomNumber value. We find randomPart like this.
  prefs: []
  type: TYPE_NORMAL
- en: '*randomNumber G = (x1; y1)*'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '*random Part = x1 mod n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let h be the cofactor of an elliptic curve, then 2 (h + 1) gives us the information
    about how many possible points we have given to randomPart of the X coordinate.
    For secp256k1 the cofactor is equal to 1\. So, we have four possible points:'
  prefs: []
  type: TYPE_NORMAL
- en: Two because each X coordinate has two possible Y coordinates, one positive and
    one negative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two because R.x = randomPart + j n with j 2 0; 1; 2; ... h (in our case h =
    1);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, R.x is uniquely recoverable from randomPart, as only one of the integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*R.x = randomPart + j * n*'
  prefs: []
  type: TYPE_NORMAL
- en: for j 0; 1; 2; .....; h represents a valid x coordinate, that is, a multiple
    of G.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, [SEC2] encryption standards recommend elliptic curves with
    cofactor h = 1 or h = 2\. For these curves recommended by [SEC2] the number of
    valid x coordinates is usually one, therefore this control is empty.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case scenario, only log2 h + 1 bits are needed to find R.x from
    randomPart.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, given the fixed randomPart information of the X coordinate of point
    R and truncating the information relating to the Y coordinate, it is possible
    to have two possible pairs (x; y) with the same valid X coordinate. That is to
    say, the one with the positive Y coordinate (x; y) and the one with the negative
    coordinate (x; -y).
  prefs: []
  type: TYPE_NORMAL
- en: To verify the signature, then, you would have to run a loop in which, during
    each iteration, you determine if one of the possible pairs matches the signature.
    However, thanks to the information about the parity of the Y coordinate, we can
    obtain the yr value of point R to derive the public key corresponding to the signature
    in one fell swoop. In fact, since v gives us information about the parity of the
    coordinate Y for which randomPart is the information about coordinate X, we can
    calculate R = (xr; yr).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let h (msg) be the hash of the transaction. We get, in this way, the corresponding
    public key Q:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.For j ranging from 0 to h (for secp256k1 h = 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pony x[r] = random Part + in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: From the information about the parity of y[r,] derive point R. R = (x[r]; y[r])
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the public key candidate![../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif](../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd)Verify the public key with the digital signature:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: i.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*u1 = h(msg) * sign-1 mod n*'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ii.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*u2 = randomPart * sing-1 mod n*'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: iii.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Calculate:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*R = (xr, yr) = u1G + u2Q*'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: iv.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set c = xr mod n. So, if c == randomPart true, then the signature is verified.
    Returns True (valid).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Otherwise, if, after the loop, the value True was not returned then there is
    a disability in the information. In this way, the public key is derived from the
    ECDSA signature with standard secp256k1 and the signature is verified.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.4 Three Types of Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section covers three types of transactions  :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fund Transfer Between EOA (Externally Owned Accounts):* This transaction is
    used when an EOA transfers funds to another EOA. This transaction has a blank
    Date field. (See Figure [4-22](#Fig22).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22
  prefs: []
  type: TYPE_NORMAL
- en: Transfer of funds between EOs
  prefs: []
  type: TYPE_NORMAL
- en: '*Storing Smart Contract on Ethereum Network* *:* In Ethereum, the distribution
    contract takes place through a transaction. This transaction has a blank destination
    address field. However, in the data field, there is the Smart Contract code in
    bytecode, plus some arguments if necessary. If successful, the sender receives
    a receipt with the contract address that they will need to use the smart contract
    (see Figure [4-23](#Fig23)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-23
  prefs: []
  type: TYPE_NORMAL
- en: Distribution of a smart contract of a Ethereum Run function on a deployed smart
    contract
  prefs: []
  type: TYPE_NORMAL
- en: After a contract is deployed, an EOA can perform functions defined in this contract.
    Again, it is implemented by submitting an Ethereum transaction. In this case,
    the destination address of the transaction is the Smart Contract address. While
    in the data field, there is the selector of the function to be recalled plus the
    data to be input into the function. (See Figure [4-24](#Fig24) )![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-24
  prefs: []
  type: TYPE_NORMAL
- en: Calling function on smart contract
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the rights on a smart contract of those who can carry out operations
    are defined in the smart contract code, where there is the logic of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.5 Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The message is a kind of virtual transaction sent by the EVM code from one smart
    contract to another. Note that transactions and messages in Ethereum are different.
    A *transaction* in the Ethereum language specifically refers to a digitally signed
    piece of data from a different source from the execution of the EVM code, to be
    registered in the blockchain. Messages can only be sent by the EVM code and are
    never represented in the data. They therefore express the ability of smart contract
    to send messages to different smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: These are the virtual objects, have never serialized, and only exist in the
    Ethereum run environment. They can also be conceived as a function call between
    smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, you need to understand that a message is like a transaction, except
    that it is developed by a contract and not by an outside actor. After a message
    is produced, and when a contract is currently executing, a code executes the main
    CALL or DELEGATE THE CALL codes, which develops a message.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a contract can have relationships with other smart contracts, like
    external actors. They are also called internal computations or transactions, and
    when a contract sends a transaction internally to different contract, the code
    is executed and associated with the recipient contract account. (See Figure [4-25](#Fig25).)
  prefs: []
  type: TYPE_NORMAL
- en: In general, a message comes from a smart contract, and the execution triggers
    a transaction from an EOA.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-25
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and messages (internal transactions)
  prefs: []
  type: TYPE_NORMAL
- en: The gasLimit is set by the external ownership account and therefore is sufficiently
    high to allow the execution of the overall operation, which includes any under-executions
    that occur because of operation itself, as messages between contracts.
  prefs: []
  type: TYPE_NORMAL
- en: For the overall chain of transactions a particular on execution of a message
    ends, then the execution of that message could be restored to its initial state,
    along with all messages subsequently activated by its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Ethereum State Transition Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-26
  prefs: []
  type: TYPE_NORMAL
- en: State change and state transition function invoked by a new transaction
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses the validation of transactions and therefore the state
    transition function. This function allows you to transit to a new state if and
    only if the transaction is valid and you have arranged all the resources necessary
    to complete its execution. See Figure [4-26](#Fig26).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the steps of the transition function of the Ethereum state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'APPLY (S; TX) -> S0 or ERROR is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the transaction for structure and syntax, verifying the validity of the
    signature and determine if the nonce of the transaction matches that of the sender.
    If unsuccessful, it returns an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then compute the transaction cost as GASLIMIT GASPRICE and determine
    the address of the sender of the sign. If the sender’s account is sufficient then
    it decreases by the value just calculated and increases the nonce; otherwise,
    it returns an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the variable GAS = GAS LIMIT. For each byte consumed it reduces the
    gas by a certain amount to pay for each byte of resource consumed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer the digital money of the transaction from the sender’s account to the
    recipient’s account. Note that if the recipient’s account does not exist, it creates
    it. Then if the beneficiary’s account is a smart contract, run the contract code
    until the operation is completed, or at least until the execution is out of gas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the transaction does not succeed because the sender does not have the money,
    or the execution of the code has run out of gas, restore full status changes,
    payment of taxes, and add taxes to the miner’s account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, if it’s successful, it reimburses the sender for the commissions
    for gas not consumed and sends the consumed commissions to the miner that wins
    the block containing the transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The messages work in an equivalent route to the transactions in terms of recovery
    management: If a running message runs out of gas, and all other executions triggered
    by this, are restored, it’s fine. In other cases, it gives an error or a STOP/RETURN
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, a Smart Contracts developer has access to three types of storage
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: The LIFO (Last-in-first-out) stack (volatile) in which it is possible push or
    feed data (in a range from 0 to 1024).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (volatile) memory is an array of indefinitely expandable bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum’s (nonvolatile) storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can also get the message’s value and data incoming. It can block header
    data, and can also return an array of bytes of data as output.
  prefs: []
  type: TYPE_NORMAL
- en: The functional state of EVM can be defined by the set of data. In this case
    the block state is the global state that contains all accounts and budgets and
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to consider that at the beginning of each turn of run, the current instruction
    is identified taking the byte pointed to by the program counter. Each operation
    has its own definition in terms of how it interacts with the set of data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Transaction Flow in Ethereum Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section discusses the transaction lifecycle in the Ethereum blockchain.
    Let’s take as an example a transaction that invokes a function of a smart contract—it’s
    valid and applies to any type of transaction. Suppose you want to cast your vote
    in an election through a decentralized application distributed on the Ethereum
    network. Figure [4-27](#Fig27) shows a graphical interface of the application,
    which you have accessed it through your browser, and which has installed a plug-in
    to manage the Ethereum accounts.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-27
  prefs: []
  type: TYPE_NORMAL
- en: Transaction that invokes a function of a smart contract
  prefs: []
  type: TYPE_NORMAL
- en: The application gives us a list of elections, and we choose the one for which
    we have the right to vote.
  prefs: []
  type: TYPE_NORMAL
- en: The vote function we click is an event handled by JavaScript through an Ethereum
    communication library called Web3.js. It connects to a node of the Ethereum network,
    creates an instance of a proxy for the smart voting contract, and calls its castVote()
    function  , passing the selected candidate. The function call is a transaction,
    since it alters the status of the voting app (through its function castVote())
    and requires a digital signature that is generated on the spot. See Figure [4-28](#Fig28).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-28
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain dapps
  prefs: []
  type: TYPE_NORMAL
- en: 'The voting transaction is validated by the local Ethereum node from which it
    is been submitted. Validation involves checking various things:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure and syntax is well defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digital signature is consistent with the sender’s address and the content
    of the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nonce value of the transaction must be valid. Remember that the nonce of
    an account is the count of computations or the transactions sent by that account
    ledger or bill. To be valid, the nonce of a transaction should match the nonce
    of the sender’s user account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender has enough ether to process the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data sent will not cause the castVote() function to fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if the validation is successful, the current node broadcasts the transaction
    to all its neighboring peer nodes. If the validation is not successful, the transaction
    is not transmitted and simply disappears. Then, the transaction is transmitted
    over the network through the various complete nodes, which in turn go through
    the previous validation process.
  prefs: []
  type: TYPE_NORMAL
- en: Then the transaction, spreading through the network, reaches the miner nodes.
    Each miner node, based on the transactions it receives, has its own transaction
    pool to add to the ledger. (See Figure [4-29](#Fig29).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-29
  prefs: []
  type: TYPE_NORMAL
- en: MemPool
  prefs: []
  type: TYPE_NORMAL
- en: The miner node then chooses the transactions to include in the candidate block.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, let’s consider that n is the number of transactions and let APPLI (S;
    TX) be the function of state transition defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let S [0] be the state at the end of the last block.
  prefs: []
  type: TYPE_NORMAL
- en: '*For i = 0; 1; ... n–1 S (i+1) = APP (S (i); TX (i))*'
  prefs: []
  type: TYPE_NORMAL
- en: If no application of the transition function returns an error, then they are
    valid and could be added to the block, otherwise it will discard those that are
    invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Then to S [n] the miner adds the rewards obtained and defines the final state
    of the block. Then the miner will build the block, solve the algorithm of consensus
    and propagate it on the network to be added to the blockchain. Once the voting
    transaction is performed during validation of the block, the smart contract will
    publish the VoteConfirmation() event.
  prefs: []
  type: TYPE_NORMAL
- en: This will be received from the voter’s web user interface, on which you are
    registered to hear that event.
  prefs: []
  type: TYPE_NORMAL
- en: The Vote Confirmation() event  will then be handled by the interface’s JavaScript
    web user, and a message will appear on the screen so that the user knows that
    the vote was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [4-30](#Fig30) shows the lifecycle of the transaction, from the origin
    to the confirmation event.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-30
  prefs: []
  type: TYPE_NORMAL
- en: Transaction pool system
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Transaction State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A transaction proceeds through a series of states until it is not confirmed
    in a block added to the ledger. (See Figure [4-31](#Fig31).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-31
  prefs: []
  type: TYPE_NORMAL
- en: Transaction state
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze these states one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unknown:** A transaction that was neither viewed nor processed by the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pending:** A transaction that is in the pending state and is waiting to be
    chosen and elaborated by the miners. It’s in the so-called transaction pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In block:** A transaction moves into the block state when a miner has correctly
    selected the transaction and extracted it in a block. Once in the block, a transaction
    can roll back to the pending status if the block is forked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replaced:** A transaction can go to the replaced state from the pending state
    when one of these events occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another transaction from the same sender with the nonce itself enters the state
    of in block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another transaction from the same sender with the same nonce with a higher gas
    price enters the state pending.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s see the state *transitions* of the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pooling:** A transition from the unknown state to the pending state. It concerns
    the transactions that enter the transaction pool of somebody. They are therefore
    waiting to be selected to train a candidate block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mined:** A mined transaction was processed by a miner, creating a block.
    Once he checked out a transaction, he entered the status in block. Due to the
    *peer-to-peer* nature of the Ethereum network, from the perspective of some node,
    the transaction can shift from the *unknown* state directly to the in-block state
    without going through the pending state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replaced:** A transaction that moves from the pending state to replaced it
    is said to have been replaced. This happens when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another transaction from the same sender with the nonce itself enters the in-block
    state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another transaction from the sender state with the same nonce but with a higher
    gas price enters the pending status.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forked:** This happens when a block transaction is part of a block that is
    inverted by the network. All transactions within that block will pass from the
    in-block state to the state pending*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confirmed:** A transaction in block status is confirmed whenever a new block
    is extracted and added to the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.10 Block Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One block of the Ethereum blockchain is divided into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Block header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of ommer block headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headers of the ommer blocks are in the same format as reported. (See Figure
    [4-32](#Fig32).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-32
  prefs: []
  type: TYPE_NORMAL
- en: Block structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of *ommer block headers* is indicated with B[U], while the list of
    transactions is indicated with B[T]. So, formally, we refer to block B as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*B = (B*[*H*]*; B*[*T*] *; B*[*U*]*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that every tree in Ethereum is a Modified Merkle Patricia trie, which
    is extensively covered in the World State section.
  prefs: []
  type: TYPE_NORMAL
- en: The approach may seem very inefficient at first look, since the entire state
    must be captured at each block, but in fact only a low part of the shaft needs
    to be changed after each block. Since all the state information is a part of the
    final block, there is no need to record the full history of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In general, most of the tree between two adjacent blocks is the same, and therefore
    only one piece of information can be recorded once and referenced twice with hash
    pointers. Also, it is worth adding that the code execution process of the smart
    contract is generated by a transaction that is executed via the state computation
    or transition function.
  prefs: []
  type: TYPE_NORMAL
- en: In view of the block validation algorithm, if the computations or transactions
    are added to the block called X, the execution of the code generated by this transaction
    will be performed by all the nodes of the network, validating and adding the X
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [4-33](#Fig33) summarizes these Ethereum blocks.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-33
  prefs: []
  type: TYPE_NORMAL
- en: Block structure in Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 4.10.1 Transaction Receipts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each transaction, when executed and validated, changes the status of the blockchain.
    Therefore, every valid transaction has an outcome. Transaction receipts record
    the result of each transaction. Each computation or transaction receipt is a tuple
    consisting of four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ru: The cumulative gas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rl: The set of registers developed through the execution of the transactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rb: The Bloom filter composed of information in those registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rz: The post-transaction status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the transaction receipt is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*R = (R*[*u*]*; R*[*b*]*; R*[*l*]*; R*[*z*]*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 4.10.2 Ommer Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The block processing  times are much lower in Ethereum compared to those of
    Bitcoin. On the one hand, this allows for faster processing of transactions, on
    the other hand, several miners simultaneously resolve more blocks. These concurrent
    blocks are called *ommer blocks.*
  prefs: []
  type: TYPE_NORMAL
- en: The ommer blocks do not enter the main chain. However, the goal to integrate
    these blocks into the main blocks that have been awarded the place in the main
    blockchain is to help reward the miner for these blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In order for a miner to be rewarded for an ommer block, it must be valid. So,
    the purpose of ommers is to reward miners who do well, as well as award orphan
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a double effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.**Feeds the decentralization of the network.** In fact, even rewarding miners
    who mine orphaned blocks due to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Greater network latency, which causes delays in data propagation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Less computing power, which leads to greater difficulty to extract a block
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduces centralization and avoids pools of miners with greater computing power
    claiming most of the rewards without leaving anything to individual miners.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Increases the safety of the chain by increasing the amount of work on the
    main chain.** So less work gets wasted.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The block that wins the place in the main chain is, generally, the one that
    has the largest share of proof of work. While the ommer blocks are those that
    usually share less than this test. Each block can have at most two ommer blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 Ethereum Simplified Ghost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim behind the *GHOST* protocol is to propose one solution for blockchains
    that had very fast block processing. In fact, chains with very fast confirmation
    times are affected by a “reduced” security as the work done by the miners mine
    blocks that spread more slowly in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the solution is to include latent blocks in the computation of the
    main blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Also, blockchains that produce fast blocks strongly run the risk of centralizing
    toward a mining pool, which has a high percentage of hash power on the network,
    arriving thus to control the mining process.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation, Ethereum has adopted a “simplified” version of the
    GHOST protocol that’s able to overcome both problems that plague blockchains that
    process blocks quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The solution adopted by Ethereum is to provide a reduced reward for latent blocks.
    Not only that, but they also provide a reward for grandchildren blocks that include
    latent blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplified version of Ethereum’s GHOST protocol is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A block must specify a previous block, and 0.1 or 2 ommer block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An ommer block included in a block should have these properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be direct child of the k-generation parent of B, with k between two
    and seven.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it should not be a progenitor of B.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be a valid block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ommer block should be varied from all included ommers in the last blocks
    and by all the other ommers included in the same block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two reasons that ommers can be included in up to seven generations:'
  prefs: []
  type: TYPE_NORMAL
- en: A GHOST with no generation limits would bring complications in calculating which
    ommers are valid for a certain block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An unlimited GHOST, moreover, as implemented in Ethereum, would eliminate the
    incentive of miners to mine the main chain, and not that of an attacker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.12 Ethereum Consensus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how, even here, it turns out to be an emerging consensus, and Ethereum
    bases its consensus on Proof of Work (POW).
  prefs: []
  type: TYPE_NORMAL
- en: The POW algorithm  used by Ethereum is the Ethash, which is based on the Keccak-256-bit
    cryptographic hash function.
  prefs: []
  type: TYPE_NORMAL
- en: As you have already seen, when a transaction is created and signed, before being
    transmitted to the network, it is validated locally through the local Ethereum
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'This validation includes the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure and syntax of the transaction is well formed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digital signature is consistent with the sender’s address and the content
    of the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nonce value of the transaction must be valid. To be valid, the nonce of
    a transaction must match the nonce of the sender’s account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender has enough ether to finance the gas of the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data sent is consistent and well-formed and therefore does not cause failures
    of any operations invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one of these validation steps fails, then the transaction will fail and be
    transmitted to the network. Instead, if so, it is spread across the network through
    neighboring nodes. Each node that will receive a transaction is carried out in
    turn a verification of the validity of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if successful, this will be passed on through the network, otherwise
    ignored. This way you avoid clogging the network with invalid transactions that,
    therefore, would not lead to any change of state.
  prefs: []
  type: TYPE_NORMAL
- en: When these reach the miners, they validate them and add them to the transaction
    pool. In fact, miners, as in Bitcoin, keep a pool of transactions locally, waiting
    to be added to a candidate block.
  prefs: []
  type: TYPE_NORMAL
- en: Miners choose the transactions to add to the block based on various criteria,
    but primarily based on the fees that a transaction offers. Miners have a gas limit
    per block, which they cannot breach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then they choose a number n of transactions to add in block, and they apply
    the transition function for each of these statusAPPLY (S; TX) -> S or ERRORSo
    the miner can finally build the block with the new state S0, fill in the fields,
    and solve the PoW puzzle we talked about in the Nakamoto Consensus section in
    the chapter dedicated to Bitcoin*.* Once the puzzle is solved, the miner can pass
    the block to the net. Each node that will receive the block will then validate
    the latter. The basic block validation algorithm in Ethereum works in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the previous reference block still exists and is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See if the timestamp of the block is larger than that of the previous and lower
    reference block of 15 minutes in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify whether the block number, difficulty, transaction origin, derivative
    transaction, and gas limit are valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify if the POW on the block is still valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S [0] can be the state at the end of the last block and TX can be the list of
    the computations or transactions of the block, with n steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*For i = 0 ... n - 1, set S (i+1) = APPLY (S (i); TX (i)).*'
  prefs: []
  type: TYPE_NORMAL
- en: Then check if the application gives an error or if the final or total gas consumed
    in the block up to this point go beyond the GASLIMIT; this too gives an error.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that S FINALS (n), however adding the block reward paid to the miner
    block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to verify that the original state of the Merkle tree S_FINAL is the same
    in the original final step or state given in the header of the block. In such
    a case, the block is valid; on the other hand, it’s not valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.12.1 The Proof of Work Algorithm (PWA)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The PWA is formally defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(n; m) = PoW (H; H*[*n*]*; d)*'
  prefs: []
  type: TYPE_NORMAL
- en: Where
  prefs: []
  type: TYPE_NORMAL
- en: (n; m)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M is a mixHash
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: n is the nonce
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: H is the block header without the nonce and without mixHash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hn is the nonce defined as a cryptographically pseudo-random number not independent
    on H and d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d is the DAG, and it is a large set of data required to compute the mix-hash.
    Simply put, a miner repeatedly spawns such mixHashes through the DAG, until the
    output has a lower nonce value than the desired value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between the nonce and the difficulty of the block is formally
    defined here:![../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 4.13 Ethereum 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have seen that, as with Bitcoin, Ethereum is an emerging consensus. The
    algorithm for extracting blocks used by Ethereum is the *Proof of Work* algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: However, soon, there will be an upgrade from Ethereum 1.0 to Ethereum 2.0\.
    This update will not be immediate but will proceed gradually through various stages.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important notes of this update is innovation of the algorithm
    used to extract the blocks. In fact, with the upgrade to Ethereum 2.0 there will
    be a transition to the Proof of Stake algorithm. The Proof of Work is an algorithm
    for extracting blocks that entails a computational burden no less. In order for
    it to be possible to win a block, you need the necessary computational power from
    expensive and specialized hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to a very high energy consumption with consequences on pollution.
    So, in summary, the problems related to PoW are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a very inefficient process due to the number of computational resources
    and the energy it requires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People and organizations who can afford more powerful hardware to carry out
    PoW are more likely to use it than the others, which means there is a risk of
    centralizing the mining process at organizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure [4-34](#Fig34) shows a statistical example of the distribution of mining
    power within the Ethereum network.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-34
  prefs: []
  type: TYPE_NORMAL
- en: Distribution of the hash rate in Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, from the image it is clear that more than 51% of the total mining
    power of Ethereum is in the hands of three organizations. To solve these problems,
    Ethereum considered Proof of Stake as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 4.14 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about Ethereum and its structure (state and transaction
    functions). It explained how Ethereum was created to enable developers to build
    and publish smart contracts and distributed applications that can be used without
    downtime issues, fraud, or interference from a third party. The next chapter will
    focus on the consensus based on the Proof of Stake algorithm, on which research
    is deepening more and more. More blockchains are considering switching to this
    algorithm consensus, first of all Ethereum. The chapter ends by covering by Ethereum
    Casper, the proof of stake the developers of Ethereum are implementing.
  prefs: []
  type: TYPE_NORMAL
