- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_4](https://doi.org/10.1007/978-1-4842-7480-4_4)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者，独家许可给APress Media, LLC，Springer Nature的一部分 2022J. T. George《引入区块链应用》[https://doi.org/10.1007/978-1-4842-7480-4_4](https://doi.org/10.1007/978-1-4842-7480-4_4)
- en: 4. Ethereum
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 以太坊
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 约瑟夫·塔奇尔·乔治^([1](#Aff2)  )(1)意大利罗马
- en: The Bitcoin blockchain model has proved to be a paradigm valid for cryptocurrencies,
    which has led to increased interest and study about blockchain in various fields
    of application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的区块链模型已被证明是加密货币的一种有效范式，这导致了对区块链在各个应用领域的兴趣和研究的增加。
- en: Vitalik Buterin realized the potential of the blockchain model early on. He
    saw it as much more than a platform for cryptocurrencies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Vitalik Buterin很早就意识到了区块链模型的潜力。他认为它远不仅仅是一个加密货币的平台。
- en: A passion for Bitcoin led him to found, at the age of 17, together with Mihai
    Alisie, *Bitcoin Magazine*, a site and print magazine covering topics related
    to Bitcoin. Vitalik quickly realized that blockchain technology could do much
    more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对比特币的热情在他17岁时促使他与Mihai Alisie共同创办了*比特币杂志*，这是一个涵盖与比特币相关主题的网站和印刷杂志。Vitalik很快意识到区块链技术的潜力远不止于此。
- en: In 2013, he declared that Bitcoin needed a language of scripting for the development
    and creation of *decentralized applications.*
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，他宣称比特币需要一种用于开发和创建*去中心化应用*的脚本语言。
- en: Failing to convince the community, he began developing a new distributed information
    platform, based on technology blockchain. Thus, Ethereum was born on July 30,
    2015, and it introduced a new feature called *smart contracts*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 未能说服社区，他开始开发一个基于区块链技术的新型分布式信息平台。因此，以太坊在2015年7月30日诞生，并推出了一个叫做*智能合约*的全新特性。
- en: A new generation of blockchain was inaugurated, and to date it’s still the most
    prominent—Blockchain 2.0.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新一代的区块链应运而生，至今仍然是最突出的一种—区块链2.0。
- en: Consider the image shown in Figure [4-1](#Fig1), in which Bitcoin and Ethereum
    are compared. On the left is Bitcoin, to which top of the stack is the Wallet
    application through which money transfer operations are made. To the right is
    Ethereum, which changed the blockchain into a computational system framework or
    architecture and opened a full world of opportunities in the decentralized realm.
    Note that Ethereum supports smart contracts and the machine virtual EVM on which
    these run. Smart contracts, in turn, enable decentralized applications that accomplish
    more of a transfer of value. In this way, a level of logic and calculation is
    added to the blockchain.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图 [4-1](#Fig1) 中显示的图像，其中比较了比特币和以太坊。左边是比特币，堆栈的顶部是通过该顶部执行货币转移操作的钱包应用程序。右边是以太坊，它将区块链转变为计算系统框架或架构，并在去中心化领域打开了全新的机会。请注意，以太坊支持智能合约和机器虚拟机
    EVM，在此上面运行。智能合约又使去中心化应用程序能够实现更多的价值转移。通过这种方式，向区块链添加了一层逻辑和计算。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg)
- en: Figure 4-1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1
- en: Bitcoin vs. Ethereum stacks
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币 vs. 以太坊技术堆栈
- en: Ethereum users can not only transfer digital money through transactions, but
    they can develop smart contracts that allow them to perform transactions under
    certain conditions. For all intents and purposes, they can set conditions on the
    ways in which the value is transferred. Understandably, the idea of “programmable
    money” has attracted users, developers, and companies all over the world.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊用户不仅可以通过交易转移数字货币，还可以开发智能合约，使他们能够在特定条件下执行交易。就所有目的而言，他们可以在价值转移方式上设置条件。可以理解的是，“可编程货币”的概念吸引了全世界的用户、开发人员和公司。
- en: In addition, developers can implement and create applications that operate in
    the distributed network of the Ethereum blockchain, the DAPPs (decentralized applications).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发人员可以在以太坊区块链的分布式网络中实现和创建应用程序，即 DAPPs（去中心化应用程序）。
- en: With Ethereum, the blockchain becomes a decentralized IT platform where, in
    addition to transferring digital money, it is possible to distribute new applications
    and interact with other users of the network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了以太坊，区块链成为一个去中心化的 IT 平台，除了转移数字货币之外，还可以分发新的应用程序并与网络中的其他用户交互。
- en: Anyone can write a new application to run on the network blockchain, instead
    of on a centralized server. This does not only require overcoming any kind of
    censorship by a central authority, but is also immune to changes and allows all
    users to check the code before interacting with it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以编写一个新的应用程序，在区块链网络上运行，而不是在集中式服务器上运行。这不仅需要克服中央机构的任何形式的审查，而且还免疫于变化，并允许所有用户在与其交互之前检查代码。
- en: With Ethereum, blockchains are certainly not limited to the financial sector;
    they can also include electoral systems, registration of domain names, crowdfunding
    platforms, and intellectual properties, to name just a few examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以太坊而言，区块链并不仅限于金融领域；它们也可以包括选举系统、域名注册、众筹平台和知识产权等，仅举几例。
- en: In short, Ethereum is a revolutionary and far-sighted project, which in addition
    to being recognized as one of the best online investments, brought world fame
    to the young founder of the Ethereum network. This invention was awarded the prestigious
    World Technology Award in 2014.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以太坊是一个革命性且有远见的项目，除了被认为是最佳在线投资之一外，还为以太坊网络的年轻创始人带来了世界声誉。该发明于2014年荣获著名的世界技术奖。
- en: This chapter goes into detail about the components and techniques that define
    the Ethereum blockchain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了定义以太坊区块链的组件和技术。
- en: 4.1 Blockchain as a State Transition System
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 区块链作为状态转换系统
- en: 'The *Ethereum blockchain* is an open-source public blockchain. The model implemented
    by Ethereum can be summarized by three definitions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太坊区块链*是一种开源的公共区块链。以太坊实现的模型可以概括为三个定义：'
- en: '**Cryptographically secure:** The information security present in the ledger
    is guaranteed by complex mathematical algorithms and difficult to break cryptography.
    In other terms, it is almost impossible to cheat the system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码学安全性：** 账本中的信息安全由复杂的数学算法和难以破解的密码学保证。换句话说，欺骗系统几乎是不可能的。'
- en: '**Transactional singleton machine:** There is, by construction paradigm, a
    single canonical instance of the machine responsible for all transactions that
    are generated in the system. There is one global truth that everyone believes
    in.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务单例机：** 按照构造范式，负责系统中生成的所有交易的机器有一个唯一的规范实例。有一个全局真理，每个人都相信。'
- en: '**With shared-state:** The state stored in this machine is shared and accessible
    by all.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享状态：** 存储在此机器中的状态是共享的，并且所有人都可以访问。'
- en: Hence, the Ethereum blockchain paradigm is that of a cryptographically secure,
    shared-state transactional singleton machine. The Ethereum blockchain is essentially
    a state machine based on transactions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以太坊区块链的范式是一个具有密码学安全性的共享状态事务单例机。以太坊区块链本质上是一个基于交易的状态机。
- en: A state machine  is a graph of states and transitions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一个由状态和转换组成的图形。
- en: A state describes a period of time in the life of an object and is represented
    by vertices or *nodes*.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态描述了对象生命周期中的一段时间，并由顶点或*节点*表示。
- en: A transition connects two states together and is represented with a oriented
    arc.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换连接两个状态，并用有向弧表示。
- en: The exit from a state defines the response of the object to the occurrence of
    an event. An event is the recurrence of a phenomenon placed in time and in space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态定义了对象对事件发生的响应。事件是时间和空间中放置的现象的再现。
- en: Thus, a state machine is an automaton which, based on a series of input data,
    changes its internal state. (See Figure [4-2](#Fig2).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，状态机是一种自动机，根据一系列输入数据，改变其内部状态。（见图[4-2](#Fig2)。)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg)
- en: Figure 4-2
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2
- en: Example of a finite state machine
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机的示例
- en: 'From this, you can deduce:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，您可以推断：
- en: The status of the blockchain as the set of transactions present in the ledger.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链的状态是账本中存在的交易的集合。
- en: An event in the blockchain such as the creation of a transaction.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链中的事件，比如创建交易。
- en: A transaction function in the blockchain that takes on a state and new transaction
    and generates a new state.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链中的交易函数，接受一个状态和新交易，并生成一个新状态。
- en: 'So, let S be a state, TX a transaction, and APPLY the function of state transition.
    It can be formally defined:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设S为状态，TX为交易，APPLY为状态转换函数。可以正式定义如下：
- en: '*APPLY (S; TX) -> S0 or ERROR*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*APPLY (S; TX) -> S0 or ERROR*'
- en: Note that the Ethereum’s state machine begins with a state of genesis, analogous
    to an empty list before transactions have been made on the network.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以太坊的状态机从创世状态开始，类似于网络上进行交易之前的空列表。
- en: To cause a transition from one state to another, a transaction must be valid.
    When the various transactions are performed, this state of genesis passes from
    time to time to a subsequent state. (See Figure [4-3](#Fig3).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要导致从一种状态到另一种状态的转变，交易必须是有效的。当各种交易被执行时，这种起源状态会从时间到时间地转换为后续状态。（见图[4-3](#Fig3).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png)
- en: Figure 4-3
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3
- en: Transitions of states based on transactions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于交易的状态转换
- en: At any point in the junction, the final state represents the overall state of
    Ethereum.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何交汇点，最终状态代表以太坊的整体状态。
- en: The overall status of Ethereum contains transactions. Such transactions are
    grouped into blocks. Each block contains a number of transactions and is chained
    to the previous block. See Figure [4-4](#Fig4).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的整体状态包含交易。这些交易被分组到区块中。每个区块包含若干笔交易，并且与前一个区块链接。见图[4-4](#Fig4)。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png)
- en: Figure 4-4
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4
- en: Transaction flow
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 交易流程
- en: From a technical point of view, the general ledger can be viewed as a state
    transition system in which there is a state that contains all of the general ledger
    transactions, as well as a transition function that takes a state and a transaction
    and returns a new state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度看，总账可以被视为一个状态转换系统，其中有一个包含全部总账交易的状态，以及一个接受状态和交易并返回新状态的转换函数。
- en: In a conventional banking system, for example, state is a balance sheet, a transaction
    is a request to shift X from account A to account B, and the state transition
    function decreases the value of X in account A and increases the value of X in
    account B.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的银行系统中，状态是资产负债表，交易是将 X 从账户 A 转移到账户 B 的请求，并且状态转换函数会减少账户 A 中 X 的值，并增加账户 B 中
    X 的值。
- en: The state transition function then gives an error if A’s account has less than
    X at the start. Let TX = Send 70 from Luca to Sara.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 A 的账户在开始时少于 X，则状态转换函数会出错。让 TX = 从 Luca 发送 70 到 Sara。
- en: '*APPLY ((Luca: e50; Sara: e50); TX) = ERROR*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*APPLY ((Luca: e50; Sara: e50); TX) = ERROR*'
- en: Or, *let TX = Send e20 from Luca to Sara*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，*让 TX = 从 Luca 发送 e20 到 Sara*
- en: '*APPLY ((Luke: e50; Sara: e50); TX) = Luke: e30; Sara: e70*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*APPLY ((Luke: e50; Sara: e50); TX) = Luke: e30; Sara: e70*'
- en: 4.2 Ethereum Account
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 以太坊账户
- en: 'In Ethereum, the state is a buildup of objects called *accounts* that play
    a central role. There are two types of accounts:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，状态是由称为 *账户* 的对象构成的，它们起着核心作用。有两种类型的账户：
- en: Externally owned accounts (EOA)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部拥有账户（EOA）
- en: Contract accounts
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约账户
- en: In general, the EOAs are user accounts and are controlled by private keys and
    have no code associated with them. But contract accounts are controlled by their
    contract code and have an associated code. (See Figure [4-5](#Fig5).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，外部拥有账户（EOAs）是用户账户，由私钥控制，并且没有与之相关联的代码。但是合约账户由其合约代码控制，并具有相关的代码。（见图[4-5](#Fig5)。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg)
- en: Figure 4-5
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5
- en: Ethereum account
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊账户
- en: 4.2.1 The Account State
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 账户状态
- en: 'This account status is made up of four elements that are present regardless
    of the account type: (See Figure [4-6](#Fig6).)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此账户状态由四个元素组成，无论账户类型如何都会存在：（见图[4-6](#Fig6)。）
- en: '**Nonce (number only used once):** If the account is owned by a third party,
    this number indicates how many transactions have been sent from the account address.
    The nonce is then the number of contracts created by the account if it is a contract
    account.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性数字（Nonce）：** 如果该账户由第三方拥有，则此数字表示从该账户地址发送了多少笔交易。如果是合约账户，则 Nonce 是该账户创建的合约数量。'
- en: '**Balance:** This is the Wei number that this address owns. One ether is equal
    to 10^18.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**余额：** 这是该地址拥有的 Wei 数。一以太币等于 10^18。'
- en: '**MemoryRoot:** A 256-bit hash of the root node of a Merkle tree Patricia (refer
    to Chapter [2](520777_1_En_2_Chapter.xhtml)). This tree encodes the hash of the
    storage account of this account and is empty by default. For contract accounts,
    this is smart contract storage.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存根（MemoryRoot）：** 是 Merkle 树帕特里夏的根节点的 256 位哈希（参见第 [2](520777_1_En_2_Chapter.xhtml)
    章）。该树编码了该账户的存储账户的哈希，并默认为空。对于合约账户，这是智能合约存储。'
- en: '**CodeHash:** This is the hash code of an EVM (Ethereum Virtual Machine) account.
    For the contract account, this is the code that is hashed and stored as a codeHash.
    For external owned accounts, the codeHash is the hash of the empty string.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CodeHash：**这是EVM（以太坊虚拟机）账户的哈希代码。对于合约账户，这是哈希并存储为codeHash的代码。对于外部拥有的账户，codeHash是空字符串的哈希。'
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg)'
- en: Figure 4-6
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6
- en: Account status in Ethereum
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的账户状态
- en: 4.2.2 Externally Owned Accounts (EOAs)
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 外部拥有的账户（EOAs）
- en: 'Externally owned accounts  :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 外部拥有的账户 ：
- en: Have an Ether balance.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有以太坊余额。
- en: Can send to the transactions (they either transfer or activate the code of a
    contract).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发送交易（它们要么转账要么激活合约代码）。
- en: Are controlled by the private key.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由私钥控制。
- en: Do not have an associated code.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有关联代码。
- en: Note that every account is defined by a key pair—a private key and a public
    key. Like Bitcoin, Ethereum also uses ECDSA (Elliptic Curve Digital Signature
    Algorithm). Ethereum also uses the curve dictated by standard secp256k1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个账户由一对密钥定义——私钥和公钥。与比特币一样，以太坊也使用ECDSA（椭圆曲线数字签名算法）。以太坊还使用由标准secp256k1规定的曲线。
- en: You should already know how private keys and respective public keys work. However,
    Ethereum differs from Bitcoin by the generation of an *Ethereum* *address* *.*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经知道私钥和相应的公钥是如何工作的。但是，以太坊与比特币不同之处在于生成一个*以太坊* *地址* *.*
- en: These, like Bitcoin, are derived from the public key. However, to this the hash
    function Keccak 256 is applied. From the result of this function, you have the
    *public key hash* *.* From this you take the 20 bytes farther to the right and
    you will get the Ethereum address. All Ethereum addresses start with the 0x prefix.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（与比特币一样）是由公钥派生的。但是，对此应用了哈希函数Keccak 256。从此函数的结果中，你得到了*公钥哈希* *.* 从这里你再往右取 20
    字节，就会得到以0x前缀开头的以太坊地址。
- en: Accounts are indexed based on their address.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户是根据其地址进行索引的。
- en: Creating an external ownership account has no cost.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建外部拥有账户不需要费用。
- en: An EOA uses transactions (or messages, as you’ll see) to interact with the Ethereum
    blockchain network.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EOA使用交易（或消息，如你将看到的）与以太坊区块链网络进行交互。
- en: They can send transactions to transfer digital money to other accounts of external
    property.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以发送交易，将数字货币转移到其他外部财产账户。
- en: They can be send to a transaction to a contract account to invoke a smart contract  .
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以将交易发送到合约账户以调用智能合约。
- en: 4.2.3 Contract Accounts
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 合约账户
- en: 'A contract account  represents a smart contract, which means:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 合约账户 代表智能合约，这意味着：
- en: It has an address.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个地址。
- en: It has an Ether balance.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有以太坊余额。
- en: It has an associated code.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有关联代码。
- en: It is controlled by the associated code.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由关联代码控制。
- en: The execution of the code is triggered/invoked by transactions or messages (calls)
    received from other accounts (EOAs or contract accounts).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的执行是由来自其他账户（EOA或合约账户）收到的事务或消息（调用）触发/调用的。
- en: Once executed, it performs operations of arbitrary complexity (Turing complete)
    and manipulates its own persistent archive; it can have its own permanent state
    it can call other contracts.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦执行，它执行任意复杂性的操作（图灵完备）并操纵其自己的持久存档；它可以拥有自己的永久状态并调用其他合约。
- en: The contract address is generated by hashing the SHA-3, also called Keccak-256,
    the address of the sender’s account and their nonce, and taking the rightmost
    20 bytes of this result. Contract accounts have a cost both in creation and in
    use (execution), because they use computational resource and network storage  .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 合约地址是通过对发送者账户和它们的nonce的SHA-3哈希，也称为Keccak-256，以及取此结果的最右20字节而生成的。合约账户在创建和使用（执行）方面都有成本，因为它们使用了计算资源和网络存储。
- en: 4.2.4 Differences Between Externally Owned and Contract Accounts
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 外部所有权和合约账户之间的区别
- en: First of all, it is good to clarify that to participate in the Ethereum network,
    an external ownership account is required. Furthermore, any type of message sent
    through the Ethereum network has a cost because it uses computational and archiving
    resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，很重要的是澄清，在以太坊网络中参与需要一个外部所有权账户。此外，通过以太坊网络发送的任何类型的消息都会产生成本，因为它使用了计算和存档资源。
- en: That means an external owned account can send or deliver the messages to other
    account owned externally or to other contract creating accounts. (See Figure [4-7](#Fig7).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着外部所有权账户可以向其他外部账户或其他创建合约的账户发送或传递消息。（见图[4-7](#Fig7)。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg)
- en: Figure 4-7
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-7
- en: Transaction from EOA
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 来自EOA的交易
- en: That means a message between two external owned accounts is simply a transfer
    of value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个外部所有权账户之间的消息仅仅是价值的转移。
- en: However, a message from an owned account external to a contract account activates
    the contract account code, allowing it to perform various actions (examples include
    transfer tokens, write to internal memory, mint new tokens, run some calculations,
    create a brand-new contracts, etc.).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，来自于合约账户外部的消息会激活合约账户代码，使其能够执行各种操作（例如转移代币，写入内部存储器，铸造新代币，运行一些计算，创建全新合约等）。
- en: In other words, through a message from an ownership account external to a contract
    account invokes a smart contract. (See Figure [4-8](#Fig8).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过来自合约账户外部的所有权账户的消息调用智能合约。（见图[4-8](#Fig8)。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg)
- en: Figure 4-8
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-8
- en: Transaction example of account contracts
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 合约账户交易示例
- en: Unlike externally owned accounts, the contract accounts won’t be able to start
    new transactions. On the contrary, the accounts of the contracts can generate
    transactions only in response to different transactions received (from an external
    ownership account or another contract account). You will find out more about contract
    calls in the section entitled “Transaction and Message.”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部拥有的帐户不同，合同帐户将无法启动新的交易。 相反，合同的帐户只能对接收到的不同交易（来自外部拥有权帐户或另一个合同帐户）生成交易。 您将在“交易和消息”部分了解有关合同调用的更多信息。
- en: Hence, any action that occurs on the Ethereum blockchain is always activated
    by transactions activated by externally regulated accounts.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以太坊区块链上发生的任何操作都是由外部受监管帐户激活的交易激活的。
- en: '4.2.5 Storing Key: Encrypted Keystore'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 存储密钥：加密 keystore
- en: Every private key/address pair is encoded in a keyfile and the keyfiles are
    JSON text files. Additionally, the critical component of the keyfile, the private
    key of the account, is always encrypted with the password entered during the account
    creation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个私钥/地址对都编码在一个密钥文件中，密钥文件是 JSON 文本文件。 此外，密钥文件的关键组件，帐户的私钥，始终使用在帐户创建期间输入的密码加密。
- en: The keyfile is located in the keystore subdirectory of the data directory Ethereum
    node that created the account or imported it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥文件位于创建或导入帐户的以太坊节点的数据目录中的 keystore 子目录中。
- en: The keystore uses the elliptic curve secp256k1 as defined in the standards for
    efficient Encryption, implemented by the libsecp256k library and found at github.com/ethereum/go-ethereum/accounts.
    Accounts are stored on disk in the Web3 secret storage format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Keystore 使用椭圆曲线 secp256k1，该曲线在有效加密标准中定义，由 libsecp256k 库实现，并在 github.com/ethereum/go-ethereum/accounts
    找到。 帐户以 Web3 密钥存储格式存储在磁盘上。
- en: 'After creating an encrypted keystore for Ethereum accounts, you can use this
    account manager for all cycle requirements account life. This includes the basic
    features:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以太坊帐户的加密 keystore 后，您可以将此帐户管理器用于所有周期要求帐户生命。 这包括基本功能：
- en: Creation of new accounts
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新帐户
- en: Elimination of existing ones
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有帐户的消除
- en: Updating of access credentials
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新访问凭据
- en: Export of existing accounts
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有帐户的导出
- en: Import to another device
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入到另一个设备
- en: Although the keystore defines the encryption level used to store accounts, there
    is no global master password capable of granting access to everyone.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 keystore 定义了用于存储帐户的加密级别，但没有全局主密码可以授予所有人访问权限。
- en: Rather, each account is managed individually and is stored on disk in its individually
    encrypted format, ensuring separation is much cleaner and uses more rigorous credentials.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，每个帐户都是单独管理的，并且以其单独加密格式存储在磁盘上，确保分离更加清洁，并使用更严格的凭据。
- en: 'This individuality means that any operation that requires access to an account
    must provide authentication credentials required for that particular account in
    the form of a passphrase:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种个性化意味着任何需要访问账户的操作都必须提供特定账户所需的身份验证凭据，形式为密码：
- en: When creating a new account, the caller must provide a passphrase with which
    to encrypt the account. This passphrase will be required for any subsequent access.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新账户时，调用方必须提供用于加密账户的密码。此密码将需要用于任何后续访问。
- en: When deleting an existing account, the caller must provide a passphrase to verify
    account ownership.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有账户时，调用方必须提供密码以验证账户所有权。
- en: When updating an existing account, the caller must provide both the current
    and the new passphrase. After completing the operation, the account will no longer
    be accessible via the previous passphrase.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有账户时，调用方必须提供当前密码和新密码。完成操作后，账户将无法再通过先前的密码访问。
- en: When exporting an existing account, the caller must provide both a current passphrase
    to decrypt the account, and a passphrase to reencode it before returning the key
    file to the user. This is necessary to allow the movement of the accounts between
    machines and applications without sharing credentials.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出现有账户时，调用方必须提供当前密码以解密账户，以及密码以重新编码它，然后将密钥文件返回给用户。这是必要的，以允许在不共享凭据的情况下在计算机和应用程序之间移动账户。
- en: When importing a new account, the caller must provide both the encryption passphrase
    of the keyfile to be imported and a new passphrase with which to store the account.
    This is necessary to allow the storage of accounts with different credentials
    than those used to move them.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入新账户时，调用方必须提供要导入的密钥文件的加密密码和用于存储账户的新密码。这是必要的，以允许存储具有不同凭据的账户，这些凭据与用于移动它们的凭据不同。
- en: Therefore  , there are no recovery mechanisms for the loss of a passphrase.
    The cryptographic properties of the encrypted keystore ensure that the account
    credentials cannot be brutally forced in any way. For account management, various
    Wallet apps are available to manage them efficiently.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于密码遗失没有恢复机制。加密密钥库的密码学属性确保无法以任何方式强制获取账户凭据。对于账户管理，有各种钱包应用程序可用于高效管理它们。
- en: 4.3 World State
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 世界状态
- en: The world state of the Ethereum blockchain is a mapping between the Ethereum
    address (160-bit identifiers) and the account state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的世界状态是以太坊地址（160位标识符）和账户状态之间的映射。
- en: This mapping is maintained through a data structure called the Modified Merkle
    Patricia tree. Let’s see what it is.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射通过一种名为修改的默克尔帕特里夏树的数据结构来维护。让我们看看它是什么。
- en: 4.3.1 Trie
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 Trie
- en: A Trie  , also called a *digital tree* or *prefix tree* , is a data structure
    ordered tree used to store a dynamic set or array associative where the keys are
    generally strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Trie，也称为*数字树*或*前缀树*，是一种有序树数据结构，用于存储动态集合或数组关联数组，其中键通常为字符串。
- en: In general, the position of a node in the tree defined the key that it is associated
    with. Nodes do not keep a copy of their own key, instead they depend on the position
    of the node in the tree. (See Figure [4-9](#Fig9).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，节点在树中的位置定义了它所关联的键。节点不保存自己的键的副本，而是依赖于树中节点的位置。（参见图[4-9](#Fig9)。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg)
- en: Figure 4-9
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-9
- en: Example of a Trie
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Trie 示例
- en: The root of the tree is associated with the empty string, and all the descendants
    of a node share the prefix associated with that node. Not all nodes necessarily
    represent a significant key, which typically is found instead in the leaves and
    possibly in some internal nodes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 树的根与空字符串相关联，节点的所有后代共享与该节点相关联的前缀。并非所有节点都必然表示一个重要的键，通常这些键可以在叶子节点以及可能的一些内部节点中找到。
- en: 4.3.2 The Radix Tree
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 Radix 树
- en: Note that the Radix tree  , also called a compact prefix tree or radix trie,
    is one data structure that represents a Trie in which space is optimized. In this
    tree, unlike the Trias, each leaf node is an only child and is joined with the
    parent node. (See Figure [4-10](#Fig10).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Radix 树，也称为紧凑前缀树或基数字典树，是一种表示 Trie 的数据结构，在这种树中，与 Trie 不同的是，每个叶节点都是唯一的子节点，并与父节点连接在一起。（参见图[4-10](#Fig10)。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg)
- en: Figure 4-10
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10
- en: Example of Radix tree
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Radix 树示例
- en: Here the result is that the number of children of each internal node is at most
    the value r, a positive integer assigned to the radix variable of the radix tree.
    The value is a power of 2x, where x is greater than or equal to 1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的结果是每个内部节点的子节点数最多为值 r，r 是基数变量的正整数赋值给基数树。该值是 2x 的幂，其中 x 大于或等于 1。
- en: This makes radix trees much more efficient for sets where the keys are long
    strings, and for shared sets of keys with long prefixes. Thus, if radix equals
    2, you get a binary Radix tree.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得基数树对于键是长字符串的集合以及具有长前缀的键的共享集合更加高效。因此，如果基数等于 2，你会得到一个二进制 Radix 树。
- en: Let k be the length of the keys. Radix trees allow searching, insertion, and
    elimination in time O (k) This doesn’t seem to be an advantage, but they can perform
    these operations with fewer comparisons and require many fewer nodes than balanced
    trees.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让 k 为键的长度。Radix 树允许在 O(k) 的时间内进行搜索、插入和删除。这似乎不是一个优势，但它们可以执行这些操作，比平衡树需要更少的比较，并且需要比平衡树少得多的节点。
- en: In general, Radix trees are useful for building associative arrays of keys that
    can be expressed as strings. They’ve particular application in IP routing, where
    the ability to contain large ranges of values with few numbers of exceptions is
    especially suited to the hierarchical organization of IP addresses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基数树对于构建可表示为字符串的键的关联数组很有用。它们在IP路由中具有特定的应用，其中容纳大范围的值并且例外较少的能力特别适用于IP地址的分层组织。
- en: 4.3.3 Patricia Trie
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 Patricia Trie
- en: Note that a Patricia trie  is a type of Radix tree where the radix equals 2\.
    (See Figure [4-11](#Fig11).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Patricia trie是基数树的一种类型，其中基数等于2（见图[4-11](#Fig11)）。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg)
- en: Figure 4-11
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11
- en: Tree radix, radix = 2
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 树的基数，基数 = 2
- en: In other words, it is a binary radix tree (radix = 2), where each node has two
    child nodes. So at each cross of the tree, for each node (which is not leaf) you
    have in front of a binary choice (two branches). This means that each bit of the
    key is compared individually and each node is a two-way branch (that’s the left
    and right).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它是一种二进制基数树（基数=2），其中每个节点都有两个子节点。因此，在树的每个交叉点处，对于每个节点（不是叶子节点），您都面临一个二进制选择（两个分支）。这意味着键的每个位都会被单独比较，并且每个节点都是一个双向分支（即左和右）。
- en: A Patricia trie is a special variant of the binary radix tree (radix = 2), where
    instead of explicitly storing every bit of every key, the nodes only store the
    position of the first bit that distinguishes two subtrees from each other.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Patricia trie是二进制基数树（基数=2）的特殊变体，其中节点仅存储区分两个子树的第一个位的位置，而不是明确存储每个键的每个位。
- en: During the intersection, the algorithm examines the indexed bit of the search
    key and chooses the appropriate right or left subtree. Among the notable features
    of Patricia trie is that it inserts only a single node for each stored key, making
    Patricia much more compact than a standard binary trie. We provide an example
    for a better understanding of a Patricia trie. Suppose you put three keys – smiled,
    smiles, and smile – in a Patricia Trie.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉点处，算法检查搜索键的索引位，并选择适当的右子树或左子树。Patricia trie的显着特点之一是，它只为每个存储的键插入一个节点，使得Patricia比标准二叉trie紧凑得多。我们提供了一个Patricia
    trie的示例，以便更好地理解。假设您在Patricia Trie中放入了三个键：smiled，smiles和smile。
- en: The binary representation of these three keys is shown in Figure [4-12](#Fig12).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个键的二进制表示如图所示[4-12](#Fig12)。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg)
- en: Figure 4-12
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-12
- en: Example by Patricia trie
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Patricia trie示例
- en: We note that smile is a prefix of smiled and smiles.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到smile是smiled和smiles的前缀。
- en: Analyzing the binary representation, we can see that the former bit that differs
    (from left to right) is 0 (highlighted in red in the second line). For this reason,
    smiled will be the left child of smile. Likewise, smiles will be smiled’ s right
    child because they share the same prefix up to a bit whose value is 1 (highlighted
    in red in the third line). The resulting Patricia trie after entering the three
    keys is shown in Figure [4-13](#Fig13).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 分析二进制表示，我们可以看到左起第一个不同的比特位是 0（在第二行中用红色突出显示）。因此，smiled 将是 smile 的左子节点。同样，smiles
    将是 smiled 的右子节点，因为它们共享相同的前缀，直到比特位的值为 1（在第三行中用红色突出显示）。输入三个密钥后得到的 Patricia trie
    如图[4-13](#Fig13)所示。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg)
- en: Figure 4-13
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-13
- en: Example of a Patricia trie
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Patricia trie 的示例
- en: Also, because the actual keys are no longer stored explicitly, you need to do
    a full comparison of the keys on the record indexed to confirm a match. About
    this, Patricia has a particular resemblance to indexing using a hash table.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际密钥不再显式存储，您需要对记录索引上的密钥进行全面比较以确认匹配。关于此，Patricia 与使用哈希表进行索引具有特定相似性。
- en: 4.3.4 Ethereum Modified Merkle Patricia Trie
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 以太坊修改后的 Merkle Patricia Trie
- en: This section explains how Ethereum changed the Merkle Patricia trie.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了以太坊如何更改 Merkle Patricia trie。
- en: In the modified Merkle Patricia tree, the keys of the tree are represented by
    Ethereum addresses (20-byte, 160-bit addresses), represented in hexadecimal notation
    (16 characters). The values from the account state correspond to that Ethereum
    address.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的 Merkle Patricia 树中，树的密钥由以十六进制表示（16 个字符）的以太坊地址（20 字节，160 位地址）表示。帐户状态中的值对应于该以太坊地址。
- en: In the case of a cryptographically secure Merkle tree, each node is referenced
    by its hash, and the root of the tree acts as a cryptographic imprint of the whole
    tree. In other words, the deterministic cryptographic hash of each node is used,
    precisely, as a pointer to the node itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密安全的 Merkle 树的情况下，每个节点都由其哈希引用，并且树的根作为整个树的密码印记。换句话说，每个节点的确定性密码哈希被精确地用作指向节点本身的指针。
- en: This provides a form of cryptographic authentication to the data. If the root
    hash of a certain trie is publicly known, then anyone can provide evidence that
    the trie has a given value at a specific path providing the nodes go up every
    step of the way. It is impossible for an attacker providing proof of a pair (path,
    value) that they do not exist since the root hash is based on all the underlying
    hashes, so any changes would change the root hash. This is the *Merkle* part of
    the tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这为数据提供了一种形式的密码身份验证。如果某个 trie 的根哈希是公开已知的，则任何人都可以提供证据，证明该 trie 在特定路径上具有给定值，只要节点一直向上走。攻击者不可能提供一对（路径，值）的证据表明它们不存在，因为根哈希基于所有底层哈希，所以任何更改都会更改根哈希。这就是树的
    *Merkle* 部分。
- en: 'Additionally, there are three different types of nodes in the Modified Merkle
    Patricia trie:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在修改后的默克尔帕特里夏树中有三种不同类型的节点：
- en: '**Extension Node:** Contains a part of the common key for multiple nodes (encoded
    path) and contains a reference to a subsequent node (key), or the hash of the
    next node. Therefore, a constituted knot from these two fields (encoded path,
    key).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展节点：** 包含多个节点的共同键的一部分（编码路径），并包含对后续节点（键）的引用，或下一个节点的哈希。因此，这两个字段（编码路径、键）构成了一个节点。'
- en: '**Branch Node:** Contains pointers to different nodes that have the same key
    prefix. A branch node has 17 fields, one for each character of the hexadecimal
    alphabet (16 characters) and a value field, to contain the final target value
    in case the path has been completely crossed, i.e., if a pair exists (key: Ethereum
    Address, value: Account State) where the key (Ethereum Address) terminates in
    the branch node. This node consists of 17 fields (v0 ... v15, value).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支节点：** 包含指向具有相同键前缀的不同节点的指针。分支节点有17个字段，每个字段对应十六进制字母表的一个字符（16个字符），以及一个值字段，用于在路径完全穿过时包含最终目标值，即如果存在一对（键：以太坊地址，值：账户状态），其中键（以太坊地址）在分支节点终止。该节点由17个字段组成（v0
    ... v15，值）。'
- en: '**Leaf Node:** Contains a value and the remainder of the key (called key-end).
    A key to a leaf node (and therefore your Ethereum Address) is the concatenation
    of a prefix from all of its parents and the key-end of the leaf node.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点：** 包含一个值和键的剩余部分（称为键尾）。叶节点的键（因此您的以太坊地址）是其所有父节点的前缀和叶节点的键尾的连接。'
- en: An extension node only ever has one child node. For this reason, the child node
    is only ever a branch node. In fact if it pointed to a leaf node, they would be
    combined into a single leaf knot. If it pointed to an extension node, these would
    be combined into a single extension node. In Figure [4-14](#Fig14), you can see
    the structure of the various types of nodes.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展节点只有一个子节点。因此，子节点只能是分支节点。实际上，如果它指向一个叶子节点，它们将合并为单个叶子节点。如果它指向一个扩展节点，这些将合并为单个扩展节点。在图[4-14](#Fig14)中，您可以看到各种节点类型的结构。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg)
- en: Figure 4-14
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-14
- en: Ethereum Modified Merkle Patricia trie
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊修改后的默克尔帕特里夏树
- en: For simplicity, the value field hosts the account balance. But in reality, it
    hosts the result of the RLP function (serialization function) applied to the Account
    State (which contains the four fields). Instead, the hash function used for nodes
    is SHA 3.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 简单起见，值字段承载的是账户余额。但实际上，它承载的是应用于账户状态（包含四个字段）的RLP函数（序列化函数）的结果。而用于节点的哈希函数是SHA 3。
- en: As you can see, both extension nodes and leaf nodes consist of two fields, a
    field dedicated to the path of the address and a field dedicated to the value.
    In the case of the extension node, this value is the hash of the node it points
    to. In the case of the leaf node, it is the account being serialized.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，扩展节点和叶节点都由两个字段组成，一个字段专门用于地址的路径，另一个字段专门用于值。对于扩展节点，该值是它指向的节点的哈希。对于叶节点，它是正在序列化的账户。
- en: But how does Ethereum distinguish between the two nodes?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但以太坊如何区分这两种节点呢？
- en: 'It adds a prefix. This is the field that in the figure is called prefix . Assume
    that a single hexadecimal character equals the unit of 1 nibbe. So, one nibbe
    is equivalent to 4 bits. Therefore, these prefixes are used:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了一个前缀。这是图中称为前缀的字段。假设一个单独的十六进制字符等于 1 个 nibbe 单位。因此，一个 nibbe 等于 4 位。因此，这些前缀被用于：
- en: 0 is an extension node that has an even number of nibbes in the field referred
    to the path.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 是一个扩展节点，其字段中引用的路径上有偶数个字节。
- en: 1 is an extension node that has an odd number of nibbes in the field referred
    to the path.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 是一个扩展节点，其字段中引用的路径上有奇数个字节。
- en: 2 is a leaf node that has an even number of nibbes in the field referred to
    path.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 是一个叶节点，其字段中引用的路径上有偶数个字节。
- en: 3 is a leaf node that has an odd number of nibbes in the field referred to the
    path.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 是一个叶节点，其字段中引用的路径上有奇数个字节。
- en: Why is it important to distinguish between an extension node and a leaf node?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 区分扩展节点和叶节点之间的重要性是什么？
- en: Because if it is an extension node then the value is a pointer to a branch node
    (that is, its hash). While if it is a leaf node then the value is the same as
    the account state serialized through the RLP function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果它是一个扩展节点，那么该值是一个分支节点的指针（即，它的哈希）。而如果它是一个叶节点，那么该值就与通过 RLP 函数序列化的账户状态相同。
- en: All Merkle Tries in Ethereum are Ethereum Merkle Patricia Trie. This structure
    is maintained through a flat key/value DB.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中的所有 Merkle Trie 都是以太坊 Merkle Patricia Trie。通过一个平坦的键/值 DB 来维护这种结构。
- en: 4.3.5 Storage Root
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 存储根
- en: A hash 256-bit root node or base node of a Merkle Patricia tree encodes the
    content of the account storage in the trie as a mapping from the Keccak hash to
    256 bit to integer values encoded in 256-bit RLP. This, then, in the case of contract
    accounts, is the storage of the smart contract. Figure [4-15](#Fig15) illustrates
    the concept.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个哈希 256 位根节点或 Merkle Patricia 树的基节点将账户存储的内容编码为 trie 中从 Keccak 哈希到 256 位 RLP
    编码的整数值的映射。因此，在合约账户的情况下，这是智能合约的存储。图 [4-15](#Fig15) 说明了这个概念。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png)
- en: Figure 4-15
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-15
- en: Storage root  is the root of or base of a Merkle Patricia Trie for storage of
    the account
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 存储根是用于存储账户的 Merkle Patricia Trie 的根或基础。
- en: 4.3.6 Why Merkle Trees?
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 为什么使用 Merkle 树？
- en: 'The power to store all this information efficiently in Merkle trees  is incredibly
    useful in Ethereum, and for those we call *light nodes* . A blockchain is handled
    by a group of nodes. Generally, there are two types of nodes: full nodes and light
    nodes.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些信息高效地存储在默克尔树中的能力在以太坊中非常有用，特别是对于我们所谓的*轻节点*而言。区块链由一组节点处理。通常有两种类型的节点：全节点和轻节点。
- en: A full node synchronizes the blockchain by archiving the entire chain, from
    the originating block to the last block, and performs all operations contained
    therein. Miners usually keep full nodes for the mining process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整节点通过存档整个链，从起始块到最后一个块，并执行其中包含的所有操作来同步区块链。矿工通常保留完整节点用于挖矿过程。
- en: It is also possible to download a full node without mining. Regardless, each
    full node contains the entire blockchain. But as long as a node does not need
    to execute every transaction or query historical data, it’s not really necessary
    to store the entire blockchain.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以下载一个没有挖矿的完整节点。无论如何，每个完整节点都包含整个区块链。但只要一个节点不需要执行每个交易或查询历史数据，就不真正需要存储整个区块链。
- en: This is where the concept of a lightweight node comes in. Instead of downloading
    and storing the entire chain and executing all of the light node’s transactions,
    they only download the chain of headers, from the originating block to the current
    one, without executing any transactions or retrieving any state. Since the light
    nodes have access to the block headers, which contain the hashes of three Merkle
    Patricia trie trees, they can still easily generate and receive verifiable responses
    to transactions, events, balances, etc.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是轻量级节点概念的应用之处。与其下载和存储整个链并执行所有轻节点的交易，它们只下载头部链，从起始块到当前块，而不执行任何交易或检索任何状态。由于轻节点可以访问区块头，其中包含三棵默克尔帕特里夏树的哈希，因此它们仍然可以轻松生成和接收到交易、事件、余额等的可验证响应。
- en: 4.4 Ethereum Virtual Machine
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊虚拟机
- en: The Ethereum Virtual Machine, often abbreviated EVM, is the computing center
    that allows the execution of complex codes (smart contracts) on top of the Ethereum
    platform. It is therefore a virtual machine, i.e. software capable of emulating
    a physical machine in all respects, through a virtualization process in which
    physical resources (CPU, RAM, hard disk, ...) are assigned to the applications
    that are run on the virtual machine (including its operating system). It plays
    a role similar to what the Java Virtual Machine (JVM) plays for Java, that is,
    a safe environment, isolated and protected from the rest of the running processes
    or files on the host computer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机，通常简称为EVM，是允许在以太坊平台上执行复杂代码（智能合约）的计算中心。因此，它是一台虚拟机，即能够通过虚拟化过程在所有方面模拟物理机器的软件，通过该过程，将物理资源（CPU、RAM、硬盘等）分配给在虚拟机上运行的应用程序（包括其操作系统）。它扮演着类似于Java虚拟机（JVM）为Java所扮演的角色，也就是说，一个安全的环境，与主机计算机上运行的其他进程或文件隔离和保护。
- en: A crash or malfunction of the EVM does not cause side effects in the host computer’s
    file system and operating system processes. EVM also acts as a guarantor for the
    network nodes, which “offer” their own physical infrastructure for the storage
    and processing of potentially harmful smart contracts. The open and permissionless
    nature of the Ethereum blockchain (like that of Bitcoin), in fact, allows anyone
    to be part of it and deploy potentially malicious smart contracts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: EVM 的崩溃或故障不会在主机计算机的文件系统和操作系统进程中引起副作用。EVM 还充当网络节点的保证人，“提供”它们自己的物理基础设施用于存储和处理潜在有害的智能合约。以太坊区块链的开放和无需许可的特性（就像比特币一样）实际上允许任何人都可以成为其一部分，并部署潜在有害的智能合约。
- en: 4.5 What Is a Gas?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 什么是 Gas？
- en: A very important concept in Ethereum is that of commissions. Consider that every
    node runs EVM as part of the verification and validation protocol. Every transaction
    and each smart contract is executed on the EVM for each node on the network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的一个非常重要的概念是手续费。请考虑每个节点都会作为验证和验证协议的一部分运行 EVM。每个交易和每个智能合约都会在网络上的每个节点上执行。
- en: Clearly this is not to optimize the efficiency of the calculation. This parallel
    processing is redundantly parallel. The goal is to offer a more efficient method
    of reaching consensus without the need for trusted third party. The fact that
    the *executions of smart contracts and transactions* are redundantly replicated
    through knots makes them very expensive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这并不是为了优化计算的效率。这种并行处理是多余的并行。目标是提供一种更有效的达成共识的方法，而不需要信任第三方。智能合约和*交易*的执行通过节点冗余复制，因此非常昂贵。
- en: This creates an incentive not to use the blockchain for computation, which can
    be performed off the platform. Any calculation that occurs because of a transaction
    on the Ethereum network comes at a cost.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这激励人们不要将区块链用于计算，这些计算可以在平台之外完成。以太坊网络上的任何交易引发的计算都是有成本的。
- en: Note that *gas* is the name of the execution commission that the senders of
    the transactions have to pay for each task carried out on the blockchain Ethereum.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 *gas* 是以太坊区块链上的执行手续费，发送交易的人必须为每项任务支付该费用。
- en: The name gas is developed by the fact that this tax acts like crypto-fuel, driving
    the motion of smart contracts and of *transactions* *.* The gas and ether are
    purposefully dissociated since the gas units align to the calculation units having
    a natural cost, while the price of the ether generally fluctuates due to market
    forces. The gas is the unit used to count the fees required for a certain computation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 的命名是因为此税项类似于加密燃料，推动着智能合约和*交易*的运动。Gas 和以太被有意区分开来，因为 gas 单位对齐于具有自然成本的计算单位，而以太的价格通常因市场力量而波动。Gas
    是用于计算所需费用的单位。
- en: The price of gas is the amount of Ether we are ready to spend on every unit
    of gas and is counted in the gwei. Note that the Wei is the smallest unit of Ether,
    where 10^18 Wei denotes one Ether. One gwei is 1,000,000,000 Wei. With every computation/transaction,
    a sender sets a gasLimit and that means the gas cost or price *(*gasprice*)*.
    In this case, the gas limit refers to the full amount of gas that we are willing
    to spend on a particular computation or transaction. The Gas cost refers to the
    amount of Gwei we are ready to pay. The product of the gas cost and the gas limit
    represent the amount of Ether that the sender is ready to pay for the execution
    of a computation or transaction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 气体价格是我们准备在每单位气体上花费的以太数量，并以 gwei 计算。请注意，Wei 是以太的最小单位，其中 10^18 Wei 表示一以太。一个 gwei
    是 1,000,000,000 Wei。在每次计算/交易时，发件人设置一个 gasLimit，这意味着气体成本或价格（*gasprice*）。在这种情况下，气体限制指的是我们愿意在特定计算或交易上花费的全部气体量。气体成本指的是我们愿意支付的
    Gwei 量。气体成本和气体限制的乘积代表发件人愿意为执行计算或交易支付的以太数量。
- en: Here we will consider an example of a sender with a limit of gas cost. Suppose
    the sender gives the gas limit as 50,000 and a gas price of 20 gwei. This means
    that the sender is ready to spend a high amount of 50000 x 20 gwei = 1,000,000,000,000,000
    Wei = 0\. 001 Ether to execute that computation or transaction. (See Figure [4-16](#Fig16).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将考虑一个具有气体成本限制的发件人的示例。假设发件人将气体限制设为 50,000，并设置气体价格为 20 gwei。这意味着发件人准备花费高达
    50000 x 20 gwei = 1,000,000,000,000,000 Wei = 0.001 以太来执行该计算或交易。（见图 [4-16](#Fig16)。)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg)
- en: Figure 4-16
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-16
- en: Example of payment of commissions for a transaction
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 交易手续费支付示例
- en: If a user has a large amount of Ether in their balance account to cover this,
    the transaction or computation can be executed. The sender is then refunded for
    the amount of gas not used during the final stage of the transaction or computation.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在其余额账户中有大量以太来支付此费用，那么交易或计算就可以执行。在交易或计算的最后阶段，发件人将获得未使用的气体数量的退款。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg)
- en: Figure 4-17
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-17
- en: Example of reimbursement for unused gas at the end of a computation
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结束后未使用气体的退款示例
- en: If the sender will not give the gas needed to perform a transaction, the transaction
    will run out and would not be considered valid. In this case, the processing of
    the transaction would stop and any path changes that would be reverted in order
    to return to the Ethereum state prior to the computation. Also, a failed transaction
    would be logged to show which operation was attempted and where it failed. And
    since the car has already spent resources to perform the calculations before running
    out of gas, no amount is refunded to the sender. (See Figure [4-18](#Fig18).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送者不提供执行交易所需的燃气，交易将耗尽并被视为无效。在这种情况下，交易的处理将停止，并且任何已经回滚以返回到计算前以太坊状态的路径更改都将被还原。此外，将记录一个失败的交易以显示尝试了哪些操作以及失败的位置。由于汽车已经在耗尽燃气之前进行了计算，因此不会向发送者退款。（见图
    [4-18](#Fig18).）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg)
- en: Figure 4-18
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-18
- en: Example of a failed transaction due to a lack of gas
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于燃气不足而导致交易失败的示例
- en: Note that the whole price spent by the sender for gas is sent to the address
    of the miner. As miners are spending their resources to run the calculations and
    identify the computations, they receive the gas tax as granted. (See Figure [4-19](#Fig19).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，发送者为燃气所支付的全部费用都将发送到矿工的地址。由于矿工正在耗费资源来运行计算并识别计算，他们会收到作为燃气税的金额。（见图 [4-19](#Fig19).）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg)
- en: Figure 4-19
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-19
- en: Example of a miner receiving a commission
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工接收佣金的示例
- en: So, it is clear that the higher the price of gas, the higher the mark the miner
    will get from computation. In this way, miners are free to select which computations
    to validate and which to avoid. To direct senders to a gas price they deem acceptable,
    miners have the option of advertising a cheaper cost for which they are willing
    to perform transactions. Miners will include transactions with the highest fees,
    so the more a user is willing to pay for gas, the more their transaction will
    quickly be included in a block. It is possible to see the gas required for each
    operation on this sheet.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，燃气价格越高，矿工从计算中获得的分数就越高。这样一来，矿工可以自由选择哪些计算要验证，哪些要避免。为了引导发送者选择他们认为合适的燃气价格，矿工可以选择宣传一个更便宜的费用，以此来执行交易。矿工会包含手续费最高的交易，因此，用户愿意为燃气支付的越多，他们的交易就越快被包含在一个区块中。你可以在这张表上看到每个操作所需的燃气。
- en: 4.5.1 Gas for Storing
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 储存用的燃气
- en: Not only is gas used to pay for the calculation steps, but it is also used to
    pay for memory usage. The rates for archiving have some nuanced aspects. For example,
    since a major memory increases the size of the Ethereum state database on all
    nodes, there is an incentive to keep the amount of data small archived.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 气体不仅用于支付计算步骤，而且用于支付内存使用。存档的费率具有一些微妙的方面。例如，由于主要内存会增加所有节点上以太坊状态数据库的大小，因此有一个保持存档数据量小的激励。
- en: 'For this reason, if a transaction has a phase when it cancels an entry in the
    storage space, the execution commission of that transaction is canceled and a
    refund is granted to free up storage space. In addition, the storage costs are
    very high. When we develop a smart contract we have three ways to access memory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，如果一笔交易在取消存储空间中的条目时有一个阶段，那么该交易的执行佣金将被取消，并且将退还款项以释放存储空间。此外，存储成本非常高。当我们开发智能合约时，有三种访问内存的方式：
- en: 'Stack: Access to the volatile stack.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈：访问易失性栈。
- en: 'Memory: Access to volatile storage or memory.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：访问易失性存储或内存。
- en: 'Storage: Access to non-volatile storage. The most expensive is non-volatile
    storage.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：访问非易失性存储。最昂贵的是非易失性存储。
- en: Figure [4-20](#Fig20) shows a table with the gas required for each memory operation.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4-20](#Fig20)显示了每个内存操作所需的气体表。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg)
- en: Figure 4-20
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-20
- en: List of gas costs for each operation on the memory
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内存操作的气体成本列表
- en: In conclusion, storing data constantly on Ethereum is extremely costly. There
    is no point in using Ethereum to keep data. Only the data needed for the current
    operations should be stored; delegate archiving to another solution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，不断在以太坊上存储数据的成本极高。使用以太坊保留数据是没有意义的。应仅存储当前操作所需的数据；将存档委托给另一个解决方案。
- en: However, a great method would be to archive in Ethereum only the root or the
    base hash of the Merkle tree as proof of data tampering on an external service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个很好的方法是仅在以太坊中存档默克尔树的根或基本哈希，作为对外部服务数据篡改的证明。
- en: It is important to understand the smart contracts in terms of consumption or
    computation of gas to control operating price.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是以气体消耗或计算来理解智能合约，以控制操作价格。
- en: There are several APIs for estimating transaction costs as well as of smart
    contracts. But this goes beyond the objectives of this book. Ultimately, all operations,
    both computational and archiving, have a price explained in the gas units. When
    a user submits a transaction, they provide an ETH price per gas unit and the number
    of units of gas that they are willing to spend. The lower the code in the terms
    of gas, the more efficient it will be in terms of materials needed to execute
    the code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个 API 可以估算交易成本以及智能合约的成本。但这超出了本书的目标。最终，所有操作，无论是计算还是存档，都有一个以 gas 单位解释的价格。当用户提交交易时，他们提供每个
    gas 单位的 ETH 价格以及他们愿意花费的 gas 单位数量。代码在 gas 方面越低，执行代码所需材料就越高效。
- en: 4.5.2 The Purpose of Gas
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 Gas 的目的
- en: An important aspect of how Ethereum runs is that every single operation performed
    by the network is performed together from every full node. But you have seen that
    the calculation steps on the Ethereum virtual machine can be more costly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊运行的一个重要方面是，网络执行的每个操作都是由每个完整节点共同执行的。但是您已经看到以太坊虚拟机上的计算步骤可能更加昂贵。
- en: Hence, the Ethereum smart contracts are used for elementary activities, such
    as the execution of a simple business strategy, or verifying digital signs and
    another cryptographic objects, rather than for more complex uses such as file
    archiving, email machine learning, and in general operations that can strain the
    network.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以太坊智能合约用于基本活动，例如执行简单的业务策略，或验证数字签名和其他加密对象，而不是用于更复杂的用途，例如文件存档、电子邮件机器学习和一般可能对网络造成压力的操作。
- en: The imposition of tariffs prevents users from overcharging. Note that the Ethereum
    is a complete or full Turing language and in a nutshell, it is capable of simulating
    any algorithm. This also allows you to create loops and it makes Ethereum sensitive
    to the problem of avoiding programs that are performed indefinitely.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 征收关税可以防止用户过度收费。请注意，以太坊是一种完整的图灵语言，简而言之，它能够模拟任何算法。这也允许您创建循环，使得以太坊对避免无限执行的程序敏感。
- en: In the absence of tariffs, an attacker could effectively try to distract the
    network by running an unlimited loop within an action or an operation without
    any repercussions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有关税的情况下，攻击者可以有效地试图通过在操作中运行无限循环来分散网络而没有任何后果。
- en: 4.6 Transactions and Messages
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 交易和消息
- en: 'We have defined the Ethereum blockchain as machine states based on transactions.
    Therefore, a transaction is an event that can change the state of the Ethereum
    blockchain. A transaction can be created for different purposes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以太坊区块链定义为基于交易的机器状态。因此，交易是可以改变以太坊区块链状态的事件。可以为不同目的创建交易：
- en: Digital money transfer between EOs
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EO 之间的数字货币转账
- en: Distribution of a smart contract in the Ethereum blockchain
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以太坊区块链上分发智能合约
- en: Execute a function on a distributed smart contract
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式智能合约上执行函数
- en: A transaction can only be created and transmitted by EOs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 交易只能由 EOs 创建和传输。
- en: 4.6.1 Transaction Structure
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 交易结构
- en: An Ethereum transaction is an array of bytes. The matrix is divided into fields,
    as shown in Figure [4-21](#Fig21).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊交易是一个字节数组。该矩阵被划分为字段，如图 [4-21](#Fig21) 所示。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg)
- en: Figure 4-21
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-21
- en: Transaction structure
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 交易结构
- en: Transactions are maintained through the modified Merkle logic Patricia tree,
    which was discussed extensively in the section dedicated to the world state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是通过修改后的默克尔逻辑帕特里夏树来维护的，该树在专门讨论世界状态的部分中被广泛讨论过。
- en: In this logic, the keys are represented by the Transaction IDs and the values
    are precisely the transactions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个逻辑中，键由交易 ID 表示，值恰好是交易。
- en: 4.6.2 Transaction Digital Signature Flow
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 交易数字签名流程
- en: We use the steps taken to sign a transaction, following the EIP (Ethereum Improvement
    Proposal) scheme proposed, after the hard fork that hit Ethereum, by Vitalik Buterin
    who protects against possible replay attacks. Using the old scheme also works;
    however the founder suggests using the new one to protect yourself from replay
    attacks. It is possible to see here :![../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了签署交易所采取的步骤，遵循了 Vitalik Buterin 在以太坊遭受硬分叉后提出的 EIP（以太坊改进提案）方案，以防止可能的重放攻击。使用旧方案也有效；然而，创始人建议使用新方案以防止重放攻击。可以在这里看到：![../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg)
- en: This was proposed by the founder of Ethereum, with the list of IDs of all chains.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以太坊创始人提出的，附有所有链 ID 列表。
- en: 'Once a transaction is created, it is serialized via the function RLP:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了交易，它将通过函数 RLP 进行序列化。
- en: '*L*[*1*] *(T) = RLP (T (T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p;
    chainID; (); ()))*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*[*1*] *(T) = RLP (T (T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p;
    chainID; (); ()))*'
- en: '*Dove p = T*[*i*] *se T*[*t*] *= 0, altrimenti p = T*[*d.*]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dove p = T*[*i*] *se T*[*t*] *= 0, altrimenti p = T*[*d.*]'
- en: 'Once serialized, the cryptographic hash function called SHA-3 is applied, also
    called Keccak-256:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦序列化，将应用称为 SHA-3 的加密哈希函数，也称为 Keccak-256：
- en: '*h*[*1*] *(T) = KEC (L (T))*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*[*1*] *(T) = KEC (L (T))*'
- en: Once this is done, you can apply the signature
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此操作，您可以应用签名
- en: '*ECDSASIGN (h (T); privKey) = (T*[*w;*] *T*[*r*]*; T*[*s*]*)*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*ECDSASIGN (h (T); privKey) = (T*[*w;*] *T*[*r*]*; T*[*s*]*)*'
- en: 'In which:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: T[w] is a recovery identifier and it is doubled plus 35 or 36
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T[w] 是一个恢复标识符，它加倍加上 35 或 36
- en: T[r] is the randomPart of the digital signature
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T[r] 是数字签名的随机部分
- en: T[s] is the sign of the digital signature
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T[s] 是数字签名的标志
- en: 'Therefore, T[r] and T[s] constitute the outputs of the ECDSA digital signature
    (randomPart; sign), while T[w] is calculated according to EIP155, and has a dual
    purpose:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，T[r] 和 T[s] 构成了 ECDSA 数字签名的输出（randomPart; sign），而 T[w] 则根据 EIP155 计算，并具有双重目的：
- en: Protects from replay attacks
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止重放攻击
- en: Allows you to retrieve information for the quick recovery of the public key
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您检索有关公钥的快速恢复信息
- en: In fact, the sender’s address is not present in the transaction. Once this is
    done, the T[w], T[r], and T[s] fields are added to the transaction, getting *T(T*[*n*]*;
    T*[*p*]*; T*[*g;*] *T*[*t*]*; T*[*v*]*; p; T*[*w*]*; T*[*r*]*; T*[*s*]*)*
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在交易中并不存在发送者地址。一旦完成此操作，T[w]、T[r] 和 T[s] 字段将被添加到交易中，得到 *T(T*[*n*]*; T*[*p*]*;
    T*[*g;*] *T*[*t*]*; T*[*v*]*; p; T*[*w*]*; T*[*r*]*; T*[*s*]*)*
- en: 'Then the RLP serialization function is applied to this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对其应用 RLP 序列化函数：
- en: '*L*[*2*] *(T)= RLP(T(T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p; T*[*w*]*;
    T*[*r*]*; T*[*s*]*))*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*[*2*] *(T)= RLP(T(T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p; T*[*w*]*;
    T*[*r*]*; T*[*s*]*))*'
- en: 'And once again applied to the SHA-3 hash function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次应用于 SHA-3 哈希函数：
- en: '*h*[*2*] *(KEC (L*[*s*] *(T))*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*[*2*] *(KEC (L*[*s*] *(T))*'
- en: What you finally get is the Transaction ID.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最终您得到的是交易 ID。
- en: 4.6.3 Recovery Public Key from Digital Signature
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 从数字签名中恢复公钥
- en: For a digital signature  , Ethereum, like Bitcoin, uses both the ECDSA algorithm
    that the standard secp256k1.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字签名，以太坊与比特币一样，使用了 ECDSA 算法和标准的 secp256k1。
- en: We deal here with the digital signature scheme in proposal EIP-155\. In this
    example we will refer to the Ethereum Mainnet chain. But the procedure is the
    same for each chain that uses this scheme, just change the chainId to the appropriate
    one.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处理 EIP-155 提案中的数字签名方案。在本示例中，我们将参考以太坊主网链。但是，对于使用此方案的每个链，该过程都是相同的，只需将 chainId
    更改为相应的值。
- en: As you can see, there is no field for the sender’s address of the transaction.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，交易中不存在发送者地址的字段。
- en: This information is in fact obtained. And it is for this reason that you have
    the variable v which gives you information about parity and the finiteness of
    curve point in which randomPart is the x value. The formula for calculating v
    is
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上获得了这些信息。这就是为什么您有变量 v 提供有关奇偶性和曲线点有限性的信息，其中 randomPart 是 x 值。计算 v 的公式是
- en: '*v = chainId 2 + ((y mod 2) + 35)*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*v = chainId 2 + ((y mod 2) + 35)*'
- en: chainID is the ID of the chain used. For Ethereum Mainnet the value of this
    variable is 1.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: chainID 是所用链的 ID。对于以太坊主网，该变量的值为 1。
- en: y is the y coordinate of curve point in which randomPart is the x value of the
    curve. It is part of the ECDSA signature.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y 是曲线点的 y 坐标，其中 randomPart 是曲线的 x 值。它是 ECDSA 签名的一部分。
- en: Analyzing the formula proposed for the calculation of v, you see that the interesting
    part is y mod 2\. Which assumes the role of recovery identifier?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 分析计算 v 的提议公式，您会发现有趣的部分是 y mod 2。它起到恢复标识符的作用？
- en: 'It is used to speed up the process of retrieving the signer’s public key. In
    fact, if the information is correct, this operation has two possible results:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它被用于加速检索签名者的公钥的过程。实际上，如果信息正确，这个操作有两个可能的结果：
- en: '0: -> the y coordinate is an even value.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: -> y 坐标是一个偶数值。'
- en: '1: -> the y coordinate is an odd value.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: -> y 坐标是一个奇数值。'
- en: 'Consequently, we find that ((y mod 2) + 35) can have two possible values:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们发现 ((y mod 2) + 35) 可以有两个可能的值：
- en: '35: -> the y coordinate is an even value.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '35: -> y 坐标是一个偶数值。'
- en: '36: -> the y coordinate is an odd value.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '36: -> y 坐标是一个奇数值。'
- en: Given a fixed value for the X coordinate and truncating the information relative
    to the Y coordinate, it is possible to have several possible pairs of points (x;
    y) with the same x.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 X 坐标的固定值并截取相对于 Y 坐标的信息，可能会有几对可能的点 (x; y)，它们的 x 相同。
- en: To verify the signature, then, we would have to retrieve the public key, perform
    a loop, in which at each iteration, compare whether one of the possible pairs
    matches the signature.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证签名，我们需要检索公钥，在其中执行一个循环，在每次迭代中，比较其中一个可能的配对是否与签名匹配。
- en: Possible pairs match the signature. So, let’s see the public key of the sender.
    We briefly explain how the ECDSA algorithm calculates the random part of a digital
    signature.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的配对匹配签名。因此，让我们看一下发送者的公钥。我们简要解释 ECDSA 算法如何计算数字签名的随机部分。
- en: Given the curve secp256k1. Let G be the generator point defined by the standard
    secp256k1. Let n be the order of point G of the curve Then, we need to understand
    a that random number is generated in between the interval of [1, n-1]. And we
    call this randomNumber value. We find randomPart like this.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 给定曲线 secp256k1。设 G 是由标准 secp256k1 定义的生成点。设 n 是曲线上点 G 的阶。那么，我们需要理解一个随机数是如何在 [1,
    n-1] 的区间内生成的。我们称这个随机数值为 randomNumber。我们可以像这样找到 randomPart。
- en: '*randomNumber G = (x1; y1)*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机数 G = (x1; y1)*'
- en: Therefore,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '*random Part = x1 mod n*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机部分 = x1 mod n*'
- en: 'Let h be the cofactor of an elliptic curve, then 2 (h + 1) gives us the information
    about how many possible points we have given to randomPart of the X coordinate.
    For secp256k1 the cofactor is equal to 1\. So, we have four possible points:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 设 h 是椭圆曲线的余因子，则 2 (h + 1) 给出了关于我们在 X 坐标的 randomPart 上有多少个可能点的信息。对于 secp256k1，余因子等于
    1。因此，我们有四个可能的点：
- en: Two because each X coordinate has two possible Y coordinates, one positive and
    one negative.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个，因为每个 X 坐标有两个可能的 Y 坐标，一个正数和一个负数。
- en: Two because R.x = randomPart + j n with j 2 0; 1; 2; ... h (in our case h =
    1);
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个，因为 R.x = randomPart + j n，其中 j 2 0; 1; 2; ... h（在我们的情况下 h = 1）;
- en: 'However, R.x is uniquely recoverable from randomPart, as only one of the integers:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，R.x 可以唯一地从 randomPart 中恢复，因为只有一个整数：
- en: '*R.x = randomPart + j * n*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*R.x = randomPart + j * n*'
- en: for j 0; 1; 2; .....; h represents a valid x coordinate, that is, a multiple
    of G.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 j 0; 1; 2; .....; h，表示一个有效的 x 坐标，即 G 的倍数。
- en: For this reason, [SEC2] encryption standards recommend elliptic curves with
    cofactor h = 1 or h = 2\. For these curves recommended by [SEC2] the number of
    valid x coordinates is usually one, therefore this control is empty.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，[SEC2]加密标准建议椭圆曲线的余因子为h = 1或h = 2。对于[SEC2]推荐的这些曲线，有效x坐标的数量通常是一个，因此这个控制为空。
- en: In the worst-case scenario, only log2 h + 1 bits are needed to find R.x from
    randomPart.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，只需要log2 h + 1位就能从randomPart中找到R.x。
- en: Therefore, given the fixed randomPart information of the X coordinate of point
    R and truncating the information relating to the Y coordinate, it is possible
    to have two possible pairs (x; y) with the same valid X coordinate. That is to
    say, the one with the positive Y coordinate (x; y) and the one with the negative
    coordinate (x; -y).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于点R的X坐标的固定randomPart信息，并截断与Y坐标有关的信息，可能会有两个可能的对(x; y)具有相同的有效X坐标。也就是说，一个是具有正Y坐标的(x;
    y)，另一个是具有负坐标的(x; -y)。
- en: To verify the signature, then, you would have to run a loop in which, during
    each iteration, you determine if one of the possible pairs matches the signature.
    However, thanks to the information about the parity of the Y coordinate, we can
    obtain the yr value of point R to derive the public key corresponding to the signature
    in one fell swoop. In fact, since v gives us information about the parity of the
    coordinate Y for which randomPart is the information about coordinate X, we can
    calculate R = (xr; yr).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证签名，然后，您将不得不运行一个循环，在每次迭代期间，您确定其中一个可能的对是否与签名匹配。然而，由于Y坐标的奇偶性信息，我们可以一举获得点R的yr值，从而导出与签名对应的公钥。事实上，由于v给出了关于坐标Y奇偶性的信息，其中randomPart是有关坐标X的信息，我们可以计算R
    = (xr; yr)。
- en: 'Let h (msg) be the hash of the transaction. We get, in this way, the corresponding
    public key Q:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让h(msg)是交易的哈希。这样，我们就得到了相应的公钥Q：
- en: '1.For j ranging from 0 to h (for secp256k1 h = 1):'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.对于j从0到h的范围（对于secp256k1，h = 1）：
- en: a)
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a)
- en: Pony x[r] = random Part + in
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pony x[r] = random Part + in
- en: b)
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b)
- en: From the information about the parity of y[r,] derive point R. R = (x[r]; y[r])
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从y[r,]的奇偶性信息派生出点R。R = (x[r]; y[r])
- en: c)
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: c)
- en: Calculate the public key candidate![../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif](../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif)
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算公钥候选![../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif](../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif)
- en: 'd)Verify the public key with the digital signature:'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: d)用数字签名验证公钥：
- en: i.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: i.
- en: '*u1 = h(msg) * sign-1 mod n*'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*u1 = h(msg) * sign-1 mod n*'
- en: ii.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ii.
- en: '*u2 = randomPart * sing-1 mod n*'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*u2 = randomPart * sing-1 mod n*'
- en: iii.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: iii.
- en: 'Calculate:'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算：
- en: '*R = (xr, yr) = u1G + u2Q*'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*R = (xr, yr) = u1G + u2Q*'
- en: iv.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: iv.
- en: Set c = xr mod n. So, if c == randomPart true, then the signature is verified.
    Returns True (valid).
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置c = xr mod n。因此，如果c == randomPart为真，则签名已验证。返回True（有效）。
- en: Otherwise, if, after the loop, the value True was not returned then there is
    a disability in the information. In this way, the public key is derived from the
    ECDSA signature with standard secp256k1 and the signature is verified.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果循环后未返回值 True，则信息中存在残疾。这样，公钥是从标准 secp256k1 的 ECDSA 签名中导出的，并验证签名。
- en: 4.6.4 Three Types of Transactions
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.4 三种交易类型
- en: 'This section covers three types of transactions  :'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了三种交易类型：
- en: '*Fund Transfer Between EOA (Externally Owned Accounts):* This transaction is
    used when an EOA transfers funds to another EOA. This transaction has a blank
    Date field. (See Figure [4-22](#Fig22).)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EOA（外部拥有账户）之间的资金转移*：当 EOA 向另一个 EOA 转账时使用此交易。该交易的日期字段为空白。（见图[4-22](#Fig22)。）'
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg)'
- en: Figure 4-22
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-22
- en: Transfer of funds between EOs
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: EOs 之间的资金转移
- en: '*Storing Smart Contract on Ethereum Network* *:* In Ethereum, the distribution
    contract takes place through a transaction. This transaction has a blank destination
    address field. However, in the data field, there is the Smart Contract code in
    bytecode, plus some arguments if necessary. If successful, the sender receives
    a receipt with the contract address that they will need to use the smart contract
    (see Figure [4-23](#Fig23)).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在以太坊网络上存储智能合约*：在以太坊中，分发合同是通过交易进行的。该交易的目的地址字段为空白。但是，在数据字段中，有智能合约代码的字节码，以及必要时的一些参数。如果成功，发送者将收到一个包含合同地址的收据，他们将需要使用该智能合约（见图[4-23](#Fig23)）。'
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg)'
- en: Figure 4-23
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-23
- en: Distribution of a smart contract of a Ethereum Run function on a deployed smart
    contract
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊网络上部署智能合约的分发智能合约的运行函数
- en: After a contract is deployed, an EOA can perform functions defined in this contract.
    Again, it is implemented by submitting an Ethereum transaction. In this case,
    the destination address of the transaction is the Smart Contract address. While
    in the data field, there is the selector of the function to be recalled plus the
    data to be input into the function. (See Figure [4-24](#Fig24) )![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 合同部署后，EOA 可以执行在此合同中定义的函数。同样，这是通过提交以太坊交易来实现的。在这种情况下，交易的目的地址是智能合约地址。而在数据字段中，有要回调的函数的选择器加上要输入到函数中的数据。（见图[4-24](#Fig24)）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg)
- en: Figure 4-24
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-24
- en: Calling function on smart contract
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约上调用函数
- en: Obviously, the rights on a smart contract of those who can carry out operations
    are defined in the smart contract code, where there is the logic of the operations.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，能够执行操作的人对智能合约的权限是在智能合约代码中定义的，其中包含操作的逻辑。
- en: 4.6.5 Messages
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.5 消息
- en: The message is a kind of virtual transaction sent by the EVM code from one smart
    contract to another. Note that transactions and messages in Ethereum are different.
    A *transaction* in the Ethereum language specifically refers to a digitally signed
    piece of data from a different source from the execution of the EVM code, to be
    registered in the blockchain. Messages can only be sent by the EVM code and are
    never represented in the data. They therefore express the ability of smart contract
    to send messages to different smart contracts.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是一种由 EVM 代码从一个智能合约发送到另一个智能合约的虚拟交易。请注意，在以太坊中，交易和消息是不同的。以太坊语言中的*交易*特指来自执行 EVM
    代码的不同来源的数字签名数据，以在区块链中注册。消息只能由 EVM 代码发送，永远不会在数据中表示。因此，它们表达了智能合约向不同的智能合约发送消息的能力。
- en: These are the virtual objects, have never serialized, and only exist in the
    Ethereum run environment. They can also be conceived as a function call between
    smart contracts.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是虚拟对象，从未序列化，并且仅存在于以太坊运行环境中。它们也可以被看作是智能合约之间的函数调用。
- en: Basically, you need to understand that a message is like a transaction, except
    that it is developed by a contract and not by an outside actor. After a message
    is produced, and when a contract is currently executing, a code executes the main
    CALL or DELEGATE THE CALL codes, which develops a message.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你需要理解，消息就像一个交易，只不过它是由合约开发而不是外部参与者开发的。在生成消息后，当一个合约正在执行时，代码执行主要的 CALL 或 DELEGATE
    THE CALL 代码，从而生成消息。
- en: Therefore, a contract can have relationships with other smart contracts, like
    external actors. They are also called internal computations or transactions, and
    when a contract sends a transaction internally to different contract, the code
    is executed and associated with the recipient contract account. (See Figure [4-25](#Fig25).)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，合约可以与其他智能合约建立关系，如外部参与者。它们也被称为内部计算或交易，当一个合约将交易内部发送到不同的合约时，代码被执行并与接收合约账户相关联。（见图[4-25](#Fig25)。）
- en: In general, a message comes from a smart contract, and the execution triggers
    a transaction from an EOA.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，消息来自智能合约，执行触发了从外部账户发出的交易。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg)
- en: Figure 4-25
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-25
- en: Transactions and messages (internal transactions)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 交易和消息（内部交易）
- en: The gasLimit is set by the external ownership account and therefore is sufficiently
    high to allow the execution of the overall operation, which includes any under-executions
    that occur because of operation itself, as messages between contracts.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: gasLimit 由外部拥有账户设置，因此足够高，可以执行整个操作，其中包括由于操作本身而发生的任何不足执行的消息，如合同之间的消息。
- en: For the overall chain of transactions a particular on execution of a message
    ends, then the execution of that message could be restored to its initial state,
    along with all messages subsequently activated by its execution.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整个交易链，一条消息的特定执行结束后，那条消息的执行可以恢复到其初始状态，以及由其执行后激活的所有消息。
- en: 4.7 Ethereum State Transition Function
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 以太坊状态转换函数
- en: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png)'
- en: Figure 4-26
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-26
- en: State change and state transition function invoked by a new transaction
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由新交易调用的状态更改和状态转换函数
- en: This section discusses the validation of transactions and therefore the state
    transition function. This function allows you to transit to a new state if and
    only if the transaction is valid and you have arranged all the resources necessary
    to complete its execution. See Figure [4-26](#Fig26).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论交易的验证以及状态转换函数。该函数允许您在交易有效且您已安排完成其执行所需的所有资源时，转移到新状态。请参见图 [4-26](#Fig26)。
- en: 'Let’s look at the steps of the transition function of the Ethereum state:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以太坊状态转换函数的步骤：
- en: 'APPLY (S; TX) -> S0 or ERROR is defined like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 应用（S; TX）-> S0 或 ERROR 的定义如下：
- en: '1.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Check the transaction for structure and syntax, verifying the validity of the
    signature and determine if the nonce of the transaction matches that of the sender.
    If unsuccessful, it returns an error.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查交易的结构和语法，验证签名的有效性，并确定交易的 nonce 是否与发送者的 nonce 匹配。如果失败，返回错误。
- en: '2.'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: You can then compute the transaction cost as GASLIMIT GASPRICE and determine
    the address of the sender of the sign. If the sender’s account is sufficient then
    it decreases by the value just calculated and increases the nonce; otherwise,
    it returns an error.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您可以将交易成本计算为 GASLIMIT GASPRICE，并确定签名者的地址。如果发送者的账户足够，则减去刚刚计算的值并增加 nonce；否则，返回错误。
- en: '3.'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Initialize the variable GAS = GAS LIMIT. For each byte consumed it reduces the
    gas by a certain amount to pay for each byte of resource consumed.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化变量 GAS = GAS LIMIT。对于每个消耗的字节，它会减少一定数量的 gas 以支付每个消耗的资源字节。
- en: '4.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Transfer the digital money of the transaction from the sender’s account to the
    recipient’s account. Note that if the recipient’s account does not exist, it creates
    it. Then if the beneficiary’s account is a smart contract, run the contract code
    until the operation is completed, or at least until the execution is out of gas.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将交易的数字货币从发送者的账户转移到接收者的账户。请注意，如果接收者的账户不存在，它将创建它。然后，如果受益者的账户是智能合约，运行合约代码直到操作完成，或者至少直到执行耗尽燃气。
- en: '5.'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: If the transaction does not succeed because the sender does not have the money,
    or the execution of the code has run out of gas, restore full status changes,
    payment of taxes, and add taxes to the miner’s account.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果交易失败，因为发送者没有钱，或者代码的执行已经耗尽了燃气，则恢复完整的状态更改，支付税金，并将税金添加到矿工的账户中。
- en: '6.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Otherwise, if it’s successful, it reimburses the sender for the commissions
    for gas not consumed and sends the consumed commissions to the miner that wins
    the block containing the transaction.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，如果成功，它会为未使用的燃气退还发送者的佣金，并将已消耗的佣金发送给包含交易的块的矿工。
- en: 'The messages work in an equivalent route to the transactions in terms of recovery
    management: If a running message runs out of gas, and all other executions triggered
    by this, are restored, it’s fine. In other cases, it gives an error or a STOP/RETURN
    statement.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的工作方式与交易相同，就恢复管理而言：如果正在运行的消息耗尽了燃气，并且所有其他由此触发的执行都得到了恢复，那就没问题。在其他情况下，它会产生错误或STOP/RETURN语句。
- en: 'As mentioned, a Smart Contracts developer has access to three types of storage
    memory:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，智能合约开发人员可以访问三种类型的存储器：
- en: The LIFO (Last-in-first-out) stack (volatile) in which it is possible push or
    feed data (in a range from 0 to 1024).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后进先出（LIFO）堆栈（易失性），可以推送或馈送数据（范围从0到1024）。
- en: The (volatile) memory is an array of indefinitely expandable bytes.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （易失性）存储器是一个无限扩展的字节数组。
- en: Ethereum’s (nonvolatile) storage.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊的（非易失性）存储。
- en: The code can also get the message’s value and data incoming. It can block header
    data, and can also return an array of bytes of data as output.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还可以获取消息的值和传入的数据。它可以阻止头数据，并且还可以将数据的字节数组作为输出返回。
- en: The functional state of EVM can be defined by the set of data. In this case
    the block state is the global state that contains all accounts and budgets and
    storage.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: EVM的功能状态可以由数据集定义。在这种情况下，块状态是包含所有账户、预算和存储的全局状态。
- en: Be sure to consider that at the beginning of each turn of run, the current instruction
    is identified taking the byte pointed to by the program counter. Each operation
    has its own definition in terms of how it interacts with the set of data.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在每次运行的开始时，当前指令都会被识别，这是通过程序计数器指向的字节来完成的。每个操作都有其与数据集交互的定义。
- en: 4.8 Transaction Flow in Ethereum Blockchain
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 以太坊区块链中的交易流程
- en: This section discusses the transaction lifecycle in the Ethereum blockchain.
    Let’s take as an example a transaction that invokes a function of a smart contract—it’s
    valid and applies to any type of transaction. Suppose you want to cast your vote
    in an election through a decentralized application distributed on the Ethereum
    network. Figure [4-27](#Fig27) shows a graphical interface of the application,
    which you have accessed it through your browser, and which has installed a plug-in
    to manage the Ethereum accounts.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论以太坊区块链中的交易生命周期。让我们以通过分布在以太坊网络上的去中心化应用程序投票的交易为例——它对任何类型的交易都有效。假设你想通过一个分布在以太坊网络上的去中心化应用程序来投票。图
    [4-27](#Fig27) 显示了该应用程序的图形界面，你通过浏览器访问了它，并安装了一个插件来管理以太坊账户。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg)
- en: Figure 4-27
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-27
- en: Transaction that invokes a function of a smart contract
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 调用智能合约函数的交易
- en: The application gives us a list of elections, and we choose the one for which
    we have the right to vote.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序向我们提供了一份选举列表，我们选择了自己有权投票的选举。
- en: The vote function we click is an event handled by JavaScript through an Ethereum
    communication library called Web3.js. It connects to a node of the Ethereum network,
    creates an instance of a proxy for the smart voting contract, and calls its castVote()
    function  , passing the selected candidate. The function call is a transaction,
    since it alters the status of the voting app (through its function castVote())
    and requires a digital signature that is generated on the spot. See Figure [4-28](#Fig28).![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击的投票功能是由 JavaScript 处理的事件，通过名为 Web3.js 的以太坊通信库。它连接到以太坊网络的一个节点，创建了一个智能投票合约的代理实例，并调用其
    castVote() 函数，传递选定的候选人。函数调用是一个交易，因为它改变了投票应用程序的状态（通过其 castVote() 函数）并需要立即生成的数字签名。参见图
    [4-28](#Fig28)。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png)
- en: Figure 4-28
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-28
- en: Blockchain dapps
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链 dapps
- en: 'The voting transaction is validated by the local Ethereum node from which it
    is been submitted. Validation involves checking various things:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 投票交易由提交它的本地以太坊节点进行验证。验证涉及检查各种事项：
- en: The structure and syntax is well defined.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构和语法定义良好。
- en: The digital signature is consistent with the sender’s address and the content
    of the transaction.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名与发送方地址和交易内容一致。
- en: The nonce value of the transaction must be valid. Remember that the nonce of
    an account is the count of computations or the transactions sent by that account
    ledger or bill. To be valid, the nonce of a transaction should match the nonce
    of the sender’s user account.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的nonce值必须有效。记住，账户的nonce是该账户分类账或账单发送的计算或交易次数。为了有效，交易的nonce应与发送方用户账户的nonce相匹配。
- en: The sender has enough ether to process the transaction.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发件人有足够的以太币来处理交易。
- en: The data sent will not cause the castVote() function to fail.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的数据不会导致castVote()函数失败。
- en: So, if the validation is successful, the current node broadcasts the transaction
    to all its neighboring peer nodes. If the validation is not successful, the transaction
    is not transmitted and simply disappears. Then, the transaction is transmitted
    over the network through the various complete nodes, which in turn go through
    the previous validation process.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果验证成功，当前节点将交易广播给所有相邻的对等节点。如果验证失败，交易不会传输，只会消失。然后，交易通过各个完整节点在网络上传输，这些节点依次经过之前的验证过程。
- en: Then the transaction, spreading through the network, reaches the miner nodes.
    Each miner node, based on the transactions it receives, has its own transaction
    pool to add to the ledger. (See Figure [4-29](#Fig29).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过网络传播的交易到达矿工节点。每个矿工节点根据收到的交易有自己的交易池添加到总账中。（参见图[4-29](#Fig29).）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg)
- en: Figure 4-29
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-29
- en: MemPool
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池
- en: The miner node then chooses the transactions to include in the candidate block.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后矿工节点选择要包含在候选块中的交易。
- en: Hence, let’s consider that n is the number of transactions and let APPLI (S;
    TX) be the function of state transition defined earlier.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑n是交易的数量，并让APPLI (S; TX)是之前定义的状态转换函数。
- en: Let S [0] be the state at the end of the last block.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让S [0]是上一个区块结束时的状态。
- en: '*For i = 0; 1; ... n–1 S (i+1) = APP (S (i); TX (i))*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于i = 0; 1; ... n–1，S (i+1) = APP (S (i); TX (i))*'
- en: If no application of the transition function returns an error, then they are
    valid and could be added to the block, otherwise it will discard those that are
    invalid.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有应用过渡函数返回错误，则它们是有效的，并且可以添加到块中，否则将丢弃无效的部分。
- en: Then to S [n] the miner adds the rewards obtained and defines the final state
    of the block. Then the miner will build the block, solve the algorithm of consensus
    and propagate it on the network to be added to the blockchain. Once the voting
    transaction is performed during validation of the block, the smart contract will
    publish the VoteConfirmation() event.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，矿工将奖励加入到S [n]中并定义块的最终状态。然后，矿工将构建块，解决共识算法，并将其传播到网络以添加到区块链中。一旦在块的验证期间执行了投票交易，智能合约将发布VoteConfirmation()事件。
- en: This will be received from the voter’s web user interface, on which you are
    registered to hear that event.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从选民的Web用户界面接收到，您已注册以侦听该事件。
- en: The Vote Confirmation() event  will then be handled by the interface’s JavaScript
    web user, and a message will appear on the screen so that the user knows that
    the vote was successful.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Vote Confirmation() 事件将由接口的JavaScript Web用户处理，并在屏幕上显示消息，以使用户知道投票成功。
- en: Figure [4-30](#Fig30) shows the lifecycle of the transaction, from the origin
    to the confirmation event.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4-30](#Fig30)展示了交易的生命周期，从发起到确认事件。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg)
- en: Figure 4-30
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-30
- en: Transaction pool system
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 交易池系统
- en: 4.9 Transaction State
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 交易状态
- en: A transaction proceeds through a series of states until it is not confirmed
    in a block added to the ledger. (See Figure [4-31](#Fig31).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 交易通过一系列状态直至未在添加到账本的区块中确认。 (参见图[4-31](#Fig31).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg)
- en: Figure 4-31
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-31
- en: Transaction state
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 交易状态
- en: 'Let’s analyze these states one by one:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个分析这些状态：
- en: '**Unknown:** A transaction that was neither viewed nor processed by the network.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未知:** 网络未查看或处理的交易。'
- en: '**Pending:** A transaction that is in the pending state and is waiting to be
    chosen and elaborated by the miners. It’s in the so-called transaction pool.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待处理:** 处于待处理状态且等待矿工选择和详细说明的交易。它在所谓的交易池中。'
- en: '**In block:** A transaction moves into the block state when a miner has correctly
    selected the transaction and extracted it in a block. Once in the block, a transaction
    can roll back to the pending status if the block is forked.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在区块中:** 当矿工正确选择交易并在一个区块中提取时，交易转移到区块状态。一旦在区块中，如果区块被分叉，交易可以回滚到待处理状态。'
- en: '**Replaced:** A transaction can go to the replaced state from the pending state
    when one of these events occurs:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已替换:** 当发生以下事件之一时，交易可以从待处理状态转移到已替换状态：'
- en: Another transaction from the same sender with the nonce itself enters the state
    of in block.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有nonce自身的同一发件人的另一笔交易进入区块状态。
- en: Another transaction from the same sender with the same nonce with a higher gas
    price enters the state pending.
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一发件人的具有相同nonce的更高燃气价格的另一笔交易进入待处理状态。
- en: So, let’s see the state *transitions* of the transactions.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看交易的状态*转换*。
- en: '**Pooling:** A transition from the unknown state to the pending state. It concerns
    the transactions that enter the transaction pool of somebody. They are therefore
    waiting to be selected to train a candidate block.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇总:** 从未知状态转移到待处理状态的转换。它涉及进入某人的交易池的交易。因此，它们正在等待被选中以训练候选区块。'
- en: '**Mined:** A mined transaction was processed by a miner, creating a block.
    Once he checked out a transaction, he entered the status in block. Due to the
    *peer-to-peer* nature of the Ethereum network, from the perspective of some node,
    the transaction can shift from the *unknown* state directly to the in-block state
    without going through the pending state.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已挖掘：** 已挖掘的交易由矿工处理，创建一个块。一旦他检查了交易，他就会将其状态输入块中。由于以太坊网络的点对点性质，从某个节点的角度来看，交易可以直接从未知状态转移到块内状态，而无需经过待处理状态。'
- en: '**Replaced:** A transaction that moves from the pending state to replaced it
    is said to have been replaced. This happens when:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已替换：** 从挂起状态转移到替换状态的交易被视为已替换。当发生以下情况时：'
- en: Another transaction from the same sender with the nonce itself enters the in-block
    state.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与相同发送者的另一笔具有相同 nonce 的交易进入块内状态。
- en: Another transaction from the sender state with the same nonce but with a higher
    gas price enters the pending status.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发件人状态中具有相同 nonce 但具有更高 gas 价格的另一笔交易进入待处理状态。
- en: '**Forked:** This happens when a block transaction is part of a block that is
    inverted by the network. All transactions within that block will pass from the
    in-block state to the state pending*.*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分叉：** 当一个块交易是网络倒置的块的一部分时发生。该块内的所有交易将从块内状态转移到待处理状态*。*'
- en: '**Confirmed:** A transaction in block status is confirmed whenever a new block
    is extracted and added to the chain.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已确认：** 块状态中的交易在每次提取并添加到链中的新块时都被确认。'
- en: 4.10 Block Structure
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 块结构
- en: 'One block of the Ethereum blockchain is divided into the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的一个块被分成以下几部分：
- en: Block header
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块头
- en: List of ommer block headers
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ommer 块头列表
- en: Block data
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块数据
- en: The headers of the ommer blocks are in the same format as reported. (See Figure
    [4-32](#Fig32).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ommer 块头的格式与报告的格式相同。 (见图 [4-32](#Fig32).)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg)
- en: Figure 4-32
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-32
- en: Block structure
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 块结构
- en: 'The list of *ommer block headers* is indicated with B[U], while the list of
    transactions is indicated with B[T]. So, formally, we refer to block B as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 B[U] 的 ommer 块头列表，而交易列表则表示为 B[T]。因此，形式上，我们将块 B 称为：
- en: '*B = (B*[*H*]*; B*[*T*] *; B*[*U*]*)*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*B = (B*[*H*]*; B*[*T*] *; B*[*U*]*)*'
- en: Remember that every tree in Ethereum is a Modified Merkle Patricia trie, which
    is extensively covered in the World State section.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以太坊中的每棵树都是修改的 Merkle Patricia trie，这在 World State 部分有详细介绍。
- en: The approach may seem very inefficient at first look, since the entire state
    must be captured at each block, but in fact only a low part of the shaft needs
    to be changed after each block. Since all the state information is a part of the
    final block, there is no need to record the full history of the blockchain.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 乍看起来，这种方法可能非常低效，因为每个区块都必须捕获整个状态，但实际上每个区块后只需改变少部分。由于所有状态信息都是最终区块的一部分，因此无需记录区块链的完整历史。
- en: In general, most of the tree between two adjacent blocks is the same, and therefore
    only one piece of information can be recorded once and referenced twice with hash
    pointers. Also, it is worth adding that the code execution process of the smart
    contract is generated by a transaction that is executed via the state computation
    or transition function.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，两个相邻区块之间的树大部分是相同的，因此只需记录一次信息并通过哈希指针引用两次。另外值得一提的是智能合约的代码执行过程是通过通过状态计算或转换函数执行的事务生成的。
- en: In view of the block validation algorithm, if the computations or transactions
    are added to the block called X, the execution of the code generated by this transaction
    will be performed by all the nodes of the network, validating and adding the X
    block.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于区块验证算法，如果将计算或交易添加到名为X的区块中，则该交易生成的代码的执行将由网络的所有节点执行，验证并添加X区块。
- en: Figure [4-33](#Fig33) summarizes these Ethereum blocks.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [4-33](#Fig33) 总结了这些以太坊区块。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg)
- en: Figure 4-33
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-33
- en: Block structure in Ethereum
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的区块结构
- en: 4.10.1 Transaction Receipts
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.1 交易收据
- en: 'Each transaction, when executed and validated, changes the status of the blockchain.
    Therefore, every valid transaction has an outcome. Transaction receipts record
    the result of each transaction. Each computation or transaction receipt is a tuple
    consisting of four elements:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交易在执行和验证时都会改变区块链的状态。因此，每个有效的交易都有一个结果。交易收据记录了每笔交易的结果。每次计算或交易收据都是由四个元素组成的元组：
- en: 'Ru: The cumulative gas'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ru：累积气体
- en: 'Rl: The set of registers developed through the execution of the transactions'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rl：通过交易执行开发的寄存器集合
- en: 'Rb: The Bloom filter composed of information in those registers'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rb：由这些寄存器中的信息组成的布隆过滤器
- en: 'Rz: The post-transaction status'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rz：交易后的状态
- en: 'Therefore, the transaction receipt is defined as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，交易收据的定义如下：
- en: '*R = (R*[*u*]*; R*[*b*]*; R*[*l*]*; R*[*z*]*)*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*R = (R*[*u*]*; R*[*b*]*; R*[*l*]*; R*[*z*]*)*'
- en: 4.10.2 Ommer Blocks
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.2 哥伦布区块
- en: The block processing  times are much lower in Ethereum compared to those of
    Bitcoin. On the one hand, this allows for faster processing of transactions, on
    the other hand, several miners simultaneously resolve more blocks. These concurrent
    blocks are called *ommer blocks.*
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的区块处理时间比比特币低得多。一方面，这允许更快地处理交易，另一方面，几个矿工同时解决更多的区块。这些并行区块被称为*附属区块*。
- en: The ommer blocks do not enter the main chain. However, the goal to integrate
    these blocks into the main blocks that have been awarded the place in the main
    blockchain is to help reward the miner for these blocks.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 附属区块不进入主链。然而，将这些区块整合到已获得主区块链位置的主区块中的目标是帮助奖励这些区块的矿工。
- en: In order for a miner to be rewarded for an ommer block, it must be valid. So,
    the purpose of ommers is to reward miners who do well, as well as award orphan
    blocks.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使矿工能够获得对一个附属区块的奖励，它必须是有效的。因此，附属区块的目的是奖励表现良好的矿工，并奖励孤立区块。
- en: 'This has a double effect:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这有双重效应：
- en: '1.**Feeds the decentralization of the network.** In fact, even rewarding miners
    who mine orphaned blocks due to:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.**促进网络的去中心化。** 事实上，甚至奖励因为孤立区块而挖掘的矿工也是如此：
- en: Greater network latency, which causes delays in data propagation
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的网络延迟，导致数据传播延迟
- en: Less computing power, which leads to greater difficulty to extract a block
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的计算能力导致更大的难度来提取一个区块
- en: Reduces centralization and avoids pools of miners with greater computing power
    claiming most of the rewards without leaving anything to individual miners.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低集中化程度，并避免拥有更大计算能力的矿工池声称大部分奖励而不留给个别矿工。
- en: '2.'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: '**Increases the safety of the chain by increasing the amount of work on the
    main chain.** So less work gets wasted.'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**通过增加主链上的工作量来增加链的安全性。** 这样就减少了浪费的工作量。'
- en: The block that wins the place in the main chain is, generally, the one that
    has the largest share of proof of work. While the ommer blocks are those that
    usually share less than this test. Each block can have at most two ommer blocks.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 赢得主链上位置的区块通常是具有最大工作量证明份额的区块。而附属区块通常比这个测试份额少。每个区块最多可以有两个附属区块。
- en: 4.11 Ethereum Simplified Ghost
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 以太坊简化的 GHOST
- en: The aim behind the *GHOST* protocol is to propose one solution for blockchains
    that had very fast block processing. In fact, chains with very fast confirmation
    times are affected by a “reduced” security as the work done by the miners mine
    blocks that spread more slowly in the network.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*GHOST* 协议背后的目标是为那些具有非常快的区块处理速度的区块链提出一种解决方案。事实上，具有非常快确认时间的链受到“减少”安全性的影响，因为矿工挖掘的区块在网络中传播得更慢。'
- en: Basically, the solution is to include latent blocks in the computation of the
    main blockchain.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，解决方案是将潜在的区块包含在主区块链的计算中。
- en: Also, blockchains that produce fast blocks strongly run the risk of centralizing
    toward a mining pool, which has a high percentage of hash power on the network,
    arriving thus to control the mining process.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，产生快速块的区块链强烈面临着向矿池中心化的风险，该矿池在网络上具有高比例的哈希能力，从而控制挖矿过程。
- en: To avoid this situation, Ethereum has adopted a “simplified” version of the
    GHOST protocol that’s able to overcome both problems that plague blockchains that
    process blocks quickly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，以太坊采用了“简化版” GHOST 协议，能够克服处理块速度快的区块链所困扰的两个问题。
- en: The solution adopted by Ethereum is to provide a reduced reward for latent blocks.
    Not only that, but they also provide a reward for grandchildren blocks that include
    latent blocks.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊采用的解决方案是为潜在块提供降低的奖励。不仅如此，他们还为包含潜在块的子块提供奖励。
- en: 'The simplified version of Ethereum’s GHOST protocol is defined like this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的简化版 GHOST 协议定义如下：
- en: A block must specify a previous block, and 0.1 or 2 ommer block.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块必须指定一个先前的块，并且 0.1 或 2 个嵌套块。
- en: 'An ommer block included in a block should have these properties:'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在块中的嵌套块应具有以下属性：
- en: It must be direct child of the k-generation parent of B, with k between two
    and seven.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是 B 的 k 代父代的直接子代，其中 k 介于两个和七个之间。
- en: So, it should not be a progenitor of B.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，它不应该是 B 的前体。
- en: It should be a valid block.
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是一个有效的块。
- en: The ommer block should be varied from all included ommers in the last blocks
    and by all the other ommers included in the same block.
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套块应该不同于上一块中包含的所有嵌套块以及同一块中包含的所有其他嵌套块。
- en: 'There are two reasons that ommers can be included in up to seven generations:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套块可以包含在最多七代中的两个原因有：
- en: A GHOST with no generation limits would bring complications in calculating which
    ommers are valid for a certain block.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有世代限制的 GHOST 将在计算哪些嵌套块对于某个块有效时带来复杂性。
- en: An unlimited GHOST, moreover, as implemented in Ethereum, would eliminate the
    incentive of miners to mine the main chain, and not that of an attacker.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且，作为以太坊中实现的无限 GHOST，将消除矿工挖掘主链的动机，而不是攻击者的动机。
- en: 4.12 Ethereum Consensus
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 以太坊共识
- en: Let’s see how, even here, it turns out to be an emerging consensus, and Ethereum
    bases its consensus on Proof of Work (POW).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看，即使在这里，也是形成共识的一种新兴方式，并且以太坊将其共识基础放在了工作量证明（POW）上。
- en: The POW algorithm  used by Ethereum is the Ethash, which is based on the Keccak-256-bit
    cryptographic hash function.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用的 POW 算法是 Ethash，它基于 Keccak-256 位密码散列函数。
- en: As you have already seen, when a transaction is created and signed, before being
    transmitted to the network, it is validated locally through the local Ethereum
    node.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，当一个交易被创建并签名后，在被传输到网络之前，它会通过本地以太坊节点进行本地验证。
- en: 'This validation includes the following checks:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证包括以下检查：
- en: The structure and syntax of the transaction is well formed.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的结构和语法是完全形成的。
- en: The digital signature is consistent with the sender’s address and the content
    of the transaction.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名与发送方地址和交易内容一致。
- en: The nonce value of the transaction must be valid. To be valid, the nonce of
    a transaction must match the nonce of the sender’s account.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的一次性值必须有效。要有效，交易的一次性值必须与发送方账户的一次性值匹配。
- en: The sender has enough ether to finance the gas of the transaction.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送方有足够的以太币来支付交易的气体。
- en: The data sent is consistent and well-formed and therefore does not cause failures
    of any operations invoked.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的数据一致且格式良好，因此不会导致任何调用操作失败。
- en: If one of these validation steps fails, then the transaction will fail and be
    transmitted to the network. Instead, if so, it is spread across the network through
    neighboring nodes. Each node that will receive a transaction is carried out in
    turn a verification of the validity of the transaction.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些验证步骤中的任何一步失败，则交易将失败并传输到网络中。相反，如果成功，则通过相邻节点传播到整个网络。每个接收交易的节点依次执行交易有效性验证。
- en: Again, if successful, this will be passed on through the network, otherwise
    ignored. This way you avoid clogging the network with invalid transactions that,
    therefore, would not lead to any change of state.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果成功，这将通过网络传递，否则将被忽略。通过这种方式，您可以避免用无效交易堵塞网络，因此这些交易不会导致任何状态更改。
- en: When these reach the miners, they validate them and add them to the transaction
    pool. In fact, miners, as in Bitcoin, keep a pool of transactions locally, waiting
    to be added to a candidate block.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些到达矿工时，他们会验证它们并将它们添加到交易池中。实际上，矿工像比特币一样在本地保留交易池，等待添加到候选块中的交易。
- en: Miners choose the transactions to add to the block based on various criteria,
    but primarily based on the fees that a transaction offers. Miners have a gas limit
    per block, which they cannot breach.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工根据各种标准选择要添加到块中的交易，但主要基于交易提供的费用。矿工每个块有一个气体限制，不能突破。
- en: 'Then they choose a number n of transactions to add in block, and they apply
    the transition function for each of these statusAPPLY (S; TX) -> S or ERRORSo
    the miner can finally build the block with the new state S0, fill in the fields,
    and solve the PoW puzzle we talked about in the Nakamoto Consensus section in
    the chapter dedicated to Bitcoin*.* Once the puzzle is solved, the miner can pass
    the block to the net. Each node that will receive the block will then validate
    the latter. The basic block validation algorithm in Ethereum works in the following
    way:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们选择一个数字n的交易添加到块中，并且他们对每个这些状态应用过渡函数APPLY(S; TX) -> S或ERROR，因此矿工最终可以构建具有新状态S0的块，填写字段，并解决我们在比特币章节中谈到的Nakamoto共识中的PoW难题。一旦谜题解决，矿工就可以将块传递给网络。将接收块的每个节点都将验证后者。以太坊中的基本块验证算法的工作方式如下：
- en: Check if the previous reference block still exists and is valid.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查先前引用的块是否仍然存在且有效。
- en: See if the timestamp of the block is larger than that of the previous and lower
    reference block of 15 minutes in the future.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看区块的时间戳是否大于前一个并且比未来 15 分钟的参考区块的时间戳。
- en: Verify whether the block number, difficulty, transaction origin, derivative
    transaction, and gas limit are valid.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证区块号、难度、交易发起方、衍生交易和 gas 限额是否有效。
- en: Verify if the POW on the block is still valid.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证区块上的 POW 是否仍然有效。
- en: S [0] can be the state at the end of the last block and TX can be the list of
    the computations or transactions of the block, with n steps.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S [0] 可以是上一个区块结束时的状态，TX 可以是该区块的计算或事务列表，有 n 步。
- en: '*For i = 0 ... n - 1, set S (i+1) = APPLY (S (i); TX (i)).*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于 i = 0 ... n - 1，设置 S (i+1) = APPLY (S (i); TX (i)).*'
- en: Then check if the application gives an error or if the final or total gas consumed
    in the block up to this point go beyond the GASLIMIT; this too gives an error.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查应用程序是否出错，或者到目前为止在区块中消耗的总 gas 是否超出了 GASLIMIT；这也会导致错误。
- en: Assume that S FINALS (n), however adding the block reward paid to the miner
    block.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 S FINALS (n)，但添加了支付给矿工的区块奖励。
- en: Need to verify that the original state of the Merkle tree S_FINAL is the same
    in the original final step or state given in the header of the block. In such
    a case, the block is valid; on the other hand, it’s not valid.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要验证 Merkle 树 S_FINAL 的原始状态是否与区块头中给出的原始最终步骤或状态相同。在这种情况下，区块是有效的；反之，则无效。
- en: 4.12.1 The Proof of Work Algorithm (PWA)
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.12.1 工作量证明算法（PWA）
- en: 'The PWA is formally defined as follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 正式定义如下：
- en: '*(n; m) = PoW (H; H*[*n*]*; d)*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*(n; m) = PoW (H; H*[*n*]*; d)*'
- en: Where
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: (n; m)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (n; m)
- en: M is a mixHash
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: M 是一个 mixHash
- en: n is the nonce
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: n 是 nonce
- en: H is the block header without the nonce and without mixHash.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H是区块头，不包含 nonce 和 mixHash。
- en: Hn is the nonce defined as a cryptographically pseudo-random number not independent
    on H and d.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hn是一个由密码学伪随机数定义的nonce，与H和d不独立。
- en: d is the DAG, and it is a large set of data required to compute the mix-hash.
    Simply put, a miner repeatedly spawns such mixHashes through the DAG, until the
    output has a lower nonce value than the desired value.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d 是DAG，是一个计算 mix-hash 需要的大量数据。简而言之，矿工通过 DAG 反复生成这样的 mixHash，直到输出的 nonce 值低于期望值为止。
- en: The relationship between the nonce and the difficulty of the block is formally
    defined here:![../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: nonce 与区块的难度之间的关系在此正式定义：![../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png)
- en: 4.13 Ethereum 2.0
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13 以太坊 2.0
- en: You have seen that, as with Bitcoin, Ethereum is an emerging consensus. The
    algorithm for extracting blocks used by Ethereum is the *Proof of Work* algorithm.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，与比特币一样，以太坊是一种新兴的共识。以太坊用于提取区块的算法是 *工作量证明* 算法。
- en: However, soon, there will be an upgrade from Ethereum 1.0 to Ethereum 2.0\.
    This update will not be immediate but will proceed gradually through various stages.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，很快，以太坊将从1.0升级到2.0版本。 这个更新不会立即发生，而是会通过各个阶段逐渐进行。
- en: One of the most important notes of this update is innovation of the algorithm
    used to extract the blocks. In fact, with the upgrade to Ethereum 2.0 there will
    be a transition to the Proof of Stake algorithm. The Proof of Work is an algorithm
    for extracting blocks that entails a computational burden no less. In order for
    it to be possible to win a block, you need the necessary computational power from
    expensive and specialized hardware.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新最重要的一个注释是创新了用于提取区块的算法。 实际上，随着升级到以太坊2.0，将过渡到权益证明算法。工作量证明是一种用于提取区块的算法，其带来的计算负担不小。
    为了赢得一个区块，您需要来自昂贵而专业的硬件的必要计算能力。
- en: 'This leads to a very high energy consumption with consequences on pollution.
    So, in summary, the problems related to PoW are:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致能源消耗非常高，对污染产生后果。因此，总的来说，与PoW相关的问题有：
- en: It is a very inefficient process due to the number of computational resources
    and the energy it requires.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常低效的过程，因为它需要大量的计算资源和能源。
- en: People and organizations who can afford more powerful hardware to carry out
    PoW are more likely to use it than the others, which means there is a risk of
    centralizing the mining process at organizations.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够负担得起更强大硬件来进行PoW的人和组织更有可能使用它，这意味着存在将挖矿过程集中在组织中的风险。
- en: Figure [4-34](#Fig34) shows a statistical example of the distribution of mining
    power within the Ethereum network.![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4-34](#Fig34)显示了以太坊网络内挖矿能力分布的统计例子。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png](../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png)
- en: Figure 4-34
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-34
- en: Distribution of the hash rate in Ethereum
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的哈希率分布
- en: Therefore, from the image it is clear that more than 51% of the total mining
    power of Ethereum is in the hands of three organizations. To solve these problems,
    Ethereum considered Proof of Stake as a solution.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从图像中可以清楚地看出，以太坊总挖矿能力的51%以上掌握在三个组织手中。为了解决这些问题，以太坊考虑了PoS作为解决方案。
- en: 4.14 Summary
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.14 总结
- en: In this chapter, you learned about Ethereum and its structure (state and transaction
    functions). It explained how Ethereum was created to enable developers to build
    and publish smart contracts and distributed applications that can be used without
    downtime issues, fraud, or interference from a third party. The next chapter will
    focus on the consensus based on the Proof of Stake algorithm, on which research
    is deepening more and more. More blockchains are considering switching to this
    algorithm consensus, first of all Ethereum. The chapter ends by covering by Ethereum
    Casper, the proof of stake the developers of Ethereum are implementing.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于以太坊及其结构（状态和交易功能）的知识。它解释了以太坊是如何被创造出来的，以使开发人员能够构建和发布智能合约和分布式应用，这些应用可以在没有停机问题、欺诈或第三方干预的情况下使用。下一章将重点介绍基于权益证明算法的共识，研究越来越深入。更多的区块链正在考虑转向这种算法共识，首先是以太坊。本章结束时，将涵盖以太坊的
    Casper，这是以太坊开发者正在实施的权益证明。
