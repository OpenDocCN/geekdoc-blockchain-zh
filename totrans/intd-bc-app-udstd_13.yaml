- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_13](https://doi.org/10.1007/978-1-4842-7480-4_13)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者，独家许可给 APress Media, LLC，属于 Springer Nature 2022 J. T. George《介绍区块链应用》[https://doi.org/10.1007/978-1-4842-7480-4_13](https://doi.org/10.1007/978-1-4842-7480-4_13)
- en: 13. Cyber-Physical Systems Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 物联网项目
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joseph Thachil George^([1](#Aff2)  )(1)意大利罗马
- en: In this chapter, you learn how to develop a cyber-physical system based on an
    Italian game called Witch Calls Color.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何基于一款名为Witch Calls Color的意大利游戏开发物联网系统。
- en: 'This game has the following rules:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏有以下规则：
- en: One player is picked to be the witch.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选中一名玩家成为女巫。
- en: They call out a color, such as blue.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们呼喊一个颜色，比如蓝色。
- en: The other children then run to touch an object of that color. (Clothes are not
    included, and only one person can touch an object.)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后其他孩子跑去触摸那种颜色的物体。（衣服不包括在内，而且只有一个人可以触摸一个物体。）
- en: If the witch catches a child who is not touching the color, they become the
    next witch. Then the original witch joins the other kids.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果女巫抓住了一个没有触摸颜色的孩子，他们就会成为下一个女巫。然后原来的女巫加入其他孩子。
- en: You are going to implement this project with the help of Kilobots. The movement
    of the witch and the color are implemented in Kilobots.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将借助Kilobots实现此项目。女巫的移动和颜色都是在Kilobots中实现的。
- en: 13.1 Using Kilobots
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 使用Kilobots
- en: The *Kilobot*  cluster  is a cluster of 1,000 robots that may be used to create
    collective behavior that is automatic and has a long duration. Each robot has
    the basic functions of an autonomous swarm robot, but it is made up of a restricted
    number of pieces and assembled mostly by an automatic system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kilobot* 群是一个由1,000个机器人组成的群集，可以用来创建自动且具有长时间持续性的集体行为。每个机器人具有自主群体机器人的基本功能，但由有限数量的零件组成，并且主要由自动系统组装。'
- en: Additionally, the system design allows a single individual to operate a huge
    Kilobot cooperative in an efficient and scalable manner, including programming
    it, turning it on, and refilling all the robots. The Kilobot swarm is used to
    investigate collective "virtual" intellect and to test innovative theories that
    link minimal personal qualities to cluster characteristics. See Figure [13-1](#Fig1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，该系统设计允许单个个体以高效且可扩展的方式操作大型Kilobot协作，包括对其进行编程、启动和为所有机器人添加燃料。Kilobot群被用于研究集体“虚拟”智能，并测试将最小个人特征与群集特性联系起来的创新理论。参见图[13-1](#Fig1)。
- en: Using a mixed concept technique, you can obtain new algorithmic understanding
    about robustness, adaptability, personality, and an emerging in groups of limited
    individuals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合概念技术，您可以获得关于稳健性、适应性、个性以及有限个体群体中的新算法理解。
- en: 13.1.1 The Kilobots Movements
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 Kilobots的运动
- en: 'The following list shows the basic Kilobots movements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了基本的Kilobots运动：
- en: Upward motion
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上运动
- en: Characteristics of rotating
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转特性
- en: Keeping in touch with adjacent units
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持与相邻单元的联系
- en: Computing the difference between adjacent units.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算相邻单元之间的差异。
- en: Having sufficient RAM to execute the Kilobots
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有足够的RAM来执行Kilobots
- en: 'The following extra parts were added to the Kilobot to expand its implementation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 向Kilobot添加以下额外部件以扩展其实现：
- en: The capacity to estimate the amount of light in the environment
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计环境中光的数量的能力
- en: Making the operations more flexible
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使操作更加灵活
- en: '![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg)'
- en: Figure 13-1
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1
- en: A Kilobot
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Kilobot
- en: 13.2 Project Requirements
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 项目要求
- en: 13.2.1 Architecture
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 架构
- en: '1.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The Kilobots will operate in a space of at least 100x80cm.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kilobots将在至少100x80cm的空间中操作。
- en: '2.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The surface should be glossy and reflective for the infrared to work properly.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表面应光滑且反射，以使红外线正常工作。
- en: '3.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: The SoS is composed of at least five Kilobots and a controller (one witch, two
    players, and two colors).
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SoS由至少五个Kilobots和一个控制器组成（一个巫师、两个玩家和两种颜色）。
- en: '4.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: The SoS is composed of at least five Kilobots and a controller (one witch, two
    players, and two colors).
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SoS由至少五个Kilobots和一个控制器组成（一个巫师、两个玩家和两种颜色）。
- en: '5.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: At the beginning of the program execution, there are assigned positions for
    the Kilobots.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序执行开始时，为Kilobots分配了位置。
- en: '6.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Each Kilobot has an ID, color, and positions.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个Kilobot都有一个ID、颜色和位置。
- en: '7.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: When the game starts, the player searches for the color and the witch searches
    for the player.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏开始时，玩家搜索颜色，而巫师搜索玩家。
- en: '8.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: The witch and player Kilobots are waiting for the signal to each other to run.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 巫师和玩家Kilobots正在等待彼此的信号以开始运行。
- en: '9.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9.'
- en: The target color is chosen by the program.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标颜色由程序选择。
- en: '10.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10.'
- en: During the game, all of the Kilobots are searching for each other.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏期间，所有Kilobots都在互相搜索。
- en: '11.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '11.'
- en: During the game, the witch is trying to catch the players and the players are
    searching for the color. If the witch catches a player, that player will be the
    witch in the next round.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏期间，巫师试图抓住玩家，而玩家则在寻找颜色。 如果巫师抓住了一名玩家，那名玩家将成为下一轮的巫师。
- en: '12.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '12.'
- en: The round is finished when the Kilobots catch the color.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当Kilobots抓住颜色时，回合结束。
- en: '13.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '13.'
- en: Each Kilobot has two independent motors.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个Kilobot都有两个独立的电机。
- en: '14.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '14.'
- en: Each Kilobot has an infrared transmitter and receiver.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个Kilobot都有红外发射器和接收器。
- en: '15.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '15.'
- en: The Kilobots can estimate relative distance from other bots from the environment.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kilobots可以从环境中估计与其他机器人的相对距离。
- en: '16.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '16.'
- en: 'The Kilobots will operate in one of at least three states: run, bootload, or
    sleep.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kilobots将在至少三种状态中的一种操作：运行、引导加载或休眠。
- en: '17.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '17.'
- en: Through a message interface, each Kilobot can communicate with every other Kilobit.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过消息接口，每个Kilobot都可以与其他每个Kilobot进行通信。
- en: 13.2.2 Project Communication
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 项目通信
- en: '1.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The Kilobots can receive messages from the overhead controller.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kilobots 可以接收来自顶层控制器的消息。
- en: '2.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The Kilobots are communicating when they are within 7.5cm distance of each other.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Kilobots 相距不超过 7.5 厘米时，它们正在通信。
- en: '3.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: The connection between all the Kilobots is established at the beginning of each
    round.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有 Kilobots 之间的连接在每一轮开始时建立。
- en: '4.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: There should be a unique Kilobot operating as a central communication coordinator.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该有一个唯一的 Kilobot 作为中央通信协调员。
- en: 13.2.3 Time
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 时间
- en: Each Kilobot will have a time-based internal clock. Kilobots can communicate
    over the network within 10 seconds of every message sent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kilobot 都将拥有一个基于时间的内部时钟。Kilobots 可以在发送的每条消息后的 10 秒内通过网络通信。
- en: 13.2.4 Dynamicity
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 动态性
- en: A Kilobot moving out of the range of communication will start moving to find
    the other Kilobots in order to become a part of the network again.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个移出通信范围的 Kilobot 将开始移动，以寻找其他 Kilobots，以便重新成为网络的一部分。
- en: 13.2.5 Dependability
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 可靠性
- en: '1.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Availability: A charged battery is necessary for Kilobots.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用性：Kilobots 需要有充电电池。
- en: '2.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Reliability: The Kilobots can start each game round only when they can communicate
    with all the others because they don’t provide the necessary service.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可靠性：Kilobots 只有当它们能够与所有其他 Kilobots 通信时，才能开始每一轮游戏，因为它们没有提供必要的服务。
- en: '3.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Integrity: It is fundamental that the SoS doesn’t have an improper state to
    function correctly.'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整性：SoS 不应该有不当状态才能正常运行。
- en: 13.3 Blockly4SoS Model
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 Blockly4SoS 模型
- en: In this model, we have an SoS composed of five Kilobots and one overhead controller  .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们有一个由五个 Kilobots 和一个顶层控制器组成的 SoS。
- en: '1.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The overhead controller has a RUMI (a Relied Upon Message Interface) that it
    uses to send information to the Kilobots about the state they must enter or sends
    the code that defines the behavior of Kilobots.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶层控制器有一个 RUMI（一个可靠的消息接口），它用来向 Kilobots 发送关于它们必须进入的状态的信息，或者发送定义 Kilobots 行为的代码。
- en: '2.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The Kilobot with ID=0 is the central point of communication; it helps you define
    a better protocol of communication .
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ID=0 的 Kilobot 是通信的中心点；它帮助你定义更好的通信协议。
- en: '3.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Every Kilobot has a RUMI, which is the interface that they use to exchange messages,
    and a RUPI (Relied Upon Physical Interface), which is represented by the infrared
    sensor that catches information from the environment (for example, the distance
    from the other bots). The message channels are based on the infrared sensor at
    the hardware layer, but since that is used to directly communicate the data and
    exchange messages, those are RUMIs. Every characteristic of the Kilobots’ SoS
    is related to a requirement.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个 Kilobot 都有一个 RUMI，它是它们用来交换消息的接口，还有一个 RUPI（Relied Upon Physical Interface），它由红外传感器表示，用于捕捉环境信息（例如，与其他机器人的距离）。消息通道基于硬件层上的红外传感器，但由于它被用来直接通信数据和交换消息，因此它们是
    RUMIs。Kilobots 的每一个特征都与一个需求相关联。
- en: 13.4 Implementing the Project
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 实施项目
- en: In this project, you assign starting positions of Kilobots and specify them
    in the endstate.json file. At first, a Kilobot moves in a spiral way, trying to
    establish a connection with the other Kilobots in order to receive a signal.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你分配 Kilobots 的起始位置并在 endstate.json 文件中指定它们。首先，一个 Kilobot 以螺旋方式移动，试图与其他
    Kilobots 建立连接以接收信号。
- en: In the first phase, every Kilobot sends an array of 10 bits, where all the bits
    are 0 except for the one at the array position equal to the Kilobot ID. When every
    Kilobot has an array, that means that every Kilobot is connected to all the other
    Kilobots one way and they are ready to communicate. The first phase is terminated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，每个 Kilobot 发送一个包含 10 位的数组，其中所有位都为 0，除了数组位置等于 Kilobot ID 的那个位。当每个 Kilobot
    都有一个数组时，这意味着每个 Kilobot 与所有其他 Kilobots 单向连接，并且它们已经准备好进行通信。第一阶段终止。
- en: In the second phase, all the Kilobots have formed a network and now act as an
    SoS. They select the witch and broadcast this information through the network
    of Kilobots. Every Kilobot resends the received message until the chosen witch
    receives it. Then the witch selects the target color to catch and broadcast this
    information.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，所有 Kilobots 形成了一个网络，现在作为一个 SoS 进行操作。它们选择女巫并通过 Kilobots 网络广播这一信息。每个 Kilobot
    重新发送收到的消息，直到被选择的女巫收到。然后女巫选择要捕捉的目标颜色并广播这一信息。
- en: In the next phase, the Kilobots try to catch the target. Every Kilobot evaluates
    the distance to the target Kilobot, identifying which of the neighbors have the
    field “distance to target” smaller than all the others. By adding the “distance
    to target” of the neighbor to the distance of Kilobot X to the neighbor’s closest
    to the target, you can obtain an approximate distance to the target. This process
    starts from the Kilobots that are effectively communicating with the target, because
    they are the only ones able to obtain the real distance to the target. After that,
    this process will recursively happen up to the outermost node of the network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一阶段，Kilobots 尝试捕捉目标。每个 Kilobot 评估到目标 Kilobot 的距离，识别出哪些邻居具有比其他邻居都小的“到目标的距离”字段。通过将邻居的“到目标的距离”与
    Kilobot X 到邻居最接近目标的距离相加，可以得到对目标的近似距离。这个过程从与目标有效通信的 Kilobots 开始，因为他们是唯一能够获得与目标的实际距离的人。之后，这个过程将递归地发生直到网络的最外部节点。
- en: So, every Kilobot in communication range can know the approximate distance to
    the target and the closest neighbor it needs to follow in order to reach the target.
    Kilobots can go out of range of communication. In such cases, they start moving
    in a spiral way until they find someone communicating with the target.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与通信范围内的每个 Kilobot 都可以知道到目标的近似距离和它需要跟随的最近邻居。Kilobots 可能会超出通信范围。在这种情况下，它们开始以螺旋方式移动，直到找到与目标通信的人。
- en: There is an emergent behavior—an unexpected and positive behavior—that when
    a Kilobot exits the range, it turns around 360 degrees and enters the range again.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一种意想不到的正面行为——当一个基洛机器人退出范围时，它会360度转身并再次进入范围。
- en: 13.5 Executing the Project
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 执行项目
- en: In this project, you assign the starting positions of the Kilobots and specify
    them in the endstate.json file. Now, we’ll describe the simulation as per the
    settings you choose (most importantly, randSeed = 2).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，您分配了基洛机器人的起始位置，并将它们指定在endstate.json文件中。现在，我们将根据您选择的设置（最重要的是randSeed
    = 2）描述模拟。 '
- en: In Figure [13-2](#Fig2), you can see the starting positions of the bots in this
    simulation. A circle around a bot means that it is transmitting; a line between
    two bots means they are communicating.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[13-2](#Fig2)中，您可以看到此模拟中机器人的起始位置。圆圈围绕着机器人表示它正在传输；两个机器人之间的线表示它们正在通信。
- en: So, from Figure [13-2](#Fig2), you can see that at the start, only one bot (with
    ID =1) is transmitting. Initially, the goal of the bots is to create a network
    in which they are connected and can send and receive messages to any bot, so they
    start moving around, stopping only when they receive a message from a bot connected
    to the growing network, starting from bot 1\. Bot 1 remains stopped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从图[13-2](#Fig2)中可以看到，在开始时，只有一个机器人（ID = 1）在传输。最初，机器人的目标是创建一个网络，在这个网络中它们彼此连接并可以向任何机器人发送和接收消息，因此它们开始四处移动，只有当它们从与不断增长的网络连接的机器人收到消息时才停止移动，从机器人1开始。机器人1保持静止。
- en: After the bots create the network, they use this common channel to agree on
    the main game parameters and then start playing. During this phase, their job
    is either to run away from other bots or catch the one who has the chosen color.
    Also, this phase starts with only one bot transmitting; this is the target bot,
    or runner, which constantly sends its color and its distance from the target (which
    is 0, of course).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人创建网络之后，它们使用这个共同的信道来协商主要的游戏参数，然后开始游戏。在此阶段，它们的工作要么是逃离其他机器人，要么是捕捉具有选定颜色的机器人。此外，此阶段始于只有一个机器人在传输；这是目标机器人或逃跑者，它不断发送其颜色和与目标的距离（当然是0）。
- en: Bots that don’t receive a message start moving around searching for anyone,
    the bots that actually get messages, and try to use the information about the
    distance from the target bot contained in those messages to catch the runner.
    See Figure [13-3](#Fig3).![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 没有收到消息的机器人开始四处移动寻找任何人，实际收到消息的机器人，并尝试使用这些消息中包含的有关目标机器人距离的信息来捕捉该机器人。见图[13-3](#Fig3)。！[../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg)
- en: Figure 13-2
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2
- en: Orbit bot
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人轨道
- en: '![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: ！[../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg)
- en: Figure 13-3
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3
- en: Orbit bot
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人轨道
- en: 13.6 Project Code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 项目代码
- en: 'This is the main code for the project. It is developed in C language. To execute
    this code, you need a C language compiler. The rotation of the robot and movements
    (left and right and forward and backward) are defined in different functions in
    the code. Using void setup_message() function message handling of each robot is
    defined. The orbit_tooclose() function  checks the adjacent robot movement (see
    Listing [13-1](#PC1)).*void smooth_set_motors(uint8_t ccw, uint8_t cw)**{**#ifdef
    KILOBOT*  *uint8_t l = 0, r = 0;*  *if (ccw && !**OCR**2A)*    *l = 0xff;*  *if
    (cw && !**OCR**2B)*    *r = 0xff;*  *if (l || r)*    *{*      *set_motors(l, r);*      *delay(15);*    *}**#endif*  *set_motors(ccw,
    cw);**}**void set_motion(motion_t new_motion)**{*  *switch(new_motion) {*  *case
    STOP:*    *smooth_set_motors(0,0);*    *break;*  *case FORWARD:*    *smooth_set_motors(kilo_straight_left,
    kilo_straight_right);*    *break;*  *case LEFT:*    *smooth_set_motors(kilo_turn_left,
    0);*    *break;*  *case RIGHT:*    *smooth_set_motors(0, kilo_turn_right);*    *break;*  *}**}**void
    orbit_normal()**{*  *if (mydata->cur_distance < TOOCLOSE_DISTANCE) {*        *mydata->orbit_state
    = ORBIT_TOOCLOSE;*    *} else {*        *if (mydata->cur_distance < DESIRED_DISTANCE)*            *set_motion(LEFT);*        *else*            *set_motion(RIGHT);*    *}**}**void
    orbit_tooclose() {*  *if (mydata->cur_distance >= DESIRED_DISTANCE)*    *mydata->orbit_state
    = ORBIT_NORMAL;*  *else*    *set_motion(FORWARD);**}**int EffectId;**int dist;**int
    id=10;**void loop() {**if(mydata->type==2)**{**set_color(**RGB**(0,1,0));**}**if(id<10)**{*  *if(kilo_uid==id){**printf("id
    : %d   %d    %d   id:%d \n",kilo_uid,mydata->type,mydata->typeEffect,id);**mydata->type=1;**set_color(**RGB**(1,0,0));**id=10;}**}**if(mydata->IdEffect<10){**switch(mydata->type)**{**case
    1:{**if(mydata->typeEffect==2)**{**printf("this =>  %d    %d   %d\n",mydata->type,mydata->typeEffect,mydata->IdEffect);**if(mydata->nowDist<40)**{**id=mydata->IdEffect;**set_color(**RGB**(0,1,0));**mydata->type=2;**set_motion(RIGHT);**}**else   if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist>mydata->beforDist){**printf("befor
    :%d  now: %d   befordist:%d   nowdist:%d   move:%d\n",**mydata->beforIdEffect,mydata->IdEffect,mydata->beforDist,mydata->nowDist,mydata->move);*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;**}**break;}**case
    2:{**if(mydata->typeEffect==3)**{**if(mydata->nowDist<40)**{**set_color(**RGB**(0,0,0));**set_motion(FORWARD);**}**}**if(mydata->typeEffect==1)**{*   *if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist<mydata->beforDist){*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;**}**if(mydata->typeEffect==3)**{*   *if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist>mydata->beforDist){*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;*         *}**break;}**case
    3:{break;}**}**}**else  if(mydata->beforIdEffect<10){*          *if(mydata->type<3){*             *if(mydata->countmove>125){*                *mydata->countmove=0;*                *switch(mydata->move){*                *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*                *case
    1:set_motion(FORWARD);mydata->move=2;*                    *mydata->countmove=100;*                    *break;*                *case
    2:set_motion(RIGHT);mydata->move=0;*                    *break;*                    *}*                      *}**mydata->countmove=mydata->countmove+1;**}**}**}**void
    message_rx(message_t *m, distance_measurement_t *d) {**mydata->nowDist = estimate_distance(d);*    *mydata->dist
    = *d;**mydata->IdEffect= m->data[0];**mydata->typeEffect= m->data[1];**}**void
    setup_message(void)**{**switch(kilo_uid){**case 0:mydata->type=1; break;**case
    1:mydata->type=2; break;**case 2:mydata->type=2; break;**case 3:mydata->type=3;
    break;**case 4:mydata->type=3; break;**}*  *mydata->transmit_msg.type = NORMAL;*  *mydata->transmit_msg.data[0]
    = kilo_uid & 0xff;*  *mydata->transmit_msg.data[1]=mydata->type;*  *mydata->transmit_msg.crc
    = message_crc(&mydata->transmit_msg);**}**message_t *message_tx()**{*  *return
    &mydata->transmit_msg;**}**void setup()**{*  *mydata->cur_distance = 0;*  *mydata->new_message
    = 2;**mydata->beforDist=125;**mydata->state=-1;**mydata->IdEffect=10;**mydata->beforIdEffect=10;**mydata->move=0;**mydata->typeEffect=10;*  *setup_message();**switch(kilo_uid){**case
    0:set_color(**RGB**(1,0,0));* *mydata->new_message = 0;**break;**case 1:set_color(**RGB**(0,1,0));* *mydata->new_message
    = 1; break;**case 2:set_color(**RGB**(0,1,0));* *mydata->new_message = 2;break;**case
    3:set_color(**RGB**(0,0,1));* *mydata->new_message = 3;break;**case 4:set_color(**RGB**(0,0,1));* *mydata->new_message
    = 4; break;**}**switch(kilo_uid){**case 0:mydata->type=1; break;**case 1:mydata->type=2;
    break;**case 2:mydata->type=2; break;**case 3:mydata->type=3; break;**case 4:mydata->type=3;
    break;**}**}**#ifdef SIMULATOR**static char botinfo_buffer[10000];**char *cb_botinfo(void)**{*  *char
    *p = botinfo_buffer;*  *p += sprintf (p, "ID: %d beforIdeffect:%d ideffect:%d  beforDist:%d  nowDist:%d   type:%d\n",* *kilo_uid,mydata->beforIdEffect,mydata->IdEffect,**mydata->beforDist,mydata->nowDist,mydata->type);*  *if
    (mydata->orbit_state == ORBIT_NORMAL)*    *p += sprintf (p, "State: ORBIT_NORMAL\n");*  *if
    (mydata->orbit_state == ORBIT_TOOCLOSE)*    *p += sprintf (p, "State: ORBIT_TOOCLOSE\n");*  *return
    botinfo_buffer;**}**#endif**int main() {*    *kilo_init();*    *kilo_message_rx
    = message_rx;*    *SET_CALLBACK(botinfo, cb_botinfo);*      *kilo_message_tx =
    message_tx;*    *kilo_start(setup, loop);*    *return 0;**}**************************************************************Listing
    13-1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Orbit.c
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Orbit.c
- en: In this next project, we assigned starting positions to the Kilobots and specified
    them in the endstate.json file, as shown in Listing [13-2](#PC2).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的项目中，我们为Kilobots分配了起始位置，并在endstate.json文件中指定，如清单[13-2](#PC2)所示。
- en: '***{***  ***"bot_states": [***    ***{***      ***"ID": 0,***      ***"direction":
    0.24680567903004347,***      ***"state": {},***      ***"x_position": -223.0,***      ***"y_position":
    -156.0***    ***},***    ***{***      ***"ID": 1,***      ***"direction": 5.8484504331042393,***      ***"state":
    {},***      ***"x_position": -258.0,***      ***"y_position": 185.0***    ***},***    ***{***      ***"ID":
    2,***      ***"direction": 4.8963292787052639,***      ***"state": {},***      ***"x_position":
    56.320128808496456,***      ***"y_position": -190.86350829767215***    ***},***    ***{***      ***"ID":
    3,***      ***"direction": 4.3219605347985022,***      ***"state": {},***      ***"x_position":
    32.498282727499863,***      ***"y_position": -215.63645771384685***    ***},***    ***{***      ***"ID":
    4,***      ***"direction": 5.5296756682271786,***      ***"state": {},***      ***"x_position":
    248.0,***      ***"y_position": -44.0***    ***}***  ***],***  ***"ticks": 224******}***Listing
    13-2'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '***{***  ***"bot_states": [***    ***{***      ***"ID": 0,***      ***"direction":
    0.24680567903004347,***      ***"state": {},***      ***"x_position": -223.0,***      ***"y_position":
    -156.0***    ***},***    ***{***      ***"ID": 1,***      ***"direction": 5.8484504331042393,***      ***"state":
    {},***      ***"x_position": -258.0,***      ***"y_position": 185.0***    ***},***    ***{***      ***"ID":
    2,***      ***"direction": 4.8963292787052639,***      ***"state": {},***      ***"x_position":
    56.320128808496456,***      ***"y_position": -190.86350829767215***    ***},***    ***{***      ***"ID":
    3,***      ***"direction": 4.3219605347985022,***      ***"state": {},***      ***"x_position":
    32.498282727499863,***      ***"y_position": -215.63645771384685***    ***},***    ***{***      ***"ID":
    4,***      ***"direction": 5.5296756682271786,***      ***"state": {},***      ***"x_position":
    248.0,***      ***"y_position": -44.0***    ***}***  ***],***  ***"ticks": 224******}***Listing
    13-2'
- en: '*endstate.json*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*endstate.json*'
- en: In this project, the basic structure of Kilobots is defined and specified in
    the kilombo.json file, as shown in Listing [13-3](#Par69).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，Kilobots的基本结构在kilombo.json文件中被定义和指定，如清单[13-3](#Par69)所示。
- en: '***Listing 13-3.*** *kilombo.json*{    "botName" : "Orbit bot",    "randSeed"
    : 1,    "nBots" : 5,    "timeStep" : 0.0416666,    "__note" : "0.04166 is 24 FPS
    which matches the movie frame rate",    "__timeStep" : 0.03225,    "simulationTime"
    : 0,    "commsRadius" : 100,    "showComms" : 0,    "showCommsRadius" : 0,    "distributePercent"
    : 0.8,    "displayWidth"  : 800,    "displayHeight" : 700,    "displayWidthPercent"
    : 80,    "displayHeightPercent" : 80,    "displayScale"  : 1,    "showHist" :
    1,    "histLength": 4000,    "storeHistory": 1,    "imageName" : "./movie4/f%04d.bmp",    "saveVideo"
    :  0,    "saveVideoN" : 1,    "stepsPerFrame" : 1,    "finalImage" : null,    "stateFileName"
    : "simstates.json",    "stateFileSteps" : 0,    "colorscheme" : "bright",    "speed":
    7,    "turnRate" : 22,    "GUI"  : 1 ,    "msgSuccessRate" : 0.8,    "distanceNoise"
    : 2}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***清单 13-3.*** *kilombo.json*{    "botName" : "轨道机器人",    "randSeed" : 1,    "nBots"
    : 5,    "timeStep" : 0.0416666,    "__note" : "0.04166 是 24 FPS，与电影帧率相匹配",    "__timeStep"
    : 0.03225,    "simulationTime" : 0,    "commsRadius" : 100,    "showComms" : 0,    "showCommsRadius"
    : 0,    "distributePercent" : 0.8,    "displayWidth"  : 800,    "displayHeight"
    : 700,    "displayWidthPercent" : 80,    "displayHeightPercent" : 80,    "displayScale"  :
    1,    "showHist" : 1,    "histLength": 4000,    "storeHistory": 1,    "imageName"
    : "./movie4/f%04d.bmp",    "saveVideo" :  0,    "saveVideoN" : 1,    "stepsPerFrame"
    : 1,    "finalImage" : null,    "stateFileName" : "simstates.json",    "stateFileSteps"
    : 0,    "colorscheme" : "bright",    "speed": 7,    "turnRate" : 22,    "GUI"  :
    1 ,    "msgSuccessRate" : 0.8,    "distanceNoise" : 2}'
- en: In this next project, the basic structure of orbit is defined and specified
    in the orbit.h file, as shown in Listing [13-4](#Par71).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的项目中，轨道的基本结构在 orbit.h 文件中定义和指定，如清单 [13-4](#Par71) 所示。
- en: '***Listing 13-4.*** *orbit.h**{*    *"botName" : "Orbit bot",*    *"randSeed"
    : 1,*    *"nBots" : 5,*    *"timeStep" : 0.0416666,*    *"__note" : "0.04166 is
    24 FPS which matches the movie frame rate",*    *"__timeStep" : 0.03225,*    *"simulationTime"
    : 0,*    *"commsRadius" : 100,*    *"showComms" : 0,*    *"showCommsRadius" :
    0,*    *"distributePercent" : 0.8,*    *"displayWidth"  : 800,*    *"displayHeight"
    : 700,*    *"displayWidthPercent" : 80,*    *"displayHeightPercent" : 80,*    *"displayScale"  :
    1,*    *"showHist" : 1,*    *"histLength": 4000,*    *"storeHistory": 1,*    *"imageName"
    : "./movie4/f%04d.bmp",*    *"saveVideo" :  0,*    *"saveVideoN" : 1,*    *"stepsPerFrame"
    : 1,*    *"finalImage" : null,*    *"stateFileName" : "simstates.json",*    *"stateFileSteps"
    : 0,*    *"colorscheme" : "bright",*    *"speed": 7,*    *"turnRate" : 22,*    *"GUI"  :
    1 ,*    *"msgSuccessRate" : 0.8,*    *"distanceNoise" : 2**}*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***清单 13-4.*** *orbit.h**{*    *"botName" : "轨道机器人",*    *"randSeed" : 1,*    *"nBots"
    : 5,*    *"timeStep" : 0.0416666,*    *"__note" : "0.04166 是 24 FPS，与电影帧率相匹配",*    *"__timeStep"
    : 0.03225,*    *"simulationTime" : 0,*    *"commsRadius" : 100,*    *"showComms"
    : 0,*    *"showCommsRadius" : 0,*    *"distributePercent" : 0.8,*    *"displayWidth"  :
    800,*    *"displayHeight" : 700,*    *"displayWidthPercent" : 80,*    *"displayHeightPercent"
    : 80,*    *"displayScale"  : 1,*    *"showHist" : 1,*    *"histLength": 4000,*    *"storeHistory":
    1,*    *"imageName" : "./movie4/f%04d.bmp",*    *"saveVideo" :  0,*    *"saveVideoN"
    : 1,*    *"stepsPerFrame" : 1,*    *"finalImage" : null,*    *"stateFileName"
    : "simstates.json",*    *"stateFileSteps" : 0,*    *"colorscheme" : "bright",*    *"speed":
    7,*    *"turnRate" : 22,*    *"GUI"  : 1 ,*    *"msgSuccessRate" : 0.8,*    *"distanceNoise"
    : 2**}*'
- en: If you upload the following GitHub file to [https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html](https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html),
    you will get the Blockly4Sos diagram for this project. Figure [13-4](#Fig4) shows
    the output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将以下 GitHub 文件上传到[https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html](https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html)，您将获得该项目的
    Blockly4Sos 图表。图[13-4](#Fig4)显示了输出。
- en: '[https://github.com/JosephThachilGeorge/Blockly4SoS](https://github.com/JosephThachilGeorge/Blockly4SoS)![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/JosephThachilGeorge/Blockly4SoS](https://github.com/JosephThachilGeorge/Blockly4SoS)![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg)'
- en: Figure 13-4
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4
- en: BlocklySoS output
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: BlocklySoS 输出
- en: 13.7 Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 总结
- en: This chapter discussed how to create a cyber-physical system based on the Italian
    game, Witch Calls Color. This project illustrates the features of cyber-physical
    systems and the communication used by distributed systems. This project is modeled
    with the help of the BlocklySoS modeling diagram. The next chapter will dive into
    a more complex project, which will help you better understand the distributed
    systems architecture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何基于意大利游戏《巫婆呼叫颜色》创建一个网络物理系统。该项目说明了网络物理系统的特性以及分布式系统使用的通信方式。该项目是借助 BlocklySoS
    建模图进行建模的。下一章将深入探讨一个更复杂的项目，这将帮助您更好地理解分布式系统架构。
