- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_13](https://doi.org/10.1007/978-1-4842-7480-4_13)
  prefs: []
  type: TYPE_NORMAL
- en: 13. Cyber-Physical Systems Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learn how to develop a cyber-physical system based on an
    Italian game called Witch Calls Color.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game has the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: One player is picked to be the witch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They call out a color, such as blue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other children then run to touch an object of that color. (Clothes are not
    included, and only one person can touch an object.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the witch catches a child who is not touching the color, they become the
    next witch. Then the original witch joins the other kids.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are going to implement this project with the help of Kilobots. The movement
    of the witch and the color are implemented in Kilobots.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Using Kilobots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Kilobot*  cluster  is a cluster of 1,000 robots that may be used to create
    collective behavior that is automatic and has a long duration. Each robot has
    the basic functions of an autonomous swarm robot, but it is made up of a restricted
    number of pieces and assembled mostly by an automatic system.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the system design allows a single individual to operate a huge
    Kilobot cooperative in an efficient and scalable manner, including programming
    it, turning it on, and refilling all the robots. The Kilobot swarm is used to
    investigate collective "virtual" intellect and to test innovative theories that
    link minimal personal qualities to cluster characteristics. See Figure [13-1](#Fig1).
  prefs: []
  type: TYPE_NORMAL
- en: Using a mixed concept technique, you can obtain new algorithmic understanding
    about robustness, adaptability, personality, and an emerging in groups of limited
    individuals.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.1 The Kilobots Movements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following list shows the basic Kilobots movements:'
  prefs: []
  type: TYPE_NORMAL
- en: Upward motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of rotating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping in touch with adjacent units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the difference between adjacent units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having sufficient RAM to execute the Kilobots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following extra parts were added to the Kilobot to expand its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The capacity to estimate the amount of light in the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the operations more flexible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig1_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1
  prefs: []
  type: TYPE_NORMAL
- en: A Kilobot
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 Project Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 13.2.1 Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kilobots will operate in a space of at least 100x80cm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The surface should be glossy and reflective for the infrared to work properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SoS is composed of at least five Kilobots and a controller (one witch, two
    players, and two colors).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SoS is composed of at least five Kilobots and a controller (one witch, two
    players, and two colors).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the beginning of the program execution, there are assigned positions for
    the Kilobots.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Kilobot has an ID, color, and positions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the game starts, the player searches for the color and the witch searches
    for the player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The witch and player Kilobots are waiting for the signal to each other to run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target color is chosen by the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the game, all of the Kilobots are searching for each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '11.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the game, the witch is trying to catch the players and the players are
    searching for the color. If the witch catches a player, that player will be the
    witch in the next round.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '12.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The round is finished when the Kilobots catch the color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '13.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Kilobot has two independent motors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '14.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Kilobot has an infrared transmitter and receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '15.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kilobots can estimate relative distance from other bots from the environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '16.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Kilobots will operate in one of at least three states: run, bootload, or
    sleep.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '17.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through a message interface, each Kilobot can communicate with every other Kilobit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 13.2.2 Project Communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kilobots can receive messages from the overhead controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kilobots are communicating when they are within 7.5cm distance of each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The connection between all the Kilobots is established at the beginning of each
    round.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There should be a unique Kilobot operating as a central communication coordinator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 13.2.3 Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each Kilobot will have a time-based internal clock. Kilobots can communicate
    over the network within 10 seconds of every message sent.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.4 Dynamicity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Kilobot moving out of the range of communication will start moving to find
    the other Kilobots in order to become a part of the network again.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5 Dependability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Availability: A charged battery is necessary for Kilobots.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reliability: The Kilobots can start each game round only when they can communicate
    with all the others because they don’t provide the necessary service.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Integrity: It is fundamental that the SoS doesn’t have an improper state to
    function correctly.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 13.3 Blockly4SoS Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this model, we have an SoS composed of five Kilobots and one overhead controller  .
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The overhead controller has a RUMI (a Relied Upon Message Interface) that it
    uses to send information to the Kilobots about the state they must enter or sends
    the code that defines the behavior of Kilobots.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kilobot with ID=0 is the central point of communication; it helps you define
    a better protocol of communication .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every Kilobot has a RUMI, which is the interface that they use to exchange messages,
    and a RUPI (Relied Upon Physical Interface), which is represented by the infrared
    sensor that catches information from the environment (for example, the distance
    from the other bots). The message channels are based on the infrared sensor at
    the hardware layer, but since that is used to directly communicate the data and
    exchange messages, those are RUMIs. Every characteristic of the Kilobots’ SoS
    is related to a requirement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 13.4 Implementing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you assign starting positions of Kilobots and specify them
    in the endstate.json file. At first, a Kilobot moves in a spiral way, trying to
    establish a connection with the other Kilobots in order to receive a signal.
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, every Kilobot sends an array of 10 bits, where all the bits
    are 0 except for the one at the array position equal to the Kilobot ID. When every
    Kilobot has an array, that means that every Kilobot is connected to all the other
    Kilobots one way and they are ready to communicate. The first phase is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: In the second phase, all the Kilobots have formed a network and now act as an
    SoS. They select the witch and broadcast this information through the network
    of Kilobots. Every Kilobot resends the received message until the chosen witch
    receives it. Then the witch selects the target color to catch and broadcast this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next phase, the Kilobots try to catch the target. Every Kilobot evaluates
    the distance to the target Kilobot, identifying which of the neighbors have the
    field “distance to target” smaller than all the others. By adding the “distance
    to target” of the neighbor to the distance of Kilobot X to the neighbor’s closest
    to the target, you can obtain an approximate distance to the target. This process
    starts from the Kilobots that are effectively communicating with the target, because
    they are the only ones able to obtain the real distance to the target. After that,
    this process will recursively happen up to the outermost node of the network.
  prefs: []
  type: TYPE_NORMAL
- en: So, every Kilobot in communication range can know the approximate distance to
    the target and the closest neighbor it needs to follow in order to reach the target.
    Kilobots can go out of range of communication. In such cases, they start moving
    in a spiral way until they find someone communicating with the target.
  prefs: []
  type: TYPE_NORMAL
- en: There is an emergent behavior—an unexpected and positive behavior—that when
    a Kilobot exits the range, it turns around 360 degrees and enters the range again.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Executing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you assign the starting positions of the Kilobots and specify
    them in the endstate.json file. Now, we’ll describe the simulation as per the
    settings you choose (most importantly, randSeed = 2).
  prefs: []
  type: TYPE_NORMAL
- en: In Figure [13-2](#Fig2), you can see the starting positions of the bots in this
    simulation. A circle around a bot means that it is transmitting; a line between
    two bots means they are communicating.
  prefs: []
  type: TYPE_NORMAL
- en: So, from Figure [13-2](#Fig2), you can see that at the start, only one bot (with
    ID =1) is transmitting. Initially, the goal of the bots is to create a network
    in which they are connected and can send and receive messages to any bot, so they
    start moving around, stopping only when they receive a message from a bot connected
    to the growing network, starting from bot 1\. Bot 1 remains stopped.
  prefs: []
  type: TYPE_NORMAL
- en: After the bots create the network, they use this common channel to agree on
    the main game parameters and then start playing. During this phase, their job
    is either to run away from other bots or catch the one who has the chosen color.
    Also, this phase starts with only one bot transmitting; this is the target bot,
    or runner, which constantly sends its color and its distance from the target (which
    is 0, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Bots that don’t receive a message start moving around searching for anyone,
    the bots that actually get messages, and try to use the information about the
    distance from the target bot contained in those messages to catch the runner.
    See Figure [13-3](#Fig3).![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13-2
  prefs: []
  type: TYPE_NORMAL
- en: Orbit bot
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig3_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-3
  prefs: []
  type: TYPE_NORMAL
- en: Orbit bot
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Project Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the main code for the project. It is developed in C language. To execute
    this code, you need a C language compiler. The rotation of the robot and movements
    (left and right and forward and backward) are defined in different functions in
    the code. Using void setup_message() function message handling of each robot is
    defined. The orbit_tooclose() function  checks the adjacent robot movement (see
    Listing [13-1](#PC1)).*void smooth_set_motors(uint8_t ccw, uint8_t cw)**{**#ifdef
    KILOBOT*  *uint8_t l = 0, r = 0;*  *if (ccw && !**OCR**2A)*    *l = 0xff;*  *if
    (cw && !**OCR**2B)*    *r = 0xff;*  *if (l || r)*    *{*      *set_motors(l, r);*      *delay(15);*    *}**#endif*  *set_motors(ccw,
    cw);**}**void set_motion(motion_t new_motion)**{*  *switch(new_motion) {*  *case
    STOP:*    *smooth_set_motors(0,0);*    *break;*  *case FORWARD:*    *smooth_set_motors(kilo_straight_left,
    kilo_straight_right);*    *break;*  *case LEFT:*    *smooth_set_motors(kilo_turn_left,
    0);*    *break;*  *case RIGHT:*    *smooth_set_motors(0, kilo_turn_right);*    *break;*  *}**}**void
    orbit_normal()**{*  *if (mydata->cur_distance < TOOCLOSE_DISTANCE) {*        *mydata->orbit_state
    = ORBIT_TOOCLOSE;*    *} else {*        *if (mydata->cur_distance < DESIRED_DISTANCE)*            *set_motion(LEFT);*        *else*            *set_motion(RIGHT);*    *}**}**void
    orbit_tooclose() {*  *if (mydata->cur_distance >= DESIRED_DISTANCE)*    *mydata->orbit_state
    = ORBIT_NORMAL;*  *else*    *set_motion(FORWARD);**}**int EffectId;**int dist;**int
    id=10;**void loop() {**if(mydata->type==2)**{**set_color(**RGB**(0,1,0));**}**if(id<10)**{*  *if(kilo_uid==id){**printf("id
    : %d   %d    %d   id:%d \n",kilo_uid,mydata->type,mydata->typeEffect,id);**mydata->type=1;**set_color(**RGB**(1,0,0));**id=10;}**}**if(mydata->IdEffect<10){**switch(mydata->type)**{**case
    1:{**if(mydata->typeEffect==2)**{**printf("this =>  %d    %d   %d\n",mydata->type,mydata->typeEffect,mydata->IdEffect);**if(mydata->nowDist<40)**{**id=mydata->IdEffect;**set_color(**RGB**(0,1,0));**mydata->type=2;**set_motion(RIGHT);**}**else   if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist>mydata->beforDist){**printf("befor
    :%d  now: %d   befordist:%d   nowdist:%d   move:%d\n",**mydata->beforIdEffect,mydata->IdEffect,mydata->beforDist,mydata->nowDist,mydata->move);*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;**}**break;}**case
    2:{**if(mydata->typeEffect==3)**{**if(mydata->nowDist<40)**{**set_color(**RGB**(0,0,0));**set_motion(FORWARD);**}**}**if(mydata->typeEffect==1)**{*   *if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist<mydata->beforDist){*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;**}**if(mydata->typeEffect==3)**{*   *if(mydata->beforIdEffect==mydata->IdEffect)**{*    *if(mydata->nowDist>mydata->beforDist){*        *switch(mydata->move){*            *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*            *case
    1:set_motion(FORWARD);mydata->move=2;*                *break;*            *case
    2:set_motion(RIGHT);mydata->move=0;*                *break;*                *}**}**}**mydata->beforIdEffect=mydata->IdEffect;**mydata->beforDist=mydata->nowDist;**mydata->IdEffect=10;*         *}**break;}**case
    3:{break;}**}**}**else  if(mydata->beforIdEffect<10){*          *if(mydata->type<3){*             *if(mydata->countmove>125){*                *mydata->countmove=0;*                *switch(mydata->move){*                *case
    0:*                *set_motion(LEFT);mydata->move=1;*                *break;*                *case
    1:set_motion(FORWARD);mydata->move=2;*                    *mydata->countmove=100;*                    *break;*                *case
    2:set_motion(RIGHT);mydata->move=0;*                    *break;*                    *}*                      *}**mydata->countmove=mydata->countmove+1;**}**}**}**void
    message_rx(message_t *m, distance_measurement_t *d) {**mydata->nowDist = estimate_distance(d);*    *mydata->dist
    = *d;**mydata->IdEffect= m->data[0];**mydata->typeEffect= m->data[1];**}**void
    setup_message(void)**{**switch(kilo_uid){**case 0:mydata->type=1; break;**case
    1:mydata->type=2; break;**case 2:mydata->type=2; break;**case 3:mydata->type=3;
    break;**case 4:mydata->type=3; break;**}*  *mydata->transmit_msg.type = NORMAL;*  *mydata->transmit_msg.data[0]
    = kilo_uid & 0xff;*  *mydata->transmit_msg.data[1]=mydata->type;*  *mydata->transmit_msg.crc
    = message_crc(&mydata->transmit_msg);**}**message_t *message_tx()**{*  *return
    &mydata->transmit_msg;**}**void setup()**{*  *mydata->cur_distance = 0;*  *mydata->new_message
    = 2;**mydata->beforDist=125;**mydata->state=-1;**mydata->IdEffect=10;**mydata->beforIdEffect=10;**mydata->move=0;**mydata->typeEffect=10;*  *setup_message();**switch(kilo_uid){**case
    0:set_color(**RGB**(1,0,0));* *mydata->new_message = 0;**break;**case 1:set_color(**RGB**(0,1,0));* *mydata->new_message
    = 1; break;**case 2:set_color(**RGB**(0,1,0));* *mydata->new_message = 2;break;**case
    3:set_color(**RGB**(0,0,1));* *mydata->new_message = 3;break;**case 4:set_color(**RGB**(0,0,1));* *mydata->new_message
    = 4; break;**}**switch(kilo_uid){**case 0:mydata->type=1; break;**case 1:mydata->type=2;
    break;**case 2:mydata->type=2; break;**case 3:mydata->type=3; break;**case 4:mydata->type=3;
    break;**}**}**#ifdef SIMULATOR**static char botinfo_buffer[10000];**char *cb_botinfo(void)**{*  *char
    *p = botinfo_buffer;*  *p += sprintf (p, "ID: %d beforIdeffect:%d ideffect:%d  beforDist:%d  nowDist:%d   type:%d\n",* *kilo_uid,mydata->beforIdEffect,mydata->IdEffect,**mydata->beforDist,mydata->nowDist,mydata->type);*  *if
    (mydata->orbit_state == ORBIT_NORMAL)*    *p += sprintf (p, "State: ORBIT_NORMAL\n");*  *if
    (mydata->orbit_state == ORBIT_TOOCLOSE)*    *p += sprintf (p, "State: ORBIT_TOOCLOSE\n");*  *return
    botinfo_buffer;**}**#endif**int main() {*    *kilo_init();*    *kilo_message_rx
    = message_rx;*    *SET_CALLBACK(botinfo, cb_botinfo);*      *kilo_message_tx =
    message_tx;*    *kilo_start(setup, loop);*    *return 0;**}**************************************************************Listing
    13-1'
  prefs: []
  type: TYPE_NORMAL
- en: Orbit.c
  prefs: []
  type: TYPE_NORMAL
- en: In this next project, we assigned starting positions to the Kilobots and specified
    them in the endstate.json file, as shown in Listing [13-2](#PC2).
  prefs: []
  type: TYPE_NORMAL
- en: '***{***  ***"bot_states": [***    ***{***      ***"ID": 0,***      ***"direction":
    0.24680567903004347,***      ***"state": {},***      ***"x_position": -223.0,***      ***"y_position":
    -156.0***    ***},***    ***{***      ***"ID": 1,***      ***"direction": 5.8484504331042393,***      ***"state":
    {},***      ***"x_position": -258.0,***      ***"y_position": 185.0***    ***},***    ***{***      ***"ID":
    2,***      ***"direction": 4.8963292787052639,***      ***"state": {},***      ***"x_position":
    56.320128808496456,***      ***"y_position": -190.86350829767215***    ***},***    ***{***      ***"ID":
    3,***      ***"direction": 4.3219605347985022,***      ***"state": {},***      ***"x_position":
    32.498282727499863,***      ***"y_position": -215.63645771384685***    ***},***    ***{***      ***"ID":
    4,***      ***"direction": 5.5296756682271786,***      ***"state": {},***      ***"x_position":
    248.0,***      ***"y_position": -44.0***    ***}***  ***],***  ***"ticks": 224******}***Listing
    13-2'
  prefs: []
  type: TYPE_NORMAL
- en: '*endstate.json*'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, the basic structure of Kilobots is defined and specified in
    the kilombo.json file, as shown in Listing [13-3](#Par69).
  prefs: []
  type: TYPE_NORMAL
- en: '***Listing 13-3.*** *kilombo.json*{    "botName" : "Orbit bot",    "randSeed"
    : 1,    "nBots" : 5,    "timeStep" : 0.0416666,    "__note" : "0.04166 is 24 FPS
    which matches the movie frame rate",    "__timeStep" : 0.03225,    "simulationTime"
    : 0,    "commsRadius" : 100,    "showComms" : 0,    "showCommsRadius" : 0,    "distributePercent"
    : 0.8,    "displayWidth"  : 800,    "displayHeight" : 700,    "displayWidthPercent"
    : 80,    "displayHeightPercent" : 80,    "displayScale"  : 1,    "showHist" :
    1,    "histLength": 4000,    "storeHistory": 1,    "imageName" : "./movie4/f%04d.bmp",    "saveVideo"
    :  0,    "saveVideoN" : 1,    "stepsPerFrame" : 1,    "finalImage" : null,    "stateFileName"
    : "simstates.json",    "stateFileSteps" : 0,    "colorscheme" : "bright",    "speed":
    7,    "turnRate" : 22,    "GUI"  : 1 ,    "msgSuccessRate" : 0.8,    "distanceNoise"
    : 2}'
  prefs: []
  type: TYPE_NORMAL
- en: In this next project, the basic structure of orbit is defined and specified
    in the orbit.h file, as shown in Listing [13-4](#Par71).
  prefs: []
  type: TYPE_NORMAL
- en: '***Listing 13-4.*** *orbit.h**{*    *"botName" : "Orbit bot",*    *"randSeed"
    : 1,*    *"nBots" : 5,*    *"timeStep" : 0.0416666,*    *"__note" : "0.04166 is
    24 FPS which matches the movie frame rate",*    *"__timeStep" : 0.03225,*    *"simulationTime"
    : 0,*    *"commsRadius" : 100,*    *"showComms" : 0,*    *"showCommsRadius" :
    0,*    *"distributePercent" : 0.8,*    *"displayWidth"  : 800,*    *"displayHeight"
    : 700,*    *"displayWidthPercent" : 80,*    *"displayHeightPercent" : 80,*    *"displayScale"  :
    1,*    *"showHist" : 1,*    *"histLength": 4000,*    *"storeHistory": 1,*    *"imageName"
    : "./movie4/f%04d.bmp",*    *"saveVideo" :  0,*    *"saveVideoN" : 1,*    *"stepsPerFrame"
    : 1,*    *"finalImage" : null,*    *"stateFileName" : "simstates.json",*    *"stateFileSteps"
    : 0,*    *"colorscheme" : "bright",*    *"speed": 7,*    *"turnRate" : 22,*    *"GUI"  :
    1 ,*    *"msgSuccessRate" : 0.8,*    *"distanceNoise" : 2**}*'
  prefs: []
  type: TYPE_NORMAL
- en: If you upload the following GitHub file to [https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html](https://blockly4sos.resiltech.com/latest/demos/amadeos/i.html),
    you will get the Blockly4Sos diagram for this project. Figure [13-4](#Fig4) shows
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/JosephThachilGeorge/Blockly4SoS](https://github.com/JosephThachilGeorge/Blockly4SoS)![../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg](../images/520777_1_En_13_Chapter/520777_1_En_13_Fig4_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13-4
  prefs: []
  type: TYPE_NORMAL
- en: BlocklySoS output
  prefs: []
  type: TYPE_NORMAL
- en: 13.7 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discussed how to create a cyber-physical system based on the Italian
    game, Witch Calls Color. This project illustrates the features of cyber-physical
    systems and the communication used by distributed systems. This project is modeled
    with the help of the BlocklySoS modeling diagram. The next chapter will dive into
    a more complex project, which will help you better understand the distributed
    systems architecture.
  prefs: []
  type: TYPE_NORMAL
