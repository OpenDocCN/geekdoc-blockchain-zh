- en: CHAPTER 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CHAPTER 2
- en: Fundamentals
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: The goal of blockchain technology is to create a shared, decentralized digital
    ledger. In this system, no centralized authority exists to dictate what the official
    version of the digital ledger is.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术的目的是创建一个共享的、去中心化的数字账本。在这个系统中，不存在中央权威来规定数字账本的官方版本。
- en: Blockchain technology transfers trust in the digital ledger away from a centralized
    authority to a set of protocols designed to provide the same guarantees as a centralized
    ledger. These protocols are created using smaller building blocks with certain
    properties that can provide these desired guarantees.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术将数字账本中的信任从集中式权威转移到一组旨在提供与集中式账本相同的保证的协议。这些协议使用具有某些性质的小型构建块创建，能够提供这些期望的保证。
- en: 'This chapter explores the fundamentals of blockchain security. This includes
    the cryptographic primitives and the data structures that are used to build blockchain
    protocols and make the decentralized digital ledger possible.  ## Cryptographic
    Primitives'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨区块链安全的基础知识。这包括用于构建区块链协议和使去中心化数字账本成为可能的密码学原语和数据结构。## 密码学原语
- en: Financial institutions maintain an internal accounts ledger, enabling value
    to be transferred from one party to another by simply updating the relevant values
    in this ledger. Each financial institution is responsible for maintaining the
    accuracy of its ledger, and customers must trust the financial institution to
    properly track their financial transactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 金融机构维护一个内部账户账本，通过简单地更新此账本中的相关值，使价值能够从一方转移到另一方。每个金融机构都负责维护其账本的准确性，客户必须信任金融机构能够正确追踪他们的财务交易。
- en: Blockchain is designed to transfer this trust from these centralized authorities
    to cryptographic algorithms and protocols. The cryptographic algorithms are relied
    upon to ensure the authenticity and integrity of the transactions recorded on
    the blockchain's ledger.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链旨在将这种信任从这些集中式权威转移到密码学算法和协议。密码学算法被依赖以确保记录在区块链账本上的交易的完整性和真实性。
- en: Blockchain technology began with Bitcoin, and since then, many different blockchains
    have emerged, each with its own tweaks on the underlying protocols and methods
    of implementing them. However, all of these protocols are reliant on the same
    set of cryptographic building blocks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术从比特币开始，自那时以来，出现了许多不同的区块链，每个区块链都有自己对该底层协议和实现方法的调整。然而，所有这些协议都依赖于相同的密码学构建块。
- en: The design of the blockchain makes data integrity and authenticity protections
    vital for the system to work. To provide these protections, blockchain technology
    uses public key cryptography and hash functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的设计使得数据完整性和真实性保护对系统运行至关重要。为了提供这些保护，区块链技术使用公钥加密和哈希函数。
- en: '### Public Key Cryptography'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '### 公钥加密'
- en: Cryptographic algorithms are divided into two main categories based on how they
    use encryption keys. Symmetric algorithms use a single key for both encryption
    and decryption. This symmetry means that the algorithms are generally more efficient,
    making them better suited for bulk data transfer. However, they require the shared
    secret key to be distributed to all participants via a secure channel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学算法根据它们如何使用加密密钥分为两大类。对称算法用于加密和解密的单密钥。这种对称性意味着算法通常更高效，使它们更适合大数据传输。然而，它们需要通过安全通道将共享密钥分发给所有参与者。
- en: Asymmetric, or public key, cryptography uses a public key for encryption and
    a private key for decryption. This makes it possible to send a secret message
    to anyone without setting up a shared secret key. However, these algorithms are
    generally less efficient than their symmetric counterparts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不对称加密，或公钥加密，使用公钥进行加密和解密。这使得能够将秘密消息发送给任何人，而无需设置共享密钥。然而，这些算法通常不如其对称对手高效。
- en: Blockchain technology is heavily dependent on public key cryptography. Its use
    of two related keys and the ability to create and validate digital signatures
    using them provides the invaluable ability to authenticate the sender of a message.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术严重依赖公钥加密。它使用两个相关密钥，并能够使用它们创建和验证数字签名，提供了验证消息发送者的无价能力。
- en: '#### *Introducing “Hard” Mathematical Problems*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 介绍“困难”的数学问题'
- en: Public key cryptography is built using “hard” mathematical problems. These mathematical
    functions are defined by an asymmetric relationship between how hard they are
    to perform versus how hard they are to reverse. For these problems, `F`(`x)` has
    polynomial complexity, while `F^(−1)(x)` has exponential complexity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学是构建在“困难”数学问题之上的。这些数学函数由它们难以执行与难以逆向的 asymmetric 关系定义。对于这些问题，\( F(x) \)的复杂度是多项式的，而\(
    F^{-1}(x) \)的复杂度是指数的。
- en: This relationship makes it possible to develop cryptographic algorithms that
    are both usable and secure. The algorithms are designed so that a legitimate user
    only has to perform the easy operation, `F(x)`, while any attacker must solve
    the harder problem, `F^(−1)(x)`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系使得开发既可用又安全的密码算法成为可能。算法设计为合法用户只需进行简单操作，\( F(x) \)，而任何攻击者必须解决更难的问题，\( F^{-1}(x)
    \)。
- en: Several of these mathematically “hard” problems exist. The two most commonly
    used in “classical” (i.e., not post-quantum) cryptography are the factoring problem,
    which is the basis for RSA, and the discrete logarithm problem, which is the basis
    for the Digital Signature Algorithm (DSA). Algorithms based on these problems
    can also be implemented more efficiently using elliptic curve cryptography (ECC).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几个数学上“困难”的问题。在“经典”（即非后量子）密码学中，最常使用的两个问题是因数分解问题，它是RSA算法的基石，以及离散对数问题，它是数字签名算法（DSA）的基石。基于这些问题的算法也可以通过使用椭圆曲线密码学（ECC）更有效地实现。
- en: '##### The Factoring Problem'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '### 因数分解问题'
- en: In the factoring problem, the easier operation is multiplying two prime numbers.
    The complexity of doing so is polynomial in the length of the two numbers. This
    means that an increase in the length of the two primes, such as switching from
    128 to 129 bits, has a relatively small impact on the overall complexity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在因数分解问题中，较简单的操作是两个素数的乘法。执行此操作的复杂度是两个数字长度的多项式。这意味着两个素数长度的增加，例如从128位增加到129位，对整体复杂度的影响相对较小。
- en: Factoring inverts multiplication, and factoring has exponential complexity in
    the length of the factors. The reason for this is that the best-known way to factor
    two numbers on a non-quantum computer has exponential complexity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因数分解逆用了乘法，且因数分解的复杂度随因数长度的指数增长。其原因是，在非量子计算机上分解两个数字的最佳已知方法其复杂度随因数长度指数增长。
- en: While one of the factors is guaranteed to be less than the square root of the
    quotient, this is a large space that grows rapidly. Adding a single bit to the
    length of the primes (i.e., from 128 to 129 bits) doubles the number of potential
    factors that an attacker needs to search.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其中一个因子保证小于商的平方根，但这是一个巨大的空间，且快速增长。将素数的长度增加一个比特（即从128位增加到129位）会将攻击者需要搜索的潜在因数数量翻倍。
- en: 'The difficulty of factoring grows much faster than the difficulty of multiplying.
    As a result, it is possible to find a length of these factors where multiplication
    is possible but factoring is not.  ##### The Discrete Logarithm Problem'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因数分解的难度远大于乘法的难度。因此，可能找到这样一个因数的长度，使得乘法是可能的，但因数分解是不可能的。### 离散对数问题
- en: The discrete logarithm problem is another asymmetric problem commonly used in
    public key cryptography. It is based on the “easy” problem of exponentiation and
    the “hard” problem of logarithms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 离散对数问题是公钥密码学中常用的另一个非对称问题。它基于指数运算的“容易”问题和对数的“困难”问题。
- en: 'As with the factoring problem, the discrete logarithm problem is designed to
    ensure that legitimate operations are easy compared to malicious ones. Increasing
    the size of the exponent has a minimal impact on a legitimate user—but a significant
    impact on an attacker. As with the factoring problem, the best way to solve the
    discrete logarithm is by guessing possible values for the exponent, so a user
    can achieve an arbitrary level of security by increasing the key length.  #####
    Elliptic Curve Cryptography'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与因数分解问题类似，离散对数问题也是设计成使合法操作相较于恶意操作变得简单。指数大小的增加对合法用户影响最小——但对攻击者影响显著。与因数分解问题一样，解决离散对数问题的最佳方法是猜测指数的可能值，因此用户可以通过增加密钥长度来实现任意安全级别。###
    椭圆曲线密码学
- en: Elliptic curve cryptography (ECC) is a type of public key cryptography that
    uses points on an elliptic curve instead of integers as the basis for computation.
    An elliptic curve is a mathematical function of the form `y² = x³ + ax + b`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）是一种使用椭圆曲线上的点而不是整数作为计算基础的公开密钥密码学。椭圆曲线是形式为`y² = x³ + ax + b`的数学函数。
- en: Using points on these curves as public keys, it's possible to create a public
    key cryptosystem that uses the same principles as the discrete logarithm problem.
    On an elliptic curve, an operation called point addition is equivalent to multiplication
    over the integers, and point multiplication is equivalent to exponentiation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些曲线上的点作为公钥，可以创建一个利用离散对数问题相同原理的公钥密码系统。在椭圆曲线上，称为点加法的操作与整数上的乘法等价，而点乘法与指数运算等价。
- en: In elliptic curve cryptography, public keys are derived from private keys by
    multiplying a random integer (the private key) with a publicly known point on
    the curve (the generator). As with the factoring and discrete logarithm problems,
    point addition and multiplication (the equivalents of multiplication and exponentiation)
    are “easy” for legitimate users, while point subtraction and division (the equivalents
    of factoring and logarithms) are “hard” for an attacker.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线密码学中，公钥是通过将一个随机整数（私钥）与曲线上的一个公开点（生成器）相乘得到的。与因数分解和离散对数问题一样，点加法和乘法（乘法和指数运算的等价物）对于合法用户来说是“容易”的，而点减法和除法（因数分解和对数的等价物）对于攻击者来说是“困难”的。
- en: 'Elliptic curve cryptography has two main advantages over integer-based public
    key cryptography: key length and energy consumption. Elliptic curve cryptography
    accomplishes the same level of security as cryptosystems using the discrete logarithm
    problem with much shorter keys. For example, a 2048-bit RSA key has equivalent
    security to a 160-bit ECC curve. ECC is also better than algorithms like RSA in
    low-power environments because the operations used in ECC-based cryptography (point
    addition and multiplication) consume less power than the equivalent operations
    over the integers (multiplication and exponentiation).  #### *Building Cryptography
    with “Hard” Problems*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学相对于基于整数的公钥密码学有两个主要优势：密钥长度和能量消耗。椭圆曲线密码学以更短的密钥实现了与使用离散对数问题的密码系统相同的级别安全性。例如，2048位的RSA密钥与160位的ECC曲线具有等效的安全性。ECC在低功耗环境也比算法如RSA更好，因为ECC基础密码学中使用的操作（点加法和乘法）比整数上的等效操作（乘法和指数运算）消耗的功率更少。####
    使用“困难”问题构建密码学
- en: Public key cryptography uses these “hard” problems to build algorithms that
    are both usable and secure. The design of these algorithms is intended to allow
    a legitimate user to only perform “easy” operations, while attackers are forced
    to complete “hard” ones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学利用这些“困难”问题来构建既可用又安全的算法。这些算法的设计旨在使合法用户只能执行“容易”的操作，而攻击者被迫完成“困难”的操作。
- en: A critical part of this process is the derivation of the public/private keypair.
    While a private key is a random number, the public key is derived from it to have
    certain properties. The intent is for one key to undo what the other does for
    a particular algorithm.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的一个关键部分是公钥/私钥对的导出。虽然私钥是一个随机数，但公钥是从私钥导出的，以具有某些属性。目的是使一个密钥能够撤销另一个密钥对特定算法所做的工作。
- en: For example, the RSA encryption operation is `c = m^e (mod n)`, where *`c`*
    is the ciphertext, *`m`* is the message, *`e`* is the public key, and *`n`* is
    a public modulus value. Substituting some values in, `2⁵ (mod 14) = 4`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，RSA加密操作是`c = m^e (mod n)`，其中*`c`*是密文，*`m`*是消息，*`e`*是公钥，*`n`*是一个公开模数值。代入一些值，`2⁵
    (mod 14) = 4`。
- en: RSA uses the same operation for decryption, so the private key is selected to
    undo the effects of encryption. A private key of 11 produces `4^(11) (mod 14)
    = 2`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RSA用于解密相同的操作，因此私钥被选择以撤销加密的效果。私钥11产生`4^(11) (mod 14) = 2`。
- en: In the case of RSA, the public and private keys, *`e`* and *`d`*, are selected
    so that `m^(d*e) = 1 (mod 14)` for any message *`m`,* since this is equivalent
    to the two-stage process that we performed due to the properties of exponents.
    With a random private key of 11, *`d`* had to be 5, according to Euler's totient
    function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在RSA的情况下，公钥和私钥*`e`*和*`d`*被选择为任意消息*`m`*满足`m^(d*e) = 1 (mod 14)`，因为这与我们由于指数的性质执行的两阶段过程等价。使用一个随机的私钥11，根据欧拉函数，*`d`*必须是5。
- en: 'Since the recipient of the message knows the private key, they can undo the
    encryption with an exponentiation operation. However, an attacker lacking knowledge
    of this key would need to calculate a logarithm, which is much harder.  #### *How
    the Blockchain Uses Public Key Cryptography*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息的接收者知道私钥，他们可以通过指数运算来撤销加密。然而，缺乏这一密钥的攻击者需要计算对数，这要难得多。#### *区块链如何使用公钥加密*
- en: Public key cryptographic algorithms can provide confidentiality, integrity,
    and authentication protections. They are a fundamental part of how the blockchain
    works and are used for digital signatures and account addressing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密算法可以提供机密性、完整性和认证保护。它们是区块链如何工作的基本组成部分，用于数字签名和账户地址。
- en: '##### Digital Signatures'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 数字签名'
- en: In the previous sections, we explored how public key cryptography can be used
    to protect confidentiality by demonstrating that a private key can be used to
    create an encrypted message that only the intended recipient can read. Digital
    signatures flip this around, creating a digital signature that only the alleged
    sender could generate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们探讨了公钥加密如何用于保护机密性，通过证明私钥可以用来创建只有预期接收者才能阅读的加密消息。数字签名将这一点反过来，生成只有声称的发送者才能生成的数字签名。
- en: As mentioned, public and private keys are selected so that one undoes what the
    other does. In the case of RSA, this meant that `m^(d*e) = 1 (mod n)`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，公钥和私钥的选择意味着一个可以撤销另一个的操作。在RSA的情况下，这意味着 `m^(d*e) = 1 (mod n)`。
- en: However, it also means that `m^(e*d) = 1 (mod n)` or that we could “encrypt”
    with a private key to generate a digital signature and “decrypt” with a public
    key to get the original plaintext. By generating a signature and sending it alongside
    the associated data, we can prove that the data could only have been generated
    by someone who knows the private key and has not been modified in transit. Anyone
    with access to the associated public key can then “decrypt” the signature and
    validate that the plaintext matches.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着 `m^(e*d) = 1 (mod n)` 或者我们可以说，我们可以使用私钥进行“加密”以生成数字签名，“解密”以得到原始明文。通过生成签名并与相关数据一起发送，我们可以证明数据只能由知道私钥的人生成，并且在传输过程中没有修改。任何拥有相关公钥的人都可以“解密”签名，并验证明文是否匹配。
- en: Blockchain uses digital signatures to prove the authenticity of transactions
    on the blockchain. If cryptocurrency is being transferred out of a particular
    account, we want to be sure that the transfer was performed by the owner of the
    account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链使用数字签名来证明区块链上交易的 authenticity。如果加密货币正从一个特定账户转出，我们希望能够确定转账是由该账户的所有者完成的。
- en: 'Also, we''re relying on a peer-to-peer network to carry the transaction and
    nodes to store copies of it in a pool of unused transactions until it is included
    in a block. Digital signatures also prove that a transaction has not been modified
    in transit.  ##### Account Addressing'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还依赖一个点对点网络来传输交易，以及节点将交易副本存储在未使用交易池中，直到它被包含在一个区块中。数字签名还证明交易在传输过程中没有被修改。#####
    账户地址
- en: One of the hard problems associated with digital signatures is proving that
    a particular public key belongs to a particular user. If an attacker intercepts
    a message and a signature, they could modify the message, sign it with their own
    key, and send their own public key alongside it. If the recipient accepts the
    public key as belonging to the alleged sender, they can validate the signature.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字签名相关的一个难题是证明某个特定的公钥属于某个特定的用户。如果攻击者拦截了一条消息和一个签名，他们可以修改消息，用自己的密钥签署，并发送自己的公钥。如果收件人接受这个公钥属于声称的发送者，他们可以验证签名。
- en: 'Blockchain solves this problem by using public keys to derive account addresses.
    This makes it possible to verify that a public key belongs to a particular account
    by rederiving the account address from the key and checking that it matches.  ####
    *Security Assumptions of Public Key Cryptography*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链通过使用公钥来推导账户地址解决了这个问题。这样，我们可以通过重新推导公钥得到账户地址并核对是否一致，来验证一个公钥是否属于某个特定账户。####
    公钥加密的安全假设
- en: 'For public key cryptography to be effective, it needs to be secure. Public
    key cryptography has two main security assumptions: that both the user''s private
    key and the algorithm used are secure.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使公钥加密有效，它需要是安全的。公钥加密有两个主要的安全假设：用户私钥和所使用算法的安全性。
- en: '##### Private Key Security'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 私钥安全'
- en: In public key cryptography, the only secret is a user's private key. Anyone
    with access to this private key can decrypt a message sent to the user or generate
    a digital signature on their behalf.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥加密中，唯一的秘密是一个用户的私钥。任何获得私钥访问权限的人都可以解密发送给该用户的消息或代表他们生成数字签名。
- en: A private key must be securely generated and protected throughout its life cycle.
    If a private key is generated using a weak random number generator or derived
    from a password or passphrase that is guessable, an attacker may be able to learn
    the private key. Blockchain security depends on private keys being generated using
    a cryptographically secure random number generator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥必须在整个生命周期内安全生成和保护。如果私钥是用弱随机数生成器生成的，或者来源于可以猜到的密码或密码短语，攻击者可能能够学到私钥。区块链安全依赖于私钥使用密码学上安全的随机数生成器生成。
- en: 'Once a private key is generated, it must be protected against compromise. If
    an attacker can steal a user''s private key using malware, phishing, or other
    methods, they have the ability to masquerade as that user on the distributed ledger,
    performing transactions on their behalf. Private keys that control accounts with
    access to elevated permissions on the distributed ledger or with large amounts
    of value stored within them should be in cold storage or stored on a device not
    accessible from the Internet.  ##### Algorithmic Security'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了私钥，就必须保护它不被泄露。如果攻击者能够使用恶意软件、网络钓鱼或其他方法窃取用户的私钥，他们就能够伪装成该用户在分布式账本上执行交易。控制分布式账本上具有提升权限的账户或存储大量价值的账户的私钥应该在冷存储中或存储在无法从互联网访问的设备上。#####
    算法安全
- en: The other half of the security of public key cryptography is the security of
    the algorithm itself. This involves ensuring that the “hard” problem that the
    algorithm is built upon remains “hard.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密安全的另一半在于算法本身的安全性。这涉及到确保算法建立在其上的“困难”问题保持“困难”。
- en: 'If this is the case, then the only way to break the cryptography is via a brute-force
    search. If the private key is long enough to make this infeasible, then the protocol
    remains secure.  #### *Attacking Public Key Cryptography*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，那么打破加密的唯一方法就是进行暴力搜索。如果私钥足够长，使得这不可行，那么协议仍然保持安全。####*攻击公钥加密*
- en: The security of public key cryptography boils down to the security of the private
    key and the difficulty of the mathematical problem that the algorithm uses for
    its asymmetry. If an attacker can compromise a private key or break this asymmetry,
    then public key cryptography becomes insecure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密的安全性归根结底在于私钥的安全性和算法所使用的数学难题的难度。如果攻击者能够攻陷私钥或破解这种非对称性，那么公钥加密就变得不安全了。
- en: '##### Private Key Security'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 私钥安全'
- en: With public key cryptography, a user's private key is the only secret. The cryptographic
    algorithm and any parameters that it uses are public knowledge. This means that
    anyone with knowledge of a user's private key can decrypt messages and generate
    digital signatures while impersonating that user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥加密中，用户的私钥是唯一的秘密。加密算法及其使用的任何参数都是公开知识。这意味着任何知道用户私钥的人都可以在伪装成该用户的情况下解密消息和生成数字签名。
- en: 'For this reason, private key security is essential to the security of asymmetric
    cryptography. Two of the primary ways in which this can go wrong are weak key
    generation and failure to properly protect the private key.  ##### Weak Key Generation'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，私钥的安全对于非对称加密的安全至关重要。出问题的主要两种方式是密钥生成薄弱和未能妥善保护私钥。##### 弱密钥生成
- en: Private keys are supposed to be random numbers that are generated to meet the
    requirements of the particular algorithm (key length, primacy, etc.). If a key
    is not random, then an attacker can potentially guess that key. This could allow
    them to generate transactions on a user's behalf, stealing cryptocurrency or interacting
    with smart contracts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥应该是随机生成的数字，以满足特定算法的要求（密钥长度、素性等）。如果密钥不是随机的，那么攻击者可能会猜到这个密钥。这可能让他们能够代表用户生成交易，窃取加密货币或与智能合约互动。
- en: '###### *Weak Random Number Generation*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *弱随机数生成*'
- en: Many blockchain users use a tool to generate private keys for their blockchain
    accounts. This functionality could be integrated into the software that they use
    to access the blockchain, or it could be a stand-alone website or service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多区块链用户使用工具为他们区块链账户生成私钥。这个功能可以集成到他们用来访问区块链的软件中，或者是一个独立的网站或服务。
- en: These tools should use a cryptographic random number generator (RNG) to create
    the users' private keys. However, some are implemented incorrectly or use a non-cryptographic
    RNG, leading to weak sources of randomness.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具应使用密码学随机数生成器（RNG）来创建用户的私钥。然而，一些工具实现不正确，或者使用了非密码学RNG，导致随机性来源薄弱。
- en: The story of the “Blockchain Bandit” demonstrates the risks of such an approach.
    A study by Independent Security Evaluators found that an attacker was scanning
    the Ethereum blockchain for account addresses generated using weak private keys.[¹](#c02-note-0001)
    As of January 13, 2018, the Blockchain Bandit had stolen 37,926 ETH from these
    accounts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “区块链大盗”的故事展示了这种方法的风险。独立安全评估师的一项研究发现，攻击者正在扫描以太坊区块链，寻找使用薄弱私钥生成的账户地址。[¹](#c02-note-0001)截至2018年1月13日，区块链大盗已经从这些账户中窃取了37,926个以太币。
- en: Another risk of using a third-party service for key generation is that the resulting
    private keys could be intentionally weak or recorded by the service to allow future
    theft. A 2019 study found that the source code for `[WalletGenerator.net](http://walletgenerator.net)`
    deviated from the source code at the project's GitHub repository for some time
    after August 17, 2018.[²](#c02-note-0002)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方服务生成密钥的另一个风险是，生成的私钥可能是故意薄弱的，或者被服务记录以允许未来的盗窃。2019年的一项研究发现，`[WalletGenerator.net](http://walletgenerator.net)`的源代码在2018年8月17日之后的一段时间内与项目GitHub存储库的源代码有所偏离。[²](#c02-note-0002)
- en: 'Testing the “bulk wallet” generator on the site found that attempts to create
    1,000 keys resulted in different results for the non-malicious GitHub version
    and the malicious active version. The GitHub version properly generated 1,000
    unique keys, while the active version only provided 120 unique keys per request.
    If these 1,000 keys were provided to different users, some would have the same
    key and access to one another''s blockchain accounts.  ###### *Password-Based
    Private Keys*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上测试“批量钱包”生成器发现，尝试创建1,000个密钥导致非恶意的GitHub版本和恶意活跃版本的结果不同。GitHub版本正确生成了1,000个唯一密钥，而活跃版本每次请求仅提供120个唯一密钥。如果这1,000个密钥提供给不同的用户，其中一些将拥有相同的密钥，并能够访问彼此的区块链账户。######
    **基于密码的私钥**
- en: '*Brain wallet* is a term for memorizing the private key associated with a blockchain
    account. While this has the benefit of being unhackable, most people struggle
    to remember a random series of letters and numbers.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**脑钱包**是指与区块链账户关联的私钥的记忆。虽然这种方法的好处是不可破解的，但大多数人却难以记住一串随机的字母和数字。'
- en: One insecure solution to this problem is to generate a private key from an easily
    memorizable word or phrase. To do so, this seed phrase could be hashed with SHA-256
    or another algorithm with the same length as the desired secret key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不安全的解决方案是使用一个容易记忆的单词或短语来生成私钥。为此，这个种子短语可以被SHA-256或其他与所需秘密密钥长度相同的算法散列。
- en: 'BitMEX research did a study on this approach that they titled Call me Ishmael
    after a quote from *Moby Dick*.[³](#c02-note-0003) The researchers generated secret
    keys using quotes from famous works such as *Moby Dick*, the Bitcoin white paper,
    and Jane Austen''s books. Attackers guessed the passphrases for all of these accounts
    within a day, and one, “Call me Ishmael,” only lasted 0.67 seconds.  ###### *Compromised
    Mnemonic Keys*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: BitMEX研究对此方法进行了一项研究，题目为《叫我以实玛利》（Call me Ishmael），来源于《白鲸记》的一句引用。[³](#c02-note-0003)
    研究人员使用了《白鲸记》、比特币白皮书以及简·奥斯汀的书籍中的引用生成秘密密钥。攻击者在一天内猜出了所有这些账户的密码短语，而“叫我以实玛利”这个密码短语只持续了0.67秒。######
    **受损的记忆密钥**
- en: For those wishing to memorize their blockchain private keys, mnemonic keys or
    seed phrases offer a more secure alternative to password-based keys. A mnemonic
    key is a set of 12 to 24 words pulled from a standard wordlist. Each word encodes
    11 bits of randomness from the original key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望记忆他们区块链私钥的人来说，记忆密钥或种子短语比基于密码的密钥提供了更安全的选择。记忆密钥是一组从标准词表中选取的12到24个单词。每个单词编码了原始密钥的11位随机性。
- en: 'Mnemonic keys make private keys easier to memorize, but they also need to be
    properly protected, and even a partially compromised mnemonic key can leave a
    blockchain account open to attack. In 2020, Alistair Milne released 8 of 12 words
    of a mnemonic key one at a time, intending to release the last three or four at
    once to prevent brute-force attacks.[⁴](#c02-note-0004) John Cantrell wrote a
    custom script that tried over 1 trillion possibilities in 30 hours to claim the
    1 BTC in the account.[⁵](#c02-note-0005)  ##### Weak Key Security'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '助记词钥匙使得私钥更易于记忆，但它们也需要得到适当的保护，而即使是一个部分受损的助记词钥匙也可能使区块链账户面临攻击。2020年，Alistair Milne分两次发布了12个助记词中的8个，意图一次性发布最后三个或四个以防止暴力攻击。[⁴](#c02-note-0004)
    John Cantrell编写了一个自定义脚本，在30小时内尝试了超过1万亿种可能性以领取账户中的1 BTC。[⁵](#c02-note-0005)  #####
    弱键安全性'
- en: After generating a private key, a blockchain user needs to preserve the secrecy
    of that key for the lifetime of the account. If an unauthorized party gains access
    to that key, they can generate transactions on the users' behalf and steal cryptocurrency
    from them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成私钥之后，区块链用户需要保护该密钥的秘密，直至账户生命周期结束。如果未经授权的方获得了该密钥，他们可以代表用户生成交易，并从他们那里窃取加密货币。
- en: '###### *Vulnerable Storage*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 脆弱的存储'
- en: Insecure storage of secret data has been a problem for far longer than blockchain
    has existed. Passwords written on sticky notes under a keyboard or saved in text
    documents on a computer have been a security challenge for decades.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的秘密数据存储问题是区块链存在的问题之一。将密码写在键盘下的便签纸上，或保存在电脑上的文本文件中，数十年来一直是安全挑战。
- en: With the introduction of blockchain technology, it should come as no surprise
    that private keys are regularly stored in locations where they can be easily stolen
    or lost forever. Countless blockchain accounts have been compromised by poor key
    management, and an estimated 30 percent of Bitcoin is lost forever due to lost
    private keys.[⁶](#c02-note-0006)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着区块链技术的引入，私钥经常被存储在容易被盗或永远丢失的位置，这并不令人意外。无数的区块链账户因密钥管理不当而被攻破，估计有30%的比特币因丢失私钥而永远丢失。[⁶](#c02-note-0006)
- en: 'Hardware wallets offer a potential solution by storing private keys on a device
    that uses a dedicated microprocessor to store keys and generate digital signatures
    so that the keys never leave the device. However, even hardware wallets can have
    security vulnerabilities. Dozens of vulnerabilities have been discovered in hardware
    wallets that can cause them to expose private keys or otherwise misbehave.[⁷](#c02-note-0007)  ######
    *Cryptocurrency Wallets and Exchanges*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '硬件钱包通过在设备上存储私钥并提供专用微处理器来生成数字签名，从而使密钥从不离开设备，为私钥提供了一种潜在的解决方案。然而，即使是硬件钱包也可能存在安全漏洞。已经发现了数十个硬件钱包漏洞，可能导致它们暴露私钥或其他不良行为。[⁷](#c02-note-0007)  ######
    加密货币钱包与交易所'
- en: Many blockchain users don't want to manage their own private keys. Instead,
    they use a third-party service to store these keys. Common examples include cryptocurrency
    wallet services and exchanges.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多区块链用户不想管理自己的私钥。相反，他们使用第三方服务来存储这些密钥。常见例子包括加密货币钱包服务和交易所。
- en: With these wallets and exchanges, the security model for user accounts changes.
    Instead of having to guess a user's secret key, which should be a large random
    value, an attacker only needs to learn the user's password for the key management
    service and potentially defeat multifactor authentication (MFA).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些钱包和交易所，用户账户的安全模型发生了变化。攻击者不需要猜测应该是一个大随机值的用户的秘密密钥，而只需要了解用户密钥管理服务的密码，并可能击败多因素认证（MFA）。
- en: 'This is a much easier problem for an attacker to solve. The following list
    includes some common approaches:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这对攻击者来说是一个更容易解决的问题。以下是一些常见的方法：
- en: '**Password Guessing:** Many people have weak and reused passwords. This makes
    it trivial for an attacker to gain access to an account via brute-force password
    guessing or credential stuffing attacks.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码猜测：**许多人使用弱密码且密码重复使用。这使得攻击者通过暴力破解密码猜测或凭据填充攻击轻易地访问账户变得简单。'
- en: '**Phishing:** Phishing attacks are a common way to steal passwords and MFA
    codes or deliver malware to target computers. In 2021, a phishing attack infected
    the computer of a bZx developer with malware that stole private keys, allowing
    tokens worth $55 million at the time to be stolen from the project and its users.[⁸](#c02-note-0008)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络钓鱼：** 网络钓鱼攻击是窃取密码和MFA代码或向目标电脑传递恶意软件的常见方式。2021年，一场网络钓鱼攻击感染了bZx开发人员的电脑，窃取了私钥，使当时价值5500万美元的代币从项目和其用户中被盗。[⁸](#c02-note-0008)'
- en: '**SIM Swapping:** Many online services use SMS messages for MFA, so a SIM swapping
    attacker can gain access to these codes. In 2021, European law enforcement arrested
    eight individuals for involvement in a $100 million SIM swapping attack.[⁹](#c02-note-0009)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIM交换：** 许多在线服务使用短信进行MFA，因此SIM交换攻击者可以获取这些代码。2021年，欧洲执法部门逮捕了8名参与1亿美元SIM交换攻击的嫌疑人。[⁹](#c02-note-0009)'
- en: '**Malware:** Some attacks on private keys are designed to replace legitimate
    software with malware that steals private keys or modifies transactions performed
    by the user. In April 2021, the EasyFi DeFi protocol lost over $46 million in
    tokens in a hack that used a malicious version of MetaMask to steal private keys.[^(10)](#c02-note-0010)  ######
    *Malware*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意软件：** 一些针对私钥的攻击旨在用恶意软件替换合法软件，该软件会窃取私钥或修改用户执行的交易。2021年4月，EasyFi DeFi协议在一场使用恶意版本的MetaMask窃取私钥的黑客攻击中失去了超过4600万美元的代币。[^(10)](#c02-note-0010)  ######
    恶意软件'
- en: Blockchain technology is implemented as software. When users want to interact
    with a blockchain, they need to use their computers. This can mean typing private
    keys or mnemonic phrases into blockchain software for use in signing a transaction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术是以软件形式实现的。当用户想要与区块链互动时，他们需要使用电脑。这意味着要将私钥或助记词输入到区块链软件中，用于签署交易。
- en: If a private key or mnemonic seed is entered into a computer, then it's potentially
    vulnerable to malware. Some malware, such as the Clippy Malware, is designed to
    scan the contents of the system clipboard or a computer's memory for data that
    resembles a private key or a blockchain address.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果私钥或助记词种子被输入到电脑中，那么它可能容易受到恶意软件的攻击。一些恶意软件，如Clippy Malware，被设计为扫描系统剪贴板或计算机内存中的任何类似于私钥或区块链地址的数据。
- en: 'One such malware campaign was designed to redirect transactions performed by
    users of compromised machines. This malware monitored the clipboards of infected
    machines for data that matched any of 2.3 million Bitcoin addresses.[^(11)](#c02-note-0011)
    If it found a match, it would replace the address with the attacker''s address.
    Unless the user double-checked the address after pasting, the transaction would
    be sent to the attacker rather than its intended recipient.  ##### Algorithmic
    Security'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '其中一个恶意软件活动旨在重定向被感染机器上用户的交易。这种恶意软件监控感染机器的剪贴板，寻找与230万个比特币地址匹配的数据。[^(11)](#c02-note-0011)
    一旦找到匹配项，它就会将地址替换为攻击者的地址。除非用户在粘贴后再次检查地址，否则交易将被发送给攻击者，而不是预期的接收者。  ##### 算法安全'
- en: While compromised private keys are the most common way for public key cryptography
    to be attacked, the algorithms themselves may also be insecure. However, no known
    attacks exist that could allow the asymmetric encryption algorithms used in blockchain
    to be broken on modern technology.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然被泄露的私钥是公钥加密被攻击的最常见方式，但算法本身也可能存在安全漏洞。然而，目前还没有已知的攻击能够允许在现代技术上破解区块链所使用的非对称加密算法。
- en: This is only true until large-scale quantum computing becomes available. Once
    this is the case, Shor's algorithm will force a transition to post-quantum encryption
    algorithms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在大规模量子计算变得可用之前才是真的。一旦这种情况出现，Shor算法将迫使转向后量子加密算法。
- en: '###### *Shor''s Algorithm*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 鲨鱼算法'
- en: Many public key cryptography algorithms are based upon the “hard” problems of
    factoring the product of two large prime numbers or calculating a logarithm within
    a modulus. Using modern computers, the best way to solve these problems is through
    a brute-force search, which scales exponentially in difficulty with the length
    of the secret values used. Since the difficulty of legitimate operations only
    scales polynomially, it's possible to choose a key length that makes the system
    usable for a legitimate user but infeasible to attack.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公钥加密算法都是基于两个大素数乘积的因式分解问题或计算模数内的对数的“难”问题。利用现代计算机，解决这些问题的最佳方式是通过暴力搜索，随着所使用密钥值的增加，难度会呈指数级增长。由于合法操作的难度仅呈多项式增长，因此可以选取一个密钥长度，使得该系统对合法用户可用，但对攻击者来说却难以实施。
- en: Shor's algorithm is an algorithm written for quantum computers that solves these
    problems in a way that's more efficient than a brute-force search. With Shor's
    algorithm, the complexity of attacking classical public key cryptography changes
    from exponential to polynomial, just like the cost of legitimate operations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 肖尔算法是为量子计算机编写的算法，比暴力搜索更有效地解决这些问题。使用肖尔算法，攻击经典公钥加密算法的复杂性从指数级降低到多项式级，与合法操作的成本相同。
- en: 'This makes it impossible to use classical public key cryptography in a scheme
    that is secure against quantum computers. Even if the complexity of the “hard”
    operation grows several times faster than the “easy” one, an attacker can feasibly
    keep up by throwing more money at the problem. It doesn''t matter if factoring
    is five times harder than multiplication if an eavesdropper has one hundred computers
    to your one.  ###### *Post-Quantum Cryptography*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在对抗量子计算机的方案中无法使用经典公钥加密。即使“难”操作的复杂性比“易”操作增长几倍，攻击者也可以通过增加投入来可行地跟上。如果因式分解比乘法难五倍，而窃听者拥有一百台计算机与你的一台相比，那么这一点就无关紧要了。######
    后量子加密
- en: 'Shor''s algorithm is a problem for classical asymmetric encryption algorithms
    because it breaks the asymmetry of the “hard” problems that these algorithms are
    based upon. If both multiplication and factoring have polynomial complexity, then
    it is infeasible to develop a system that is both usable and secure. Even if the
    complexity of factoring grows 100x faster than that of multiplication, an attacker
    can break it by spending 100x more than a legitimate user.  ### Hash Functions'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '肖尔算法对古典非对称加密算法构成问题，因为它打破了这些算法所基于的“难”问题的非对称性。如果乘法和因式分解都具有多项式复杂性，那么开发既可用又安全的系统是不切实际的。即使因式分解的复杂性比乘法增长100倍，攻击者也可以通过投入合法用户100倍的成本来攻破它。  ###
    哈希函数'
- en: Hash functions are at the core of blockchain technology. The main function of
    a hash function is to ensure the integrity of data. This is possible because hash
    functions are one-way, collision-resistant functions, meaning that it is infeasible
    to determine the input that produced a given output or find two inputs that produce
    the same output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是区块链技术的核心。哈希函数的主要作用是确保数据完整性。这是因为哈希函数是一种单向、抗冲突的函数，意味着确定产生给定输出的输入或找到产生相同输出的两个输入是不切实际的。
- en: Providing the hash of a piece of data along with the data itself is a common
    way of ensuring the integrity of the data. File checksums use hash functions to
    ensure that the file has not been modified after creation (since finding another
    version of the data that produces the same hash is extremely unlikely). Computers
    store the hashed versions of passwords to maintain the confidentiality of the
    passwords since it's impossible to determine the original password from the hash
    and comparing the hash of a password to a stored hash is almost as secure as comparing
    the true passwords.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提供数据的哈希值与数据本身一起是确保数据完整性的常见方法。文件校验和利用哈希函数确保文件在创建后没有被修改（因为找到另一个产生相同哈希值的版本的数据的概率极低）。计算机存储密码的哈希值以保持密码的保密性，因为从哈希值确定原始密码是不可能的，将密码的哈希值与存储的哈希值进行比较与比较真实密码一样安全。
- en: In blockchain (and other distributed ledger implementations), hash functions
    are commonly used to ensure the integrity of the data stored within the distributed
    ledger. Each block in a blockchain contains the hash of the previous block and
    a hash summarizing the transaction data stored within the block. As long as the
    hash function remains secure, the data in the distributed ledger cannot be modified
    without the modifications being detected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链（以及其他分布式账本实现）中，散列函数通常用于确保分布式账本中存储的数据的完整性。区块链中的每个区块包含前一个区块的散列和总结存储在区块中的交易数据的散列。只要散列函数保持安全，分布式账本中的数据就不能被修改，而不会被检测到修改。
- en: '#### *Security Assumptions of Hash Functions*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *散列函数的安全假设*'
- en: 'The security of hash functions is a major assumption of distributed ledger
    technology. Hash functions protect the integrity of the data stored within the
    distributed ledger and must have two important properties: preimage resistance
    and collision resistance.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 散列函数的安全性是分布式账本技术的主要假设。散列函数保护分布式账本中存储的数据的完整性，并必须具有两个重要属性：前像抵抗和碰撞抵抗。
- en: '##### Preimage Resistance'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 前像抵抗'
- en: A preimage of a hash function is an input that produces a desired output. Hash
    functions must be preimage-resistant, meaning that, for a given output, it should
    be infeasible for someone to find an input that produces that output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 散列函数的前像是一个产生所需输出的输入。散列函数必须具有前像抵抗性，这意味着对于给定的输出，对于某人来说找到一个产生该输出的输入应该是不可行的。
- en: Preimage resistance is achieved by using a one-way function in a cryptographic
    hash function. One-way functions discard some information during their computations
    so that it is impossible to uniquely map an output to the input used to create
    it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前像抵抗是通过在密码散列函数中使用单向函数来实现的。单向函数在计算过程中丢弃一些信息，这样就无法唯一地将一个输出映射到创建它的输入。
- en: An example of a simple one-way function is the modulo operation, where the input
    is divided by the modulus and only the remainder of the division is retained.
    With an output of 5 modulo 10, the possible inputs are 5, 15, 25, and so on. Without
    additional knowledge, it is impossible to determine which of the possible inputs
    was used to create the output of 5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的单向函数的例子是模运算，其中输入除以模数，只保留除法的余数。当模运算的输出为5除以10时，可能的输入是5、15、25等等。没有额外知识，无法确定哪个可能的输入被用来创建输出5。
- en: 'Hash functions have an infinite space of potential inputs and a finite space
    of potential outputs because they can take any input and produce a fixed-size
    output. This means that hash functions map an infinite number of inputs to each
    potential output, making them inherently preimage-resistant.  ##### Collision
    Resistance'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '散列函数具有潜在输入的无限空间和潜在输出的有限空间，因为它们可以接受任何输入并产生固定大小的输出。这意味着散列函数将无限多个输入映射到每个潜在的输出，使其本质上具有前像抵抗性。  #####
    碰撞抵抗'
- en: 'The other important principle of hash functions for distributed ledger security
    is collision resistance. A hash function collision is when two inputs to the hash
    function can be found that produce the same output. There are two levels of collision
    resistance that a cryptographic hash function must have: weak collision resistance
    and strong collision resistance.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式账本安全的散列函数的另一个重要原则是碰撞抵抗。散列函数的碰撞是指可以找到两个输入，它们产生的输出相同。加密散列函数必须具有两个级别的碰撞抵抗：弱碰撞抵抗和强碰撞抵抗。
- en: 'A hash function is weakly collision-resistant if, given an input *`m`*[1],
    it is difficult to find another input, *`m`*[2], that maps to the same output.
    Strong collision resistance means that it is difficult to find any pair of inputs
    that map to the same output. A cryptographic hash function used in distributed
    ledger technology needs to be both weakly and strongly collision-resistant.  ####
    *Additional Security Requirements*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '如果给定一个输入`m`[1]，散列函数是弱碰撞抵抗的，那么很难找到另一个输入`m`[2]，它映射到相同的输出。强碰撞抵抗意味着很难找到任何一对输入映射到相同的输出。在分布式账本技术中使用的加密散列函数需要同时具有弱和强的碰撞抵抗性。  ####
    *额外的安全要求*'
- en: While preimage resistance and collision resistance are the only requirements
    necessary for security, a hash function must have certain other properties to
    achieve these requirements. A cryptographic hash function must have a large state
    space and be a nonlocal function to protect it against successful brute-force
    attacks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像抵抗和冲突抵抗是安全所必需的仅有要求的同时，哈希函数必须具备某些其他属性才能实现这些要求。密码学哈希函数必须具备大的状态空间和非局部性函数，以保护它免受成功的暴力攻击。
- en: '##### Large State Space'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 大状态空间'
- en: If a hash function is well-designed, the best way of finding a collision is
    searching through the set of possible inputs and looking for one that produces
    the desired output. In order to make this type of attack infeasible, the hash
    function needs to be designed so that it is unlikely that an attacker will successfully
    complete this search within a reasonable length of time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个哈希函数设计得当，寻找冲突的最佳方法是搜索可能的输入集合，寻找一个能产生所需输出的输入。为了使这种攻击不可行，哈希函数需要设计得足够好，使得攻击者不太可能在合理的时间内完成这个搜索。
- en: The size of the space that needs to be searched to find a collision is determined
    by the size of the output of the hash function. By the pigeonhole principle, an
    attacker needs to test a set of inputs equal to the number of possible outputs
    in order to be certain of finding a collision. A strong cryptographic hash function
    will have a large enough output that attempting to search it using modern technology
    will take either too much time or too many resources to be feasible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要搜索的状态空间大小由哈希函数的输出大小决定。根据鸽巢原理，攻击者需要测试一个等于可能的输出数量的输入集合，才能确信找到一个冲突。一个强大的密码学哈希函数将具有足够大的输出，以至于使用现代技术试图搜索它将花费太多时间或太多资源，从而变得不可行。
- en: 'Several blockchains use the Keccak-256 hash function (a variant of the SHA-256
    hash function). As its name suggests, this hash function has a 256-bit output,
    meaning that there are 2^(256) possible values of this output. For comparison,
    the known universe contains fewer than 2^(272) atoms,[^(12)](#c02-note-0012) so
    a hard drive made using all of these atoms would still be too small to store the
    complete set of options (modern hard drives use about 1 million atoms per bit[^(13)](#c02-note-0013)).
    While an attacker may get lucky and find a solution on their first try, the only
    way to be certain is to search the complete space of 2^(256) options.  ##### Nonlocal
    Function'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '有几个区块链使用Keccak-256哈希函数（SHA-256哈希函数的一种变体）。正如它的名字所说的，这个哈希函数有一个256位的输出，意味着有2^(256)种可能的输出值。作为比较，已知的宇宙包含的的原子数少于2^(272)，[^(12)](#c02-note-0012)所以即使使用所有这些原子制成的硬盘仍然太小，无法存储完整的选项集合（现代硬盘大约使用100万原子每个比特[^(13)](#c02-note-0013))。尽管攻击者可能运气好，一次尝试就找到解决方案，但确信的唯一方法是搜索2^(256)个选项的完整空间。  #####
    非局部函数'
- en: The other important property that a hash function needs for collision resistance
    is nonlocality. In a cryptographic hash function, two very similar inputs produce
    very dissimilar outputs. On average, hashing two inputs that differ by a single
    bit will produce outputs that differ in half of their bits.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数为了抵抗冲突还需要另一个重要的属性，那就是非局部性。在密码学哈希函数中，两个非常相似的输入会产生非常不相似的输出。平均而言，对两个仅有一个比特不同的输入进行哈希，将会有半数的比特不同。
- en: 'The nonlocality of the hash function is important to collision resistance because
    it protects against hill-climbing attacks. In a hill-climbing attack, an attacker
    takes the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的非局部性对于冲突抵抗很重要，因为它能抵御山丘攀爬攻击。在山丘攀爬攻击中，攻击者采取以下步骤：
- en: Select an input.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个输入。
- en: Hash the input.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输入进行哈希。
- en: Flip one bit of the input.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变输入的一位。
- en: Hash the new input.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对新的输入进行哈希。
- en: Compare the new input's hash with the current one's hash.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新输入的哈希值与当前哈希值进行比较。
- en: If the new hash is closer to the target, retain the change and go to step 3.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新的哈希值更接近目标，保留这个变化，回到步骤3。
- en: If the new hash is further from the target, discard the change and go to step
    3.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新的哈希值离目标更远，丢弃这个变化，回到步骤3。
- en: A hill-climbing attack takes advantage of the locality of a function by making
    small changes and evaluating whether the change is positive or negative. By retaining
    positive changes and discarding negative ones, the attacker incrementally moves
    toward their goal (a collision).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 山丘攀爬攻击利用函数的局部性，通过做出小的改变并评估改变是正还是负。通过保留正的变化并丢弃负的变化，攻击者逐步接近他们的目标（一个冲突）。
- en: 'Cryptographic hash functions are protected against this type of attack because
    it is impossible to evaluate whether a change is positive or negative. Since small
    changes to hash function inputs produce large, unpredictable changes to outputs,
    it''s impossible to determine if the attacker is moving toward or away from an
    input that would produce a collision.  #### *How the Blockchain Uses Hash Functions*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '密码学散列函数之所以能抵御这种攻击，是因为无法评估变化是正面还是负面。由于对散列函数输入的小变化会产生输出的大规模、不可预测的变化，因此无法确定攻击者是朝着产生冲突的输入移动还是远离它。  ####
    *区块链如何使用散列函数*'
- en: The integrity protections offered by hash functions are crucial to blockchain
    technology. Three major places where hash functions appear on the blockchain are
    the blocks' “chains,” their Merkle trees, and within digital signatures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术中，散列函数提供的完整性保护至关重要。在区块链上，散列函数主要出现在区块的“链”、Merkle树以及数字签名中。
- en: '##### The Blocks'' “Chains”'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 区块的“链”'
- en: The blockchain gets its name from the fact that it is a set of blocks chained
    together. The “chains” in blockchain are hash functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链之所以得名，是因为它是由链接在一起的区块集合。区块链中的“链”是指散列函数。
- en: Inside the header of each block in the blockchain is the hash of the previous
    block header. This both links the blockchain together, providing a clear ordering,
    and makes it more difficult to forge blocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中每个区块的头部都包含前一个区块头部的散列值。这不仅使区块链连接在一起，提供清晰的排序，而且还使伪造区块变得更加困难。
- en: Without these previous block hashes, modifying a past transaction in the distributed
    ledger would only require finding an alternative, valid version of the block that
    contains it. While the definition of a valid block depends on the consensus algorithm
    used by the blockchain, block creators regularly create new blocks, so it can't
    be too hard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些前一个区块的散列值，在分布式账本中修改过去的交易只需要找到一个包含它的替代、有效区块版本。虽然有效区块的定义取决于区块链使用的共识算法，但区块创建者经常创建新区块，因此这并不困难。
- en: With the blocks' chains, the value of each block header depends on the previous
    one. A change to one block header changes the previous block hash in the next,
    which changes the previous block hash in the next, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块的“链”中，每个区块头的值取决于前一个。对一个区块头的更改会在下一个更改前一个区块的散列值，以此类推。
- en: These cascading changes mean that changing a single transaction in the blockchain
    requires finding an alternative version of both the block that contains it and
    every following block. Blockchain consensus algorithms are designed to make this
    much more difficult than faking a single block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些级联变化意味着在区块链中更改单个交易需要找到包含它的区块及其后续所有区块的替代版本。区块链共识算法旨在使这比伪造一个单独的区块困难得多。
- en: 'The only way to get around these cascading changes is if an attacker can find
    an alternative version of a block that doesn''t change the previous block hash
    value in the next block. This is the definition of a hash collision: two hash
    inputs that produce the same output. If the blockchain is using a secure, collision-resistant
    hash function, this is infeasible.  ##### Merkle Trees'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '要绕过这些级联变化，攻击者必须找到一个不会在下一个区块中更改前一个区块散列值的区块的替代版本。这就是散列冲突的定义：两个产生相同输出的散列输入。如果区块链使用的是安全的、抗冲突的散列函数，这是不可能的。  #####
    Merkle树'
- en: The transactions contained within a block are stored in the block's body, not
    its header. This means that they are not included as an input to the hash function
    that implements the blocks' chains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 区块内的交易存储在区块的体中，而不是头部。这意味着它们不包括在实现区块“链”的散列函数的输入中。
- en: The immutability of blockchain transactions is protected by a Merkle tree. A
    Merkle tree is a binary tree whose internal nodes contain the hashes of their
    children.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链交易的不可变性由Merkle树保护。Merkle树是一种二叉树，其内部节点包含其子节点的散列值。
- en: An example of a Merkle tree is shown in [Figure 2.1](#c02-fig-0001). The transactions
    contained within a block are shown at the bottom of the tree. Each leaf node of
    the tree contains the hash of the transaction below it, and all other nodes contain
    the hashes of their children's values concatenated together.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Merkle树的例子显示在[图2.1](#c02-fig-0001)中。区块内的交易显示在树的底部。树的每个叶节点包含其下方交易的散列值，所有其他节点包含其子节点值连接起来的散列。
- en: One of the major advantages of a Merkle tree is that it allows transaction data
    to be securely summarized by the root hash of the Merkle tree. Due to hash function
    collision resistance, it is infeasible to find two versions of the Merkle tree
    that produce the same root hash. By including just the root hash of the Merkle
    tree within the block header, a blockchain ensures that all transactions contained
    by it are protected from modification by the blocks' chains.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树的一个主要优点是，它允许通过Merkle树的根哈希来安全地总结交易数据。由于哈希函数抗碰撞的特性，找到两个产生相同根哈希的Merkle树版本是不切实际的。通过在区块头中只包含Merkle树的根哈希，区块链确保包含在其中的所有交易都受到区块链的保护，防止被修改。
- en: '![Schematic illustration of an example of a Merkle tree.](images/c02f001.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Merkle树的示例示意图](images/c02f001.png)'
- en: '[**Figure 2.1**](#R_c02-fig-0001): Example of a Merkle tree'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图2.1**](#R_c02-fig-0001)：Merkle树的示例'
- en: 'Merkle trees also make it possible to prove that a transaction is contained
    within a Merkle tree or a given block without revealing any of the other transactions
    in that block. For example, proving the presence of Transaction 0 in the Merkle
    tree in [Figure 2.1](#c02-fig-0001) to someone who has access to the block header
    only requires revealing the following values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树还使得能够证明一个交易包含在Merkle树中或给定区块内，而不揭示该区块中其他任何交易的信息。例如，向仅拥有区块头的某人证明Transaction
    0包含在[图2.1](#c02-fig-0001)中的Merkle树中，只需揭示以下值：
- en: Transaction 0
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Transaction 0
- en: Hash 1
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hash 1
- en: Hash 2-3
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hash 2-3
- en: From the value of Transaction 0, it's possible to calculate Hash 0\. By combining
    Hash 0 and Hash 1, the user could calculate Hash 0-1\. With Hash 0-1 and Hash
    2-3, the user can calculate the value of Tx Root and compare it to the value of
    Tx Root in the block header.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从Transaction 0的值可以计算出Hash 0。通过将Hash 0和Hash 1结合，用户可以计算出Hash 0-1。有了Hash 0-1和Hash
    2-3，用户可以计算出Tx Root的值，并与区块头中的Tx Root值进行比较。
- en: 'These proofs are commonly used by Simplified Payment Verification (SPV) nodes
    to verify the inclusion of a transaction within a block without downloading the
    entire block body. These SPV nodes track the block headers and their connecting
    chains but verify transactions by requesting these proofs.  ##### Digital Signatures'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些证明通常被简化支付验证（SPV）节点用于验证一个交易是否包含在一个区块内，而无需下载整个区块体。这些SPV节点追踪区块头和它们连接的链，但通过请求这些证明来验证交易。#####
    数字签名
- en: The discussion of digital signatures in the context of public key cryptography
    left out one crucial component. The data actually “encrypted” by the private key
    and “decrypted” by the public key is the hash of the message, not the message
    itself.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论公钥密码学中的数字签名时，遗漏了一个关键组成部分。实际上由私钥“加密”并由公钥“解密”的数据是消息的哈希，而不是消息本身。
- en: 'The use of hash functions helps to shrink the size of the digital signature
    by securely compressing it into a fixed-size value. Due to the hash function collision
    resistance, it is infeasible to find another message that would produce the same
    hash output and not invalidate the digital signature. As a result, hashing the
    message and comparing hashes is nearly as secure as comparing the messages themselves.  ####
    *Attacking Hash Functions*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '哈希函数的使用有助于缩小数字签名的尺寸，通过安全地将其压缩到一个固定大小的值中。由于哈希函数抗碰撞的特性，找到另一个会产生相同哈希输出的消息并无效化数字签名是不切实际的。因此，对消息进行哈希处理并比较哈希值在安全性上几乎与直接比较消息本身一样。  ####
    *攻击哈希函数*'
- en: If a hash function is secure and collision-resistant, the only means of finding
    a hash collision is via a brute-force attack. With quantum computing, Grover's
    algorithm makes this attack easier to perform; however, it doesn't break hash
    function security.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个哈希函数是安全的且抗碰撞的，找到哈希冲突的唯一方法就是通过暴力攻击。随着量子计算的发展，Grover算法使得这种攻击更容易实施；然而，它并没有破坏哈希函数的安全性。
- en: '##### Brute Force'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 暴力攻击'
- en: Hash functions are designed to be collision-resistant, meaning that it is infeasible
    to find two inputs to the hash function that produce the same output. However,
    the pigeonhole principle states that it's possible to break collision resistance
    if you try hard enough.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数被设计成抗碰撞的，意味着找到两个输入值使得它们产生相同的输出是不切实际的。然而，鸽巢原理表明，如果你尝试得足够努力，是可以破坏碰撞抵抗的。
- en: A brute-force attack on a secure hash function is infeasible as long as the
    hash function has no exploitable vulnerabilities. A well-designed hash function
    that is a one-way, nonlocal function with a large state space is infeasible to
    attack.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只要哈希函数没有可利用的漏洞，对其进行暴力攻击就是不可行的。一个设计良好的哈希函数，如果是一个单向的、非局部的函数，并且状态空间很大，那么对它进行攻击就是不可行的。
- en: The Lisk blockchain provides an example of what can happen if a hash function
    does not fulfill all of these properties. In Lisk, account addresses were calculated
    by hashing a public key and truncating the result to a 64-byte address.[^(14)](#c02-note-0014)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Lisk区块链提供了一个例子，说明如果一个哈希函数不满足所有这些属性会发生什么。在Lisk中，账户地址是通过哈希一个公钥并将结果截断到64字节地址计算得出的。[^(14)](#c02-note-0014)
- en: With only 2^(64) potential addresses, a brute-force attack against this blockchain
    is entirely possible. At the time of writing, the Bitcoin network had a hash rate
    of over 2^(67) hashes per second, meaning that it could find multiple potential
    private keys for each address every second.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链只有2^(64)个潜在的地址，对其进行暴力攻击是完全可能的。在撰写本文时，比特币网络的哈希率超过了2^(67)次每秒，这意味着它每秒钟可以找到每个地址的多个潜在私钥。
- en: Lisk only tied a public key to an address when it created a transaction or voted
    for a delegate. This meant that accounts containing cryptocurrency could have
    that cryptocurrency extracted by the first person to find a valid private key
    for it. One of these vulnerable accounts contained over $48 million at the time
    of the vulnerability's discovery.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在创建交易或为代表投票时，Lisk才会将公钥与地址关联。这意味着包含加密货币的账户可能被第一个找到其有效私钥的人提取加密货币。在发现漏洞时，其中一个易受攻击的账户包含了超过4800万美元。
- en: 'This vulnerability was discovered by an ethical hacker and reported to the
    Lisk developers, who issued a warning to users to generate a transaction that
    secured their accounts. However, due to the nature of the vulnerability, it''s
    impossible to determine if the user who did so for an account was the legitimate
    owner of any cryptocurrency that it contained.  ##### Grover''s Algorithm'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这位道德黑客发现了这个漏洞，并报告给了Lisk开发者，开发者警告用户生成一个保护其账户的交易。然而，由于漏洞的性质，无法确定是否生成交易的账户所有者是该账户包含的任何加密货币的合法所有者。#####
    格拉夫算法
- en: Like Shor's algorithm, Grover's algorithm is designed to run on a quantum computer
    that threatens the security of distributed ledgers using classical cryptography.
    Unlike Shor's algorithm, Grover's algorithm threatens the security of modern hash
    functions but does not completely break them the way that Shor's algorithm breaks
    classical public key cryptography.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与肖尔算法类似，格拉夫算法也是为在量子计算机上运行而设计的，这种计算机使用经典密码学威胁分布式账本的安全。与肖尔算法不同的是，格拉夫算法威胁现代哈希函数的安全，但不像肖尔算法那样完全破解经典公钥密码学。
- en: On classical computers, the most efficient way to find a collision for a secure
    hash function is to search through a set of possible inputs equal to the size
    of the space of possible outputs. Hash functions are designed to make this infeasible
    by making the space of possible outputs too large to search efficiently.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算机上，寻找安全哈希函数的冲突的最有效方法是搜索一个等于可能输出空间大小的可能的输入集合。哈希函数通过使可能的输出空间太大而无法有效搜索来设计，从而使这变得不可行。
- en: Grover's algorithm makes the process of finding collisions more efficient for
    an attacker. On a classical computer, searching for a collision to a hash function
    with an N-bit output requires 2^N evaluations of the hash function. With Grover's
    algorithm and a quantum computer, this drops to `sqrt(2^N)` or `2^(N/2)` evaluations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 格拉夫算法使攻击者寻找冲突的过程更加高效。在经典计算机上，对一个N位输出的哈希函数寻找冲突需要2^N次哈希函数评估。使用格拉夫算法和量子计算机，这降低到2^(N/2)次评估，即`sqrt(2^N)`。
- en: 'However, Grover''s algorithm does not completely break the security of classical
    hash functions since the desired level of security can be achieved by doubling
    the size of the output. SHA-256 is theoretically as equally secure against a quantum
    computer as SHA-128 is against a classical one. As quantum computers become more
    common, new hash functions will need to be developed with output lengths sufficient
    to protect against attacks using Grover''s algorithm.  ### Threat Modeling for
    Cryptographic Algorithms'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，Grover算法并没有完全破解古典哈希函数的安全性，因为通过将输出大小加倍可以达到所需的安全级别。SHA-256理论上与SHA-128对抗量子计算机一样安全。随着量子计算机变得更加普及，需要开发新的哈希函数，其输出长度足够长以保护免受使用Grover算法的攻击。  ###
    针对密码算法的安全威胁建模'
- en: 'Attacks against the public key cryptography and hash functions used in blockchain
    technology can have impacts on several areas of the STRIDE threat model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 针对区块链技术中使用的公钥密码学和哈希函数的攻击可能会对STRIDE威胁模型中的多个领域产生影响：
- en: '**Spoofing:** Compromised private keys enable an attacker to masquerade as
    a user and generate blockchain transactions on their behalf.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪装攻击:** 被破解的私钥让攻击者能够伪装成用户，代表他们生成区块链交易。'
- en: '**Tampering:** A hash function collision in the blocks'' chains, a Merkle tree,
    or digital signature can break the immutability of the distributed ledger.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改:** 区块链中的块链、Merkle树或数字签名中的哈希函数冲突可以破坏分布式账本的不可变性。'
- en: '**Information Disclosure:** A compromised private key could allow decryption
    of messages intended for the owner of a blockchain account.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息披露:** 被破解的私钥可能允许解密旨在发送给区块链账户所有者的消息。'
- en: '**Elevation of Privileges:** A compromised private key provides unauthorized
    access to a user''s blockchain account.  ## Data Structures'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升:** 被破解的私钥提供了对用户区块链账户的未授权访问。  ## 数据结构'
- en: The primary function of the blockchain is data storage. The blockchain network
    cooperates to maintain a distributed, immutable digital ledger that tracks the
    history of the blockchain network.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的主要功能是数据存储。区块链网络协作维护一个分布式、不可变的数字账本，跟踪区块链网络的历史。
- en: Under the hood, a blockchain may use a variety of different data structures
    to store information about the state of the network. However, the two most important
    data structures in blockchain are the transaction and the block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，区块链可能会使用多种不同的数据结构来存储有关网络状态的信息。然而，在区块链中最重要的两种数据结构是交易和区块。
- en: '### Transactions'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '### 交易'
- en: The transaction is the basic unit of data on the blockchain's digital ledger.
    When a blockchain user wants to transfer value or interact with a smart contract,
    they create a transaction and broadcast it to the blockchain network.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是区块链数字账本的基本数据单位。当区块链用户想要转移价值或与智能合约互动时，他们会创建一个交易并将其广播到区块链网络。
- en: '#### *What''s In a Transaction?*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#### **交易中包含什么？**'
- en: 'Different blockchains may have slightly different transaction formats; however,
    many of the core fields are the same. In Bitcoin, a transaction contains the following
    seven fields:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的区块链可能具有略有不同的交易格式；然而，许多核心字段是相同的。在比特币中，交易包含以下七个字段：
- en: '**Version:** The version of the transaction.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本:** 交易的版本。'
- en: '**Witness Marker:** Indicates that the transaction uses Segregated Witness.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**见证标记:** 表示交易使用了隔离见证。'
- en: '**Flags:** Flags are used for parsing if the witness marker is present.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志:** 用于解析是否包含见证人标记的标志。'
- en: '**Inputs:** An array of inputs to the transaction.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入:** 交易的输入数组。'
- en: '**Outputs:** An array of outputs from the transaction.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出:** 交易的输出数组。'
- en: '**Witnesses:** An array of witnesses for the transaction.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**见证人:** 交易的见证人数组。'
- en: '**Lock Time:** The time for a time-locked transaction to remain locked.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁定时间:** 时间锁定交易的锁定时间。'
- en: As shown, a Bitcoin transaction can include multiple different transfers of
    value. If Segregated Witness is used, each input has its own corresponding witness,
    which contains the digital signature that authorizes the use of that input within
    the transaction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，比特币交易可以包括多个不同的价值转移。如果使用隔离见证，每个输入都有自己的对应见证，其中包含授权在该交易中使用该输入的数字签名。
- en: 'Unlike Bitcoin, Ethereum specifies a single intended recipient for a transaction,
    which is either an external address (i.e., a user account) or a smart contract
    address. Similar to Bitcoin, smart contracts can perform multiple actions within
    a single transaction, which are called *internal transactions*.  #### *Inside
    the Life Cycle of a Transaction*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币不同，以太坊为每笔交易指定了一个单一的预期接收者，这可以是外部地址（即用户账户）或智能合约地址。与比特币相似，智能合约可以在单个交易中执行多个动作，这些被称为*内部交易*。####
    *交易的生命周期内*
- en: Transactions are not immediately added to the blockchain's immutable digital
    ledger. Transactions are added to the blockchain as part of blocks, and several
    stages occur between their creation and inclusion in the ledger.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 交易不会立即添加到区块链不可变的数字账本中。交易作为区块的一部分被添加到区块链上，并在它们的创建和包含在账本之间发生几个阶段。
- en: After being created, a transaction is broadcast to other nodes via the blockchain's
    peer-to-peer network. Each node stores pending transactions in a mempool for inclusion
    in later blocks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，交易通过区块链的对等网络广播给其他节点。每个节点都将待处理的交易存储在内存池中，以包括在稍后的区块中。
- en: When it is time to create a new block, a block producer draws from this pool
    of available transactions. Before including a transaction in a potential block,
    the creator checks it to ensure that it is valid and that it doesn't conflict
    with any other transactions currently on the blockchain (a *double spend*).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成新区块的时候，区块生产者从这个可用交易池中提取。在将交易包含在潜在的区块之前，创建者检查它以确保它是有效的，并且它不会与区块链上当前的任何其他交易冲突（*双重支付*）。
- en: 'After a valid block is produced, the block creator transmits it to the rest
    of the blockchain network via the peer-to-peer network. Each of these nodes also
    validates the transactions within a block and, if they are valid, accepts the
    block. This involves adding the block to the digital ledger and performing state
    updates, such as determining the new allocation of cryptocurrency within the blockchain
    network or executing code on a smart contract platform.  #### *Attacking Transactions*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成有效的区块后，区块创建者通过对等网络将其传输给区块链网络的其余部分。这些节点也会验证区块内的交易，如果它们是有效的，就会接受该区块。这包括将区块添加到数字账本中并执行状态更新，例如确定区块链网络内加密货币的新分配或在一个智能合约平台上执行代码。####
    *攻击交易*
- en: Transactions are the basic building blocks of the blockchain and lie completely
    under the control of a blockchain user. Malicious transactions can be used in
    various attacks to exploit vulnerable blockchain nodes and other systems.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是区块链的基本构建块，完全受区块链用户的控制。恶意交易可能被用于各种攻击，以利用脆弱的区块链节点和其他系统。
- en: '##### Malformed or Invalid Transactions'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 格式错误或无效交易'
- en: As part of the process of creating blocks and updating the ledger, blockchain
    nodes must read and validate the contents of every transaction. This ensures that
    double-spend attacks and other invalid transactions are not included on the blockchain.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建区块和更新账本过程的一部分，区块链节点必须读取并验证每笔交易的內容。这确保了双重支付攻击和其他无效交易不会被包含在区块链上。
- en: Blockchain transactions are untrusted user input and may be intentionally malformed
    to exploit vulnerable nodes. If a vulnerable node processes an invalid transaction,
    it may crash or exhibit other undesirable behavior.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链交易是不可信的用户输入，可能被故意格式错误以利用脆弱的节点。如果一个脆弱的节点处理了一笔无效交易，它可能会崩溃或表现出其他不受欢迎的行为。
- en: '###### *Countermeasures*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'Exploitation of blockchain software with malformed transactions requires a
    vulnerability to exploit. Secure code development practices and code reviews are
    the best protection against this threat.  ###### *Case Study*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 利用格式错误的区块链软件进行攻击需要一个可利用的漏洞。安全的代码开发实践和代码审查是对这种威胁的最佳保护。###### *案例研究*
- en: Blockchain software is software, and all software has bugs. As a result, multiple
    vulnerabilities have been discovered in blockchain transaction validation code
    that have been or could have been exploited over the years.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链软件是软件，所有软件都有漏洞。因此，在区块链交易验证代码中已经发现或可能已经被利用多年的多个漏洞。
- en: One significant example was the 2010 Bitcoin hack, which created over 184 billion
    Bitcoin out of nothing.[^(15)](#c02-note-0015) This attack was enabled by an integer
    overflow vulnerability in the Bitcoin Core software. A malicious transaction performed
    two transfers that, when summed with some other values, overflowed to 50.51, which
    passed the transaction validation check.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的例子是2010年的比特币攻击，它创造了超过1840亿个比特币。[^(15)](#c02-note-0015) 这次攻击是利用了比特币核心软件中的整数溢出漏洞。恶意交易执行了两次转账，加上其他一些值后溢出到了50.51，通过了交易验证检查。
- en: 'However, the actual transfers were performed separately, which did not trigger
    the overflow and allowed a massive amount of Bitcoin to be transferred to the
    attacker''s account. This vulnerability was fixed soon afterward with a hard fork
    that patched the vulnerability and rolled back history to the block right before
    the attack.  ##### Transaction Malleability'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，实际的转账是分开执行的，这没有触发溢出，使大量比特币被转到了攻击者的账户。这个漏洞后来通过一个硬分叉得到了修复，该硬分叉修补了漏洞，并将历史回滚到了攻击前的那个区块。  #####
    交易可塑性'
- en: In the Bitcoin blockchain, transactions are uniquely identified by a transaction
    ID (txid). This txid is calculated by double-hashing the contents of a transaction.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币区块链上，交易通过交易ID（txid）唯一标识。这个txid是通过双重哈希交易的内容计算得出的。
- en: Transaction malleability attacks took advantage of the fact that the unlocking
    script for a transaction is included in the hash, and the format of the script
    was not always properly validated. This could allow an attacker to modify the
    unlock script of a pending transaction without invalidating it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 交易可塑性攻击利用了这样一个事实，即交易的解锁脚本包含在哈希中，而脚本的格式并不总是得到适当验证。这可能允许攻击者修改待处理交易的解锁脚本，而不使其无效。
- en: This modification would change the txid of that transaction. If the sender of
    the transaction only uses the txid to identify transactions on the blockchain,
    the recipient could use transaction malleability to claim that they never received
    a payment. This could cause the sender to repeat the transaction, paying the recipient
    twice.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改将改变那个交易的txid。如果交易发送者只使用txid在区块链上识别交易，接收者可以使用交易可塑性声称他们从未收到过付款。这可能导致发送者重复交易，向接收者支付两次。
- en: '###### *Countermeasures*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: Bitcoin addressed transaction malleability issues with Segregated Witness (SegWit),
    which moves witnesses out of transaction inputs. Since these digital signatures
    are no longer included in the txid calculation, this fixes the transaction malleability
    problem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币通过隔离见证（SegWit）解决了交易可塑性问题，它将见证从交易输入中移出。由于这些数字签名不再包括在txid计算中，这解决了交易可塑性问题。
- en: 'Other blockchains have addressed the malleability issue through different means.
    For example, Bitcoin Cash (BCH) split from the Bitcoin network over a disagreement
    over SegWit. Instead, BCH has addressed various sources of transaction malleability
    in a series of independent upgrades.[^(16)](#c02-note-0016)  ###### *Case Study*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '其他区块链通过不同的方式解决了可塑性问题。例如，比特币现金（BCH）因对SegWit的看法不一致而与比特币网络分裂。相反，BCH在一系列独立的升级中解决了交易可塑性的各种来源。[^(16)](#c02-note-0016)  ######
    *案例研究*'
- en: 'Mt. Gox was a cryptocurrency exchange that went bankrupt. Before announcing
    bankruptcy, the exchange blamed frozen Bitcoin withdrawals on a repeated transaction
    malleability attack. By exploiting the transaction malleability bug and claiming
    that they had never received withdrawal transactions, attackers were able to extract
    386 Bitcoin (worth $203,000) from the exchange.[^(17)](#c02-note-0017)  #####
    Serialization Vulnerabilities'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mt. Gox](https://example.org/mt-gox) 是一家申请破产的加密货币交易所。在宣布破产之前，该交易所将比特币提现冻结归咎于连续的交易可塑性攻击。利用交易可塑性漏洞，攻击者声称他们从未收到提现交易，从而得以从交易所提取了386个比特币（价值203,000美元）。[^(17)](#c02-note-0017)  #####
    序列化漏洞'
- en: Serialization is a technique for converting an object or a collection of variables
    into a single series of bits for transmission or storage. If the structure of
    the object is well-defined, then the recipient of the data can deserialize it
    into the original object or set of variables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将对象或变量集合转换为单一比特序列的技术，以便进行传输或存储。如果对象的结构是明确定义的，那么数据的接收方可以将它反序列化为原始对象或变量集合。
- en: Blockchain nodes commonly serialize and deserialize untrusted user input, including
    transactions, blocks, and other data structures. This creates the potential for
    serialization vulnerabilities where deserialization code makes assumptions about
    the data that it receives and processes it without verifying these assumptions
    first.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链节点通常会序列化和反序列化未经验证的用户输入，包括交易、区块和其他数据结构。这创造了序列化漏洞的可能性，其中反序列化代码对收到的数据做出了假设，并在没有首先验证这些假设的情况下处理这些数据。
- en: Serialization vulnerabilities can result in integer and buffer overflow vulnerabilities,
    infinite loops or recursion, or other issues. Exploitation of these vulnerabilities
    can allow an attacker to execute malicious code or perform a denial-of-service
    (DoS) attack against vulnerable software.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化漏洞可能导致整数和缓冲区溢出漏洞、无限循环或递归，或其他问题。利用这些漏洞可以让攻击者执行恶意代码或对易受攻击的软件执行服务拒绝（DoS）攻击。
- en: '###### *Countermeasures*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 对策'
- en: 'Serialization vulnerabilities are the result of failing to perform proper input
    validation on untrusted data before deserializing it. Verifying that serialized
    data follows the protocol and is valid before deserializing or processing it can
    protect against these vulnerabilities.  ###### *Case Study*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化漏洞是由于在反序列化之前没有对未经验证的数据进行适当的输入验证造成的。在反序列化或处理之前验证序列化数据是否遵循协议并且有效，可以防止这些漏洞。######
    案例研究
- en: In 2018, a serialization vulnerability was discovered in the NEO smart contract
    platform that could have enabled a denial-of-service (DoS) attack against the
    network.[^(18)](#c02-note-0018) The software's StackItem type can contain different
    types of data, including arrays, whose size and child elements would be serialized
    as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，在NEO智能合约平台中发现了一个序列化漏洞，这可能使网络面临服务拒绝（DoS）攻击。[^(18)](#c02-note-0018) 该软件的StackItem类型可以包含不同类型的数据，包括数组，其大小和子元素也会被序列化。
- en: 'The security researchers who discovered this vulnerability found that an array,
    *a*, could be added as an element of itself. Attempting to deserialize this would
    result in an infinite loop, causing a NEO node attempting to process the data
    to crash with a StackOverflowException.  ##### Block Explorer Injection'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 发现这个漏洞的安全研究人员发现，一个数组*a*可以作为自身的元素添加进去。尝试反序列化这会导致无限循环，从而导致处理数据的NEO节点崩溃，抛出StackOverflowException。#####
    区块浏览器注入
- en: Block explorers are websites that are designed to provide visibility into what
    is happening on the blockchain. Block explorers allow inspection of each block
    on the blockchain down to the contents of individual transaction inputs and outputs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 区块浏览器是设计用来提供对区块链上正在发生事情的可见性的网站。区块浏览器允许查看区块链上的每个区块，甚至包括个别交易输入和输出的内容。
- en: Blockchain transactions have a defined structure, but they also have room for
    arbitrary data. For example, the Bitcoin genesis block is famous for containing
    a quote from the UK newspaper *The Times*, “*The Times* 03/Jan/2009 Chancellor
    on brink of second bailout for banks.”[^(19)](#c02-note-0019)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链交易有一个定义好的结构，但它们也存在任意数据的空间。例如，比特币创世区块因包含来自英国报纸《泰晤士报》的引用而闻名，“《泰晤士报》03/Jan/2009
    财相面临第二次银行救助。”[^(19)](#c02-note-0019)
- en: With the ability to embed arbitrary data within a transaction, it is possible
    that an attacker could craft a transaction designed to exploit vulnerable block
    explorers or other software that processes transactions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于能够在交易中嵌入任意数据，攻击者可能会构造一个旨在利用易受攻击的区块浏览器或其他处理交易的软件的交易。
- en: For example, a blockchain transaction could be designed to contain a cross-site
    scripting (XSS) exploit. If a vulnerable block explorer displays the malicious
    transaction, then it could expose visitors to an XSS attack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个区块链交易可能被设计包含一个跨站脚本攻击（XSS）利用。如果一个易受攻击的区块浏览器显示了这个恶意交易，那么它可能会将访问者暴露于XSS攻击之下。
- en: '###### *Countermeasures*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 对策'
- en: 'Injection attacks are a common attack vector for web applications, and this
    threat is only different due to the potential sources of the malicious user data.
    Performing input validation and implementing standard protections against XSS
    and other web application attacks can help to protect against this threat.  ######
    *Case Study*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击是Web应用程序常见的攻击方式，这种威胁之所以不同，只是因为恶意用户数据的潜在来源不同。对输入进行验证并实施针对XSS和其他Web应用程序攻击的标准保护可以帮助抵御这一威胁。#####
    案例研究
- en: EtherDelta is a decentralized exchange that included a frontend application
    that showed information about the tokens that users could trade. As a frontend
    for a trading platform, it also had users enter their private keys to perform
    transactions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: EtherDelta是一个包含前端应用程序的去中心化交易所，该应用程序显示用户可以交易的代币信息。作为交易平台的前端，它还让用户输入私钥来执行交易。
- en: This frontend application contained an XSS vulnerability that could be exploited
    via malicious token contracts.[^(20)](#c02-note-0020) The vulnerable page extracted
    the name of a token from the contract code and embedded it within the web page.
    An attacker exploited this by creating a malicious contract whose name included
    JavaScript code that was designed to access the private keys entered by the user
    and send them to the attacker.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前端应用程序包含了一个XSS漏洞，可以通过恶意代币合约被利用。[^(20)](#c02-note-0020) 漏洞页面从合约代码中提取代币名称并将其嵌入网页中。攻击者通过创建一个包含JavaScript代码的恶意合约来利用这一点，该代码旨在访问用户输入的私钥并将它们发送给攻击者。
- en: 'The attacker posted links to their contract on Discord and Slack. By stealing
    private keys from visitors to the site, the attacker was able to steal thousands
    of dollars from their compromised accounts.  ### Blocks'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '攻击者在Discord和Slack上发布了他们合约的链接。通过窃取访问网站的用户的私钥，攻击者能够从他们的被攻陷账户中窃取数千美元。#### #块'
- en: Transactions are added to the blockchain's distributed ledger as parts of blocks.
    The blocks are created by block producers selected via the blockchain consensus
    algorithm.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 交易作为区块的一部分添加到区块链的分布式账本中。区块是由通过区块链共识算法选择的区块生产者创建的。
- en: '#### *Inside a Block*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *区块内部*'
- en: 'As mentioned previously, a blockchain block is made up of two parts. The block
    header is a fixed-size structure that contains metadata about the block and is
    the value covered by the previous block hash. While the contents of a block header
    can vary from one blockchain to another, a Bitcoin block header includes the following
    fields:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，区块链块由两部分组成。块头是一个固定大小的结构，包含有关块的元数据，并且是前一个块哈希所覆盖的值。虽然不同区块链的块头内容可能有所不同，但比特币块头包括以下字段：
- en: Version
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: Previous block hash
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个块哈希
- en: Merkle root
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Merkle根
- en: Time stamp
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Difficulty target
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难度目标
- en: Nonce
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数（Nonce）
- en: Blocks add transactions to the distributed ledger, but these aren't included
    in the block header. The other part of the block is the block body, which contains
    these transactions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 区块向分布式账本添加交易，但这些不包括在块头中。区块的另一个部分是块体，其中包含这些交易。
- en: 'Transactions in the body of a block are organized in the same order that they
    appear in the block''s Merkle tree. This enables anyone with access to the entire
    block to recompute the Merkle tree and compare its root value to the one stored
    within the block header. If they match, then the transactions in the block have
    presumably not been modified since the block was created.  #### *Attacking Blockchain
    Blocks*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 区块体内的交易按照它们在区块Merkle树中的顺序组织。这使得任何拥有整个区块访问权限的人都可以重新计算Merkle树，并将其根值与存储在块头中的值进行比较。如果它们匹配，那么自区块创建以来，区块中的交易
    presumably 没有被修改过。#### *攻击区块链区块*
- en: Like transactions, blockchain blocks contain untrusted data and are processed
    by every node within the network as part of the ledger update process. While potential
    vulnerabilities in the block creation process are covered in a later chapter,
    note that the block data structure can be used in different attacks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 像交易一样，区块链区块包含不可信的数据，并且作为账本更新过程的一部分由网络中的每个节点处理。尽管块创建过程中的潜在漏洞在后面的章节中有所涉及，但请注意，块数据结构可以用于不同的攻击。
- en: '##### Serialization Vulnerabilities'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 序列化漏洞'
- en: 'The potential for serialization vulnerabilities was mentioned in the discussion
    of attacks against transactions because they can contain serialized data. Similarly,
    block headers are serialized for transmission on the blockchain, potentially enabling
    a malformed block header to exploit vulnerable nodes.  ##### Bitcoin Leaf-Node
    Weakness'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论针对交易的攻击时提到了序列化漏洞的可能性，因为它们可以包含序列化数据。同样，块头在区块链上进行序列化以供传输，这可能使恶意块头利用易受攻击的节点。#####
    Bitcoin Leaf-Node Weakness
- en: Merkle trees are binary trees that summarize the transactions within a block
    in the transaction root. The number of layers within a Merkle tree depends on
    the number of transactions the block contains.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树是一种二叉树，它总结了区块内的交易，并以交易根的形式进行汇总。Merkle树中的层数取决于区块包含的交易数量。
- en: The Bitcoin Leaf-Node weakness took advantage of the fact that Bitcoin doesn't
    specify the depth of a Merkle tree. An attacker could theoretically construct
    a transaction that appears to be an inner node of a Merkle tree, which summarizes
    two transactions within a 64-byte hash.[^(21)](#c02-note-0021)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币叶节点弱点利用了比特币没有指定梅克尔树深度的事实。理论上，攻击者可以构造一个交易，这个交易看起来是梅克尔树的一个内部节点，它总结了两个交易在一个64字节的哈希值内。[^(21)](#c02-note-0021)
- en: With a 72-bit brute-force attack, an attacker could craft a pair of transactions
    that would hash to this 64-byte hash. The attacker could then generate a valid
    proof to an SPV node that these child transactions were included in the blockchain
    when they were not.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过72位的暴力攻击，攻击者可以构造一对交易，这些交易哈希后会生成这个64字节的哈希值。然后攻击者可以生成一个有效的证明给一个SPV节点，证明这些子交易在区块链中被包含，尽管实际上并没有被包含。
- en: '###### *Countermeasures*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'Version 0.14 of the Bitcoin blockchain addressed this issue by disallowing
    any transactions that were exactly 64 bytes in length. Additionally, transactions
    valuable enough to make such an attack profitable would use a full node for verification,
    which does not rely on an SPV proof.  ### Threat Modeling for Data Structures'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链0.14版本通过禁止任何长度为64字节的交易解决了这个问题。此外，足够有价值的交易会使用完整节点进行验证，而不依赖于SPV证明。### 数据结构威胁建模
- en: 'The transactions and blocks used to organize data in the blockchain are under
    an attacker''s control. This allows them to be used in attacks against most areas
    of the STRIDE threat model:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中用于组织数据的交易和区块处于攻击者的控制之下。这允许它们被用于针对STRIDE威胁模型的绝大多数领域的攻击：
- en: '**Spoofing:** Exploitation of injection vulnerabilities in block explorers
    and other frontend systems can result in the compromise of private keys. These
    can be used to masquerade as the user and perform transactions on their behalf.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪装：** 利用区块浏览器和其他前端系统中的注入漏洞可以导致私钥被泄露。这些泄露的私钥可以被用来伪装成用户，代表他们执行交易。'
- en: '**Tampering:** Transaction malleability can allow an attacker to change the
    hash and transaction ID of unconfirmed transactions, changing how they are recorded
    on the blockchain.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改：**未确认交易的哈希和交易ID可以被攻击者修改，改变它们在区块链上的记录方式。'
- en: '**Denial of Service:** Malformed transactions or blocks can be used to crash
    vulnerable nodes.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务拒绝：** 恶意格式化的交易或区块可以用来崩溃易受攻击的节点。'
- en: '**Elevation of Privileges:** Theft of private keys through block explorer injection
    attacks can grant unauthorized access to user accounts.  ## Conclusion'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升：**通过区块浏览器注入攻击窃取私钥可以授予攻击者对用户账户的不授权访问。## 结论'
- en: This chapter explored the security of the fundamentals of the blockchain ecosystem.
    The public key cryptography, hash functions, transactions, and blocks are the
    core components used to build blockchain's decentralized, immutable ledger.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了区块链生态系统的基石——公钥加密、哈希函数、交易和区块的安全性。这些是构建区块链去中心化、不可篡改账本的核心组件。
- en: 'In the next chapter, we''ll step up a level to look at the protocols used to
    achieve consensus in the blockchain and to define how blocks are created and added
    to the digital ledger. These protocols use the cryptographic algorithms and data
    structures explored here to provide the vital functionality and security guarantees
    of the blockchain.  ## Notes'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提升一个层次，来研究区块链中实现共识的协议以及定义区块是如何创建并添加到数字账本中的。这些协议使用前面探讨过的密码学算法和数据结构，为区块链提供关键功能和安全保证。##
    注释
- en: 1.  [1](#R_c02-note-0001).  `[www.ise.io/casestudies/ethercombing](http://www.ise.io/casestudies/ethercombing)`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  [1](#R_c02-note-0001).  `[www.ise.io/casestudies/ethercombing](http://www.ise.io/casestudies/ethercombing)`
- en: '[2](#R_c02-note-0002).  `[https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961](https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961)`'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2](#R_c02-note-0002).  `[https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961](https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961)`'
- en: '[3](#R_c02-note-0003).  `[https://blog.bitmex.com/call-me-ishmael](https://blog.bitmex.com/call-me-ishmael)`'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[3](#R_c02-note-0003).  `[https://blog.bitmex.com/call-me-ishmael](https://blog.bitmex.com/call-me-ishmael)`'
- en: '[4](#R_c02-note-0004).  `[https://twitter.com/alistairmilne/status/1266037520715915267](https://twitter.com/alistairmilne/status/1266037520715915267)`'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[5](#R_c02-note-0005).  `[https://medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin-635fe051a752](https://medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin-635fe051a752)`'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[6](#R_c02-note-0006).  `[https://blog.chainalysis.com/reports/money-supply](https://blog.chainalysis.com/reports/money-supply)`'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[7](#R_c02-note-0007).  `[https://thecharlatan.ch/List-Of-Hardware-Wallet-Hacks](https://thecharlatan.ch/List-Of-Hardware-Wallet-Hacks)`'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[8](#R_c02-note-0008).  `[https://therecord.media/hacker-steals-55-million-from-bzx-defi-platform](https://therecord.media/hacker-steals-55-million-from-bzx-defi-platform)`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9](#R_c02-note-0009).  `[www.europol.europa.eu/media-press/newsroom/news/ten-hackers-arrested-for-string-of-sim-swapping-attacks-against-celebrities](http://www.europol.europa.eu/media-press/newsroom/news/ten-hackers-arrested-for-string-of-sim-swapping-attacks-against-celebrities)`'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#R_c02-note-0010). `[https://medium.com/easify-network/easyfi-security-incident-pre-post-mortem-33f2942016e9](https://medium.com/easify-network/easyfi-security-incident-pre-post-mortem-33f2942016e9)`'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#R_c02-note-0011). `[www.bleepingcomputer.com/news/security/clipboard-hijacker-malware-monitors-23-million-bitcoin-addresses](http://www.bleepingcomputer.com/news/security/clipboard-hijacker-malware-monitors-23-million-bitcoin-addresses)`'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#R_c02-note-0012). `[www.universetoday.com/36302/atoms-in-the-universe](http://www.universetoday.com/36302/atoms-in-the-universe)`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#R_c02-note-0013). `[www.bbc.com/news/technology-16543497](http://www.bbc.com/news/technology-16543497)`'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#R_c02-note-0014). `[https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations](https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations)`'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14](#R_c02-note-0014). `[https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations](https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations)`'
- en: '[15](#R_c02-note-0015). `[https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug](https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug)`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15](#R_c02-note-0015). `[https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug](https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug)`'
- en: '[16](#R_c02-note-0016). `[https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279](https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279)`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[16](#R_c02-note-0016). `[https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279](https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279)`'
- en: '[17](#R_c02-note-0017). `[www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability](http://www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability)`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[17](#R_c02-note-0017). `[www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability](http://www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability)`'
- en: '[18](#R_c02-note-0018). `[https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network](https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network)`'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18](#R_c02-note-0018). `[https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network](https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network)`'
- en: '[19](#R_c02-note-0019). `[https://en.bitcoin.it/wiki/Genesis_block](https://en.bitcoin.it/wiki/Genesis_block)`'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[19](#R_c02-note-0019). `[https://en.bitcoin.it/wiki/Genesis_block](https://en.bitcoin.it/wiki/Genesis_block)`'
- en: '[20](#R_c02-note-0020). `[https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0](https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0)`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[20](#R_c02-note-0020). `[https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0](https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0)`'
- en: '[21](#R_c02-note-0021). `[https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design)`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21](#R_c02-note-0021). `[https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design)`'
