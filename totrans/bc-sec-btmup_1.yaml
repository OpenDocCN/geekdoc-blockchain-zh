- en: CHAPTER 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentals
  prefs: []
  type: TYPE_NORMAL
- en: The goal of blockchain technology is to create a shared, decentralized digital
    ledger. In this system, no centralized authority exists to dictate what the official
    version of the digital ledger is.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology transfers trust in the digital ledger away from a centralized
    authority to a set of protocols designed to provide the same guarantees as a centralized
    ledger. These protocols are created using smaller building blocks with certain
    properties that can provide these desired guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explores the fundamentals of blockchain security. This includes
    the cryptographic primitives and the data structures that are used to build blockchain
    protocols and make the decentralized digital ledger possible.  ## Cryptographic
    Primitives'
  prefs: []
  type: TYPE_NORMAL
- en: Financial institutions maintain an internal accounts ledger, enabling value
    to be transferred from one party to another by simply updating the relevant values
    in this ledger. Each financial institution is responsible for maintaining the
    accuracy of its ledger, and customers must trust the financial institution to
    properly track their financial transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is designed to transfer this trust from these centralized authorities
    to cryptographic algorithms and protocols. The cryptographic algorithms are relied
    upon to ensure the authenticity and integrity of the transactions recorded on
    the blockchain's ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology began with Bitcoin, and since then, many different blockchains
    have emerged, each with its own tweaks on the underlying protocols and methods
    of implementing them. However, all of these protocols are reliant on the same
    set of cryptographic building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the blockchain makes data integrity and authenticity protections
    vital for the system to work. To provide these protections, blockchain technology
    uses public key cryptography and hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: '### Public Key Cryptography'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic algorithms are divided into two main categories based on how they
    use encryption keys. Symmetric algorithms use a single key for both encryption
    and decryption. This symmetry means that the algorithms are generally more efficient,
    making them better suited for bulk data transfer. However, they require the shared
    secret key to be distributed to all participants via a secure channel.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric, or public key, cryptography uses a public key for encryption and
    a private key for decryption. This makes it possible to send a secret message
    to anyone without setting up a shared secret key. However, these algorithms are
    generally less efficient than their symmetric counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology is heavily dependent on public key cryptography. Its use
    of two related keys and the ability to create and validate digital signatures
    using them provides the invaluable ability to authenticate the sender of a message.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Introducing “Hard” Mathematical Problems*'
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography is built using “hard” mathematical problems. These mathematical
    functions are defined by an asymmetric relationship between how hard they are
    to perform versus how hard they are to reverse. For these problems, `F`(`x)` has
    polynomial complexity, while `F^(−1)(x)` has exponential complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This relationship makes it possible to develop cryptographic algorithms that
    are both usable and secure. The algorithms are designed so that a legitimate user
    only has to perform the easy operation, `F(x)`, while any attacker must solve
    the harder problem, `F^(−1)(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Several of these mathematically “hard” problems exist. The two most commonly
    used in “classical” (i.e., not post-quantum) cryptography are the factoring problem,
    which is the basis for RSA, and the discrete logarithm problem, which is the basis
    for the Digital Signature Algorithm (DSA). Algorithms based on these problems
    can also be implemented more efficiently using elliptic curve cryptography (ECC).
  prefs: []
  type: TYPE_NORMAL
- en: '##### The Factoring Problem'
  prefs: []
  type: TYPE_NORMAL
- en: In the factoring problem, the easier operation is multiplying two prime numbers.
    The complexity of doing so is polynomial in the length of the two numbers. This
    means that an increase in the length of the two primes, such as switching from
    128 to 129 bits, has a relatively small impact on the overall complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Factoring inverts multiplication, and factoring has exponential complexity in
    the length of the factors. The reason for this is that the best-known way to factor
    two numbers on a non-quantum computer has exponential complexity.
  prefs: []
  type: TYPE_NORMAL
- en: While one of the factors is guaranteed to be less than the square root of the
    quotient, this is a large space that grows rapidly. Adding a single bit to the
    length of the primes (i.e., from 128 to 129 bits) doubles the number of potential
    factors that an attacker needs to search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difficulty of factoring grows much faster than the difficulty of multiplying.
    As a result, it is possible to find a length of these factors where multiplication
    is possible but factoring is not.  ##### The Discrete Logarithm Problem'
  prefs: []
  type: TYPE_NORMAL
- en: The discrete logarithm problem is another asymmetric problem commonly used in
    public key cryptography. It is based on the “easy” problem of exponentiation and
    the “hard” problem of logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the factoring problem, the discrete logarithm problem is designed to
    ensure that legitimate operations are easy compared to malicious ones. Increasing
    the size of the exponent has a minimal impact on a legitimate user—but a significant
    impact on an attacker. As with the factoring problem, the best way to solve the
    discrete logarithm is by guessing possible values for the exponent, so a user
    can achieve an arbitrary level of security by increasing the key length.  #####
    Elliptic Curve Cryptography'
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC) is a type of public key cryptography that
    uses points on an elliptic curve instead of integers as the basis for computation.
    An elliptic curve is a mathematical function of the form `y² = x³ + ax + b`.
  prefs: []
  type: TYPE_NORMAL
- en: Using points on these curves as public keys, it's possible to create a public
    key cryptosystem that uses the same principles as the discrete logarithm problem.
    On an elliptic curve, an operation called point addition is equivalent to multiplication
    over the integers, and point multiplication is equivalent to exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: In elliptic curve cryptography, public keys are derived from private keys by
    multiplying a random integer (the private key) with a publicly known point on
    the curve (the generator). As with the factoring and discrete logarithm problems,
    point addition and multiplication (the equivalents of multiplication and exponentiation)
    are “easy” for legitimate users, while point subtraction and division (the equivalents
    of factoring and logarithms) are “hard” for an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elliptic curve cryptography has two main advantages over integer-based public
    key cryptography: key length and energy consumption. Elliptic curve cryptography
    accomplishes the same level of security as cryptosystems using the discrete logarithm
    problem with much shorter keys. For example, a 2048-bit RSA key has equivalent
    security to a 160-bit ECC curve. ECC is also better than algorithms like RSA in
    low-power environments because the operations used in ECC-based cryptography (point
    addition and multiplication) consume less power than the equivalent operations
    over the integers (multiplication and exponentiation).  #### *Building Cryptography
    with “Hard” Problems*'
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography uses these “hard” problems to build algorithms that
    are both usable and secure. The design of these algorithms is intended to allow
    a legitimate user to only perform “easy” operations, while attackers are forced
    to complete “hard” ones.
  prefs: []
  type: TYPE_NORMAL
- en: A critical part of this process is the derivation of the public/private keypair.
    While a private key is a random number, the public key is derived from it to have
    certain properties. The intent is for one key to undo what the other does for
    a particular algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the RSA encryption operation is `c = m^e (mod n)`, where *`c`*
    is the ciphertext, *`m`* is the message, *`e`* is the public key, and *`n`* is
    a public modulus value. Substituting some values in, `2⁵ (mod 14) = 4`.
  prefs: []
  type: TYPE_NORMAL
- en: RSA uses the same operation for decryption, so the private key is selected to
    undo the effects of encryption. A private key of 11 produces `4^(11) (mod 14)
    = 2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of RSA, the public and private keys, *`e`* and *`d`*, are selected
    so that `m^(d*e) = 1 (mod 14)` for any message *`m`,* since this is equivalent
    to the two-stage process that we performed due to the properties of exponents.
    With a random private key of 11, *`d`* had to be 5, according to Euler's totient
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the recipient of the message knows the private key, they can undo the
    encryption with an exponentiation operation. However, an attacker lacking knowledge
    of this key would need to calculate a logarithm, which is much harder.  #### *How
    the Blockchain Uses Public Key Cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptographic algorithms can provide confidentiality, integrity,
    and authentication protections. They are a fundamental part of how the blockchain
    works and are used for digital signatures and account addressing.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Digital Signatures'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we explored how public key cryptography can be used
    to protect confidentiality by demonstrating that a private key can be used to
    create an encrypted message that only the intended recipient can read. Digital
    signatures flip this around, creating a digital signature that only the alleged
    sender could generate.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, public and private keys are selected so that one undoes what the
    other does. In the case of RSA, this meant that `m^(d*e) = 1 (mod n)`.
  prefs: []
  type: TYPE_NORMAL
- en: However, it also means that `m^(e*d) = 1 (mod n)` or that we could “encrypt”
    with a private key to generate a digital signature and “decrypt” with a public
    key to get the original plaintext. By generating a signature and sending it alongside
    the associated data, we can prove that the data could only have been generated
    by someone who knows the private key and has not been modified in transit. Anyone
    with access to the associated public key can then “decrypt” the signature and
    validate that the plaintext matches.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain uses digital signatures to prove the authenticity of transactions
    on the blockchain. If cryptocurrency is being transferred out of a particular
    account, we want to be sure that the transfer was performed by the owner of the
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''re relying on a peer-to-peer network to carry the transaction and
    nodes to store copies of it in a pool of unused transactions until it is included
    in a block. Digital signatures also prove that a transaction has not been modified
    in transit.  ##### Account Addressing'
  prefs: []
  type: TYPE_NORMAL
- en: One of the hard problems associated with digital signatures is proving that
    a particular public key belongs to a particular user. If an attacker intercepts
    a message and a signature, they could modify the message, sign it with their own
    key, and send their own public key alongside it. If the recipient accepts the
    public key as belonging to the alleged sender, they can validate the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchain solves this problem by using public keys to derive account addresses.
    This makes it possible to verify that a public key belongs to a particular account
    by rederiving the account address from the key and checking that it matches.  ####
    *Security Assumptions of Public Key Cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For public key cryptography to be effective, it needs to be secure. Public
    key cryptography has two main security assumptions: that both the user''s private
    key and the algorithm used are secure.'
  prefs: []
  type: TYPE_NORMAL
- en: '##### Private Key Security'
  prefs: []
  type: TYPE_NORMAL
- en: In public key cryptography, the only secret is a user's private key. Anyone
    with access to this private key can decrypt a message sent to the user or generate
    a digital signature on their behalf.
  prefs: []
  type: TYPE_NORMAL
- en: A private key must be securely generated and protected throughout its life cycle.
    If a private key is generated using a weak random number generator or derived
    from a password or passphrase that is guessable, an attacker may be able to learn
    the private key. Blockchain security depends on private keys being generated using
    a cryptographically secure random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a private key is generated, it must be protected against compromise. If
    an attacker can steal a user''s private key using malware, phishing, or other
    methods, they have the ability to masquerade as that user on the distributed ledger,
    performing transactions on their behalf. Private keys that control accounts with
    access to elevated permissions on the distributed ledger or with large amounts
    of value stored within them should be in cold storage or stored on a device not
    accessible from the Internet.  ##### Algorithmic Security'
  prefs: []
  type: TYPE_NORMAL
- en: The other half of the security of public key cryptography is the security of
    the algorithm itself. This involves ensuring that the “hard” problem that the
    algorithm is built upon remains “hard.”
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the case, then the only way to break the cryptography is via a brute-force
    search. If the private key is long enough to make this infeasible, then the protocol
    remains secure.  #### *Attacking Public Key Cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: The security of public key cryptography boils down to the security of the private
    key and the difficulty of the mathematical problem that the algorithm uses for
    its asymmetry. If an attacker can compromise a private key or break this asymmetry,
    then public key cryptography becomes insecure.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Private Key Security'
  prefs: []
  type: TYPE_NORMAL
- en: With public key cryptography, a user's private key is the only secret. The cryptographic
    algorithm and any parameters that it uses are public knowledge. This means that
    anyone with knowledge of a user's private key can decrypt messages and generate
    digital signatures while impersonating that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, private key security is essential to the security of asymmetric
    cryptography. Two of the primary ways in which this can go wrong are weak key
    generation and failure to properly protect the private key.  ##### Weak Key Generation'
  prefs: []
  type: TYPE_NORMAL
- en: Private keys are supposed to be random numbers that are generated to meet the
    requirements of the particular algorithm (key length, primacy, etc.). If a key
    is not random, then an attacker can potentially guess that key. This could allow
    them to generate transactions on a user's behalf, stealing cryptocurrency or interacting
    with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Weak Random Number Generation*'
  prefs: []
  type: TYPE_NORMAL
- en: Many blockchain users use a tool to generate private keys for their blockchain
    accounts. This functionality could be integrated into the software that they use
    to access the blockchain, or it could be a stand-alone website or service.
  prefs: []
  type: TYPE_NORMAL
- en: These tools should use a cryptographic random number generator (RNG) to create
    the users' private keys. However, some are implemented incorrectly or use a non-cryptographic
    RNG, leading to weak sources of randomness.
  prefs: []
  type: TYPE_NORMAL
- en: The story of the “Blockchain Bandit” demonstrates the risks of such an approach.
    A study by Independent Security Evaluators found that an attacker was scanning
    the Ethereum blockchain for account addresses generated using weak private keys.[¹](#c02-note-0001)
    As of January 13, 2018, the Blockchain Bandit had stolen 37,926 ETH from these
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Another risk of using a third-party service for key generation is that the resulting
    private keys could be intentionally weak or recorded by the service to allow future
    theft. A 2019 study found that the source code for `[WalletGenerator.net](http://walletgenerator.net)`
    deviated from the source code at the project's GitHub repository for some time
    after August 17, 2018.[²](#c02-note-0002)
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the “bulk wallet” generator on the site found that attempts to create
    1,000 keys resulted in different results for the non-malicious GitHub version
    and the malicious active version. The GitHub version properly generated 1,000
    unique keys, while the active version only provided 120 unique keys per request.
    If these 1,000 keys were provided to different users, some would have the same
    key and access to one another''s blockchain accounts.  ###### *Password-Based
    Private Keys*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Brain wallet* is a term for memorizing the private key associated with a blockchain
    account. While this has the benefit of being unhackable, most people struggle
    to remember a random series of letters and numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: One insecure solution to this problem is to generate a private key from an easily
    memorizable word or phrase. To do so, this seed phrase could be hashed with SHA-256
    or another algorithm with the same length as the desired secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 'BitMEX research did a study on this approach that they titled Call me Ishmael
    after a quote from *Moby Dick*.[³](#c02-note-0003) The researchers generated secret
    keys using quotes from famous works such as *Moby Dick*, the Bitcoin white paper,
    and Jane Austen''s books. Attackers guessed the passphrases for all of these accounts
    within a day, and one, “Call me Ishmael,” only lasted 0.67 seconds.  ###### *Compromised
    Mnemonic Keys*'
  prefs: []
  type: TYPE_NORMAL
- en: For those wishing to memorize their blockchain private keys, mnemonic keys or
    seed phrases offer a more secure alternative to password-based keys. A mnemonic
    key is a set of 12 to 24 words pulled from a standard wordlist. Each word encodes
    11 bits of randomness from the original key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mnemonic keys make private keys easier to memorize, but they also need to be
    properly protected, and even a partially compromised mnemonic key can leave a
    blockchain account open to attack. In 2020, Alistair Milne released 8 of 12 words
    of a mnemonic key one at a time, intending to release the last three or four at
    once to prevent brute-force attacks.[⁴](#c02-note-0004) John Cantrell wrote a
    custom script that tried over 1 trillion possibilities in 30 hours to claim the
    1 BTC in the account.[⁵](#c02-note-0005)  ##### Weak Key Security'
  prefs: []
  type: TYPE_NORMAL
- en: After generating a private key, a blockchain user needs to preserve the secrecy
    of that key for the lifetime of the account. If an unauthorized party gains access
    to that key, they can generate transactions on the users' behalf and steal cryptocurrency
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Vulnerable Storage*'
  prefs: []
  type: TYPE_NORMAL
- en: Insecure storage of secret data has been a problem for far longer than blockchain
    has existed. Passwords written on sticky notes under a keyboard or saved in text
    documents on a computer have been a security challenge for decades.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of blockchain technology, it should come as no surprise
    that private keys are regularly stored in locations where they can be easily stolen
    or lost forever. Countless blockchain accounts have been compromised by poor key
    management, and an estimated 30 percent of Bitcoin is lost forever due to lost
    private keys.[⁶](#c02-note-0006)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardware wallets offer a potential solution by storing private keys on a device
    that uses a dedicated microprocessor to store keys and generate digital signatures
    so that the keys never leave the device. However, even hardware wallets can have
    security vulnerabilities. Dozens of vulnerabilities have been discovered in hardware
    wallets that can cause them to expose private keys or otherwise misbehave.[⁷](#c02-note-0007)  ######
    *Cryptocurrency Wallets and Exchanges*'
  prefs: []
  type: TYPE_NORMAL
- en: Many blockchain users don't want to manage their own private keys. Instead,
    they use a third-party service to store these keys. Common examples include cryptocurrency
    wallet services and exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: With these wallets and exchanges, the security model for user accounts changes.
    Instead of having to guess a user's secret key, which should be a large random
    value, an attacker only needs to learn the user's password for the key management
    service and potentially defeat multifactor authentication (MFA).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a much easier problem for an attacker to solve. The following list
    includes some common approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password Guessing:** Many people have weak and reused passwords. This makes
    it trivial for an attacker to gain access to an account via brute-force password
    guessing or credential stuffing attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phishing:** Phishing attacks are a common way to steal passwords and MFA
    codes or deliver malware to target computers. In 2021, a phishing attack infected
    the computer of a bZx developer with malware that stole private keys, allowing
    tokens worth $55 million at the time to be stolen from the project and its users.[⁸](#c02-note-0008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIM Swapping:** Many online services use SMS messages for MFA, so a SIM swapping
    attacker can gain access to these codes. In 2021, European law enforcement arrested
    eight individuals for involvement in a $100 million SIM swapping attack.[⁹](#c02-note-0009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malware:** Some attacks on private keys are designed to replace legitimate
    software with malware that steals private keys or modifies transactions performed
    by the user. In April 2021, the EasyFi DeFi protocol lost over $46 million in
    tokens in a hack that used a malicious version of MetaMask to steal private keys.[^(10)](#c02-note-0010)  ######
    *Malware*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain technology is implemented as software. When users want to interact
    with a blockchain, they need to use their computers. This can mean typing private
    keys or mnemonic phrases into blockchain software for use in signing a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: If a private key or mnemonic seed is entered into a computer, then it's potentially
    vulnerable to malware. Some malware, such as the Clippy Malware, is designed to
    scan the contents of the system clipboard or a computer's memory for data that
    resembles a private key or a blockchain address.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such malware campaign was designed to redirect transactions performed by
    users of compromised machines. This malware monitored the clipboards of infected
    machines for data that matched any of 2.3 million Bitcoin addresses.[^(11)](#c02-note-0011)
    If it found a match, it would replace the address with the attacker''s address.
    Unless the user double-checked the address after pasting, the transaction would
    be sent to the attacker rather than its intended recipient.  ##### Algorithmic
    Security'
  prefs: []
  type: TYPE_NORMAL
- en: While compromised private keys are the most common way for public key cryptography
    to be attacked, the algorithms themselves may also be insecure. However, no known
    attacks exist that could allow the asymmetric encryption algorithms used in blockchain
    to be broken on modern technology.
  prefs: []
  type: TYPE_NORMAL
- en: This is only true until large-scale quantum computing becomes available. Once
    this is the case, Shor's algorithm will force a transition to post-quantum encryption
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Shor''s Algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: Many public key cryptography algorithms are based upon the “hard” problems of
    factoring the product of two large prime numbers or calculating a logarithm within
    a modulus. Using modern computers, the best way to solve these problems is through
    a brute-force search, which scales exponentially in difficulty with the length
    of the secret values used. Since the difficulty of legitimate operations only
    scales polynomially, it's possible to choose a key length that makes the system
    usable for a legitimate user but infeasible to attack.
  prefs: []
  type: TYPE_NORMAL
- en: Shor's algorithm is an algorithm written for quantum computers that solves these
    problems in a way that's more efficient than a brute-force search. With Shor's
    algorithm, the complexity of attacking classical public key cryptography changes
    from exponential to polynomial, just like the cost of legitimate operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it impossible to use classical public key cryptography in a scheme
    that is secure against quantum computers. Even if the complexity of the “hard”
    operation grows several times faster than the “easy” one, an attacker can feasibly
    keep up by throwing more money at the problem. It doesn''t matter if factoring
    is five times harder than multiplication if an eavesdropper has one hundred computers
    to your one.  ###### *Post-Quantum Cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shor''s algorithm is a problem for classical asymmetric encryption algorithms
    because it breaks the asymmetry of the “hard” problems that these algorithms are
    based upon. If both multiplication and factoring have polynomial complexity, then
    it is infeasible to develop a system that is both usable and secure. Even if the
    complexity of factoring grows 100x faster than that of multiplication, an attacker
    can break it by spending 100x more than a legitimate user.  ### Hash Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are at the core of blockchain technology. The main function of
    a hash function is to ensure the integrity of data. This is possible because hash
    functions are one-way, collision-resistant functions, meaning that it is infeasible
    to determine the input that produced a given output or find two inputs that produce
    the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the hash of a piece of data along with the data itself is a common
    way of ensuring the integrity of the data. File checksums use hash functions to
    ensure that the file has not been modified after creation (since finding another
    version of the data that produces the same hash is extremely unlikely). Computers
    store the hashed versions of passwords to maintain the confidentiality of the
    passwords since it's impossible to determine the original password from the hash
    and comparing the hash of a password to a stored hash is almost as secure as comparing
    the true passwords.
  prefs: []
  type: TYPE_NORMAL
- en: In blockchain (and other distributed ledger implementations), hash functions
    are commonly used to ensure the integrity of the data stored within the distributed
    ledger. Each block in a blockchain contains the hash of the previous block and
    a hash summarizing the transaction data stored within the block. As long as the
    hash function remains secure, the data in the distributed ledger cannot be modified
    without the modifications being detected.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Security Assumptions of Hash Functions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The security of hash functions is a major assumption of distributed ledger
    technology. Hash functions protect the integrity of the data stored within the
    distributed ledger and must have two important properties: preimage resistance
    and collision resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: '##### Preimage Resistance'
  prefs: []
  type: TYPE_NORMAL
- en: A preimage of a hash function is an input that produces a desired output. Hash
    functions must be preimage-resistant, meaning that, for a given output, it should
    be infeasible for someone to find an input that produces that output.
  prefs: []
  type: TYPE_NORMAL
- en: Preimage resistance is achieved by using a one-way function in a cryptographic
    hash function. One-way functions discard some information during their computations
    so that it is impossible to uniquely map an output to the input used to create
    it.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a simple one-way function is the modulo operation, where the input
    is divided by the modulus and only the remainder of the division is retained.
    With an output of 5 modulo 10, the possible inputs are 5, 15, 25, and so on. Without
    additional knowledge, it is impossible to determine which of the possible inputs
    was used to create the output of 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash functions have an infinite space of potential inputs and a finite space
    of potential outputs because they can take any input and produce a fixed-size
    output. This means that hash functions map an infinite number of inputs to each
    potential output, making them inherently preimage-resistant.  ##### Collision
    Resistance'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important principle of hash functions for distributed ledger security
    is collision resistance. A hash function collision is when two inputs to the hash
    function can be found that produce the same output. There are two levels of collision
    resistance that a cryptographic hash function must have: weak collision resistance
    and strong collision resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function is weakly collision-resistant if, given an input *`m`*[1],
    it is difficult to find another input, *`m`*[2], that maps to the same output.
    Strong collision resistance means that it is difficult to find any pair of inputs
    that map to the same output. A cryptographic hash function used in distributed
    ledger technology needs to be both weakly and strongly collision-resistant.  ####
    *Additional Security Requirements*'
  prefs: []
  type: TYPE_NORMAL
- en: While preimage resistance and collision resistance are the only requirements
    necessary for security, a hash function must have certain other properties to
    achieve these requirements. A cryptographic hash function must have a large state
    space and be a nonlocal function to protect it against successful brute-force
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Large State Space'
  prefs: []
  type: TYPE_NORMAL
- en: If a hash function is well-designed, the best way of finding a collision is
    searching through the set of possible inputs and looking for one that produces
    the desired output. In order to make this type of attack infeasible, the hash
    function needs to be designed so that it is unlikely that an attacker will successfully
    complete this search within a reasonable length of time.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the space that needs to be searched to find a collision is determined
    by the size of the output of the hash function. By the pigeonhole principle, an
    attacker needs to test a set of inputs equal to the number of possible outputs
    in order to be certain of finding a collision. A strong cryptographic hash function
    will have a large enough output that attempting to search it using modern technology
    will take either too much time or too many resources to be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several blockchains use the Keccak-256 hash function (a variant of the SHA-256
    hash function). As its name suggests, this hash function has a 256-bit output,
    meaning that there are 2^(256) possible values of this output. For comparison,
    the known universe contains fewer than 2^(272) atoms,[^(12)](#c02-note-0012) so
    a hard drive made using all of these atoms would still be too small to store the
    complete set of options (modern hard drives use about 1 million atoms per bit[^(13)](#c02-note-0013)).
    While an attacker may get lucky and find a solution on their first try, the only
    way to be certain is to search the complete space of 2^(256) options.  ##### Nonlocal
    Function'
  prefs: []
  type: TYPE_NORMAL
- en: The other important property that a hash function needs for collision resistance
    is nonlocality. In a cryptographic hash function, two very similar inputs produce
    very dissimilar outputs. On average, hashing two inputs that differ by a single
    bit will produce outputs that differ in half of their bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nonlocality of the hash function is important to collision resistance because
    it protects against hill-climbing attacks. In a hill-climbing attack, an attacker
    takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flip one bit of the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash the new input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the new input's hash with the current one's hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the new hash is closer to the target, retain the change and go to step 3.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the new hash is further from the target, discard the change and go to step
    3.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A hill-climbing attack takes advantage of the locality of a function by making
    small changes and evaluating whether the change is positive or negative. By retaining
    positive changes and discarding negative ones, the attacker incrementally moves
    toward their goal (a collision).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptographic hash functions are protected against this type of attack because
    it is impossible to evaluate whether a change is positive or negative. Since small
    changes to hash function inputs produce large, unpredictable changes to outputs,
    it''s impossible to determine if the attacker is moving toward or away from an
    input that would produce a collision.  #### *How the Blockchain Uses Hash Functions*'
  prefs: []
  type: TYPE_NORMAL
- en: The integrity protections offered by hash functions are crucial to blockchain
    technology. Three major places where hash functions appear on the blockchain are
    the blocks' “chains,” their Merkle trees, and within digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '##### The Blocks'' “Chains”'
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain gets its name from the fact that it is a set of blocks chained
    together. The “chains” in blockchain are hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the header of each block in the blockchain is the hash of the previous
    block header. This both links the blockchain together, providing a clear ordering,
    and makes it more difficult to forge blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Without these previous block hashes, modifying a past transaction in the distributed
    ledger would only require finding an alternative, valid version of the block that
    contains it. While the definition of a valid block depends on the consensus algorithm
    used by the blockchain, block creators regularly create new blocks, so it can't
    be too hard.
  prefs: []
  type: TYPE_NORMAL
- en: With the blocks' chains, the value of each block header depends on the previous
    one. A change to one block header changes the previous block hash in the next,
    which changes the previous block hash in the next, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These cascading changes mean that changing a single transaction in the blockchain
    requires finding an alternative version of both the block that contains it and
    every following block. Blockchain consensus algorithms are designed to make this
    much more difficult than faking a single block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to get around these cascading changes is if an attacker can find
    an alternative version of a block that doesn''t change the previous block hash
    value in the next block. This is the definition of a hash collision: two hash
    inputs that produce the same output. If the blockchain is using a secure, collision-resistant
    hash function, this is infeasible.  ##### Merkle Trees'
  prefs: []
  type: TYPE_NORMAL
- en: The transactions contained within a block are stored in the block's body, not
    its header. This means that they are not included as an input to the hash function
    that implements the blocks' chains.
  prefs: []
  type: TYPE_NORMAL
- en: The immutability of blockchain transactions is protected by a Merkle tree. A
    Merkle tree is a binary tree whose internal nodes contain the hashes of their
    children.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a Merkle tree is shown in [Figure 2.1](#c02-fig-0001). The transactions
    contained within a block are shown at the bottom of the tree. Each leaf node of
    the tree contains the hash of the transaction below it, and all other nodes contain
    the hashes of their children's values concatenated together.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major advantages of a Merkle tree is that it allows transaction data
    to be securely summarized by the root hash of the Merkle tree. Due to hash function
    collision resistance, it is infeasible to find two versions of the Merkle tree
    that produce the same root hash. By including just the root hash of the Merkle
    tree within the block header, a blockchain ensures that all transactions contained
    by it are protected from modification by the blocks' chains.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic illustration of an example of a Merkle tree.](images/c02f001.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 2.1**](#R_c02-fig-0001): Example of a Merkle tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'Merkle trees also make it possible to prove that a transaction is contained
    within a Merkle tree or a given block without revealing any of the other transactions
    in that block. For example, proving the presence of Transaction 0 in the Merkle
    tree in [Figure 2.1](#c02-fig-0001) to someone who has access to the block header
    only requires revealing the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash 2-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the value of Transaction 0, it's possible to calculate Hash 0\. By combining
    Hash 0 and Hash 1, the user could calculate Hash 0-1\. With Hash 0-1 and Hash
    2-3, the user can calculate the value of Tx Root and compare it to the value of
    Tx Root in the block header.
  prefs: []
  type: TYPE_NORMAL
- en: 'These proofs are commonly used by Simplified Payment Verification (SPV) nodes
    to verify the inclusion of a transaction within a block without downloading the
    entire block body. These SPV nodes track the block headers and their connecting
    chains but verify transactions by requesting these proofs.  ##### Digital Signatures'
  prefs: []
  type: TYPE_NORMAL
- en: The discussion of digital signatures in the context of public key cryptography
    left out one crucial component. The data actually “encrypted” by the private key
    and “decrypted” by the public key is the hash of the message, not the message
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of hash functions helps to shrink the size of the digital signature
    by securely compressing it into a fixed-size value. Due to the hash function collision
    resistance, it is infeasible to find another message that would produce the same
    hash output and not invalidate the digital signature. As a result, hashing the
    message and comparing hashes is nearly as secure as comparing the messages themselves.  ####
    *Attacking Hash Functions*'
  prefs: []
  type: TYPE_NORMAL
- en: If a hash function is secure and collision-resistant, the only means of finding
    a hash collision is via a brute-force attack. With quantum computing, Grover's
    algorithm makes this attack easier to perform; however, it doesn't break hash
    function security.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Brute Force'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are designed to be collision-resistant, meaning that it is infeasible
    to find two inputs to the hash function that produce the same output. However,
    the pigeonhole principle states that it's possible to break collision resistance
    if you try hard enough.
  prefs: []
  type: TYPE_NORMAL
- en: A brute-force attack on a secure hash function is infeasible as long as the
    hash function has no exploitable vulnerabilities. A well-designed hash function
    that is a one-way, nonlocal function with a large state space is infeasible to
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: The Lisk blockchain provides an example of what can happen if a hash function
    does not fulfill all of these properties. In Lisk, account addresses were calculated
    by hashing a public key and truncating the result to a 64-byte address.[^(14)](#c02-note-0014)
  prefs: []
  type: TYPE_NORMAL
- en: With only 2^(64) potential addresses, a brute-force attack against this blockchain
    is entirely possible. At the time of writing, the Bitcoin network had a hash rate
    of over 2^(67) hashes per second, meaning that it could find multiple potential
    private keys for each address every second.
  prefs: []
  type: TYPE_NORMAL
- en: Lisk only tied a public key to an address when it created a transaction or voted
    for a delegate. This meant that accounts containing cryptocurrency could have
    that cryptocurrency extracted by the first person to find a valid private key
    for it. One of these vulnerable accounts contained over $48 million at the time
    of the vulnerability's discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'This vulnerability was discovered by an ethical hacker and reported to the
    Lisk developers, who issued a warning to users to generate a transaction that
    secured their accounts. However, due to the nature of the vulnerability, it''s
    impossible to determine if the user who did so for an account was the legitimate
    owner of any cryptocurrency that it contained.  ##### Grover''s Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Like Shor's algorithm, Grover's algorithm is designed to run on a quantum computer
    that threatens the security of distributed ledgers using classical cryptography.
    Unlike Shor's algorithm, Grover's algorithm threatens the security of modern hash
    functions but does not completely break them the way that Shor's algorithm breaks
    classical public key cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: On classical computers, the most efficient way to find a collision for a secure
    hash function is to search through a set of possible inputs equal to the size
    of the space of possible outputs. Hash functions are designed to make this infeasible
    by making the space of possible outputs too large to search efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Grover's algorithm makes the process of finding collisions more efficient for
    an attacker. On a classical computer, searching for a collision to a hash function
    with an N-bit output requires 2^N evaluations of the hash function. With Grover's
    algorithm and a quantum computer, this drops to `sqrt(2^N)` or `2^(N/2)` evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Grover''s algorithm does not completely break the security of classical
    hash functions since the desired level of security can be achieved by doubling
    the size of the output. SHA-256 is theoretically as equally secure against a quantum
    computer as SHA-128 is against a classical one. As quantum computers become more
    common, new hash functions will need to be developed with output lengths sufficient
    to protect against attacks using Grover''s algorithm.  ### Threat Modeling for
    Cryptographic Algorithms'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attacks against the public key cryptography and hash functions used in blockchain
    technology can have impacts on several areas of the STRIDE threat model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing:** Compromised private keys enable an attacker to masquerade as
    a user and generate blockchain transactions on their behalf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering:** A hash function collision in the blocks'' chains, a Merkle tree,
    or digital signature can break the immutability of the distributed ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information Disclosure:** A compromised private key could allow decryption
    of messages intended for the owner of a blockchain account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of Privileges:** A compromised private key provides unauthorized
    access to a user''s blockchain account.  ## Data Structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary function of the blockchain is data storage. The blockchain network
    cooperates to maintain a distributed, immutable digital ledger that tracks the
    history of the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, a blockchain may use a variety of different data structures
    to store information about the state of the network. However, the two most important
    data structures in blockchain are the transaction and the block.
  prefs: []
  type: TYPE_NORMAL
- en: '### Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: The transaction is the basic unit of data on the blockchain's digital ledger.
    When a blockchain user wants to transfer value or interact with a smart contract,
    they create a transaction and broadcast it to the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *What''s In a Transaction?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Different blockchains may have slightly different transaction formats; however,
    many of the core fields are the same. In Bitcoin, a transaction contains the following
    seven fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version:** The version of the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Witness Marker:** Indicates that the transaction uses Segregated Witness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags:** Flags are used for parsing if the witness marker is present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inputs:** An array of inputs to the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outputs:** An array of outputs from the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Witnesses:** An array of witnesses for the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lock Time:** The time for a time-locked transaction to remain locked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown, a Bitcoin transaction can include multiple different transfers of
    value. If Segregated Witness is used, each input has its own corresponding witness,
    which contains the digital signature that authorizes the use of that input within
    the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Bitcoin, Ethereum specifies a single intended recipient for a transaction,
    which is either an external address (i.e., a user account) or a smart contract
    address. Similar to Bitcoin, smart contracts can perform multiple actions within
    a single transaction, which are called *internal transactions*.  #### *Inside
    the Life Cycle of a Transaction*'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are not immediately added to the blockchain's immutable digital
    ledger. Transactions are added to the blockchain as part of blocks, and several
    stages occur between their creation and inclusion in the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: After being created, a transaction is broadcast to other nodes via the blockchain's
    peer-to-peer network. Each node stores pending transactions in a mempool for inclusion
    in later blocks.
  prefs: []
  type: TYPE_NORMAL
- en: When it is time to create a new block, a block producer draws from this pool
    of available transactions. Before including a transaction in a potential block,
    the creator checks it to ensure that it is valid and that it doesn't conflict
    with any other transactions currently on the blockchain (a *double spend*).
  prefs: []
  type: TYPE_NORMAL
- en: 'After a valid block is produced, the block creator transmits it to the rest
    of the blockchain network via the peer-to-peer network. Each of these nodes also
    validates the transactions within a block and, if they are valid, accepts the
    block. This involves adding the block to the digital ledger and performing state
    updates, such as determining the new allocation of cryptocurrency within the blockchain
    network or executing code on a smart contract platform.  #### *Attacking Transactions*'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are the basic building blocks of the blockchain and lie completely
    under the control of a blockchain user. Malicious transactions can be used in
    various attacks to exploit vulnerable blockchain nodes and other systems.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Malformed or Invalid Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the process of creating blocks and updating the ledger, blockchain
    nodes must read and validate the contents of every transaction. This ensures that
    double-spend attacks and other invalid transactions are not included on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain transactions are untrusted user input and may be intentionally malformed
    to exploit vulnerable nodes. If a vulnerable node processes an invalid transaction,
    it may crash or exhibit other undesirable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploitation of blockchain software with malformed transactions requires a
    vulnerability to exploit. Secure code development practices and code reviews are
    the best protection against this threat.  ###### *Case Study*'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain software is software, and all software has bugs. As a result, multiple
    vulnerabilities have been discovered in blockchain transaction validation code
    that have been or could have been exploited over the years.
  prefs: []
  type: TYPE_NORMAL
- en: One significant example was the 2010 Bitcoin hack, which created over 184 billion
    Bitcoin out of nothing.[^(15)](#c02-note-0015) This attack was enabled by an integer
    overflow vulnerability in the Bitcoin Core software. A malicious transaction performed
    two transfers that, when summed with some other values, overflowed to 50.51, which
    passed the transaction validation check.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the actual transfers were performed separately, which did not trigger
    the overflow and allowed a massive amount of Bitcoin to be transferred to the
    attacker''s account. This vulnerability was fixed soon afterward with a hard fork
    that patched the vulnerability and rolled back history to the block right before
    the attack.  ##### Transaction Malleability'
  prefs: []
  type: TYPE_NORMAL
- en: In the Bitcoin blockchain, transactions are uniquely identified by a transaction
    ID (txid). This txid is calculated by double-hashing the contents of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction malleability attacks took advantage of the fact that the unlocking
    script for a transaction is included in the hash, and the format of the script
    was not always properly validated. This could allow an attacker to modify the
    unlock script of a pending transaction without invalidating it.
  prefs: []
  type: TYPE_NORMAL
- en: This modification would change the txid of that transaction. If the sender of
    the transaction only uses the txid to identify transactions on the blockchain,
    the recipient could use transaction malleability to claim that they never received
    a payment. This could cause the sender to repeat the transaction, paying the recipient
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin addressed transaction malleability issues with Segregated Witness (SegWit),
    which moves witnesses out of transaction inputs. Since these digital signatures
    are no longer included in the txid calculation, this fixes the transaction malleability
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other blockchains have addressed the malleability issue through different means.
    For example, Bitcoin Cash (BCH) split from the Bitcoin network over a disagreement
    over SegWit. Instead, BCH has addressed various sources of transaction malleability
    in a series of independent upgrades.[^(16)](#c02-note-0016)  ###### *Case Study*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mt. Gox was a cryptocurrency exchange that went bankrupt. Before announcing
    bankruptcy, the exchange blamed frozen Bitcoin withdrawals on a repeated transaction
    malleability attack. By exploiting the transaction malleability bug and claiming
    that they had never received withdrawal transactions, attackers were able to extract
    386 Bitcoin (worth $203,000) from the exchange.[^(17)](#c02-note-0017)  #####
    Serialization Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization is a technique for converting an object or a collection of variables
    into a single series of bits for transmission or storage. If the structure of
    the object is well-defined, then the recipient of the data can deserialize it
    into the original object or set of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain nodes commonly serialize and deserialize untrusted user input, including
    transactions, blocks, and other data structures. This creates the potential for
    serialization vulnerabilities where deserialization code makes assumptions about
    the data that it receives and processes it without verifying these assumptions
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization vulnerabilities can result in integer and buffer overflow vulnerabilities,
    infinite loops or recursion, or other issues. Exploitation of these vulnerabilities
    can allow an attacker to execute malicious code or perform a denial-of-service
    (DoS) attack against vulnerable software.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization vulnerabilities are the result of failing to perform proper input
    validation on untrusted data before deserializing it. Verifying that serialized
    data follows the protocol and is valid before deserializing or processing it can
    protect against these vulnerabilities.  ###### *Case Study*'
  prefs: []
  type: TYPE_NORMAL
- en: In 2018, a serialization vulnerability was discovered in the NEO smart contract
    platform that could have enabled a denial-of-service (DoS) attack against the
    network.[^(18)](#c02-note-0018) The software's StackItem type can contain different
    types of data, including arrays, whose size and child elements would be serialized
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security researchers who discovered this vulnerability found that an array,
    *a*, could be added as an element of itself. Attempting to deserialize this would
    result in an infinite loop, causing a NEO node attempting to process the data
    to crash with a StackOverflowException.  ##### Block Explorer Injection'
  prefs: []
  type: TYPE_NORMAL
- en: Block explorers are websites that are designed to provide visibility into what
    is happening on the blockchain. Block explorers allow inspection of each block
    on the blockchain down to the contents of individual transaction inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain transactions have a defined structure, but they also have room for
    arbitrary data. For example, the Bitcoin genesis block is famous for containing
    a quote from the UK newspaper *The Times*, “*The Times* 03/Jan/2009 Chancellor
    on brink of second bailout for banks.”[^(19)](#c02-note-0019)
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to embed arbitrary data within a transaction, it is possible
    that an attacker could craft a transaction designed to exploit vulnerable block
    explorers or other software that processes transactions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a blockchain transaction could be designed to contain a cross-site
    scripting (XSS) exploit. If a vulnerable block explorer displays the malicious
    transaction, then it could expose visitors to an XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Injection attacks are a common attack vector for web applications, and this
    threat is only different due to the potential sources of the malicious user data.
    Performing input validation and implementing standard protections against XSS
    and other web application attacks can help to protect against this threat.  ######
    *Case Study*'
  prefs: []
  type: TYPE_NORMAL
- en: EtherDelta is a decentralized exchange that included a frontend application
    that showed information about the tokens that users could trade. As a frontend
    for a trading platform, it also had users enter their private keys to perform
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This frontend application contained an XSS vulnerability that could be exploited
    via malicious token contracts.[^(20)](#c02-note-0020) The vulnerable page extracted
    the name of a token from the contract code and embedded it within the web page.
    An attacker exploited this by creating a malicious contract whose name included
    JavaScript code that was designed to access the private keys entered by the user
    and send them to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker posted links to their contract on Discord and Slack. By stealing
    private keys from visitors to the site, the attacker was able to steal thousands
    of dollars from their compromised accounts.  ### Blocks'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are added to the blockchain's distributed ledger as parts of blocks.
    The blocks are created by block producers selected via the blockchain consensus
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Inside a Block*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, a blockchain block is made up of two parts. The block
    header is a fixed-size structure that contains metadata about the block and is
    the value covered by the previous block hash. While the contents of a block header
    can vary from one blockchain to another, a Bitcoin block header includes the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous block hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merkle root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time stamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficulty target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks add transactions to the distributed ledger, but these aren't included
    in the block header. The other part of the block is the block body, which contains
    these transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transactions in the body of a block are organized in the same order that they
    appear in the block''s Merkle tree. This enables anyone with access to the entire
    block to recompute the Merkle tree and compare its root value to the one stored
    within the block header. If they match, then the transactions in the block have
    presumably not been modified since the block was created.  #### *Attacking Blockchain
    Blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: Like transactions, blockchain blocks contain untrusted data and are processed
    by every node within the network as part of the ledger update process. While potential
    vulnerabilities in the block creation process are covered in a later chapter,
    note that the block data structure can be used in different attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Serialization Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'The potential for serialization vulnerabilities was mentioned in the discussion
    of attacks against transactions because they can contain serialized data. Similarly,
    block headers are serialized for transmission on the blockchain, potentially enabling
    a malformed block header to exploit vulnerable nodes.  ##### Bitcoin Leaf-Node
    Weakness'
  prefs: []
  type: TYPE_NORMAL
- en: Merkle trees are binary trees that summarize the transactions within a block
    in the transaction root. The number of layers within a Merkle tree depends on
    the number of transactions the block contains.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin Leaf-Node weakness took advantage of the fact that Bitcoin doesn't
    specify the depth of a Merkle tree. An attacker could theoretically construct
    a transaction that appears to be an inner node of a Merkle tree, which summarizes
    two transactions within a 64-byte hash.[^(21)](#c02-note-0021)
  prefs: []
  type: TYPE_NORMAL
- en: With a 72-bit brute-force attack, an attacker could craft a pair of transactions
    that would hash to this 64-byte hash. The attacker could then generate a valid
    proof to an SPV node that these child transactions were included in the blockchain
    when they were not.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 0.14 of the Bitcoin blockchain addressed this issue by disallowing
    any transactions that were exactly 64 bytes in length. Additionally, transactions
    valuable enough to make such an attack profitable would use a full node for verification,
    which does not rely on an SPV proof.  ### Threat Modeling for Data Structures'
  prefs: []
  type: TYPE_NORMAL
- en: 'The transactions and blocks used to organize data in the blockchain are under
    an attacker''s control. This allows them to be used in attacks against most areas
    of the STRIDE threat model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing:** Exploitation of injection vulnerabilities in block explorers
    and other frontend systems can result in the compromise of private keys. These
    can be used to masquerade as the user and perform transactions on their behalf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering:** Transaction malleability can allow an attacker to change the
    hash and transaction ID of unconfirmed transactions, changing how they are recorded
    on the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of Service:** Malformed transactions or blocks can be used to crash
    vulnerable nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of Privileges:** Theft of private keys through block explorer injection
    attacks can grant unauthorized access to user accounts.  ## Conclusion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter explored the security of the fundamentals of the blockchain ecosystem.
    The public key cryptography, hash functions, transactions, and blocks are the
    core components used to build blockchain's decentralized, immutable ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll step up a level to look at the protocols used to
    achieve consensus in the blockchain and to define how blocks are created and added
    to the digital ledger. These protocols use the cryptographic algorithms and data
    structures explored here to provide the vital functionality and security guarantees
    of the blockchain.  ## Notes'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  [1](#R_c02-note-0001).  `[www.ise.io/casestudies/ethercombing](http://www.ise.io/casestudies/ethercombing)`
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#R_c02-note-0002).  `[https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961](https://medium.com/mycrypto/disclosure-key-generation-vulnerability-found-on-walletgenerator-net-potentially-malicious-3d8936485961)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3](#R_c02-note-0003).  `[https://blog.bitmex.com/call-me-ishmael](https://blog.bitmex.com/call-me-ishmael)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4](#R_c02-note-0004).  `[https://twitter.com/alistairmilne/status/1266037520715915267](https://twitter.com/alistairmilne/status/1266037520715915267)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[5](#R_c02-note-0005).  `[https://medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin-635fe051a752](https://medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin-635fe051a752)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[6](#R_c02-note-0006).  `[https://blog.chainalysis.com/reports/money-supply](https://blog.chainalysis.com/reports/money-supply)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[7](#R_c02-note-0007).  `[https://thecharlatan.ch/List-Of-Hardware-Wallet-Hacks](https://thecharlatan.ch/List-Of-Hardware-Wallet-Hacks)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[8](#R_c02-note-0008).  `[https://therecord.media/hacker-steals-55-million-from-bzx-defi-platform](https://therecord.media/hacker-steals-55-million-from-bzx-defi-platform)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9](#R_c02-note-0009).  `[www.europol.europa.eu/media-press/newsroom/news/ten-hackers-arrested-for-string-of-sim-swapping-attacks-against-celebrities](http://www.europol.europa.eu/media-press/newsroom/news/ten-hackers-arrested-for-string-of-sim-swapping-attacks-against-celebrities)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#R_c02-note-0010). `[https://medium.com/easify-network/easyfi-security-incident-pre-post-mortem-33f2942016e9](https://medium.com/easify-network/easyfi-security-incident-pre-post-mortem-33f2942016e9)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#R_c02-note-0011). `[www.bleepingcomputer.com/news/security/clipboard-hijacker-malware-monitors-23-million-bitcoin-addresses](http://www.bleepingcomputer.com/news/security/clipboard-hijacker-malware-monitors-23-million-bitcoin-addresses)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#R_c02-note-0012). `[www.universetoday.com/36302/atoms-in-the-universe](http://www.universetoday.com/36302/atoms-in-the-universe)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#R_c02-note-0013). `[www.bbc.com/news/technology-16543497](http://www.bbc.com/news/technology-16543497)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#R_c02-note-0014). `[https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations](https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-steal-millions-in-264-operations)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[15](#R_c02-note-0015). `[https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug](https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16](#R_c02-note-0016). `[https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279](https://bitcoincashresearch.org/t/transaction-malleability-malfix-segwit-sighash-noinput-sighash-spendanyoutput-etc/279)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17](#R_c02-note-0017). `[www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability](http://www.coindesk.com/markets/2014/03/27/study-mt-gox-may-have-lost-just-386-btc-due-to-transaction-malleability)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18](#R_c02-note-0018). `[https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network](https://blog.360totalsecurity.com/en/alert-dos-vulnerability-is-discovered-to-crash-the-entire-neo-network)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[19](#R_c02-note-0019). `[https://en.bitcoin.it/wiki/Genesis_block](https://en.bitcoin.it/wiki/Genesis_block)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20](#R_c02-note-0020). `[https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0](https://medium.com/hackernoon/how-one-hacker-stole-thousands-of-dollars-worth-of-cryptocurrency-with-a-classic-code-injection-a3aba5d2bff0)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[21](#R_c02-note-0021). `[https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
