- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_3](https://doi.org/10.1007/978-1-4842-4847-8_3)
  prefs: []
  type: TYPE_NORMAL
- en: 3. Creating Your Own Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Elad Elrom^([1](#Aff2) )(1)New York, NY, USAIn this chapter, I will cover how
    to build your very own blockchain P2P network. This is a seven-step process, so
    in each section I’ll start with a brief introduction followed by an exercise.
    You can download the code for each of the following exercises from GitHub and
    follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic P2P network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering miners and creating new blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a name-value database, LevelDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a private-public wallet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using API services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will drill down into the code, and the examples in this chapter
    are simple in nature and intended for learning purposes. They will give you a
    better understanding of blockchain and the elements that are needed to achieve
    a fully working prototype of a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s not feasible to create a full production-grade blockchain in this short
    instructional chapter; however, I will give you the fundamentals for creating
    a basic working one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Basic P2P Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in creating your blockchain is to create a P2P network. As you
    saw in previous chapters, the P2P network was the key to making blockchain work.
    In cryptocurrency the P2P network can help prevents the double spending issue
    for PoW and is also the core architecture behind PoS. In a blockchain, it allows
    you to sync any data needed on a network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Peer-to-peer (P2P) is a type of computer network that uses a distributed architecture.
    Each peer or node shares the workload and is equal to the other peers, meaning
    there should not be any privileged peer.
  prefs: []
  type: TYPE_NORMAL
- en: '*“We have proposed a system for electronic transactions without relying on
    trust. We started with the usual framework of coins made from digital signatures,
    which provides strong control of ownership, but is incomplete without a way to
    prevent double-spending. To solve this, we proposed a peer-to-peer network using
    proof-of-work to record a public history of transactions that quickly becomes
    computationally impractical for an attacker to change if honest nodes control
    a majority of CPU proof-of-worker.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—*Bitcoin: A Peer-to-Peer Electronic Cash System*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, I will show you how to create your blockchain with Node.js,
    but you can do this with any other programming language because the principles
    are the same. You will be setting up your machine with the WebStorm integrated
    development environment (IDE) that will be used throughout this book. To download
    WebStorm, go to [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)
    . WebStorm offers a 30-day trial; however, it’s not necessary, and you can choose
    any IDE of your liking and achieve the same results. At the time of writing, the
    WebStorm version is 2018.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Basic P2P Network Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Setting Up Your Project**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will set up your project and create a basic P2P network
    to send and receive messages. After you are able to send and receive messages,
    you will be able to create a block class and a chained library and tie several
    blocks together to create a blockchain. You will need Node.js installed on your
    machine; there are many ways to install it. One easy way is through the prebuilt
    installer manager; find one that fits your platform here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: After you have downloaded WebStorm, you can create a new project. Select File
    ➤ Create New Project ➤ Node.js Express App ➤ CREATE. In Location, call the project
    **Blockchain**, and click Create (see Figure [3-1](#Fig1)).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-1
  prefs: []
  type: TYPE_NORMAL
- en: WebStorm  , creating a new project wizard
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a P2P Network**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder and name it **Blockchain**. Then create a file and name it
    p2p.js and write the following code. Alternatively, you could just clone the code
    from GitHub.https://github.com/Apress/the-blockchain-developer/blob/master/chapter2/step1/p2p.js>
    git clone https://github.com/Apress/the-blockchain-developer**Tip** You can clone
    the entire code listings in this book from GitHub. Use the following Terminal
    command: > git clone [https://​github.​com/​Apress/​the-blockchain-developer/​chapter3/​step1/​](https://github.com/Apress/the-blockchain-developer/chapter3/step1/)const
    crypto = require(''crypto''),    Swarm = require(''discovery-swarm''),    defaults
    = require(''dat-swarm-defaults''),    getPort = require(''get-port'');const peers
    = {};let connSeq = 0;let channel = ''myBlockchain'';const myPeerId = crypto.randomBytes(32);console.log(''myPeerId:
    '' + myPeerId.toString(''hex''));const config = defaults({    id: myPeerId,});const
    swarm = Swarm(config);(async () => {    const port = await getPort();    swarm.listen(port);    console.log(''Listening
    port: '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info)
    => {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }        conn.on(''data'', data => {            let
    message = JSON.parse(data);            console.log(''----------- Received Message
    start -------------'');            console.log(                ''from: '' + peerId.toString(''hex''),                ''to:
    '' + peerId.toString(message.to),                ''my: '' + myPeerId.toString(''hex''),                ''type:
    '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');        });        conn.on(''close'', ()
    => {            console.log(`Connection ${seq} closed, peerId: ${peerId}`);            if
    (peers[peerId].seq === seq) {                delete peers[peerId]            }        });        if
    (!peers[peerId]) {            peers[peerId] = {}        }        peers[peerId].conn
    = conn;        peers[peerId].seq = seq;        connSeq++    })})();setTimeout(function(){    writeMessageToPeers(''hello'',
    null);}, 10000);writeMessageToPeers = (type, data) => {    for (let id in peers)
    {        console.log(''-------- writeMessageToPeers start -------- '');        console.log(''type:
    '' + type + '', to: '' + id);        console.log(''-------- writeMessageToPeers
    end ----------- '');        sendMessage(id, type, data);    }};writeMessageToPeerToId
    = (toId, type, data) => {    for (let id in peers) {        if (id === toId) {            console.log(''--------
    writeMessageToPeerToId start -------- '');            console.log(''type: '' +
    type + '', to: '' + toId);            console.log(''-------- writeMessageToPeerToId
    end ----------- '');            sendMessage(id, type, data);        }    }};sendMessage
    = (id, type, data) => {    peers[id].conn.write(JSON.stringify(        {            to:
    id,            from: myPeerId,            type: type,            data: data        }    ));};Listing
    3-1'
  prefs: []
  type: TYPE_NORMAL
- en: Shows Node.js P2P Network initial code to send and receive messages
  prefs: []
  type: TYPE_NORMAL
- en: To get this example to work, you need to run two instances of this code. You
    can run it from two separate machines as would be done in real life, or you could
    run two instances from the same machine via Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code needs to find and connect peers, deploy servers that are used to
    discover other peers, and get an available TCP port. That is done by utilizing
    these three libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**discovery-swarm**: Used to create a network swarm that uses discovery-channel
    to find and connect peers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dat-swarm-defaults**: Deploys servers that are used to discover other peers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**get-port**: Gets available TCP ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To install these libraries, run this command:> npm install crypto discovery-swarm
    dat-swarm-defaults get-port --saveNow that are libraries are installed, open two
    Terminal instances and navigate to the location of the library. Run the following
    command:> node p2p.jsTo run the code from the clone library on GitHub, navigate
    to the code, follow these Terminal commands to install the libraries, and run
    a node.js instance attaching our p2p.js code:> cd [location]/chapter2/step2> npm
    install> node p2p.jsFigure [3-2](#Fig2) shows the output of running the Node.js
    code.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-2
  prefs: []
  type: TYPE_NORMAL
- en: P2P running two peers in Terminal
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in Figure [3-2](#Fig2), the network generated a random peer ID
    for your machine and picked a random port utilizing the discovery libraries you
    installed. Then the code was able to discover other peers on the network and send
    and receive messages to and from these peers. You are now connected on a P2P network
    with other users.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the code to better understand how it all works. The first
    lines of code are an import statement  for the open source libraries that you
    are using in your code.  const crypto = require('crypto'),    Swarm = require('discovery-swarm'),    defaults
    = require('dat-swarm-defaults'),    getPort = require('get-port');
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you use const to set your variable instead of let. You want to ensure
    there is no rebinding, and you always refer to the same object, so selecting const
    is advised according to best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you set your variables to hold an object with the peers and connection
    sequence, and you choose a channel name that all your nodes will be connecting
    to. You also set a randomly generated peer ID for your peer utilizing the crypto
    library.const peers = {};let connSeq = 0;let channel = ''myBlockchain'';const
    myPeerId = crypto.randomBytes(32);console.log(''myPeerId: '' + myPeerId.toString(''hex''));Next,
    you generate a config object that holds your peer ID. Then you use the config
    object to initialize the swarm library. The swarm library can be found here: [https://github.com/mafintosh/discovery-swarm](https://github.com/mafintosh/discovery-swarm)
    . What it does is create a network swarm that uses the discovery-channel library
    to find and connect peers on a UCP/TCP network.const config = defaults({    id:
    myPeerId,});const swarm = Swarm(config);Now that everything is set up and ready,
    you will be creating a Node.js async function to continuously monitor swarm.on
    event messages.(async () => {You listen on the random port selected, and once
    a connection is made to the peer, you use setKeepAlive to ensure the network connection
    stays with other peers.    const port = await getPort();    swarm.listen(port);    console.log(''Listening
    port: '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info)
    => {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }Once you receive a data message on the P2P network,
    you parse the data using JSON.parse, which is a Node.js native command, so you
    do not need to include any import statement. This command decodes your message
    back into an object, and the toString command  converts bytes into a readable
    string data type.        conn.on(''data'', data => {            let message =
    JSON.parse(data);            console.log(''----------- Received Message start
    -------------'');            console.log(                ''from: '' + peerId.toString(''hex''),                ''to:
    '' + peerId.toString(message.to),                ''my: '' + myPeerId.toString(''hex''),                ''type:
    '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');        });You also listen to a close event  ,
    which will indicate that you lost a connection with peers, so you can take action,
    such as delete the peers from your peers list object.        conn.on(''close'',
    () => {            console.log(`Connection ${seq} closed, peerId: ${peerId}`);            if
    (peers[peerId].seq === seq) {                delete peers[peerId]            }        });        if
    (!peers[peerId]) {            peers[peerId] = {}        }        peers[peerId].conn
    = conn;        peers[peerId].seq = seq;        connSeq++    })})();Here, you will
    be using a setTimeout Node.js native function to send a message after ten seconds
    to any available peers. The first message you will be sending is just an “hello”
    message. You create methods called writeMessageToPeers  and writeMessageToPeerToId
    to handle your object, so it’s formatted with the data you want to transmit and
    who you want to send it to.setTimeout(function(){    writeMessageToPeers(''hello'',
    null);}, 10000);The writeMessageToPeers method  will be sending messages to all
    the connected peers.writeMessageToPeers = (type, data) => {    for (let id in
    peers) {        console.log(''-------- writeMessageToPeers start -------- '');        console.log(''type:
    '' + type + '', to: '' + id);        console.log(''-------- writeMessageToPeers
    end ----------- '');        sendMessage(id, type, data);    }};Additionally, you
    will be creating another method, writeMessageToPeerToId, that will be sending
    the message to a specific peer ID, in case you want to communicate with just one
    specific peer.writeMessageToPeerToId = (toId, type, data) => {    for (let id
    in peers) {        if (id === toId) {            console.log(''-------- writeMessageToPeerToId
    start -------- '');            console.log(''type: '' + type + '', to: '' + toId);            console.log(''--------
    writeMessageToPeerToId end ----------- '');            sendMessage(id, type, data);        }    }};Lastly,
    sendMessage is a generic method that you will be using to send a message formatted
    with the params you would like to pass and includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**to/from**: The peer ID you are sending the message from and to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type**: The message type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**data**: Any data you would like to share on the P2P network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These params will be useful once you share your blockchain block. Notice that
    the message you pass needs to be a string and cannot be an object, so you are
    using a JSON.stringify native function to encode your messages before sharing
    them over the P2P network.sendMessage = (id, type, data) => {    peers[id].conn.write(JSON.stringify(        {            to:
    id,            from: myPeerId,            type: type,            data: data        }    ));};'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you downloaded and installed the WebStorm IDE and created
    your project, which includes a basic P2P network. You were able to keep a connection
    to a TCP network random port and send and receive messages including encoding
    and decoding these messages. You are ready to move to the next exercise and send
    an actual block between each node on your network.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Genesis Block and Sharing Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next exercise, you will be creating block objects that you can share
    between your nodes. But before you do that, let’s take a closer look at the Block
    object. The Block object is not the same for every blockchain. Different blockchains
    utilize different types of Block objects; you will be using a Block object similar
    to bitcoin; I covered in details during Chapter [2](475651_1_En_2_Chapter.xhtml).
    To better understand the architecture, take a look at a Unified Modeling Language
    (UML) diagram of the Block and the BlockHeader objects you will be using in the
    next exercise, as shown in Figure [3-3](#Fig3).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-3
  prefs: []
  type: TYPE_NORMAL
- en: Block and BlockHeader UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, from Chapter [2](475651_1_En_2_Chapter.xhtml), the Block object
    contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '***index***: GenesisBlock is our first block, we assign the block index with
    the value of 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***txns***: This is the raw transaction in the block. I don’t want to focus
    on just cryptocurrencies in this chapter, so think of this as any type of data
    you want to store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Included in the Block object is the BlockHeader object, which contains the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Version***: At the time of writing, there are four block versions. Version
    1 is the genesis block (2009), and version 2 is a soft fork of bitcoin core 0.7.0
    (2012). Version 3 blocks were a soft fork of bitcoin core 0.10.0 (2015). Version
    4 blocks are BIP65 in bitcoin core 0.11.2 (2015).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Previous block header hash***: This is an SHA-256 (Secure Hash Algorithm)
    hash function of the previous block’s header. It ensures that the previous block
    cannot be changed as this block needs to be changed as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Merkle root hash***: A Merkle tree is a binary tree that holds all the hashed
    pairs of the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Time***: This is the Unix epoch time when the miner started hashing the
    header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you recall, bitcoin also includes a difficulty property for the miners that
    gets recalculated every 2,016 blocks. Here you won’t use the nBits and nounce
    params, as you are not doing PoW.
  prefs: []
  type: TYPE_NORMAL
- en: '***nounce***: The nonce in a bitcoin block is a 32-bit (4-byte) field whose
    value is adjusted by miners so that the hash of the block will be less than or
    equal to the current target of the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***nBits***: This refers to the target. The target is a 256-bit number and
    inversely proportional to the difficulty. It is recalculated every 2,016 blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of P2P communication, the flow of blocks between each peer on the P2P
    network consists of requesting the latest block from a peer on the network and
    then receiving a block request. Figure [3-4](#Fig4) shows the flow diagram.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-4
  prefs: []
  type: TYPE_NORMAL
- en: Flow diagram of P2P communications requesting latest block and receiving latest
    block
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the architecture and the flow of blocks in the P2P network,
    in the following exercise you will be sending and requesting blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: P2P Network Sending Blocks Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Setting** **Up a** **Block Class and Chain Library**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will create your blockchain. The blockchain consists
    of two files: block.js and chain.js. The file Block.js will hold the block class
    object, and chain.js will be the glue with methods to handle the interactions
    with the blocks. In terms of the Block object, you will be creating properties
    similar to the properties that bitcoin core holds. Take a look at Listing [3-2](#PC17),
    block.js file include Block and BlockHeader objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-2. block.js*exports.BlockHeader = class BlockHeader {    constructor(version,
    previousBlockHeader, merkleRoot, time) {        this.version = version;        this.previousBlockHeader
    = previousBlockHeader;        this.merkleRoot = merkleRoot;        this.time =
    time;    }};exports.Block = class Block {    constructor(blockHeader, index, txns)
    {        this.blockHeader = blockHeader;        this.index = index;        this.txns
    = txns;    }}As you can see, chain.js contains the first block, which is called
    the *genesis* block, as well as a method to receive the entire blockchain object,
    add a block, and retrieve a block. Note that you will be adding a library called
    moment  to save the time in a Unix time format in your chain.js library. To do
    so, install moment with npm.> npm install moment --save'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the block.js file created, you can create the chain.js class;
    see Listing [3-3](#PC19).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-3. chain.js*let Block =  require("./block.js").Block,    BlockHeader
    =  require("./block.js").BlockHeader,    moment = require("moment");let getGenesisBlock
    = () => {    let blockHeader = new BlockHeader(1, null, "0x1bc3300000000000000000000000000000000000000000000",
    moment().unix());    return new Block(blockHeader, 0, null);};let getLatestBlock
    = () => blockchain[blockchain.length-1];let addBlock = (newBlock) => {    let
    prevBlock = getLatestBlock();    if (prevBlock.index < newBlock.index && newBlock.blockHeader.previousBlockHeader
    === prevBlock.blockHeader.merkleRoot) {        blockchain.push(newBlock);    }}let
    getBlock = (index) => {    if (blockchain.length-1 >= index)        return blockchain[index];    else        return
    null;}const blockchain = [getGenesisBlock()];if (typeof exports != ''undefined''
    ) {    exports.addBlock = addBlock;    exports.getBlock = getBlock;    exports.blockchain
    = blockchain;    exports.getLatestBlock = getLatestBlock;}'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a block object that is included in chain.js. Your library can create
    your genesis block and add a block to your blockchain object. You also will be
    able to send and request blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in your P2P network class, you can use the chain.js file you created.
    First you need to import the class chain.js.const chain =  require("./chain");Then
    you can define a message type to request and receive the latest block. When you
    send messages in your P2P network, you need to be able to figure out the purpose
    of messages. By using a MessageType property  , you can define a switch mechanism
    so different messages types will be used for different functions.let MessageType
    = {    REQUEST_LATEST_BLOCK: ''requestLatestBlock'',    LATEST_BLOCK: ''latestBlock''};Once
    a connection data event message is received, you can create your switch code to
    handle the different types of requests, as shown in Listing [3-4](#PC22).switch
    (message.type) {    case MessageType.REQUEST_BLOCK:        console.log(''-----------REQUEST_BLOCK-------------'');        let
    requestedIndex = (JSON.parse(JSON.stringify(message.data))).index;        let
    requestedBlock = chain.getBlock(requestedIndex);        if (requestedBlock)        writeMessageToPeerToId(peerId.toString(''hex''),
    MessageType.RECEIVE_NEXT_BLOCK, requestedBlock);        else            console.log(''No
    block found @ index: '' + requestedIndex);        console.log(''-----------REQUEST_BLOCK-------------'');        break;    case
    MessageType.RECEIVE_NEXT_BLOCK:        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        chain.addBlock(JSON.parse(JSON.stringify(message.data)));        console.log(JSON.stringify(chain.blockchain));        let
    nextBlockIndex = chain.getLatestBlock().index+1;        console.log(''-- request
    next block @ index: '' + nextBlockIndex);        writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: nextBlockIndex});        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        break;}Listing
    3-4'
  prefs: []
  type: TYPE_NORMAL
- en: Message Switch and Handlers
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you will set a timeout request that will send a request to retrieve
    the latest block every 5,000 milliseconds (5 seconds).setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: chain.getLatestBlock().index+1});}, 5000);'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you were able to generate your genesis block and create a
    mechanism to request and receive blocks by sending messages requests. The ability
    to request and receive blocks allows you to sync new peers that enter the P2P
    network. You also need a sync for any additional blocks you generate after the
    genesis block creation.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Miners and Creating New Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you have a basic P2P network, and you are able to connect peers
    in the network, create a genesis block, and send and receive blocks. The next
    step is being able to generate new blocks. As you saw in Chapter [2](475651_1_En_2_Chapter.xhtml),
    proof of work is based on creating a mathematical problem and rewarding miners
    that find the solution for the problem first. However, in this example, you will
    take an approach of proof of stake (PoS)  where you trust each miner to generate
    your blocks. Each peer will register as a miner and will take a turn to mine a
    block. You can see an overview of each miner generating a block in Figure [3-5](#Fig5).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-5
  prefs: []
  type: TYPE_NORMAL
- en: Your blockchain handles mining using a simple PoS mechanism
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, before you start your next exercise, revisit Figure [3-4](#Fig4) to
    better understand your flow. The flow shows how your P2P network handles peer
    communications requesting the latest block and receiving the latest block. In
    the next exercise, you will register your peers as miners and create new blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Register Miners and Creating New Blocks Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Register Miners**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will register miners and create new blocks. You can download
    the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To automate the process of generating a block every x number of minutes, you
    can use a Node.js library called cron, which is similar to the Linux library that
    automates tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To install the cron open source library, run the following command:> npm install
    cron --saveNext, in your p2p.js file, you will create two variables to keep track
    of the registered miners as well as who mined the last block so you can assign
    the next block to the next miner.let registeredMiners = [];let lastBlockMinedBy
    = null;You are also going to add two messages types.
  prefs: []
  type: TYPE_NORMAL
- en: REQUEST_ALL_REGISTER_MINERS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REGISTER_MINER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'let MessageType = {    REQUEST_BLOCK: ''requestBlock'',    RECEIVE_NEXT_BLOCK:
    ''receiveNextBlock'',    RECEIVE_NEW_BLOCK: ''receiveNewBlock'',    REQUEST_ALL_REGISTER_MINERS:
    ''requestAllRegisterMiners'',    REGISTER_MINER: ''registerMiner''};Before you
    register your peers as miners, you will request to receive all the existing registered
    miners in the network, and then you will add your peer as a miner in a registeredMiners
    object. You do that by running a timer to update your miners every five seconds.setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_ALL_REGISTER_MINERS,
    null);}, 5000);Now, that have an automated timeout command that can point to a
    handler to update the list of registered miners you can also automate a command
    to register your peer as a miner;setTimeout(function(){    registeredMiners.push(myPeerId.toString(''hex''));    console.log(''----------Register
    my miner --------------'');    console.log(registeredMiners);    writeMessageToPeers(MessageType.REGISTER_MINER,
    registeredMiners);    console.log(''---------- Register my miner --------------'');},
    7000);In your switch command, you want to modify the code to be able to set handlers
    for incoming messages regarding the registrations of miners. You want to keep
    track of the registered miners as well as handle a message once a new block is
    mined. See Listing [3-5](#PC28) for the miner’s handlers.case MessageType.REQUEST_ALL_REGISTER_MINERS:        console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);        writeMessageToPeers(MessageType.REGISTER_MINER, registeredMiners);        registeredMiners
    = JSON.parse(JSON.stringify(message.data));        console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);        break;    case MessageType.REGISTER_MINER:        console.log(''-----------REGISTER_MINER-------------
    '' + message.to);        let miners = JSON.stringify(message.data);        registeredMiners
    = JSON.parse(miners);        console.log(registeredMiners);        console.log(''-----------REGISTER_MINER-------------
    '' + message.to);        break;Listing 3-5'
  prefs: []
  type: TYPE_NORMAL
- en: Miner’s Handlers
  prefs: []
  type: TYPE_NORMAL
- en: '**Unregister Miners**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to unregister a miner once a connection with the miner is closed
    or lost.    console.log(`Connection ${seq} closed, peerId: ${peerId}`);    if
    (peers[peerId].seq === seq) {        delete peers[peerId];        console.log(''---
    registeredMiners before: '' + JSON.stringify(registeredMiners));        let index
    = registeredMiners.indexOf(peerId);        if (index > -1)            registeredMiners.splice(index,
    1);        console.log(''--- registeredMiners end: '' + JSON.stringify(registeredMiners));    }});'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mine a New Block**'
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to bitcoin, which generates a block every 10 minutes, your blockchain
    will be improved and will generate a block every 30 seconds. To achieve that,
    you already installed the open source cron library for Node.js. The cron library
    works the same as the Linux cron. You can utilized the cron library to set how
    often to call the same code again, which will be used to call your miners every
    30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, first include the library in your code’s import statement on top of
    the p2p.js file.let CronJob = require('cron').CronJob;
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can set your cronjob  to run every 30 seconds, and job.start(); will
    start the job, as shown in Listing [3-6](#PC31).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-6. crobjob to Mine a New Block*const job = new CronJob(''30 ∗ ∗
    ∗ ∗ ∗'', function() {    let index = 0; // first block    if (lastBlockMinedBy)
    {        let newIndex = registeredMiners.indexOf(lastBlockMinedBy);        index
    = ( newIndex+1 > registeredMiners.length-1) ? 0 : newIndex + 1;    }    lastBlockMinedBy
    = registeredMiners[index];    console.log(''-- REQUESTING NEW BLOCK FROM: '' +
    registeredMiners[index] + '', index: '' + index);    console.log(JSON.stringify(registeredMiners));    if
    (registeredMiners[index] === myPeerId.toString(''hex'')) {        console.log(''-----------create
    next block -----------------'');        let newBlock = chain.generateNextBlock(null);        chain.addBlock(newBlock);        console.log(JSON.stringify(newBlock));        writeMessageToPeers(MessageType.RECEIVE_NEW_BLOCK,
    newBlock);        console.log(JSON.stringify(chain.blockchain));        console.log(''-----------create
    next block -----------------'');    }});job.start();Reviewing the code, notice
    that the first block’s index is 0, so after the first block is mined, lastBlockMinedBy
    will be set, and you will be requesting the next block from your next miner.let
    newIndex = registeredMiners.indexOf(lastBlockMinedBy);index = ( newIndex+1 > registeredMiners.length-1)
    ? 0 : newIndex + 1;To generate and add a new block, you will be calling chain
    generateNextBlock and addBlock. Lastly, you will broadcast the new block to all
    the connected peers.let newBlock = chain.generateNextBlock(null);chain.addBlock(newBlock);writeMessageToPeers(MessageType.RECEIVE_NEW_BLOCK,
    newBlock);In your code, your switch will handle the new incoming blocks.case MessageType.RECEIVE_NEW_BLOCK:    if
    ( message.to === myPeerId.toString(''hex'') && message.from !== myPeerId.toString(''hex''))
    {        console.log(''-----------RECEIVE_NEW_BLOCK------------- '' + message.to);        chain.addBlock(JSON.parse(JSON.stringify(message.data)));        console.log(JSON.stringify(chain.blockchain));        console.log(''-----------RECEIVE_NEW_BLOCK-------------
    '' + message.to);    }    break;To see this code in action, run three instances
    of your code.> node p2p.jsYou can see the messages of registering each peer as
    a miner, as well as your code starting to mine blocks every 30 seconds in order,
    as shown in Figure [3-6](#Fig6).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig6_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig6_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-6
  prefs: []
  type: TYPE_NORMAL
- en: Code registering miners and generating new blocks
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you were able to register your peers as a miners, generate
    new blocks, and share blocks with other peers; you used a simple PoS for the consensus
    mechanism and were able to test the functionality by creating three peers. The
    consensus mechanism is simple and does not take into account every use case that
    can happen or security. In the next step, you will save your blocks in a LevelDB
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Blocks in LevelDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run your blockchain for a few hours, you will notice that the number
    of blocks created grows, which can become a problem as currently these blocks
    are stored in your computer’s memory cache. As you add more and more blocks, the
    memory usage will grow, and eventually your code will crash. Further, without
    storing your blocks in a database, you will not be able to start and stop your
    P2P network, as the blocks are not saved.
  prefs: []
  type: TYPE_NORMAL
- en: To accommodate these use cases and others, you will be using a LevelDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A LevelDB database stores name-value pairs in what is called a *level-up* and
    *level-down* fashion. It is an ideal option for blockchain networks. In fact,
    bitcoin uses LevelDB to store not only block information but also transaction
    information. See [https://github.com/bitcoin-core/leveldb](https://github.com/bitcoin-core/leveldb)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Leveldb to Store Blocks Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LevelDB**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will implement a database to store your blocks. You can
    download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain)
    . Remember to run the install command to retrieve all the npm modules.> npm installTo
    get started on your own from the previous step, you will be using a Node.js LevelDB
    wrapper so you can communicate with LevelDB through your code. Install the library
    via npm.>  npm install level -saveNext, make a directory where you will be saving
    the database.> mkdir dbYou can now implement the database. In your chain.js library,
    you will add some code to save your block in the LevelDB database, as shown in
    Listing [3-7](#PC39).let level = require(''level''),    fs = require(''fs'');let
    db;let createDb = (peerId) => {    let dir = __dirname + ''/db/'' + peerId;    if
    (!fs.existsSync(dir)){        fs.mkdirSync(dir);        db = level(dir);        storeBlock(getGenesisBlock());    }}Listing
    3-7'
  prefs: []
  type: TYPE_NORMAL
- en: Storing Blocks in LevelDB
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you use the __dirname Node.js  native class to give you the
    directory path location because you need the full path to save your database.
  prefs: []
  type: TYPE_NORMAL
- en: Because you are running multiple instances of your P2P network on the same machine,
    you cannot use the same path for each peer because the database needs to be separate.
    What you can do is set each database’s location in a separate path location using
    the folder name as the name of your peer ID; then each database can be stored
    in the db folder. Also notice that you save the first block, getGenesisBlock().
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you create a storeBlock method  to store the new block.let storeBlock
    = (newBlock) => {    db.put(newBlock.index, JSON.stringify(newBlock), function
    (err) {        if (err) return console.log(''Ooops!'', err) // some kind of I/O
    error        console.log(''--- Inserting block index: '' + newBlock.index);    })}When
    you generate a new block using the generateNextBlock method  , you can now store
    the block in the LevelDB database.storeBlock(newBlock);You are also going to add
    a method to be able to retrieve a block from the LevelDB database.let getDbBlock
    = (index, res) => {    db.get(index, function (err, value) {        if (err) return
    res.send(JSON.stringify(err));        return(res.send(value));    });}Make sure
    you expose the createDb and getDbBlock methods  .if (typeof exports != ''undefined''
    ) {    exports.createDb = createDb;    exports.getDbBlock = getDbBlock;}Lastly,
    in your P2P network code, all you need to do is create a database once you start
    the code.chain.createDb(myPeerId.toString(''hex''));To see the code in action,
    run an instance of the P2P network.> node p2p.jsYou can monitor the database’s
    data in the db folder using the tail command with the -f flag. Terminal will stay
    open and can show you new blocks as they are being generated (see the output in
    Figure [3-7](#Fig7)).> cd step4/db/[our peer Id]> tail –f 000003.log![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-7
  prefs: []
  type: TYPE_NORMAL
- en: tail command with the LevelDB database showing new blocks being generated
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you created a LevelDB database. You are storing your blocks
    so you will be able to retrieve them instead of relying on your cache memory.
    I am keeping things simple; if this were a real working blockchain, you would
    implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mitigate all the possible security risks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store and retrieve your blocks from the LevelDB database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to restore LevelDB’s entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean old databases because new ones are created on every init.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a Blockchain Wallet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cryptocurrency, a wallet is necessary in order to reward miners for generating
    blocks as well as to be able to create transactions and send transactions. In
    this section, you will create a wallet. You need to create a combination of public
    and private keys not just to authenticate a user but so you can store and retrieve
    data that the user owns. You will create a wallet with public and private keys.
  prefs: []
  type: TYPE_NORMAL
- en: In bitcoin, the wallet’s original software is the bitcoin core protocol you
    downloaded in Chapter [2](475651_1_En_2_Chapter.xhtml); it needs the entire ledger
    of all transactions since 2009, which is more than 150 GB at the time of writing.
    For that reason, most wallets in use are “light” wallets or what’s called *simplified
    payment verification* (SPV)  wallets that sync to bitcoin core. In blockchain,
    there are many different wallets available, from online all the way to a paper
    wallet where you write your private key on a piece of paper.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, let’s take a quick look at how you can communicate with a
    bitcoin wallet. As you recall, in Chapter [2](475651_1_En_2_Chapter.xhtml) you
    were able to get the balance of a certain bitcoin wallet. To better understand
    wallets, you can create a bitcoin wallet using the bitcoin core.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to run the bitcoin daemon.> bitcoind –printtoconsoleNext, you
    can request an address.> bitcoin-cli help getnewaddressThen, you are able to dump
    your private keys into a text file.> bitcoin-cli dumpwallet ~/mywallet.txtYou
    can get the location of your private key and view the key.> vim /Users/[location]/mywallet.txtFor
    reference, check the C++ bitcoin core wallet code here:> vim /[Bitcoin Core Location]/bitcoin/src/wallet/init.cpp
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Wallet Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Create a Blockchain Wallet**'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will generate public-private keys to be used for your
    wallet. You can download the complete exercise from [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain)
    and run the npm install command. Additionally, create a folder named wallet.>
    npm install> mkdir wallet
  prefs: []
  type: TYPE_NORMAL
- en: You will be using the elliptic-curve cryptography library implementation to
    generate private-public key combos. Note that the elliptic-curve library uses
    secp256k1 as the ECDSA curve algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** *Elliptical curve cryptography* (ECC) is the public key encryption
    technique used by bitcoin. It’s based on elliptic curve theory to generate the
    cryptographic keys. Secp256k1 is the graph elliptic curve ECDSA algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: To install the library, run the following command:> npm install elliptic --save
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a file and name it wallet.js. Take a look at the complete code in
    Listing [3-8](#PC54).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-8. wallet.js*let EC = require(''elliptic'').ec,    fs = require(''fs'');const
    ec = new EC(''secp256k1''),    privateKeyLocation = __dirname + ''/wallet/private_key'';exports.initWallet
    = () => {    let privateKey;    if (fs.existsSync(privateKeyLocation)) {        const
    buffer = fs.readFileSync(privateKeyLocation, ''utf8'');        privateKey = buffer.toString();    }
    else {        privateKey = generatePrivateKey();        fs.writeFileSync(privateKeyLocation,
    privateKey);    }    const key = ec.keyFromPrivate(privateKey, ''hex'');    const
    publicKey = key.getPublic().encode(''hex'');    return({''privateKeyLocation'':
    privateKeyLocation, ''publicKey'': publicKey});};const generatePrivateKey = ()
    => {    const keyPair = ec.genKeyPair();    const privateKey = keyPair.getPrivate();    return
    privateKey.toString(16);};In the wallet file, you create and initialize the EC
    context.const ec = new EC(''secp256k1''),You then store the location of your wallet’s
    private key, privateKeyLocation.privateKeyLocation = __dirname + ''/wallet/private_key'';Next,
    you are able to create a method exports.initWallet to generate the actual public-private
    key, generatePrivateKey.    const keyPair = ec.genKeyPair();    const privateKey
    = keyPair.getPrivate();Notice that you will be generating a new wallet only if
    one doesn’t exist.if (fs.existsSync(privateKeyLocation))'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you create a wallet.js file utilizing the Elliptic Curve Cryptography
    library to generate your private-public key combo.
  prefs: []
  type: TYPE_NORMAL
- en: To see the code working, add the following code temporarily at the end of the
    wallet.js file  . The script will create the public and private keys.let wallet
    = this;let retVal = wallet.initWallet();console.log(JSON.stringify(retVal));Next,
    create a wallet directory to store the private key and run the script. The code
    will initialize the script and create your public key.> mkdir wallet> node wallet.js>
    cat wallet/private_keyWhen you run the node wallet.js command, you can see the
    public key. See Figure [3-8](#Fig8) for the output.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-8
  prefs: []
  type: TYPE_NORMAL
- en: Generating a wallet’s private-public key
  prefs: []
  type: TYPE_NORMAL
- en: Remember to comment out these lines because in the next exercise, you will create
    an API to be able to create your keys via the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is creating an application program interface (API) to be able
    to access the code you write. This is an important part of a blockchain, as you
    want to access your blocks and wallet or any other P2P network operation using
    an HTTP service. In this section, you will be using the express library, as it’s
    easy to run, and you will be able to create your API easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: API P2P Blockchain Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Creating API**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will create an API to interact with your P2P blockchain
    network. You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be creating the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '***blocks***: Retrieves all the blocks in the blockchain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***getBlock***: Retrieves a specific block by index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***getDBBlock***: Retrieves a block from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***getWallet***: Creates a new wallet by generating a public-private key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will install express and body-parser. These libraries will allow you to
    create a server and display pages in the browser.> npm install express body-parser
    --saveYou also need to import the wallet.js file you created.let express = require("express"),    bodyParser
    = require(''body-parser''),    wallet = require(''./wallet'');Next, you create
    a method called initHttpServer that will initiate the server and create the services.
    As you utilize different instances of the P2P network and run instances on the
    same computer, you want to utilize different port numbers. It’s common to use
    port 80 or 8081 for HTTP services but not required. What you will do is pass the
    random port number you are using and utilize the slice method to get the last
    two digits of the port number.let initHttpServer = (port) => {    let http_port
    = ''80'' + port.toString().slice(-2);    let app = express();    app.use(bodyParser.json());The
    Blocks service will be retrieving all of your blocks.    app.get(''/blocks'',
    (req, res) => res.send(JSON.stringify( chain.blockchain )));The getBlock service
    will be retrieving one block based on an index.    app.get(''/getBlock'', (req,
    res) => {        let blockIndex = req.query.index;        res.send(chain.blockchain[blockIndex]);    });The
    getDBBlock service  will be retrieving a LevelDB database entry based on an index.    app.get(''/getDBBlock'',
    (req, res) => {        let blockIndex = req.query.index;        chain.getDbBlock(blockIndex,
    res);    });The getWallet service  will be utilizing the wallet.js file you created
    in the previous step and generate your public-private key pair.    app.get(''/getWallet'',
    (req, res) => {        res.send(wallet.initWallet());    });Lastly, you will utilize
    the Express listen method.    app.listen(http_port, () => console.log(''Listening
    http on port: '' + http_port));};You will call the initHttpServer method you created
    after you start the P2P network and a random port was selected.(async () => {     const
    port = await getPort();     initHttpServer(port);}To call your services, run the
    P2P network, and then you can open a browser and call the API.http://localhost:80[port]/getWallethttp://localhost:80[port]/blockshttp://localhost:80[port]/getBlock?index=0http://localhost:80[port]/
    getDBBlock?index=0See Figure [3-9](#Fig9), for instance, as you retrieve all the
    blocks in your blockchain.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-9
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving all the blocks in your blockchain
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created API services, and you can now interact with your
    P2P network. You created your services so you will be able to create multiple
    instances of the P2P networks on the same machine; however, in reality, every
    machine will be holding only one peer. In the next exercise, you will create a
    command-line interface (CLI) to easily call these services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Command-Line Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the last step in this chapter, you will be creating a command-line interface
    (CLI  ). The CLI is needed to be able to easily access the services you created.
    I won’t get into the entire internal process of the CLI script, as it’s beyond
    the scope of this chapter; however, you can download the whole example and review
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: CLI Exercise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Block Command**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a CLI to interact with and access your P2P
    blockchain network. You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the libraries you will be utilizing to run promises, run the
    async function, add colors to the console, and store cookies.> npm babel-polyfill
    async update-notifier handlebars colors nopt --saveIn the block.js command, you
    will be setting two commands: get and all. Take a look at the entire code in Listing
    [3-9](#PC72).let logger = require(''../logger'');function Block(options) {    this.options
    = options;}Block.DETAILS = {    alias: ''b'',    description: ''block'',    commands:
    [''get'', ''all''],    options: {        create: Boolean    },    shorthands:
    {        s: [''--get''],        a: [''--all'']    },    payload: function(payload,
    options) {        options.start = true;    },};Block.prototype.run = function()
    {    let instance = this,        options = instance.options;    if (options.get)
    {        instance.runCmd(''curl http://localhost:'' + options.argv.original[2]
    + ''/getBlock?index='' + options.argv.original[3]);    }    if (options.all) {        instance.runCmd(''curl
    http://localhost:'' + options.argv.original[2] + ''/blocks'');    }};Block.prototype.runCmd
    = function(cmd) {    const { exec } = require(''child_process'');    logger.log(cmd);    exec(cmd,
    (err, stdout, stderr) => {        if (err) {            logger.log(`err: ${err}`);            return;        }        logger.log(`stdout:
    ${stdout}`);    });};exports.Impl = Block;Listing 3-9'
  prefs: []
  type: TYPE_NORMAL
- en: Block Command Code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the wallet.js command will include the get and all methods to
    point to a curl command to run the HTTP service call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wallet Command**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the block.js command will include a create method and a curl command
    to run the HTTP service call. See Listing [3-10](#PC73).let logger = require(''../logger'');function
    Wallet(options) {    this.options = options;}Wallet.DETAILS = {    alias: ''w'',    description:
    ''wallet'',    commands: [''create''],    options: {        create: Boolean    },    shorthands:
    {        c: [''--create'']    },    payload: function(payload, options) {        options.start
    = true;    },};Wallet.prototype.run = function() {    let instance = this,        options
    = instance.options;    if (options.create) {        instance.runCmd(''curl http://localhost:''
    + options.argv.original[2] + ''/getWallet'');    }};Wallet.prototype.runCmd =
    function(cmd) {    const { exec } = require(''child_process'');    logger.log(cmd);    exec(cmd,
    (err, stdout, stderr) => {        if (err) {            logger.log(`err: ${err}`);            return;        }        logger.log(`stdout:
    ${stdout}`);    });};exports.Impl = Wallet;Listing 3-10'
  prefs: []
  type: TYPE_NORMAL
- en: Wallet Command Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have your commands set up, you can add your CLI to the bash_profile
    as an alias to be able to run the CLI from any path location.> vim ~/.bash_profilealias
    cli=''node /[project location]/step7/bin/bin/cli.jsSave and run bash_profile to
    apply these changes.> . ~/.bash_profileYou can call the CLI once you run the P2P
    and know the ports you are using.> cli block --get [port] 1 #port #index> cli
    block –all [port] #port> cli wallet --create [port]For instance, run an instance
    of the P2P network in Terminal.> node p2p.jsNext, open a new window terminal and
    run the CLI command to retrieve the first generated block.> cli block --get [port]
    1You can see the output in Figures [3-10](#Fig10) and [3-11](#Fig11).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig10_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig10_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-10
  prefs: []
  type: TYPE_NORMAL
- en: Running the P2P blockchain network on port 8057
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig11_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig11_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving blocks on port 8057
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created two commands for getting blocks and creating your
    wallet. This is a starting point for your CLI, and you will be able to continue
    to add commands as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Where to Go from Here
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I already mentioned that the code in this chapter does not take into account
    many use cases and has no security to keep it simple. There are many things you
    can do to improve the code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Confirmations*: Each miner sends a message with a block. You can create a
    confirmation system to ensure the integrity of the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transactions/data*: You could implement transactions or data objects to address
    double spending, transaction validation, and coinbase transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*levelDB*: Once the P2P is initialized, you can create a script to retrieve
    and write all the blocks into the LevelDB database, validate them, and clean the
    database as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered how to create your very own basic P2P blockchain network;
    you were able to send and receive messages and include blocks in these messages.
    You were able to register and unregister miners and implement a simple PoS consensus
    mechanism. You created new blocks and sent them between the peers. You also set
    up a name-value LevelDB database to store blocks. You continued and created a
    wallet that consists of private-public key pairs. Lastly, you created ways to
    communicate with your P2P network via API services and the CLI. In the next chapter,
    you will be diving deep into understanding bitcoin wallets and transactions by
    interacting with the bitcoin core API.
  prefs: []
  type: TYPE_NORMAL
