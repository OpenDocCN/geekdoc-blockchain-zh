- en: © The Author(s), under exclusive license to Springer Nature Singapore Pte Ltd. 2021Z.
    Zheng et al. (eds.)Blockchain Intelligence[https://doi.org/10.1007/978-981-16-0127-9_3](https://doi.org/10.1007/978-981-16-0127-9_3)
  prefs: []
  type: TYPE_NORMAL
- en: 3. Analysis and Mining of Blockchain Transaction Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dan Lin^([1](#Aff4), [2](#Aff5) [ ](#ContactOfAuthor1)), Jiajing Wu^([1](#Aff4),
    [2](#Aff5) [ ](#ContactOfAuthor2)), Qi Yuan^([1](#Aff4), [2](#Aff5) [ ](#ContactOfAuthor3))
    and Zibin Zheng^([2](#Aff5) [ ](#ContactOfAuthor4))(1)School of Data and Computer
    Science, Sun Yat-sen University, Guangzhou, China(2)National Engineering Research
    Center of Digital Life, Sun Yat-sen University, Guangzhou, ChinaDan LinEmail:
    [lind8@mail2.sysu.edu.cn](mailto:lind8@mail2.sysu.edu.cn)Jiajing Wu (Corresponding
    author)Email: [wujiajing@mail.sysu.edu.cn](mailto:wujiajing@mail.sysu.edu.cn)Qi YuanEmail:
    [yuanq29@mail2.sysu.edu.cn](mailto:yuanq29@mail2.sysu.edu.cn)Zibin ZhengEmail:
    [zhzibin@mail.sysu.edu.cn](mailto:zhzibin@mail.sysu.edu.cn)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduce an overview of network construction in blockchain.
    In recent years, network has been widely used to present information in various
    areas, and graph-embedding techniques have attracted attention from various fields.
    Ethereum is a blockchain-based platform supporting smart contracts. The open nature
    of blockchain makes the transaction data on Ethereum completely public, and also
    brings unprecedented opportunities for the transaction network analysis. We first
    model the Ethereum transaction records as a complex network named temporal weighted
    multidigraph (TWMDG) by incorporating time and amount features of the transactions,
    and then define the problem of temporal weighted multidigraph embedding (T-EDGE)
    by incorporating both temporal and weighted information of the edges. Moreover,
    we also design several flexible temporal walk strategies for random-walk based
    graph representation of this large-scale network and study the Ethereum transaction
    tracking problem and the evolution factors of transaction network via link prediction
    from the network perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network is a kind of data form which is often used to describe the relationship
    between objects. In the past decade, network data has grown explosively and have
    been used to present information in various areas such as biological networks,
    social networks, computer networks, and financial transaction networks (Boccaletti
    et al. [2006](#CR3)). Complex networks can represent complex information in the
    real world in an elegant way. More and more attention has been paid to the analysis
    of large-scale networks by industry and academia. With the rapid development of
    machine learning technology, how to analyze the data effectively for large-scale
    complex networks becomes a central topic in the field of artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, there are few analytical studies on financial transactions
    which have been conducted because the transaction records are usually private
    for the consideration of security and profit. The open nature of Blockchain provides
    us with unprecedented opportunities for data mining in this area. In fact, since
    blockchain technology was born from Bitcoin, cryptocurrency and blockchain are
    highly coupled. The research of cryptocurrency transaction network has very high
    application value, and nowadays, there are already some studies including graph
    analysis, price prediction, portfolio management, anti-money laundry, illicit
    detection, and so on (Chen et al. [2018a](#CR6),[b](#CR7), [2019](#CR8); Feder
    et al. [2018](#CR13); Jiang and Liang [2016](#CR15); Liang et al. [2018](#CR17);
    Ron and Shamir [2013](#CR25)). In 2017, Jiang and Liang presented a deterministic
    deep reinforcement learning method for cryptocurrency portfolio management, which
    inputs the historic prices of a set of financial assets and outputs the portfolio
    weights of the set in its trading algorithm. In 2018, Liang et al. traced the
    properties over time and understood the dynamics of three representative cryptocurrencies,
    that is, Bitcoin, Ethereum, and Namecoin, by constructing monthly transaction
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Because the processing of the whole blockchain transaction network is very time-consuming,
    it is essential to find an effective and efficient method to analyze the Blockchain
    transaction data. As we all know, the performance of machine learning tasks largely
    depends on the selection of data features, so how to represent the feature information
    reasonably in large-scale transaction networks is the key issue. Moreover, the
    algorithm based on machine learning usually requires feature information of samples,
    while the account information of the transaction networks is often difficult to
    obtain. The graph embedding algorithms can be used to mine the implicit features
    of the accounts.
  prefs: []
  type: TYPE_NORMAL
- en: For network analysis and downstream machine learning tasks, graph embedding
    is an effective method to represent node features in a low dimensional space (Cai
    et al. [2018](#CR4)). Graph embedding algorithms can effectively reduce the data
    dimension of transaction network, and convert the large-scale and sparse high-dimensional
    one-hot node vectors to the dense low-dimensional node vectors. So it could be
    an effective way to analyze data on blockchain using Graph embedding.
  prefs: []
  type: TYPE_NORMAL
- en: Data analysis and mining on blockchain transaction network can help us to understand
    more about the blockchain transaction pattern, the evolution of blockchain financial
    market and the illegal activities on blockchain, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce the basic knowledge of network, including the concept of network and
    the expression of the network
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a network construction model that can keep the transaction information
    of blockchain completely
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce the application examples of data analysis and mining using blockchain
    transaction network
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.2 Basic Knowledge of Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the rapid development of network information technology represented by
    the Internet, mankind has entered the era of complex networks. Human production
    and life are increasingly dependent on the safe, reliable, and effective operation
    of various complex network systems.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Concept of Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the natural world and even in human society, there are various connections
    between massive individuals, and interconnected individuals constitute a complex
    system of all kinds. If nodes are used to represent individuals and connected
    edges are used to represent connections between individuals, then these complex
    systems can be characterized through the network. For example, the social network
    of the Tencent platform records the user’s classmate relationship, friend relationship,
    and even group relationship with similar interests; the computer network describes
    the communication relationship between some computers connected by communication
    media; the biological body’s nervous system portrays the interconnection and interaction
    of a large number of nerve cells. These networks are connected by different individuals
    through various rules. They have many similar but not identical features in structure,
    and they also have different characteristics in function. They are often collectively
    called complex networks. Networks are a general language for describing complex
    systems of interacting entities (Fig. [3.1](#Fig1)).![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig1_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.1
  prefs: []
  type: TYPE_NORMAL
- en: Communication Network
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of networks, and real complex systems require different
    types of networks to describe them. For example, when investigating the cooperative
    relationship between scientists, scientists who have collaborated on at least
    one article will establish a connected edge. Then such a system can be described
    through the simplest undirected network. Undirected means that the connected edge
    has no directivity, and no right means that there is no strength or weakness in
    the connected side. If you want to use the edge to indicate the number of collaborative
    articles between scientists, then this system requires an undirected weighted
    network to represent, the thickness of the edge represents the size of the weight,
    that is, the cooperative frequency. In another example, in the food chain system,
    the edge represents the relationship between the predator and the predator. To
    describe this relationship with directivity, a directed network must be used (Fig.
    [3.2](#Fig2)).![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig2_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.2
  prefs: []
  type: TYPE_NORMAL
- en: Neuron Network
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Mathematical Representation of Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Network often refers to real systems, and graph is a mathematical representation
    of a network. The graph provides a unified method for representing various actual
    networks with abstract points and lines, and thus has become a common language
    for studying complex networks. But in most cases the two terms are used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete network can be abstracted as a graph ![
  prefs: []
  type: TYPE_NORMAL
- en: $$G\left (V,E\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq1.png), *V* is
    a set of vertexs, *E* is a set of edges, excluding multiple edges and self-connected
    edges. The total number of vertexs in the graph is !['
  prefs: []
  type: TYPE_NORMAL
- en: $$N\left (N = |V|\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq2.png), and
    the number of edges is !['
  prefs: []
  type: TYPE_NORMAL
- en: $$M\left ( M = |E|\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq3.png). The
    graph has !['
  prefs: []
  type: TYPE_NORMAL
- en: $$N\left (N-1\right ) / 2$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq4.png) vertex
    pairs, which is the complete set *U*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, according to whether the edges in the graph are directed and weighted,
    there can be four types of graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unweighted Undirected Graph. The edges in the graph are unweighted and undirected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unweighted Directed Graph. The edges in the graph are unweighted and directed.
    Unweighted graphs can actually mean that the weights in the graphs are all equal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Weighted Undirected Graph. The edges in the graph are weighted and undirected.
    Undirected means that *(i, j)* and *(j, i)* represent the same edge.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Weighted Directed Graph. The edges in the graph are weighted and directed. Edge
    is directed means there is an edge *(i, j)* from node *i* to node *j*, but there
    is not necessarily an edge *(j, i)* from node *j* to node *i*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.3 Blockchain Transaction Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, graphs have been widely used to analyze various networks, but most
    of the existing graph constructed miss temporal and weighted information on edges
    that may play a role in the financial transaction networks. The openness of Ethereum,
    a blockchain-based platform, provides us with an opportunity for data mining in
    this field. By considering the realistic rules and characteristics of the transaction
    networks, we model the Ethereum transaction network as a temporal weighted multidigraph
    (TWMDG), in which each node is a unique Ethereum account and each edge represents
    a transaction weighted by amount and allocated with timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Method of Modeling Blockchain Transaction Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to now, graph has been used to model and analyze the huge transactions network
    of blockchain-based systems. In 2018, Chen et al. conducted the first systematic
    study to characterize Ethereum and get new observations with various indicators.
    Alqassem et al. ([2018](#CR1)) found the antisocial properties of Bitcoin system
    via transaction network data analysis. In existing research, transaction records
    are modeled as a simple graph, in which multiple transactions between a pair of
    addresses are merged into one transaction during the construction of the graph.
    However, different from other large-scale complex networks which edge only contains
    single information, each edge in the blockchain transaction network represents
    a particular coin transaction, and thus contains some unique information such
    as the direction, amount value and timestamp of a particular transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the above information is essential for accurate modeling, characterization,
    and understanding of transaction network data. In addition, multiple transactions
    between two users are expected and it is more comprehensive to model a transaction
    network as a multidigraph rather than a simple graph. In graph theory, a multigraph
    (as opposed to a simple graph) is a graph which is allowed to have self-loops
    and multiple edges (also called parallel edges). A multidigraph is a directed
    multigraph.
  prefs: []
  type: TYPE_NORMAL
- en: The existing methods of modeling the transaction records as simple graph are
    not sufficient to characterize the temporal and multiple features of transaction
    networks. So, we model the blockchain transaction records as a **Temporal Weighted
    Multidigraph**, and propose novel graph sampling and representation methods to
    keep the temporal and weighted information of the blockchain transaction. Next
    we provide an example of how to model the blockchain transaction network as Temporal
    Weighted Multidigraph. The selected blockchain transaction system is Ethereum,
    which is the largest public platform based on blockchain that supports smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Modeling Ethereum Transaction Network by Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The modeling framework includes two main procedures, as shown in Fig. [3.3](#Fig3):
    (a) Data Collection. Obtain the transaction records of objective accounts from
    Ethereum through API of [https://​etherscan.​io/​](https://etherscan.io/) (A block
    explorer and analytics platform for Ethereum); (b) Network Construction. Based
    on the collected transaction data, a Temporal Weighted Multidigraph is constructed
    to represent the relationship of Ether transfer between accounts.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig3_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig3_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.3
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the proposed framework for modeling Ethereum transaction
    network by graph. (**a**) Data acquisition. (**b**) Network construction
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2.1 Data Collection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two types of Ethereum accounts, that is, external owned accounts (EOA),
    which is similar to ordinary bank accounts (Chen and Zheng [2018](#CR9)), and
    smart contract accounts, which are source code files. Ethereum accounts/addresses
    (We use “account” and “address” interchangeably in the following paper) are composed
    of the prefix “0x”, a common identifier for hexadecimal, concatenated with the
    rightmost 20 bytes of the public key. One example is “0x51faeda318982f439e80012fb45d2b017ddccd-be.”
    Usually, transactions take place between accounts that are represented by addresses
    for anonymity. In this work, we focus on the transactions between EOAs because
    the Ether transfer records between them are publicly available on the blockchain.
    Besides, we only include the successful transactions with nonzero amount value
    into our dataset. Because there are more than two million EOAs in the whole Ethereum
    transaction network, it (Chen et al. [2018a](#CR6)) is extremely time-consuming
    to process it, here we select objective accounts and then obtain their transaction
    data through APIs of Etherscan. As shown in Fig. [3.4](#Fig4), centered by a particular
    objective account, we obtain a directed *K*-order subgraph. *K*-in and *K*-out
    are two parameters to control the depth of sampling inward and outward from the
    center, respectively. The *K*-order sampling method can obtain space-intensive
    transaction data, whose corresponding transaction network is always connected
    and can better reserve the local information of the target nodes.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig4_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.4
  prefs: []
  type: TYPE_NORMAL
- en: A schematic illustration of a directed *K*-order subgraph
  prefs: []
  type: TYPE_NORMAL
- en: Using this sampling method, we get three subgraphs with different size from
    Ethereum for experiments. EthereumG1 is centered by account “0x51faeda318982f4-39e80012fb45d2b017ddccdbe”
    with *K*-in = *K*-out = *K* = 3; EthereumG2 is centered by account “0x5e247060f48eeb64367250ed03ff5091bba
    47fd1” with *K*-in = *K*-out = *K* = 4; EthereumG3 is centered by the same account
    as EthereumG1 with *K*-in = *K*-out = *K* = 4\. A summary of the datasets is listed
    in Table [3.1](#Tab1). The center accounts for building subgraphs are chosen randomly
    with no specification.Table 3.1
  prefs: []
  type: TYPE_NORMAL
- en: Statistics of datasets. The notation “#” represents “the number of” and “Txs”
    is short for “Transactions”
  prefs: []
  type: TYPE_NORMAL
- en: '| Dataset | Address of center node | *K* | #Account | Txs |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG1 | 0x51faeda318982f439e80012fb45d2b017ddcc | 3 | 3832 | 208927
    |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG2 | 0x5e247060f48eeb64367250ed03ff5091bba47fd1 | 4 | 10,628 | 208533
    |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG3 | 0x51faeda318982f439e80012fb45d2b017ddccdbe | 4 | 26,175 | 677785
    |'
  prefs: []
  type: TYPE_TB
- en: On Ethereum, various related information about Ether transactions is stored
    as data packets. In details, the *TxHash* field is a unique identification of
    a transaction, the *Value* field in a transaction refers to the amount of money
    transferred, and the *Timestamp* field indicates when the transaction happens.
    Besides, the *From* and *To* fields denote the sender and recipient of the transaction.
    With the collected fourtuples *(From, To, Value, Timestamp)*, we can construct
    a Temporal Weighted Multidigraph.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2.2 Network Construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ether transfer is one of the main activities that occurs on Ethereum. Here
    we abstract an Ether transfer transaction as a four-tuple *(src, dst, w, t)*,
    which means the sender src transfers *w* Ether to the recipient *dst* at time
    . To investigate the Ether transfer on Ethereum, we abstract the Ethereum transaction
    network as a Temporal Weighted Multidigraph:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition 3.1 (Temporal Weighted Multidigraph (TWMDG))
  prefs: []
  type: TYPE_NORMAL
- en: Given a graph ![
  prefs: []
  type: TYPE_NORMAL
- en: $$G = \left (V, E\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq5.png), let
    *V* be the set of vertexs and *E* be the set of edges. Each edge is unique and
    is represented as !['
  prefs: []
  type: TYPE_NORMAL
- en: $$e = \left (u, v, w, t\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq6.png), where
    *u* is the source vertex, *v* is the target vertex, *w* is the weight value, and
    *t* is the timestamp. For the sake of simplicity, we define mapping functions
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Src\left (e\right ) = u$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq7.png), !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Dst\left (e\right ) = v$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq8.png), !['
  prefs: []
  type: TYPE_NORMAL
- en: $$W\left (e\right ) = w$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq9.png), !['
  prefs: []
  type: TYPE_NORMAL
- en: $$T\left (e\right ) = t$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq10.png) for
    ∀*e* ∈ *E*.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the four-tuples collected from Ethereum transaction records, we can
    build a TWMDG, where each node represents a unique account and each edge represents
    a unique Ether transfer transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Data Analysis and Mining Based on Blockchain Transaction Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Existing studies on blockchain transaction network analysis and data mining
    can be categorized into two groups. One is applying metrics and topological features
    of complex networks to analyze and characterize blockchain transaction networks.
    The other is the blockchain transaction data mining problem solving by means of
    machine-learning based approaches. These studies mainly focus on the issues of
    ownership identification and anomaly detection in the blockchain systems. Except
    for the ownership identification and detection problem, transaction tracking of
    cryptocurrencies is also of importance to improve the financial security of blockchain
    systems. Current research on transaction tracing mainly discuss about how to trace
    the capital flow in the past by studying the transaction records, while the problem
    of using past records to predict future transactions are rarely considered. However,
    predicting transaction execution is another way to study transaction tracking
    effectively. In this part, we present a new method based on network embedding
    to study Blockchain transactions, and apply it to actual Blockchain data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Temporal Weighted Multidigraph Embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a temporal weighted multidigraph ![
  prefs: []
  type: TYPE_NORMAL
- en: $$G = \left (V,E\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq11.png), which
    Construction method has been shown in Sect. [3.3.1](#Sec6). We define following
    mapping functions: For ∀*e* ∈ *E*, !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Src\left (e\right ) = u$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq12.png), !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Dst\left (e\right ) = v$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq13.png). Function
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$W\left (e\right ) = w$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq14.png) maps
    an edge to its weight and function !['
  prefs: []
  type: TYPE_NORMAL
- en: $$T\left (e\right ) = t$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq15.png) maps
    an edge to its timestamp. Our principal goal is to learn an embedding function
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\Phi :V\rightarrow \mathbb {R}^d$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq16.png) (*d* ≪|*V* |)
    which preserves original network information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of learned representations is to include node similarity, as well
    as temporal and weighting properties specifically for financial transaction networks,
    which can improve predictive performance on downstream machine learning tasks.
    The proposed method T-EDGE can learn dynamic node representations more appropriately
    and meaningfully using a general embedding framework consisting of two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first part is the temporal walk generator with the temporal restriction
    and walking strategies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second part is the update process based on skip-gram, and the parameters
    are updated by Stochastic Gradient Descent algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.4.1.1 Random Walk
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For scalable network representation learning, random walk mechanism has been
    widely proven to be an effective technique to capture structural relationships
    between nodes (Perozzi et al. [2014](#CR23)). Taking the temporal dependencies
    and multiplicity of edges into consideration, we adopt a temporal walk for transaction
    networks. This kind of random walk sequences contains the actual meaning of capital
    flow in transaction networks. In a temporal weighted multidigraph, the *temporal
    walk* defined as sequential incremental path from the beginning node to the end
    node. Such a temporal walk is represented as a sequence of *l* nodes *walk* [*n*] = {*v*
    [1], *v* [2], …, *v* [*l*]} together with a sequence of ![
  prefs: []
  type: TYPE_NORMAL
- en: $$\left (l - 1\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq17.png) edges
    *walk* [*e*] = {*e* [1], *e* [2], …, *e* [*l*−1]}, where !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Src\left (e_i\right )=v_i$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq18.png), !['
  prefs: []
  type: TYPE_NORMAL
- en: $$Dst\left (e_i\right ) = v_{i + 1}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq19.png) !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\left (1\leq i \leq \left (l - 1\right )\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq20.png), and
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$T\left (e_i\right )\leq T\left (e_{i + 1}\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq21.png) !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\left (1\leq i \leq \left (l - 2\right )\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq22.png). This
    temporal limit is a novel idea designed for the temporal walk.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a temporal walk that just traversed edge *e* [*i*−1], and is now stopping
    at node *v* [*i*] at time ![
  prefs: []
  type: TYPE_NORMAL
- en: $$t = T\left (e_{i - 1}\right )$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq23.png). The
    next node *v* [*i*+1] of the random walk is decided by selecting a temporally
    valid edge *e* [*i*]. We define the *temporal edge neighborhood* for a node *u*
    as !['
  prefs: []
  type: TYPE_NORMAL
- en: $$N_t\left (u\right ) = \{ e~|~Src\left (e\right ) = u, T\left (e\right )\geq
    t \} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq24.png). Let
    !['
  prefs: []
  type: TYPE_NORMAL
- en: '$$\eta _-: \mathbb {R}\rightarrow \mathbb {Z}^+$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq25.png) to be
    a function that maps the timestamps of edges to a descending ranking, and let
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\eta _+:\mathbb {R}\rightarrow \mathbb {Z}^+$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq26.png) be a
    function that maps the timestamps of edges to an ascending ranking. Here are our
    walking strategies used in Ethereum transaction network embedding as a example:'
  prefs: []
  type: TYPE_NORMAL
- en: T-EDGEIn our temporal weighted multidigraphs discussed here, a random walk generator
    of T-EDGE samples uniformly from the neighbors. All candidate edges in *N* [*t*]
    have the same probability to be selected as the next edge of random walk. The
    expression of the probability is![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)=\frac{1}{|N_t(v_i)|}. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ1.png)(3.1)T-EDGE
    (TBS)TBS refers to Temporal Biased Sampling. For financial transaction networks,
    the similarity between accounts is time-dependent and dynamic. Naturally, there
    is a strong correlation between frequently transaction accounts. The probability
    of selecting each edge *e* ∈ *N* [*t*](*v* [*i*]) can be given as:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)=P_{TBS}(e)=\frac{\eta_-(T(e))}{\sum_{e'\in
    N_t(v_i)}~\eta_-(T(e'))}. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ2.png)(3.2)T-EDGE
    (WBS)WBS refers to Weighted Biased Sampling. The weight value of each transaction
    indicates the importance of interactions between the two accounts involved. The
    transaction amount can reflect the importance of transactions between accounts
    and then can reflect the degree of correlation between accounts. In most cases,
    there is a great similarity between accounts with large number of transactions.
    The probability of each edge *e* ∈ *N* [*t*](*v* [*i*]) being selected is!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)=P_{WBS}(e)=\frac{\eta_+(W(e))}{\sum_{e'\in
    N_t(v_i)} \eta_+(W(e'))}. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ3.png)(3.3)T-EDGE
    (TBS+ WBS)We combine the aforementioned sampling probabilities considering information
    from both temporal and weighted domains by!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P_{TBS+WBS}(e) = P_{TBS}(e)^\alpha P_{WBS}(e)^{(1-\alpha)}
    , (0\leq\alpha\leq1), \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ4.png)(3.4)!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)=\frac{P_{TBS+WBS}(e)}{\sum_{e'\in N_t(v_i)}
    P_{TBS+WBS}(e')}, \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ5.png)(3.5)'
  prefs: []
  type: TYPE_NORMAL
- en: for ∀*e* ∈ *N* [*t*](*v* [*i*]). Here *α* = 0.5 is the default value for balancing
    between TBS (time domain) and WBS (amount domain).
  prefs: []
  type: TYPE_NORMAL
- en: When ending up with a leaf node, we return the walk immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for temporal and directed multigraphs such as transaction networks,
    T-EDGE can be regarded as a specific version of DeepWalk. As Table [3.2](#Tab2)
    shows, T-EDGE is equally likely to select all candidate edges (temporal successive
    edges). T-EDGE (TBS) and T-EDGE (WBS) represent adding sampling preference on
    the time domain and the amount domain respectively while T-EDGE (TBS+WBS) denotes
    to add sampling preference on both the time domain and the amount domain.Table
    3.2
  prefs: []
  type: TYPE_NORMAL
- en: Four types of T-EDGE variation for Ethereum transaction network
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Time domain | Amount domain |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Algorithms | Unbiased | Biased | Unbiased | Biased |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE | *√* |   | *√* |   |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE (TBS) |   | *√* | *√* |   |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE (WBS) | *√* |   |   | *√* |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE (TBS+WBS) |   | *√* |   | *√* |'
  prefs: []
  type: TYPE_TB
- en: 3.4.1.2 Learning Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the above subsection, we have described the method to obtain the sampling
    sequence of temporal walk related to time and weight. In this section, we will
    formally use skip-gram model to describe the process of learning node vectors
    (Mikolov et al. [2013a](#CR20),[b](#CR21)).
  prefs: []
  type: TYPE_NORMAL
- en: The essence of skip-gram model is a three-layer neural network model, including
    input layer, hidden layer, and output layer. First, we train a neural network
    model based on the sampling walk sequences; however, the purpose of training is
    not to use the model to predict the test set, but to use the parameters learned
    from the model, namely the hidden layer parameters, as the node vectors. Then,
    the node representations can be learned by maximizing the probability of observing
    the neighborhood of a node conditioned on its embedding by making an analogy between
    natural language sentence and truncated random walk sequence (as shown in Table
    [3.3](#Tab3)). This cost function is as followed:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \min_{\Phi} -\Pr(\{v_{i-k}, \ldots, v_{i+k}\}
    \backslash v_i | \Phi(v_i)), \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ6.png)(3.6)Table
    3.3'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison between language model word2vec and graph model Deepwalk
  prefs: []
  type: TYPE_NORMAL
- en: '| Research domain | Example | Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Natural language processing | word2vec | Sequence of word (sentences) | Word
    vectors |'
  prefs: []
  type: TYPE_TB
- en: '| Graph representation learning | deepwalk | Sequence of nodes (random walks)
    | Node vectors |'
  prefs: []
  type: TYPE_TB
- en: where *k* is the window size. According to the conditional independent assumption
    in skip-gram model, we have:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \Pr(\{v_{i-k}, \ldots, v_{i+k}\} \backslash
    v_i | \Phi(v_i)) = \prod_{j=i-k, j\neq i}^{i+k}~\Pr(v_j|\Phi(v_i)). \end{aligned}
    $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ7.png)(3.7)Similar
    to DeepWalk, we employ “hierarchical softmax” technique (Perozzi et al. [2014](#CR23))
    to accelerate the computation of !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\Pr (v_j|\Phi (v_i))$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq27.png). We
    first apportion |*V* | nodes to the leaf nodes of a Huffman Tree, and then transform
    the computation of !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\Pr (v_j|\Phi (v_i))$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq28.png) into
    computing the probability of walking randomly from the root of Huffman Tree with
    inputting node *v* [*i*] and outputting node *v* [*j*]. The probability is!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \Pr(v_j | \Phi(v_i)) = \prod_{t=1}^{\lceil \log
    |V| \rceil}~\Pr(b_t|\Phi(v_i)), \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ8.png)(3.8)where
    *b* [*t*] is from !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\{ b_0=root, b_1, \ldots , b_{\lceil \log |V| \rceil }=v_j\}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq29.png). Then
    we model !['
  prefs: []
  type: TYPE_NORMAL
- en: $$\Pr (b_t|\Phi (v_i)$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq30.png) with
    *sigmiod* function:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \Pr(b_t|\Phi(v_i)=\frac{1}{1+\exp(-\Phi(v_i)\cdot
    \Phi(b_{t-1}))}, \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ9.png)(3.9)'
  prefs: []
  type: TYPE_NORMAL
- en: where Φ(*b* [*t*−1]) represents *b* [*t*]’s parent node in the Huffman tree.
    Skip-gram model then updates the weight using back propagation algorithm and Stochastic
    Gradient Descent.
  prefs: []
  type: TYPE_NORMAL
- en: Random walk based graph embedding methods have been proved to be scalable and
    effective for large graphs. The time complexity of the temporal walk part and
    the SkipGram learning procedure is *O*(*r*|*V* |*L*) and ![
  prefs: []
  type: TYPE_NORMAL
- en: $$O(|V| \log |V|)$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq31.png), respectively,
    where |*V* | is the number of nodes, *r* represents walks per node, and *L* refers
    to the length of random walk.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Phishing Scam
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the advent of online businesses, phishing scam becomes a new type of cybercrime
    (Liu and Ye [2001](#CR19)). It is reported to account for more than 50% of all
    cyber-crimes in Ethereum since 2017 (Team [2017](#CR26)). In order to evaluate
    the performance of the proposed T-EDGE strategies, we conduct node classification
    experiments on Ethereum to classify labeled phishing nodes and unlabeled nodes
    (treated as unphishing nodes).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2.1 Data Acquisition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To train our node classification model using supervised learning, we obtain
    445 phishing nodes labeled by Etherscan with the same number of randomly selected
    unlabeled nodes as the objective nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As Sect. [3.3](#Sec5) has shown, *K*-order sampling is an effective method to
    obtain the local information of an objective accounts (Lin et al. [2020](#CR18)).
    We assume that for a typical *Ether* transfer flow centered on a phishing node,
    the previous node of the phishing node may be a victim, and the next one to three
    nodes may be the bridge nodes with money laundering behaviors. Therefore, we collect
    subgraphs with *K*-in = 1, *K*-out = 3 for each of the 890 objective nodes and
    then splice them into a large-scale network with 86,623 nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2.2 Setting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the experiments, we compare the proposed T-EDGE algorithms with two baseline
    random walk based graph embedding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DeepWalk** is the pioneer work in employing random walks to learn a latent
    space representation of social interactions. Borrowing the idea of word2vec, the
    learned representation encodes community structure so it can be easily exploited
    by standard classification methods (Perozzi et al. [2014](#CR23)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Node2vec** further exploits a flexible neighborhood sampling strategy, that
    is, Breadth-first Sampling (BFS) and Depth-first Sampling (DFS), with parameters
    *p* and *q* to capture both local and global structure (Grover and Leskovec [2016](#CR14)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To ensure a fair comparison, we implement the directed version of DeepWalk
    and node2vec using OpenNE (an open-source package for network embedding, [github.​com/​thunlp/​openne](https://github.com/thunlp/openne)).
    For these random walk based embedding methods, we set several hyperparameters:
    the node embedding dimension *d* = 128, the size of window *k* = 4, the length
    of walk *l* = 10, and walks per node *r* = 4\. For node2vec, we grid search over
    *p*, *q* ∈{0.50, 1.0, 1.5, 2.0} according to Grover and Leskovec ([2016](#CR14)).
    For DeepWalk, we set *p* = *q* = 1.0 as it is a special case of node2vec. We implement
    the Skip-gram model by using a Python library named Gensim (Rehurek and Sojka
    [2010](#CR24)), a framework for fast Vector Space Modeling.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2.3 Metrics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the comprehensively, we randomly select {50%, 60%, 70%, 80%} of objective
    nodes as training set and the remaining objective nodes as test set respectively.
    We use the training set to train a classic binary classifier, namely, Support
    Vector Machine (SVM), and then use it to classify the samples of the test set.
    Note that we use fivefold cross validation to train the classifier and evaluate
    it on the test set.
  prefs: []
  type: TYPE_NORMAL
- en: For a binary classification task based on a supervised learning framework, it
    can be divided into the following four cases according to the actual labels of
    the samples and the prediction results of the classifier.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True Positive (TP): Samples whose labels are positive and also predicted to
    be positive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True Negative (TN): Samples whose labels are positive but predicted to be negative.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False Positive (FP): Samples whose labels are negative but predicted to be
    positive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False Negative (FN): Samples whose labels are negative and also predicted to
    be positive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In classification tasks, micro-F1 (Mi-F1) and macro-F1 (Ma-F1) are generally
    used to evaluate classification accuracy. First we have
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Precision: !['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$ \frac {TP}{TP+FP}$$
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq32.png)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recall: !['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$ \frac {TP}{TP+FN}$$
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq33.png)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: F1-score is an indicator used to measure the accuracy of the binary classification
    model. The calculation formula is![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} 2 \times \frac{precision\times recall }{precision
    + recall}. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ10.png)(3.10)'
  prefs: []
  type: TYPE_NORMAL
- en: Macro-F1 refers to calculating the total *precision* and *recall* of all categories
    for F1-score, while Micro-F1 refers to the calculation of F1-score after calculating
    the average of *precision* and *recall* for each category.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2.4 Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The results of micro-F1 (Mi-F1) and Marco-F1 (Ma-F1) are shown in Fig. [3.5](#Fig5).
    According to Fig. [3.5](#Fig5), we have the following observations:![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig5_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.5
  prefs: []
  type: TYPE_NORMAL
- en: Node classification performance with different training ratio
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our proposed methods T-EDGE, T-EDGE (TBS), T-EDGE (WBS), T-EDGE (TBS+WBS) overwhelmingly
    outperform DeepWalk and node2vec.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both T-EDGE(TBS) and T-EDGE(WBS) attain better performance than T-EDGE in which
    the random walk generator has uniform probability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both T-EDGE(TBS) and T-EDGE(WBS) perform better than T-EDGE(TBS+ WBS) which
    considers both temporal and amount information with parameter *α* = 0.5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All in all, our proposed methods learn effective node representations combined
    with rich information, which really help us obtain better performance in classification
    task. The result also indicates that time-dependent walks and edge information
    are essential in transaction networks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3 Link Prediction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The link prediction problem is to predict the appearance of links in a given
    graph based on the observed information. In this work, we evaluate the performance
    of the proposed T-EDGE method through a temporal directed link prediction task
    based on binary classification.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.1 Data Acquisition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To do the link prediction, we obtain three subgraphs with different size for
    experiments from Ethereum. EthereumG1 is centered by account “0x51faeda318982f439e
    800-12fb45d2b01-7ddccdbe” with *K*-in = *K*-out = 3; EthereumG2 is centered by
    account “0x5e247060f48eeb64367250ed03ff5091bba47fd1” with *K*-in = *K*-out = 4;
    and EthereumG3 is centered by account same as EthereumG1 with *K*-in = *K*-out = 4\.
    The summary of the dataset is listed in Table [3.4](#Tab4).Table 3.4
  prefs: []
  type: TYPE_NORMAL
- en: Statistics of datasets used in link prediction problem
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Current network | Node pairs split for classification |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dataset | &#124;*V* &#124; | &#124;*E′*&#124; | #train | #test | #test/train
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG1 | 3832 | 208927 | 13658 | 1140 | 8.35% |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG2 | 10628 | 208533 | 26958 | 7510 | 27.86% |'
  prefs: []
  type: TYPE_TB
- en: '| EthereumG3 | 26175 | 677785 | 66102 | 11502 | 17.40% |'
  prefs: []
  type: TYPE_TB
- en: Firstly, we sort all the collected edges based on their timestamps and presume
    that the earlier edges *E′* (with a smaller timestamp) as the known links, and
    *V* denotes the nodes which are involved in *E′*. The current network *G* = (*V*,
    *E′*) is formed by node set *V* and edge set *E′*. Then we can use graph embedding
    methods to learn node representations of the current network Φ(*v*) for ∀*v* ∈ *V* .
    Secondly, node pairs (*src*, *dst*) existing in *E′* are used as positive samples
    of the training set in the binary classifier. Then the negative samples are the
    equal number of node pairs which are randomly selected. We obtain features of
    a directed link from nodes *v* [*i*] to *v* [*j*] by concatenating their node
    embeddings, that is, *F* [*i*,*j*] = [ Φ(*v* [*i*]), Φ(*v* [*j*])]. If *i* = *j*,
    *F* [*i*,*j*] = *F* [*j*,*i*]. Finally, we train a support vector classifier to
    classify the links in the test set, whose positive samples are the residue links
    (with a larger timestamp).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.2 Setting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In experiments, we compared the proposed T-EDGE with two baseline random walk
    based graph embedding methods, DeepWalk (Perozzi et al. [2014](#CR23)) and node2vec
    (Grover and Leskovec [2016](#CR14)). To ensure the fairness of the comparison,
    we implement the directed version of DeepWalk and node2vec using OpenNE (THUNLP
    [2017](#CR27)), an open source toolkit for graph embedding. For these random walk
    based embedding methods, we have several hyperparameters: the node embedding dimension
    *d*, the size of window *k*, the length of walk *l*, and walks per node *r*. Generally,
    we set *d* = 128, and *k* = 4\. Specifically, we set *r* = 20, *l* = 10 for EthereumG1,
    *r* = 10, *l* = 10 for EthereumG2, *r* = 10, *l* = 20 for EthereumG3\. For node2vec,
    we grid search over *p*, *q* ∈ 0.50, 1.0, 1.5, 2.0\. For DeapWalk, we set *p* = *q* = 1.0
    as it is a special case of node2vec.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3.3 Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The performance of various methods on temporal directed link prediction is
    compared in terms of area under curve (AUC) and average precision (AP), which
    is shown in Table [3.5](#Tab5). For a clearer explanation, we only demonstrate
    two extreme sampling strategies of proposed algorithm: T-EDGE, which does not
    apply any bias, and T-EDGE (TBS+WBS), which combines biases from both time-domain
    and amount-domain with default *α* = 0.5\. According to Table [3.5](#Tab5), we
    have got the observations as follow: (1) T-EDGE without any bias overwhelmingly
    outperforms DeepWalk and node2vec, which manifests that for analysis and understanding
    of financial transaction networks, the temporal information as well as the multiplicity
    characteristic of edges in TWMDG is very significant and meaningful; (2) with
    biases of both time and amount domains, TEDGE (TBS+WBS) attains better performance
    than unbiased T-EDGE, which demonstrates that the abundant information in time
    and amount domains is indeed helpful for us to obtain a more comprehensive representation
    for predictive tasks.Table 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: Performances of different methods for link prediction
  prefs: []
  type: TYPE_NORMAL
- en: '|   | EthereumG1 | EthereumG2 | EthereumG3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Metrics(%) | AUC | AP | AUC | AP | AUC | AP |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| DeepWalk | 82.71 | 76.69 | 85.91 | 82.13 | 79.92 | 77.72 |'
  prefs: []
  type: TYPE_TB
- en: '| node2vec | 83.03 | 76.94 | 86.30 | 82.47 | 82.20 | 79.99 |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE | 87.73 | 83.73 | 92.85 | 90.29 | 93.00 | 90.78 |'
  prefs: []
  type: TYPE_TB
- en: '| T-EDGE(TBS+WBS) | **89**.**55** | **85**.**58** | **93**.**36** | **90**.**94**
    | **93**.**83** | **91**.**89** |'
  prefs: []
  type: TYPE_TB
- en: 'In order to further illustrate the advantages of T-EDGE methods, we compares
    the performance of the embedding methods on EthereumG1 with varying value of node
    embedding dimension *d*, walk length *h*, walks per node *l*, and window size
    *k*. Results in Fig. [3.6](#Fig6) point out: (1) T-EDGE with or without additional
    biases consistently is always better than DeepWalk and node2vec under different
    conditions of *k*, *l*, *r*; (2) DeepWalk and node2vec are more sensitive to two
    hyperparameters, walk length *l* and walks per node *r*, while T-EDGE methods
    can always achieve satisfactory results with a wide variance of both *l* and *r*;
    (3) interestingly, with the increase of *d*, the performance of T-EDGE methods
    monotonically improves, while the performance of DeepWalk and node2vec decreases
    as *d* exceeds 64, which implies that T-EDGE methods can embed more useful information
    and thus for data representation it requires a larger value of *d*.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig6_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig6_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.6
  prefs: []
  type: TYPE_NORMAL
- en: Performance in terms of Area Under Curve (AUC) under varying hyperparameters,
    when (**a**) fixing *l* = 10, *r* = 20, *d* = 128, and varying *k* from 2 to 8;
    (**b**) fixing *k* = 4, *r* = 20, *d* = 128, and varying *l* from 4 to 10; (**c**)
    fixing *k* = 4, *l* = 10, *d* = 128, and varying *r* from 8 to 20; (**d**) fixing
    *k* = 4, *l* = 10, *r* = 20, and varying *d* from 8 to 256
  prefs: []
  type: TYPE_NORMAL
- en: To further look into the sampling strategies of T-EDGE methods, we provide results
    of all possible combinations of different biases in both time and amount domains.
    Figure [3.7](#Fig7) shows that averagely, biased methods T-EDGE (TBS), TEDGE (WBS),
    and T-EDGE (TBS+WBS) outperform the unbiased method T-EDGE; adding bias in both
    temporal and weighted domain methods T-EDGE (TBS+WBS) surpass adding only one
    bias methods T-EDGE (TBS) and T-EDGE(WBS).![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig7_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.7
  prefs: []
  type: TYPE_NORMAL
- en: Heat map of Area Under Curve (%) for link prediction using proposed T-EDGE with
    different combinations of strategies
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4 Transaction Tracking on Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The emergence of blockchain provides an ideal solution to solve the trust problems
    and achieving efficient collaboration in the digital world. It is well known that
    the industry has special expectations for blockchain as a new application scenario
    of Internet infrastructure. However, various types of cybercrime have also arisen
    on the blockchain ecosystem in recent years. Criminals take advantage of the anonymity
    of blockchain to evade supervision and engage in money laundering, smuggling,
    and other illegal activities. For instance, Bitcoin is reported to be involved
    in a number of illegal transactions on the dark web marketplaces, for example,
    “Silk Road,” which hided a lot of drug dealing, assassinations, and other crimes
    (ElBahrawy et al. [2019](#CR11)). Besides, for Ethereum which supports the functionality
    of smart contracts, more types of cybercrimes have been reported, such as exploits,
    hacks, phishing, and ponzi schemes (Chen et al. [2018b](#CR7); Ethereum).
  prefs: []
  type: TYPE_NORMAL
- en: Due to the rise of cybercrimes on blockchain systems, *transaction tracking*
    of cryptocurrencies has become an increasingly urgent issue. The past few years
    have witnessed a rise in a series of well-known projects and companies in the
    field of transaction tracking on the blockchain, such as Chainalysis, Ethereum,
    and CipherTrace. Transaction tracking is an interesting and important issue for
    regulators, cryptocurrency exchanges, as well as investors. For regulators, transaction
    tracking can assist them to identify fraud gangs, trace the capital flow, retrieve
    the stolen money, and improve the regulatory system. For example, it is reported
    that Chainalysis has helped the FBI identify two agents on corruption charges
    of stealing bitcoin from an online drug market operator (O’Neill [2017](#CR22)).
    While for cryptocurrency exchanges, transaction tracking improves their capabilities
    of know your transaction (KYT) and anti-money laundering (AML), and thus better
    understand the market and ensure that the rights of law-abiding users are not
    affected. Besides, for ordinary investors or cryptocurrency companies, they can
    employ the results of transaction tracking to check whether some funds or transactions
    have been associated with illegal identities or polluted by traveling through
    suspicious paths, which prevents the withdrawals to blacklisted addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, the huge transaction records of cryptocurrencies can be modeled
    as a network for analysis and understanding. Take Ethereum as an example, its
    transaction history can be modeled as a directed transaction network, where a
    node represents an account and an edge connecting two nodes refers to the existence
    of at least one transaction between them. In this work, we study the issue of
    transaction tracking on Ethereum from a network perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Current research on transaction tracing mainly discuss about how to trace the
    capital flow in the past by studying the transaction records, while the problem
    of using past records to predict future transactions are rarely considered. However,
    predicting transaction execution is another way to study transaction tracking
    effectively. Hence in this part, we provide an example of studying the prediction
    facet of transaction tracking on Ethereum, and by this way, also can discover
    the driving factors of Blockchain transaction network evolution.
  prefs: []
  type: TYPE_NORMAL
- en: In Fig. [3.8](#Fig8), we plot the relationships between transaction tracking,
    network evolution, and link prediction on Ethereum. More details about these three
    issues are discussed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 1.Transaction tracking of cryptocurrency consists of two parts, tracing and
    prediction. The problem of tracing pays attention to how the cryptocurrency accumulated
    and flowed in the past by studying the transaction records. While the problem
    of prediction tries to figure out where the cryptocurrency will go in the future.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig8_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig8_HTML.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fig. 3.8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The relations among transaction tracking, network evolution and link prediction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the field of network science, link prediction and network evolution are
    closely related: The link prediction method provides a quantitative technique
    to evaluate the corresponding evolutionary model, while the mechanism of network
    evolution gives an interpretation to the results of the corresponding link prediction
    model. In addition, link prediction and network evolution can be viewed as analyzing
    the rules of network changes over time from the microscopic and macroscopic perspectives,
    that is, link prediction focuses on predicting the generation of new links in
    the network and network evolution studies the overall change trends of the whole
    network.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link prediction aims to predict the occurrence of links in a given network on
    the basis of observed information (the existing links are used as the training
    data for learning to predict the future links in the test set). Similarly, transaction
    tracking tries to predict future transactions by mining and extracting information
    from historical records. Thus, it is reasonable to deal with problem of the transaction
    tracking with link prediction techniques from a network perspective.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the cryptocurrency transaction is a kind of financial and social behaviors
    (Alqassem et al. [2020](#CR2)), the transaction patterns are driven by intrinsic
    mechanisms and the transaction networks should exhibit some corresponding evolution
    rules. Therefore, exploring the rules and factors of network evolution can provide
    important insights for designing the cryptocurrency tracking strategies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In consideration of the relationship between link prediction and network evolution,
    we propose a comprehensive framework with supervised link prediction approach
    for transaction network analysis. Besides, we explore how two important factors
    in financial networks, namely, transaction time and transaction amount, impact
    the evolution of Ethereum transaction network. In particular, we discuss the scenarios
    in which the new transaction relationships are more likely to arise, as shown
    in Fig. [3.9](#Fig9).![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig9_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.9
  prefs: []
  type: TYPE_NORMAL
- en: 'A draft of discovering new relationship generation factor in Ethereum transaction
    network. Scenario (**a**) and (**b**) consider transaction features (i.e., edge
    features). We notice that in scenario (**a**), there is much *Ether* involved
    in the money transfer path {*a* → *d* → *e*} than that in {*a* → *b* → *c*}. In
    scenario (**b**), there are more frequent transactions in the money transfer path
    {*a* → *d* → *e*} than that in {*a* → *b* → *c*}. To investigate the driving factors
    of Ethereum, we seek to answer the issue: *In which situation it is more likely
    to generate new transaction between accounts* (*a*, *c*) or (*a*, *e*)*?*'
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we introduce a framework to investigate the transaction tracking
    problem and the evolution factors of Ethereum transaction networks via embedding
    based link prediction. First, convert the transaction records to a temporal weighted
    multidigraph from a network perspective, which has been showed in Sect. [3.3](#Sec5).
    Next we trace the transaction paths by running random walks with different strategies
    to obtain co-occurrence statistics considering different factors, and then learn
    representations mapping the original graph into the embedded space. Last, by employing
    link prediction methods, we predict the transactions, and then try to infer the
    possible factors of network evolution by comparing the results derived from different
    walk strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4.1 Embedding Based Link Prediction for Investigation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Link prediction is a quantitative tool to investigate the evolution mechanism
    comprehensively. It is to estimate the likelihood of the existence of links between
    node pairs based on the current network in formation, such as the observed links
    and node attributes (Kumar et al. [2020](#CR16)). Link prediction techniques like
    similarity-based indices are difficult with dealing large-scale networks, since
    calculating the indices for each unconnected node pairs is time-consuming for
    Ethereum transaction networks.
  prefs: []
  type: TYPE_NORMAL
- en: Network embedding is considered as a dimension reduction technique which has
    become a popular research direction in the field of graph mining in recent years
    (Cai et al. [2018](#CR4)). Network embedding, also known as network representation
    learning, is an effective representation of networks preserving the node neighborhood
    structures. Similar nodes in the original network should have similar node vectors
    in the embedded low-dimensional space, as shown in Fig. [3.10](#Fig10).![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig10_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.10
  prefs: []
  type: TYPE_NORMAL
- en: A toy example of embedding the network into a 2D space. (**a**) Input graph.
    (**b**) Embedding space and nodes
  prefs: []
  type: TYPE_NORMAL
- en: For scalable networks, random walk mechanism has been widely proved to be an
    effective technique to capture structural relationships between nodes (Perozzi
    et al. [2014](#CR23)). With various walking strategies considering different factors,
    the original network is transformed into different collections of node sequences
    by sampling truncated random walks. The occurrence frequency on short random walks
    of a node and its content reflects the proximity between them. Therefore, the
    obtained node sequences with different distributions results in various node representations
    via the optimization procedure.
  prefs: []
  type: TYPE_NORMAL
- en: For the Ethereum transaction network which can be modeled as Temporal Weighted
    Multidigraph, we propose a dynamic node representation method consisting of two
    main parts, random walk and optimization procedure, which has been explained in
    detail in Sect. [3.4.1](#Sec11). Here, we give a complete algorithm for you to
    better understand it. Combining the two parts, the pseudocode for temporal weighted
    multidigraph embedding is given in Algorithm [3.1](#FPar2).
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.1 Temporal weighted multidigraph embedding![../images/506524_1_En_3_Chapter/506524_1_En_3_Figa_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Figa_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4.2 Evaluation Measurement of Temporal Link Prediction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Link prediction aims to predict the appearance of links in the network based
    on observed information. In conventional link prediction experiments where links
    have no timestamp, the observed links of the network are usually randomly divided
    into training and test sets.
  prefs: []
  type: TYPE_NORMAL
- en: For the problem of link prediction considered in a temporal network considered
    here, we find it more reasonable to split the train-test set according to the
    timestamp and use the existing links in the past to predict the occurrences of
    links in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'We depict the main steps of the temporal link prediction in Fig. [3.11](#Fig11),
    and explain each of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.We sort all the edges collected from transaction records by timestamps and
    assume that 50% of the earlier edges as the known edges, which constitute the
    current network.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig11_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig11_HTML.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fig. 3.11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The main steps of temporal link prediction in our work. t r a i n_p o s a n
    d t e s t_p o s are the positive links of the training set and test set, and t
    r a i n_n e g a n d t e s t_n e g are the negative links of the training set and
    test set, respectively
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we can learn node representations of the current network Φ(*v*) for ∀*v* ∈ *V* via
    graph embedding methods. For the embedding methods based on random walk, we have
    several hyperparameters: the node embedding dimension *d*, the size of window
    *k*, the length of walk *l*, and walks per node *r*. In general, we set *d* = 128,
    and *k* = 4\. Specifically, we set *r* = 20, *l* = 10 for EthereumG1, *r* = 10,
    *l* = 10 for EthereumG2, and *r* = 10, *l* = 20 for EthereumG3.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the binary classifier, the 50% links with earlier timestamps in the original
    network act as positive samples of the training set, and the remainder (the 50%
    links with later timestamps) are treated as the positive samples of the test set.
    Besides, we randomly sample an equal number of node pairs with no link as negative
    samples of the training set and the test set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the evaluation of link prediction experiments, the samples in test set can
    be divided into four categories, according to the combination of the ground-truth
    category and the prediction category.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True Positive (TP): The positive data item (the existent link) predicted as
    positive'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True Negative (TN): The negative data item (the nonexistent link) predicted
    as negative'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False Positive (FP): The negative data item (the nonexistent link) predicted
    as positive'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False Negative (FN): The positive data item (the existent link) predicted as
    negative'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Based on the four categories, the following two metrics can be derived.
  prefs: []
  type: TYPE_NORMAL
- en: 1.True positive rate (TPR):![
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} TPR= \frac{\#TP}{\#TP+\#FN}. \end{aligned} $$
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ11.png)(3.11)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.False positive rate (FPR):![
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \frac{\#FP}{\#FP+\#TN}. \end{aligned} $$
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ12.png)(3.12)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, based on TPR and FPR, we calculate area under curve (AUC) to evaluate
    the performance of the experiments. AUC is a commonly considered metric in many
    predictive tasks, and its value is usually defined as the area under the receiver
    operating characteristic curve (ROC), whose horizontal axis is FPR and vertical
    axis is TPR. The higher the AUC value is, the more accurate the classifier.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5 Results and Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 3.4.5.1 Investigation on the Transaction Time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we investigate how the temporal information affects the evolution of Ethereum
    transaction networks. Consider a random walk which is currently stopping at a
    node *v* [*i*], the next node of the random walk is decided by selecting a temporally
    valid edge of node *v* [*i*]. As mentioned before, this edge is selected from
    the set of temporal successive edge denoted as *L* [*t*](*v* [*i*]) using a particular
    sampling bias. Considering transaction time information, each candidate edge *e* ∈ *L*
    [*t*](*v* [*i*]) is assigned a selection probability *P* [*T*](*e*) whose calculation
    methods under different walking strategies are given in Table [3.6](#Tab6). The
    four kinds of walking strategies with the consideration of transaction time information
    are explained as follows:Table 3.6
  prefs: []
  type: TYPE_NORMAL
- en: Sampling biases in different walking strategies, taking the timestamp (transaction
    time) of edges into account. *T* [*max*] is the largest timestamp of the current
    network
  prefs: []
  type: TYPE_NORMAL
- en: '| Factor | Walking strategies | Equation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| From *WS* [4] to *WS* [1], the random walks tend to sample the successive
    transactions with shorter time interval. | *WS* [1] | *P*(*e*) = ![ $$\frac {T_{max}-T(e)}{\sum
    _{e''\in L_t(v_i)}~(T_{max}-T(e''))}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq34.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *WS* [2] | *P* [*T*](*e*) = ![ $$\frac {\eta _-(T(e))}{\sum _{e''\in
    L_t(v_i)}~\eta _-(T(e''))}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq35.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *WS* [3] | *P* [*T*](*e*) = ![ $$\frac {1}{&#124;L_t(v_i)&#124;}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq36.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *WS* [4] | *P* [*T*](*e*) = ![ $$\frac {\eta _+(T(e))}{\sum _{e''\in
    L_t(v_i)}~\eta _+(T(e''))}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq37.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [1]: This strategy assumes that the earliest transaction (with
    the smallest timestamp) of the current node has the highest probability of being
    selected as the next edge of the random walk. More specifically, the selection
    probability of the next walk (i.e., transaction) is linearly dependent on the
    time interval between the next walk timestamp *T*(*e*) and the largest timestamp
    *T* [*max*] of the current network.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [2]: Similar to Strategy *WS* [1], an earlier transaction has
    a higher probability to be selected. Yet this strategy employs a descending ranking
    function *η* [−] which maps the timestamp of edges to a descending order. The
    selection probability of the next walk is linearly dependent on the descending
    ranking of the timestamp *η* [−](*T*(*e*)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [3]: Under this strategy, each candidate transaction has the
    identical probability to be selected.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [4]: This strategy is an opposite of Strategy *WS* [2], and the
    earliest transaction of the current node has the lowest probability of being selected
    as the next edge of the random walk. Analogically, this strategy employs an ascending
    ranking function *η* [+] which maps the timestamp of edges to an ascending order.
    The selection probability of the next walk is linearly dependent on the ascending
    ranking of the timestamp *η* [+](*T*(*e*)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The essence of different strategies is to adjust the effects of time interval
    between successive edges on sampling random walk paths, which meanwhile influence
    the proximity between nodes in the graph. We can see that, walking strategies
    in Table [3.6](#Tab6), from *WS* [1] to *WS* [4], the random walks tend to sample
    the successive transactions with longer time intervals. Figure [3.12](#Fig12)
    compares the performance of link prediction under different walking strategies
    in terms of AUC. On all the three transaction networks, the algorithm based on
    Strategy *WS* [1] outperforms the rest.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig12_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.12
  prefs: []
  type: TYPE_NORMAL
- en: Link prediction result considering transaction time factor with different walking
    strategies
  prefs: []
  type: TYPE_NORMAL
- en: Back to the problem of transaction tracking of cryptocurrencies, we can roughly
    infer that in an Ethereum transaction network, the generation of new transaction
    is related to the time factor. The answer to the question in Fig. [3.9](#Fig9)b
    is that, it is more likely to generate new transaction between accounts *a* and
    *e*. This indicates that new transactions are more likely to take place between
    node pairs with more frequent transactions in the path. When tracking the money
    flow among Ethereum accounts, we should pay more attention to those transaction
    paths with shorter time interval.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5.2 Investigation on the Transaction Amount
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we investigate the effects of edge weight information (i.e., transaction
    amount value) on the link prediction experiments. With the consideration of transaction
    amount, each candidate edge *e* ∈ *L* [*t*](*v* [*i*]) is assigned a selection
    probability *P* [*W*](*e*) whose calculation methods under different walking strategies
    are given in Table [3.7](#Tab7), and walking strategies with the consideration
    of transaction time information are explained as follows:Table 3.7
  prefs: []
  type: TYPE_NORMAL
- en: Sampling biases in different walking strategies, taking the weight (transaction
    amount) of edge into account
  prefs: []
  type: TYPE_NORMAL
- en: '| Factor | Walking strategies | Equation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| From *WS* [7] to *WS* [5], the random walks tend to sample the successive
    transactions with largest transaction amount. | *WS* [5] | *P* [*W*](*e*) = ![
    $$\frac {W(e)}{\sum _{e''\in L_t(v_i)} W(e'')}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq38.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *WS* [6] | *P* [*W*](*e*) = ![ $$\frac {\eta _+(W(e))}{\sum _{e''\in
    L_t(v_i)} \eta _+(W(e''))}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq39.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *WS* [7] | *P* [*W*](*e*) = ![ $$\frac {1}{&#124;L_t(v_i)&#124;}$$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_IEq40.png) |'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [5]: This strategy assumes that the probability of each candidate
    edge being selected is proportional to its edge weight, that is, the transaction
    amount *W*(*e*).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [6]: Under this strategy, an edge with higher weight has a higher
    probability to be chosen, but a linear mapping function (i.e., ranking function)
    is adopted to weaken the impact of edge weight information, comparing with Strategy
    *WS* [5]. Specifically, the selection probability of the next walk is linearly
    dependent on *η* [+](*W*(*e*)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Strategy *WS* [7]: Under this strategy, each candidate transaction has the
    identical probability to be selected.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From Strategy *WS* [5], *WS* [6], to *WS* [7], the impact of edge weight gradually
    weakens. The result given in Fig. [3.13](#Fig13) demonstrates that the link prediction
    model based on Strategy *WS* [5] attains the best performance. This result implies
    that the likelihood of transaction occurrence in the future is positively related
    to transaction amount. In most cases, the larger amount of transaction, the closer
    relationship between two accounts. We can have an answer to the question in Fig.
    [3.9](#Fig9)a—it is more likely to generate new transaction between accounts *a*
    and *e*. As nodes *a* and *e* have large amount transactions with a common neighbor
    *d*, the relationship between them should be much stronger than that between nodes
    *a* and *c*. When dealing with the transaction tracking problem, we should pay
    more attention to those transaction paths with larger amount.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig13_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig13_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.13
  prefs: []
  type: TYPE_NORMAL
- en: Link prediction result considering transaction amount factor with different
    walking strategies
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5.3 Investigation on Both Factors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Furthermore, we combine both the temporal and weight factors, and investigate
    how they influence transaction evolution. We combine the aforementioned sampling
    probabilities from both temporal and weighted domains by setting the probability
    of choosing edge *e* as:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)_{TW} = P_T(e)^\alpha P_W(e)^{(1-\alpha)},
    \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ13.png)(3.13)where
    *α* is a tuning parameter varying from 0 to 1\. Here *α* = 0.5 is the default
    value for balancing between time domain and amount domain. Notably, *P* [*T*](*e*)
    denotes to the selecting probability with Strategies from *WS* [1] to *WS* [4],
    and *P* [*W*](*e*) denotes to the selecting probability with Strategies from *WS*
    [5] to *WS* [7]. Finally there is a standardized operation as!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} P(e)=\frac{P_{TW}(e)}{\sum_{e'\in L_t(v_i)}
    P_{TW}(e')}. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_3_Chapter/506524_1_En_3_Chapter_TeX_Equ14.png)(3.14)We
    provide the results of all possible combinations of time domain strategy and amount
    domain strategy in Fig. [3.14](#Fig14), and can observe that from bottom to top,
    from left to right, link prediction model tends to obtain better performance.
    Moreover, when the amount factor is taken into account, especially with Strategy
    *WS* [5] (the rightmost column), the difference between combining different time
    strategies is less obvious.![../images/506524_1_En_3_Chapter/506524_1_En_3_Fig14_HTML.png](../images/506524_1_En_3_Chapter/506524_1_En_3_Fig14_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.14
  prefs: []
  type: TYPE_NORMAL
- en: Link prediction result considering both the transaction time and amount factors.
    (**a**) *EthereumG1*. (**b**) *EthereumG2*. (**c**) *EthereumG3*
  prefs: []
  type: TYPE_NORMAL
- en: The results further verify that both the time and amount factors impact the
    Ethereum transaction interaction, and imply that the amount factor has greater
    influence than the time factor on the network evolution. This inspires us to pay
    more attention to the transactions with large amount when talking about transaction
    tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we briefly introduced the complex network, which is an important
    mean to understand complex system. And we proposed a novel framework for Ethereum
    analysis through network embedding. Particularly, we constructed a temporal weighted
    multidigraph to reserve information as much as possible and present a graph embedding
    method called T-EDGE which incorporates temporal and weighted information of financial
    transaction networks into node embeddings. To investigate the impact of transaction
    time and amount, we design flexible walking strategies for random-walk based temporal
    network embedding.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the proposed and two baseline embedding methods on the actual
    Ethereum network to achieve two actual-related prediction tasks, namely temporal
    link prediction and phishing/non-phishing node classification, and we first discussed
    the importance of the transaction tracking problem on Ethereum and dealt with
    this problem from the network science perspective. Technically, we presented a
    comprehensive framework to explore the factor of Ethereum transaction network
    evolution via network-embedding based link prediction. Experimental results demonstrated
    the effective of the proposed T-EDGE embedding method, meanwhile indicating that
    a temporal weighted multidigraph can more comprehensively represent the temporal
    and financial properties of dynamic transaction networks.
  prefs: []
  type: TYPE_NORMAL
