## 第一部分。

【第一部分】（#part01）是对以太坊 Dapps 和相关技术的高级介绍。【第一章】（kindle_split_012.xhtml#ch01）介绍了去中心化应用。【第二章】（kindle_split_013.xhtml#ch02）阐述了区块链和智能合约。【第三章】（kindle_split_014.xhtml#ch03）介绍了以太坊平台，包括以太坊虚拟机（EVM）、Go Ethereum（geth）客户端和以太坊钱包。在本部分，你将建立继续阅读本书所需的基础知识。你还将实现你的第一个 Dapp——一个简单的加密货币——在【第四章】（kindle_split_015.xhtml#ch04），将其部署在公共测试网络上。

## 第一章。初探去中心化应用

| ``` |
| --- |

**本章内容概述**

+   去中心化应用是什么

+   去中心化应用的样子以及它是如何工作的

+   Dapp 术语

+   适合和不适合的 Dapps

| ``` |
| --- |

你有多少次发现自己处于以下情况？你在浏览购买最新小玩意，并在网上比较价格时，发现[SmallWebRetailer.com](http://SmallWebRetailer.com)比[WellKnown.com](http://WellKnown.com)便宜 30%。你迅速把商品加入购物车，担心价格随时会上涨，并输入了你的邮寄地址和信用卡详情，但突然...你打退堂鼓。你开始怀疑：这个价格是不是好的不真实？如果这个不知名的[SmallWebRetailer.com](http://SmallWebRetailer.com)是个骗局怎么办？他们会卷走我的钱吗？在犹豫了几分钟是否点击购买按钮后，你打开了一个新浏览器标签页，直接访问了[WellKnown.com](http://WellKnown.com)。你提交了订单，意识到你可能为这个小玩意多付了 30%的钱。

你为什么会恐慌？也许你不信任[SmallWebRetailer.com](http://SmallWebRetailer.com)。也许你不想浪费时间联系信用卡公司，可能还要等待如果交易变坏时的退款。

如果你能通过一个“替代电子商务应用”从同一个小型未知零售商那里购买小玩意，这个应用能保证卖家在您确认订单安全交付之前无法接触到您的钱，那会怎样？如果这个保证不是由卖家或单一的第三方提供，而是由许多独立参与的一个平台提供，这个平台旨在根据任何人都可以检查的软件条件处理交易呢？慢着，我可能说得有点快了。我会更慢地重复一遍：

1.  如果资金转账在交付后才被释放，不是由零售商或第三方，而是由平台上的许多参与者来持有，那会怎样？

1.  如果资金托管和释放的规则是通过逻辑编码，而不是受人工交互影响呢？

1.  如果你仍然不够信服，那假如你可以亲自检查代码呢？

我敢打赌，您会点击购买，自信您的资金将安全地存储在这个平台上，直到货物送达。这样的系统确实存在，它们被称为*去中心化应用程序*。像 OpenBazaar 这样的去中心化市场就是这样的运作方式。[`openbazaar.org/`](https://openbazaar.org/)。资金在您确认商品安全送达后才转到卖家的机制称为*智能合约*。

去中心化应用程序，也被称为*去中心化应用*或*Dapps*（通常发音为 dee-apps），是新一代网络应用程序的一部分，旨在增加商业交易、政府流程、供应链以及所有目前需要客户和供应商、用户和提供商之间相互信任的系统的透明度。Dapps 的目标是尽量减少或消除系统参与者之间的信任需求，以实现超越 Web 2.0 的用户赋权。一些人认为 Dapps 可能是 Web 3.0 的支柱。

假设您有编程经验——如果使用 JavaScript 就更好了——并且对网络应用程序有些了解，这本书将教您如何构建由一个或多个由用户界面控制的智能合约组成的 Dapps。到本书结束时，您将不仅能够编写智能合约代码，还能够设计、实现、测试、调试、部署和一个完整的端到端去中心化应用程序。在这个过程中，您还将学习一种新语言，一个新平台，以及最重要的，一种关于设计、思考和运行应用程序的新方式。

在第一章中，我将为您提供一个关于 Dapps 的高级概览。我将详细解释它们是什么，长什么样子，建立在什么技术栈上，以及在什么情况下构建它们是有意义的。更重要的是，我会帮助您开始构建您自己的 Dapp！让我们开始我们的旅程。

### 1.1. 什么是 Dapp？

在我谈论去中心化应用程序之前，我将刷新一个您可能已经熟悉但很可能没有意识到的概念：那就是*中心化应用程序*。您可能从未听说过这个表达，因为传统的网络和企业应用程序在其用户方面是隐式中心化的。我能听到您在问，“中心化”到底是什么意思？

一个*中心化应用程序*或系统是由一个或*中央*实体控制的：一个人、公司、机构、政府机构等等。实体直接在其场地上或通过一个服务或云提供商托管系统，并拥有系统架构中所有组件和层的全权控制。用户信任中央实体的善意，并根据实体的声誉决定是否访问其系统。从用户的角度来看，系统要么是*可信*的，要么不是。这就是大多数网络和企业应用程序目前的设计方式。

图 1.1（#ch01fig01）展示了用户与一个*集中式* *可信*系统之间的典型交互。你不应该觉得它有什么奇怪的地方。

##### 图 1.1。集中式应用与控制它的单一实体有很强的关联。因此，用户根据对实体的信任来决定是否访问它。

![](img/fig01-01_alt.jpg)

让我们来看看去中心化应用。如果你稍微考虑一下我之前介绍的替代电子商务应用，你会同意它在[SmallWebRetailer.com](http://SmallWebRetailer.com)方面有一些优势：

+   有利的交易条件——只有当零售商遵守与交易相关的所有条件，例如你确认安全交货时，交易才会完成，并将全部款项转移给零售商。这将消除你对[SmallWebRetailer.com](http://SmallWebRetailer.com)的最大疑虑之一：是否能够收到交货以及如果不能，你的钱会怎样。

+   独立的交易执行和验证——交易不会由零售商或单一的第三方处理，而是由支持电子商务应用的平台上的众多参与者之一处理，然后平台上的所有参与者都会独立地验证它。所有各方用来对交易的验证达成一致的机制被称为*共识*（在注释中定义）。共识机制会让你相信，承诺的交易条件将由许多独立方执行和验证，而不是一个不知名的零售商。

|  |
| --- |

##### 定义

共识是一种*分布式和无需信任*的对交易验证达成一致的形式。*分布式*意味着独立的中央权威机构不执行交易的验证；相反，所有各方共同贡献并同意其验证。*无需信任*意味着各方不需要相互信任就能对验证结果达成一致。当参与者的合格多数同意了交易的结局时，共识就达成了。

|  |
| --- |

+   透明度——你将能够检查处理交易的代码并验证它是否在转账给零售商之前遵守了指定的条件。这将给你额外的信心，应用程序是在承诺的条款下执行的。

你可以通过构建作为一个由平等重要和功能的处理节点网络的替代电子商务应用来实现所有这些要求，每个节点由不同的方拥有。每个节点将

+   能够像其他节点一样处理交易

+   像其他节点一样验证所有交易

+   以平等的方式对交易结果做出贡献

这种架构的后果将是处理过程将分散到一组独立节点的网络中，而不是集中到特定实体拥有的特定服务器上。这种去中心化将使用户不必信任特定实体：用户只需信任整个网络的设计。

基于此架构的应用程序被称为**去中心化应用**（Dapp）。我将提供另一个例子以使这个概念更清晰。

#### 1.1.1\. Dapps 与传统的中心化应用

为了更清楚地解释构建 Dapp 的好处，以及与开发传统中心化应用相比的优点，我将为您举一个典型的用例：一个电子投票应用。

##### 中心化投票应用

传统的中心化投票应用程序通常由公司提供，以促进股东投票，或由地方政府或政府提供，以促进法律提案的批准或选择。运行应用程序的机构在投票期间至少直接或间接拥有它。

如图 1.2 顶部所示，中心化投票应用运行在一个或多个应用服务器上，这些服务器连接到一个中心数据库。系统通过一个或多个托管投票网站的网络服务器暴露给选民。机构可以在自己的场所或云端托管网络、应用和数据库服务器。如果机构内部开发了投票系统，则可以通过提供基础设施即服务（IaaS）的云服务提供商进行云托管；如果投票系统只是在投票期间从外部提供商那里租用或租用，则可以通过提供软件即服务（SaaS）的云应用提供商进行云托管。从选民的角度来看，这种架构可能不是理想的，因为可能存在关于信任和安全的潜在担忧。

##### 对中心化投票的信任

考虑到过去几年在企业层面和政府层面发生的所有金融和会计丑闻，如果您不完全*信任*您是股东或公民的组织，这是可以理解的。您可能想知道电子投票的结果是否可能以某种方式被操纵。

例如，很容易想象，一个恶意开发人员或投票应用的管理员，与某些有兴趣达到某种投票结果的党派勾结，可以访问系统的关键部分，并篡改投票的收集、处理和存储方式，在应用程序架构的不同层次上。根据应用程序的设计方式，某些恶意数据库管理员甚至可能 retroactively 修改投票。

##### 中心化投票的安全性

通过集中式应用投票时，您不仅会担心组织选举的公司或机构的善意，还会担心系统是否足够安全，以防止外部操纵。例如，外部各方可能希望投票结果朝某个方向发展，并可能通过入侵系统来获得他们所期望的结果。

如我之前解释的，集中式投票系统只包括位于同一网络中的少数服务器。每台服务器通常只提供一种功能，因此从处理角度看，它是一个单点失败，而且尤其是从安全角度看。例如，如果黑客设法修改 Web 服务器的代码，以便在那一层拦截并修改投票，整个系统都会受到威胁。通过仅入侵应用服务器或，更好的是，数据库服务器，可以实现相同的结果。系统中的一个安全漏洞就足以威胁到整个系统的安全。

##### 去中心化投票应用

去中心化应用程序基于两个关键技术原则：

+   它的应用逻辑在*点对点(P2P)网络*的每一台服务器上同时存在并独立执行。在理论 上，每一台服务器由不同的参与者拥有，也称为*节点*。中心节点不控制或协调服务器；相反，它们直接相互通信，因此也被称为*对等节点*。它们持续地验证彼此的输出，因此用户只需信任 P2P 网络，而不需要信任某个单独的组织。应用数据和状态存储在网络中每台服务器的本地数据库副本上，如图 1.2 所示。

+   它的数据库技术，称为*区块链*，确保数据不能被追溯修改。

##### 图 1.2. 集中式投票应用与去中心化投票应用的比较。集中式应用的所有服务器都由一个机构拥有。而去中心化投票应用则是在不同实体拥有的网络多个节点上同时运行。

![](img/fig01-02_alt.jpg)

##### 信任和安全得益于 P2P 网络复制

根据我概述的两个原则，您如何通过去中心化投票应用来解决信任和安全问题？去中心化投票应用通过在包括许多服务器的网络中复制其执行，使信任和安全漏洞变得毫无意义，理论上每个服务器都由不同的方拥有。想想看：如果投票不是由一台单一服务器处理和验证，而是由许多不同方拥有且独立运行的服务器处理和验证，并且它们不是存储在单一数据库中，而是存储在许多本地数据库中，每个数据库都由处理方拥有，那么信任和安全问题都将得到解决：

+   信任—如果参与者之一试图恶意地篡改选票并将其修改后的选票传播到网络中，其他参与者在验证过程中会发现选票被修改了，并将拒绝它。他们不会在本地数据库副本中存储它，并且不会将修改后的选票进一步传播到网络中，因此恶意修改变得毫无意义。

+   安全性—黑客在去中心化系统中尝试篡改选票会比在中心化系统中难得多。即便他们成功地在某台服务器上修改了选票，或者他们自己在一台去中心化投票应用网络的服务器上进行操作以更容易地篡改，其他参与者也会发现并拒绝这种修改，如前所述。因此，成功的黑客攻击将需要同时攻陷网络中至少 51%的节点，假设应用程序的状态是网络节点中的大多数所达成的共识。如你所理解，试图操纵包括成千上万服务器在内的网络的大部分，特别是如果每个服务器都独立管理的话，是一项极其困难的任务。此外，每个服务器可能都有不同的防止安全漏洞的方法。

##### 区块链带来的 Dapps 的信任和安全

区块链数据库基于一种数据结构，正如其名称所示，它是区块的链条。区块可以被看作是包含一组交易记录，每个记录都经过数字签名，一些元数据（如区块号码和时间戳信息），以及到前一个区块的链接。每笔交易、每个区块整体以及区块之间的链接都通过加密技术得到保护，这使得它们*不可更改*：回溯性地修改单个交易几乎是不可能的，尤其是当链中添加更多区块时。因此，区块链数据库通过提供进一步的保护，以防止恶意参与者和外部实体对应用程序进行篡改尝试，从而解决信任和安全问题。

##### 低级方面的未解问题

在这个阶段，你可能从逻辑或高层次的角度认为去中心化投票应用概念是有希望的，但你可能仍然对它的物理和低级架构方面感到困惑。你可能在各个领域都有疑虑：

+   系统架构—去中心化投票应用的网络是一种特殊的网络吗？服务器是否使用特殊的协议或标准互联网技术进行相互通信？

+   投票处理和验证—投票提交是如何在网络上传播，以便在网络的每台服务器上进行处理的？投票是如何被计数并存储在区块链上的？网络的一名成员是如何验证从其他成员那里接收到的合并投票记录的真实性的？

在接下来的两个部分中，我将尝试回答这些问题，这些部分涵盖了去中心化投票应用的高级细节。我还假设投票 Dapp 是为以太坊开发的，这是本书关注的区块链和 Dapp 平台。这样做将允许我开始介绍以太坊，并在呈现系统的两个互补的高级视图时参考具体的底层组件：

+   *结构 Dapp 视图*——我将描述我们投票 Dapp 的客户端和服务器端的高级架构。

+   *交易 Dapp 视图*——我将带你逐步了解投票交易的整个生命周期。

#### 1.1.2. 结构视图：Dapp 的解剖

去中心化投票应用的*结构视图*包括客户端组件的描述，由代表投票者提交投票的网页用户界面（UI）表示，以及服务器端组件的描述，由运行应用逻辑的一组服务器表示。

##### 去中心化应用（Dapp）客户端：一个网页应用

如图 1.3 所示，投票应用的网页客户端最初从传统的网页服务器下载到用户浏览器中，通常是一个包含 HTML 和 JavaScript 的网页应用。网页用户界面不包含任何服务器端脚本，并通过一个名为 Web3.js 的客户端 JavaScript 库直接与网络中的特定服务器通信。它还可能允许用户与位于其场地的网络节点进行通信。到目前为止，这个应用与传统的网页应用在主要方面没有区别。

##### 图 1.3. 对投票者而言，去中心化投票应用呈现为一个网页应用，其中包含 HTML 和 JavaScript，并从传统的网页服务器下载。这个不包含任何服务器端脚本（否则它将是部分中心化的）的网页应用通常配置为直接与网络的特定节点通信。

![](img/fig01-03_alt.jpg)

##### 去中心化应用（Dapp）服务器端：一个 P2P 网络

去中心化应用的服务器端是一个运行相同代码并拥有区块链数据库相同副本的一组服务器构成的 P2P 网络。正如你所知，这种网络拓扑的一个关键特征是它不使用中心协调，而是使用每个节点与称为*对等节点*或简称* peers*的多个其他节点的直接通信。不需要主节点。如图 1.4 所示，一个节点不需要连接到网络的所有其他节点。与几个节点的连接就足以确保交易快速传播到整个网络。

##### 图 1.4. 对等网络（P2P）由直接与其他节点通信，无需主节点协调的节点组成。

![](img/fig01-04_alt.jpg)

##### 以太坊网络

存在支持区块链平台的各种 P2P 网络。最著名的一个是以太坊网络。

在这本书中，我将重点关注以太坊网络，其*参与者*节点如图 1.5 所示(figure 1.5)，托管一个*区块链数据库*和一块被称为节点*客户端*的软件，该软件允许节点与其他节点通信。因为所有节点彼此平等，所以在以太坊网络中，你没有一个清晰定义的客户端和服务器概念。每个节点对其他节点来说是服务器，但同时，它也是其他节点的客户端。这就是为什么以太坊节点的软件元素被称为客户端。

以太坊客户端暴露出一个共同的客户端接口，并通过名为*Wire*的 P2P 协议相互通信。该协议确保了在网络中发送数据的标准方式，具体包括*交易*，比如提交的投票，以及*区块*，比如在区块链数据库中的一组投票汇总。

存在各种以太坊客户端的实现。如图 1.5 所示(figure 1.5)，它们是用各种语言编写的，从 C++到 Go，但都实现了标准的客户端接口和 Wire 协议，因此它们可以无缝交互。

##### 图 1.5\. 以太坊网络的每个节点都托管一个区块链数据库和一个能够执行存储在区块链中的应用程序代码的节点客户端。节点通过 Wire 协议通信，并暴露出相同的接口，但可以采用不同的编程语言实现。

![](img/fig01-05_alt.jpg)

以太坊节点客户端与比特币节点客户端的优势在于，它不仅能够像比特币节点那样在网络中传播加密货币交易和区块，还能够执行托管在区块链数据库上的应用程序代码。从这一点来看，像以太坊这样的平台被称为*可编程区块链*。去中心化应用程序的代码结构在*智能合约*中，智能合约以大多数面向对象语言中的类封装逻辑和状态的方式封装逻辑和状态。例如，投票去中心化应用程序将基于各种智能合约进行结构化，这些智能合约将托管在以太坊区块链上。我即将解释智能合约是什么，如何部署它，如何执行它，以及智能合约存储和运行的位置。耐心点。

##### 网络节点的作用

尽管所有网络节点都通过共同的 P2P Wire 协议无缝通信，但并非所有节点执行相同的功能。广泛来说，如图 1.6 所示(figure 1.6)，两大类节点，功能上不同，如下所述：

+   *完整节点*—大多数节点具有标准设置，使它们能够被动处理交易：它们可以从区块链数据库中读取，但不能创建新的区块链块。但它们可以将从对等节点接收的块附加到本地区块链。它们确实执行交易，但仅用于验证从对等节点接收的区块链块的正确性。在投票应用程序的情况下，完整节点将来自其对等节的投票传播给其他对等节点。它们还验证接收到的块是否正确，并包含真实的投票，通过运行投票 Dapp 智能合约来实现。但完整节点不会在新区块链块中存储投票。

    ##### 图 1.6。以太坊网络包括两种主要类型的节点。完整节点被动处理交易，可以从区块链数据库中读取，但不能写入。挖矿节点主动处理交易：它们像完整节点一样验证交易的正确性，但它们还组装新的交易块，这些块被附加到区块链上。

    ![](img/fig01-06_alt.jpg)

+   *挖矿节点*—一些节点被配置为主动处理交易：它们将交易分组并存储在新的区块链块中。它们通过在以太坊平台上支持的加密货币 Ether 中执行这样计算密集型和能源消耗型工作而获得奖励。然后，它们将这些新块传播到 P2P 网络的其余部分。这些节点被称为挖矿节点，因为将新块整合到区块链中并因此获得加密货币代币奖励的过程被称为*挖矿*。在投票 Dapp 的情况下，挖矿节点将来自对等节点的投票分组到一个新块中，将块附加到区块链，并通过其对等节点传播该块。

##### 将所有内容放在一起

您已经检查了投票 Dapp 的结构视图。图 1.7 展示了整个系统，包括客户端和服务器端。

##### 图 1.7。分布式投票应用程序的整个静态视图，包括客户端和服务器端

![](img/fig01-07_alt.jpg)

#### 1.1.3。交易视图：通过交易的生命周期

在您在图 1.7 中看到的静态视图的基础上增加时间维度，图 1.8 逐步说明了投票交易的完整生命周期：

1.  用户从网页客户端的下拉列表框中选择一个可能的投票选项，然后单击投票。

1.  一个 JavaScript 函数处理点击事件并获取投票选择。然后，通过各种 web3.js 库函数，它与配置的以太坊节点建立通信，连接到投票智能合约，并在其上调用`castVote()`函数。对`castVote()`的调用生成一个交易消息，该消息以用户的账户为依据进行数字签名，以证明他们是真正的发送者。

1.  联系到的本地以太坊节点处理交易消息，验证它，并将它传递给其对等节点。

1.  节点之间相互转发交易，直到交易到达挖矿节点。这相对较快发生，取决于完整节点与挖矿节点的比例。挖矿节点执行与完整节点相同的步骤（第 2 步和第 3 步）。此外，挖矿节点选择一个交易，如一个投票交易。如果一个交易预计能产生一个可接受的交易费，高于挖矿节点处理交易时面临的电力成本，那么这个挖矿节点就会执行`castVote()`函数，与其他挖矿节点竞争将交易存储在区块链上。获胜的挖矿节点（即成功解决所谓共识算法，一个加密问题的挖矿节点）会在区块链的新区块中与其他交易一起巩固投票交易。然后，它将新区块传递给所有其同伴节点（不论它们是完整节点还是挖矿节点）。

1.  每个接收到新块的节点都会验证其中包含的个别交易是否真实，以及整个区块是否有效。然后处理其中的所有交易。在这个过程中，它隐式地验证了合约状态的有效性。例如，投票提交逻辑可能包括一个不变量，验证对于一个候选人投出的票数，或所有候选人投出的总票数，不会高于注册选民的数量。如果节点成功验证了区块，它会将其传递给它的同伴节点，这些节点执行相同的验证和传播动作，直到整个网络都获得了新的区块链区块。（验证过程在下一章中会更清晰地解释给你听，届时我将介绍它所基于的加密技术。）

1.  对于用户而言，本地的以太坊节点接收新块并通过执行其中的所有交易来验证它，像其他所有节点一样。其中一个是投票交易，它已经被编程在成功完成时触发一个`VoteConfirmation`事件。事件被发布给所有订阅它的客户端，包括 Dapp 的 Web UI。

    ##### 图 1.8\. 投票交易的生命周期。当一个选民浏览器在以太坊网络的本地节点上调用`castVote()`函数在一个投票智能合约上时，就会创建一个投票交易。这然后被验证并在整个网络中传播，直到它被一个挖矿节点包含在一个新的区块链区块中。新的区块在整个网络中传播，然后最终返回到本地节点。

    ![](img/fig01-08_alt.jpg)

1.  投票 Web 客户端上存在的 JavaScript 代码包含一个针对`VoteConfirmation`事件的回调函数，该函数随后会被触发。

1.  最后，回调函数在选民屏幕上显示一个投票确认通知。

#### 1.1.4\. 一些 Dapp 术语

尽管去中心化应用是一个相对较新的概念，但在第一个 Dapps 构建后相对较短的时间内，围绕它们的标准化术语开始出现。在本节中，我将概述以太坊创始人 Vitalik Buterin 在一篇著名的博客文章中描述的关键术语^([1])，以解释关键的 Dapp 概念。您已经在之前的章节中遇到过一些这些术语，但现在我将更精确地定义它们。

> ¹
> 
> Vitalik Buterin，“DAOs, DACs, DAs and More: An Incomplete Terminology Guide，”[`mng.bz/vNrq`](http://mng.bz/vNrq)。

##### 智能合约

一个*智能合约*是涉及数字资产交换的两个或多个方的安排。其中一个或多个方在合约启动时向合约分配数字资产。随后，根据逻辑中预定义的协议和初始化的状态，资产根据逻辑重新分配给各方。

##### 自主代理

一个*自主代理*是一个与外部软件服务自主交互的软件实体，根据外部环境验证的变化重新配置或甚至重新编程自己。

##### 去中心化组织

一个传统的*中心化组织*包含资产和不同类别的个体，通常是投资者、员工和客户。投资者通过购买股份拥有组织的一部分来控制组织。某些类别的个体之间的交互受到他们是否控制组织的影响。例如，员工可以被投资者直接或间接授权的其他员工招募。

一个*去中心化组织*（DO）不由任何一个人或实体控制。预定义的协议决定了组织中涉及的不同类别人群之间的交互。但是，这些协议可以设计成让某些人比其他人拥有更多的权力——例如，根据所拥有的股份数量——正如集中式组织一样。

##### 去中心化自治组织

一个*去中心化自治组织*（DAO）既是 DO 又是自主代理。与自主代理一样，它是一个与外部软件服务自主交互的软件实体。参与 DAO 的个人通过预定义的协议与 DOs 交互。

DAO 与 DO 的主要区别在于，DAO 与外部实体的交互 largely 是自动化的，且交互协议编程在*智能合约*中，而拥有 DO 的个人与外部实体的交互仅受*手动协议*的约束。关键点是，从外部实体的角度来看，DAOs 比 DOs 更可信，因为自动交互是可预测的，而基于手动协议的交互完全依赖于遵循它的个体的声誉。

根据这些定义，关于是否可以将构建区块链平台的主要或唯一目的定义为支持加密货币的 DAO 或 DO 存在分歧。因为比特币基础设施不允许实现容易自动化的交互协议，有些人认为它应该被归类为 DO。

##### 去中心化自治公司

一个*去中心化自治公司*（DAC）是一个可以通过购买股份部分拥有的 DAO。与经典的（中心化的）公司一样，根据其财务成功，DAC 会定期重新分配股息。另一方面，纯粹的 DAO 通常是一个非营利组织，参与者的经济利益仅限于为其生态系统做出贡献并增加其内部资本。

|  |
| --- |

##### 注

The current widely accepted definition of *decentralized application* corresponds to that of DAO described previously, which is still in use among Ethereum purists. I’ll use this definition for Dapp for the rest of this book. The reason why the initial terminology used the word *organization* rather than *application* was because the Ethereum founders wanted to put emphasis on the fact that a decentralized application can transact with other parties exactly like conventional organizations: by following rules and protocols and exchanging monetary value, obviously in the form of cryptocurrency rather than conventional currency.

|  |
| --- |

The key aspects of each of these terms are summarized in table 1.1.

##### 表 1.1. 各术语关键方面的矩阵总结，DAO 代表 Dapp

|  | 是软件 | 有资本 | 自治 | 被拥有 |
| --- | --- | --- | --- | --- |
| Autonom agent | YES | NO | YES | NO |
| DO | NO | YES | NO | YES |
| **DAO** | **YES** | **YES** | **YES** | **NO** |
| DAC | YES | YES | YES | **YES** |

虽然你已经了解了一些高级术语，但不去熟悉区块链的概念，你无法真正理解 Dapps 的目的以及它们是如何工作的。因为 Dapps 是构建在区块链之上的，并且严重依赖它，你应该去了解它以及其底层技术。我在下一节会覆盖这个内容。

|  |
| --- |

**去中心化应用与分布式应用对比**

*去中心化*的应用不应该与*分布式*应用混淆。这两个概念有相似之处，但它们并不是一回事。

如果一个应用程序在网络中的多个服务器上运行，则该应用程序是分布式的。分布式应用程序的最简单例子是一个网络应用程序，它通常在网络服务器、应用服务器和数据库服务器上分布式运行，可能还包括邮件服务器和遗留的大型计算机。前面提到的中心化投票应用程序是一个分布式应用程序的例子。它是分布式的，因为它在多个服务器上运行，但它也是中心化的，因为所有服务器都属于同一机构。

分布式应用在网络的多个服务器上运行。而去中心化应用则是完整地复制在广泛网络的每个节点上。

![](img/f0019-01_alt.jpg)

分布式与去中心化应用结构的比较

一个应用若是其完整副本分布在网络的每个节点上，并且每个节点理论上属于不同的实体，那么这个应用就是去中心化的。拥有网络节点实体数量越多，整个网络的可信度就越高。显然，只有少数所有者的网络不能被认为是可信的，因为它们并没有真正实现处理的去中心化。

中心化的应用通常是分布式的，但去中心化的应用也可以分布在每个逻辑节点内的多个服务器上。

|  |
| --- |

### 1.2. 好的和不好的 Dapps

在过去的几年里，开发了许多 Dapps。一些已经获得了多轮风险投资，并成功部署到生产环境中。其他的则未能说服投资者和用户，从未走出概念验证阶段。

#### 1.2.1. 好的用例

鉴于这项技术的新颖性，很难预测哪些会成功，哪些会失败。尽管如此，各种用例正在被广泛认为是区块链以及特别是以太坊的一个很好的匹配。理想的 Dapps 是那些利用了这些技术主要优势的应用，具体来说是记录不可变性、去中心化、安全和弹性。因此，可能主要由 Dapps 引发革命的领域包括来源和所有权追踪、真实性追踪、身份验证、监管审计、慈善支出审计、预测市场、客户忠诚度管理、众筹、电子投票、投资、赌博、借贷、在线游戏管理、作者版税支付、物联网、云计算，甚至包括言论自由。让我们看看在这些领域中已经找到了哪些创新性解决方案。

##### 来源和真实性追踪

影响供应链管理的一个最大问题，特别是在涉及穿越多个国家的加工商品长链时，是追踪材料的真实性。以下是一些基于区块链解决方案在这一领域进行创新的 Dapps：

+   像 Provenance 这样的 Dapp 提供了基于区块链的来源追踪，以确保在供应商链中没有信息丢失或被操纵，并确保符合预期质量的商品到达最终客户。Provenance 上构建的第一个应用程序一直专注于食品行业，追踪从收集点开始的原料供应链，经过食品制造过程，最终到达消费者销售点。该系统的目的是证明销售的食品具有向消费者广告的声称特征，例如收割或饲养的地点和可持续性，来源是否有机或经过基因改造，是否来自公平贸易等等。

+   联合利华这家跨国消费品公司正在与多家初创公司合作，开发一个基于区块链的系统，以追踪从马拉维农民开始的茶叶供应链。

+   Everledger 是一个旨在用基于区块链的系统替换钻石纸质认证流程的 Dapp。一颗钻石的完整数字记录，包括其证书 ID 和许多属性，如切割、等级、清晰度、颜色和克拉重量，存储在区块链上，然后使用激光在钻石上刻上证书 ID。然后，在任何供应链环节，都可以使用读取石头上证书 ID 的扫描仪检索与钻石相关的所有信息。已经有近 200 万颗钻石存储在 Everledger 上。

+   制药公司辉瑞正在与生物技术公司基因泰克合作开发 MediLedger，这是一个基于区块链的药物交付追踪系统。目标是验证辉瑞药物在整个分销链中的来源和真实性，以防止盗窃、欺诈和假冒。

##### 身份验证

正如来源追踪一样，身份证明的验证试图保护企业和个人免受欺诈和身份盗窃的后果。KYC-Chain 是一个建立在以太坊区块链上的新型平台，使用户能够安全地管理他们的数字身份。它还帮助企业和金融机构以可靠和简单的方式管理客户数据。该系统设计成用户拥有个人数据和身份证明的“钥匙”。因此，身份所有者，可以是个人或公司，是唯一可以选择分享其信息的一部分、与谁分享以及分享条件的唯一人员。在所有者及其注册代理分享之前，此类信息由公证人和机构数字证实。

##### 证明所有权

传统的区块链技术，如与比特币关联的加密货币，隐含地证明了数字资产的所有权，比如某个地址存储的比特币数量。只有地址的合法所有者才能转账，因为他们是唯一知道私钥的人。

TrustToken 试图更进一步。它是一个旨在通过智能合约证明实体资产所有权的 Dapp，如房地产、股票和债券等金融资产、黄金等商品，甚至音乐、书籍和专利等知识产权。想法是你可以像转移比特币一样，将这类资产的所有权从一个人转移到另一个人。TrustToken 成功的根本假设是，通过系统记录的所有权证明在法律上应该是可执行的。

##### 物联网经济

科技创业公司 Slock.it（[`slock.it/`](https://slock.it/)）正在构建物联网与区块链技术交汇点的“物联网经济”的基础设施。该公司称之为“通用共享网络”的基础设施，有潜力作为金融互联网使用，在其中的自主物体不仅可以出售和出租自己，还可以互相支付服务费用。该公司正在开发的技术，基于以太坊智能合约，旨在为自主物体提供身份认证，并使其能够接收付款和签订协议，而无需中介。已经在这个平台上创建了智能锁柜等应用，这些应用可以在支付费用时解锁物理对象。由于智能锁柜使得租赁体育设备、酒店房间、自行车和办公室变得容易，这种解决方案被认为为共享经济提供了基础。

##### 去中心化的预测市场

预测市场通过正确预测现实世界事件来奖励人们，如总统选举的获胜者、公投的结果、特定日期的利率水平或体育比赛的获胜者。除了用于投机，它还是一种有用的工具，供经济学家、公共行政规划者和企业战略家使用，他们可以根据目前市场上正在交易的事件概率做出决策，这些概率被认为反映了“群体智慧”。

尽管存在像[predictit.org](http://predictit.org)（[www.predictit.org](http://www.predictit.org)）这样的集中市场，但已经有几个去中心化的倡议开始出现。Augur 是一个基于以太坊的去中心化市场预测平台。理念是去中心化能够带来以下好处：

+   基于以太坊网络，它没有单一的失败点，因此具有高度的可用性。

+   没有人控制市场的定义：任何人都可以开始一个新的市场，对新的预测进行预测，并且可以因为创造了这个市场而获得奖励。

+   每个预测的官方结果并不是集中决定的；它是由市场参与者集体提供的，因此不太可能受到操纵。

+   资金存储在区块链上，消除了对手方风险，支付给预测赢家迅速，并减少了出错的可能性。

##### 国际贸易融资

位于不同国家的供应商和制造商之间的国际贸易是一项复杂的业务。正如你在图 1.9 中所看到的，它通常基于一个涉及许多方的复杂工作流程，如银行促进支付、商业中介促进分销、航运和交付公司运输货物、保险公司在货物运输过程中承担金融风险、海关官员检查货物的合法性和支付进口关税。

##### 图 1.9. 涉及许多参与方的典型国际贸易：银行、商业中介、航运公司、保险公司、海关官员等等。

![](img/fig01-09_alt.jpg)

参与特定交易的各方通常以前从未相互交易过。但是，为了使交易成功完成，他们必须有效地相互沟通，通常是通过建立的长达数小时的协议，旨在保护一方免受另一方的恶意行为。各方相互核实，这需要大量的文件和时间，常常导致长时间延迟。

we.trade 是一个由银行合作伙伴（包括 Société Générale、Deutsche Bank、Nordea、Santander 和 HSBC）组成的平台，旨在利用区块链技术简化并优化这些流程。该平台公开透明地跟踪交易的每个步骤，以便各方能够提交和消费相关文件，确信没有人会篡改它们。以前需要几周的交易现在可以在几天内完成。

##### 监管审计

区块链特别适用于确保存储在其中的记录没有被更改或篡改。Balanc3 是一个基于以太坊的 Dapp，用于确保会计记录的完整性以满足监管要求。

##### 众筹

WeiFund 旨在提供基于以太坊区块链的开源模块化和可扩展的众筹工具。用户可以通过这些工具建立和管理众筹活动。基于智能合约技术编码的筹款规则使得用户能够确切知道如果活动失败或成功，他们的钱会发生什么。

##### 赌博

直观上，一个自然适合去中心化应用的平台是一个赌博平台，因为用户可以确保投注被公平且可预测地处理。Edgeless 就是这样一个平台的例子，它在一个成功的众筹活动之后目前正在开发中。

既然你已经了解了某些成功的 Dapp 实现，你可能想知道是否总是值得将你的应用程序建立在区块链技术之上。我们将在下一节探讨这个问题。

#### 1.2.2. 无意义的 Dapps

决定区块链是否是一个适合你计划构建的应用的技术可能会很困难。你应该问自己的是，区块链平台提供的功能是否符合你的业务需求。更重要的是，考虑使用此类平台的好处是否会因这项技术带来的所有技术限制和额外的复杂性而抵消。一篇题为“避免无意义的区块链项目”的冷静博文([2])分析了使用区块链平台而非更传统的如 SQL 或 NoSQL 数据库等技术的需求。它得出结论，只有在你能对以下所有问题回答“是”的情况下，区块链项目才是有意义的：

> ²
> 
> 避免无意义的区块链项目](http://mng.bz/4Oqg)。

+   你的应用程序需要一个共享数据库吗？

+   数据库是否需要支持多个写入方？

+   写入方之间是否互不信任？

+   写入方是否希望直接修改数据库的状态，而不需要所有参与者都信任的中心实体？

+   写入方创建的交易是否相互协作地交互？

根据这些标准，例如，一个不会向外部各方暴露任何数据的内部企业应用不适合作为 Dapp。其他不适合作为 Dapp 的候选应用是那些业务规则保密性重要的应用。智能合约，按定义，对所有交互方完全公开和透明。因此，防止参与者访问和理解规则的逻辑将违背目的。

尽管像 EthTweet 这样的去中心化微博应用被那些重视信息发送后不能被审查和修改的人来说是合理的 Dapp，但一个即时通讯的 Dapp，比如一个“去中心化的 WhatsApp”，并不会是一个特别有用的产品，原因在于一个基本的技术缺点。区块链平台的一个技术缺点是处理交易（在这种情况下是即时消息）需要大约 15 秒来巩固一个新的区块链区块。因此，消息根本不可能*即时*。

在构建 Dapp 时，你还应该考虑一些操作方面的问题，由于这项技术的新颖性，这些问题可能会在以后出现。例如，尽管智能合约可以自动保证在满足某些条件的情况下路由和释放资金，但商业交易也可能受到现实世界条件的影响，这些条件编程逻辑无法强制执行。一个非完全自动强制执行的经典智能合约例子是电子贷款。如果借款人必须将借来的钱困在区块链账户上，以便智能合约能够在借款人错过利息支付时自动将其还给贷款人，那么借款在经济上就没有任何意义。在这些情况下，法院是否能够强制执行智能合约的非自动元素尚不明确，或者是否需要用传统法律安排来补充交易。

### 1.3. 五分钟的 Dapp 实现

到目前为止，你应该已经对 Dapp 有了很好的了解，包括 Dapp 与传统应用相比的目的，去中心化应用程序的主要架构组件，以及基于区块链技术进行项目是否合理。现在，是时候再迈出一小步，开始进行编程了。在本章的剩余部分，你将开始构建一个自定义加密货币的智能合约。然后激活它并与之交互。

#### 1.3.1. 构建基本加密货币 SimpleCoin

大多数 Dapp 都是基于加密货币或代币的交换功能设计的，这些功能编码在一个或多个智能合约中。你将通过构建一个名为 SimpleCoin 的基本加密货币来开始了解 Dapp 编程，它将为你提供关于智能合约和以太坊平台的有用的初步概念。在接下来的章节中，你将逐步在此基础上构建，了解更多关于 Dapp 开发的内容。你还将从其他章节中构建的 Dapp 中使用或参考 SimpleCoin。

由于你还没有在电脑上安装以太坊平台客户端，你现在将使用 Remix Solidity（以前称为 Browser Solidity）集成开发环境（IDE）编写代码。这个在线工具将允许你使用类似于 JavaScript 的高级语言 Solidity 实现智能合约，并在本地 JavaScript 虚拟机上运行，该虚拟机模拟你将在下一章遇到的以太坊虚拟机。通过这个工具，还可以与部署在以太坊网络上的真实智能合约进行交互。

打开一个网页浏览器，访问：[`remix.ethereum.org/`](http://remix.ethereum.org/)。你应该会看到类似图 1.10 figure 1.10 的屏幕。在网站上，IDE 的左侧是一个文件资源管理器（你可以通过点击左上角的的双箭头切换按钮来隐藏它）；中间是代码编辑器；右侧包含运行代码和与之交互的各种面板。

##### 图 1.10\. Remix 启动屏幕的截图，左侧是代码，右侧是代码执行面板。我已经通过点击左上角的的双箭头切换按钮隐藏了文件资源管理器。

![](img/fig01-10_alt.jpg)

在你第一次接触 Solidity 时，你将实现最简单的智能合约。如果你把智能合约看作是面向对象语言中类的等价物，那么你将写出一个只有一个成员字段、一个构造函数和一个方法的单一类。然后你将运行它并与它交互。

通过点击左上角的的双箭头切换按钮隐藏文件资源管理器，然后在第 1.1 节清单中，在屏幕左侧的 Remix 编辑器中输入代码。

##### 清单 1.1\. SimpleCoin 的基本加密货币的第一次实现

```
pragma solidity ⁰.4.0;                                          *1*

contract SimpleCoin {                                            *2*

  mapping (address => uint256) public coinBalance;               *3*

  constructor() public {                                         *4*
    coinBalance
 [0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C] = 10000;         *5*
  }

  function transfer(address _to, uint256 _amount) public {       *6*
    coinBalance[msg.sender] -= _amount;                          *7*
    coinBalance[_to] += _amount;                                 *8*
  }
}
```

+   ***1*** **Pragma 指令指定了 Solidity 编译器支持版本（代码支持 0.4.0 之后、0.5.0 之前的编译器）**

+   ***2*** **定义一个合约，这与其他语言中的类相似**

+   ***3*** **定义一个状态变量作为一个“映射”（between an address and an integer）。状态变量相当于一个成员变量。映射相当于哈希表或哈希映射。**

+   ***4*** **开始定义合约构造函数**

+   ***5*** **在合约创建时将 10,000 SimpleCoin 代币分配给地址为 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 的代币账户**

+   ***6*** **定义了一个函数，将一定数量的 SimpleCoin 代币从函数调用者的代币账户移动到指定的代币账户**

+   ***7*** **通过特定数量的代币减少消息发送者的币余额。 （特殊的隐式属性 msg.sender 代表交易发送者的地址。）**

+   ***8*** **通过特定数量的代币增加币余额**

让我们详细检查这段代码。在 Solidity 中，*合约*是一种与其他语言中的类相似的类型：它有*状态变量*（如`coinBalance`）、构造函数、函数（如`transfer`）和事件。

`coinBalance` 状态变量被定义为一个 `mapping`。*mapping* 是一个哈希表，相当于 Java 中的 hashMap、C# 中的 Dictionary 或 Python 中的 dict。在此示例中，键的类型是一个 `address`，而值是一个 `uint256`——一个无符号的 256 位整数。*address* 保持一个 20 字节值，可以识别一个特定的智能合约账户或一个特定的用户账户。如您稍后详细看到的，账户是交易的发送者或接收者。因此 `coinBalance` 状态变量代表了一组代币账户，每个账户都持有若干 SimpleCoin 代币。

`transfer` 函数旨在将一定数量的 SimpleCoin 代币从函数调用者的代币账户转移到指定的代币账户。在智能合约术语中，函数调用者是 *交易发送者*。`msg` 是一个特殊隐式定义的变量，代表传入的消息。它有各种属性，其中 `msg.sender` 代表交易发送者的地址，即 `transfer` 的调用者。

`transfer` 函数的主体简单易懂。它涉及从与函数调用者关联的现金账户中减去指定金额，并将 `_amount` 参数中指定的金额添加到 `_to` 参数中指定的地址关联的账户。为了保持这个初始代码简单，此实现尚未对交易发送者拥有的 SimpleCoin 代币数量执行任何边界检查，例如，不应该允许发送比他们拥有的更多代币。当我们在后面的章节中重新访问 SimpleCoin 时，您将执行此类检查。

在此阶段，您应该明白您的 `SimpleCoin` 合约实际上是一个具有构造函数（`SimpleCoin` 函数）、一些状态（`coinBalance` 变量）和方法（`transfer` 函数）的类。 表 1.2 对您已经遇到的 Solidity 关键词进行了简要总结。

##### 表 1.2. Solidity 关键词汇总，用于第一个代码示例

| 关键词 | 解释 |
| --- | --- |
| contract | **与其他任何语言中的类相似的类型** |
| mapping | **与哈希表或哈希映射类似的数据结构** |
| address | 表示 Ethereum 用户账户或合约账户的 20 字节值 |
| uint256 | **无符号的 256 位整数** |
| msg | **代表传入消息对象的特别变量** |
| msg.sender | **msg 对象的代表消息发送者地址的属性** |

#### 1.3.2. 运行合约

将鼠标移至屏幕右侧以部署 `SimpleCoin` 合约。首先，确保在编译标签页中的自动编译选项已勾选，如图 1.11 所示，以便 Remix 在每次更改后重新编译代码。同时，确保您选择了编译器的 0.4.24 版本（例如 0.4.24+commit.e67f0147），因为我在编写 `SimpleCoin` 时使用的正是这个版本。

##### 图 1.11\. 编译选项卡中的自动编译选项确保在每次更改时重新编译编辑器中输入的代码。

![](img/fig01-11_alt.jpg)

如果您正确地输入了您的代码（我建议您从本书网站提供的文件中复制代码！），并且没有发生编译错误，您应该在运行选项卡中看到以下按钮：部署和 At 地址，如图 1.12 所示。现在忽略 At 地址，将注意力集中在部署上。通过点击此按钮，您将在 Remix 内模拟的区块链上部署 `SimpleCoin` 合约。

##### 图 1.12\. 一旦代码正确编译，运行选项卡将显示两个按钮：部署和 At 地址。您可以通过点击部署来实例化合约。

![](img/fig01-12_alt.jpg)

合约将被存储在模拟的以太坊区块链上的地址中，并将出现一个新的已部署合约面板，如图 1.13 所示。您可以通过点击复制地址图标并将其粘贴到记事本等应用程序中来读取部署地址。

##### 图 1.13\. 部署合约后，已部署合约面板出现，包含一个下拉列表，其中有一个 SimpleCoin 选项；点击它，您将看到合约操作。

![](img/fig01-13_alt.jpg)

#### 1.3.3\. 与合约交互

现在 `SimpleCoin` 合约已经部署，您将能够对其执行简单的操作：您将检查 SimpleCoin 代币余额并在账户之间移动代币。

在已部署合约面板内点击 SimpleCoin 下拉列表。将出现两个新按钮：CoinBalance 和 Transfer，如图 1.14 所示。

##### 图 1.14\. SimpleCoin 操作按钮：CoinBalance 和 Transfer。CoinBalance 是获取 coinBalance 状态变量的读取操作。Transfer 允许您将指定数量的代币转移到指定的地址。

![](img/fig01-14_alt.jpg)

Remix IDE 显示两种类型的按钮：

+   *蓝色按钮*—它们对合约执行读操作，例如检查状态变量的值或调用只读函数。

+   *红色按钮*—它们对合约执行写操作，例如通过构造函数实例化合约（Create），或调用修改任何状态变量的函数。

在此情况下，CoinBalance 是蓝色，因为它允许您读取与地址关联的代币余额。Transfer 是红色，因为通过点击它，您将改变合约的状态，具体是通过更改 `coinBalance` 映射状态变量中的值。

现在检查构造函数中指定地址的`coinBalance`是否拥有你在构造函数中设置的 SimpleCoin 的完整初始供应量。用双引号括起地址：`"0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C"`。在文本框中输入它，然后点击 CoinBalance。一些输出将会出现。在底部，你应该看到你在构造函数中指定的 SimpleCoin 代币的预期数量：10,000。

`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`是 Remix IDE 上存在的五个测试账户之一的地址。你可以在屏幕右上角的 Transaction Origin 下拉列表框中看到它们。虽然它们在屏幕上并不完全可见，但它们的完整地址在 table 1.3 中报告。（我一个接一个地点击了账户下拉列表旁边的 Copy Address 图标，逐一检索它们。）

##### Table 1.3\. 被 HTML 遮挡的 Remix 测试账户的完整地址

| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c |
| --- |
| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c |
| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db |
| 0x583031d1113ad414f02576bd6afabfb302140225 |
| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 |

你可以双重检查任何地址与`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`不同的 SimpleCoin 代币的数量是否为零。例如，在 CoinBalance 文本框中输入以下地址，并用双引号括起来，就像你之前做的那样：`"0x583031D1113aD414F02576BD6afaBfb302140225"`。点击按钮后，你会看到一个零，正如预期的那样。

总结一下，当你实例化合约时，10,000 个 SimpleCoin 代币的数量被分配为初始货币供应量，分配给以`0x14723A09`开头的地址。其他地址还没有任何代币，正如 ch01table04 中总结的那样。

##### Table 1.4\. 合约实例化后每个 Remix 测试账户的余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |
| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **10,000** |
| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **0** |
| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |
| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |

现在您将调用`transfer`函数，从地址以`0x14723a09`开头的帐户转移一些代币到不同的测试帐户。因为转账函数从其调用者的帐户中移动代币，所以该函数必须从合同创建者的地址，即以`0x14723a09`开头的地址调用。从运行选项卡右上角的帐户下拉菜单中选择此地址，然后在转账方法的文本框中输入目标地址——例如，以`0x4b0897b0`开头的地址——以及要转移的代币数量——例如，150 个代币。您应该用逗号分隔这些参数的值：

```
"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB", 150
```

现在点击转账。预期功能将不返回结果。

点击进入合约创建者的地址（`"0x14723A09AC-ff6-D2-A60Dcd-F7aA4AFf308FDDC160C"`）后的 CoinBalance，检查合约创建者的地址中代币的数量。现在的值是 9,850，如预期。

如果你对目标地址（`"0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB"`）执行相同的检查，你会得到 150。所有其他地址仍然没有代币，如表 1.5 所总结。

##### 表 1.5。转账操作后每个 Remix 测试账户的余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | **0** |
| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | **9,850** |
| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | **150** |
| 0x583031d1113ad414f02576bd6afabfb302140225 | **0** |
| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | **0** |

作为一个练习，你可以尝试将`0x4b0897b05`开头的地址的代币转到一个不同的地址，并重新检查金额是否正确。在这个过程中，请不要执行任何疯狂的交易，比如尝试移动一个地址持有的比更多代币。为了保持代码目前简单，你没有编写任何边界条件来处理这种情况。你将在下一章学习这些内容。

尽管你到目前为止所写的代码很简单，但在这个阶段的唯一目标是开始熟悉智能合约、Solidity 语言和 Remix。到现在，你应该已经实现了这个目标，并且你应该理解合约实例化是如何工作的，以及如何从不同的账户与合约进行交互。

SimpleCoin 仍处于一个胚胎期的 Dapp 阶段。到目前为止，你只是在基于 JavaScript VM 的模拟器上执行了它的代码，因为它缺少 UI，所以你是通过 Remix 看到它的输出的。在下一章，你将更进一步，安装一个以太坊客户端。然后你将在真正的以太坊网络上部署 SimpleCoin，并再次与之交互。

|  |
| --- |

##### 警告

如果编译器配置在“编译”标签中是 0.4.25 版本，Remix 将只允许你在代码编辑器中输入具有有效校验和的地址。我将在第五章解释什么是有效校验和。但目前，它意味着`0x14723a09acff6d2a60dcdf7aa4aff308fddc160c`（全部小写）和`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`不被解释为彼此等价。不幸的是，运行标签中的账户下拉菜单中的所有地址都是小写的，因此不符合要求。如果你想知道具有有效校验和的对应地址，你可以使用 Etherscan，一个在线区块链浏览器（[`etherscan.io/`](https://etherscan.io/)）。在屏幕顶部的文本框中输入格式不正确的地址（例如，`0x14723a09acff6d2a60dcdf7aa4aff308fddc160c)`，你将在屏幕顶部同样顶部的地址栏中看到格式正确的对应地址（`0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C`）。

| ``` |
| --- |

### 总结

+   去中心化应用是一种新型的应用，它不由任何实体拥有或控制，并在无需信任的分布式 P2P 网络上运行。

+   去中心化应用的网络拓扑与传统的、中心化的应用不同，因为它的业务逻辑层和数据层（区块链）在网络的每个节点上都完全复制。

+   Dapps 依赖于区块链技术，而区块链技术又基于公钥密码学、密码学哈希函数和通过共识协议挖矿的概念。

+   许多合适的用例都适用于去中心化应用，特别是在来源和真实性追踪、身份验证、合规审计、预测市场和众筹等领域。

+   去中心化应用并不总是解决业务问题的最佳方案。例如，将一个不与任何外部参与者共享的内部企业应用去中心化是没有意义的。

+   你可以在以太坊平台上使用类似于 JavaScript 的 Solidity 语言实现智能合约，这是 Dapps 的核心。通过 Remix Solidity IDE，你可以编写简单的智能合约，并模拟它们的激活和与各种模拟以太坊账户的互动。

## 第二章. 理解区块链

| ``` |
| --- |

**本章内容**

+   以太坊节点的低级细节

+   构建以太坊 Dapps 所使用的技术栈

+   以太坊区块链背后的技术

+   以太坊的历史和治理

| ``` |
| --- |

我本意是第一章给你提供去中心化应用的高级概览，而不会让你感到过于详细的信息。因此，我相信你仍然想知道你需要学习什么技术堆栈来构建一个完整的 Dapp。另外，你可能会觉得 Dapps 的建筑呈现没有达到你想要的程度，你可能仍然对区块链如何工作有所疑虑。如果你自己在问这些问题，我将在这一章中回答它们。

我将首先重新审视前章中我介绍的投票 Dapp，并覆盖我之前为了简单起见而跳过的以太坊节点的某些方面。然后，我将涵盖实现完整端到端去中心化应用所需整个技术堆栈。此外，我将介绍你需要掌握的密码学概念和基础，以理解区块链是如何工作的。在章节结束之前，我将介绍以太坊区块链特有的技术，并给你一些关于以太坊历史和治理的信息。

### 2.1. 深入查看去中心化应用

当我队在第一章中呈现去中心化应用的结构和交易视图时，我决定保持在一个相对较高的层面。我明白区块链技术可能对你来说完全是新的，所以我想确保你理解去中心化应用的高级架构和目的，而不是用太多的行话和太多的技术让你感到困惑。既然你已经打下了坚实的基础，那就是深入了解以太坊 Dapp 的时候了。让我们先走进一个以太坊节点。

#### 2.1.1. 在以太坊节点内部

如图 2.1 所示，以太坊 P2P 网络的每个节点包含两个主要组件：

+   一个*以太坊客户端*——这作为运行时，包含四个元素：

    +   一个名为*以太坊虚拟机(EVM)*的虚拟机，能够执行通常用名为 Solidity 的语言编写的智能合约代码，并编译成 EVM 字节码。

        ##### 图 2.1. 一个以太坊节点包括一个以太坊客户端和一个区块链数据库。客户端包含一个客户端进程、一个以太坊虚拟机、一个内存池和一个暴露节点外部功能的 JSON-RPC API。节点有两种类型：完整节点和挖矿节点。

        ![](img/fig02-01_alt.jpg)

    +   一个*内存池*，节点在此存储它接收到的交易，如来自客户端方面的选民提交的投票，然后再将它们传播到网络中。

    +   一个*客户端进程*，负责协调处理工作。它处理传入的消息和交易，在合适的时候将它们分派到 EVM，并将交易存储到内存池中，从内存池中检索它们。客户端进程还处理节点从对等节点接收到的区块链块，并将它们附加到区块链数据库的本地副本。

    +   *JSON-RPC API*，它暴露客户端的功能给其他节点和外部用户。

+   *区块链数据库*——除了交易数据（如选民提交的投票），区块链还保留网络上所有部署的智能合约的 EVM 字节码的副本，并持有它们的状态。矿工节点定期在区块链上添加新块，每隔 15 秒一次。

#### 2.1.2\. 重新审视交易的生命周期

既然你知道以太坊节点托管了一个 JSON-RPC 接口、一个 EVM 和一个内存池，我可以借助一些图表（图 2.2 至 2.4）向你解释它们在交易生命周期中扮演的角色。

##### 图 2.2\. 交易的生命周期。当在选定的以太坊节点上的智能合约上通过 JSON-RPC 接口调用函数时创建投票交易。节点将交易放入内存池并在 EVM 上执行以进行验证。如果验证成功，交易会被广播到同伴节点，直到它达到矿工节点；否则，它就会消亡。

![](img/fig02-02_alt.jpg)

当通过 JSON-RPC 接口在选定的以太坊节点上的智能合约上调用函数时生成交易。（参见图 2.2。）

1.  一个完整节点从同伴节点接收交易，并将其放入内存池中。（参见图 2.2。）

1.  完整节点在 EVM 上执行交易以进行验证。（参见图 2.2。）

1.  如果验证成功，节点将其交易广播给它的同伴节点。如果验证失败，节点不会进一步传播交易，它就会消亡。

1.  一个矿工节点将来自同伴节点的交易放入内存池中。（参见图 2.3。）

1.  矿工节点从内存池中选择被认为是盈利的交易，在 EVM 上执行它们，并尝试将它们添加到新区块中。（参见图 2.3。）

1.  如果成功将创建的块添加到区块链，矿工节点将内存池中与相关交易移除。（参见图 2.3。）

    ##### 图 2.3\. 矿工节点从同伴节点接收交易并将其放入其内存池中。节点随后挑选它并在 EVM 上与其他交易一起执行，将其放在新区块中。如果块被添加到区块链上，交易将被从内存池中移除，并将块广播给同伴节点。

    ![](img/fig02-03_alt.jpg)

1.  节点将新块广播给同伴节点。（参见图 2.3。）

1.  一个完整节点从同伴节点接收新块。（参见图 2.4。）

1.  完整节点在 EVM 上执行所有区块交易以进行验证。（参见图 2.4。）

1.  如果块成功验证，节点将其内存池中所有相关交易移除。（参见图 2.4。）

1.  节点将区块广播给对等节点。（参见图 2.4。）

##### 图 2.4. 从节点接收到新区块开始，到它在 EVM 上处理所有交易进行验证，然后，如果验证成功，将相关交易从内存池中移除并进一步传播到网络中

![](img/fig02-04_alt.jpg)

#### 2.1.3 节. 开发视图：部署投票智能合约

到目前为止，您应该对去中心化应用程序的外观以及交易如何在系统中流转有一个很好的了解。不过，您可能仍在想知道智能合约何时以及如何传播到整个网络。结果是，服务器端合约传播过程与标准交易（如前章分析的图 1.8 中的投票交易）类似。

以太坊智能合约，如投票 Dapp 的投票智能合约，是用 Solidity 语言编写的代码。智能合约开发者将代码编译成 EVM 字节码，然后通过合约部署交易将其部署到 P2P 网络中，该交易在本地以太坊节点执行，然后传播到整个网络。在其传播过程中，矿工节点处理部署交易，并在区块链上存储其 EVM 字节码，如图 2.5 所示。

##### 图 2.5. 开发者用 Solidity 语言编写投票智能合约，然后将其编译成 EVM 字节码并插入到合约部署交易中。该交易会被推送到本地以太坊节点，并传播到整个网络。随后被矿工挖掘并添加到区块链上。

![](img/fig02-05_alt.jpg)

在阅读本章的前两节，关于 Dapp 的静态、动态和开发视图时，你可能会注意到我提到了一些可能会让你感到陌生的语言和 JavaScript 库。你不必过于担心需要学习的技术含量。你可以使用与您已经熟悉的中心化应用相似的编程语言来实现基于以太坊区块链的 Dapp。Dapp 的客户端通常基于标准的 HTML5+JavaScript；UI 与服务器端之间的通信层基于在客户端执行的 JavaScript 库 Web3；您还可以使用 Solidity 实现服务器端智能合约，这是 JavaScript 的一种变体。

正如图 2.6 所示，您将继续通过服务器端深入了解去中心化应用的核心，您将使用 Solidity 编写智能合约。然后，您将学习如何使用 Web3.js JavaScript 库远程与智能合约进行交互。最后，您将实现一个基于 HTML 和 JavaScript 的 Web UI。

##### 图 2.6。你将从用 Solidity 编写智能合约开始，然后通过 Web3.js Java-Script 库远程与智能合约交互，最后用 HTML 和 JavaScript 构建 web UI。

![](img/fig02-06_alt.jpg)

总之，有了一些 JavaScript 的知识，或者任何 C 语言样的语言，从中心化到去中心化应用开发的过渡并不困难。但在那种过渡中，完全理解去中心化应用背后的技术是很重要的，因为它们与中心化应用所基于的技术相当不同。我们在下一节探讨那个。

### 2.2。是什么技术使 Dapps 变得可行？

正如你所知，一个 Dapp 是基于业务逻辑被封装到智能合约中，这些智能合约是针对一个分布式数据库区块链执行的。区块链技术，反过来，基于公钥密码学、密码学散列函数和共识概念，你可以使用*工作量证明*和*权益证明*算法等多种方式来实现。

你可能会觉得我一直在打开越来越多的俄罗斯套娃，这可能永远不会结束，但请别灰心！密码学是我要覆盖的最低级别，我保证。

#### 2.2.1。区块链技术

在接下来的几节中，我将简要解释我刚才提到的所有密码学术语，这样你可以在我们进一步前进之前形成一个关于区块链数据库如何工作的心理模型。公钥密码学是区块链 underlying 的最低技术块，所以让我们从那里开始。

##### 公钥密码学

公钥密码学是一种基于一对密钥的加密方法：一个*私钥*，通常随机生成，只有其所有者知道，和一个*公钥*，对每个人公开，由一个输入私钥的算法生成。图 2.7 说明了私钥和公钥是如何生成的。

##### 图 2.7。私钥使用随机数生成器生成，然后输入到一个算法中生成公钥。

![](img/fig02-07_alt.jpg)

为了更好地理解，想象一下私钥就是你的邮箱的物理钥匙（只有你有它的副本）和公钥就是你的邮政地址（每个人都知道它），如图 2.8 所示。

##### 图 2.8。为了理解私钥和公钥的目的，你可以把公钥想成是大家都知道的你的邮政地址，而私钥是想成是你邮箱的钥匙，只有你拥有。

![](img/fig02-08_alt.jpg)

私钥有两个主要目的，如图 2.9 所示：

+   它允许解密使用公钥加密的数据。

+   它允许某人数字签名文档。他们只有知道私钥时才能产生签名，但任何知道公钥的人都可以验证签名。正如你将看到的，智能合约交易的真实性依赖于数字签名。

##### 图 2.9。你可以使用私钥解密用相关公钥加密的文档，如顶部图表所示。如图底部图表所示，私钥还允许某人数字签名文档以证明其来源。生成的数字签名随后可以与文档和相关公钥进行验证。

![](img/fig02-09_alt.jpg)

在区块链平台的背景下，加密货币通常存储在与公钥相关联的账户中，但只有知道私钥才能操作。如果私钥被遗忘或丢失，没有人可以使用该账户 anymore，其资金被认为是丢失的。

##### 密码学哈希函数

一个*哈希函数*是任何可以将任意大小的数据映射到固定大小数据的函数。固定大小的数据称为哈希或摘要。举个例子，你可以设计一个哈希函数，使其总能从任意大小的文件或字符串生成一个 64 位的哈希值。无论其大小是 10 KB 还是 10 GB，都会生成一个 64 位的哈希值，如图 2.10 所示。

##### 图 2.10。一个哈希函数给定任意大小的输入数据生成一个固定大小的哈希值（本例中为 64 位）。

![](img/fig02-10_alt.jpg)

一个*密码学哈希函数*具有五个额外的属性：

+   *它是确定性的*。相同的输入总会生成相同的哈希值。

+   计算起来*很快*。

+   *它是一个单向函数，反向操作不可行*。这意味着，除非你通过尝试，用函数对大量输入数据集进行暴力破解，否则无法从其哈希值推导出原始数据。

+   *它应该几乎不可能从两组不同的输入数据中得到相同的哈希值*。尽管存在两个输入可能产生相同哈希的小概率事件，但不可能事先确定它们，除非像前一点所建议的那样，将函数应用于大量输入数据。

+   *输入数据的微小变化应产生截然不同的哈希值*。因此，也正因为我在前一点所说，除非你用密码学哈希函数对相同的输入进行操作，否则你无法*故意*得到相同的哈希值，甚至是一个接近的值。

考虑到这些特性，思考以下场景。想象你正在写一张 30 美元的支票来支付你当地书店最新区块链书籍的费用。我知道，支票几乎已经不再使用，如果你是一位年轻的读者，你可能从未见过！请暂时忍受我一下。

你填写并签署了支票，正前往书店的路上，这时，你在手机聊天应用上绊倒了 curb。你没意识到支票掉在了路上，一阵风把它吹走了。你太倒霉了，它最后落到了当地小罪犯 Jack Forger 手中。他知道如何去除墨水，并迅速更换了金额和收款人，如图 2.11 所示。

##### 图 2.11\. 通过重新使用原始签名并更改收款人和金额来伪造物理支票

![](img/fig02-11_alt.jpg)

Jack 然后去了一家银行，成功兑现了 30,000 美元的支票。罪犯有了你的手写签名，并成功更换了收款人和金额。让我们看看电子支票上的数字签名如何避免这种令人不快的局面。

电子支票上的数字签名将是使用你的支票详情、支付的金额和收款人以及与你的银行账户关联的私钥（相当于你的手写签名）生成的加密哈希，如图 2.12 所示。

##### 图 2.12\. 电子支票可以利用与发送方银行账户关联的私钥生成的数字签名以及支票详情进行加密。可以通过将数字签名与发送方银行账户和支票详情关联的公钥进行比对来验证它。

![](img/fig02-12_alt.jpg)

当有人提交这种电子支票以及与你的银行账户关联的公钥时，银行可以验证数字签名是否与支票（金额和收款人）详情匹配，并且是否使用你的私钥生成。这就是书店老板将能够兑现你的支票的方式。

因为数字签名是一种加密哈希，所以只能从你填写电子支票时使用的特定详情中生成该签名。如果有人试图劫持电子支票——比如说一组熟练的黑客——改变金额，更重要的是，收款人将是毫无意义的，原因有两个：

1.  新的金额或收款人将会生成一个完全不同的数字签名，所以银行不会认为当前的签名是有效的，如图 2.13 所示。

1.  如果黑客尝试使用新的校验细节生成一个新的数字签名，他们无法生成与你的银行账户的公钥相关联的签名，因为他们不知道你的私钥。

##### 图 2.13\. 尝试伪造一个由数字签名保护的电子支票是徒劳的，因为新的原始数字签名与更改后的支票详情不匹配。

![](img/fig02-13_alt.jpg)

区块链交易与这里描述的电子支票非常相似：

+   它们起源于一个由公钥标识的账户。

+   它们包含交易详情，如加密货币的金额和收款人，也通过公钥进行标识。

+   它们携带数字签名，证明交易详情是通过发件人账户的所有者的私钥输入的。

区块链交易不必携带加密货币；它们可以携带任何数据。关键的一点是，通过携带数字签名，它们可以证明它们确实是由发件人发送的。

密码学散列函数不仅适用于数字签名。如果您想了解更多内容，请阅读边栏部分，了解如何使用它们来保护卖家免受恶意买家的侵害。

|  |
| --- |

**使用提交-揭示方案保护卖家免受恶意买家侵害**

密码学散列函数在各种情况下都很有用。您还记得我在第一章开头描述的去中心化电子商务应用程序吗？如果您是以卖家的身份阅读这本书，您可能会觉得这个解决方案没有从买家的角度来看那么有说服力。例如，根据所提出的解决方案，似乎没有什么能阻止用户接受货物，然后不授权向卖家付款。这令人失望！不要绝望：密码学散列函数来帮忙！

如果要求买家生成一个秘密代码，例如一个秘密短语或一个随机数，并在订单确认时将其加密散列值提供给卖家，那么您可以使应用程序对卖家更安全。您可以将这个散列值视为支付的一种键锁。当货物送达时，快递员只有在收到秘密代码后才会交付货物，该代码，当提供给电子商务 Dapp 时，会生成预期的初始散列代码，并且，作为一个物理钥匙，可以打开其关联的键锁，从而解锁支付。

最初提供原始信息的散列值，然后在第二阶段揭示完整信息的方式，被称为*提交方案*或*提交-揭示方案*，它有两个阶段：

1.  提交阶段，在此阶段，使用公开算法生成的原始信息的加密散列值提交给另一方。

1.  揭示阶段，在此阶段，完整的信息被揭示，并与提交的散列值进行验证，以证明揭示的信息确实与该散列值相关联。

这个强大的想法：证明拥有某些信息的知识，而不透露信息本身，早在 16 世纪就已经被伽利略使用过。伽利略最初以原论文的字母谜形式发表了他对金星的相位的发现，在最终确定研究之前，并未透露其真实信息。胡克和牛顿后来使用了类似的技巧，隐藏了他们发现的细节，同时又能声称他们是首先做出这些发现的人。

在本书的其余部分，你将看到这个想法是如何用来保护去中心化应用程序的。

|  |
| --- |

恭喜你完成了密码学 101 课程！希望这并不是太痛苦。你现在有了理解区块链如何工作的必要工具。现在我们将进入区块链。

##### 区块链

区块链是一个分布式数据库，包含称为块的记录。图 2.14（#ch02fig14）展示了典型区块链的结构。

##### 图 2.14. 区块链是一系列块的序列，每个块包含一个序列号、一个时间戳和一系列交易，每个交易都有单独的数字签名。每个块还引用了前一个块的加密哈希。

![](img/fig02-14_alt.jpg)

一个区块包括一系列交易，这些交易通过数字签名来证明它们的来源。大多数区块链使用*椭圆曲线数字签名算法*（ECDSA），基于椭圆曲线密码学，而不是传统的数字签名算法（DSA），因为 ECDSA 更难破解，并且使用更小的密钥来保证相同级别的安全性。每个区块包含一个时间戳和一个基于其加密哈希的前一个区块的链接。它还包含一个加密哈希，总结区块的完整内容，包括前一个区块的哈希。这样，区块链既保存了当前状态（最新的区块），又保存了自其成立以来存储在其中的所有交易的完整历史。

这种结构保证了交易不能被篡改或修改。在区块中记录的交易不能被追溯性地修改，因为要修改它，包含它的块的哈希将必须被重新生成，而这不会与已经由后续块引用的现有的哈希相匹配，如图 2.15（#ch02fig15）所示。

##### 图 2.15. 试图更改区块内容的尝试，例如其交易，是不会成功的：从被更改的区块详情生成的新的哈希不会与已经在下一个区块直接引用并在后续区块间接引用的原始区块的哈希相匹配。

![](img/fig02-15_alt.jpg)

|  |
| --- |

##### 注意

如果两个交易相互矛盾——例如，它们都试图将同一个账户的所有资金转移到不同的目标账户（这被称为“双重花费攻击”）——矿工会只执行第一个，通过全球可访问的序列号在以太坊网络中被识别。他们会拒绝第二个，并且它永远不会出现在合并的区块上。比特币的创始人中本聪是第一个解决双重花费问题的人。每个区块链都有解决这个问题的方案；否则，它就不会是可行的。

|  |
| --- |

我描述的区块链结构实际上是现实世界中区块链数据结构的一个简化版本，比如比特币中使用的默克尔树或以太坊中使用的帕特里夏树。区块链通过一个 P2P 网络自主管理，通过在每个节点上独立处理所有交易来实现容错和去中心化共识。由于这些特性，区块链特别适合记录事件的历史。这在身份管理、交易处理和来源追踪等几个用例中非常有用。

##### 挖矿

为了鼓励支持区块链的 P2P 网络持续处理其交易，活跃的处理节点，也称为*挖矿节点*或*矿工*，会因为提供的计算资源而获得奖励，间接地覆盖相关的电力成本，通过*共识*机制。每几秒钟，一个成功的矿工有权生成并保留平台支持加密货币的若干代币。这种加密货币具有经济价值，因为它可以用来购买网络上的服务，但它也可以兑换成美元、日元、欧元等传统货币。在比特币区块链的情况下，他们将获得几个比特币代币，截至撰写本文时，每个代币价值约 2000 美元。以太坊区块链给出的代币称为以太币，截至撰写本文时，每个代币价值约 200 美元。现在让我们来看看共识机制是如何工作的。

##### 共识

正如我之前提到的，共识是网络参与节点就交易结果达成一致的机制。在我第一章一开始提出的共识定义中，我还强调共识是分布式的，因为它是由许多参与者确定的，并且是无信任的，因为参与者不需要相互信任。实际上，共识并不是针对单个交易达成的，而是针对新的区块链区块。每个参与者独立验证一个新的区块是否有效，如果满意，将进一步将其传播到网络的其余部分。

实际中发生的情况是，如果大多数参与者都接受该区块作为有效区块，并且它已经成功地在整个网络中传播，矿工们将会使用这样的区块作为最新的有效区块，区块链的其余部分也将建立在这个区块之上。如果恶意矿工向区块链中添加了一个错误的区块，并且它传播到了其同伴节点，这些节点将会拒绝这个新区块，恶意链将会立即消亡。如果一个完整节点试图在传播给其同伴之前修改一个区块，也会有同样的结果。

正如你所见，共识机制的关键步骤是参与者节点验证最新区块。在验证区块中个人交易的数字签名后，参与者节点验证块的散列值是否有效。这样的散列值是由矿工根据商定的协议产生的。以太坊的早期版本使用了一种名为*Ethash*的算法，基于工作量证明协议。未来版本将基于一种权益证明协议，名为*Casper*。我会解释这两种协议。

##### 工作量证明

如您之前所见，一个区块包含一个加密散列值，它总结了区块的完整内容，包括其元数据和交易数据，还有一个固定长度的额外数据，例如 32 位，称为*nonce*。工作量证明（PoW）协议的目标是矿工必须找到一个 nonce，使得生成的散列值符合某种约束，例如，具有很多前导零。将 64 位无符号整数散列约束为在十六进制格式中具有 13 个前导零，如图 2.16 的示例，将有效的散列数从理论上的最大值 18,446,744,073,709,551,615 减少到 4,095。

##### 图 2.16. 工作量证明：生成一个不成功的区块散列和一个成功的区块散列

![](img/fig02-16_alt.jpg)

由于您之前看到的散列函数的特性，矿工找到这样的 nonce 的唯一方法是尝试许多可能的值，直到满足散列值的约束。在我刚才给出的例子中，每一次尝试成功的几率大约只有 0.00000000000002%。当找到一个满意的散列值时，矿工有权将正在处理的新区块附加到区块链上，并声称代币奖励。正如您所理解，产生有效散列值这种方式对 CPU 要求高，耗能，因此经济上昂贵。这种昂贵算法的主要原因是阻止恶意参与者附加新的错误区块或修改已存在的区块，使它们看起来像真正的区块。执行这些操作所需的能量（和金钱）会使它们变得不可行。在第 3.3.4 节的边栏中，我会向您介绍大多数矿工使用的硬件。

##### 权益证明

工作量证明（Proof of Work，PoW），比特币网络也使用这种机制，因耗费巨大能源（或者说，浪费？）而受到广泛批评。据估计，到 2020 年，比特币网络本身将消耗与保加利亚相同的电力。

为了解决这个问题，以太坊创始人之一 Vitalik Buterin 提出了一种基于**权益证明**的替代方法。这基于一组*验证者*对新区块链块的有效性进行投票。要加入验证者池，该池对任何人开放，节点必须提交一个以太币存款，直到节点离开该池才会释放。每个节点表达的投票权以其承诺的存款金额（相当于节点在池中的股份）为基准。在此方案下，验证者可以从发送者支付的交易费中获利。如果验证者作弊，与其关联的以太币存款将从网络上删除，并且所有者将被禁止重新加入，这起到了防止操纵的威慑作用。

现在你已覆盖了区块链数据库背后所有的通用加密技术。如果你想要了解更多关于这个主题的内容，我鼓励你阅读**Kalle Rosenbaum**所著的《Grok-king Bitcoin》（Manning, 2019）。现在让我们来考察一下简化 Dapp 开发的新近技术。

##### 梅克尔树和梅克尔根

我在前面的图表中展示的区块链结构是真实的一个简化表示。通常，矿工在块中放置两部分：*头部*和*身体*，如图 2.17 所示。身体包含块中包括的所有交易。头部包含你之前看到的块元数据，如区块号码、时间戳、前一个区块哈希和证明工作（PoW）的非数值。它还包含矿工计算的*交易梅克尔树*的*梅克尔根*。

##### 图 2.17。包括包含元数据的头部，如区块号码、时间戳、前一个区块哈希和交易梅克尔树的梅克尔根，以及包含交易集合的身体

![](img/fig02-17_alt.jpg)

如图 2.18 所示，交易 Merkle 树是一种按以下方式构建的树结构：

+   区块的交易放在树的底部，成对排列。

+   每个交易都被哈希，这些哈希中的每一个都成为梅克尔树的一个叶子。

+   对每对连续的哈希值都会计算一个哈希。

+   连续哈希的哈希一直重复，直到只剩下两个哈希值。这两个最终哈希值的哈希是*梅克尔根*。

##### 图 2.18。梅克尔树。单个交易位于树的底部；树的叶子是单个交易的哈希；再上一行是由树的叶子哈希组成的。最上面的一行，即下面的哈希的哈希，结束了树：这是梅克尔根。

![](img/fig02-18_alt.jpg)

因此，Merkle 树根是一个单一的散列值，它以一种保证其完整性的方式总结了包含在区块中的所有交易。在区块头中拥有 Merkle 树根的优势是，客户端可以通过检索网络对等体的区块头，而不是整个交易历史，以更快的速度同步区块链。这通常被称为*轻量级同步*。

#### 2.2.2. 以太坊技术

尽管可以困难地在早期的区块链系统（如比特币）上实现智能合约，但后来设计的区块链平台（如 Hyperledger、Nxt 和 Ethereum）可以更容易地编写和执行智能合约，这些平台的主要目的是简化其开发。因此，后来的区块链平台被认为是所谓的*智能区块链*或*区块链 2.0*的一部分。现在让我们简要地检查以太坊引入的主要创新：改进的区块链设计、EVM 和智能合约。

##### 以太坊区块链

在前一部分，您学习了关于区块链以及一种更高效的结构，该结构基于包含区块元数据的区块头和包含交易的区块体，使得客户端同步更快。以太坊区块链进一步改进了设计。首先，交易被散列在一个更紧凑且高效的（但仍具有加密验证）结构中，称为*Merkle-Patricia 树*（有关详细信息请参见侧边栏）。其次，区块头（由矿工通常生成）还包含除了交易 Merkle-Patricia 树的根之外，还包含收据（即交易输出）的 Merkle-Patricia 树的根和当前区块链状态的 Merkle-Patricia 树的根，如图 2.19 所示。

##### 图 2.19. 以太坊改进的区块头。以太坊区块链的区块头包含交易 Merkle-Patricia 树的根，这是一个比 Merkle 树更紧凑高效的结构。此外，它还包含收据（即交易效果）和区块链状态的 Merkle-Patricia 树的根。

![](img/fig02-19_alt.jpg)

如 Vitalik Buterin 在他博客文章“Merkling in Ethereum”中解释的，^([1])借助这三个 Merkle-Patricia 树，客户端可以有效地以可验证的方式检查以下内容：

> ¹
> 
> 参见 Vitalik Buterin，“Merkling in Ethereum，” Ethereum Blog，November 15，2015， [`mng.bz/QQYe`](http://mng.bz/QQYe)。

+   某个交易是否包含在某个区块中

+   交易输出会是什么

+   账户是否存在

+   账户余额是什么

|  |
| --- |

**Merkle-Patricia 树**

*trie*^([2])（或*前缀树*）是一种有序的数据结构，用于存储动态集合，其中键通常是字符串。trie 的根是一个空字符串，然后节点的所有后代都有与该节点关联的字符串的共同前缀，如图所示。

> ²
> 
> 请参考维基百科上的“Trie”页面了解更多关于这种数据结构的信息。[`en.wikipedia.org/wiki/Trie`](https://en.wikipedia.org/wiki/Trie)

![](img/f0053-01.jpg)

Trie 结构（图片：Booyabazooka（基于 Deco 的 PNG 图像）。Superm401 的修改 - 自己的工作（基于 Deco 的 PNG 图像））

**Merkle-Patricia trie**是一种结合了 trie 和 Merkle 树的数据结构。它通过使用*PATRICIA*算法（由 D. R. Morrison 于 1968 年设计的*实践的字母数字编码信息检索算法*）存储节点键，提高了 Merkle 树的效率（以 Ralph Merkle 的名字命名）。你可以在 Lloyd Allison 算法存储库上了解有关 Patricia 算法的信息。^([3]) 以太坊的 Merkle-Patricia trie 在以太坊维基上有详细的描述，附有代码示例。^([4])

> ³
> 
> [`www.allisons.org/ll/AlgDS/Tree/PATRICIA/`](http://www.allisons.org/ll/AlgDS/Tree/PATRICIA/)
> 
> ⁴
> 
> [`github.com/ethereum/wiki/wiki/Patricia-Tree`](https://github.com/ethereum/wiki/wiki/Patricia-Tree)

|  |
| --- |

当完整节点接收到一个新的块时，块体中包含的交易将按照以下方式处理：

+   交易按照新块的特定交易 Merkle-Patricia trie 组织。

+   交易在 EVM 上执行。这一操作生成了交易收据，这些收据按照新块的特定 Merkle-Patricia trie 组织。它还改变了全局状态 trie，每个节点上只存在一个实例。

如果新交易 trie、收据 trie 和修改后的状态 trie 的根与头部中的根匹配，则认为区块已验证。然后，新的和修改后的 trie 基于 LevelDB 存储在完整节点上，LevelDB 是一个开源的 NoSQL 数据库，由谷歌开发。请注意以下内容：图 2.20：

+   *交易存储*包含每个块的交易 trie，每个 trie 都是不可变的。这个存储的键是交易 hash（keccak 256 位 hash）。

+   *收据存储*包含每个块的交易 trie，每个 trie 都是不可变的。这个存储的键是交易收据的 hash（keccak 256 位 hash）。

+   *状态存储*包含一个代表最新全局状态的*状态 trie*，每当新块添加到区块链时，这个 trie 就会更新。trie 是以账户为中心的，所以这个存储的键是账户地址（160 字节）。

##### 图 2.20. 以太坊节点中详细的区块处理。当一个完整节点收到一个新的区块时，它会分离出头部和体部。然后它会创建一个本地交易尝试和一个本地收据尝试，并更新现有的状态尝试。新的和更新的尝试随后被提交到各自的存储中。

![](img/fig02-20_alt.jpg)

以太坊区块链设计的一个主要好处是，它允许三种类型的同步：

+   *完整*——你的客户端下载整个区块链，并在本地验证所有区块。这是最慢的选项，但你会有信心本地区块链副本的一致性。

+   *快速*——你的客户端下载整个区块链，但只验证在同步开始前 64 个区块和新的区块。

+   *轻量级*——你的客户端从一个对等完整节点检索区块链的当前状态尝试，并将其存储在本地。它不会从对等节点检索任何历史区块，只会接收新的区块，所以你不必等待很长时间。这将允许你快速启动。

|  |
| --- |

##### 注意

虽然在本节中我详细介绍了以太坊区块链的物理设计，因为了解交易和状态是如何维护的是很重要的，但在整本书中，我将使用简化的逻辑图，在这些图中，我将区块表示为交易的集合。

|  |
| --- |

##### 以太坊虚拟机

以太坊虚拟机（EVM）的目的与 Java 虚拟机（JVM）或.NET 公共语言运行时（CLR）相似。它在以太坊 P2P 网络的每个节点上运行。它是图灵完整的，这意味着它可以运行任何复杂度的代码。它可以在读取和写入模式下访问区块链数据。只有在数字签名已验证且满足基于区块链当前状态的限制后，EVM 才会执行代码。

##### 智能合约

智能合约，或简称为合约，封装了去中心化应用的逻辑。如我之前提到的，以太坊智能合约是用像 Solidity 或 Serpent 这样的高级语言编写的，并编译成 EVM 字节码。它部署在 P2P 网络的每个节点上，并在 EVM 上执行。

##### 下一代区块链

多亏了 EVM，以太坊是一个*可编程区块链*。因此，你可以在其上开发任何类型的去中心化应用，不仅仅是加密货币，这是早期区块链的情况。由于这种可编程性，以太坊被认为是通用或下一代区块链。有些人甚至认为智能区块链平台将是新一代互联网的基础，即 Web 3.0（尽管这个版本的网络也被“语义网络”社区使用），这将特征更加强大的用户。

### 2.3. 以太坊的历史和治理

在结束本章之前，我想分享一下以太坊的创建过程以及初始发布后的发展。在接下来的几章中，你将开始使用以太坊平台的一些组件。在你这样做之前，了解这些组件是如何产生的以及提议和达成变更的过程是很重要的。你会发现去中心化不仅是以太坊的一个技术方面；它几乎是一种哲学，也渗透在其治理之中。

#### 2.3.1. 谁创造了以太坊？

以太坊是维塔利克·布特林的创意，他从 2011 年起就是比特币和加密货币技术的早期追随者，当时他还与米哈伊·阿尔西共同创立了比特币杂志。在研究将区块链技术泛化以构建任何应用程序的可能性之后，2013 年 11 月，他撰写了*以太坊白皮书*（[`github.com/ethereum/wiki/wiki/White-Paper`](https://github.com/ethereum/wiki/wiki/White-Paper)），在其中他阐述了以太坊协议的设计，以及智能合约基础设施的初步细节。在维塔利克的愿景中首批参与的人包括加文·伍德，他参与了协议的塑造，并成为 C++客户端的主导开发者，以及杰弗里·威尔克，他成为 Go 客户端的主导开发者。仅仅几个月的工作后，2014 年 1 月，维塔利克在 bitcointalk 上宣布了以太坊计划[5]，并得到了相当大的回应。随后，在 2014 年 4 月，加文撰写了*以太坊黄皮书*[6]，详细说明了以太坊虚拟机的设计。为了加速平台的发展，2014 年 7 月，以太坊通过以太币众筹筹集了约 1840 万美元，这次众筹在法律上得到了刚刚一个月前在瑞士成立的以太坊基金会的支持，该基金会的使命是（引用官方网站[`www.ethereum.org/foundation`](https://www.ethereum.org/foundation)）：

> ⑤
> 
> 参见维塔利克·布特林，“欢迎来到开始”[`bitcointalk.org/index.php?topic=428589.0`](https://bitcointalk.org/index.php?topic=428589.0)。
> 
> ⑥
> 
> 参见“关于以太坊基金会”[`github.com/ethereum/yellowpaper`](https://github.com/ethereum/yellowpaper)。
> 
> ……促进和支持以太坊平台和基础层的研究、开发和教育，将去中心化协议和工具带到世界各地，使开发者能够产生下一代去中心化应用程序（Dapps），并共同构建一个更加全球可访问、更加自由、更加值得信赖的互联网。

表 2.1 总结了自以太坊成立以来至本书写作时的时间线。

##### 表 2.1. 自成立以来至 2018 年夏季以太坊的时间线

| 2011 年 9 月 | 维塔利克·布特林与米哈伊·阿尔西共同创立了比特币杂志。 |
| --- | --- |
| 2013 年 11 月 | 维塔利克·布特林发布了以太坊白皮书，阐述了以太坊协议的设计和智能合约基础设施。 |
| 2013 年 12 月 | 加文·伍德联系了维塔利克，并开始了详细的设计讨论。 |
| 2014 年 1 月 | 维塔利克在 bitcointalk 上发布了以太坊的正式公告。 |
| 2014 年 4 月 | 加文·伍德发布了以太坊黄皮书，详细规定了以太坊虚拟机（EVM）。 |
| 2014 年 6 月 | 以太坊基金会成立于瑞士。 |
| 2014 年 7 月 | 以太坊通过以太币众筹筹集了 1840 万美元。 |
| 2014 年 8 月 | 维塔利克·布特林、加文·伍德和杰弗里·威尔克设立了 ETH DEV，一个专注于以太坊核心协议和基础设施发展的非营利组织，该组织在 2014 年管理了各种概念验证的开发。 |
| 2014 年 11 月 | ETH DEV 在柏林组织了 DEVCON-0，这是第一次以太坊开发者大会，整个以太坊项目团队首次聚会。 |
| 2015 年 1 月 | Go Ethereum 团队在阿姆斯特丹聚会，会上展示了 Whisper Dapp 和 Mist 的原型。 |
| 2015 年 7 月 | 发布了 1.0 版的主网，代号为 Frontier，以及以太坊钱包的稳定测试版。 |
| 2015 年 11 月 | 在伦敦，400 人参加了 DEVCON-1，会上给出了关于以太坊生态系统的每个部分的 80 多个演讲。 |
| 2016 年 3 月 | 该项目发布了 2.0 版的主网，代号为 Homestead。 |
| 2016 年 7 月 | 在 DAO 攻击后，以太坊发生了一次计划外的分叉，以太坊与以太坊经典之间发生了分裂。（见边栏。） |
| 2017 年 10 月 | 该项目发布了 3.0 版的主网，代号为 Byzantium。 |
| 2018 年 6 月 | 该项目发布了基于权益证明（PoS）的测试网版本，代号为 Casper。 |

如果你对以太坊的历史感兴趣，官方文档有一个页面^([7])专门介绍。但你可以在泰勒·格里宁的博客文章“Cut and Try: Building a Dream，”^([8])（一名核心以太坊开发者）和维塔利克·布特林本人撰写的“以太坊协议的史前史，”^([9])中找到关于以太坊创建过程中发生的主要事件的一手且更吸引人的描述。|

> ⁷|
> 
> 参见“以太坊历史，”以太坊 Homestead，[`mng.bz/XgwM`](http://mng.bz/XgwM)。|
> 
> ⁸|
> 
> 参见泰勒·格里宁，“Cut and Try: Building a Dream，”2016 年 2 月 9 日，[`mng.bz/y1BE`](http://mng.bz/y1BE)。|
> 
> ⁹|
> 
> 参见维塔利克·布特林，“以太坊协议的史前史，”[`mng.bz/MxRm`](http://mng.bz/MxRm)。|

|  |
| --- |

**DAO 攻击以及以太坊与以太坊经典之间的分裂**

DAO（去中心化自治组织）是以太坊领域内的第一个主流 Dapp。它是一个去中心化的风险投资基金。DAO 代币持有者本应就所有投资决策进行投票。在 DAO 智能合约仍在开发时，代币通过众筹销售出售给投资者，这是一种去中心化的众筹应用程序。（你会在第六章和第七章中了解更多关于众筹销售的内容。）这场于 2016 年 5 月进行的资金筹集活动成功筹集了超过 1200 万以太币，当时价值约 1.5 亿美元（以太币交易价格为 11 美元）。

DAO 合约的一个功能是，如果 DAO 代币持有者对合格多数做出的决定（投资决策需要 20%的投票支持）不满意，他们可以分裂出主 DAO 并创建自己的 Child DAO，在那里他们开始对不同的投资提案进行投票。2016 年 6 月，一些社区成员认为这一功能从安全角度来看可能存在缺陷，一名黑客利用了这一功能，通过递归调用不断提取资金，成功控制了 3500 万以太币（当时价值约 5 亿美元）。

幸运的是，Child DAO 创建功能需要保留资金 28 天，然后才能将其转出到另一个账户，所以黑客不能立即窃取资金。这为 DAO 开发者和以太坊社区提供了一些时间来提出解决方案以防止盗窃。最终，在区块链的软分叉失败后（该分叉将列入黑名单任何来自 DAO 的交易），社区投票决定进行硬分叉，包括一个旨在将被盗资金归还给原所有者的智能合约。尽管大多数人投票支持硬分叉，但社区中的一些成员认为硬分叉违反了以太坊白皮书中的各种原则，主要是智能合约代码默认为法律的原则以及区块链不可篡改的保证。他们随后决定保留原始的区块链运行，并将其重命名为以太坊经典。

关于 DAO 攻击的文章和博客文章有很多，从技术层面到高级层面不等。考虑到您在这个领域还没有很强的技术基础，如果您想了解更多关于这方面的内容，我建议您阅读一下“The DAO, The Hack, The Soft Fork and The Hard Fork，”^([10])这篇文章，它详细描述了发生了什么，而没有过多涉及技术细节。在阅读了关于安全性的第十五章之后，您将能更好地理解 DAO 攻击，但我之所以特别提到它，是因为本书大多数所用的技术超出了本书的范围。尽管如此，如果您那时急于了解攻击的技术细节，我推荐您阅读这篇精彩的“Analysis of the DAO Exploit.”^([11])文章。

> ¹⁰
> 
> 请参阅 Antonio Madeira 的文章，“The DAO, The Hack, The Soft Fork and The Hard Fork，”2016 年 7 月 26 日，[`mng.bz/a7NY`](http://mng.bz/a7NY)。
> 
> ¹¹
> 
> 请参阅 Phil Daian 的文章，“Analysis of the DAO exploit，” Hacking, Distributed，2016 年 6 月 18 日，[`mng.bz/gNrn`](http://mng.bz/gNrn)。

|  |
| --- |

#### 2.3.2 谁控制 Ethereum 的开发？

自从 2015 年 7 月的 Frontier 版本发布以来，Ethereum 治理这个热门话题在 Ethereum 基金会以及更广泛的 Ethereum 社区中开始加速推进。诸如“谁控制 Ethereum 的开发”、“更改如何提出”以及“谁批准它们以及如何批准”的关键问题被公开讨论，以便早期采用者能够被鼓励使用并信任这个平台。

区块链治理关乎参与者必须遵循的规则和流程，以便对平台进行更改，以及这些规则和流程本身应该如何定义。简而言之，它关乎谁决定更改以及决策如何获得批准并得以执行。

ETH DEV，这个领导 Ethereum 开发的非营利组织，在 Ethereum Improvement Proposals (EIPs, [`eips.ethereum.org/`](https://eips.ethereum.org/) )存储库中收集提案。^([12])这是基于其他开源项目也遵循的成熟流程——Python Improvement Proposals (PIPs) 和 Bitcoin Improvement Proposals (BIPs) 是典型的例子。提案最初被研究，通常随后会有概念验证（PoCs）。

> ¹²
> 
> 请访问 GitHub 上的 EIPs 页面：[`github.com/ethereum/EIPs`](https://github.com/ethereum/EIPs)。

如果一个提案获得了足够的动力（被核心以太坊开发者认为是有趣的），它将进入*草稿*状态，并可能在开发人员会议或官方在线论坛上由更广泛的社区进一步讨论。如果达成了非正式共识，提案可以立即进入*接受*或*拒绝*状态。被接受的提案将被安排在未来的平台版本中发布，因此会投入更多的努力。显然，参与者总是存在不同意提案或其实施的风险，因此只有当大多数参与者采用该提案后，该提案才被视为隐性接受。

偶尔，一些提案会在更广泛的社区中引起热烈讨论。在这些情况下，决策并不清晰，它们会经历正式的链上投票。当涉及到链上投票时，通常遵循以下两种竞争性模型之一：

+   松耦合链上投票（亦称非正式治理）—社区领导者（例如以太坊基金会和 ETH DEV）示意如何投票。参与者通过一个专用的智能合约在链上投票，该合约根据他们拥有的以太币数量来赋予他们的偏好权重。（这种投票通常被称为*币投票*。）如果投票结果有利，则实施该提案。尽管投票在伦理上是具有约束力的，但开发者或其他关键参与者，如矿工，可能总是决定不实施或采用获胜的提案，冒着被社区贴上标签的风险。

+   紧密耦合链上投票（亦称链上治理）—在投票发生之前，提案得到完全实施，通常是由支持它的开发者团队完成的，然后智能合约在链上投票成功后仅在生产网络上启用功能。这种模型通常受到纯粹主义者的青睐，他们认为技术分析在最后阶段之前不应受到政治影响。

紧密耦合链上投票已在各种区块链平台上引入，并变得相当流行。但与比特币和 Zcash 等其他 established 区块链平台一样，以太坊倾向于遵循松耦合投票的原则，Vitalik Buterin 在他的博客文章“区块链治理笔记”中公开支持这一点。^([13])

> ¹³
> 
> 参见 Vitalik Buterin，“区块链治理笔记”，2017 年 12 月 17 日，[`vitalik.ca/general/2017/12/17/voting.html`](https://vitalik.ca/general/2017/12/17/voting.html)。

正如你所看到的，以太坊治理相对非正式且集中，因为核心开发者似乎比更广泛的社区拥有更多的决策权。这种说法是，如果一切都通过正式投票，平台会发展得太慢。如果你对以太坊治理感兴趣，我推荐以下文章：

+   “以太坊正在摒弃加密货币治理手册”^([14])

    > ¹⁴
    > 
    > 参见 Rachel Rose O’Leary，“以太坊正在摒弃加密治理手册，”Coindesk，2018 年 3 月 14 日，[`mng.bz/edwZ`](http://mng.bz/edwZ)。

+   “实验性投票努力旨在打破以太坊治理僵局”^([15])

    > ¹⁵
    > 
    > 参见 Rachel Rose O’Leary，“实验性投票努力旨在打破以太坊治理僵局，”Coindesk，2018 年 5 月 23 日，[`mng.bz/pgQ0`](http://mng.bz/pgQ0)。

+   “用户视角下的区块链治理介绍”^([16])

    > ¹⁶
    > 
    > 参见 Richard Red，“用户视角下的区块链治理介绍，”Medium，[`mng.bz/O2VO`](http://mng.bz/O2VO)。

### 总结

+   一个以太坊节点托管一个以太坊客户端和区块链的一个副本。

+   以太坊客户端包含

    +   一个名为 Ethereum 虚拟机（EVM）的虚拟机，能够执行智能合约字节码。

    +   一个内存池，其中节点接收的交易在进一步传播到网络之前被存储。

    +   一个 JSON-RPC API，它将客户端的功能暴露给其他节点和外部用户。

    +   一个客户端进程，用于协调处理。

+   以太坊智能合约是使用 Solidity 语言编写的代码，并编译为 EVM 字节码。

+   以太坊智能合约通过合约部署交易在 P2P 网络上部署，推送到本地以太坊节点，然后在整个网络中传播。

+   区块链是一个由区块组成的序列，每个区块包含一个序列号、一个时间戳和一系列交易，每个交易都单独进行数字签名。每个区块包括对前一个区块的加密哈希的副本和 nonce，用于生成当前区块的哈希。

+   以太坊相对于之前区块链实现的主要创新是 EVM 和智能合约的概念。

+   以太坊遵循一种非正式的治理模式，其中提案需要经历以太坊改进提案（EIPs）的过程：它们由核心以太坊开发者进行分析，通常通过概念验证（PoCs）进行尝试，最终被接受或拒绝。

+   偶尔，当一个 EIP 引起热烈讨论时，参与者在链上对其进行正式投票，但是，即使投票有利，一个提案实际上只有在大多数参与者采纳它时才被认为是被接受。

## 第三章. 以太坊平台

|  |
| --- |

**本章内容**

+   通过以太坊钱包与以太坊交互

+   理解以太坊智能合约的特点

+   通过 Go Ethereum (geth) 客户端与以太坊交互

+   理解和管理工作账户

|  |
| --- |

前一章介绍了 Dapps 和背后的概念和技术，其中就包括以太坊。在本章中，我将更深入地介绍以太坊，所以你会得到开发 Dapps 所需的基础知识。我会首先介绍以太坊钱包，这是一个你将用来通过传输一些以太币（以太坊加密货币）开始与以太坊 P2P 网络互动的 UI 工具。然后，你将获得智能合约的广泛概述，这是以太坊引入的关键技术。

在学习 Go Ethereum，也就是平台上众多客户端中的一种之后，当你理解了账户的用途，你将进入下一个阶段，并通过几种方式开始通过 Go Ethereum 与以太坊网络互动：将命令输入到操作系统壳中，将指令输入到 Go Ethereum 控制台，以及使用 HTTP 请求。到那时，你应该已经对平台有足够的熟悉度，可以自信地继续阅读本书的剩余部分。这将是一个密集但值得的章节。让我们开始吧。

### 3.1. 通过钱包连接到以太坊

以太坊网络提供两个主要的图形用户界面：

+   *Mist*—用于以太坊 Dapp 的浏览器

+   *以太坊钱包*—带有单个 Dapp 的 Mist 特定版本

在后面的章节中，你将会了解到 Mist。目前，我们将重点关注以太坊钱包。钱包的主要目的是存储、接收和传输以太币，这是以太坊的加密货币。如果你曾经处理过比特币，它与比特币钱包相似，你将使用它来传输以太币，以便以最简单的方式开始与平台互动。它也是一个有用的工具，可以学习如何在公共以太坊网络上部署智能合约并与之互动。

#### 3.1.1. 开始使用以太坊钱包

当你打开下载页面([`github.com/ethereum/mist/releases`](https://github.com/ethereum/mist/releases))时，你会找到各种版本的 Mist 和以太坊钱包。选择与你操作系统相对应的以太坊钱包版本，并下载相关的 zip 文件。（我选择了 Ethereum-Wallet-win64-0-11-1.zip。）解压后，你可以直接运行可执行文件 Ethereum Wallet.exe。第一次启动时，它将默认为主网络。在本章中，你将在公共测试 Ropsten 网络上进行操作，而不是主网络。要选择它，你必须从顶部菜单中选择，如图 3.1 所示：开发 > 网络 > Ropsten。你还可以通过 Alt+Ctrl+2 快捷键选择 Ropsten 网络。

##### 图 3.1. 从“开发 > 网络 > Ropsten”菜单选项中选择测试 Ropsten 网络，或者通过 Alt+Ctrl+2 快捷键进行选择。

![](img/fig03-01_alt.jpg)

在您选择 Ropsten 网络后，钱包将开始与相关区块链同步。默认情况下，同步模式是轻量级，正如您在上章看到的那样，从对等节点下载当前状态三叉树，因此您不必等待很长时间（几分钟）。这将允许您快速启动。但是，如果您想要执行写操作，例如传输以太币或部署智能合约，这是您将要执行的操作，您必须获取区块链的完整副本——您可以选择快速或完整。如果您不记得这些同步模式是如何工作的，请回到上一章。以下是您在本地同步 Ropsten 区块链时可以预期的粗略估计：

+   **快速**—占用大约 1 GB 的磁盘空间，需要两到四个小时

+   **完整**—占用大约 100 GB 的磁盘空间，可能需要一两天

一旦您同步完成，您将能够在屏幕顶部看到同步详细信息，包括您连接到的网络名称、最新区块号码以及自接收最后一个区块以来经过的秒数，如图 3.2 所示。

##### 图 3.2。您可以在屏幕顶部看到同步详细信息，包括网络名称和最新区块号码。

![](img/fig03-02_alt.jpg)

|  |
| --- |

##### 警告

为了执行本章及下一章将介绍的操作，您必须选择快速或完整同步；否则，您将无法通过钱包传输以太币或部署合约。为了能够执行交易，您必须拥有区块链的完整本地副本。如果钱包在一段时间后似乎无响应并且您没有注意到同步有任何进展，这可能是因为钱包尚未能够连接到任何对等节点。在这种情况下，关闭它，尝试通过 geth 客户端同步 Ropsten 区块链。如果您需要这样做，请阅读第 3.3 节中关于 geth 的部分，然后按照第八章中第 8.1 节的说明同步它到 Ropsten。

|  |
| --- |

##### 图 3.3。账户概览屏幕。您可以通过点击“添加账户”来创建一个账户。

![](img/fig03-03_alt.jpg)

此时，您已经准备好创建账户。点击“钱包”选项卡，这将带您到“账户概览”屏幕，然后点击带有加号符号的“添加账户”按钮，如图 3.3 所示。

您将看到一个要求输入强密码的小对话框。（确保您从右下角拉出对话框，直到看到“确定”按钮。）输入密码（两次）后，您将被告知备份您的密钥文件（稍后详细介绍）和密码。

|  |
| --- |

##### 警告

小心管理你的密码。如果你忘记了自己的密码，你将无法点击任何“我忘记了我的密码”按钮。丢失你的密码意味着你将失去账户中存储的以太币。当指向测试网络时，这不是一个大问题，因为那里以太币没有价值。但是，尤其是在转移到生产网络时，你应该养成选择强密码并在安全的地方保存副本的好习惯。安全总比后悔好！

|  |
| --- |
|  |

##### 注意

如果你使用的是 Ethereum 钱包 for Mac OS 或 LINUX，界面会有所不同，截图可能与您看到的不匹配，并且我的描述可能不会完全适用。另外，默认网络可能也会有所不同。但您应该能够找到执行我描述的操作的其他方法。

|  |
| --- |

钱包生成账户后，在账户概览屏幕上你会看到*账户 1* 以及相关的十六进制地址，以太币余额为零。我稍后会详细介绍账户；现在，用相同的方法再创建一个账户，现在你应该在屏幕上看到两个账户，如图 3.4 所示。图 3.4 现在你已经创建了几个账户（可以随意创建更多），你可以尝试使用钱包执行一些常见操作。

##### 图 3.4. 在账户概览屏幕上显示账户详情，该账户是在创建后显示的

![](img/fig03-04_alt.jpg)

#### 3.1.2. 使用钱包执行常见操作

在所有账户上以太币（Ethereum 加密货币）的余额为零，你不会走得太远，因为如你所学，要在网络上执行交易，你必须用以太币支付交易费用。因为在测试网络上无法购买以太币，你必须要生成它。一种方法是通过挖矿。

##### 挖矿

挖矿是通过将新交易整合到区块链区块的过程。Ethereum 网络中的许多参与者运行特殊的挖矿节点，希望以此获得以太币奖励，并因向网络提供计算能力而获得补偿。尽管在真实公共网络上挖矿以太币具有挑战性，并需要基于先进 GPU 芯片集的专业硬件，但在测试网络上使用“普通 CPU”挖矿并通过钱包菜单生成以太币是很容易的：

开发 > 开始挖矿（仅限测试网）

|  |
| --- |

##### 注意

只有在完全以快速或完整模式同步区块链后，菜单选项开发 > 开始挖矿才会出现。

|  |
| --- |

你的机器的 CPU 将会忙碌起来，几分钟后你应该积累足够的以太币开始操作。

-   如果出于任何原因挖矿时间太长，为你的 Ropsten 账户提供资金的另一种方式是通过所谓的*水龙头*。以下网址可以免费发送测试以太币到你的地址：http://faucet.ropsten.be:3001/donate/<目的地地址>，例如，http://faucet.ropsten.be:3001/donate/0x8713Cb74c7DB911f2056C8DD2bA5036-7-eeEa11D0\. 几秒钟后，你的目标地址应该会收到 1 个以太币，如图 3.5 所示。figure 3.5 你可以通过在 Ropsten Etherscan 网页顶部的文本框中输入你的地址来检查水龙头发送以太币的状态：[`ropsten.etherscan.io/`](https://ropsten.etherscan.io/)。如果 faucet.ropsten.be 无法按预期工作或者你一直被列入灰名单，可以尝试[`faucet.kyber.network/`](https://faucet.kyber.network/)。或者，尝试 Google ropsten faucet。

##### -   图 3.5. 使用水龙头设施后的账户余额

![](img/fig03-05_alt.jpg)

##### -   转移以太币

-   现在你可以尝试在账户之间移动一些以太币。很简单。首先，前往发送屏幕。选择源（账户 1）和目标账户地址（从账户概览屏幕复制账户 2 的地址），然后选择你想转移的以太币金额——例如，0.5 以太币。最后，在决定交易费用后，点击发送交易。现在不用担心这个；我们稍后讨论交易费用。

-   你会被提示输入密码，如图 3.6 所示。figure 3.6 输入源账户（账户 1）的密码以数字签名交易，并随后证明账户所有者正在发送该交易，然后点击发送交易。你现在已经完成了你的第一次以太币交易！

##### -   图 3.6. 在账户之间移动以太币的密码输入屏幕。当使用以太坊钱包发送以太币时，必须输入发送账户的密码以数字签名交易，从而证明确实是账户所有者发送以太币。

![](img/fig03-06_alt.jpg)

-   要查看交易的状态，返回账户概览屏幕，并在屏幕底部点击最新交易。点击相关链接可以进一步查看详细信息，如图 3.7 所示的屏幕截图。figure 3.7

##### -   图 3.7. 账户概览屏幕中交易概要信息

![](img/fig03-07_alt.jpg)

-   你可以通过在 Etherscan 网站上检查，更好地了解你的交易对 Ropsten 区块链的贡献。这是一个报告以太坊区块链实时发展的网站：[`ropsten.etherscan.io/`](https://ropsten.etherscan.io/)。你可以获取详细的区块和交易信息。

既然你已经对以太坊有了一些了解，是时候了解更多关于这个平台引入的伟大创新之一：智能合约。一旦你理解了智能合约是如何工作的，你就能在 SimpleCoin 这个你在上一章开始构建的加密货币上取得更大的进步。

### 3.2. 智能合约：Dapps 的大脑

如我在第一章所描述，以太坊智能合约，或简单地说*合约*，是一个包含业务规则和状态的软件实体。它是用如 Solidity 之类的高级语言编写的，编译成 EVM 字节码，部署到以太坊网络，并存储在其区块链上的一个特定账户，该账户在部署时生成。

如图 3.8 所示，合约从用户账户（或其他合约）接收交易消息，并在以太坊虚拟机（EVM）上执行其逻辑。这可能涉及到向其他合约发送消息，从区块链中读取状态，或向区块链写入状态（具体来说是从/到状态 Merkle-Patricia 树）。向合约发送消息的账户会被成功挖矿节点收取以太币，用于处理所请求操作期间的计算和网络资源消耗。这种计算和资源的数量是以一个称为*燃料*的单位计算的，正如你将在 3.2.3 节看到的，所以通常说一个交易消耗了一定的燃料（而不是资源）。

##### 图 3.8. 以太坊合约从用户账户接收交易消息。它的逻辑在以太坊虚拟机（EVM）上执行；然后成功挖矿者计算执行计算和网络资源所使用的燃料单位，并以以太币向用户账户收费。

![](img/fig03-08_alt.jpg)

如果你想要理解智能合约，用户和其他合约是如何实例化它们的，以及它们是如何执行的，你需要更深入地了解我到目前为止只触及的各种概念：

+   账户

+   以太币和燃料

+   交易消息

+   以太坊虚拟机

首先，我会告诉你更多关于各种类型的账户的信息。

#### 3.2.1. 账户

你已经遇到了账户的概念好几次了。账户分为两种类型：

+   外部所有者账户（EOA）(或简单地说*外部账户*)—这些也被非正式地称为*用户账户*。从其公钥可以公开识别它们，但只有知道私钥才能操作它们。如果你买了一些以太币，你会把它存在这种类型的账户里。而且，你也会从一个 EOA 开始与智能合约的交易。

+   合约账户—这些账户是用于执行合约的。合约地址在部署时生成，它标识了合约在区块链上的位置。

交易所账户和合约账户都以键值存储和以太币余额的形式存储数据。表 3.1 比较了交易所账户和合约账户的主要属性。

##### 表 3.1. 交易所账户与合约账户对比

| 属性 | 外部所有账户 | 合约账户 |
| --- | --- | --- |
| 是否有以太币余额 | 是 | 是 |
| 能否发起交易消息 | 是 | 否 |
| 能否发起调用消息 | 否 | 是 |
| 是否有代码 | 否 | 是 |

#### 3.2.2. 以太币

我随便提到了几次以太币，所以可能是时候让你了解更多关于以太币的信息了。以太币是支持以太坊区块链的加密货币。其主要用途是代表在平台上交易的服务和商品的货币价值。

以太币也用于支付交易费用。如 3.2 节和 3.2.3 节所述，这些费用以计算单位“气”来衡量，该单位衡量交易消耗的计算资源。但是这些费用是以以太币结算的（从单位气的价格计算得出）。矿工通过向网络提供计算能力并在区块链上附加新的交易区块来收取交易费用作为补偿。

以太币有各种面额，正如您在表 3.2 中所见，都是以 Wei 为单位的最小以太币面额来定义的。

##### 表 3.2. 以太币面额及其在 Wei 中的价值

| 单位 | Wei 值 | Wei |
| --- | --- | --- |
| Wei | 1 Wei | 1 |
| 克维 (Babbage) | 1e3 Wei | 1,000 |
| 兆维 (Lovelace) | 1e6 Wei | 1,000,000 |
| 吉维 (Shannon) | 1e9 Wei | 1,000,000,000 |
| 微以太 (Szabo) | 1e12 Wei | 1,000,000,000,000 |
| 毫以太 (Finney) | 1e15 Wei | 1,000,000,000,000,000 |
| 以太币 | 1e18 Wei | 1,000,000,000,000,000,000 |

图 3.9 总结了以太币的生命周期，它经历了以下步骤：

1.  铸造以太币

1.  传输以太币

1.  存储以太币

1.  交换以太币

##### 图 3.9. 以太币生命周期。以太币由矿工节点铸造到矿工用户账户中。然后它被传输到交易所账户（也称为用户账户）。从那里，它可以存储在各种钱包中。最终，它可以通过加密货币交易所兑换成美元、欧元、日元、英镑等真实货币。

![](img/fig03-09_alt.jpg)

##### 铸造以太币

如果你不熟悉加密货币，你可能会想知道以太币是如何铸造和交换的。以太币是通过挖矿过程产生的，在这个过程中，矿工竞争将交易分组并附加到新的区块链区块中，如我在 1.1.2 节中讨论的。成功时，矿工将获得一定数量的以太币硬币作为奖励。大约每 15 秒就会在以太坊区块链上添加一个区块，相应的货币供应量也会增加。

##### 传输以太币

一旦以太币被生成，它就被分配给矿工的外部账户。矿工然后可以将以太币转移到其他外部账户或合约账户，无论是通过以太坊钱包还是像后面会看到的程序化方式。

##### 交换以太币

由于以太币有价值，它通常不会免费在账户间转移。它通常是在智能合约进行的商品和服务交换中转移，但也可能是用比如美元、欧元、英镑、日元等传统货币来交换。尽管有可能从个体所有者那里购买以太币，并支付他们约定数量的传统货币，但使用加密货币交易所处理这类交易更加有效。有两种主要的交易所类型可用：集中的，如 Kraken、Coinbase 和 Coinsquare，以及去中心的，如 EtherEx。每个交易所通常都倾向于特定的现实世界货币。

##### 存储以太币

一旦某人获得以太币，不管通过挖矿、智能合约交易还是基于交易所的交易，它都会分配到一个账户。你可以用很多方法来管理账户，每种方法都在便利性和安全性之间有不同的权衡。最便利的一般是通过桌面或在线钱包，这让你能轻松地转移以太币。最安全的则是通过冷存储或纸质存储，这意味着生成私钥离线，并实际上将其保存在一张纸上。硬件钱包提供了另一种高安全性选择，在概念上与纸质钱包相似，因为它们可以被认为是在线下的。主要区别在于账户所有者将私钥存储在一个类似 USB 键的小型电子设备上。表 3.3 总结了不同的选项。

##### Table 3.3. 钱包类型及其特点

| 钱包类型 | 便利性 | 安全性 | 示例 |
| --- | --- | --- | --- |
| 桌面钱包 | 高 | 高 | 以太坊钱包，Exodus |
| 移动钱包 | 高 | 低 | Jaxx |
| 在线钱包 | 高 | 中 | MyEtherWallet, Coinbase, Kraken |
| 硬件钱包 | 中 | 非常高 | Trezor, Ledger Nano, KeepKey |
| 纸质存储 | 低 | 非常高 | EthAddress |

我提到过交易费用是以太币计价，但以一个叫燃气的东西来计算。我们来看看燃气是什么以及它和交易费用有什么关系。

#### 3.2.3. 燃气

燃气是以太坊平台上交易费用衡量单位。完成一笔交易所需的燃气量取决于执行交易时 EVM（以太坊虚拟机）花费的计算资源量。具体地说，这取决于交易过程中执行的具体低级 EVM 指令数量。表 3.4 提供了最常见 EVM 操作的燃气费用大概。

##### Table 3.4. 简单 EVM 操作的燃气费用

| 操作 | EVM 操作码 | 燃气费用 |
| --- | --- | --- |
| 加法、减法 | ADD, SUB | 3 |
| 乘法、除法 | MUL, DIV | 5 |
| 比较 | LT, GT, SLT, SGT | 3 |
| 从内存中加载单词 | MLOAD | 3 |
| 将单词存储到内存中 | MSTORE | 3 |
| 从存储中加载单词 | SLOAD | 200 |
| 将单词存储到存储中 | SSTORE | >5000 |
| 合约创建 | CREATE | 32000 |

交易执行以燃料单位计费的主要原因，以及间接以计算工作单位计费，是为了防止不良参与者通过可能想破坏网络的服务拒绝攻击（DoS）。要发起 DoS 攻击，恶意参与者必须向网络发送大量交易，每笔交易执行大量计算工作；例如，一个无限循环。这笔工作的燃料量会很高，并且必须以相应的高额以太币支付——几乎没有人会支付来破坏一个服务！

大多数智能合约开发 IDE 可以提供一个交易完成所需的总燃料量的概念。例如，在图 3.10 的截图中，你可以看到通过在输出面板上点击“详情”按钮获得的`SimpleCoin`合约的转移函数执行的燃料估算，该合约是来自第一章的最后部分。

##### 图 3.10\. `SimpleCoin`转移函数执行的成本

![](img/fig03-10_alt.jpg)

交易费用成本是根据此公式计算的：交易费用（以以太币计）= 消耗的燃料单位数 * 每单位燃料的价格（以以太币计）。让我们来分解一下：

+   当运行交易时，EVM 确定消耗的*燃料单位数*，这取决于在交易期间运行的代码的计算成本。

+   交易的发送者决定了*燃料单位的价格*（以以太币计）。价格越高，矿工将交易包含在他们正在处理的区块中的可能性就越大。矿工优先处理可能支付高费用的交易，因此如果一个交易预计会消耗相对较少的燃料，发送者将不得不设置一个相对较高的燃料价格以确保快速处理。

+   交易发送者为*交易应消耗的最大燃料量*设置了限制。这保护了发送者免受由于代码执行方式与预期不同而导致的意外高的交易成本；例如，如果开发者引入了一个导致无限循环的错误。这些限制应该相对接近完成交易所需的预估燃料量。

在交易执行期间，EVM 消耗其燃料。在交易结束时可能有两个结果：

1.  *交易成功完成*。在这种情况下，未使用的燃料将退还给发送者。

1.  *在交易完成之前，可用的燃料量结束了*。在这种情况下，EVM 抛出一个*燃料结束异常*，并且交易被回滚。

您可能想知道交易费用谁来支付。鉴于这两种交易结果中的任何一种，处理交易的矿工将收到费用。对于第一种结果，他们通过将交易包含在成功附加到区块链的新块中来赚取费用。对于第二种结果，即使 EVM 抛出异常，矿工仍会以以太币收取燃料费，并像往常一样收取相关交易费用。简而言之，成功的矿工通过铸造新以太币和从交易发送者那里获得交易费用来奖励。在以太坊平台的早期阶段，矿工的大部分利润来自于铸币。

#### 3.2.4. 调用和交易

账户通过两种类型的消息相互交互：调用和交易。

##### 调用

调用是通过不存储在区块链上的消息发送的，其执行具有以下特点：

+   它只能执行只读操作，这些操作不会改变区块链的状态。

+   它不消耗任何燃料，因此是免费的。

+   它是同步处理的。

+   它立即返回一个返回值。

+   它不允许将以太币转移给合约账户。

典型的调用是对合约成员变量的直接调用，包括映射，以及对所谓的*常量函数*的调用，这些函数不会改变合约状态。例如，当您检查 SimpleCoin 账户余额时，您进行了调用，这是您在第一章末开始构建的基本加密货币。

##### 交易

在第一章的 Dapp 动态视图中，我向您介绍的交易是通过在挖矿过程中序列化并存储在区块链上的消息发送的。它包含以下字段：

+   发送者地址

+   收件人地址

+   价值——转移以太币的数量（以 Wei 计），如果消息被用来转移以太币（可选）

+   数据——输入参数，以防消息被用作函数调用（可选）

+   开始燃料——用于消息执行的最大燃料量。如果超出此限制，EVM 将抛出异常并回滚消息状态。

+   数字签名——证明交易发送者的身份

+   燃料价格——交易发起者愿意支付的每单位燃料的价格，如燃料部分所述

您在执行 SimpleCoin 转账时执行了交易。交易的执行具有以下特点：

+   它可以执行写操作，改变区块链的状态。

+   它消耗燃料，必须用以太币支付。

+   它作为异步处理：通过挖矿执行，然后附加到新的区块链块上，然后在整个网络上广播。

+   它立即返回一个交易 ID，但不返回一个返回值。

+   它允许将以太币转移到合约账户中。（以太币的转移成为交易本身的一部分。）

到目前为止，您知道智能合约是在以太坊网络的每个节点上由 EVM 执行的。我将简要介绍 EVM 是如何工作的。

#### 3.2.5. 以太坊虚拟机

以太坊虚拟机（EVM）是一个基于栈的抽象计算机器，其目的类似于 Java 虚拟机（JVM）和.NET 公共语言运行时（CLR）。它使计算机能够运行以太坊应用程序，并具有两个内存区域：

+   *易失内存*，或简称为*内存*。这是一个字地址的字节数组，每次消息调用时都会分配给智能合约。读取访问 256 位字，而写入可以在 8 位或 256 位宽度上执行。

+   *存储*。这是一个键值存储，键和值都是 256 位宽。存储分配给每个账户，并持久化在区块链上。合约账户只能访问自己的存储。

EVM 操作码包括布尔、位 wise 和算术比较与跳转（条件性和无条件）操作。这些是处理合约创建和调用的主要操作码：

+   `CREATE`—这执行了新的合约实例的创建。

+   `CALL`—合约通过此操作符向自己或其他合约发送消息。

+   `DELEGATECALL`—此操作符允许调用合约向外部合约发送消息，但在调用者的上下文中执行相关代码。这个操作符特别适用于创建多个合约可以访问的共享代码库。

虚拟机是完全沙盒化的：合约不能访问网络或文件系统资源。它只能访问其他合约。深入解释 EVM 的设计超出了本书的范围。要理解其设计，最好的参考资料是 Gavin Wood 所谓的*黄色论文*：[`gavwood.com/paper.pdf`](http://gavwood.com/paper.pdf)。

至此，你已经巩固了你对智能合约的知识。现在该更进一步，通过适当的客户端连接到以太坊网络：Go Ethereum 客户端。

### 3.3. 使用 geth 连接到以太坊

在您开始安装客户端之前，我想给您更详细地介绍以太坊网络，我已经在第一章中开始介绍它。这将帮助您了解客户端所适配的更广泛的环境。

您已经知道以太坊网络是一个点对点（P2P）网络，这意味着没有中央主节点或服务器节点来协调它们。因此，所有节点彼此都是客户端。节点根据黄色论文中定义的预定义协议（Wire）以完全相同的方式工作和相互通信。这意味着所有节点必须能够将新的交易区块附加到区块链（如果启用了挖矿）并在网络中的区块传播时验证它们。

从实现角度来看，网络包含两类广泛的节点：

+   *矿工*—他们处理最新的交易，并将它们合并到区块链中，以交易费用和挖矿奖励（以以太币计）的形式作为成功执行共识算法的回报。在这种情况下，它们将合并后的区块传播到网络的其他对等体。因为这些节点生成新块，所以它们被认为是生产者（尽管从技术上讲，它们仍然也是消费者）。

+   *完整节点*—它们主要验证从邻近对等体接收到的区块的有效性，并将其传播到网络的其余部分。因此，它们被认为是消费者。

挖矿节点运行在优化处理交易、生成区块和有效执行工作量证明算法的客户端上，以相对频繁地获得奖励。像*ethminer*这样的挖矿实现已经用 C++编写，并使用 NVIDIA 的 CUDA 等 GPU 库。因此，它们在能够提供卓越性能的 GPU 硬件上运行。

另一方面，完整节点没有性能要求，因此已经用各种语言实现了标准客户端。表 3.5 总结了至今可用的主要客户端实现，按流行度排序，如 Ethernodes([`ethernodes.org/network/1`](https://ethernodes.org/network/1))所报告的。

##### Table 3.5. 以太坊客户端实现语言表

| 客户端 | 语言 |
| --- | --- |
| Go Ethereum (geth) | Go |
| Parity | Rust |
| Cpp-ethereum (eth) | C++ |
| 以太坊(J) | Java |
| Pyethapp | Python |
| ethereumjs-lib | JavaScript |
| Ruby 以太坊 | Ruby |
| 以太坊客户端 | 编程语言 |

每个客户端都带有控制台，其中一些还包括图形浏览器或钱包。在本书中，你将使用 Go Ethereum，也被称为 geth，这是最受欢迎的客户端，安装在超过 70%的网络节点上。

#### 3.3.1. 使用 geth 开始

Go Ethereum 网站的下载页面[`ethereum.github.io/go-ethereum/downloads/`](https://ethereum.github.io/go-ethereum/downloads/)显示了所有主要操作系统的版本：Android、iOS、Linux、MacOS 和 Windows。对于一些受支持的操作系统，可用的安装格式各不相同。例如，对于 Windows，你可以选择 32 位和 64 位版本，以及是否仅下载可执行文件（归档选项）或完整的安装程序（安装程序选项）。我选择了 64 位的 Geth & Tools 1.8.13 归档。

一旦你安装或解压了相关文件，就可以运行 geth 可执行文件。如果你已经打开了以太坊钱包，在启动 geth 之前关闭它，因为它们使用相同的端口号！如果你没有参数运行 geth，它将以完整模式与公共生产网络，也称为 MAINNET 同步，如图 3.11 所示的屏幕截图。

##### 图 3.11. geth 在启动时与 MAINNET 网络同步

![](img/fig03-11_alt.jpg)

在 geth 同步完整区块链（这可能需要数小时至数天，具体取决于您的硬件和互联网连接速度）之后，控制台将开始减慢速度，并实时显示区块添加到区块链。

|  |
| --- |

##### 注意

关于钱包，你可以以轻量级或快速模式同步 geth——例如，`C:\program files\geth>geth –-syncmode "light"`——如果你希望更快地启动（几分钟而不是几小时或甚至几天），并且不介意没有在本地下载完整区块链。

|  |
| --- |

你可以以两种方式与 geth 交互：

+   通过用户友好的 geth 交互式 JavaScript 控制台

+   通过低级别的基于 HTTP 的 JSON-RPC 调用

我将向您展示这两种技术。让我们从更简单的工具开始：交互式 JavaScript 控制台。

#### 3.3.2. geth 交互式控制台的第一印象

geth 带有一个接受 JavaScript 指令的交互式控制台。它隐式引用 Web3.js，这是 Web3 的 JavaScript 实现，是用于与 Ethereum 客户端交互的官方高级库。这个控制台在目的上类似于编程语言 IDE 的 read-eval-print 循环（REPL）控制台。我将在接下来的几章中详细介绍 Web3。现在，让我们快速了解一下。

首先，打开交互式控制台。您有两种可能的启动方式：

+   如果在同一台机器上没有运行任何 geth 客户端，使用 console 命令运行 geth 可执行文件：

    ```
    C:\program files\geth> geth console 
    ```

+   如果机器上已经运行了一个 geth 客户端，使用 attach 命令附加到运行中的 geth 进程：

    ```
    C:\program files\geth> geth attach ipc:\\.\pipe\geth.ipc
    ```

你有一个正在运行的 geth 进程，所以你会选择第二个选项。

|  |
| --- |

##### 注意

在这本书中，我假设你使用 Windows，因为超过 60%的 Ethereum 网络节点运行在这个操作系统上。因此，我将展示带有 Windows 命令提示符格式的 shell 命令。还要注意，在控制台成功执行指令后，你可能会在正确结果的前后看到*undefined*。你可以忽略它。

|  |
| --- |

##### 显示版本信息

首先，你可以向 console 查询版本信息。当打开 console 时，会隐式实例化一个名为 web3 的 Web3 对象，因此你可以通过输入

```
> web3.version
```

然后你会看到类似的内容

```
{
  api: "0.20.1",
  ethereum: "0x3f",
  network: "1",
  node: "Geth/v1.8.13-stable-225171a4/windows-amd64/go1.10.3",
  ...
```

正如你所看到的，version 属性是一个包含许多子属性的对象。如果你愿意，你可以具体查询 version 对象的个别属性：

```
> web3.version.api
```

你会看到类似的内容

```
"0.20.1"
```

因为控制台接受 JavaScript 指令，所以可以将为 Web3 属性和子属性的值分配给变量，然后通过 console 对象显示它们：

```
> var apiVersion = web3.version.api
> var nodeVersion = web3.version.node
> console.log('Api version: ' + apiVersion)
> console.log('Node version: ' + nodeVersion)
```

##### 检查连通性

你可以从 web3.net 对象获取一些客户端连通性信息。（你可以省略 web3 命名空间，因为它隐式引用。）如果你输入

```
> net
```

你会看到类似的内容

```
{
  listening: true,
  peerCount: 2,
  version: "3",
  getListening: function(callback),
  getPeerCount: function(callback),
  getVersion: function(callback)
}
```

至于版本对象，你可以直接访问 net 对象的个人属性，如下所示：

```
> console.log('this geth instance is listening for network connections : ' +
     web3.net.listening)
> console.log('number of peers connected to this geth instance: ' +
     web3.net.peerCount)
```

如果你想获取关于你的节点更详细的信息，你可以使用 web3.admin 对象并调用：

```
> admin.nodeInfo
```

你会看到类似的结果：

```
{
  enode: "enode://90946319e42ef4d4670c1d7...,
  id: "90946319e42ef4d467...,
  ip: "::",
  listenAddr: "[::]:30303",
  name: "Geth/v1.8.13-stable-225171a4/windows-amd64/go1.10.3",
  ...
```

`peers`属性为你提供了关于你连接到的对等节点的详细信息：

```
> admin.peers
```

会产生类似的结果：

```
 [{
    caps: ["eth/62", "eth/63"],
    id: "0b64924d478abaf6900ffe...,
    name: "Geth/v1.6.1-stable-021c3c28/linux-amd64/go1.8.1",
    network: {
      localAddress: "192.168.1.108:53557",
      remoteAddress: "136.144.129.222:30303"
    },
...
```

##### 访问区块链

`web3.eth`对象检索有关客户端和区块链的实时信息。看看当前运行的 geth 进程的控制台。你应该看到新块如何实时地附加到区块链上。注意最近附加的块的区块号码，然后切换回 JavaScript 控制台。

你可以通过`eth.blockNumber`属性获取最新的区块号码：

```
> var latestBlockNum = eth.blockNumber
> console.log('Latest block #: ' + latestBlockNumber)
```

然后，你可以通过调用显示关于这个区块的摘要信息：

```
> eth.getBlock(latestBlockNum)
```

你会看到类似的结果：

```
{
  difficulty: 64344784,
  extraData: "0xd7830106078467657...,
  gasLimit: 4723091,
  gasUsed: 262264,
  hash: "0x8196edb66315b460f0bd4b9bdfa884...,
  nonce: "0x2ac78a350ec95787",
  number: 1732206,
...
```

你也可以深入到交易级别。你可以这样获取存储在最新区块中的第一个交易：

```
> eth.getTransactionFromBlock(latestBlockNum, 0)
```

你会看到类似的结果：

```
{
  blockHash: "0x8196edb66315b460f0bd4b9bdfa88...,
  blockNumber: 1732206,

  from: "0x392fd4954de442bb6c4d57f1923b4708642d3408",
  gas: 210000,
  gasPrice: 120000000000,
  hash: "0x4eb5ae8d7b7919f92d1dd02fcc407d6...",
...
```

我鼓励你查看整个`eth`对象的内容：

```
> eth
```

##### 执行以太币转换

Web3 API 提供了一些有用的函数，将任何以太坊货币单位从/转换为 Wei。你可以将 Wei 金额转换为特定的货币单位：

```
> var amountInWei = 12000000
> var amountInSzabo = web3.fromWei(amountInWei, 'szabo')
> console.log(amountInWei + ' Wei is equivalent to '  + amountInSzabo + '
     szabo')
12000000 Wei is equivalent to 0.000012 szabo
```

并且你可以将特定的货币单位转换为 Wei：

```
> var amountInEther = 12
> var amountInWei = web3.toWei(amountInEther, 'Ether')
> console.log(amountInEther + ' Ether is equivalent to '  + amountInWei + '
      Wei')
12 Ether is equivalent to 12000000000000000000 Wei
```

#### 3.3.3. JSON-RPC 的第一次亮相

现在你已经学会了 JavaScript 控制台的基础知识，你可以尝试通过执行几个 JSON-RPC 调用与 geth 交互。geth 提供了一个远程过程调用（RPC）接口，允许你访问节点的功能和区块链数据，比 Web3 API 提供的控制程度要细。实际上，Web3 是建立在 RPC 层之上的，这是以太坊平台暴露的最低级别的 API，如图 3.12 所示。

##### 图 3.12. 通过 Web3.js 和 JSON-RPC 访问 geth 的比较

![](img/fig03-12_alt.jpg)

RPC 接口是根据 JSON-RPC 2.0 标准设计的，因此它以 JSON 格式发送和接收数据。你可以在侧边栏找到更多关于 JSON-RPC 的信息。

如果你想直接通过 JSON-RPC 与 geth 通信，你必须做两件事：

1.  停止任何在标准操作系统命令行或 geth 控制台中运行的 geth 实例。

1.  使用`--rpc`和`--rpcapi`选项以 RPC 模式启动 geth：

    ```
    C:\program files\geth>geth --rpc --rpcapi "eth,net,web3,personal"
    ```

当你以 RPC 模式启动 geth 时，它可以通过一个 HTTP 服务器来访问，该服务器接受 HTTP 请求，默认情况下在：

```
http://localhost:8545
```

|  |
| --- |

**JSON-RPC**

JSON-RPC 是一种轻量级的远程过程调用，使用 JSON 作为数据格式。

您通过向服务器发送一个请求对象来调用 RPC，通常是通过 HTTP，或者以其他方式，如套接字甚至是消息传递，因为传输层不是协议的一部分。

请求对象必须包含以下成员：

+   `jsonrpc`—这设置了协议版本，目前为 2.0。

+   `method`—要调用的远程过程的名称。

+   `params`—包含过程参数的数组。

+   `id`—一个调用标识符，通常是一个字符串或整数。它必须不为空。

服务器处理调用后，会回复一个响应对象，其中包含以下成员：

+   `jsonrpc`—这设置了协议版本，目前为 2.0。

+   `result`—如果响应成功，此字段存在；如果出现错误，则不包括。

+   `error`—如果出现错误，此字段存在；如果响应成功，则不包括。

+   `id`—与请求中指定的相同。

|  |
| --- |

你会使用 cURL 控制台命令对 geth 的 HTTP 服务器执行 JSON-RPC 调用。为了让你了解 Web3 API 与 JSON-RPC API 之间的差异，我将展示如何通过 cURL 执行你在 Web3 交互式控制台中执行的相同操作。

|  |
| --- |

##### 注意

cURL 可以在包括 Windows（版本 7 和 10）和 Linux 在内的多数操作系统中使用。另外，如果你更喜欢，你可以从互联网上下载 cURL 的开源版本，或者通过图形工具（如 Postman）执行 HTTP 请求。

|  |
| --- |

##### 显示版本信息

你可以用这个调用获取关于 geth 客户端的版本信息：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":2
3} http://localhost:8545

{"jsonrpc":"2.0","id":23,"result":"Geth/v1.6.5-stable-cf87713d/windows-
amd64/go1.8.3"}
```

（如果你在 Windows 上使用，你必须转义 JSON 中的双引号，如边栏中所解释。）结果等价于你从 `web3.version.node` 得到的结果。

|  |
| --- |

**Windows 上的 cURL JSON 转义**

cURL 操作必须在 JSON POST 数据中转义双引号符号 "，在 Windows 的某些版本中。例如，在 Windows 的命令提示符中，你这样执行请求：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"i
d\":23} http://localhost:8545
```

而在 Linux 中：

```
$curl -H "Content-Type: application/json" -X POST --data
'{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":23}'
http://localhost:8545
```

|  |
| --- |

##### 检查客户端连通性

你可以通过执行几个调用来获取连通性信息。例如，要检查客户端是否正在积极监听网络连接，你必须执行这个请求：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"net_listening\",\"params\":[],\"id\":23}
http://localhost:8545
```

然后你会得到

```
{"jsonrpc":"2.0","id":23,"result":true}
```

结果等价于 `web3.net.listening`。

为了获取与客户端连接的节点数量，你必须执行这个调用：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":23}
http://localhost:8545
```

然后你会得到

```
{"jsonrpc":"2.0","id":23,"result":"0x6"}
```

结果，其中包含以十六进制格式编码的数字，如边栏中所解释，等价于 `web3.net.peerCount`。

|  |
| --- |

**通过 JSON-RPC 的数字**

以太坊的 JSON-RPC 接口处理数字的方式与官方 JSON-RPC 2.0 规范不同。通过 JSON-RPC 发送和返回的数字必须以十六进制格式编码。这样做可以确保每个客户端实现适当地解析和处理大数字，而不依赖于客户端编写语言对大数字的支持。

十六进制编码应包括 0x 前缀，至少有一个有效数字，没有前导零，如所示：

```
0x4d2            *1*
```

+   ***1*** **这等同于十进制的 1234。**

以下是一些数字应该编码为十六进制格式的例子：

| 十进制格式 | 十六进制格式 |
| --- | --- |
| 0 | 0x0 |
| 9 | 0x9 |
| 1234 | 0x4d2 |

以下是一些错误编码数字的例子：

| 错误的十六进制编码 | 原因 |
| --- | --- |
| 0x | 在 0x 前缀后没有指定数字。 |
| 42d | 没有指定 0x 前缀。 |
| 0x042d | 不允许前导 0 数字。 |
|  |

##### 访问区块链

你可以这样获取区块链的最新区块号：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":23}
http://localhost:8545
```

然后你会得到

```
{"jsonrpc":"2.0","id":23,"result":"0x1a705d"}
```

一旦你获得了最新的区块号，你可以通过调用（用`result`中的区块号替换`params`中的区块号）来检查它：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"0x1a70
5d\",true],\"id\":23} http://localhost:8545
```

然后你会得到

```
{"jsonrpc":"2.0","id":23,"result":{"difficulty":"0x3e37031","extraData":"0xd6
      83010700846765746885676...","gasLimit":"0x47e7c4","gasUsed":"0x323db6","
      hash":"0x0d6ae4b07a731834f5ca0d18859...",...
"miner":"0x22d1d502356c1c2d...","nonce":"0x3b886846920d3c81","number":"0x1a70
      5d","parentHash":"0x90fbbacbf8945fb8d4..."
...
```

然后你可以以与在 Web3 中通过交互式控制台相同的方式检查检索到的区块中的第一个交易（再次，将你在`results`中获得的区块号放入`params`中）：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockNumberAndIndex\",\
"params\":[\"0x1a705d\",\"0x0\"],\"id\":23} http://localhost:8545
```

然后你会得到

```
{"jsonrpc":"2.0","id":23,"result":{"blockHash":"0x0d6ae4b07a731834f5ca0d1885.
..","blockNumber":"0x1a705d","from":"0xcaf4a30e5fef5c0a...","gas":"0x47b760",
"gasPrice":"0x1bf08eb000","hash":"0x9acf62392d266086ec8..."
...
```

结果对象与 Web3 `eth.getTransactionFromBlock`调用返回的对象类似。

在本书的剩余部分，你将主要通过 Web3.js 与 geth 交互，但偶尔我也会展示如何使用 JSON-RPC 执行等效操作。如果你对学习更多关于 JSON-RPC API 感兴趣，请查阅其维基百科：[`github.com/ethereum/wiki/wiki/JSON-RPC`](https://github.com/ethereum/wiki/wiki/JSON-RPC)。

#### 3.3.4. 使用 geth 控制台挖矿

在介绍以太坊客户端的章节中，在提到如何通过客户端进行挖矿之前，你无法认为这个部分已经完整。你已经在本书的开头通过以太坊钱包进行了一些挖矿，以将以太币加载到你的测试账户中。

正如你所想象的，通过钱包执行操作隐藏了底层发生的事情。例如，你是否问过自己为什么你挖到的以太币被分配给了 account1？这是因为*etherbase*账户，与挖矿线程关联的账户，默认设置为`eth.accounts[0]`。但是，在重新启动 geth 并以附加模式重新打开 geth 控制台（就像你之前做的那样，如果你关闭了它），如果你愿意，你可以通过隐式实例化的`miner`对象将 etherbase 账户重新配置为`eth.accounts[1]`，如下所示：

```
C:\program files\geth> geth attach ipc:\\.\pipe\geth.ipc

> miner.setEtherbase(eth.accounts[1])
```

无论你的 etherbase 账户是`eth.accounts[0]`还是你已经重新配置为`eth.accounts[1]`，你都可以按照以下方式开始挖矿：

```
> miner.start()
```

在这一点上，你机器的 CPU 将几乎达到 100%。然后你可以停止挖矿：

```
> miner.stop()
```

在你挖到一些以太币的极不可能的情况下，现在这些以太币将被分配到你的`eth.accounts[1]`，如果你决定不重新配置，那么就会分配到`eth.accounts[0]`。

当你用`miner.start()`在 geth 交互窗口启动挖矿时，你可能会注意到类似以下内容的输出：

```
INFO [09-29|18:08:23] Imported new chain segment               blocks=1
     txs=20  mgas=4.401   elapsed=25.066ms  mgasps=175.592 number=1732751
     hash=fa5a62...050eb5
INFO [09-29|18:08:25] Updated mining threads                   threads=0
INFO [09-29|18:08:25] Transaction pool price threshold updated
     price=18000000000
INFO [09-29|18:08:25] Starting mining operation
INFO [09-29|18:08:25] Commit new mining work                   number=1732752
     txs=5   uncles=0 elapsed=7.017ms
INFO [09-29|18:08:27] Generating DAG in progress               epoch=57
     percentage=0 elapsed=922.455ms
INFO [09-29|18:08:28] Generating DAG in progress               epoch=57
     percentage=1 elapsed=1.846s
INFO [09-29|18:08:29] Generating DAG in progress               epoch=57
     percentage=2 elapsed=2.772s

INFO [09-29|18:08:30] Generating DAG in progress               epoch=57
     percentage=3 elapsed=3.753s
INFO [09-29|18:08:31] Imported new chain segment               blocks=1
     txs=0   mgas=0.000   elapsed=6.016ms   mgasps=0.000   number=1732752
     hash=c98db8...2d044c
INFO [09-29|18:08:31] Commit new mining work                   number=1732753
     txs=6   uncles=0 elapsed=22.058ms
INFO [09-29|18:08:31] Generating DAG in progress               epoch=57
     percentage=4 elapsed=4.724s
INFO [09-29|18:08:31] Imported new chain segment               blocks=1
     txs=5   mgas=3.693   elapsed=21.056ms  mgasps=175.370 number=1732752
     hash=f4432f...8bae81
```

你可能会想知道 DAG 是什么，以及为什么计算它需要这么长时间。DAG 代表有向无环图，它是构成*Ethash*的数据结构，Ethash 是 Ethereum 平台上的工作量证明（PoW）挖矿算法。DAG 需要相对较多的内存，因此 Ethash 被认为是内存密集型的 PoW 算法。它进而鼓励通过通用硬件进行挖矿，比如 GPU 芯片集（在边栏中解释更多）。

挖矿是一个专业性很强的主题，超出了本书的范围。如果你对 Ethash 更感兴趣，我鼓励你查阅官方笔记，地址为[`mng.bz/WaOw`](http://mng.bz/WaOw)。

既然你已经亲身体验了挖矿，你可能要问自己，如果你有幸将一个新区块添加到区块链上，在您的 etherbase 账户中获得相关的以太币奖励，然后决定通过关闭节点来退出您的挖矿活动，会发生什么。您创建并添加到区块链上的区块是否仍然有效，即使您已经从网络上消失了呢？区块中包含的交易是否仍然有效？您是否仍然能够将您 etherbase 账户中的以太币转移到另一个账户？

回答这些问题，答案都是肯定的。记住，区块链验证过程，由所有活跃的全节点持续执行，只关心一个区块散列和生成该区块的矿工的公钥地址之间的加密一致性，正如它关心一个交易散列和生成该交易账户的公钥地址之间的一致性一样。所以，一个创建新区块的节点是活跃还是不活跃，对于区块（和交易）历史来说，就像你在将一些以太币从你的桌面以太坊钱包的一个账户转移到另一个账户之后，你的电脑是开还是关一样无关紧要。

|  |
| --- |

**GPU 挖矿**

如果你想尝试运气，希望通过 CPU 挖矿在公共生产网络上生成以太币，就像你在测试网络上所做的那样，我不得不告诉你，你通过中彩票致富的可能性更大。正如你在第一章所见，PoW 算法的执行只有在组合了区块信息和随机数（nonce）后获得的散列具有某些特性时才是成功的——例如，前面有大量零。PoW 算法设计得如此复杂，以至于你必须尝试数百万个 nonce 值，才能找到那个幸运值，生成有效的散列。因此，成功挖矿意味着能够比其他矿工每秒生成更多的散列。

拥有最佳的 CPU 芯片组，你将能够最多生成 1 兆哈希每秒（Mh/s），其中兆哈希意味着一百万个哈希值。拥有良好的 GPU 芯片组，你可能会能够生成高达 30 Mh/s——几乎是标准 CPU 哈希能力的 30 倍。同时考虑挖矿池，这是一种组织，将各种 GPU 矿工聚集在一起，共享资源和奖励，它们能够生成高达 30 Th/s（每秒 30 万亿个哈希值），这意味着在相同时间内，CPU 能够生成的哈希值的 3000 万倍。最后，在以太坊领域，大约有 40 个挖矿池的哈希率在 30 Gh/s 到 30 Th/s 之间。

现在你可以理解为什么仅使用 CPU 生成以太币的几率很小。你可能会对这一严酷的现实感到失望，甚至可能会认为挖矿池在挖矿过程中的巨大影响可能会对以太坊的去中心化信誉带来疑问。许多以太坊参与者认为，只要许多挖矿池相互竞争，去中心化就应得到保证。同时考虑正在实施的新共识算法——工作量证明（Stake of Work），在前一章中介绍，可能会完全改变以太坊网络中权力的集中（或希望分散）方式。以下是不同硬件可以达到的哈希率的快速摘要：

| 硬件 | 哈希率 |
| --- | --- |
| 单核 CPU | 1 Mh/s |
| 单 GPU | 30 Mh/s |
| GPU 挖矿机 (10 个 GPU) | 300 Mh/s |
| 挖矿池 | 30,000,000 Mh/s |
|  |

#### 3.3.5 其他客户端

尽管 Go Ethereum 是最受欢迎的客户端，但其他实现（相对于 geth）在各种方面提供了不同的好处：

+   **Parity** 是用 Rust 编写的第二大受欢迎的以太坊客户端，被认为是最快、最轻、最安全的实现。它带有控制台和内置钱包。

+   **cpp-ethereum** 是用 C++ 编写的，被称为 **eth**，是另一种快速的实现，受欢迎程度排名第三，因其便携性而受到好评。**Ethminer** 是一个专门的挖矿客户端，是 cpp-ethereum 的一个分叉。

+   **pyethapp** 是由 Python 编写而成的，它基于两个核心组件：**pyethereum** 为用户提供以太坊虚拟机、区块链和挖矿功能，而 **pydevp2p** 支持对 P2P 网络的访问和节点发现机制。Python 开发者特别欣赏这一实现，因为其扩展性非常好。

在本章结束之前，你将加深对账户的理解，这是你必须熟悉才能有效地与以太坊工作的关键概念。

### 3.4 使用 geth 管理账户

在本章开头，当我介绍智能合约时，我简要地提到了账户。我还帮助你通过以太坊钱包用户界面创建了一些账户，这样你就可以用它们来转账一些以太币。有了 geth 控制台，你现在可以通过编程方式创建和与账户互动，从而加深对账户的理解。

#### 3.4.1. 以太坊账户

正如你所知，以太坊平台支持两种类型的账户：

+   外部所有账户（EOAs）—这些账户模仿最终用户，以及矿工和自主代理。

+   合约账户—这些账户模仿合约。

对于本章剩下的部分，我们将只处理 EOAs，我将称之为*账户*。

与大多数区块链系统一样，以太坊平台的安全性基于公钥加密。因此，一个账户由私钥/公钥对来标识。账户地址由公钥的最后 20 个字节表示。

与账户关联的私钥/公钥对存储在一个文本*密钥文件*中。公钥以明文形式可见，而私钥则用创建账户时引入的密码加密。账户密钥文件在 Ethereum 节点的数据目录中的*keystore*文件夹内：

+   Windows：C:\Users\username\%appdata%\Roaming\Ethereum\keystore

+   Linux：~/.ethereum/keystore

+   苹果系统：~/Library/Ethereum/keystore

|  |
| --- |

##### 提示

强烈建议你定期备份 keystore 文件夹，并将你在创建每个账户时引入的密码保存在安全的地方。如果我一直纠缠这个问题，请见谅，但如果你还没有注意到，我想强调在区块链世界中键和密码细节是多么敏感！

|  |
| --- |
|  |

**账户可移植性**

你不能在测试网络上使用你在公共生产网络上创建的账户，例如 Ropsten，反之亦然。这是因为每个网络的 keystore 不同，并且位于 Ethereum 文件夹内的单独文件夹中：

+   主生产网络密钥文件：~/.ethereum/keystore

+   Rinkeby 测试网络密钥文件：~/.ethereum/rinkeby/keystore

+   Ropsten 测试网络密钥文件：~/.ethereum/testnet/keystore

|  |
| --- |

你可以通过四个不同的途径创建账户并与其互动：

+   正如你在本章早些时候看到的以太坊钱包

+   geth 命令

+   在 geth 控制台上的 Web3

+   JSON-RPC 调用

你已经看到了如何使用以太坊钱包管理账户。在接下来的几节中，你将通过 geth 命令和 geth 控制台管理账户。你还将快速了解如何通过 JSON-RPC API 对账户执行一些操作。

#### 3.4.2. 使用 geth 命令管理账户

你可以通过输入特定于 geth 命令的操作系统的控制台轻松地管理一个账户，这些命令从 geth 可执行文件的目录中进入（或者如果 geth 在你的 PATH 全局变量中的任何目录中）。

##### 创建新账户

你可以手动创建一个新账户，或者使用一个纯文本文件：

1.  手动创建

    1.  要以新账户的身份登录，请输入

        ```
        C:\program files\geth>geth account new 
        ```

    1.  您将被要求输入密码两次，然后您将看到您创建的账户的地址：

        ```
        Your new account is locked with a password. Please give a password.
          Do not forget this password.
        Passphrase:
        Repeat passphrase:
        Address: {47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1}
        ```

    |  |
    | --- |

    ##### 提示

    养成选择强密码或通过强密码生成器生成密码的习惯。我在重复自己；我知道，我知道！但这是重要的，相信我！

    |  |
    | --- |

1.  文本文件创建

    1.  为了避免必须手动输入密码，您可以将其以纯文本形式存储在文本文件中。

    1.  如下执行 geth 账户命令：

        ```
        C:\program files\geth>geth --password passworddirectory/passwordfile
           account new 
        ```

|  |
| --- |

##### 提示

正如您所理解的，尽管在测试环境中将密码放在纯文本文件中可能是可以接受的，但这种创建账户的方式在生产环境中可能带来更大的风险，您必须确保密码文件的访问受到严格的限制。

|  |
| --- |

##### 列出账户

一旦您创建了一个账户，您可以通过执行以下命令来验证它确实存在于您的节点中：

```
C:\program files\geth>geth account list 
```

您将通过 geth 账户命令和 geth 控制台看到您创建的账户：

```
Account #0: {edde06bc0e45645e2f105972bdefc220ed37ae10}
     keystore://C:\Users\rober\AppData\Roaming\Ethereum\keystore\UTC--2017-
     06-24T08-49-46.377533700Z--edde06bc0e45645e2f105972bdefc220ed37ae10
Account #1: {4e6c30154768b6bc3da693b1b28c6bd14302b578}
     keystore://C:\Users\rober\AppData\Roaming\Ethereum\keystore\UTC--2017-
     06-24T13-26-18.696630000Z--4e6c30154768b6bc3da693b1b28c6bd14302b578
Account #2: {70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02}
     keystore://C:\Users\rober\AppData\Roaming\Ethereum\keystore\UTC--2017-
     06-24T18-21-36.890638200Z--70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02
Account #3: {c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4}
     keystore://C:\Users\rober\AppData\Roaming\Ethereum\keystore\UTC--2017-
     06-24T18-21-47.794428600Z--c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4
...
```

##### 更新账户

在 geth 创建并在 keystore 文件夹中的 keyfile 中保存账户后，随后的 geth 版本可能会实现新的 keyfile 格式。在这种情况下，更新账户变得必要。您想要更新账户的其他原因可能是您想要更改密码。

您可以使用以下 geth 命令更新您之前创建的账户 47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1 （显然用您的账户号码替换）：

```
C:\program files\geth>geth account update
     47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1
```

您将被迫输入现有的密码以解锁账户，然后输入一个新的密码，您必须像往常一样再次输入。然后，您将看到账户的新地址：

```
Unlocking account 47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1 | Attempt 1/3
Passphrase:
INFO [09-30|08:36:25] Unlocked account
     address=0x47e3d3948f46144afa7df2c1aa67f6b1b1e35cf1
Please give a new password. Do not forget this password.
Passphrase:
Repeat passphrase:
```

geth 账户更新命令提供了与 geth 账户新命令相同的 `--password` 选项。但在此情况下，您还可以使用它来解锁账户，以便将其转换为新 keyfile 格式。

#### 3.4.3. 使用 geth 控制台管理账户

让我们通过交互式控制台重复一些早期的账户管理操作。

##### 创建新账户

回到交互式 geth 控制台。您可以使用 `web3.personal` 对象创建账户：

```
> personal.newAccount()
```

至于 geth 账户命令，您将被要求输入密码两次，然后您将看到账户地址：

```
Passphrase:
Repeat passphrase:
"0x70ff99d4bc8054b2e09269bcbfdddf8e1ae7d155"
```

##### 列出账户

您可以使用交互式控制台列出账户，通过显示 `web3.eth` 对象的 `account` 属性值。您将获得与使用 geth 账户列表命令获得的相同结果集：

```
> eth.accounts
```

会产生类似的内容

```
["0xedde06bc0e45645e2f105972bdefc220ed37ae10",
     "0x4e6c30154768b6bc3da693b1b28c6bd14302b578",
     "0x70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02",
     "0xc99048e9b98d3fcf8b5f0d5644794b562f9a2ea4", 
...
```

您还可以直接引用 `eth.accounts` 数组中的特定账户：

```
> eth.accounts[0]
```

这将产生类似的内容

```
"0xedde06bc0e45645e2f105972bdefc220ed37ae10"
```

##### 检查账户的以太币余额

您可以使用以下调用检查账户中存储的以太币量，它以 Wei 返回：

```
> var balanceInWei = eth.getBalance(
"0x407d73d8a49eeb85d32cf465507dd71d507100c1")
```

然后您可以像往常一样将其转换为以太币：

```
> var balanceInEther = web3.fromWei(balanceInWei, "Ether")
```

##### 在账户之间转移以太币

你可以尝试从`accounts[1]`向`accounts[2]`转账 0.0025 以太币。首先，检查一下这两个账户当前的余额，就像你之前看到的那样：

```
> var balanceAcc1 = eth.getBalance(eth.accounts[1]);
> var balanceAcc2 = eth.getBalance(eth.accounts[2]);
> console.log('Balance account 1: ' + balanceAcc1 + '; Balance account 2: ' +
     balanceAcc2);
Balance account 1: 1938331059000000000; Balance account 2:
     1000741600000000000
```

在从某个账户，例如`accounts[1]`，转账以太币之前，你必须解锁它：

```
> personal.unlockAccount(eth.accounts[1]);
```

像往常一样，系统会要求你输入与这个账户关联的密码：

```
Unlock account 0x4e6c30154768b6bc3da693b1b28c6bd14302b578
Passphrase:
true
```

然后，你可以使用 web3.eth.sendTransaction 函数在账户之间转账以太币，该函数需要以 Wei 为单位指定金额，如下所示：

```
> var sender = eth.accounts[1];
> var recipient = eth.accounts[2];
> var amount = web3.toWei(0.0025, "Ether");
> eth.sendTransaction({from:sender, to:recipient, value: amount});
"0xf1c342c668bcd1d59f3e95cfaf08acc6d7cda8adae02da05ceb76c8c3c137eef"
```

返回的值是发送的交易哈希。

几分钟后，重新检查一下余额：

```
> console.log('Balance account 1: ' + eth.getBalance(eth.accounts[1]) + ';
      Balance account 2: ' + eth.getBalance(eth.accounts[2]));
Balance account 1: 1933311059000000000; Balance account 2:
     1003241600000000000
```

如果余额还没有更新，那是因为交易还没有被矿工挖出。

#### 3.4.4. 使用 JSON-RPC 管理账户

我将给你一个关于如何使用 JSON-RPC 执行账户管理操作的快速示例。打开一个新的操作系统终端，你可以使用以下 JSON-RPC 调用来列出你的账户：

```
C:\>curl -H "Content-Type: application/json" -X POST --data
{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":23}
http://localhost:8545
```

这将得到类似的结果：

```
{"jsonrpc":"2.0","id":23,"result":"0xedde06bc0e45645e2f105972bdefc220ed37ae1
0","0x4e6c30154768b6bc3da693b1b28c6bd14302b578","0x70e36be8ab8f6cf66c0c953cf9
c63ab63f3fef02","0xc99048e9b98d3fcf8b5f0d5644794b562f9a2ea4",...
```

### 3.5. 重新审视 SimpleCoin 合约

在这章中我们已经覆盖了相当多的内容。如果你一直跟到现在，恭喜你：你已经完成了以太坊的入门，涵盖了以太坊钱包和 Go Ethereum 客户端。你也以许多方式开始与这个平台互动——通过 geth 命令，通过 get Interactive console 上的 Web3 指令，以及通过直接的 JSON-RPC 请求。

这真是一次紧张的旅程。我敢打赌你迫不及待想要回到编码中了！让我们重新审视一下你在[第一章末尾介绍的 SimpleCoin，这个基础加密货币，并尝试改进它。

重新输入你在上一章看到的`SimpleCoin`代码到 Remix 中，如下所示列表。像往常一样，暂时忽略警告：随着你在接下来的章节中改进代码，它们会消失。

##### 列表 3.1. `SimpleCoin`合约，就像你在第一章中留下的那样

```
pragma solidity ⁰.4.0;   

contract SimpleCoin {   

  mapping (address => uint256) public coinBalance; 

  constructor() public { 
    coinBalance[0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C] = 10000;   
  }

  function transfer(address _to, uint256 _amount) public { 
    coinBalance[msg.sender] -= _amount;
    coinBalance[_to] += _amount;
  }
}
```

这段代码很基础。即使你还不了解 Solidity 语言，你也可以看到构造函数中有一个硬编码的值和一个`transfer`函数中缺乏输入验证。你可以通过几种方式改进代码。首先，你可以参数化构造函数，这样初始货币供应就不会分配给任意测试账户的地址，而是分配给合约所有者账户的地址。然后，你可以在`transfer`函数中引入一些检查，以防止错误的转账。最后，你可以设置当代币被转账时触发一个事件，然后智能合约的客户端可以收到通知或对其作出反应。

#### 3.5.1. 改进 SimpleCoin 合约

你将改进构造函数和`transfer`函数。你可以从构造函数开始着手。

##### 参数化构造函数

将构造函数重写如下：

```
  constructor(uint256 _initialSupply) public {
    coinBalance[msg.sender] = _initialSupply;   
}
```

您已经遇到了特殊的属性`msg.sender`，其值是消息发送者的地址（或调用者）。当涉及到构造函数时，消息发送者是实例化合约的账户，从而成为其所有者。因此，当构造函数被调用时，`_initialSupply`参数中指定的代币数量将分配给合约所有者。

##### 使传输更加健壮

将传递函数重写如下列表所示。

##### 列表 3.2\. 一个更健壮的传递函数，带有输入检查

```
  function transfer(address _to, uint256 _amount) {
    require(coinBalance[msg.sender] >= _amount);      *1*
    require(coinBalance[_to] + _amount >= 
       coinBalance[_to]);                             *2*
    coinBalance[msg.sender] -= _amount;  
    coinBalance[_to] += _amount;         
}
```

+   ***1*** **检查发送者账户是否有等于或大于您试图转移的代币数量**

+   ***2*** **检查在传输操作期间接收者余额是否产生算术溢出。（如果余额因从发送者接收的金额而变得大于 uint256，这种情况可能会发生。）**

`require`特殊函数如果条件不满足就会抛出异常。您还可以直接使用`throw`关键字抛出异常，但这种验证输入的方式正在被弃用。例如

```
require(coinBalance[msg.sender] > _amount);
```

可以先前写为

```
if (coinBalance[msg.sender] < _amount) throw;
```

##### 引发事件

合约可以声明一个或多个事件，可以在其任何函数中引发。监视合约状态的客户端可以处理一个事件。例如，您可以声明一个事件，通知 SimpleCoin 代币的转移已经发生：

```
event Transfer(address indexed from, address indexed to, uint256 value);
```

您会在传输函数底部引发这个事件：

```
    function transfer(address _to, uint256 _amount) {
        ...

        emit Transfer(msg.sender, _to, _amount);  
    }
```

#### 3.5.2\. 尝试修改后的代码

修改后的`SimpleCoin`合约现在将如下列表所示。

##### 列表 3.3\. `SimpleCoin`具有参数化构造函数、输入验证和事件

```
pragma solidity ⁰.4.0;

contract SimpleCoin {
    mapping (address => uint256) public coinBalance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _initialSupply) public {
        coinBalance[msg.sender] = _initialSupply;   
    }

    function transfer(address _to, uint256 _amount) public {
        require(coinBalance[msg.sender] > _amount);
        require(coinBalance[_to] + _amount >= coinBalance[_to] );
        coinBalance[msg.sender] -= _amount;  
        coinBalance[_to] += _amount;   
        emit Transfer(msg.sender, _to, _amount);  
    }
}
```

##### 尝试使用修改后的构造函数

如果你关闭了 Remix，请重新打开它，并将列表 3.3 的代码复制到编辑器中。然后从交易源下拉列表中选择一个测试账户地址；例如，0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db。这将是要执行构造函数的账户，并且它将相应地成为合约所有者。

在右侧面板点击运行标签。现在您可以输入 SimpleCoin 代币的初始供应量，位于部署按钮旁边，比如 10,000，然后点击部署。像往常一样，`coinBalance`和`transfer`按钮将出现在屏幕的下方部分，如前章所示，如图 3.13 所示。

##### 图 3.13\. 部署操作现在接受构造函数输入。在点击部署实例化合约后，`CoinBalance`和`Transfer`按钮出现。

![](img/fig03-13_alt.jpg)

您可以在`coinBalance`映射中检查合约拥有者的地址余额。如预期的那样，你会得到 10,000。您还可以再次确认其他地址的余额为零，如表 3.6 所示。

##### 表 3.6\. SimpleCoin 账户的余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |
| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |
| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 10,000 |
| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |
| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 0 |

##### 尝试使用修改后的转账函数

尝试从一个没有代币的账户中转出一些 SimpleCoin 代币；例如，0x583031d1113ad414f02576bd6afabfb302140225。从交易起源的下拉列表中选择这个地址，并将以下以逗号分隔的值输入到转账文本框中：

```
"0xdd870fa1b7c4700f2bd7f44238821c26f7392148", 150
```

点击转账后，你会得到以下错误信息，多亏了你之前添加的`require`检查：

```
transact to browser/SimpleCoin.sol:SimpleCoin.transfer errored: VM error:
     invalid opcode.
  The constructor should be payable if you send value.
  The execution might have thrown.
  Debug the transaction to get more information.
```

现在尝试从合约所有者的账户向刚才的收款人转账 150 个代币。你需要在交易起源的下拉列表中选择以 0x4b0897b 开头的账户，并将以下以逗号分隔的值重新输入到转账文本框中：

```
"0xdd870fa1b7c4700f2bd7f44238821c26f7392148", 150
```

操作现在将成功完成，正如你在屏幕左侧的输出中看到的图 3.14 所示。

##### 图 3.14 成功转账操作的输出

![](img/fig03-14_alt.jpg)

如果你点击调试旁边的箭头，你可以在`logs`属性中验证，在函数调用结束时已经触发了转账事件：

```
[
  {
    "event": "Transfer",
    "args": [
      "0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2db",
      "000000000000000000000000dd870fa1b7c4700f2bd7f44238821c26f7392148",
      "150"
    ]
  }
]
```

重新检查所有余额后，结果应该与表 3.7 相匹配。

##### 表 3.7 SimpleCoin 账户的新余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 0 |
| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 0 |
| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 9,850 |
| 0x583031d1113ad414f02576bd6afabfb302140225 | 0 |
| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 150 |

恭喜你完成了这个练习！你所做的改进可能并不特别具有挑战性，但这些改进应该能帮助你更加熟悉智能合约。

#### 3.5.3 Ethereum 网络中代币转账是如何执行的？

你可能理解了执行代币转账的 Solidity 代码，但如果这个转账是在真实的 Ethereum 网络上进行的，而不是在 Remix JavaScript EVM 模拟器上，你知道它会在网络中的哪个部分执行吗？你知道 SimpleCoin 代币的转账会对区块链产生什么影响吗？通过查看图 3.15 中的图表，你可以得到这些问题的答案。我将其从图 1.8`函数时，创建了一个转账交易。然后它会在网络中被验证并传播，直到被挖矿节点包含在一个新的区块链块中。然后这个新块会在网络上传播，最后回到本地节点。

![](img/fig03-15_alt.jpg)

### 总结

+   以太坊钱包是一个 GUI，通过创建账户和直观地转移以太币来与平台交互。

+   最受欢迎的以太坊客户端是 Go Ethereum，也被称为 geth。它带有一个交互式控制台，引用 Web3.js，这是一个高级接口，用于与以太坊客户端交互。

+   例如，可以通过各种途径与 geth 交互：

    +   在操作系统命令行中执行 geth 命令

    +   在 geth 交互式控制台中执行 Web3.js 指令

    +   通过 cURL 或像 Postman 这样的 UI 工具执行 HTTP JSON-RPC 命令

+   以太坊智能合约，或简称*合约*，是用如 Solidity 这样的高级语言编写的，编译成 EVM 字节码，部署在以太坊网络上，并存储在区块链上。

+   可以通过调用、交易和事件与合约进行通信。交易涉及计算和网络资源的消耗，这些资源以称为燃料（gas）的单位计算，并以以太坊平台加密货币以太币（Ether）的形式结算。

## 第四章. 部署你的第一个智能合约

|  |
| --- |

**本章内容**

+   将合约部署到以太坊网络上

+   通过网络与合约交互

+   无节点合约部署和通过 MetaMask 的交互

|  |
| --- |

在前两章中，你开始构建 SimpleCoin，你的基本加密货币。你在 Remix IDE 中这样做，并通过基于 JavaScript 的 EVM 模拟器尝试其最小功能。这种体验有助于你从概念上理解智能合约的样子以及如何激活和与之交互。但 SimpleCoin 仍然看起来像是在 IDE 中运行的一段代码。现在你已经开始熟悉以太坊平台，你可能在想，“看到 SimpleCoin 在一个更真实的环境中运行难道不好吗？”本章你将做正好这件事。

你将把`SimpleCoin`合约部署到以太坊网络上，然后你将用几种不同的方式与之交互。首先，你将通过以太坊钱包进行，这需要你本地导入区块链的一个副本，然后你将通过 MetaMask 进行，MetaMask 是一个第三方工具，它允许你连接到以太坊网络，而无需访问以太坊客户端或钱包。

### 4.1. 将合约部署到网络上

你可能习惯了在服务器上部署集中式应用。例如，如果你曾经开发过一个网络应用，你可能最初在你的台式计算机上开发所有层次。然后，在应用成熟到足够用户或测试人员测试时，你将其组件部署到用户接受测试（UAT）环境中的一个或多个服务器上。一个网络应用的典型部署可能包括

+   一个托管静态和动态网页的网络服务器

+   一个或多个应用服务器，用于托管网页使用的服务

+   一个或多个数据库服务器，用于持久化服务使用的数据

去中心化应用的部署相当不同。即使是一个只包含一个智能合约的简单去中心化应用，如你的 SimpleCoin 应用，也会跨越整个以太坊网络进行部署。正如你在我在第二章中介绍的开发视图中所可能回忆到的，在第 2.1.3 节中，智能合约作为一种特殊的交易部署，其有效载荷是编译后的 EVM 字节码。你通过一个本地节点提交部署交易，该交易会传播到整个以太坊网络，直到它到达挖矿节点。只有当挖矿节点成功处理了包含合约 EVM 字节码的部署交易，并将新区块附加到区块链之后，智能合约才会被部署。正如图 4.1 所示，该区块随后会复制到整个以太坊网络。

你在网络上部署合约有两个选项：

+   通过以太坊钱包手动部署

+   通过 geth 的交互式控制台命令部署

##### 图 4.1\。用类似 Solidity 的高级语言编写的合约会被编译成 EVM 字节码，并通过包含合约 EVM 字节码的部署交易部署到网络上，该交易通过网络的本地全节点执行。部署交易会传播到整个网络；然后由挖矿节点处理，并包含在新的复制到整个网络的区块中。这就像任何其他交易一样，只不过存储在区块链上的是 EVM 字节码，而不是以太币或数据。

![](img/fig04-01_alt.jpg)

在这个章节，你将手动部署`SimpleCoin`合约。这样做，你将以一种视觉化和直观化的方式经历部署过程，这将帮助你快速学习。

一旦你习惯了通过以太坊钱包部署合约，你将准备好进行下一步：基于命令的部署。虽然一开始可能会有些令人畏惧，但通过 geth 控制台部署合约是一个有用的练习，因为它能帮助你更全面地理解平台。你将在接下来的几章中探索这个主题。现在，我会快速回顾你已经知道的内容：

+   *触发部署的机制*——你知道你可以通过以太坊钱包手动部署合约，或者使用 geth 控制台上的命令来部署合约。（你很快就会看到这些内容。）

+   *部署过程中会发生什么*——合约的字节码在其部署交易执行后存储在区块链上。

但以太坊网络究竟是什么呢？我在下一节回答这个问题。

#### 4.1.1\. 以太坊公共网络

当你在前一章中连接到以太坊时，你可能没有注意到你连接到了两个不同的网络：

+   你通过以太坊钱包连接到了*Ropsten*，这是一个公共测试网络。

+   从 geth 中，你连接到了*Mainnet*，这是一个公共生产网络。

*Ropsten*是以太坊提供的公共测试网络，基于工作量证明（PoW）挖矿，这是目前公共生产网络中使用的算法。如果你按照我给你的指示操作，你的以太坊钱包已经指向了 Ropsten 网络，并且你账户中只有通过 CPU 挖矿生成的假以太币。

如果你在前一章中让 geth 客户端一直运行，它现在指向的是*Mainnet*，即生产网络。在这个网络中账户间转移的以太币是真实的。你应只在此网络上对生产 Dapp 执行交易；在开发过程中应避免使用此网络。

还有一个名为*Kovan*的公共测试网络，它支持使用名为 Proof of Authority 的新算法进行挖矿。到目前为止，这只在 Parity 客户端实现，所以本书不涉及这部分内容。

在下一节中，你将通过钱包将`SimpleCoin`合约部署到 Ropsten 网络。因此，你暂时还不需要进行任何环境配置更改。

#### 4.1.2\. 使用以太坊钱包部署 SimpleCoin

启动以太坊钱包——确保同步模式是快速或完全同步，并等待它完全同步——然后通过点击顶栏附近的 Contracts 来打开合约屏幕。你会看到两个主要选项：

+   *部署新合约*——你可以通过提供其 Solidity 代码来部署新合约。

+   *观察合约*——你可以引用一个已经部署好的合约，以便与之交互。

点击部署新合约。当打开部署合约屏幕时，你可以决定哪个账户将成为合约所有者。选择账户 1，然后点击屏幕底部的 Solidity 合约源代码标签，并粘贴来自第三章末尾的`SimpleCoin`代码（确保构造函数和函数声明为*public*，以便在钱包中编译；我将在第五章解释函数访问修饰符，如 public）。

##### 列表 4.1\. `SimpleCoin`的最新版本（来自第三章）

```
pragma solidity ⁰.4.0;

contract SimpleCoin {
    mapping (address => uint256) public coinBalance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _initialSupply) public {
        coinBalance[msg.sender] = _initialSupply;   
    }

    function transfer(address _to, uint256 _amount) public {
        require(coinBalance[msg.sender] > _amount);

        require(coinBalance[_to] + _amount >= coinBalance[_to] );
        coinBalance[msg.sender] -= _amount;  
        coinBalance[_to] += _amount;   
        emit Transfer(msg.sender, _to, _amount);  
   }
}
```

粘贴代码后，钱包将其编译成 EVM 字节码，右侧会出现一个下拉列表。从列表中选择 Simple Coin，并将构造函数参数设置为 10000。最后，点击屏幕底部的部署按钮，如图 4.2 所示。

##### 图 4.2\. 输入合约的 Solidity 代码后，钱包将其编译成 EVM 字节码。提供合约参数，点击部署，新的对话框会确认部署交易。

![](img/fig04-02_alt.jpg)

一个新对话框将出现，如图 4.3 所示。系统会提示你输入密码并发送部署交易。记住：你的账户里需要有以太币才能提交交易！一旦你发送了部署交易，你可以在钱包主界面的最新交易部分检查其状态。在那里，你可以看到部署交易被当作任何其他交易处理。

##### 图 4.3\. 对话框要求你输入将部署合约的账户密码。提供后点击发送，将生成并发送部署交易到网络。

![](img/fig04-03_alt.jpg)

一旦合约收到了所有必要的网络确认，你可以在最新交易面板（见图 4.4）中查看。然后回到合约界面。你会看到 Simple Coin 以太币余额为零（见图 4.5）。

##### 图 4.4\. 合约交易提交给网络后，你可以在合约界面的最新交易面板中监控其网络确认。

![](img/fig04-04_alt.jpg)

##### 图 4.5\. 合约在收到 12 次确认后，这使得部署交易非常可能永久存储在区块链上，部署的合约将出现在合约面板上。

![](img/fig04-05_alt.jpg)

|  |
| --- |

##### 定义

*交易确认*表示交易在区块链中的深度。新区块在包含所查询交易的区块之后附加到区块链时，就会收到新的确认。随着确认次数的增加，区块撤销的概率呈指数级下降，所以交易在获得 12 次确认后被认为是稳定的。（这意味着在包含交易的区块之后添加了 12 个区块到区块链。）

|  |
| --- |

恭喜你！你在以太坊网络上部署了你的第一个合约。现在你可以像之前与 Remix 交互一样与合约交互。你可以从移动 SimpleCoin 代币并在账户之间验证预期余额开始。

### 4.2\. 与合约交互

在开始移动 SimpleCoin 代币之前，返回钱包主界面并添加两个更多账户。 （记住要记录相关的密码。）这些额外账户在测试合约操作时会很有用。我建议你将钱包中的所有账户地址复制到一个临时文本文件中。表 4.1 显示了我的情况会包含什么。

##### 表 4.1\. 以太坊钱包账户地址

| 账户名称 | 账户地址 |
| --- | --- |
| 主账户 | 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 |
| 账户 2 | 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 |
| 账户 3 | 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 |
| 账户 4 | 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 |
|  |

##### 提示

要复制一个地址，选择它，然后点击“复制地址”。或者，你可以使用常规的 Ctrl+C 快捷键。无论如何，钱包都会要求你确认是否要继续这个操作。（存在风险，恶意软件可能会替换地址。）

|  |
| --- |

现在回到合约界面并点击 SimpleCoin。在屏幕顶部， just below the name of the contract, 你将看到合约地址，这是合约在区块链中的账户地址。你会注意到与`SimpleCoin`合约相关的区域逻辑上分为两部分：左侧的“从合约读取”和右侧的“向合约写入”。这种布局与你在 Remix 中看到的只读功能（蓝色）和写入功能（红色）的颜色代码相似。

#### 4.2.1\. 检查币余额

你可以首先通过在每个账户的币余额文本框旁边输入每个账户的地址来检查所有账户的币余额。预期的余额显示在表 4.2 中。

##### 表 4.2\. 预期账户余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |
| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |
| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |
| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |

如果你尝试检查一个无效地址的余额会发生什么？例如，将主账户的最后一位（以 0xedDE06bC 开头）替换为 8 并尝试检查币余额。你不能输入这样的地址，因为钱包会认为其校验和无效。但是你可以输入任何有效的以太坊地址，即使它与你账户无关。（你可以从[`etherscan.io/`](https://etherscan.io/)拿一些来尝试。）

#### 4.2.2\. 转账币

现在你可以移动一些币。你可以从主账户向账户 3 转账 150 个 SimpleCoin。这是你在上一章中在 Remix 上执行的相同操作。在“写入合约”面板中的“选择函数”下拉菜单中选择“转账”。所有必要的币转账输入字段将出现，如图 4.6 所示。

从执行列表中选择主账户，然后在到字段中设置账户 3 的地址和 150 的金额。点击执行后，系统会要求你输入主账户的密码以数字签名交易。

如果你在最新事件面板中选择监视合约事件框，你很快就会看到你发送的交易详情。在此阶段，你可以重新检查所有地址的余额。预期的余额显示在表 4.3 中。

##### 表 4.3。预期的更新账户余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |
| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |
| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |
| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |

##### 图 4.6。检查 SimpleCoin 余额是一个只读操作，所以你只需要指定输入地址。转账硬币是一个写操作。如图所示，你必须指定要转动的硬币数量、目标地址和发送账户。

![](img/fig04-06_alt.jpg)

现在尝试从账户 3 移动 50 个硬币到账户 2，并在最新事件面板中出现交易后重新检查余额。你会注意到在执行从下拉列表中列出的唯一账户是主账户和账户 2。这是因为钱包不允许你从没有以太币的账户执行交易。

正如你在第二章看到的，执行账户必须支付以燃气计算但以以太币结算的交易费用才能执行交易。为了使账户 3 和 4 有用，你必须从主账户向他们发送一些以太币。你可以在发送屏幕上执行此以太币转账，正如你在上一章设置账户 2 时所做的那样。像往常一样，你可以在最新交易面板中监控以太币转账交易，并等待它们完成。一旦所有账户都拥有了一些以太币，你就可以执行交易了。

回到`SimpleCoin`合约屏幕，再次选择转账功能。执行从下拉列表现在将显示所有账户，所以你可以选择账户 3。在到文本框中输入账户 2 的地址，在金额字段中输入 50。点击执行后，系统会要求你输入账户 3（发送账户）的密码。交易确认后，重新检查余额。新预期的余额显示在表 4.4 中。

##### 表 4.4。第二次转账后更新的账户余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |
| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |
| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |
| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |

##### 尝试转让不可用的硬币

正如您将记得的，`SimpleCoin` `transfer`函数的代码在修改发送者和接收者地址的余额之前执行一些检查。它通过抛出错误防止账户尝试转账不存在的硬币。您可以通过钱包尝试这样做看看会发生什么。例如，尝试将 200 个硬币从账户 4 转移到账户 3。如预期所示，您将收到一个错误消息，指示交易将失败，如图 4.7 所示。

##### 图 4.7. 如果一个来自写操作的交易，如`SimpleCoin.transfer()`，未能通过验证检查，它不能发送到网络。

![](img/fig04-07_alt.jpg)

您可能会惊讶于错误信息甚至在交易发送之前就已经抛出。这是因为钱包在发送之前本地验证交易，就像任何节点都会做的那样。如果返回错误，钱包不会将交易传播到网络，并且您会立即收到错误消息。

干得好！您已经完全手动测试了`SimpleCoin`在公共测试网络上。

到目前为止，这一章已经向您展示了如何在不运行完整的以太坊节点的情况下将智能合约部署到公共网络的方法。您是通过以太坊钱包完成的，而在幕后，它仍然连接到一个完全同步的区块链副本。但是您可能想知道是否可以在没有本地同步的区块链副本的情况下实现相同的功能。答案是可以的。正如我们在下一节中将要探讨的，您可以连接到由名为 MetaMask 的 Chrome 插件公开提供的节点集。

### 4.3. 无节点通过 MetaMask 部署

*MetaMask* 是一个连接您到外部以太坊节点的 Chrome 扩展，如图 4.8 所示。它允许您将合约部署到公共网络并与之交互，而无需安装和维护任何以太坊软件。作为替代方案，如果您不想使用 Chrome，可以下载 Brave 浏览器并作为扩展安装 MetaMask。对于不经常开发智能合约且不想每次恢复开发时都要更新钱包或 Go Ethereum 客户端并重新同步区块链的麻烦的人来说，MetaMask 特别方便。

##### 图 4.8. 当通过以太坊钱包或 Go Ethereum 客户端控制台连接到以太坊时，您是通过本地节点连接的。当通过 MetaMask 连接到以太坊时，您是通过远程节点连接的。

![](img/fig04-08_alt.jpg)

在下一节中，您将安装 MetaMask。然后您将通过 MetaMask 将`SimpleCoin`重新部署到 Ropsten，并与之交互，完全绕过您的本地 geth 客户端和以太坊钱包。

#### 4.3.1. 安装 MetaMask

您可以从这个网址安装 MetaMask 浏览器扩展：[`mng.bz/8JzB`](http://mng.bz/8JzB)。在添加扩展后，您应该能在浏览器地址栏旁边看到 MetaMask 图标。

你现在可以点击 MetaMask 图标开始设置 MetaMask 钱包。你会被邀请接受隐私政策和条款和条件（自担风险）。然后你会被要求创建一个新的密码，如图 4.9 所示。

##### 图 4.9. 设置 MetaMask 钱包密码

![](img/fig04-09_alt.jpg)

输入你的新密码（最好是安全的）并点击创建。你会被建议复制并安全地存储系统生成的 12 个单词的恢复短语。确认你已这样做后，钱包将被创建，此时你会在左上角看到连接的网络名称。最初，你连接到主以太坊网络，如图 4.10 所示。

##### 图 4.10. MetaMask 最初指向主以太坊网络。

![](img/fig04-10_alt.jpg)

考虑到你将在测试网络上部署`SimpleCoin`，通过点击主以太坊网络并从下拉列表中选择 Ropsten 测试网络，如图 4.11 所示，来更改你当前的网络。

##### 图 4.11. 可以通过 MetaMask 连接到各种以太坊网络。

![](img/fig04-11_alt.jpg)

你会注意到默认账户与你在 Ropsten 以太坊钱包中的任何账户都没有关系。而这个默认的测试账户没有任何以太币，所以你无法用它做很多事情。要导入你现有的包含以太币的 Ropsten 账户，点击右上角的菜单图标，然后选择导入。在导入对话框中，你会看到一个选择类型的下拉列表。选择 JSON 文件，如图 4.12 所示。

##### 图 4.12. 从 JSON 文件导入账户的对话框

![](img/fig04-12_alt.jpg)

现在你必须提供包含你现有 Ropsten 账户私钥的 JSON 文件。记住，你的 Ropsten 账户的密钥对保存在测试网络密钥库中，根据你的操作系统，你可以在表 4.5 中显示的位置之一找到。

##### 表 4.5. 测试网络密钥库位置

| 系统 | 密钥库路径 |
| --- | --- |
| 系统 | 系统 |
| 系统 | C:\Users\用户名\%appdata%\Roaming\Ethereum\testnet\keystore |
| Linux | ~/.ethereum/testnet/keystore |
| macOS | ~/Library/Ethereum/testnet/keystore |

测试网络密钥库文件夹应该包含一个列表，其中的文件名包含它们所指的时间戳和账户地址：

+   `UTC--2017-06-24T08-49-46.377533700Z--edde06bc0e45645e2f105972bdefc220ed37ae10`

+   `UTC--2017-06-24T13-26-18.696630000Z--4e6c30154768b6bc3da693b1b28c6bd14302b578`

+   `UTC--2017-06-24T18-21-36.890638200Z--70e36be8ab8f6cf66c0c953cf9c63ab63f3fef02`

+   `UTC--2017-06-24T18-21-47.794428600Z--c99048e9b98d3fcf8b5f0d5644794b562f9a2ea4`

尽管文件扩展名不存在，但这些是 JSON 文件。例如，列表中的第二个文件指的是账户 4e6c30154768b6bc3da693b1b28c6bd14302b578。如果你用 Windows 中的 Notepad 等文本编辑器打开该文件，你应该会看到类似这样的 JSON 内容：

```
{"address":"4e6c30154768b6bc3da693b1b28c6bd14302b578","crypto":{"cipher":"aes
-128-ctr","ciphertext":"bc7569458b99dcbbdcb0cf46402eeb83875baa6302d27e887a6d4
e2d6e31771f","cipherparams":{"iv":"f0838a98d39d532e8d96e9f7cc799712"},"kdf":"
scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"fb2dbd4f24553c
585025417b691ef11784cf6ae90aa412b73e4965ba3d4f2772"},"mac":"36ba647b1d2ff7a3d
8ca6b32731593caee920dcc19d14e91915cb98a7a244c2c"},"id":"32bb1449-60f5-4cd0-
a4d2-4608fa9fc1c3","version":3}
```

在 MetaMask 导入账户对话框中，点击选择文件，导航到你的测试网 keystore，然后选择与你要导入的账户相关的文件。你必须提供创建此账户时输入的密码，然后点击导入。几秒钟后，你应该看到你导入的账户的详细信息，包括其中的以太币，如图 4.13 所示。图 4.13 导入你现有的两个 Ropsten 账户后，你可以继续部署 `SimpleCoin`。

##### 图 4.13. 当你从 keystore 导入一个账户后，其所有详细信息都会出现在 MetaMask 上。

![](img/fig04-13_alt.jpg)

#### 4.3.2. 通过 MetaMask 部署 SimpleCoin

要部署 `SimpleCoin`，首先打开 Remix 并输入 `SimpleCoin` 的最新版本，即你之前在钱包中输入的版本，如图 4.1 所示。列表 4.1 现在在右侧面板的运行标签中选择环境下拉列表中的注入 Web3 选项，如图 4.14 所示。图 4.14

##### 图 4.14. 截图显示了如何通过选择环境下拉列表中的注入 Web3 来配置 Remix 以使用外部 MetaMask 节点（而不是本地的 JavaScript 虚拟机模拟器）。

![](img/fig04-14_alt.jpg)

Remix 将检测到 MetaMask，并会使用 MetaMask 节点之一，而不是本地的 JavaScript EVM 模拟器。如果在账户下拉列表中没有显示账户，刷新 Remix 网页，MetaMask 中当前选中的账户将被选中。

你可以通过点击红色的部署按钮来触发 `SimpleCoin` 的部署。地址以 0x4e6c30154 开头的账户 2 是唯一可选的选项，并且目前正选中在账户下拉列表框中。那个账户将会部署合约。

点击部署后，你将看到一个对话框，其中总结了执行账户和部署交易的成本信息。你还将被要求确认是否继续，如图 4.15 所示。图 4.15

##### 图 4.15. 在配置 Remix 以指向外部 MetaMask 节点并开始部署合约（如 `SimpleCoin`）之后，你将收到来自 MetaMask 的（部署）交易确认对话框。这显示了执行部署交易和交易成本的信息。对话框还要求用户确认是否继续部署合约。

![](img/fig04-15_alt.jpg)

点击确认后，你可以在 MetaMask 钱包底部的区域检查交易状态。状态将从一个提交状态移动到确认状态，如图 4.16 所示。图 4.16

如果你在合约状态为“已提交”时点击“交易编号”标签，然后在其变为“已确认”后，你将在 Etherscan 网站上看到交易详情，如图 4.17 所示。正如你所看到的，Etherscan 还显示了合约的目标地址（以 0x0c9189e4d6 开头）。

##### 图 4.16\. 可以在 MetaMask 钱包的底部区域监控部署交易的状态。这将从已提交更改为已确认。

![](img/fig04-16_alt.jpg)

##### 图 4.17\. 从 Etherscan 网站上获取的交易详情，在点击 MetaMask 钱包的（已提交或已确认）状态时调用

![](img/fig04-17_alt.jpg)

如果你回到 Remix，你将在“部署”按钮下方看到一些部署详情，包括部署地址，这个地址与你在 Etherscan 页面上看到的是同一个。你可以通过点击“复制地址”链接来获取该地址，如图 4.18 所示。

##### 图 4.18\. 部署交易完成后，合约地址在 Remix 中显示在“部署”按钮下方。

![](img/fig04-18_alt.jpg)

干得好！您通过 MetaMask 在 Ropsten 上重新部署了`SimpleCoin`。现在您可以看看如何通过 MetaMask 与它互动。

#### 4.3.3\. 通过 MetaMask 与 SimpleCoin 互动

图 4.18 还显示，在部署`SimpleCoin`后，Remix 显示两个按钮：CoinBalance 和 Transfer。这两个按钮与你第一次在 JavaScript VM 上创建合约时出现的完全相同。不过，这次你将和一个在真实网络上实例化的合约互动。

您可以执行的第一个操作是检查部署合约的账户 2 的代币余额。输入“0x4e6c30154768b6bc3da693b1b28-c6bd14302b578”（记住，通常要将地址用双引号括起来）并点击 CoinBalance。您将立即得到 10,000，如预期一样。与通过以太坊钱包检查余额一样，这个操作是只读的，不会产生交易。因此，您不需要授权它。

现在将 250 个代币从账户 2 转移到账户 3。在 Transfer 文本框中输入此内容：

```
"0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02", 250
```

点击 Transfer。这是一次写操作，因此 MetaMask 交易确认对话框会弹出，如图 4.19 所示。您可以从账户 2 授权它。点击确认，并在 MetaMask 对话框中跟随交易状态。

##### 图 4.19\. 为了转移 SimpleCoin 代币（这是一个合约状态写操作），发送账户需要被授权。随后，MetaMask 交易确认对话框显示以获取用户确认。

![](img/fig04-19_alt.jpg)

如果您点击交易编号图标，您将在 Etherscan 上看到交易详情。现在您可以回到 Remix 并检查那里的交易详情。

以太坊网络上的 Etherscan 和 Remix 都确认了从账户 2 向账户 3 转移 250 个 SimpleCoin 代币的操作已成功完成，但您可以通过使用`coinBalance`函数来再次检查这些账户的新余额，以确保与表 4.6 中的余额一致。

##### 表 4.6. 转移 250 代币后的账户余额

| 账户地址 | 账户余额 |
| --- | --- |
| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 9,750 |
| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 250 |

我就讲到这里，但我鼓励你产生一些错误信息，例如尝试移动无法使用的代币，就像之前你用以太坊钱包做的那样。这样做将允许你确认合约在 MetaMask 上是否也能正确运行。

### 总结

+   您可以在以太坊网络上部署一个合约，并使用以太坊钱包与之交互。

+   以太坊钱包是通过一个本地的 geth 实例与以太坊通信的。

+   您可以将合约部署在以太坊网络上，并使用 MetaMask 与之交互。
