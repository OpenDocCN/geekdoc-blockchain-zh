© 作者（们），经 Springer Nature Switzerland AG 2022 独家授权 X. Yi 等。区块链基础与应用 Springer Briefs in Applied Sciences and Technology[`doi.org/10.1007/978-3-031-09670-9_2`](https://doi.org/10.1007/978-3-031-09670-9_2)

# 2. 比特币、以太坊、智能合约与区块链类型

许云^(1  )，杨学超^(1  )，安德烈·凯拉雷夫^(1  )，林国尧^(2  ) 和 塔里·扎希尔^(1  )（1）澳大利亚皇家墨尔本理工大学计算技术学院（2）新加坡南洋理工大学计算机科学与工程学院许云（通讯作者）电子邮件: xun.yi@rmit.edu.au 杨学超电子邮件: xuechao.yang@rmit.edu.au 安德烈·凯拉雷夫电子邮件: andrei.kelarev@gmail.com 林国尧电子邮件: kwokyan.lam@ntu.edu.sg 塔里·扎希尔电子邮件: zahir.tari@rmit.edu.au

## 2.1 比特币

比特币是一种去中心化的数字货币，没有中央行政权威或单一管理者。比特币可以由用户间通过点对点的比特币网络发送，无需中介。比特币交易通过网络节点使用密码学进行验证，并记录在一个名为区块链的公共分布式账本中。

比特币是在 2008 年由一个未知个人或团体以中本聪（Satoshi Nakamoto）的名字发明的。这种加密货币在 2009 年开始被使用，当时它的实现作为开源软件发布。

### 2.1.1 比特币网络

如图 2.1 所示，比特币网络是一个点对点（P2P）的去中心化网络。P2P 网络是由两台或更多直接相连并共享资源而无需经过单独的服务器站的计算机创建的。它可能是一个临时连接，例如，通过通用串行总线连接的两台计算机来传输文件。它也可以是一个永久的架构，将一家公司中的多台计算机通过铜线或光纤连接起来。它还可以更大，并使用特殊的协议和应用程序在互联网上建立用户间的直接关系。![](img/516136_1_En_2_Fig1_HTML.png)

一幅插图展示了比特币网络。它有六个比特币节点，它们之间用双箭头连接。

图 2.1

比特币网络

比特币网络使用特殊的加密协议和软件应用程序通过互联网连接节点。网络中的货币单位被称为*比特币*。用户可以通过使用比特币加密货币钱包软件，将他们签名的消息广播到网络的其他节点，从而在网络上发送和接收比特币。这些货币交易随后记录在一个分布式、复制的公共数据库或账本中，该数据库或账本被称为*区块链*或*区块链账本*，通过一种名为*挖矿*的证明工作机制来实现共识。

比特币的创造者中本聪（Satoshi Nakamoto）写道，比特币软件的设计和编码始于 2007 年。该项目于 2009 年作为开源软件发布。

比特币网络需要最基本的基础设施来共享交易。一个自发的去中心化网络，由志愿者参与或节点构成，就足够了。消息是以最佳努力的方式广播的，节点可以自行决定离开和重新加入网络。重新连接到网络，每个节点都会从其他节点下载并验证新区块，以维护其本地区块链账本。

### 2.1.2 比特币交易

比特币交易是比特币价值的转移。它被广播到网络，并记录在账本中的区块中。一个交易通常引用先前的交易输出作为新的交易输入，并将所有的输入比特币值 dedication to 新的输出。交易以未加密的纯文本形式存储。因此，很容易查看账本中每个区块记录的每一笔交易，浏览区块并搜索感兴趣的交易。一旦交易获得足够数量的确认，它们就可以被认为是不可撤销的。

所有交易都以十六进制格式记录，并可在区块链中查看，以便每个人都可以使用十六进制编辑器查看或编辑它们。区块链浏览器是一个网站，可以查看区块链中的每笔交易，并以人类可读的形式显示。这对于调查交易的运行技术细节和验证支付的正确性非常有用。

图 2.2（2.2）展示了比特币交易的主要部分。![](img/516136_1_En_2_Fig2_HTML.png)

一个插图展示了比特币交易。它有两个主要组成部分，分别是新交易和先前的交易。两者都包含版本、输入、输出和锁定时间等子组件。第一个交易的输入和先前交易的输出通过箭头连接。

图 2.2

比特币交易的格式

每个交易都以一个四字节的交易版本号开始，它告诉比特币对等体和矿工使用哪一套规则来验证它。

每个交易都有一个或多个输入和一个或多个输出。每个输入花费由先前输出支付的比特币。每个输出然后作为未花费交易输出（UTXO）等待，直到后来的输入花费它。当你的比特币钱包告诉你有 10,000 比特币余额时，实际上这意味着有 10,000 比特币在一个或多个 UTXO 中等待。Locktime 设置了将交易添加到区块链块中的最早时间。

每个输出都有一个由其在交易中的位置确定的索引号。第一个输出的索引为零。输出还具有以比特币支付给接收者的金额，它带有条件的 pubkey 脚本（即接收者公钥的哈希），例如，![](img/516136_1_En_2_Figa_HTML.png)

一组随机的字母和数字。

比特币单位是聪，这是比特币的最小币值，相当于比特币的百万分之一。

能够满足那个 pubkey 脚本条件的人，即知道相应的私钥，能够花费未来比特币的最大金额。

每个输入都使用一个交易标识符（TXID）（即前一个交易的哈希）和一个输出索引号来标识一个特定的输出以供消费。此外，它还有一个签名脚本，该脚本提供了满足 pubkey 脚本中条件的参数，即发送者的签名（在新输出上）和发送者的公钥，例如，![](img/516136_1_En_2_Figb_HTML.png)

一组随机的字母和数字。

花费输出的过程可以在图 2.3 中说明，其中序列号是输入序列号，因为可能有一个以上的输入。![](img/516136_1_En_2_Fig3_HTML.png)

图有三个层次。第一层是带有版本、输入、输出和锁定时间的新的交易。第二层是带有输出索引、序列号、签名脚本、金额和 pub-key 脚本的交易标识符。第三层是带有版本、输入、输出和锁定时间的先前交易。

图 2.3

花费输出

如果一个新交易有效（1）基于发送者的公钥，输出上的签名是真实的，（2）发送者的公钥可以哈希到先前有效交易中的输出的 pubkey 脚本。

接收者公/私钥对的公钥部分的 160 位哈希称为一个*比特币地址*。比特币地址的标准格式是 P2PKH（支付到公钥哈希）。图 2.4 展示了如何创建 P2PKH 公钥哈希以接收付款。![](img/516136_1_En_2_Fig4_HTML.png)

在一个流水链中，在鲍勃的计算机上有私钥、完整的公钥和公钥哈希，在爱丽丝的计算机上有公钥哈希的副本，在新交易中有公钥哈希的副本，所有这些都由箭头连接。

图 2.4

创建一个 P2PKH 公钥哈希以接收付款

接下来，让我们详细看看爱丽丝发送给鲍勃的交易的工作流程，以及鲍勃稍后如何花费这笔交易。爱丽丝和鲍勃都使用标准 P2PKH 交易类型的最常见形式。P2PKH 允许爱丽丝将比特币发送到典型的比特币地址，然后让鲍勃使用加密密钥对花费相同的比特币。

首先，鲍勃必须生成一个私钥和公钥组成的密钥对。然后爱丽丝可以实施交易。比特币使用 secp256k1 曲线的椭圆曲线数字签名算法（ECDSA）。^(1)secp256k1 私钥由 256 位随机数据表示。这部分数据的一个副本通过确定性转换为 secp256k1 公钥。因为该转换可以可靠地稍后重复，所以不需要存储公钥。

然后，公钥（pubkey）通过加密哈希进行处理。哈希缩短并混淆了公钥，使得手动转录变得更容易，并为防止后来从公钥数据中重建私钥提供了安全保护，防止了无法预见的问题。

鲍勃向爱丽丝提供公钥哈希。公钥哈希几乎总是以比特币地址的形式发送，这是包含地址版本号、哈希和错误检测校验和的 base58 编码字符串。^(2)地址可以通过任何介质传输，包括防止花费者与接收者通信的一方向性介质。

当爱丽丝收到地址并将其解码回标准哈希时，她可以生成第一个交易。爱丽丝创建一个包含允许任何人花费该输出的指令的标准 P2PKH 交易输出，如果他们能证明他们控制着与鲍勃哈希的公钥对应的私钥。这些指令称为公钥脚本或脚本公钥。

在签署输出后，爱丽丝将交易广播给所有节点，并将其添加到区块链中。网络将其归类为未花费交易输出（UTXO）。鲍勃的钱包软件将其显示为可花费的余额。

当鲍勃决定花费 UTXO 时，他可以创建一个输入，引用爱丽丝通过交易哈希创建的交易，这也称为交易标识符（TXID），以及爱丽丝使用的特定输出，通过其索引号码来引用，即输出索引。然后鲍勃必须创建一个签名脚本——满足爱丽丝在先前输出的公钥脚本中放置的条件的一组数据参数。签名脚本也称为脚本签名。

公钥脚本和签名脚本结合了 secp256k1 公钥和签名以及条件逻辑。这创建了一个可编程的授权机制，如图 2.5 所示。![](img/516136_1_En_2_Fig5_HTML.png)

插图描绘了一个 P 2 P K H 输出。组件包括先前交易的版本、输入、输出和锁定时间，然后是公钥哈希，接着是包含签名、完整公钥、公钥脚本、公钥哈希的签名脚本，最后是鲍勃的计算机，带有私钥和完整公钥，由箭头连接。

图 2.5

花费 P2PKH 输出

对于 P2PKH 风格的输出，鲍勃的签名脚本包含以下两个数据项。

+   鲍勃的未哈希完整公钥，以便公钥脚本可以检查它哈希到的值与爱丽丝提供的公钥哈希相同。

+   一个使用 ECDSA 加密公式结合特定交易数据（如下所述）和鲍勃的私钥生成的 secp256k1 签名。这使得公钥脚本能够验证鲍勃拥有与公钥对应的私钥。

鲍勃的 secp256k1 签名证明鲍勃控制着他的私钥，并使他的交易的非签名脚本部分不可篡改。鲍勃可以安全地在点对点网络上广播它们。![](img/516136_1_En_2_Fig6_HTML.png)

一个流程图具有带有交易 ID I D、输出索引号和公钥脚本的先前交易，然后是鲍勃的计算机、私钥、新交易、公钥脚本和金额，接着是已签名数据，最后是新交易，带有交易 ID I D、输出索引、完整公钥、签名、公钥脚本和金额。

图 2.6

花费输出时签署的数据项

如图 2.6 所示，鲍勃签署的数据包括先前交易的 TXID 和输出索引、鲍勃创建的将允许下一个接收者花费这笔交易输出的公钥脚本，以及要花费给下一个接收者的比特币金额。因此，整个交易除了所有包含完整公钥和 secp256k1 签名的签名脚本外都被签署了。

接下来，鲍勃将他的签名和公钥附加到新交易的输入中的签名脚本，并通过点对点网络将交易广播给所有比特币矿工。每个节点和矿工在进一步传播交易或尝试将其包含在新的交易区块之前，独立验证交易。

在 P2PKH 输出中，公钥脚本具有以下形式：![](img/516136_1_En_2_Figc_HTML.png)

一组随机的字母和数字。

在新交易的输入中，签名脚本包含一个 secp256k1 签名（sig）和完整的公钥（pubkey）。签名可以按照以下顺序进行验证：![](img/516136_1_En_2_Figd_HTML.png)

一组随机的字母和数字。

为了测试交易是否有效，逐个执行签名脚本和公钥脚本操作，从 Bob 的签名脚本开始，继续执行 Alice 输出中的 Bob 的公钥脚本。标准 P2PKH 公钥脚本的评估过程如下所述。

+   从 Bob 的签名脚本中添加签名到空栈。不需要加密它，因此它以明文形式推送到栈中。签名脚本中的公钥推到签名上面。

+   对 Bob 的公钥执行了 OP_DUP 操作。它将当前位于栈顶的数据推入栈中。这创建了 Bob 提供的公钥的一个副本。

+   然后，执行 OP_HASH160 操作。它将当前位于栈顶的数据的哈希值压入栈中——在这个例子中，是 Bob 的公钥。这创建了 Bob 的公钥的哈希值。

+   然后，Bob 从 Alice 的输出中推送的公钥脚本将 Bob 为先前交易提供的公钥哈希值压入栈中。此时，栈顶应该有两个 Bob 的公钥哈希值。

+   接下来，执行 OP_EQUALVERIFY 操作。它等效于先执行 OP_EQUAL 操作，然后执行 OP_VERIFY 操作，如下所示。

+   OP_EQUAL 检查栈顶的两个值是否相等。在我们的案例中，它检查 Bob 提供的完整公钥生成的公钥哈希是否等于 Alice 在创建先前交易时包含在她输出中的公钥哈希。OP_EQUAL 操作比较了两个值，并替换它们为比较的结果：零（false）或一（true）。

+   OP_VERIFY 检查栈顶的值。如果值为 false，它将立即终止评估，交易验证失败。否则，它将真值从栈中弹出。

+   最后，执行 OP_CHECKSIG 操作，该操作验证 Bob 提供的签名，将其与他也提供的已认证的公钥进行比较。如果签名与公钥匹配，并且使用所有需要签名的数据生成了签名，那么 OP_CHECKSIG 将真值‘true’推送到栈顶。如果在公钥脚本评估完毕后栈顶不是 false，则只要交易没有其他语义问题，交易就是有效的。

### 2.1.3 区块链与比特币的工作量证明

比特币使用区块链公共账本作为按顺序和时间戳记录交易的系统。这个系统应用于防止双重花费，并防止修改以前的事务记录。

比特币网络中的每个完整节点独立地存储包含仅由该节点验证的区块的区块链。当几个节点在他们区块链账本的副本中都有相同的区块时，它们被认为是达成共识的。为了维护共识，这些节点遵循称为共识规则的验证规则。![](img/516136_1_En_2_Fig7_HTML.png)

插图展示了区块链数据结构和区块格式。它包含了三个区块，区块 N-1，区块 N 和区块 N+1。图片的右侧展示了区块 N+1 的哈希等于区块头（block header）的哈希。它有一个区块 N-1 的哈希、市场根哈希、版本、时间戳、随机数（nonce）和目标难度。

图 2.7

区块链数据结构和区块格式

图 2.7 展示了一个简化版的区块链。一组一个或多个新的交易被收集到一个块的交易数据部分。每个交易的副本被哈希处理，然后将这些哈希值配对，再次哈希，再次配对，直到剩下一个哈希值，这就是梅克尔树（Merkle tree）的根哈希。

梅克尔根哈希存储在区块头中。每个区块还存储前一个区块头的哈希。这使得区块连锁在一起，确保了一个交易不能被修改，而不修改记录它的区块和所有后续的区块。

交易也被连锁在一起。比特币的钱包软件给人一种比特币是从一个钱包发送到另一个钱包的错觉，但事实上比特币是从一个交易转移到另一个交易。每个交易花费之前在一个或多个早期交易中接收的比特币。这意味着一个交易的输入是之前交易的输出。

区块链是由网络上的匿名对等节点协作维护的。比特币要求每个区块包含证明在其创建中投入了大量工作的证明。这确保了那些想要修改过去区块的不信守承诺的对等节点面临一个劳动量过大的工作。

连锁区块会使修改任何区块中包含的交易变得不可能，除非也修改所有后续的区块。因此，修改特定区块的成本会随着区块链账本上新增的区块而增加，从而增加了工作量证明机制的效果。

比特币中使用的工作量证明利用了加密哈希的看似随机性质。一个好的加密哈希算法将任意数据转换成一个看起来像随机数的哈希值，与数据无关。如果以任何方式修改数据，并再次运行哈希算法，将生成一个新的看起来像新随机数的哈希值，因此不可能通过修改数据来创建一个可预测的哈希值。

为了证明矿工完成了创建区块的大量工作，矿工需要随机选择一个 nonce 来创建一个不超过一定阈值的区块头哈希。例如，如果最大可能的哈希值是![$$2^{256}-1$$](img/516136_1_En_2_Chapter_TeX_IEq1.png)，那么矿工可以通过产生小于![$$2^{255}$$](img/516136_1_En_2_Chapter_TeX_IEq2.png)的哈希值来证明至少进行了两次测试。

在上面的简化示例中，矿工平均每两次尝试就能产生一个成功的哈希。矿工可以估计一次哈希尝试生成的数值低于目标阈值的概率。比特币假设概率与阈值值呈线性相关。目标阈值设置得越低，平均来说找到满足此条件的哈希所需的哈希尝试次数就越多。

只有当区块的哈希满足共识协议中当前目标阈值指定的难度级别条件时，才会将新区块添加到区块链中。在每次向账本添加 2016 个区块的一部分后，网络会使用这些区块头部中存储的时间戳来计算从第一个到最后一个 2016 个区块生成的秒数。理想值是 1,209,600 秒，即两周。

+   如果发现最后 2016 个区块的生成时间少于两周，那么预期的难度值将相应地增加（最多增加 300%），以确保如果所需的哈希值以之前的相同速率被发现，下一个 2016 个区块的生成正好需要两周时间。

+   如果发现最后一批区块的生成时间超过两周，那么预期的难度值将相应地减少（最多减少 75%），以加快进程，使得如果所需的哈希值继续以之前的相同速率被发现，再次下一个 2016 个区块的生成正好需要两周时间。

由于每个区块头必须哈希到一个低于目标阈值的值，并且因为每个区块都链接到它前面的区块，所以传播一个修改过的区块平均需要与整个比特币网络在原始区块创建至今的时间内向外耗散的哈希力量一样多。只有当你获得了网络大多数的哈希力量，你才能可靠地对交易历史执行此类 51%攻击。然而，从概率上讲，需要注意的是，即使一个拥有不到 50%哈希力量的群体仍然有一定的机会进行此类攻击。

区块头部包括几个容易修改的字段，如专用的 nonce 字段。因此，矿工无需等待新交易即可生成新散列。此外，只有 80 字节的区块头部需要进行工作量证明。在区块中包含大量交易数据不会因为额外的输入输出而减慢散列速度。仅需要重新计算 Merkle 树中祖先的散列值来添加交易数据。

### 2.1.4 比特币挖矿

比特币挖矿是维护和发展区块链账本的关键组成部分。它用于将新的比特币投入流通。它还用于通过网络节点确认新交易。

比特币挖矿是通过应用复杂的硬件来解决极其复杂的计算问题。问题的每一个解决方案都可以作为完成困难工作的证明。首先解决这个问题的计算机将被授予添加下一个比特币块的权利，挖矿过程继续进行。

成功将区块头部散列到一个低于目标阈值的比特币矿工可以添加相应的区块到区块链账本，前提是该区块在其他方面是有效的。区块通常按它们的区块高度来称呼——它们之间和第一个比特币块（块 0，通常被称为创世块）之间的区块数量。例如，区块 2016 可能是首次可以根据目标阈值调整难度级别的区块。![](img/516136_1_En_2_Fig8_HTML.png)

插图展示了常见的和不常见的区块链分叉。它分为两类，分别是正常偶尔分叉和罕见延长分叉。

图 2.8

常见的和不常见的区块链分叉

多个区块都可以有相同的区块高度，因为两个或更多的矿工可能恰好在他们大约相同的时间内产生区块。这会在区块链账本中创建一个冲突的分叉，如图 2.8 所示。

当两个矿工同时产生他们的区块并将它们添加到区块链账本的末尾时，网络上的每个节点都会单独选择接受哪个区块。通常，许多节点可以使用他们看到的第一个被添加的区块。其他可能考虑的因素如下所述。

最终，矿工产生了另一个区块，这个区块只附着在同时挖出的竞争区块中的一个。这使得分叉的对应侧面比另一侧面更强。假设分叉中只包含有效的区块，普通节点总是跟随最长的账本链，因为它是通过更多困难的证明确认的更可靠的。属于较短分叉的区块被称为*陈旧区块*。它们必须被丢弃并重新创建。陈旧区块有时也被称为*孤儿区块*或*孤儿块*，但这些术语也用于没有已知父块的区块。

如果不同的矿工工作目的相反，例如一些矿工勤奋地延长区块链账本的同时，其他矿工试图进行 51%攻击来修订交易历史，则可能会出现长期分叉。

矿工因为他们的工作（审计）而得到报酬。他们正在做验证比特币交易合法性的工作。这种习俗旨在保持比特币用户的诚实，由比特币创始人中本聪提出。通过验证交易，矿工有助于防止“双重花费”问题。

双重花费是指比特币所有者非法地将同一个比特币花两次的情况。对于纸币来说，这并不是一个问题：一旦你给某人一张 20 美元的钞票去买东西，你就不再拥有它，所以你不可能用那张同样的 20 美元钞票去隔壁买彩票。虽然存在伪造现金的可能性，但这并不完全等同于字面上将同一美元花两次。然而，对于数字货币来说，持有可能制作该数字货币的副本并发送给商家或其他方，同时保留原币。

比特币矿工通过完成验证交易的区块获得比特币作为奖励，这些区块被添加到区块链中。挖矿奖励支付给第一个发现解决复杂散列谜题的矿工。发现解决方案的概率与网络上的总挖矿力量有关。

比特币挖矿的奖励大约每四年减半，如图 2.9 所示。![](img/516136_1_En_2_Fig9_HTML.png)

条形图展示了矿工成功完成 1 个区块所获得的奖励。该图表示每 210,000 个区块减半一次，或者平均每 4 年在 2009 年每个区块奖励 50 BTC，2012 年每个区块奖励 25 BTC，2016 年每个区块奖励 12.5 BTC，以及从 2020 年开始每个区块奖励 6.25 BTC。

图 2.9

矿工的奖励

当比特币在 2009 年开始运营时，挖出一个区块矿工可以获得 50 BTC。到了 2012 年，这个数额减少到了 25 BTC。到了 2016 年，再次减少到 12.5 BTC。2020 年，奖励再次减少到 6.25 BTC。

2021 年 9 月，比特币的价格大约为每比特币 45,000 美元，这意味着每位矿工完成一个区块可以获得 281,250 美元（6.25*45,000）的奖励。

一个区块中的第一条交易是一个币基交易。这是一种独特的比特币交易，只能由矿工创建。矿工使用它来收集他们工作的区块奖励以及矿工收集的任何其他交易费用也在此交易中发送。

币基交易必须恰好有一个输入，这被称为币基。币基输入格式可以如图 2.10 所示说明。![](img/516136_1_En_2_Fig10_HTML.png)

一个表格有四列和六行。这些列分别有字节、名称、数据类型和描述。

图 2.10

币基输入格式

币基交易总是由矿工构造。

它们包含在工作量证明挖矿过程中花费工作的奖励。矿工收到的奖励总额等于区块奖励和从所有包含在区块中的交易中收取的交易费用的总和。为了创建一个币基交易，矿工计算包含在区块中的交易的交易费用总额。计算方法如下：![](img/516136_1_En_2_Fige_HTML.png)

总费用等于输入之和加上输出之和

创世区块，即区块 0，以及一些初始区块，只包含币基交易，因为在比特币的初始化中没有发生其他交易。

矿工可以直接在比特币网络上宣布他的新发现区块，该区块包含他的随机数，使得他的区块散列值低于给定阈值，因为他的币基交易（作为奖励）已经包含在他的区块中。任何人想要替换他的币基交易而不改变区块散列值（即低于给定阈值）是非常困难的。这是比特币设计中最聪明的想法之一。

## 2.2 以太坊

比特币发布后不久，以太坊查看了他们使用区块链技术的方式，并想象如何将其用于不仅仅是货币。

每一个区块链都是一个公共数据库，它通过网络中的许多计算机进行更新和共享。这里的“区块”指的是以块的形式存储的数据和状态。

以太坊网络上使用的加密货币称为以太币（ETH）。如果你向他人发送以太币，交易的数据显示需要添加到一个区块才能成功。以太坊中可用的以太币的最小单位由 WEI 表示。一个以太币等于一万亿 WEI，即![$$10^{18}$$](img/516136_1_En_2_Chapter_TeX_IEq4.png) WEI。最常使用的以太币单位是 GWEI。一个以太币等于十亿 GWEI，即![$$10^{9}$$](img/516136_1_En_2_Chapter_TeX_IEq5.png) GWEI。

“链”这个词的解释是因为每个区块通过加密方式与其前一个区块链接在一起。这样，区块被组织成一个连续的链。一个区块中的数据在没有改变所有后续区块的情况下无法被修改，这需要整个网络的共识。

网络中的每个参与者或计算机都必须就每个新区块及整个链达成一致。这些参与者或计算机被称为网络的“节点”。节点确保与区块链互动的每个人都拥有相同的数据。为了实现这种分布式共识，区块链采用了一种共识机制。

以太坊目前使用工作量证明（Proof of Work，PoW）共识机制。这意味着任何想要向链中添加新区块的人都必须解决一个难题，这个问题需要大量的计算工作。解决难题证明了您使用计算资源完成了工作。这样做被称为*挖矿*。通常，挖矿使用暴力尝试和错误。每次成功添加区块都会以以太币作为奖励。

新区块广播给网络中的节点，并通过验证来更新区块链账本的状态，以便让所有人都能获得更新。总结来说，当你向某人发送以太币时，这笔交易必须经过挖掘并包含在新区块中。然后将更新后的状态分享给整个网络。

### 2.2.1 以太坊网络

在以太坊社区中，有一个称为*以太坊虚拟机*或 EVM 的单一标准计算机。每个以太坊节点都保留 EVM 状态的一个副本。需要达到以太坊网络上所有参与者的共识，才能确定 EVM 的当前状态。此外，任何参与者都可以广播一个请求，要求 EVM 执行某个计算。每当这种请求被广播时，网络上的其他参与者都会在他们 EVM 状态的副本上进行验证、验证和执行计算。这种执行导致 EVM 状态发生变化，这种变化被提交并在整个网络上分布。

这些计算请求称为*交易请求*。所有交易记录以及 EVM 当前状态都存储在区块链账本上，而账本则由所有节点记录和达成共识。

网络使用加密机制来确保当交易被验证为有效并添加到区块链时，它们以后不能被篡改。同样的机制还确保了所有交易都经过签名并以适当的“权限”执行。因此，除了账户所有者外，没有人能从网络账户发送数字资产。

#### 2.2.1.1 以太（ETH）

*以太*（ETH）是用于以太坊网络上许多事物的加密货币。它是支付交易费用、挖矿收益和其他支付的唯一接受形式。

以太坊允许开发者创建去中心化应用程序或 dapps，它们都共享一个计算资源池。这个共享池是有限的，以太坊应用了一种机制来确定谁可以使用资源以及何时使用。否则，dapp 可能会意外或恶意地消耗所有网络资源，这将阻止其他人访问它。

以太坊加密货币支持以太坊计算力的定价机制。当用户想要进行交易时，他们必须贡献以太币，以便他们的交易被区块链认可。这些使用成本被称为*燃料费*。燃料费取决于执行交易所需的计算力和当时网络对计算力的需求。

因此，即使恶意 dapp 提交了一个无限循环，交易最终也会用完以太币并终止，使网络恢复正常。

“以太坊”和“以太”这两个词经常可以互换使用。例如，“以太坊的价格”与“以太的价格”意思相同。

#### 2.2.1.2 以太坊账户

以太坊的当前状态由称为*账户*的对象组成。每个账户都有一个 20 字节的地址和状态转换，即账户之间的直接价值和安全信息转移。以太坊账户包含以下四个字段。

+   **nonce**，一个用于确保每笔交易只能处理一次的计数器。

+   账户当前的**以太币余额**。

+   账户的**合约代码**（如果有）。

+   账户的**存储空间**，默认是空的。

以太币用于支付交易费用。通常，账户分为两种：**外部所有账户**，由私钥控制，和**合约账户**，由合约代码控制。外部所有账户没有代码，可以通过创建并签署交易从外部所有账户发送消息。每次合约账户接收到消息时，其代码都会激活，允许它读写内部存储并发送其他消息或创建新合约。

以太坊合约不需要实现或遵守某些东西。相反，它们作为以太坊环境中的自主代理。每个合约在接收到消息或交易请求时总是执行特定的代码。合约直接控制自己的以太币余额和自己的键/值存储，以跟踪持久变量。

**账户创建示例。** 要在以太坊中创建账户，大多数库可以为您生成一个随机的私钥。私钥是 64 个十六进制字符的序列，可能用密码加密。以下是一个私钥的示例：![](img/516136_1_En_2_Figf_HTML.png)

一串随机的字母和数字。

公钥是由私钥使用椭圆曲线数字签名算法生成的。用户可以通过取公钥的 Keccak-256 哈希的最后 20 个字节并在前面加上 0x 来获得账户的公地址。

接下来，我们给出使用 GETH 的 personal_newAccount 在控制台创建账户的示例。![](img/516136_1_En_2_Figg_HTML.png)

一个算法

用户可以从私钥派生出新的公钥，但没有人能从公钥派生出私钥。因此，保护私钥的安全和保密至关重要。

私钥用于签署消息和交易，输出签名。其他人可以然后用签名派生出你的公钥，证明消息的作者。在以太坊应用中，节点可以使用 JavaScript 库向网络发送交易。

每个合约账户都有一个 42 个字符的十六进制地址，例如，![](img/516136_1_En_2_Figh_HTML.png)

一串随机的字母和数字。

合约地址通常在合约部署到以太坊区块链时给出。

### 2.2.2 以太坊交易

以太坊交易是从账户发出的加密签名指令。账户可以发起交易来更新以太坊网络的状态。最简单的交易是将 ETH 从一个账户转移到另一个账户。

以太坊交易指的是由外部所有账户发起的动作，即由人类管理而非合约的账户。例如，如果鲍勃向爱丽丝发送 1 个 ETH，鲍勃的账户必须被借记，爱丽丝的账户必须被贷记。这个改变状态的动作在交易中进行。

改变 EVM 状态的交易需要广播到整个网络。每个节点可以将交易执行请求广播到 EVM。广播后，矿工执行交易并将结果状态更改传播到网络的其他部分。

交易需要费用，并且必须被挖矿才能生效。除了上述讨论的气体费用和与挖矿过程相关的细节外，每个提交的交易都必须包括以下信息。

+   recipient 是接收地址。（对于外部所有权的账户，交易转移加密货币。对于合约账户，交易执行合约代码。）

+   signature 是发送者的标识符。当发送者的私钥签署交易并确认发送者已经授权此交易时，生成此标识符。

+   value 是从发送者转移到接收者的 ETH 数量。

+   data 是一个可选字段，用于包含任意数据。

+   gasLimit 是交易可以消耗的最大气体单位数。气体单位代表计算步骤。

+   maxPriorityFeePerGas 是作为矿工小费的最大气体量。

+   maxFeePerGas 是愿意为交易支付的最大气体量（包括 baseFeePerGas 和 maxPriorityFeePerGas）。

术语 *gas* 指的是矿工处理交易所需的计算量。用户必须为此计算支付费用。gasLimit 和 maxPriorityFeePerGas 决定了支付给矿工的最大交易费用。以下是一个相应交易对象的示例。![](img/516136_1_En_2_Figi_HTML.png)

An algorithm

每个交易对象需要使用发送者的私钥进行签名。这证明交易只可能来自发送者并且没有被欺诈发送。这个签名过程由像 Geth 这样的以太坊客户端处理。一个调用示例是![](img/516136_1_En_2_Figj_HTML.png)

An algorithm

接下来，我们给出一个可能响应的示例。![](img/516136_1_En_2_Figk_HTML.png)

An algorithm

+   raw 是使用递归长度前缀 (RLP) 编码的已签名交易。

+   tx 是 JSON 格式的已签名交易。

使用签名哈希，交易可以使用提交到网络的已签名哈希进行加密验证，以证明它来自发送者。

一旦交易被提交，以下步骤将会进行。

1.  1. 一旦你发送了一个交易，加密学就会生成一个交易哈希，例如，![](img/516136_1_En_2_Figl_HTML.png)

    一组随机字母和数字。

1.  2.

    然后，交易会被广播到网络并包含在其他交易池中。

1.  3.

    矿工必须选择你的交易并将其包含在一个区块中，以便验证交易并认为它成功。

1.  4.

    你的交易将会收到确认。确认数是自包含你交易的区块以来创建的区块数。数字越高，网络处理并认可交易的确信度就越高。

+   最近的区块可能会被重新组织，给人一种交易失败的印象；然而，交易可能仍然有效，但包含在不同的区块中。

+   随着后续区块的增加，重组的概率逐渐减小，即确认次数越多，交易越不可变。

交易需要消耗燃料来执行。简单的转账交易需要 21,000 个单位的燃料。

例如，为了在 baseFeePerGas 为 190 GWEI 和 maxPriorityFeePerGas 为 10 GWEI 的条件下，Bob 需要支付以下费用。![](img/516136_1_En_2_Figm_HTML.png)

一组随机字母和数字。

+   Bob 的账户将被扣减-1.0042 ETH

+   Alice 的账户将被增加+1.0 ETH

+   基础费用将燃烧-0.00399 ETH

+   矿工保留小费+0.000210 ETH

智能合约交互也需要燃料。![](img/516136_1_En_2_Fig11_HTML.png)

Ethereum 状态转换的流程图有三个组成部分，分别是当前状态、新交易和当前状态。

Fig. 2.11

Ethereum 状态转换

#### 2.2.2.1 Ethereum 状态转换函数

Ethereum 状态转换函数 APPLY(S, TX)，-> S’ 如图 2.11 所示，定义如下。

1.  1.

    检查交易是否格式正确（即，具有正确的值数量），签名是否有效，发送者账户中的 nonce 是否匹配。如果不正确，则返回错误。

1.  2.

    计算交易费用为 STARTGAS * GASPRICE，并通过签名确定发送地址。从发送者账户余额中减去费用，并增加发送者的 nonce。如果余额不足，则返回错误。

1.  3.

    初始化 GAS = STARTGAS，并从中扣除一定数量的燃料费用来支付交易中的字节。

1.  4.

    如果接收账户尚不存在，则创建它。将从发送者账户转账交易价值到接收账户。如果接收账户是合约，则运行合约代码，要么运行完成，要么执行耗尽燃料。

1.  5.

    如果因为发送者钱不够或代码执行耗尽燃料而导致价值转移失败，除了支付费用外，回滚所有状态更改，并将费用添加到矿工账户。

1.  6.

    否则，将所有剩余燃料的费用退还给发送者，并将消耗燃料的费用发送给矿工。

例如，假设合约的代码是![](img/516136_1_En_2_Fign_HTML.png)

自存储 calldataload (0) 等于 calldataload (32)

请注意，实际上合同代码是以太坊虚拟机（EVM）的低级代码编写的。为了清晰起见，本例使用我们的一种高级语言 Serpent 编写，并可以编译成 EVM 代码。假设合同的存储最初为空，发送一个带有 10 个以太币、2000 个燃料、0.001 个以太币的燃料价格和 64 个字节数据的交易，其中字节 0-31 表示数字 2，字节 32-63 表示字符串 CHARLIE。在这种情况下，状态转换函数按如下方式操作。

1.  1.

    检查交易是否有效且格式正确。

1.  2.

    检查交易发送者至少有 2000 * 0.001 = 2 个以太币。如果是，那么从发送者的账户中减去 2 个以太币。

1.  3.

    初始化燃料=2000，假设交易为 170 个字节长，每个字节的费用为 5。从账户中减去 850，以便剩下 1150 个燃料。

1.  4.

    从发送者的账户中再减去 10 个以太币，并添加到合同的账户中。

1.  5.

    运行代码。在此案例中，代码检查合同存储中的索引 2 是否被使用，发现未被使用，因此将索引 2 的存储设置为值 CHARLIE。假设这需要 187 个燃料。那么剩余的燃料量为！$$1150 - 187 = 963.$$

1.  6.

    向发送者的账户中添加 963 * 0.001 = 0.963 个以太币，并返回结果状态。

如果交易接收端没有合同，那么总交易费用将等于 GASPRICE 乘以交易的字节长度，与交易一起发送的数据将无关。

请注意，消息的处理方式与交易的处理方式相同，都可以逆转。如果消息执行耗尽了燃料，那么执行以及由该执行触发的所有其他执行都将回滚，但父执行不需要回滚。这意味着合同调用另一个合同是安全的，因为如果 A 用 G 个燃料调用 B，那么 A 的执行最多会损失 G 个燃料。最后，请注意存在一个操作码 CREATE，用于创建合同。它的执行机制与 CALL 类似，不同之处在于执行的输出确定了新创建合同的代码。

### 2.2.3 以太坊的工作量证明

以太坊，像比特币一样，目前使用一种名为工作量证明（PoW）的共识协议。这使得以太坊网络的节点能够就以太坊区块链上记录的所有信息的状态达成一致，并防止各种经济攻击。

工作量证明是设置难度和工作矿工规则的底层算法。挖矿本身就是“工作”。它是向链中添加有效块的行为。这很重要，因为链的长度帮助网络跟随正确的以太坊链并理解以太坊的当前状态。完成的工作越多，链越长，块数越高，网络对账本当前状态的确定性就越高。

#### 2.2.3.1 以太坊的工作量证明是如何工作的？

工作量证明由矿工执行，他们竞争创建充满处理交易的新块。胜者将新块与其他网络分享，并获得一些新铸造的 ETH。比赛由第一个解决数学难题的计算机赢得。这产生了当前块与链中前一个块之间的加密链接。解决难题是建立工作量证明的工作。

以太坊交易被处理成区块。每个区块都有一个

+   block 难度—例如：3,324,092,183,262,715

+   mixHash，例如：0x44bca881b07a6a09f83b130798072441705d9a6...

+   nonce，例如：0xd3ee432b4fb3d26b

工作量证明协议 Ethash 要求矿工进行一场激烈的试错赛，以找到一个块的非 ce。只有具有有效 nonce 的块才能添加到链中。当创建块时，矿工反复将一个数据集（只有通过下载并运行完整链（矿工这样做）才能获得）通过一个数学函数。数据集用于生成一个低于目标 nonce 的 mixHash，如难度所规定。最好的方法是通过试错。

难度决定了哈希的目标。目标越低，有效的哈希集合越小。一旦生成，这对于其他矿工和客户端来说验证起来非常容易。即使有一个交易发生变化，哈希也会完全不同，表示欺诈。

哈希使得欺诈变得容易识别。作为一种过程，工作量证明也是防止攻击的一大威慑。

#### 2.2.3.2 工作量证明与安全性

矿工被激励在以太坊主链上进行工作。在主链之外开始自己的链对矿工的激励很小。区块链依赖于拥有单一状态作为真实来源。用户总是选择最长或“最重”的链。

工作量证明的目标是延伸链。最长的链因为进行了最多的计算工作而被认为是最可信的。在以太坊的 PoW 系统中，几乎不可能创建新的块来删除交易，创建假交易或维护第二条链。这是因为恶意矿工需要始终比其他人更快地解决块 nonce。

要持续创建恶意但有效的区块，攻击者需要超过 51%的网络挖矿功率来打败其他人。攻击者可能需要花费的能源甚至可能超过攻击中能获得的收益。

#### 2.2.3 最终性

在以太坊中，当交易包含在区块中且区块不能再更改时，交易达到*最终性*。由于以太坊矿工的工作是去中心化的，可能会同时生成两个有效的区块。这创建了一个临时分叉。最终，这些链中的一个会增长并成为后续区块被挖掘并添加后变得更长的接受链。

为了进一步复杂化问题，临时分叉上被拒绝的交易可能已经被包含在接受的链中。这意味着它可能会被撤销。以太坊的*最终性*指的是用户不必等待并且可以认为交易是不可变和不可撤销的时间。对于以太坊，建议的等待时间是等待六个区块被添加，或者超过 1 分钟。六个区块之后，用户可以高度自信地认为交易成功并且不能被撤销。谨慎的用户可能会决定等待更长时间以获得更高的确定性。

在设计 dapps 的过程中必须考虑到最终性。如果用户误报交易信息并允许用户过早地依赖交易，尤其是如果交易价值很高，这将误导用户。最终性等待时间不包括交易被矿工选择并包含在区块之前必须经过的时间。![](img/516136_1_En_2_Fig12_HTML.png)

以太坊应用和工作流程的链式图。

图 2.12

以太坊区块链和挖矿

### 2.2.4 以太坊挖矿

以太坊区块链和挖矿如图 2.12 所示。它们与比特币区块链相似。然而，也有一些不同之处。以太坊与比特币在区块链架构方面的主要区别在于，与比特币不同，以太坊区块包含交易列表和最新状态的副本。区块还存储了另外两个值，即区块号码和难度。以太坊的基本区块验证算法如下进行。

1.  1.

    检查前一个区块是否引用存在且有效。

1.  2.

    检查区块的时间戳是否大于引用的前一个区块的时间戳且小于 15 分钟的未来时间。

1.  3.

    检查区块号码、难度、交易根、叔块根和燃料限制（各种低级以太坊特定概念）是否有效。

1.  4.

    检查区块上的工作量证明是否有效。

1.  5.

    设 S[0]为前一个区块结束时的状态。

1.  6.

    设 TX 为一个区块的交易列表，包含 n 笔交易。对于所有 i 在 0...n-1，设置 S[i+1] = APPLY(S[i],TX[i])。如果任何应用返回错误，或者如果区块到目前为止消耗的总燃料气体超过 GASLIMIT，返回一个错误。

1.  7.

    设 S_FINAL 为 S[n]，但添加了矿工的区块奖励。

1.  8.

    检查状态 S_FINAL 的 Merkle 树根是否等于区块头中提供的最终状态根。如果是，区块有效；否则，区块无效。

这种方法可能看起来效率不高，因为它需要在每个区块中存储整个状态的副本。然而，实际上以太坊的效率与比特币相当。原因是状态是以树结构存储的，在每一个新块之后只需要调整树的小部分。因此，在一般情况下，相邻两个区块之间的树的大部分保持不变。因此，数据可以一次存储，并使用指针（即子树的哈希值）引用两次。一种特殊的树结构，称为*Patricia 树*，被用来实现这一点。它包括对 Merkle 树概念的一种修改，允许节点被有效地插入和删除，而不仅仅是更改。此外，由于所有状态信息都是上一个块的一部分，因此无需存储整个区块链历史——这种策略，如果应用于比特币，可以证明可以节省 5-20 倍的存储空间。

执行合约代码的过程是状态转换函数定义的一部分。后者是区块验证算法的一部分，所以如果将交易添加到区块 B 中，现在以及未来的所有节点都会执行由该交易触发的代码，下载并验证区块 B。

## 2.3 智能合约

“智能合约”这一概念最早是由 Nick Szabo 提出的[30]。Szabo 是一位法律学者和密码学家，以在数字货币基础方面的开创性工作而闻名。将合同以计算机代码的形式记录下来的想法是在[30]中提出的。提议的合约在满足某些条件时会自动激活。这个想法可能会消除需要信任的第三方公司。

2008 年，基于区块链网络的比特币加密货币被开发出来[25]。这项技术使得可以开发智能合约代码，用于将合同条款输入区块链。

在这种格式下，合约被转换成计算机代码，存储并在系统上复制，并由运行区块链的计算机网络监督。这导致了诸如转账货币和接收产品或服务之类的账本反馈。

2015 年，以太坊由 Buterin 创立，引入了第一个可工作的智能合约[10]。

一个*智能合约*是一组在区块链上运行的规则组成的计算机程序。区块链技术与智能合约的整合为开发和设计以及实现一些现实世界问题提供了灵活性。

目前区块链中使用的智能合约类似于实现传统纸质合同的脚本，通过代码行来实现。当满足某些条件时，智能合约执行代码。

智能合约允许两个彼此完全陌生的双方创建新的合同。只有在满足某些条件时，合同才生效。因此，智能合约的一个主要特征是它们能够无需中间人参与就签署和执行合同。

智能合约在许多区块链平台上实施，不仅在以太坊上。区块链是一个测试智能合约想法的理想环境。

每一个智能合约都是一个去中心化应用，它根据事件执行商业逻辑。智能合约的执行可能导致货币的交换、服务的交付、数字版权管理保护的内容的解锁或其他类型的数据操作，例如更改土地登记上的名字。智能合约还可以用于通过例如促进针对特定请求的隐私保护数据的的选择性释放来执行隐私保护。

可以采用多种架构用于开发、分发、管理和更新智能合约。合约可以存储在区块链或其他分布式账本技术上，并且可以集成到依赖比特币或其他加密货币的各种支付机制和数字交易所中。

智能合约并不是具有法律约束力的。它们的主要功能是按照预设的条件，程序化地执行包含在其中的各种任务、流程或交易。必须采取法律步骤将这种执行与各方之间的具有法律约束力的协议相链接。

智能合约是一种具有自我验证、自我执行、防篡改特性的计算机程序。智能合约帮助你以透明、无冲突的方式交换货币、财产、股份或任何有价值的东西，同时避免使用中间人服务。

智能合约可以像传统合同一样定义协议中的规则和处罚，并设想有助于自动执行这些义务的行动。智能合约的操作更像自动售货机，而不是法律实体。通过智能合约，你只需将比特币投入自动售货机（即账本）中，并提供你的驾照、密码或其他用于访问账户的身份证明。

### 2.3.1 智能合约的定义

智能合约是运行在以太坊区块链上的程序。它是一系列代码（其功能）和数据（其状态）的集合，位于以太坊区块链上的特定地址。

智能合约是以太坊的一种账户类型。这意味着它们有余额，并且可以在网络上发送交易。然而，它们不由用户控制，而是部署到网络上并按编程方式运行。用户账户可以通过提交执行智能合约上定义的功能的交易与智能合约互动。智能合约可以定义规则，就像普通的合同一样，并通过代码自动执行它们。智能合约默认情况下不能被删除，与它们的互动是不可逆的。

为了说明智能合约的操作，将其与自动售货机进行比较可能是有用的。像自动售货机一样，智能合约也接收适当的输入并生成某些输出。

例如，从自动售货机获取小吃的过程可以符号化为以下形式![](img/516136_1_En_2_Figo_HTML.png)

金钱加上小吃选择等于分发小吃

智能合约就像自动售货机一样，其中包含逻辑代码。以下是一个将同样的自动售货机表示为智能合约的示例。![](img/516136_1_En_2_Figp_HTML.png)

算法

自动售货机消除了售货员的需求。同样，智能合约可以在许多行业中取代中介。

每个人都可以编写智能合约并将其部署到网络上。只要学会用智能合约语言编程，并拥有足够的 ETH 来部署合约即可。部署智能合约技术上是一种交易，因此每个人都必须为部署智能合约支付燃料费，就像为简单的 ETH 转账支付燃料费一样。实际上，部署智能合约的燃料成本要高得多。

以太坊有以下几种对开发者友好的语言用于编写智能合约：

+   Solidity（上述自动售货机示例是用 Solidity 编写的）。

+   Vyper

用这些语言编写的程序在部署之前必须编译，以便以太坊虚拟机可以解释并存储合约。

### 2.3.2 智能合约是如何工作的？

创建智能合约的过程从业务团队与开发者合作描述智能合约在应对各种事件或情况时的预期行为开始。简单的事件可能是诸如支付授权、收到货物或公用事业表读数阈值等条件。更复杂的逻辑可能会编码更复杂的事件，如计算衍生金融工具的价值并处理衍生品的交易，或在人员死亡或自然灾害事件自动释放保险赔偿。

然后开发者在智能合约编写平台上工作，开发逻辑并测试它，以确保它按预期工作。应用程序编写完成后，它被交给另一支团队进行安全审查。这可能是一个内部专家或一家专门验证智能合约安全的公司。一旦合同获得批准，它将被部署在现有的区块链或其他分布式账本基础设施上。

每个部署的合同都被配置为监听来自预言机的事件更新，预言机是一个经过加密保护的流数据源。一旦智能合约从一台或多台预言机接收到适当的事件组合，它就会执行。

首先，合同的各方应该确定合同的条款。合同条款完成后，它们被转换成编程代码，如图 2.13 所示。该代码表示了许多不同的条件语句，描述了未来交易可能发生的各种场景 [11]。![](img/516136_1_En_2_Fig13_HTML.png)

插图描述如何将基于文本的正常合同转换为基于代码的智能合同。

图 2.13

第一步. 将合同条款转换成代码

当代码已经被创建时，它被存储在区块链网络中，并且如 图 2.14 所示，在区块链的参与者之间复制。![](img/516136_1_En_2_Fig14_HTML.png)

插图描述了存储在区块链中的代码如何被所有参与者复制到他们的副本中。合同连接到三个网络图像。

图 2.14

第二步. 代码存储在区块链中，并由所有参与者在他们的副本中复制

该代码由网络中的所有计算机运行和执行。如果合同的条件被满足，并且这一点被区块链网络的所有参与者验证，那么将执行相关交易，如图 2.15 所示。![](img/516136_1_En_2_Fig15_HTML.png)

插图描述当条款被满足时，网络中的计算机验证其正确性。三个网络以及联系图像由箭头连接。

图 2.15

第三步. 当一个条款被满足时，网络中的计算机验证其正确性

例如，假设一个用户打算从一个房东那里租一套公寓。用户可以通过区块链支付加密货币来完成这一过程。用户会收到一份收据，这份收据保存在我们的虚拟合约中。房东会给用户一个数字化的入门钥匙，钥匙会在指定日期前发送给用户。如果钥匙没有按时到达，智能合约可以被编程为退款。如果房东在租赁日期前发送钥匙，智能合约可以在日期到达时同时释放费用给房东和钥匙给用户。该系统可以作为一系列 If-Then 操作符的集合来运行。操作会被区块链网络上的数百人观察到。因此，所有参与者都可以期待无误的交货。如果房东给用户钥匙，房东必须得到支付。如果用户发送一定数量的比特币，那么用户就会收到钥匙。智能合约可以被编程在截止日期过后自动取消。由于区块链上的所有参与者在同一时间收到警报，因此房东或用户无法在未经其他网络节点知情的情况下干扰合约代码。

智能合约过程中有四个基本步骤。

+   **编码协议**。区块链使用计算机代码层代替传统的纸质文件。代码行代表合同条款并指示如何执行。这个过程保证了根据预编程条件特定结果的产生。随后，任何个人或组织都无法更改或操纵合同。

+   **事件**。事件指的是交易的发生。一旦满足了协议的条款和条件，代码就会自动执行智能合约。智能合约是由区块链节点执行的。

+   **价值交换**。在智能合约执行后，将进行价值交换。所谓的“价值”是预先确定的，并取决于使用情况。这个过程也是自动化的，无需人工干预。

+   **结算**。一旦交易或交换完成，记录就会被存储在区块链上。由于区块链的特性，交易会被传播到对等网络上的所有节点。因此，信息无法被篡改或伪造。

接下来，我们用自动售货机为例说明智能合约的过程。自动售货机内有许多预选的产品和货币输入源。基于算法运行，机器被编码为根据预先编程的一组规则自动产生结果。当投入货币并做出选择时，会释放一个物品。例如，假设拉里向售货机投入了 1.50 美元。他在键盘上选择了 B4，这是特定软饮料的数字表示。机器检查 1.50 美元是否与软饮料的价格相匹配并释放该物品。

只要满足预先指定的条件，用户与机器之间的合同义务得到履行，所需的操作随之进行。

### 2.3.3 如何编写智能合约？

智能合约是在以太坊上的地址上运行的程序。这些程序由数据和函数组成，可以在接收到交易时执行。以下是智能合约的组成部分概述。

#### 2.3.3.1 数据

合约数据必须分配给一个位置：要么是存储，要么是内存。在智能合约中修改存储的成本很高，所以你需要考虑你的数据应该存放在哪里。

#### 2.3.3.2 存储

在合约中的*持久数据*被称为*存储*，由状态变量表示。这些值永久存储在区块链账本上。用户需要声明变量的类型，以便在编译合约时，合约可以确定每个状态变量在区块链账本上所需的存储空间。![](img/516136_1_En_2_Figq_HTML.png)

Solidity 示例合约 Simple Storage 单元存储 Data 状态变量

地址类型可以包含以太坊地址，等于 20 个字节或 160 位。在十六进制表示法中，其值以引导的 0x 开头。其他类型包括：

+   布尔值

+   整数

+   固定小数点数

+   固定大小的字节数组

+   动态大小的字节数组

+   理性数和整数字面量

+   字符串字面量

+   十六进制字面量

+   枚举

#### 2.3.3.3 内存

仅在合约函数执行期间存储的值称为*内存变量*。它们不会永久存储在区块链上，使用起来要便宜得多。

#### 2.3.3.4 环境变量

除了在合约中定义的变量外，还存在特殊的全局变量。它们主要用于提供关于区块链或当前交易的信息。

| 属性 | 状态变量 | 描述 |
| --- | --- | --- |
| block.timestamp | uint256 | 当前区块的时间戳 |
| msg.sender | 地址 | 消息发送者（当前调用） |

#### 2.3.3.5 函数

函数可以获取信息或设置信息以响应传入的交易。有两种类型的函数调用。

+   internal—这些不会创建 EVM 调用

    +   内部函数和状态变量只能内部访问（即在当前合约或派生自它的合约内访问）。

+   外部—这些会创建 EVM 调用

    +   外部函数是合约接口的一部分，这意味着它们可以从其他合约和交易中调用。外部函数 f 不能内部调用（即 f() 不工作，但 this.f() 工作）。

函数也可以被分类为公共或私有。

+   公共函数可以通过消息在合约内部或外部调用。

+   私有函数仅对定义它们的合约可见，而在派生合约中不可见。

函数和状态变量都可以设置为公共或私有。

这是一个用于在合约上更新状态变量的函数。![](img/516136_1_En_2_Figr_HTML.png)

Solidity 示例函数 updateName(string value)public dapp name 等于 value

+   类型为字符串的参数值传递给函数：update_name。

+   它被声明为公共的，意味着任何人都可以访问它。

+   它没有被声明为视图，所以它可以修改合约状态。

**视图函数**：视图函数承诺不修改合约数据的状态。常见的例子是“获取器”函数。例如，您可以使用以下函数来接收用户的余额。![](img/516136_1_En_2_Figs_HTML.png)

Solidity 示例函数 balanceOf(address owner)public view returns(uint256 balance) return owner Pizza Count [owner]

以下是一份被视为状态修改的事件列表：

1.  1.

    写入状态变量，

1.  2.

    发射事件，

1.  3.

    创建其他合约，

1.  4.

    使用 selfdestruct，

1.  5.

    通过调用发送以太币，

1.  6.

    调用任何未标记为 view 或 pure 的函数，

1.  7.

    使用低级调用，

1.  8.

    使用包含某些操作码的内联汇编。

**构造函数** 在合约首次部署时只执行一次。与许多基于类的编程语言中的构造函数类似，这些函数通常将状态变量初始化为它们的指定值。![](img/516136_1_En_2_Figt_HTML.png)

一个算法

**内置函数**。除了在您的合约上定义的变量和函数外，还有一些特殊的内置函数。最明显的例子是在 Solidity 中：address.send()，它允许合约将 ETH 发送到其他账户。

**带有逐行解释的智能合约**。编写智能合约需要一种编程语言。以太坊核心贡献者发明了一种名为 Solidity 的编程语言来编写智能合约，可以将其视为在区块链上运行的计算机程序。Solidity 是一种高级面向对象的编程语言，灵感来自 JavaScript、C++和 Python。Solidity 的语法与 JavaScript 非常相似。还有其他区块链和以太坊分叉支持 Solidity。此类区块链的一个示例是 Tron。程序员不仅可以使用 Solidity 编写智能合约，但现在它是最受欢迎的一种。

要编写智能合约函数，需要指定与函数相关的以下信息

+   参数变量及其类型，如果函数接受参数，

+   内部/外部变量的声明，

+   纯/视图/可支付的声明，

+   如果函数返回一个值，返回类型，

下面是一个 solidity 智能合约的简单示例！[](../images/516136_1_En_2_Chapter/516136_1_En_2_Figu_HTML.png)

算法

上面的代码是一个用 Solidity 语言编写的智能合约。接下来，我们将描述这个智能合约示例中每行代码的动作。

第一行声明了可以用来编译合约的 Solidity 编译器的版本。在我们的示例中，任何介于![$$\ge $$](img/516136_1_En_2_Chapter_TeX_IEq7.png)0.4.0 和![$$\le $$](img/516136_1_En_2_Chapter_TeX_IEq8.png)0.7.0 之间的版本都是合适的。

第二行声明了合约，并将其命名为 inventoryInfo。通常做法是使用与合约名称相同的文件名。例如，这个合约将保存在一个名为 inventoryInfo.sol 的文件中（.sol 是 solidity 智能合约的文件扩展名）。

第三行声明了一个名为 numberInStock 的 uint（无符号整数）变量。这个变量用于存储数据。

第 4 至 6 行添加了一个设置函数，使用该函数可以更改变量 numberInStock 的值。在此，设置函数接受一个参数*x*，并将其值存储在 numberInStock 中。该函数被标记为 public，这意味着任何人都可以调用它。

第 7 至 9 行添加了一个获取函数，用于检索 numberInStock 的值。这个函数被标记为视图函数，告诉 solidity 编译器这是一个只读函数。获取函数还有 uint 返回类型，这意味着函数将返回一个 uint。

### 2.3.4 去中心化应用（DApp）是什么？

去中心化应用（dapp）是建立在去中心化网络上的应用。dapp 将智能合约和前端用户界面结合在一起。以太坊智能合约像开放的应用程序编程接口一样可访问和透明。因此，dapp 也可以包括其他程序员编写的智能合约。每个 dapp 都有其后端代码在去中心化的点对点网络上运行。

一个 DApp 可以有使用任何语言编写的前端代码和用户界面（就像一个应用程序一样）来调用其后端。此外，它的前端可以托管在如 IPFS 的去中心化存储上。

+   **去中心化**的 DApp 运行在以太坊上，这是一个开放的公共去中心化平台，没有人或团体能够掌控。

+   **确定性**。无论在何种环境中执行，确定性的 DApp 都会执行相同的功能。

+   **图灵完备**的 DApp 可以提供所需的资源执行任何动作。

+   **隔离性**。DApp 在称为以太坊虚拟机（EVM）的虚拟环境中执行，这样如果智能合约有漏洞，它不会阻碍区块链网络的正常运行。

#### 2.3.4.1 DApp 开发的优点

+   **零停机时间**。一旦智能合约部署在区块链上，整个网络总能服务于希望与合约互动的客户。因此，恶意行为者无法针对个别 DApp 发起拒绝服务攻击。

+   **隐私保护**。您无需提供现实世界的身份信息即可部署或与去中心化应用（DApp）互动。

+   **抵抗审查**。网络上的任何单一实体都无法阻止用户提交交易、部署 DApp 或从区块链读取数据。

+   **完全的数据完整性**。存储在区块链上的数据由于加密原语的支持而不可篡改且不容争议。恶意行为者无法伪造已经公开的交易或其他数据。

+   **无需信任的计算/可验证行为**。智能合约可以被分析，并保证以可预测的方式执行，无需信任中央权威。这在传统模型中是不成立的；例如，当我们使用在线银行系统时，我们必须信任金融机构不会误用我们的财务数据、篡改记录或遭受黑客攻击。

#### 2.3.4.2 DApp 开发的缺点

+   **维护**。DApp 的维护可能更加困难，因为发布到区块链账本上的代码和数据更难以修改。即使在新版本中发现漏洞或安全风险，开发者也很难对其 DApp 或其 DApp 存储的基础数据进行更新。

+   **性能开销**。存在巨大的性能开销，并且扩展非常困难。为了达到以太坊所追求的安全性、完整性、透明性和可靠性，每个节点都运行并存储每一笔交易。此外，工作量证明也需要时间。因此，许多 DApp 计算的开销大约是普通应用程序标准计算的![$$10⁶\times $$](img/516136_1_En_2_Chapter_TeX_IEq9.png)。

+   **网络拥堵**。当一个 dapp 使用过多的计算资源时，整个网络都会出现拥堵。目前，网络每秒只能处理大约 10-15 笔交易；如果交易发送速度超过这个限制，未确认交易池会迅速膨胀。

+   **用户体验**。由于普通最终用户可能发现设置与区块链安全互动所需的工具堆栈过于困难，因此可能更难工程化用户友好的体验。

+   **中心化**。建立在以太坊基础层之上的用户友好和开发者友好的解决方案可能会最终看起来像中心化服务。例如，这类服务可能会在服务器端存储密钥或其他敏感信息，使用中心化服务器提供前端，或在向区块链写入数据之前在中心化服务器上运行重要的业务逻辑。这种中心化可能会消除区块链相对于传统模型的许多甚至所有优势。

### 2.3.5 局限性和未来发展趋势

智能合约并不能完美解决传统合同的所有问题。特别是，它们无法从区块链账本外部获取当前信息。因此，用户在验证智能合约条件是否满足的过程中可能遇到问题。例如，假设有一个以下条件的合同：“如果 ETH 的价格超过 1000 美元，A 向 B 提供 1 ETH。”在这里，智能合约只有在以太坊价格超过 1000 美元或低于 1000 美元的信息可用时才能运行。因此，只有在从加密货币交易所获取准确的以太坊价格数据时，合同才能执行，而这份数据位于区块链账本外部。

在检索过程中，可能会检索到错误的数据，或者数据可能被故意篡改。换句话说，需要检索有关特定条件的特定信息，如果这份信息依赖于第三方，这不可避免地导致信誉问题。为了解决这一固有问题，许多初创公司正在努力提供生成和执行智能合约所需的准确信息。

智能合约的另一个固有限制是，一旦部署，它们就无法编辑。一方面，这种僵化正是使智能合约安全可靠的原因。另一方面，这也可能变成可以被利用的潜在弱点。有案例中，智能合约因为这一特性被黑客攻击或永久性功能失效，最突出的案例是 SmartMesh。SmartMesh 团队分发的智能合约包含一个安全漏洞，黑客利用它发行/出售额外的代币。还有案例中，由于这个安全漏洞，包含在钱包中的 513.774.16ETH 变得永久无法提取。

智能合约直接处理数字货币。因此，在开发智能合约时，安全性是首要考虑的。在区块链行业中，分发前进行安全审计已成为一项标准程序。可能需要进行特殊的网络安全审计，以确保智能合约提供的安全保证。

智能合约的潜力远不止于加密货币的简单转移，因为智能合约要复杂得多。它们可以在广泛领域执行交易，从法律程序到保险费到众筹协议，再到金融衍生品。智能合约有可能通过简化并自动化目前人们支付银行和律师巨额费用处理的常规和重复性流程，中介法律和金融领域。

随着智能合约获得广泛的能力，律师的角色也可能会在未来得到调整，他们可以贡献于传统法律协议和可定制的智能合约模板的功能。此外，智能合约不仅能自动化流程，还能控制行为，以及它们实时审计和风险评估的潜力，对合规性有益。

智能合约在自动化物联网和边缘计算设备上运行的流程也显示出潜力。例如，一家公用事业公司可能会提供一项服务，智能合约根据电价的变化与内置在电表中的设备协同执行。例如，当价格达到某个阈值时，智能合约可能会自动关闭或降低空调等耗电设备的电力，使用专门的物联网控制器进行控制。

将来也有可能将智能合约集成到能够响应加密货币支付释放商品的自动售货机中。

在供应链场景中，智能合约可能在货物集装箱到达目的地并且物联网传感器表明它保持未开启状态，以及内容保持正确的温度和适当的湿度时解锁资金。

## 2.4 区块链类型

存在对区块链类型进行各种分类，有时这些分类是冲突的。本节重点介绍根据网络节点作为验证者所需的授权类型对区块链系统进行分类。区块链系统可以分为三大类，如图 2.16 所示。![](img/516136_1_En_2_Fig16_HTML.png)

一个维恩图将公共置于第一圈，私有和联盟置于第二圈。交集处是混合型。第一圈标题为无需许可，第二圈为需要许可。

图 2.16

三种主要的区块链类型

+   **无许可区块链**，任何人都可以参与验证过程，也就是说，不需要事先授权。所有用户都可以参与共识过程，例如，通过贡献他们的计算资源，通常会得到货币奖励。

+   **许可区块链**，验证节点由中心机构或联盟预先选择。

+   **混合区块链**，结合了无许可和许可区块链的某些特性。

实际上，大多数无许可区块链提供了公共访问设施，而大多数许可区块链的意图是将数据访问限制在运行区块链的公司或公司联盟内。为此原因，接下来我们将查看区块链的主要类别，无许可和许可区块链，并在以下章节中详细阐述它们之间的区别。

### 2.4.1 无许可区块链

加密货币的原始实例，比特币网络，通过使用无许可区块链实现了高度流行。"许可"这个词指的是节点的授权验证。在无许可的区块链中，每个人都被允许加入网络成为验证者，而无需为执行此类网络任务获得任何事先的许可。验证者的行为对网络的运行至关重要，因此，通过发行新货币并将其支付给验证者完成交易块的确认来鼓励他们的参与。

无许可区块链的优势[29]在于它可以容纳匿名或伪匿名参与者，并保护免受 Sybil（即身份伪造）攻击[13]。另一方面，必须仔细开发激励机制，以确保验证者被适当地激励参与系统的工作。例如，在比特币中，验证者会收到一笔费用用于验证每笔交易，以及发布一个交易块。然而，后者的激励比前者奖励高两个数量级。由于发布交易块的激励根据预定义的计划减少，因此可以推断，经过一段时间后，验证者必须提高他们为处理个别交易收取的费用。这使得比特币交易更加昂贵。

除了比特币，还有很多其他无许可区块链的例子，包括以太坊。以太坊平台提供区块链即服务，并为其区块链提供对智能合约的访问。其他无许可区块链的例子在[3, 7, 22]中提出。关于无许可区块链的新结果也出现了，例如在[17–19]中。

### 2.4.2 许可区块链

尽管非许可区块链非常流行，但它们并不是区块链系统可能配置的唯一选项。许可区块链让一组可信的各方执行验证工作。只有在现有成员或中央权威的同意下，基于协议才能添加额外的验证者。这种具有集中权限的配置与传统金融设置更为相似，后者运行了解你的业务（KYB）或了解你的客户（KYC）程序，以将允许在特定空间进行操作的用户列入白名单。论文[29]解释了非许可和许可区块链在操作和它们所启用的活动范围上根本不同。接下来，我们回顾它们的主要区别。

许可区块链旨在为特定目的而建立。它们可以创建以与现有应用程序保持兼容，例如，财务应用程序。许可区块链可以是完全私有的，写入数据的权限属于所有者或管理组织。或者，它们可以是联盟链，共识过程由联盟中预选的一组节点控制。

由于许可区块链中的所有行动节点都是预先批准并知的，自然可以期待他们对网络上的活动和行为个人承担责任。就这些区块链处理的交易而言，通常它们主要处理链下资产，如证券的数字表示、法定货币和所有权证明，而不是链上资产，如虚拟货币代币[29]。

许可区块链的一个优势是其可扩展性。在非许可区块链中，数据存储在网络中的每一台计算机上，所有节点都要验证所有交易。很明显，一旦交易数量显著增加，用户进行这种处理和验证的能力就会下降。这可能导致更高的集中度，因为验证过程变得更加困难。在许可区块链中，只有少量预先选定的参与者需要充当验证者。即使验证者在大型机构中选出，他们也可以升级计算能力以满足随着交易数量增加而增加的要求。

在许可区块链中，潜在的验证者和可能参与者数量较少。因此，一组用户更容易协作，根据需要更改规则或撤销交易。此外，他们很容易拒绝交易。这意味着许可区块链不能像非许可区块链那样有效地抵抗审查。

#### 2.4.2.1 私有区块链

私有链也可以被称为受管理的链。它们是由单个所有者或组织控制的权限链。每个私有链都有一个中心权威决定谁被允许加入作为一个节点。中心权威也不一定授予每个节点执行区块链功能的平等权利。私有链只是部分去中心化，因为这些链的公共访问是受限的。私有链的例子包括企业对企业虚拟货币交换网络 Ripple 和 Hyperledger，一个开源区块链应用的伞形项目。

私有链的特点意味着区块链的所有者具有最高的权威，可能有能力更改账本中存储的信息。私有链应用于更封闭的网络，例如一个组织的内部网。开发私有链的新贡献已经出现，例如[4, 5, 8]。

私有链和公链都有其缺点。与私有链相比，公链对于新数据项的验证时间更长。私有链更容易受到数据审查和潜在的来自行为不当的管理角色的攻击。联盟链和混合链是为了克服这些缺点而开发的。

#### 2.4.2.2 联盟链

联盟链是由一组组织管理的权限链，而不是一个实体，这与私有链的情况不同。因此，与私有链相比，联盟链享有更广泛的去中心化。这导致了更高的安全性。然而，建立联盟链的过程可能充满困难，因为它需要多个组织的合作，这可能带来后勤挑战以及创建反垄断风险的潜在风险。

此外，联盟链的一些成员可能没有实施基本区块链工具所需的必要技术或基础设施。其他成员可能决定，试图数字化他们的数据并连接到区块链的其他成员的前期成本过高。

联盟链可以用于管理电子学习教育记录，例如[2]，农业供应链[15]，医疗信息共享[14]，无线网络中的匿名交接认证[23]，健康信息系统中的受保护数据共享[27]以及符合通用数据保护条例的数据共享[26]。对联盟链及其应用的新研究已经进行，例如[1, 20, 21]。

### 2.4.3 混合链

混合型区块链结合了不同类别区块链的多种特性。它们可能由一个单一组织控制，但同时具有由典型公共区块链承担的监督级别，后者需要执行某些交易验证。混合型区块链的一个例子是 IBM 食品信任网络，该网络旨在提高整个食品供应链的效率和吞吐量。

最近，混合型区块链已经被用于例如医疗监控和推荐系统[28]、组织拍卖[9]、身份管理[6]、可追溯的联邦学习[12]、能源应用[16]、基本数据与业务数据的分离[24]等领域。
