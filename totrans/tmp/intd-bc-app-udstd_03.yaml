- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_3](https://doi.org/10.1007/978-1-4842-7480-4_3)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（或作者），在Springer Nature的APress Media, LLC独家许可下 2022J. T. George介绍区块链应用[https://doi.org/10.1007/978-1-4842-7480-4_3](https://doi.org/10.1007/978-1-4842-7480-4_3)
- en: 3. Bitcoin
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 比特币
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 约瑟夫·塔奇尔·乔治^([1](#Aff2)  )(1)意大利罗马
- en: In the previous chapter, you saw how blockchain technology, without the need
    for a central authority, and thanks to the techniques and algorithms discussed,
    can establish trust between participants and certify the *immutability* of a distributed
    ledger. The blockchain lends itself to being an ideal model for digital currencies,
    where there is no need for intermediaries and third parties such as banks, insurance
    companies, and other central organizations. In fact, blockchain was born and spread
    thanks to Bitcoin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了区块链技术如何在不需要中央机构的情况下，并借助所讨论的技术和算法，建立参与者之间的信任，并证明了分布式账本的*不可变性*。区块链非常适合作为数字货币的理想模型，其中不需要中介和银行、保险公司等中央组织。事实上，区块链的诞生和传播归功于比特币。
- en: In 2008, a person (or group of persons) named Satoshi Nakamoto released a research
    paper entitled “Peer-to-Peer Electronic Cash System in Bitcoin.” This paper described
    a peer-to-peer cash system that permitted network transactions to be sent directly
    from one part to another without going through any intermediaries/banking organizations.
    It explains Bitcoins in great detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，一名名为中本聪（或一组人）的人发布了一篇名为《比特币中的点对点电子现金系统》的研究论文。这篇论文描述了一个允许网络交易直接从一方发送到另一方而无需经过任何中介/银行组织的点对点现金系统。它对比特币进行了详细解释。
- en: The term cryptocurrency describes all the systems, networks, and media that
    use cryptography to protect digital transactions, compared to those systems where
    transactions are managed through a common trusted entity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币这个术语描述了所有使用密码学保护数字交易的系统、网络和媒体，与那些通过共同信任实体管理交易的系统相比。
- en: This chapter covers the *Bitcoin protocol*. It analyzes in detail the main parts
    that compose it—the public and private keys, the Bitcoin addresses, and the blocks.
    The chapter then illustrates the network and consensus mechanisms, including the
    proof of work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*比特币协议*。它详细分析了组成它的主要部分——公钥和私钥、比特币地址和区块。该章节还说明了网络和共识机制，包括工作证明。
- en: 3.1 The History of Bitcoin
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 比特币的历史
- en: Almost all of the technological parts of Bitcoin were born in academic publications
    of the 1980s and 1990s. “We need to emphasis that our aim is not to reduce the
    work and success of Nakamoto, but only to emphasize what the real leap of intuition
    was. Indeed, by tracking the initial of ideas present in Bitcoin, we can focus
    on the specific and complex way they come put together the underlying components”.^([1](#Fn1))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有比特币技术部分都诞生于1980年代和1990年代的学术出版物。“我们需要强调的是，我们的目标不是为了减少中本聪的工作和成功，而只是为了强调真正的直觉飞跃是什么。事实上，通过追踪比特币中存在的初始思想，我们可以专注于它们如何以特定和复杂的方式将底层组件组合在一起。”^([1](#Fn1))
- en: Bitcoin’s history doubles as a case study, as it proves relationships between
    the academic world, external scientists, engineers, and professionals and shows
    on how these teams can gain knowledge from each other. Many professionals have
    studied Bitcoin and have produced numerous research papers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的历史同时也是一个案例研究，它证明了学术界、外部科学家、工程师和专业人士之间的关系，并展示了这些团队如何相互获取知识。许多专业人士已经研究了比特币，并发表了大量的研究论文。
- en: Note that the ledger idea is the initial starting point for Bitcoin. If you
    understand the ledger, you will understand the system’s structure and its communication.
    The ledger is the place where all the transactions take place. It’s open and trusted
    by all parties and components in the system (see Figure [3-1](#Fig1)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig1_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig1_HTML.jpg)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，账本思想是比特币的初始起点。如果你理解了账本，你就会理解系统的结构及其通信。账本是所有交易发生的地方。它是公开的，并被系统中的所有方和组件信任（见图[3-1](#Fig1)）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig1_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig1_HTML.jpg)
- en: Figure 3-1
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1
- en: The main ideas behind Bitcoin
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特币的主要思想**'
- en: 'In order to support a digital currency, the ledger must have these fundamental
    properties:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持数字货币，账本必须具有这些基本属性：
- en: '**Append-only:** It is only possible to add new transactions to the ledger.
    It is not possible to abandon, modify, or reorder the existing ledger.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅追加：**只能向账本中添加新的交易。不可能放弃、修改或重新排序现有的账本。'
- en: '**Immutable:** The information present cannot be changed in the ledger.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性：**账本中的信息无法更改。'
- en: '**Prevents double spending:** It is not possible to spend the same currency
    security more than once.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止双重花费：**不可能花费相同的货币安全超过一次。'
- en: 3.1.1 Linked Timestamping and the Merkle Tree
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 连接时间戳和 Merkle 树
- en: The Bitcoin ledgers data architecture is taken, with appropriate changes, from
    several articles by Stuart Haber and Scott Stornetta (1990 and 1997)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币账本的数据架构是从 Stuart Haber 和 Scott Stornetta（1990年和1997年）的几篇文章中取得的，经过适当的修改。
- en: As we know well, since Nakamoto states it in the paper on Bitcoin, the Haber
    and Stornetta’s paper dealt with the timestamp issue for documents. Note that
    when it comes to commercial contracts, patents, and other documents, it is possible
    to determine that the document was generated at given point of time. We understand
    that their notion of a documents are quite generic, and it can include different
    types of data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，自从中本聪在比特币论文中声明过，Haber 和 Stornetta 的论文处理了文档的时间戳问题。请注意，当涉及商业合同、专利和其他文件时，可以确定文档是在特定时间点生成的。我们理解他们对文档的概念是相当通用的，它可以包括不同类型的数据。
- en: They casually mentioned banking transactions as a possible application, but
    note that this was not their goal. The originator of every document confirms the
    time of generation and signs the document, its date, and time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 他们随意提到银行交易可能是一个应用场景，但请注意，这并不是他们的目标。每个文档的发起者确认生成的时间并签署文档、其日期和时间。
- en: This initial document was approved/signed by the creator, so the document forms
    a lengthy chain with pointers into the past. A third-party user cannot edit a
    timestamped message because it is approved by its originator, and moreover the
    originator or the creator cannot edit the message without changing the entire
    subsequent chain of message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最初的文档是由创建者批准/签署的，因此文档形成了一个指向过去的长链。第三方用户无法编辑时间戳消息，因为它是由其发起者批准的，而且创建者或发起者不能编辑消息而不改变整个后续消息链。
- en: 'Haber and Stornetta also mentioned in their articles several ideas to make
    this data structure more fast, effective, and accurate:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Haber 和 Stornetta 在他们的文章中还提到了一些想法，使这种数据结构更快、更有效和更准确：
- en: The chain between documents can be created by using hashes instead of signatures;
    note that these hashes are easier and faster to compute and are stronger when
    it comes to data identifiers. We call such links *pointers* .
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档之间的链可以通过使用哈希而不是签名来创建；请注意，这些哈希更容易、更快速地计算，并且在数据标识符方面更强大。我们称这样的链接为 *指针*。
- en: Rather than timestamping documents separately, which could be inefficient if
    many documents are generated at once, the documents can be combined into batches
    or blocks, using the same timestamp in the documents.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其单独为文档加时间戳，如果一次生成了许多文档，这可能效率低下，不如将文档合并成批或块，使用相同的时间戳在文档中。
- en: The documents in each block should be tied by a binary tree of hash pointers
    called the *Merkle tree*. Mr. Josh Benaloh and Mr. Michael de Mare presented these
    ideas independently in 1991, immediately after Haber’s article.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块中的文档应该由一个称为 *默克尔树* 的哈希指针二叉树绑定。乔希·贝纳洛先生和迈克尔·德·马尔先生在哈伯的文章发表后立即在1991年独立提出了这些想法。
- en: Note that the Merkle trees are named after Ralph Merkle, who presented the asymmetric
    cryptography logic in his 1980 document.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默克尔树是以拉尔夫·默克尔命名的，他在他的1980年文件中提出了非对称加密逻辑。
- en: Either way, Bitcoin takes the data structure from the work of Haber and Stornetta
    and redesigns its safety characteristics with the addition of the PoW scheme.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，比特币都从 Haber 和 Stornetta 的工作中借鉴了数据结构，并通过添加 PoW 方案重新设计了其安全特性。
- en: 3.1.2 Distributed Consensus
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 分布式共识
- en: A common authority is required for Internet money or currency transactions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网货币或货币交易需要一个共同的权威机构。
- en: In the case of a distributed ledger, you can see that there will automatically
    be forks, which means that some nodes will conclude that block A is the last block,
    whereas all other nodes will conclude that it is block B.^([2](#Fn2))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式账本的情况下，您会发现会自动出现分叉，这意味着一些节点将得出结论认为区块 A 是最新的区块，而所有其他节点都会得出结论认为是区块 B。^([2](#Fn2))
- en: In this case, you need to understand that this is due to an opponent trying
    to interrupt the transaction of the ledger or because of the network delay, occasionally
    causing near-block generation together from different nodes, unaware of reciprocal
    blocks. The linked timestamp is not sufficient to rectify the forks, and this
    is expressed by Mike in 1997-1998.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您需要了解这是因为对手试图中断账本交易还是因为网络延迟，偶尔会导致来自不同节点的几乎同时产生的区块，不知道相互之间的区块。链接的时间戳不足以纠正分叉，这是由
    Mike 在 1997-1998 年提出的。
- en: The problem of how to reach consensus in situations where errors are possible
    is called the *Byzantine generals problem* *.* It was talked about informally
    in Chapter [2](520777_1_En_2_Chapter.xhtml). Byzantine faults include both natural
    breakdowns and malicious behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能出现错误的情况下达成共识的问题称为 *拜占庭将军问题*。它在第 [2](520777_1_En_2_Chapter.xhtml) 章中非正式地讨论过。拜占庭故障包括自然故障和恶意行为。
- en: This idea was initially discussed in an article by Leslie Lamport, written with
    Robert & Marshall in 1982\. In 1999, a document from Miguel Castro & Barbara Liskov
    presented the PBFT algorithm, and this enables you to solve the problem of Byzantine
    generals with excellent performance. (Note that the PBFT stands for Practical
    Byzantine Fault Tolerance.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法最初在 Leslie Lamport 与 Robert & Marshall 1982 年的一篇文章中讨论过。1999 年，Miguel Castro
    & Barbara Liskov 的一份文件提出了 PBFT 算法，这使您能够以出色的性能解决拜占庭将军问题。（请注意，PBFT 代表实用拜占庭容错。）
- en: The replication algorithm can manage the Byzantine defects. Byzantine fault-tolerant
    algorithms will become increasingly important in the near future, because as malicious
    attacks and software bugs become very common in the cyber world, this can cause
    faulty nodes to promote arbitrary behaviors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 复制算法可以处理拜占庭缺陷。拜占庭容错算法在不久的将来将变得越来越重要，因为恶意攻击和软件缺陷在网络世界中变得非常普遍，这可能导致有缺陷的节点促使任意行为。
- en: But in the case of the previous algorithms, they needed a special synchronous
    system and were slow. The algorithm described in this book is very practical,
    because it works in asynchronous environments quickly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在以前的算法中，它们需要一个特殊的同步系统，并且速度很慢。本书描述的算法非常实用，因为它在异步环境中快速运行。
- en: Nakamoto doesn’t cite the same article in his initial paper, nor does he utilize
    his phrasing. However, he employs some concepts, referring to his own protocol
    as a consensus protocol and taking into account both faults in the form of intruders,
    as well as nodes joining and exiting the infrastructure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 中本聪在他最初的论文中没有引用同一篇文章，也没有使用他的措辞。然而，他运用了一些概念，将自己的协议称为共识协议，并考虑了形式上的入侵者的故障，以及加入和退出基础设施的节点。
- en: When asked about the connection between Bitcoin and the Byzantine generals problem
    on a mailing list, Nakamoto claims that the Proof-of-Work (PoW) chain fixes the
    issue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及比特币与拜占庭将军问题之间的联系时，中本聪在一个邮件列表上声称，工作证明（PoW）链解决了这个问题。
- en: Almost all failure systems assume that the majority of the nodes in the system
    are both trustworthy and honest (e.g., more than half or two-thirds). Nodes in
    an open peer-to-peer network are free to join and leave at any time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的失败系统都假设系统中大多数节点都是值得信赖和诚实的（例如，超过一半或三分之二）。开放的点对点网络中的节点可以随时加入和退出。
- en: As a result, a Sybil attack can be used to go around the system’s consent or
    quality assurances. John Douceur defined the Sybil attack in 2002 and proposed
    a cryptographic breakthrough called Proof of Work to combat it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，蚁人攻击可以用来绕过系统的同意或质量保证。约翰·杜塞尔（John Douceur）在2002年定义了蚁人攻击，并提出了一种称为工作证明（Proof
    of Work）的密码学突破来对抗它。
- en: 3.2 Proof of Work
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 工作证明
- en: This section goes over the first phases of Proof of Work so you can get a better
    understanding of it. Cynthia Dwork and Moni Naor created the first proposal, which
    was titled “Proof of Work,” in 1992\. Their purpose at the time was to discourage
    spam.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了工作证明的第一个阶段，以便您更好地理解它。辛西娅·德沃克（Cynthia Dwork）和莫尼·纳奥尔（Moni Naor）在1992年创建了第一个提议，标题为“工作证明”。当时他们的目的是阻止垃圾邮件。
- en: For example, the Hashcash is a proof-of-work method that has been employed in
    a variety of systems as a denial-of-service countermeasure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，哈希现金是一种在各种系统中作为防止服务拒绝的措施而被采用的工作证明方法。
- en: A hashcash stamp is a proof-of-work that takes the sender a parameterizable
    amount of time to compute. The recipient may quickly check the hashcash stamps
    he or she has received.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希现金邮票是一个需要发送者计算可参数化时间的工作证明。收件人可以快速检查他或她收到的哈希现金邮票。
- en: While hashcash was designed to add a penalty to sending email in order to prevent
    high-volume email spammers, it may now be introduced to any internet service to
    impose a computational cost on customers who might otherwise misuse a server’s
    resources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然哈希现金的设计是为了对发送电子邮件进行处罚，以防止大量的电子邮件垃圾邮件，但现在它可能被引入到任何互联网服务中，以对可能滥用服务器资源的客户施加计算成本。
- en: However, a spammer who wanted to transmit a million emails might need multiple
    weeks to do it using a similar approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个想要传输一百万封电子邮件的垃圾邮件发送者可能需要数周时间来使用类似的方法。
- en: Occasionally, the Proof-of-Work instance (also known as a *puzzle*) is required
    to identify the email and the recipient.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，需要工作证明实例（也称为*难题*）来识别电子邮件和收件人。
- en: A spammer may otherwise send many messages to the same recipient (or the same
    message to multiple recipients) for the cost of only sending one message to one
    receiver. The second critical feature is that the recipient’s computing cost should
    be as minimal as feasible; puzzle answers, no matter how complex to compute, should
    be straightforward to check.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，垃圾邮件发送者可能向同一收件人发送多条消息（或向多个收件人发送相同消息），但只需支付向一个接收者发送一条消息的费用。第二个关键特性是接收者的计算成本应尽可能低；无论计算多么复杂，谜题的答案都应易于检查。
- en: Dwork and Naor’s suggestion spawned an entire field of inquiry. Adam Back, a
    post-doc in the cypherpunk research community at the time, separately devised
    a similar concept called hashcash in 1997.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Dwork 和 Naor 的建议引发了整个探索领域。当时的密码朋克研究社区的博士后 Adam Back 分别在 1997 年设计了一个名为 hashcash
    的类似概念。
- en: '*Cypherpunks* were anti-government and anti-centralized institution activists
    who used encryption to bring about social and political change.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码朋克*是反政府和反中心化机构的活动人士，他们使用加密来带来社会和政治变革。'
- en: Hashcash is nothing more than a proof-of-work algorithm; it was used as a measure
    against spam and denial-of-service attacks in different systems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Hashcash 不过是一个工作量证明算法；它被用作防止不同系统中的垃圾邮件和拒绝服务攻击的措施。
- en: 'It is based on a simple principle connected to the hash function: the only
    way to identify an input that has a hash on a given output is to test various
    inputs until the desired data is provided in a hash function. As a result, the
    only method to identify an input that hashes in one arbitrary series of outputs
    is to try hashing different inputs, one after the other.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于与哈希函数相关的简单原理：唯一识别具有给定输出的哈希的输入的方法是测试各种输入，直到提供所需数据为止。因此，唯一识别将哈希在一个任意系列的输出中的输入的方法是尝试不同的输入，一个接一个地哈希。
- en: 3.2.1 Nakamoto’s Genius
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 中本聪的天才
- en: Understanding all of the predecessors that comprise elements of the Bitcoin
    design leads to an appreciate of Nakamoto’s truly great discoveries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 了解构成比特币设计要素的所有前任将使人欣赏到中本聪真正伟大的发现。
- en: Proof-of-Work (PoW) is used to protect the book master or ledger. Proof-of-work
    resolution is done by miners.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（Proof-of-Work，PoW）用于保护账本的主人或分类账。工作量证明的解决由矿工完成。
- en: Each miner solves a slightly different form of the challenge; thus the odds
    of success are proportional to the fraction of the world’s processing power that
    the miner owns. A miner who solves a problem can donate a new transaction block
    to the ledger, which is added to the ledger depending on the timestamp.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矿工解决的挑战形式略有不同；因此成功的几率与矿工拥有的世界处理能力的比例成正比。解决问题的矿工可以向分类账捐赠一个新的交易块，该交易块将根据时间戳添加到分类账中。
- en: A prospector who contributes a block is paid with units of recently produced
    coin in exchange for maintaining the ledger. If a prospector contributes to an
    invalid block or a transaction, it will most likely be eliminated by the majority
    of other prospectors who contribute to succeeding blocks, invalidating the block
    reward for the wrong block.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 贡献一个区块的探矿者将以最近产出的币单位作为酬劳，来维护分类帐。如果一个探矿者贡献了一个无效的区块或交易，那么它很可能会被贡献给连续区块的大多数其他探矿者所淘汰，使错误区块的区块奖励无效。
- en: Miners are mutually insured in this way, thanks to monetary incentives.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工们以这种方式相互保险，这要归功于货币激励。
- en: Instead of the sophisticated method used to bring the computer system, Nakamoto’s
    genius is one of the individual components of Bitcoin.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于构建计算机系统的复杂方法不同，中本聪的天才体现在比特币的个别组件之一。
- en: Nobody thought of encouraging the knots to be truthful. No one has thought of
    using a consent algorithm to avoid the twofold cost.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人考虑鼓励结点保持真实。没有人考虑使用同意算法来避免双重成本。
- en: To eliminate duplicate spending and ensure that the currency has value, Bitcoin
    requires a secure ledger. Miners must be rewarded in some way. The strength of
    the miner’s power, in turn, is used to safeguard the ledger. Otherwise, an enemy
    with more than 51% the world’s mining capacity may generate blocks quicker than
    the rest of the network, do double-spend computations or transactions, and completely
    rewrite history by avoiding the computer system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除重复消费并确保货币具有价值，比特币需要一个安全的分类帐。矿工必须以某种方式获得奖励。矿工的力量，反过来，用于保护分类帐。否则，拥有超过全球 51%
    的挖掘能力的敌人可能会比网络的其余部分更快地生成区块，执行双重支出计算或交易，并通过避开计算机系统完全重写历史。
- en: As a result, Bitcoin is launched with a well-balanced reliance on these three
    components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，比特币的推出在这三个组件上有一个很好的平衡依赖。
- en: 3.3 Key and Address
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 密钥和地址
- en: 'In order to have your own Bitcoins, that is, to spend them, it is necessary
    to have:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要拥有自己的比特币，也就是说，要花费它们，需要：
- en: A collection of digital keys, including a private key and a public key
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组数字密钥，包括私钥和公钥
- en: A Bitcoin address
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个比特币地址
- en: A digital sign
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字签名
- en: The Elliptic Curve Digital Signature Method is a cryptographic algorithm that
    underpins Bitcoin’s private and public keys. It’s used to make sure that only
    legitimate owners can spend money.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线数字签名方法是支撑比特币私钥和公钥的加密算法。它用于确保只有合法所有者才能花钱。
- en: 3.3.1 Private Key
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 私钥
- en: In the context of Bitcoin, a private key  is a secret number that allows you
    to spend Bitcoins. Each Bitcoin wallet comes with one or more private keys kept
    in the wallet file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币的背景下，私钥是一个秘密数字，允许您花费比特币。每个比特币钱包都带有一个或多个保存在钱包文件中的私钥。
- en: It is also used to make a digital signature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被用来生成数字签名。
- en: A private key is just a number that is created at random. It’s a signed 256-bit
    (32-byte) integer. Not all 256-bit unsigned numbers, however, are Bitcoin private
    keys. In fact, the standard secp256k1 used by Bitcoin limits the number of valid
    private keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥只是随机生成的一个数字。它是一个带符号的 256 位（32 字节）整数。然而，并非所有的 256 位无符号数都是比特币私钥。事实上，比特币使用的标准
    secp256k1 限制了有效私钥的数量。
- en: Secp256k1 is described in the standards for efficient cryptography and corresponds
    to the parameters of the elliptic curve used in Bitcoin public key cryptography
    (SEC).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Secp256k1在高效加密标准中有所描述，对应于比特币公钥加密（SEC）中使用的椭圆曲线的参数。
- en: Keep in mind that the private key is utilized to generate the public key.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，私钥用于生成公钥。
- en: 3.3.2 Public Key
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 公钥
- en: The argument is that a public key  can be used to verify the authenticity of
    a signature (that is, produced with the correct private key). In general, the
    public key is created by multiplying the private key by an elliptic curve. Bitcoin
    is defined in the secp256k1 constant and uses a constant elliptic curve and a
    set of mathematical constants.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 论点是公钥可用于验证签名的真实性（即使用正确的私钥生成）。一般来说，公钥是通过将私钥与椭圆曲线相乘来创建的。比特币在secp256k1常数中定义，并使用常数椭圆曲线和一组数学常数。
- en: Starting with a private key << privkey >> and multiplying it by a predefined
    dot on the curve called the *generator point* G produces a different dot on the
    curve, which corresponds to the public key << pubKey >>. Usually, a public key
    can be defined by the coordinates of the point «privkey»*G=«pubKey» = (x,y) (see
    Figure [3-2](#Fig2)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig2_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig2_HTML.jpg)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个私钥 << privkey >> 开始，并将其乘以曲线上的预定义点称为*生成点* G，可以在曲线上产生一个不同的点，对应于公钥 << pubKey
    >>。通常，一个公钥可以通过点的坐标来定义：«privkey»*G=«pubKey» = (x,y)（见图[3-2](#Fig2)）。
- en: Figure 3-2
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2
- en: Example of an elliptic curve cryptographic function for calculating the public
    key
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线加密函数的示例，用于计算公钥
- en: The generating point G is described as part of secp256k1, and it is the same
    for all keys in Bitcoin.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 生成点 G 被描述为 secp256k1 的一部分，并且对于比特币中的所有密钥都是相同的。
- en: The private key << privKey >> multiplied by G will have the outcome with the
    same public key << pubKey >>. The connection between <<privKey >> and << pubKey
    >> is constant. However it can only be compute in single direction, from << privKey
    >> to << pubKey >>.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥 << privKey >> 乘以 G 将产生相同的公钥 << pubKey >>。<<privKey >> 和 << pubKey >> 之间的连接是恒定的。但是它只能在单个方向上计算，从
    << privKey >> 到 << pubKey >>。
- en: The (x; y) coordinates of a point on an elliptic curve can be used to describe
    the public key. Hexadecimal is the most commonly used format for storing data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线上点的（x；y）坐标可用于描述公钥。十六进制是存储数据的最常用格式。
- en: 'Hence, there are two formats for public keys  :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，公钥有两种格式：
- en: Uncompressed public key
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未压缩的公钥
- en: Compressed public key
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩的公钥
- en: Note that the uncompressed public key is the old format. It is generally no
    longer used in favor of the compressed format. Bitcoin originally used both x
    and y coordinates to store the public key. In this uncompressed format, the coordinates
    are simply strung together, and the prefix 04 is added to indicate that it is
    an uncompressed public key, as shown in Figure [3-3](#Fig3).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig3_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig3_HTML.jpg)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，未压缩的公钥是旧格式。通常不再使用这种格式，而是使用压缩格式。比特币最初同时使用 x 和 y 坐标存储公钥。在这种未压缩格式中，坐标被简单地串在一起，并添加前缀
    04 表示它是未压缩的公钥，如图 [3-3](#Fig3) 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig3_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig3_HTML.jpg)
- en: Figure 3-3
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3
- en: Uncompressed public key
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 未压缩的公钥
- en: With a compressed public key, the elliptical curve is symmetrical along the
    axis of X, as shown in Figure [3-4](#Fig4).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig4_HTML.png](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig4_HTML.png)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩的公钥，椭圆曲线在 X 轴上是对称的，如图 [3-4](#Fig4) 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig4_HTML.png](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig4_HTML.png)
- en: Figure 3-4
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4
- en: Symmetry of the elliptical curve
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线的对称性
- en: Hence, in the compressed public key format (see Figure [3-5](#Fig5)), you only
    save the full x coordinates, along with a prefix indicating if y is even or odd.![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig5_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig5_HTML.jpg)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在压缩的公钥格式中（参见图 [3-5](#Fig5)），您只保存完整的 x 坐标，以及指示 y 是偶数还是奇数的前缀。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig5_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig5_HTML.jpg)
- en: Figure 3-5
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5
- en: Compressed public key
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩的公钥
- en: This format saves a lot of space on the blockchain  .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式在区块链上节省了大量空间。
- en: 3.3.3 Bitcoin Address
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 比特币地址
- en: A Bitcoin address, or simply an address, is an identifier of 26-35 alphanumeric
    characters, starting with the number 1, 3, or bc1, that represents a possible
    destination for a Bitcoin payment. Transactions in Bitcoin (cryptocurrency, BTC)
    can be made through an address, a bit like sending an email. However, unlike an
    email addresses, people have different Bitcoin addresses and at the same time
    a unique address should be used for every transaction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币地址，或简称地址，是一个由 26-35 个字母数字字符组成的标识符，以数字 1、3 或 bc1 开头，代表比特币支付的可能目的地。比特币（加密货币，BTC）的交易可以通过地址进行，有点类似发送电子邮件。但与电子邮件地址不同的是，人们有不同的比特币地址，同时每笔交易都应使用唯一地址。
- en: 'A person can create an unlimited number of addresses, increasing the level
    of anonymity of payments. An address is created from three elements:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可以创建无限数量的地址，增加支付的匿名性。一个地址由三个元素组成：
- en: A public key hash
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥哈希
- en: A prefix
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个前缀
- en: A checksum
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和
- en: Let’s analyze these three components in detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析这三个组件。
- en: The public key hash is nothing more than a double hash applied to the public
    key. In particular, it is the hash obtained through the SHA-256 and RIPEMD160,
    and therefore:<< PublicKeyHash >> = RIPEMD160 (SHA-256 (<< publicKey >>))
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥哈希只是应用于公钥的双重哈希。特别是，它是通过 SHA-256 和 RIPEMD160 获得的哈希，因此：<< PublicKeyHash >> =
    RIPEMD160 (SHA-256 (<< publicKey >>))
- en: It is sometimes referred to as HASH160 (<< publickey >>), because it is simpler
    than writing RIPEMD160 (SHA256 (<< publickey >>)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它被称为 HASH160 (<< publickey >>)，因为它比写 RIPEMD160 (SHA256 (<< publickey >>))
    更简单。
- en: The prefix indicates the type of block to be created.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示要创建的区块类型。
- en: 'The most commonly used ones are:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的是：
- en: '00: For the P2PKH locking script (you will learn what it is later)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 00：用于 P2PKH 锁定脚本（稍后您将学到它是什么）
- en: '05: For P2SH locking script'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 05：用于 P2SH 锁定脚本
- en: 'Finally, the checksum is obtained by performing the SHA-256 hash twice on the
    public key hash and taking the first four bytes. So, you take these elements and
    put them in order to get a queue (see Figures [3-6](#Fig6) and [3-7](#Fig7)):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过对公钥哈希执行两次 SHA-256 哈希并取前四个字节来获得校验和。因此，您需要将这些元素按顺序放置以获得一个队列（请参见图 [3-6](#Fig6)
    和 [3-7](#Fig7)）：
- en: '1.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: prefix
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前缀
- en: '2.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: HASH160(«public key»)
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HASH160(«公钥»)
- en: '3.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: checksum
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 校验和
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig6_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig6_HTML.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig6_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig6_HTML.jpg)'
- en: Figure 3-6
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6
- en: Elements to form the Bitcoin address
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 组成比特币地址的元素
- en: The Base58 function is then applied, which will finally provide the Bitcoin
    address, as shown in Figure [3-7](#Fig7).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig7_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig7_HTML.jpg)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用 Base58 函数，最终将提供比特币地址，如图 [3-7](#Fig7) 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig7_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig7_HTML.jpg)
- en: Figure 3-7
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7
- en: Bitcoin address
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币地址
- en: Base58 is a converter that you can use to represent large numbers in a shorter
    and more intuitive format, resulting in a text alphanumeric. Obviously, these
    operations are implemented at the application level, and it is not up to the user
    to carry out all these steps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Base58 是一个转换器，您可以使用它将大数字表示为更短且更直观的格式，从而产生文本字母数字字符。显然，这些操作是在应用程序级别实现的，用户无需执行所有这些步骤。
- en: 3.3.4 Digital Signature
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 数字签名
- en: The *digital signature* is a mathematical means of demonstrating that you are
    aware of the private key associated with a public key without revealing the effective
    private key. When making a transaction, you must first unlock the balances you
    want to use (UTXO, as you’ll see in the next section). This can be accomplished
    by demonstrating that you “own” the balance and that you know the private key
    to the address where the balance is kept. Therefore, to unlock a balance without
    providing the private key you use the digital signature. In this way you show
    that you have the private key, without handing it over to the network. These are
    then used in transactions to prove you own the balances you are spending.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字签名*是一种数学手段，用于证明您知道与公钥相关联的私钥，而不会泄露有效的私钥。在进行交易时，您必须首先解锁要使用的余额（正如您将在下一节中看到的UTXO）。这可以通过证明您“拥有”该余额并知道存放余额的地址的私钥来实现。因此，要在不提供私钥的情况下解锁余额，您使用数字签名。通过这种方式，您表明您拥有私钥，而不将其交给网络。然后，这些将用于交易以证明您拥有要消费的余额。'
- en: What stops someone from exploiting a transaction’s digital signature to unlock
    other exits at your address? Each transaction has its own digital signature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 是什么阻止有人利用交易的数字签名来解锁您地址上的其他退出？每个交易都有自己的数字签名。
- en: To put it another way, you employ not only the private key, but the private
    key and the transaction data to construct a digital signature. As a result, any
    digital signature is associated with the transaction in which it is employed.
    As a result, if someone tries to use a transaction’s digital signature in a new
    transaction, it will clash with the data of the transaction in the digital signature
    shop and will be rejected by the Bitcoin network’s nodes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你不仅需要使用私钥，还需要使用私钥和交易数据来构建数字签名。因此，任何数字签名都与其所使用的交易相关联。因此，如果有人试图在新交易中使用交易的数字签名，它将与数字签名中的交易数据发生冲突，并将被比特币网络的节点拒绝。
- en: 'Consequently, the digital signature will also save against destroying the transaction
    in which it is used. A digital signature consists of two parts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数字签名还将防止破坏其所使用的交易。数字签名由两部分组成：
- en: A random part
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机部分
- en: A part of the signature, consisting of
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由一部分组成的签名
- en: A private key
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私钥
- en: The data on which you are creating the digital signature
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在创建数字签名的数据
- en: For the random part, let *n* be the order of point G of the second elliptic
    curve the standard secp256k1. You generate a random number 2 [1; n - 1] and call
    this random number.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于随机部分，让*n*为第二个椭圆曲线的点G的标准secp256k1的阶。您生成一个介于2 [1; n - 1]之间的随机数，并将此随机数命名为。
- en: You then multiply this random number by the point G (generator point) of the
    elliptic curve. This is the same G you used for the public key and indicated by
    the standard secp256k1. For the sake of brevity, you call the random number with
    the variable k.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将此随机数乘以椭圆曲线的点G（生成点）。这与您用于公钥并由标准secp256k1指示的G相同。为简洁起见，您使用变量k表示随机数。
- en: k G = (xr; yr)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: k G = (xr; yr)
- en: The random part of this digital signature is the point on the curve that you
    obtain (see Figure [3-8](#Fig8)). But you only take the xr coordinate.![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig8_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig8_HTML.jpg)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此数字签名的随机部分是您获得的曲线上的点（参见图[3-8](#Fig8)）。但您只取xr坐标。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig8_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig8_HTML.jpg)
- en: Figure 3-8
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-8
- en: Random number obtained on the curve, from which you take the X coordinate
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从曲线上获得的随机数，从中取X坐标
- en: For the sake of brevity, you can call r the randomPart value obtained from
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，您可以将r称为从中获得的randomPart值
- en: '*r = randomPart = xr mod n*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*r = randomPart = xr mod n*'
- en: For the signature part, you need to take the private key for the random part.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于签名部分，您需要获取用于随机部分的私钥。
- en: '*r * privKey*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*r * privKey*'
- en: Then you include the data on which you want to create the signature.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要包含要创建签名的数据。
- en: 'In Bitcoin, this is represented by the hash of the transaction that contains
    the balance (UTXO) that you want to unlock. You define h (msg) = SHA-256 (<<transaction
    >>) and get:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，这由包含您要解锁的余额（UTXO）的交易的哈希表示。您定义h（msg）= SHA-256（<<transaction >>）并获得：
- en: '*[r * privKey] + h(msg)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*[r * privKey] + h(msg)*'
- en: 'The inclusion of the transaction hash binds the signature to a transaction
    (therefore it cannot be used in a different transaction). Finally, you divide
    this by the initial random number k:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 交易哈希的包含将签名绑定到交易（因此不能在不同的交易中使用）。最后，您将此除以初始随机数k：
- en: '*s = sign = k-1 (r privKey + h(msg)) (mod n)*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*s = sign = k-1 (r privKey + h(msg)) (mod n)*'
- en: You have obtained the fundamental part of the digital signature. The digital
    signature is made up of an r and an s.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您已获得数字签名的基本部分。数字签名由r和s组成。
- en: If someone asks you to prove that you know the key private for a public key,
    you can give them the signature digital (r; s) as proof.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人要求您证明您知道某个公钥的私钥，则可以向他们提供签名数字（r; s）作为证据。
- en: 3.3.4.1 Verifying a Digital Signature
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4.1 验证数字签名
- en: To verify that a digital signature has been made using a correct private key,
    the person to whom you provide this digital signature must use both sides (r;
    s) to find two new points on the elliptic curve and check the signature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证数字签名是否使用正确的私钥进行了签名，您提供此数字签名的人必须同时使用两侧（r; s）以在椭圆曲线上找到两个新点并检查签名。
- en: From here on, the multiplication operator is used only when it is strictly necessary
    to divide the variables, otherwise yes assumes the implicit multiplication operation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，仅在严格需要除法变量时才使用乘法运算符，否则假定隐式乘法操作。
- en: First, let’s take the data on which the digital signature has been affixed.
    In this case, it is the SHA-256 hash that’s applied to the transaction.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看数字签名所附的数据。在这种情况下，应用于交易的是 SHA-256 哈希。
- en: 'You divide this value by s (the core part of the digital signature) and multiply
    by G (the generator point), like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将此值除以 s（数字签名的核心部分），然后乘以 G（生成点），如下所示：
- en: '*u1 = (x1; y1) = (h(msg) s-1 mod n) G*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*u1 = (x1; y1) = (h(msg) s-1 mod n) G*'
- en: You then find point 1 (see Figure [3-9](#Fig9)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig9_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig9_HTML.jpg)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到 1 点（参见图 [3-9](#Fig9)）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig9_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig9_HTML.jpg)
- en: Figure 3-9
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9
- en: Example of graphic representation of point 1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 1 点的图形表示示例
- en: 'Then you divide r by s and multiply by the < < publickey > >:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 r 除以 s 并乘以 < < publickey > >：
- en: '*u2 = (x2; y2) = (r s-1 mod n) pubKey*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*u2 = (x2; y2) = (r s-1 mod n) pubKey*'
- en: You then have point 2 (see Figure [3-10](#Fig10)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig10_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig10_HTML.jpg)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有了 2 点（见图 [3-10](#Fig10)）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig10_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig10_HTML.jpg)
- en: Figure 3-10
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10
- en: Example of graphic representation of point 2
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 2 点的图形表示示例
- en: Finally, add these two points and you get a third point on the elliptic curve.
    (See Figure [3-11](#Fig11).)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这两个点相加，你就得到了椭圆曲线上的第三个点。（见图 [3-11](#Fig11)。）
- en: '*Rv = (xv; yv) = u1 + u2*![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig11_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig11_HTML.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rv = (xv; yv) = u1 + u2*![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig11_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig11_HTML.jpg)'
- en: Figure 3-11
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11
- en: Example of graphical representation of the sum between the point 1 and point
    2
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 1 点和 2 点之间求和的图形表示示例
- en: If the value c = xv mod n of this point Rv = (xv; yv) obtained on the elliptic
    curve is equal to r, that is, c == initial r, then it’s proof that the digital
    signature was made with the public key’s connected private key.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在椭圆曲线上获得的点 Rv = (xv; yv) 的值 c = xv mod n 等于 r，即 c == 初始 r，则证明数字签名是用连接的私钥进行的。
- en: 3.3.4.2 Understanding the ECDSA Sign/Verify Math
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4.2 理解 ECDSA 签名/验证数学
- en: 'The ECDSA signature  has a simple description:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA 签名具有简单的描述：
- en: Note that the signing process signature encodes a random dot R (represented
    only from the X coordinate, you refer to r = randomPart =xr mod n) through transformations
    of the elliptic curve uses the private key privKey. It then encodes the hash of
    the message h (msg) in a number sign, which is proof that the signer understands
    the private key privKey. The signature (random Part, sign) may reveal the private
    key due to the complexity of the problem ECDLP.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意，签名过程通过椭圆曲线的变换使用私钥 privKey 对随机点 R 进行编码（仅从 X 坐标表示）（您可以参考 r = randomPart =
    xr mod n）。接着对消息的哈希值 h(msg) 进行编码，这表示签名者理解私钥 privKey。签名（random Part, sign）可能会因 ECDLP
    问题的复杂性而泄漏私钥。
- en: Verification of the signature encodes the proof number sign using the public
    key pubKey and the message hash h (msg). It then restores the original point R,
    used to create the signature, called Rv. Then compare the X coordinate (xv mod
    n) of the Rv retrieved with the r = randomPart value of the signature.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名通过使用公钥 pubKey 和消息哈希 h(msg) 对证明数进行编码。然后恢复用来创建签名的原始点 R，称为 Rv。然后将从签名中取回的 Rv
    的 X 坐标（xv mod n）与签名的 r = randomPart 值进行比较。
- en: So how does the reported signature and verification scheme work? Let’s consider
    the verification, then the equation to derive Rv. We then write the equation in
    the extended form.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所报告的签名和验证方案是如何工作的呢？让我们考虑验证，然后推导出 Rv 的方程。接着我们将方程写成扩展形式。
- en: '*Rv = (xv; yv) = h (msg) s-1 (modn) G + r s-1 (modn) pubKey*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rv = (xv; yv) = h(msg) s^-1 (modn) G + r s^-1 (modn) pubKey*'
- en: 'Replace pubKey with privKey G:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用 privKey G 替换 pubKey：
- en: '*Rv = (xv; yv) = h (msg) s-1 (modn) G + r s-1 (modn) privKey G*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rv = (xv; yv) = h(msg) s^-1 (modn) G + r s^-1 (modn) privKey G*'
- en: 'Highlight G and s-1 (mod n), obtaining:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 强调 G 和 s^-1 (modn)，得到：
- en: '*Rv = (xv; yv) = (h (msg) + r privKey) s-1 (mod n) G*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rv = (xv; yv) = (h(msg) + r privKey) s^-1 (modn) G*'
- en: 'We know that:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道：
- en: '*s-1 (mod n) = (k-1 (h (msg) + r privKey)) - 1 (mod n)*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*s^-1 (modn) = (k^-1 (h(msg) + r privKey))^-1 (modn)*'
- en: 'And so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '*s-1 (mod n) = k (h (msg) + r privKey) -1 (mod n)*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*s^-1 (modn) = k (h(msg) + r privKey)^-1 (modn)*'
- en: 'We substitute this in the equation of Rv:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其代入 Rv 的方程中：
- en: '*Rv = (h (msg) + r privKey) k (h (msg) + r privKey) -1 (modn) G = k*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rv = (h(msg) + r privKey) k (h(msg) + r privKey)^-1 (modn) G = k*'
- en: The last step is to compare the point Rv with the point R. This is encoded by
    privKey. This algorithm compares the X coordinates of Rv with the X of R (where
    R = (xr; yr) e r = randomPart = xr mod n). More precisely, the signature is expected
    to be valid if given c = xv mod n, then c == r.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将点 Rv 与点 R 进行比较。这由 privKey 进行编码。该算法比较了 Rv 的 X 坐标与 R 的 X 坐标（其中 R = (xr;
    yr) 且 r = randomPart = xr mod n）。更确切地说，如果给定 c = xv mod n，则 c == r 时签名预计是有效的。
- en: Figure [3-12](#Fig12) illustrates, at a high level, how the digital signatures
    in Bitcoin transactions work.![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig12_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig12_HTML.jpg)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [3-12](#Fig12)在高层次上说明了比特币交易中数字签名的工作原理。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig12_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig12_HTML.jpg)
- en: Figure 3-12
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12
- en: Transactions  and digital signatures
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 交易与数字签名
- en: 3.4 The Transaction
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 交易
- en: The transaction is the most basic component of Bitcoin’s blockchain. Transactions
    are verified and sent out. Many transactions combine to make a block. Furthermore,
    a chain of blocks is formed through a digital data link.^([3](#Fn3))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是比特币区块链的最基本组成部分。交易被验证并发送出去。许多交易组合成一个区块。此外，通过数字数据链接形成区块链。
- en: To select the next block to be put to the chain, the blocks go through a consensus
    procedure. The chosen block is verified and added to the existing chain.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择下一个要放入链中的区块，区块经过共识程序。选择的区块经过验证后添加到现有链中。
- en: Miners are special peer nodes that perform the validation and consensus processes.
    It’s important to note that they are unique or powerful machines that run blockchain
    protocol-specific software. Let’s take a look at the specifics of a single Bitcoin
    transaction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工是执行验证和共识过程的特殊对等节点。重要的是要注意，它们是运行区块链协议特定软件的独特或强大的机器。让我们来看看单个比特币交易的具体内容。
- en: 3.4.1 The Unspent Transaction Output (UTXO)
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 未花费的交易输出（UTXO）
- en: Unspent Transaction Output (UTXO) is a fundamental idea in the Bitcoin network
    UTXOs are a set of Bitcoins that are linked to a certain user. They can only be
    spent in a transaction if they are used entirely for that. A user can be associated
    with zero, one, or many UTXOs. Obviously, once a user has used a UTXO to complete
    a transaction, it cannot be used by another user. The sum of UTXOs associated
    with a user is the total balance of the latter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 未花费的交易输出（UTXO）是比特币网络中的一个基本概念。UTXO是与某个用户关联的一组比特币。只有在一笔交易中完全使用时，它们才能被用于交易。用户可以与零、一个或多个UTXO关联。显然，一旦用户使用了UTXO完成一笔交易，它就不能被另一个用户使用。与用户关联的UTXO的总和是用户的总余额。
- en: In other words, Bitcoin stores data relating to transactions and balances of
    users in the form of UTXO, which are “unspent” Bitcoin amounts that have been
    sent to a user, and that are potentially expendable from that user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，比特币以未花费的比特币金额（UTXO）的形式存储与用户的交易和余额相关的数据，这些金额已经发送到用户，可以从该用户支出。
- en: The set of all the UTXOs in the network constitute the state of the blockchain
    Bitcoin. A Bitcoin transaction consists of inputs and outputs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中所有UTXO的集合构成了比特币区块链的状态。比特币交易由输入和输出组成。
- en: A transaction takes as input one or more UTXOs and, according to the request
    initiated by the sender, it generates one or more UTXOs to output the amount specified
    by the transaction request. As a result, an Unspent Transaction Output is the
    result of a transaction that a user receives and can spend later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 交易以一个或多个UTXO作为输入，并根据发送方发起的请求生成一个或多个UTXO以输出交易请求指定的金额。因此，未花费的交易输出是用户接收并以后可以花费的交易的结果。
- en: For example, suppose John has a UTXO with a value of ten Bitcoin and another
    five Bitcoin UTXO, and he wants to send eight Bitcoins to Sara, who has no UTXO
    in her portfolio. John can create a transaction, specifying the amount to spend
    on Sara, and enter ten Bitcoin UTXO as the transaction input.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设约翰有一个价值十比特币的 UTXO 和另一个价值五比特币的 UTXO，并且他想向萨拉发送八比特币，而萨拉的投资组合中没有 UTXO。约翰可以创建一个交易，指定要向萨拉花费的金额，并将十比特币
    UTXO 输入为交易输入。
- en: 'The transaction will therefore look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，交易将如下所示：
- en: '**Input:** 10 Bitcoin Mario UTXO'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入：**10 比特币马里奥 UTXO'
- en: '**Output:**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: An 8 Bitcoin UTXO associated with Sara
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与萨拉关联的 8 比特币 UTXO
- en: A 2 Bitcoin UTXO associated with Mario (the rest of the transaction)
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与马里奥关联的 2 比特币 UTXO（交易的其余部分）
- en: So, once the transaction is recorded, Mario will have in his wallet a 5 Bitcoin
    UTXO and a 2 Bitcoin UTXO, for a total balance of 7 Bitcoins. Sara will have an
    8 Bitcoin UTXO, for a total balance of 8 Bitcoins. The anatomy of a UTXO is very
    simple. (See Figure [3-13](#Fig13).)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦交易被记录，马里奥将在他的钱包中拥有一个 5 比特币 UTXO 和一个 2 比特币 UTXO，总余额为 7 比特币。萨拉将拥有一个 8 比特币
    UTXO，总余额为 8 比特币。UTXO 的解剖非常简单。（见图 [3-13](#Fig13)。）
- en: 'There are two sorts of scripts: locking scripts and unlocking scripts. Given
    the definition of the term, and the fact that unlocking ownership is the first
    step in transferring UTXO, the input value contains the phrase *unlocking script*.
    The output value, on the other hand, will be *locking script* as a result of the
    locking procedure. The term “script” means “stack structure,” however we’ll focus
    on the method rather than the definition.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本有两种：锁定脚本和解锁脚本。鉴于该术语的定义，以及解锁所有权是转移 UTXO 的第一步，输入值包含短语*解锁脚本*。另一方面，输出值将作为锁定过程的结果为*锁定脚本*。术语“脚本”意味着“堆栈结构”，但我们将重点放在方法上而不是定义上。
- en: A transaction output UTXO has the following structure  (see Figure [3-13](#Fig13)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig13_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig13_HTML.jpg)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 交易输出 UTXO 具有以下结构（见图 [3-13](#Fig13)）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig13_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig13_HTML.jpg)
- en: Figure 3-13
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-13
- en: The UTXO structure
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: UTXO 结构
- en: 3.4.2 Input and Output (I&O)
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 输入和输出（I&O）
- en: This is the notion of “listing” the income source (input) and spending (output)
    of a transaction, rather than the concept of transferring money by placing input
    and the outcome being the output. That is, when you pay the amount, you explain
    the revenue source of the UTXO you want to spend first, and then the quantity
    you want to invest on the output item second. Let’s first look at the output’s
    structure. (See Figure [3-14](#Fig14).)![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig14_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig14_HTML.jpg)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是“列举”交易收入来源（输入）和支出（输出）的概念，而不是通过放置输入和产出作为输出来转移资金的概念。也就是说，当你支付金额时，你首先解释你想要花费的
    UTXO 的收入来源，然后是你想要投资的输出项目的数量。让我们首先看一下输出的结构。（见图[3-14](#Fig14)。）![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig14_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig14_HTML.jpg)
- en: Figure 3-14
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14
- en: Input and output
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig15_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig15_HTML.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig15_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig15_HTML.jpg)'
- en: Figure 3-15
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-15
- en: UTXO description
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: UTXO 描述
- en: When a transaction to transfer money is created, the transaction input must
    specify which UTXO will be issued. Simply put, the transaction’s inputs are pointers
    to UTXO. They define a specific UTXO, which relates to the transaction’s hash
    and the transaction output’s index number. A transaction input additionally contains
    the unlock script that satisfies the output conditions given by UTXO in order
    to output UTXO (see Figures [3-15](#Fig15) and [3-16](#Fig16)). The unlock script
    is usually a signature that verifies that the Bitcoin address identified in the
    block script belongs to the owner.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建用于转移资金的交易时，交易输入必须指定将要发行的 UTXO。简单地说，交易的输入是指向 UTXO 的指针。它们定义了一个特定的 UTXO，这与交易的哈希和交易输出的索引号有关。交易输入还包含了满足
    UTXO 给出的输出条件以输出 UTXO 的解锁脚本（参见图[3-15](#Fig15) 和 [3-16](#Fig16)）。解锁脚本通常是一个签名，用于验证区块脚本中识别的比特币地址是否属于所有者。
- en: So, the structure of a UTXO input to a transaction is as shown in Figure [3-16](#Fig16).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig16_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig16_HTML.jpg)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，UTXO 输入到交易的结构如图[3-16](#Fig16)所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig16_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig16_HTML.jpg)
- en: Figure 3-16
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-16
- en: UTXO description
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UTXO 描述
- en: This structure of transaction inputs and outputs leads to a transaction link
    design, as shown in Figure [3-17](#Fig17).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig17_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig17_HTML.jpg)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交易输入和输出的结构导致了交易链接设计，如图[3-17](#Fig17)所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig17_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig17_HTML.jpg)
- en: Figure 3-17
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17
- en: Bitcoin transaction input and output
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易的输入和输出
- en: 3.4.3 Pay to Public Key Hash (P2PKH)
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 公钥哈希付款（P2PKH）
- en: Given a high-level description of how a transaction takes place  , this section
    covers the technical and structural details of it, to understand how it is implemented.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了交易发生的高层描述后，本节涵盖了其技术和结构细节，以了解其实现方式。
- en: P2PKH (pay to a public key hash) is a script template for completing a Bitcoin
    transaction or sending money to someone. It is most commonly used script to lock
    an output on the key someone’s public key. It ensures that only the UTXO beneficiary,
    or the person who owns the private key and therefore the public key relating the
    address Bitcoin beneficiary of UTXO, can spend it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: P2PKH（支付到公钥哈希）是完成比特币交易或向某人发送货币的脚本模板。它是最常用的脚本，用于锁定某人公钥的输出。它确保只有 UTXO 的受益者，或者拥有私钥并因此拥有与地址
    Bitcoin 受益者的 UTXO 相关的公钥的人，才能花费它。
- en: For greater understanding, let’s analyze the output part of the Transaction
    process first, neglecting the details of the input. Then we will address the input
    aspect of the process, going into the process of check that it combines both parts.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们首先分析交易过程的输出部分，忽略输入部分的细节。然后我们将解决交易过程的输入方面，深入探讨它如何将这两个部分结合起来。
- en: 3.4.4 Looking at the Output Side
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 查看输出方面
- en: Let’s say Mario wants to send 20 Bitcoins to Sara. Sara, therefore, will have
    to generate a public key/private key pair associated with it. Then Sara will provide
    her Bitcoin address (see the “Bitcoin Address” section) to Mario.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设马里奥想要向莎拉发送 `20 比特币`。因此，莎拉将不得不生成与之关联的公钥/私钥对。然后莎拉将提供她的比特币地址（参见“比特币地址”部分）给马里奥。
- en: 'The address could be transmitted in any way, including in a one-way manner
    that stops communication between the sender and receiver, and it can be further
    encoded in a different format, such as a QR code that includes a Bitcoin: URI.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '地址可以以任何方式传输，包括以一种阻止发送者和接收者之间通信的单向方式传输，还可以以不同格式进一步编码，例如包含 Bitcoin: URI 的 QR
    代码。'
- en: Then, Mario, the spender of the transaction, will receive Sara’s Bitcoin address
    and can specify it as the beneficiary/recipient of the transaction. This will
    be used to create the UTXO blocking script for the transaction, so that only Sara,
    or whoever can prove to have the associated private key to the public key relating
    to that Bitcoin address that Sara provided, can spend it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，交易的支付者马里奥将收到莎拉的比特币地址，并可以将其指定为交易的受益方/接收方。这将用于创建交易的 UTXO 阻塞脚本，以便只有莎拉，或者谁能证明拥有与莎拉提供的比特币地址相关联的公钥的私钥的人，才能花费它。
- en: Then Mario will transmit the transaction. Once the transaction is validated,
    added to the block, and reaches consensus, it will be part of the blockchain Bitcoin.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后马里奥将传输交易。一旦交易经过验证，添加到区块并达成共识，它将成为比特币区块链的一部分。
- en: The network, therefore, classifies it as an Unspent Transaction Output (UTXO)
    and Sara’s wallet software shows it as a spendable balance. In other words, Sara
    now has a 20 Bitcoin UTXO in her wallet received from Mario.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 网络因此将其分类为未花费的交易输出（UTXO），并且Sara的钱包软件将其显示为可花费的余额。换句话说，Sara现在在她的钱包里有来自Mario的20比特币UTXO。
- en: Therefore, in each UTXO there is the PubKey script, which blocks the use of
    the UTXO to the beneficiary, or to whoever owns the private key. It is then used
    in the transaction validation process. This is structured as shown in Figure [3-18](#Fig18).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig18_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig18_HTML.jpg)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在每个UTXO中都有PubKey脚本，该脚本阻止了UTXO被受益人或拥有私钥的人使用。然后在交易验证过程中使用。结构如图[3-18](#Fig18)所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig18_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig18_HTML.jpg)
- en: Figure 3-18
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-18
- en: PubKey script structure
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PubKey脚本结构
- en: The fields starting with OP denote an operation, while the others denote a value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以OP开头的字段表示一个操作，而其他字段表示一个值。
- en: 'OP_DUP: Performs a duplication operation; serves to copy the public key present
    in the scriptSig (which you will see later), which hash functions will be applied
    to compare the result obtained with the pubKeyHash of this scriptPubKey.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_DUP：执行复制操作；用于复制脚本Sig中的公钥（稍后将看到的），然后将哈希函数应用于比较所得结果与此ScriptPubKey中的pubKeyHash。
- en: 'OP_HASH160: First applies the SHA-256 hash function and then RIPEMD160 to the
    public key of the duplicate scriptSig.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_HASH160：首先对复制的scriptSig中的公钥应用SHA-256哈希函数，然后应用RIPEMD160。
- en: 'PubKeyHash: The public Key hash; comes from decoding the Bitcoin address provided
    to the sender.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PubKeyHash：公钥哈希；来自解码发送者提供的比特币地址。
- en: 'OP_EQUALVERIFY: The operation that verifies that the two public key hashes
    (the one from the complete public key in scriptSig and the one in this PubKey
    script) are the same. Returns True if they are the same, False if they are different.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_EQUALVERIFY：验证两个公钥哈希（在scriptSig中的完整公钥和此PubKey脚本中的公钥哈希）是否相同的操作。如果它们相同，则返回True，如果它们不同，则返回False。
- en: 'OP_CHECKSIG: This operation is therefore carried out on the script. Mr. Check
    signature <sig> against public key <pub-Key>. If the signature joining the public
    key and has been generated using all the data required for the signature, OP_CHECKSIG
    returns True.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_CHECKSIG：因此，此操作在脚本上执行。检查签名<sig>是否与公钥<pub-Key>匹配。如果签名与公钥结合在一起并且使用了生成签名所需的所有数据，则OP_CHECKSIG返回True。
- en: In order for this UTXO to be spent, there needs to be a resolved script. In
    order to solve this script and then use the UTXO to make a transaction, you must
    prove that you have the key private and the public key related to the Bitcoin
    address to which it was sent the UTXO.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要花费此UTXO，需要解决脚本。为了解决此脚本，然后使用UTXO进行交易，您必须证明您拥有与发送UTXO的比特币地址相关联的私钥和公钥。
- en: 3.4.5 Looking at the Input Side
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 查看输入端
- en: Let’s see how the process of creating a transaction works from the spender’s
    perspective. Let’s assume Sara wants to send 20 Bitcoins to Fabio. Sara, once
    Fabio has provided her with the Bitcoin address, will enter as a beneficiary of
    the transaction, together with the amount.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从花费者的角度来看一下创建交易的过程是如何工作的。假设萨拉想要向法比奥发送 20 比特币。一旦法比奥提供了比特币地址给她，萨拉将作为交易的受益者输入，并附上金额。
- en: The Bitcoin address provided by Fabio will also be used for the PubKey script,
    which will therefore allow him to spend the output of the transaction exclusively
    to the owner of the relative private key.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 法比奥提供的比特币地址也将用于 PubKey 脚本，因此将允许他将交易的输出专门用于相对私钥的所有者。
- en: Then Sara will fill in the transaction input, where for each UTXO, she must
    target and unlock the information shown in Figure [3-19](#Fig19).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig19_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig19_HTML.jpg)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后萨拉将填写交易输入，在每个 UTXO 中，她必须定位并解锁图 [3-19](#Fig19) 中显示的信息。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig19_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig19_HTML.jpg)
- en: Figure 3-19
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-19
- en: The Script structure Sig
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本结构 Sig
- en: 3.4.6 Validation Process
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 验证过程
- en: The language used, Script  , is stack-based and allows for limited operations
    to avoid loops in the code that would cause problems of execution. Because of
    their low complexity and predicted lead times, these languages are referred regarded
    as incomplete Turing languages. A stack is a data structure that resembles a stack
    of playing cards.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的语言，脚本，是基于栈的，并允许有限的操作以避免在代码中引起问题的循环执行。由于它们的低复杂性和可预测的导致时间，这些语言被视为不完全的图灵语言。栈是一种类似于一叠纸牌的数据结构。
- en: 'There are two procedures available: push and pop. Push puts a card to the top
    of the deck, whereas pop removes it. In this case, the cards are the data. Anyone
    who wants to send money to someone must prove they actually own that coin. The
    scriptSig of the input and the scriptPubKey of the referenced output are combined
    and evaluated.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个可用的程序：push 和 pop。Push 将一张卡放在牌堆的顶部，而 pop 则将其移除。在这种情况下，卡片是数据。任何想要向某人发送钱的人都必须证明他们实际拥有那个币。输入的
    scriptSig 和引用输出的 scriptPubKey 被结合并进行评估。
- en: Initially, the data entered in the Sig script is added to the stack of the transaction
    input (therefore, first sig and then pubKey).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 Sig 脚本中输入的数据添加到交易输入的栈中（因此，首先是 sig，然后是 pubKey）。
- en: The script extracts the public key from the stack, which coincides with the
    pubKey of the scriptSig, and applies it to it, hashed it first SHA-256 and then
    RIPEMD160. Then compare the result with the public key hash of the PubKey script  .
    If it is successful, you proceed to verify the digital signature, otherwise the
    transaction is rejected.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本从栈中提取公钥，与 scriptSig 的 pubKey 相符，并将其应用于它，首先进行 SHA-256 哈希，然后进行 RIPEMD160。然后将结果与
    PubKey 脚本的公钥哈希进行比较。如果成功，就继续验证数字签名，否则交易被拒绝。
- en: So, if the signature common for the public key and has been generated using
    all the data required to be signed, then the transaction is valid.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果对于公钥是共同的签名，并且已使用所有必须签名的数据生成了，则交易有效。
- en: You can see these operations, in more detail, through the diagrams in Figures
    [3-20](#Fig20) through [3-26](#Fig26).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig20_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig20_HTML.jpg)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过图 [3-20](#Fig20) 到 [3-26](#Fig26) 中的图表更详细地了解这些操作。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig20_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig20_HTML.jpg)
- en: Figure 3-20
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-20
- en: Transaction validation process, Step 1
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 1 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig21_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig21_HTML.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig21_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig21_HTML.jpg)'
- en: Figure 3-21
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-21
- en: Transaction validation process, Step 2
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 2 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig22_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig22_HTML.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig22_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig22_HTML.jpg)'
- en: Figure 3-22
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-22
- en: Transaction validation process, Step 3
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 3 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig23_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig23_HTML.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig23_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig23_HTML.jpg)'
- en: Figure 3-23
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-23
- en: Transaction validation process, Step 4
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 4 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig24_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig24_HTML.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig24_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig24_HTML.jpg)'
- en: Figure 3-24
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-24
- en: Transaction validation process, Step 5
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 5 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig25_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig25_HTML.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig25_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig25_HTML.jpg)'
- en: Figure 3-25
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-25
- en: Transaction validation process, Step 6
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 6 步
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig26_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig26_HTML.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig26_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig26_HTML.jpg)'
- en: Figure 3-26
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-26
- en: Transaction validation process, Step 7
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证过程，第 7 步
- en: So if False is not at the top of the stack after scriptsig and scriptPubKey
    were evaluated, then the transaction is valid.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 False 不是在 scriptsig 和 scriptPubKey 评估后堆栈的顶部，则交易有效。
- en: In fact, the complete validation process of a transaction, in addition to being
    independent for each node that receives it, also includes other steps and checks
    that you will see later.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，交易的完整验证过程除了对接收它的每个节点都是独立的之外，还包括其他步骤和检查，稍后您将看到。
- en: 3.4.7 Transaction Structure
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7 交易结构
- en: After learning about the operation and analyzing the fundamental components,
    you’ll now learn how a transaction is structured. (See Figure [3-27](#Fig27)).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig27_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig27_HTML.jpg)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解操作并分析基本组件之后，您现在将学习交易的结构。 (参见图[3-27](#Fig27))。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig27_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig27_HTML.jpg)
- en: Figure 3-27
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-27
- en: Transaction structured
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 交易结构
- en: The Locktime variable  is a fascinating one. It defines when a transaction can
    be added to the blockchain for the first time. In most transactions, it is set
    to 0 to indicate instant execution.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定时间变量是一个令人着迷的变量。它定义了交易何时首次可以添加到区块链中。在大多数交易中，它设置为0以表示即时执行。
- en: If the block time is more than zero but less than 400 milliseconds, it is regarded
    as a block height, implying that the transaction is not included on the blockchain
    until the block height is reached. It is interpreted as a *UNIX timestamp* if
    it exceeds 400 milliseconds, and the transaction is not included in the blockchain
    before the required time. Locktime is the same as postdating a paper check.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果区块时间大于零但小于400毫秒，则视为区块高度，意味着交易在达到区块高度之前不会包含在区块链中。如果超过400毫秒，则被解释为*UNIX时间戳*，并且在所需时间之前交易不会包含在区块链中。锁定时间与预日期支票相同。
- en: 3.4.8 Transaction Fee
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.8 交易费用
- en: By charging a modest fee for each transaction, transaction fees serve as an
    incentive to include a transaction in the next block, as well as a deterrent against
    “spam” transactions or other forms of system abuse.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每笔交易收取适度的费用，交易费用既作为激励，以便在下一个区块中包含交易，又作为防范“垃圾邮件”交易或其他形式的系统滥用的威慑手段。
- en: The miner who mines the block and stores the transaction in the blockchain collects
    transaction fees. And, unlike the amount of a Bitcoin transaction, transaction
    fees are calculated depending on the size of the transaction in bytes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘区块并将交易存储在区块链中的矿工会收取交易费用。而且，与比特币交易金额不同，交易费用是根据交易的字节大小计算的。
- en: Note that Bitcoin blocks are limited to 1MB (1,000,000 bytes) of dimensions.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，比特币区块的尺寸限制为1MB（1,000,000字节）。
- en: Transaction data takes up space in a block.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易数据占据区块的空间。
- en: So when a miner fills a block of transactions, they will want to maximize the
    amount of money they can raise in taxes. They do it selecting the transactions
    that give them the most money in commissions for the space they occupy in the
    block. Therefore, when processing the value of the transaction fee, the important
    metric is the commission per byte. The miners prioritize transactions based on
    a variety of factors, and in some cases, they may even process transactions for
    free.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当矿工填满一个交易区块时，他们会希望最大化他们能够征税的金额。他们通过选择给他们最多佣金的交易来实现这一点，以及占据区块空间。因此，在处理交易费用的价值时，重要的指标是每字节的佣金。矿工根据各种因素优先处理交易，并且在某些情况下，他们甚至可能免费处理交易。
- en: Because transaction fees influence processing priority, a transaction with commissions
    is more likely to be included in the next block extracted, but a transaction with
    inadequate or no commissions may be postponed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交易费用影响处理优先级，具有佣金的交易更有可能被包括在下一个提取的区块中，但是具有不足或没有佣金的交易可能会被推迟。
- en: Transaction costs are not required in most cases, and transactions without them
    may be completed later; however, the inclusion of transaction fees encourages
    priority processing. A charge field is also missing from the transaction data
    structure.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下不需要交易成本，没有交易成本的交易可能会在以后完成；但是，包括交易费用鼓励优先处理。交易数据结构中还缺少一个收费字段。
- en: Fees are implied instead as the difference between the sum of inputs and outputs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 费用是作为输入和输出之和之间的差额隐含的。
- en: There is no risk of losing Bitcoins because most wallets compute and account
    for transaction fees automatically. If the transactions are created programmatically
    or via the command line, however, the fees must be manually entered and accounted
    for.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有丢失比特币的风险，因为大多数钱包会自动计算和记录交易费用。然而，如果交易是通过编程方式或通过命令行创建的，则必须手动输入和记录费用。
- en: Any excess amount left over after all expenses are subtracted from all inputs
    is the commission charged by the miners.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支出扣除所有输入后剩余的额外金额是矿工收取的佣金。
- en: Therefore, if you do not want to lose Bitcoin, it is important to also specify
    the change in UTXOs of a transaction for your wallet.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你不想丢失比特币，重要的是也要为你的钱包指定交易的UTXO变化。
- en: 3.5 Transaction Flow
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 交易流程
- en: Once a new transaction is made, it is forwarded to the Bitcoin network’s nearby
    nodes to be spread throughout the network.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进行新交易，它会被转发到比特币网络附近的节点，以便在整个网络中传播。
- en: Each Bitcoin node that receives a transaction, however, verifies it first before
    sending it to its neighbors. Only legitimate transactions are sent over the network,
    and invalid transactions are discarded by the first node that encounters them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接收交易的每个比特币节点在将其发送到其邻居之前都会首先验证它。只有合法的交易才会在网络上传播，而无效的交易会被首次遇到它们的节点丢弃。
- en: If the transmitted transaction is genuine, that node forwards it to the other
    nodes with whom it is connected, and a success message is sent back to the sender
    synchronously. If the transaction is invalid, the node rejects it and sends the
    sender a synchronous rejection message.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传输的交易是真实的，该节点将其转发给与其连接的其他节点，并且将成功消息同步发送回发送者。如果交易无效，节点将拒绝它并向发送者发送同步拒绝消息。
- en: Therefore, invalid transactions will be rejected, while valid ones are disseminated
    through the network and will form the *transaction pool* **.** The transaction
    pool is the set of validated transactions that await be confirmed and added to
    a new block.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无效的交易将被拒绝，而有效的交易将通过网络传播，并形成*交易池*。交易池是等待确认并添加到新区块中的验证交易的集合。
- en: As a result, it serves as a holding area for fresh transactions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它作为新交易的临时存储区。
- en: To produce a new block, miners choose transactions from the transaction pool.
    This new block is called the *candidate block* . Each miner then attempts to add
    their candidate block to the blockchain through the mining process.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个新的块，矿工从交易池中选择交易。这个新块被称为*候选块*。然后，每个矿工尝试通过挖矿过程将他们的候选块添加到区块链中。
- en: Let’s say a transaction A is the child of a transaction B when a UTXO spent.
    Transaction A is dependent on the output UTXO of the parent transaction (B). Transactions
    do not always arrive in the same order when broadcast over the network.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 UTXO 被花费时，我们说交易 A 是交易 B 的子交易。交易 A 依赖于父交易（B）的输出 UTXO。交易在通过网络广播时，并不总是按相同顺序到达。
- en: It is possible that the child will come before the parents. In this situation,
    nodes that view the child for the first time may notice that it belongs to an
    unknown parent. Rather than rejecting it, it places the child in a temporary pool
    until the parents arrive, after which the child is passed on to all the other
    nodes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 子交易可能会在父交易之前到达。在这种情况下，首次查看子交易的节点可能会注意到它属于一个未知的父交易。节点不会拒绝子交易，而是将其放入临时池，直到父交易到达，然后将子交易传递给所有其他节点。
- en: The orphan transaction pool, also known as the orphaned transaction pool, is
    a parentless transaction pool. All orphans referring to the parent’s UTXO are
    freed from the pool and recursively revalidated once their parents arrive, allowing
    the complete transaction chain to be contained in the transaction pool, ready
    to be pulled into a block.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立交易池，也称为孤立交易池，是一个没有父级的交易池。所有引用父级 UTXO 的孤儿都从池中释放，并在其父级到达时递归重新验证，使完整的交易链能够包含在交易池中，准备被拉入一个块。
- en: 'The orphan pool’s detention mechanism ensures that otherwise acceptable transactions
    are rejected solely because their parent is late, and that the chain of belonging
    is finally rebuilt in the right order, independent of the order of arrival. The
    transaction chains can be as long as you want them to be. Each node checks each
    transaction it receives against a long list of criteria. Here is the fundamental
    verification criteria:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立池的拘留机制确保仅因其父级迟到而拒绝否则可接受的交易，并且归属链最终按正确顺序重建，与到达顺序无关。交易链可以任意长。每个节点都会检查收到的每个交易是否符合一长串标准。以下是基本的验证标准：
- en: The transaction’s syntax and data format must be accurate.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的语法和数据格式必须准确。
- en: None of the input or output lists can be empty.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入或输出列表中不能有空的。
- en: MAX BLOCK SIZE is less than the transaction size in bytes.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大块大小小于以字节为单位的交易大小。
- en: For each input, the referenced output must exist and cannot be spent (to prevent
    double spending).
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个输入，所引用的输出必须存在且不能被花费（以防止双重支付）。
- en: If the referenced output in any other transaction in the pool exists for any
    input, the transaction must be cancelled (to prevent double spending).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果交易池中的任何其他交易中的引用输出存在于任何输入中，则必须取消交易（以防止双重支付）。
- en: To discover the referred output transaction for each input, scan the main branch
    and the transaction pool. Note that if the output transaction is absent for any
    input, the transaction will be orphaned. If a transaction match isn’t already
    in the pool, add it to the orphaned transaction pool.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发现每个输入的引用输出交易，需要扫描主分支和交易池。请注意，如果任何输入的输出交易不存在，则该交易将被孤立。如果交易匹配尚未在交易池中，将其添加到孤立交易池中。
- en: Each input’s unlock scripts must be compared to the equivalent output blocking
    scripts. These are the most important verification rules, carried out by each
    node that receives the transaction. The list may vary based on an updated protocol.
    (See Figure [3-28](#Fig28).)![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig28_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig28_HTML.jpg)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将每个输入的解锁脚本与相应的输出阻止脚本进行比较。这是由接收到交易的每个节点执行的最重要的验证规则。列表可能会根据更新的协议而变化。（见图 [3-28](#Fig28)。）![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig28_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig28_HTML.jpg)
- en: Figure 3-28
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-28
- en: Lifecycle of a transaction
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的生命周期
- en: 3.6 The Block
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 区块
- en: The blockchain’s data structure is an ordered list with transaction block backlinks.
    The blockchain can be saved as a simple database or as a flat file. The blockchain
    metadata is stored in Google’s LevelDB database by the Bitcoin Core client.^([4](#Fn4))
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的数据结构是一个具有交易区块反向链接的有序列表。区块链可以保存为简单的数据库或平面文件。区块链元数据由比特币核心客户端存储在 Google 的 LevelDB
    数据库中。^([4](#Fn4))
- en: The blocks are connected “backward,” with each one referencing the block before
    it in the chain.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 区块“向后”连接，每个区块都引用链中它之前的区块。
- en: Every block in the blockchain is identified by a hash created by the SHA-256
    cryptographic hash technique in the block’s header. Additionally, each block uses
    the prior block’s hash field in the block’s header to refer to the parent block,
    which is the previous block.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块在区块链中都由区块头中使用 SHA-256 密码哈希技术创建的哈希来标识。此外，每个区块都在区块头中使用前一个区块的哈希字段来引用父区块，即上一个区块。
- en: To put it another way, each block’s header contains the hash of its parent.
    The hash sequence that connects each block to its parent, known as the *genesis
    block* *,* generates a chain that extends back to the first block ever created.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个区块的头部包含其父区块的哈希。连接每个区块与其父区块的哈希序列，称为*创世区块*生成了一条链，延伸至第一个创建的区块。
- en: A block has only one parent, although it can have multiple children at any time.
    Every child refers to the same block as its parent, and the “hash” field of the
    previous block includes the same hash (parent). During a blockchain fork, which
    is a transitory condition in which numerous blocks are mined almost simultaneously
    by several miners, more child blocks appear.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块只有一个父区块，尽管它可以随时有多个子区块。每个子区块都指向同一个区块作为其父区块，并且前一个区块的“哈希”字段包含相同的哈希值（父区块）。在区块链分叉期间，这是一种短暂的条件，其中多个挖矿者几乎同时挖出许多区块，会出现更多的子区块。
- en: Finally, the “fork” is rectified, and only a child block becomes part of the
    blockchain. Even though a block can have multiple children, it can only have one
    parent. Due to a block’s single field preceding block hash referencing its single
    parent, this occurs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，“分叉”被纠正，只有一个子区块成为区块链的一部分。即使一个区块可以有多个子区块，但它只能有一个父区块。这是由于一个区块的单一字段前置区块哈希引用其单一父区块，因此会发生这种情况。
- en: The hash of the previous block is located in the block and influence header,
    followed by the hash of the current block.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个区块的哈希值位于区块和影响头部，随后是当前区块的哈希值。
- en: Keep in mind that as the parent’s identify changes, the child’s identity changes
    as well. The hash of the parent changes if the parent is altered in any way. As
    a result, the modified hash of the parent necessitates a change in the child’s
    pointer pre-block hash. This changes the hash of the child block, which changes
    the hash of the nephew block’s preceding block hash field and the hash of the
    nephew itself, and so on, until the last block in the chain is added.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，随着父节点的标识发生变化，子节点的标识也会发生变化。如果父节点以任何方式被修改，父节点的哈希值就会发生变化。因此，修改后的父节点哈希值需要改变子节点指针前置区块哈希。这将改变子区块的哈希值，从而改变侄子区块的前置区块哈希字段和侄子自身的哈希值，依此类推，直到链中的最后一个区块被添加。
- en: Because of the cascade effect, a block with many subsequent generations cannot
    be altered without causing all subsequent blocks to be recalculated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于级联效应，一个有许多后续生成的区块不能被修改，否则会导致所有后续的区块都要重新计算。
- en: Due to the massive computer power required for such a recalculation, the existence
    of a long chain of blocks results in the blockchain’s deep history, which is a
    major security element of Bitcoin. The first six blocks are taken as confirmation
    of the seventh block.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进行这种重新计算需要大量的计算机功率，一长串区块的存在导致了区块链的深层历史，这是比特币的一个重要安全元素。前六个区块被视为对第七个区块的确认。
- en: As you learn more about blockchain technology, you’ll see that the blocks are
    becoming less and less likely to change. Finally, a block is a data structure
    that holds a collection of transactions uploaded to the blockchain.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对区块链技术的了解越来越多，你会发现区块变得越来越不可能改变。最后，一个区块是一个存储上传到区块链的交易集合的数据结构。
- en: 3.6.1 The Structure of a Block
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 区块的结构
- en: The block is made up of a header with metadata or a model, followed by a series
    of transactions that take up the majority of its space. A block’s average size
    is set to 1MB. The block header is 80 bytes long, but the average transaction
    is at least 250 bytes long. (See Figure [3-29](#Fig29).)![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig29_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig29_HTML.jpg)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 区块由带有元数据或模型的头部组成，后跟占据其大部分空间的一系列交易。一个区块的平均大小设置为1MB。区块头长80字节，但平均交易长度至少为250字节。
    (参见图[3-29](#Fig29)。)![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig29_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig29_HTML.jpg)
- en: Figure 3-29
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-29
- en: Structure of block
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 区块的结构
- en: 3.6.2 The Block Header
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 区块头
- en: 'There are three sets of block metadata in the block header:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 区块头中有三组区块元数据：
- en: A reference to a previous block hash that connects this block to the blockchain’s
    preceding block.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此区块连接到区块链前一个区块的上一个区块哈希的引用。
- en: The terms “target,” “once,” and “timestamp” all refer to Bitcoin mining.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “target”，“once”和“timestamp”这些术语都指的是比特币挖矿。
- en: The market root is the root of the Merkle tree, which is used to effectively
    and securely summarize block transactions.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场根是默克尔树的根，用于有效而安全地总结区块交易。
- en: Merkle trees are a type of tree that grows in the Merkle. With Merkle trees,
    a node can only download a few block headers (80 bytes per block) and still detect
    the inclusion of a transaction in a block. It does this by recovering a small
    Merkle path from a full node without having to store or expand the vast majority
    of blockchains, which can be several gigabytes in size.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 默克尔树是一种生长在默克尔的树。有了默克尔树，一个节点只需下载少量区块头（每个区块80字节），就能检测到交易是否包含在一个区块中。它通过从完整节点恢复一个小型的默克尔路径来实现这一点，而无需存储或扩展绝大多数区块链，后者可能达到数千兆字节的大小。
- en: SPV nodes (simplified payment verification)  are nodes that do not retain a
    full blockchain and use Merkle pathways to verify transactions without downloading
    full blocks. SPV nodes frequently employ Merkle trees. Only block headers are
    downloaded by SPV nodes, which do not hold full transactions or download all blocks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: SPV节点（简化支付验证）是不保留完整区块链的节点，它们使用默克尔路径来验证交易，而不必下载完整的区块。 SPV节点经常使用默克尔树。 SPV节点仅下载区块头，不保存完整的交易或下载所有区块。
- en: They employ an authentication or Merkle path to check if a transaction is contained
    in a block without downloading all of the block’s transactions. The block header’s
    detailed structure is shown in the table in Figure [3-30](#Fig30).![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig30_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig30_HTML.jpg)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用身份验证或默克尔路径来检查交易是否包含在一个区块中，而不必下载所有区块的交易。 区块头的详细结构在图表中显示，见图[3-30](#Fig30)。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig30_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig30_HTML.jpg)
- en: Figure 3-30
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-30
- en: Block header’s details
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 区块头的详细信息
- en: Figure [3-31](#Fig31) shows a graphic example of the structure of the blocks
    of the Bitcoin blockchain.![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig31_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig31_HTML.jpg)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [3-31](#Fig31) 展示了比特币区块链的区块结构的图形示例。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig31_HTML.jpg](../images/520777_1_En_3_Chapter/520777_1_En_3_Fig31_HTML.jpg)
- en: Figure 3-31
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-31
- en: Bitcoin blockchain structure
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链结构
- en: The block hash is not included in the block’s structural data, either when it
    is broadcast over the network or when it is stored in the blockchain, as you have
    seen.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 区块哈希也不包含在区块的结构数据中，无论是在网络上传播还是在区块链中存储时，正如你所看到的。
- en: 'Instead, when a block is received by the network, every node computes the block
    hash. The block height, or position in the blockchain, is the second way to identify
    a block. As a result, a block may be identified in two ways: by looking at its
    hash or by looking at its height.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当网络接收到一个区块时，每个节点都会计算区块哈希。区块高度，或者在区块链中的位置，是识别区块的第二种方式。因此，一个区块可以通过查看其哈希或查看其高度来识别。
- en: Each consecutive block placed “above” the first block in the blockchain is one
    position “higher,” like boxes stacked on top of each other.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在区块链中第一个区块“上方”的每个连续区块都比前一个位置“高”，就像箱子一样堆叠在一起。
- en: It’s vital to realize that the block height isn’t a unique identifier like the
    block hash. The block height may not always imply a single block. As you will
    see, two or more blocks with the same block height might contend for the same
    position in the blockchain. The data structure of the block does not include the
    block’s height; it is not saved in the block.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到，区块高度并不像区块哈希一样是一个唯一的标识符。区块高度可能并不总是表示一个单独的区块。正如你将看到的，两个或更多的具有相同区块高度的区块可能争夺区块链中的同一位置。区块的数据结构不包括区块的高度；它不会保存在区块中。
- en: When a block is received by the Bitcoin network, every node dynamically determines
    its position (height) in the blockchain.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个区块被比特币网络接收时，每个节点动态确定其在区块链中的位置（高度）。
- en: 3.7 The Nakamoto Consensus
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 中本聪共识
- en: Furthermore  , all traditional payment systems rely on a trust with a central
    authority that administers transactions and, as a result, the ledger.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有传统支付系统都依赖于与管理交易和分类帐的中央权威的信任。
- en: Bitcoin has no central authority, but each full node has a copy of the blockchain,
    complete with a public ledger that you can rely on as a record. The blockchain
    is not established by a central authority, but rather by each network node working
    independently. Using the information supplied over the network, each node of the
    network can come to the same conclusion and assemble the same copy of the ledger.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币没有中央权威，但每个完整节点都有区块链的副本，包括您可以依赖的公共分类帐记录。区块链不是由中央权威建立的，而是由每个网络节点独立工作建立的。使用网络上提供的信息，网络的每个节点都可以得出相同的结论并组装相同的分类帐副本。
- en: The decentralized technique, through *emergent consensus* *,* is Satoshi Nakamoto’s
    key invention.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*紧急共识*的分散技术是中本聪的关键发明。
- en: Consensus is emerging because it is not expressly reached. There is no election
    in which consent happens. Instead, the consensus is an emergent result of hundreds
    of independent nodes interacting asynchronously under simple rules and regulations.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 共识正在形成，因为它并不明确达成。没有选举表明同意。相反，共识是数百个独立节点在简单的规则和法规下异步交互的结果。
- en: 'The interaction of four processes that run independently on nodes in the network
    results in Bitcoin’s decentralized consensus:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中运行的四个独立过程的相互作用导致了比特币的去中心化共识：
- en: Independent verification of each transaction for each full node using a thorough
    set of criteria.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个完整节点独立验证每个交易，使用一套彻底的标准。
- en: Autonomous grouping of these transactions into new blocks by mining nodes, as
    well as proved computations through a proof-of-work algorithm.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易由挖矿节点自主分组到新的区块中，并通过工作证明算法进行验证计算。
- en: Each node independently verifies new blocks before adding them to the blockchain.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点在将新区块添加到区块链之前都会独立验证新区块。
- en: Independent selection of the longer proof-of-work chain for each node (i.e.,
    proven to have higher computational power than the shorter one).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点独立选择更长的工作证明链（即，被证明具有比较短链更高的计算能力）。
- en: 3.7.1 Miner
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 矿工
- en: Some nodes are particular nodes, called mining nodes or *miner nodes* . They
    are responsible for creating and registering new blocks to the ledger. These nodes
    compete with each other to add a new block to the blockchain.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有些节点是特殊节点，称为挖矿节点或*矿工节点*。他们负责创建和注册新的区块到账本。这些节点相互竞争，以添加新的区块到区块链。
- en: They are in contention with each other because who manages to win the block
    and add it to the chain receives a Bitcoin reward such as an incentive for contributing
    to the consensus of the Bitcoin network.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 他们相互竞争，因为谁成功赢得区块并将其添加到链中，谁就会收到比特币奖励，作为对贡献到比特币网络共识的激励。
- en: 'To form a new block, miners select transactions from the transaction pool,
    thus obtaining a candidate block to be registered to the ledger. To select transactions,
    miners apply a property metric transactions, giving higher priority to transactions
    with UTXO in older inputs and of a higher amount than the most recent ones and
    of smaller amount. In other words, given a transaction Tx. Let N be its UTXO number
    in input and for each UTXO i in input. We define the priority of TX as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成新的区块，矿工从交易池中选择交易，从而获得一个待注册到账本的候选区块。为了选择交易，矿工应用一个属性度量交易，给予具有更老的输入UTXO和更高金额的交易更高的优先级，而对最新的和金额较小的交易给予较低的优先级。换句话说，给定一个交易Tx。让N是其输入中的UTXO编号，并对于输入中的每个UTXO
    i。我们如下定义TX的优先级：
- en: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Figa_HTML.gif](../images/520777_1_En_3_Chapter/520777_1_En_3_Figa_HTML.gif)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_3_Chapter/520777_1_En_3_Figa_HTML.gif](../images/520777_1_En_3_Chapter/520777_1_En_3_Figa_HTML.gif)'
- en: At the same time, they will assign more weight to those with costs of commission
    per kilobyte higher than those that have commissions for lower kilobytes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，他们将会给予那些每千字节佣金成本更高的交易更高的权重，而不是给予低字节交易佣金的交易。
- en: The average size of a Bitcoin block is set at 1MB. Hence, a miner will try to
    select the sequence of transactions which, respecting the priorities (of seniority
    and value) and the maximum block size, will allow you to have a greater income.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块的平均大小设置为1MB。因此，矿工将尝试选择一系列交易，这些交易在尊重优先级（老化和价值）和最大区块大小的情况下，将允许您获得更高的收入。
- en: As a result, transaction commissions are usually valued based on the magnitude
    of the transaction.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，交易佣金通常是根据交易的大小来评估的。
- en: 3.7.2 Coinbase Transaction
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 Coinbase 交易
- en: The first transaction added to the block is a one-of-a-kind transaction that
    differs from regular transactions. Coinbase Transaction  is the name given to
    it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到区块的第一笔交易是一种独特的交易，不同于常规交易。这被称为 Coinbase 交易。
- en: 'It is the transaction that allows the miner who extracts the block to receive:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它是允许挖掘出区块的矿工收到的交易：
- en: The incentive for having participated and contributed to the consent process
    adding a new block.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为参与并添加新区块到共识过程中的激励。
- en: The sum of all the commissions of all the transactions it has added to the block.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加到区块的所有交易的佣金总和。
- en: 'Obviously, the beneficiary Bitcoin address of this transaction is that of the
    miner who extracts the block. The difference between the total value of input
    and the total value of output for each transaction is used to compute the total
    commissions. That is to say:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这笔交易的受益地址是挖掘出区块的矿工的地址。每笔交易的输入总值与输出总值之间的差异用于计算总佣金。也就是说：
- en: Take N as the total number of inputs, I as the index for each input, and Vi
    as the amount of input i.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 N 视为输入总数，I 视为每个输入的索引，Vi 视为输入 i 的金额。
- en: 'Let M be the total number of outputs, or the index for each output, and V be
    the amount of the output. Then:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 M 为输出的总数，或者每个输出的索引，V 为输出的金额。那么：
- en: '![$$ \mathrm{Commission}i\mathrm{Total}i=\sum \limits_{\mathrm{i}=1}^{\mathrm{N}}{V}_i-\sum
    \limits_{0=1}^{\mathrm{M}}{V}_0 $$](../images/520777_1_En_3_Chapter/520777_1_En_3_Chapter_TeX_Equ2.png)(3.2)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![$$ \mathrm{Commission}i\mathrm{Total}i=\sum \limits_{\mathrm{i}=1}^{\mathrm{N}}{V}_i-\sum
    \limits_{0=1}^{\mathrm{M}}{V}_0 $$](../images/520777_1_En_3_Chapter/520777_1_En_3_Chapter_TeX_Equ2.png)(3.2)'
- en: Instead, the miner reward is calculated from 50 bitcoin and by dividing this
    value by 2, every 210,000 blocks. That means Bitcoins are “minted” at a set and
    declining rate throughout the construction of each block. Each block, which is
    formed every ten minutes, comprises a new Bitcoin created from scratch. The currency
    issuance rate is reduced by 50% every 210,000 blocks, or about every four years.
    Each block included 50 new Bitcoins throughout the first four years of the network’s
    functioning.^([5](#Fn5))
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，矿工奖励是从 50 比特币计算的，并且每 210,000 个块减半一次。这意味着比特币在每个区块的构建过程中以一定速率减少。每十分钟形成一个新的区块，其中包含从头开始创建的新比特币。每
    210,000 个块，或大约每四年，货币发行速率减少 50%。在网络运行的前四年中，每个区块都包含 50 个新比特币。^([5](#Fn5))
- en: The reward is based on the block height, with a beginning value of 50 Bitcoins
    per block and halving every 210,000 blocks. The proper reward is 25 Bitcoins because
    this block has a height of 277,316.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励是基于区块高度的，每个区块的起始值为 50 比特币，并且每 210,000 个区块减半一次。适当的奖励是 25 比特币，因为该区块的高度为 277,316。
- en: The computation  may be observed in the Bitcoin Core client’s GetBlockValue
    function, as demonstrated in Listing [3-1](#PC2).**int64_t** GetBlockValue(**int**
    nHeight, **int64_t** nFees){    **int64_t** nSubsidy = 50 * COIN;    **int** halvings
    = nHeight / Params().SubsidyHalvingInterval();        **if** (halvings >= 64)        **return**
    nFees;    *// Every 210,000 blocks, or about every 4 years, the subsidy is decreased
    in half..*    nSubsidy >>= halvings;    **return** nSubsidy + nFees;}Listing 3-1
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '可以在比特币核心客户端的 GetBlockValue 函数中观察到这种计算，如[3-1](#PC2)中所示。**int64_t** GetBlockValue(**int**
    nHeight, **int64_t** nFees){    **int64_t** nSubsidy = 50 * COIN;    **int** halvings
    = nHeight / Params().SubsidyHalvingInterval();        **if** (halvings >= 64)        **return**
    nFees;    *// 每 210,000 个块，或大约每 4 年，补贴减半.*    nSubsidy >>= halvings;    **return**
    nSubsidy + nFees;}[3-1] '
- en: The GetBlockValue Function
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: GetBlockValue 函数
- en: 3.7.3 Developing the Block Header
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.3 开发区块头
- en: 'After calculating the transactions from the Transaction Pool and the Coinbase
    Transaction, the miner continues on to construct the block header in order to
    generate the Candidate Block  . The following steps will then be taken:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算交易池和 Coinbase 交易的交易后，矿工继续构建区块头以生成候选区块。然后将采取以下步骤：
- en: '1.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Indicates the block’s version number, which explains the block’s architecture.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指示区块的版本号，解释了区块的结构。
- en: '2.'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Adds the hash of the previous block that it accepted as a block parent.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将之前接受的区块的哈希作为区块的父块添加。
- en: '3.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Add the Merkle tree root value to the equation. So, after calculating the SHA-256
    hash for each transaction, these are merged in pairs to form each level of the
    tree, until all transactions are summarized in a node at the “root” of the tree.
    As a result, the Merkle tree’s root stores all transactions in a single 32-byte
    value.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 Merkle 树的根值添加到等式中。因此，计算每个交易的 SHA-256 哈希后，这些哈希会两两合并以形成树的每个层级，直到所有交易都被总结在树的“根”节点中。因此，Merkle
    树的根存储在单个 32 字节值中的所有交易。
- en: '4.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Adds the timestamp in Unix Epoch format that it refers to now of block creation.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加了以Unix Epoch格式的时间戳，指的是区块创建的现在。
- en: '5.'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Defines the test difficulty of work required to make it a legitimate block by
    filling in the difficulty target.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了将其作为合法区块所需的测试难度，通过填写难度目标。
- en: '6.'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: The final field is the nonce, initialized to 0.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个字段是nonce，初始化为0。
- en: The block header is now complete, with all other fields filled in, and the mining
    operation may commence. The goal now is to discover a value for the nonce that
    transforms the difficulty target into a hash of the lower block header.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，区块头已经完整，所有其他字段都已填写，并且挖矿操作可以开始。现在的目标是发现一个nonce值，将难度目标转换为较低的区块头的哈希值。
- en: 3.7.4 Difficulty Target
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.4 难度目标
- en: The target  is used in mining. It is the number (expressed in hexadecimal) to
    which the hash value of a block must be reduced in order for it to be added to
    the ledger.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 目标用于挖矿。它是区块哈希值必须减少到的数字（以十六进制表示），以便将其添加到账本中。
- en: The target is adjusted every 2016 blocks (about two weeks) to ensure that blocks
    are extracted on average every ten minutes.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 每2016个区块（约两周）调整一次目标，以确保平均每十分钟提取一个区块。
- en: The complexity of the Proof of Work is determined by a moving average that aims
    an average number of blocks per hour to adjust for increasing hardware speed and
    variable interest in node execution over time. The difficulty increases if they
    are generated too quickly.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明的复杂性由一个移动平均数确定，该移动平均数旨在调整每小时的平均区块数，以适应硬件速度的增加和随时间的变化的节点执行的可变兴趣。如果它们生成得太快，则难度会增加。
- en: The target is calculated by each node of the network independently, but following
    the Bitcoin protocol rules.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络节点都独立计算目标，但遵循比特币协议规则。
- en: The rule stipulates that every 2,016 blocks, all nodes automatically retarget
    the Proof of Work difficulty. The retargeting difficulty calculation compares
    the time it takes to find the remaining 2,016 blocks to the expected time of 20,160
    minutes (which equals two weeks, based on a time of desired block of ten minutes).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 规则规定，每2016个区块，所有节点都会自动重新定位工作量证明的难度。重新定位难度计算将剩余的2016个区块的时间与期望的20160分钟（基于十分钟的期望区块时间计算，等于两周）的时间进行比较。
- en: The desired ratio between the actual period and the time period is then computed,
    and an adjustment based on the difficulty is made. The difficulty rises if the
    network finds blocks faster than every ten minutes. The difficulty decreases if
    block finding is slower than planned.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后计算了实际周期与时间周期之间的期望比率，并根据难度进行调整。如果网络发现区块生成速度比每十分钟快，则难度会上升。如果区块发现速度比计划慢，则难度会降低。
- en: Let RecentBlockTime be the variable that indicates the time taken to find the
    latest 2016 blocks. The equation for calculating the *Difficulty Target* is:![$$
    \mathrm{NewDifficultyTarget}=\mathrm{OldTarget}\ast \left(\frac{\mathrm{RecentBlockTime}}{20160}\right)
    $$](../images/520777_1_En_3_Chapter/520777_1_En_3_Chapter_TeX_Equ3.png)(3.3)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让RecentBlockTime表示指示查找最新的2016个区块所需时间的变量。计算*难度目标*的方程式如下：![$$ \mathrm{NewDifficultyTarget}=\mathrm{OldTarget}\ast
    \left(\frac{\mathrm{RecentBlockTime}}{20160}\right) $$](../images/520777_1_En_3_Chapter/520777_1_En_3_Chapter_TeX_Equ3.png)(3.3)
- en: The adjustment per cycle must be less than a factor of 4 to avoid significant
    volatility in the difficulty objective.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 每个周期的调整必须小于4倍因子，以避免难度目标的显著波动。
- en: If the required difficulty adjustment exceeds a factor of 4, it is limited to
    the maximum allowed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所需的难度调整超过4倍因子，则限制为最大允许值。
- en: All remaining modifications will be performed in the next period. Because each
    node adheres to the same consensus rules and all blocks are identical, they will
    all arrive at the same difficulty value  .
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 所有剩余的修改将在下一个周期内进行。因为每个节点都遵循相同的共识规则，而且所有区块都是相同的，它们最终都将到达相同的难度值。
- en: If a node miscalculates the goal (or lies about it) and then produces a block
    based on that value, the rest of the network will reject it since it does not
    match the target’s requirements, and all of the work invested in mining that block
    will be lost.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点错误地计算目标（或对其进行虚假陈述），然后基于该值生成区块，则由于不符合目标的要求，网络的其余部分将拒绝它，并且投入到挖掘该区块中的所有工作都将丧失。
- en: 3.7.5 Proof of Work
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.5 工作量证明
- en: Once a miner node has created a candidate block, the block must be extracted
    by the node’s hardware platform. It must solve the proof-of-work algorithm in
    order for the block to be valid. The SHA-256 hash function is utilized in the
    Bitcoin mining process.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦矿工节点创建了候选区块，该区块必须由节点的硬件平台提取出来。它必须解决工作量证明算法，以使区块有效。在比特币挖矿过程中，使用了SHA-256哈希函数。
- en: Simply said, *mining* is the process of hashing the block header by modifying
    the “nonce parameter repeatedly until the resulting hash does not match a specific
    target.”. “The hash function’s result cannot be predicted in advance, nor can
    a pattern that generates a certain hash value be generated.” Hash functions have
    this property, which means that the only method to achieve a hash result that
    matches a specific target is to repeat the input until the desired hash result
    arises randomly.^([6](#Fn6))
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，*挖矿* 是通过修改“nonce参数重复多次，直到生成的哈希不匹配特定目标”来散列区块头的过程。 “哈希函数的结果无法预测，也无法生成生成特定哈希值的模式。”哈希函数具有这个属性，这意味着达到与特定目标匹配的哈希结果的唯一方法是重复输入，直到随机产生所需的哈希结果为止。^([6](#Fn6))
- en: As a result, we must understand that the miner computes the hash of this block’s
    header to determine whether it is smaller than the current target. If the hash
    isn’t smaller than the target, the minor increases the nonce (typically by one)
    and tries again. “Miners must try several million times to discover a nonce that
    results in a low enough hash of the block header at the present difficulty level
    of the Bitcoin network.”
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须理解矿工计算此区块头的哈希以确定它是否小于当前目标。如果哈希值不小于目标值，则矿工会增加 nonce（通常增加一），然后重试。“矿工必须尝试数百万次才能发现一个导致在比特币网络当前难度水平下区块头的哈希值低到足够的
    nonce。”
- en: Furthermore, while it was possible to mine the blocks using a simple home computer
    in the early years, today you must utilize specialized and expensive hardware
    and share your processing power with other users by joining mining pools. When
    a mining node solves the problem, it sends the block to all of its neighbors so
    that it can propagate around the network, be validated, and ultimately be added
    to the ledger.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管在早期年份使用简单的家用计算机挖掘区块是可能的，但今天必须利用专门的昂贵硬件，并通过加入挖矿池与其他用户共享处理能力。当一个挖矿节点解决问题时，它会将区块发送给所有邻居，以便在网络中传播，被验证，并最终添加到分类帐中。
- en: 3.7.6 Validating a New Block
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.6 验证新区块
- en: The third step in reaching consensus on the blockchain is independent validation,
    which is carried out by each node that receives a new block.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 达成区块链共识的第三步是独立验证，由接收到新区块的每个节点执行。
- en: As the newly solved block propagates over the network, each node runs a series
    of tests to ensure that it is valid before forwarding it to its peers. Only legitimate
    blocks are propagated over the network as a result of this. Independent validation
    also ensures that honest miners are putting their blocks on the blockchain and
    profiting.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新解决的区块在网络上传播，每个节点都会运行一系列测试以确保其有效，然后将其转发给其对等节点。只有合法的区块才会因此在网络上传播。独立验证还确保了诚实的矿工将他们的区块放在区块链上并获利。
- en: Those that act dishonestly have their blocks rejected, losing not only the reward,
    but also the effort of finding a proof-of-work solution, and therefore bearing
    the expense of electricity without reimbursement.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 那些不诚实行事的人会被拒绝他们的区块，不仅失去奖励，还失去了找到工作证明解决方案的努力，并因此承担了电费而没有获得补偿。
- en: When a node receives a new block, it verifies it by comparing it to a large
    set of requirements that must all be met; otherwise, the block is eliminated.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点接收到新区块时，它通过将其与必须满足的大量要求进行比较来验证它；否则，该区块将被淘汰。
- en: 'These is a list of the most significant characteristics that can be summarized:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以总结的最重要的特征列表：
- en: The block’s structure and syntax are correct.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块的结构和语法是正确的。
- en: The target value is accurate.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标值是准确的。
- en: It’s important to realize that the block header hash is easier than the target
    difficulty (proof of work check).
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要意识到，区块头哈希值比目标难度（工作证明检查）要容易。
- en: The block timestamp is less than two hours in the future (holding timing faults).
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块的时间戳比未来两小时小（保持时间故障）。
- en: The block size follows the protocol’s criteria.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块大小遵循协议的标准。
- en: The initial transaction is made with coinbase.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始交易是使用 coinbase 进行的。
- en: The transactions contained therein are valid (recheck transactions using the
    verification criteria outlined in the transaction flow).
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中包含的交易是有效的（使用交易流程中概述的验证标准重新检查交易）。
- en: As a result, independent validation ensures that miners cannot cheat. Miners
    must construct a complete block based on a shared protocol or set of rules observed
    by all nodes and extract it using a proper proof of work solution. They use a
    lot of electricity to do this, and if they cheat, all of the electricity and effort
    is squandered. Therefore, the validation not depended on is a key part of the
    decentralized consensus.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，独立验证确保了矿工不能作弊。矿工必须基于所有节点观察到的共享协议或一组规则构建完整的区块，并使用适当的工作量证明解决方案进行提取。他们会用大量的电来做这件事，如果他们作弊，所有的电力和努力都会被浪费。因此，不依赖于验证是分散式共识的关键部分。
- en: 3.7.7 The Blockchain Forks
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链分叉
- en: Different copies of the blockchain are not always constant because it is a decentralized
    data architecture. Blocks could arrive at different times on different nodes,
    giving nodes different perspectives on the blockchain. To tackle this problem,
    each node picks the most effective proof of work blockchain, also known as the
    highest chain or chain with the greatest cumulative difficulty, and tries to extend
    it as much as possible.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的不同副本并不总是恒定的，因为它是一种分散的数据架构。区块可能在不同的节点上以不同的时间到达，从而给节点带来了对区块链不同的视角。为了解决这个问题，每个节点选择最有效的工作量证明区块链，也称为最高链或具有最大累积难度的链，并尽可能扩展它。
- en: A node can calculate the total amount of proof of work used to form a chain
    by summing the difficulty recorded in each block.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点可以通过总结每个区块中记录的难度来计算用于形成链的工作量证明的总量。
- en: The global Bitcoin network eventually converges to a coherent state by the time
    all nodes select the longest cumulative chain of difficulty.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 全球比特币网络最终通过在所有节点选择具有最长累积难度链的链路来收敛到一个连贯的状态。
- en: 'The nodes manage three groups of blocks:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 节点管理三组区块：
- en: The first is the one that is linked to the main blockchain.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是链接到主区块链的。
- en: The blocks that do not have a known parent in known chains.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已知链中没有已知父级的区块。
- en: The blocks that constitute the branches of the main blockchain (secondary chains)
    (orphans).
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成主区块链分支（次要链）的区块（孤块）。
- en: When any of the criterion validations fail, the invalid blocks are removed or
    rejected, and they are not included in the chain. You must realize that the main
    chain is the blockchain with the greatest or highest cumulative difficulty at
    any given time.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何标准验证失败时，无效的区块将被移除或拒绝，并且它们不会被包含在链中。你必须意识到，在任何给定时间，主链都是具有最大或最高累积难度的区块链。
- en: Unless there are two chains of equal length, one of which has a larger number
    of functioning proofs, this is usually the chain with the most blocks. When a
    new block is discovered, a node tries to incorporate it into the current blockchain.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 除非存在两条相等长度的链，其中一条具有更多有效证明，否则通常是拥有最多区块的链。当发现新区块时，节点会尝试将其合并到当前的区块链中。
- en: The node examines the previous block’s hash field, which contains the address
    of the new block’s parent. The node will then search the current blockchain for
    that parent. The parent block is the “top” of the main chain in the most recent
    examples, implying that this new block extends the main chain.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 节点会检查前一个区块的哈希字段，其中包含新区块父区块的地址。然后节点将在当前区块链中搜索该父区块。父区块是最近示例中“主”链的顶部，这意味着此新区块扩展了主链。
- en: Additionally, the new block may occasionally extend a chain that isn’t the main
    chain. In this situation, the node connects the new block to the secondary chain,
    allowing it to compare the secondary chain’s difficulty to that of the main chain.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，新区块偶尔可能会扩展不是主链的链。在这种情况下，节点将新区块连接到次级链，使其能够比较次级链的难度与主链的难度。
- en: If the secondary chain has a higher cumulative difficulty than the main chain,
    the node will fall back to it, making the secondary chain the new parent chain
    and the former main chain a secondary chain.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果次级链的累积难度高于主链，则节点会回退到次级链，使次级链成为新的父链，而原来的主链则成为次级链。
- en: If a good lock is received but no parent is discovered in the current chains,
    the block is referred to as an *orphan*. The orphaned blocks are placed in the
    orphaned blocks pool and will remain there until their parent arrives.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到一个良好的锁定，但在当前链中找不到父块，则该块被称为*孤儿*。孤儿块被放置在孤儿块池中，并将一直留在那里，直到其父块到达。
- en: The orphaned block can be retrieved from the orphan pool and attached to the
    parent once the parent has arrived or been received and joined to the existing
    chains. Keep in mind that orphaned blocks typically occur when two blocks mined
    within a short period of time are received in reverse order. By selecting the
    chain with the highest difficulty, all nodes reach network-level consensus in
    the end.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 孤儿块可以从孤儿池中检索出来，并在其父块到达或被接收并连接到现有链后连接到父块。请记住，孤儿块通常在短时间内收到两个以相反顺序挖掘的块时发生。通过选择难度最高的链，所有节点最终达成网络级共识。
- en: Temporary chain modifications are finally resolved by extending one of the existing
    chains with new proofs of work. Mining nodes use their mining power to “vote”
    for the next block to be extracted. The new block will represent their vote when
    they extract a new block to expand the chain.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 临时链修改最终通过使用新的工作证明来扩展现有的一条链解决。挖掘节点利用其挖掘能力来“投票”以提取下一个区块。当他们提取新块以扩展链时，新块将代表他们的投票。
- en: 3.8 Summary
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 总结
- en: When you think about the term “blockchain,” the main concept that should come
    to mind is Bitcoin, which you learned about in this chapter. I explained the technical
    aspects of Bitcoin, the block structure of the Bitcoin blockchain, and the flow
    of transactions in the blockchain, with examples. To develop a blockchain application,
    you must understand these fundamental concepts.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当你思考“区块链”这个术语时，脑海中应该浮现的主要概念是比特币，这是你在本章学到的内容。我解释了比特币的技术方面，比特币区块链的区块结构，以及区块链中交易的流程，并举了例子。要开发区块链应用程序，你必须理解这些基本概念。
- en: The next chapter focuses on Ethereum, a blockchain-based software platform that
    is primarily used to support the world’s second-largest cryptocurrency by market
    capitalization after Bitcoin.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章重点介绍以太坊，这是一个基于区块链的软件平台，主要用于支持比特币之后市值排名第二的世界上第二大加密货币。
