- en: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal,
    Gautam Dhameja and Priyansu Sekhar PandaBeginning Blockchain[https://doi.org/10.1007/978-1-4842-3444-0_3](A440588_1_En_3_Chapter.xhtml)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018 Bikramaditya
    Singhal, Gautam Dhameja 和 Priyansu Sekhar Panda 著《区块链入门》[https://doi.org/10.1007/978-1-4842-3444-0_3](A440588_1_En_3_Chapter.xhtml)
- en: 3. How Bitcoin Works
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 比特币是如何工作的
- en: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1)Bangalore,
    Karnataka, India(2)Berlin, Berlin, GermanyBlockchain technology is all the rage
    these days, thanks to Bitcoin! blockchain as we know it is a gift of Bitcoin and
    its inventor, Satoshi Nakamoto, to the whole world. If you are wondering who Satoshi
    Nakamoto is, it is the name used by the unknown person or persons who originated
    Bitcoin. We suggest that you understand and appreciate the wonderful technology
    behind Bitcoin without searching for the inventor. Learning the technical fundamentals
    of Bitcoin will enable you to understand the other blockchain applications that
    are there in the market.Since Bitcoin testified to the robustness of blockchain
    technology for years, people now believe in it and have started exploring other
    possible ways to use it. In the previous chapter, we already got the hang of how
    blockchain works at a technical level, but learning Bitcoin can give you the real
    taste of blockchain. You may want to consider Bitcoin as a cryptocurrency use
    case of blockchain technology. So, this chapter will not only help you understand
    how Bitcoin works in particular, but also give you a perspective of how different
    use cases can be built using blockchain technology, the way Bitcoin is built.We
    will cover Bitcoin in greater detail throughout this chapter and while doing so,
    a lot of blockchain fundamentals will also be clarified with more practical insights.
    If you are already familiar with the Bitcoin fundamentals, you may skip this chapter.
    Otherwise, we advise you to follow through the concepts in the order presented.
    This chapter explains what Bitcoin is, how it is designed technically, and provides
    an analysis of some inherent strengths and weaknesses of Bitcoin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Bikramaditya Singhal^(1 ), Gautam Dhameja² 和 Priyansu Sekhar Panda¹(1) 印度卡纳塔克邦班加罗尔(2)
    德国柏林区块链技术如今非常热门，这要归功于比特币！我们所知的区块链是比特币及其发明者中本聪送给全世界的礼物。如果你在想中本聪是谁，那是一个未知个人或团体使用的名字，他们发明了比特币。我们建议你无需寻找发明者，理解和欣赏比特币背后的美妙技术。了解比特币的技术基础将使你能够理解市场上存在的其他区块链应用。由于比特币多年来证明了区块链技术的健壮性，人们现在相信它并开始探索使用它的其他可能方式。在上一章，我们已经了解了区块链在技术层面是如何工作的，但学习比特币可以让你真正体验到区块链的味道。你可能想将比特币视为区块链技术的加密货币用例。因此，这一章不仅会帮助你理解比特币是如何工作的，还会给你一个如何使用区块链技术构建不同用例的视角，就像比特币一样。在本章中，我们将详细介绍比特币，并在介绍的过程中，通过更多实践洞察阐明许多区块链基础知识。如果你已经熟悉比特币的基础知识，你可以跳过这一章。否则，我们建议你按照呈现的顺序跟随这些概念。这一章解释了比特币是什么，它是如何从技术上设计的，并提供了对比特币某些固有优势和缺点的分析。
- en: The History of Money
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 货币的历史
- en: 'Ever wonder what money is and why it even exists? Money is primarily the medium
    of exchange for exchanging value, that is anything of value. It has a history
    to it. We will quickly recap the history to be able to understand how money has
    eveolved to how we know it today, and how Bitcoin furthers it to the next level.Not
    everyone has everything. In the good old days when there were no notions of currency
    or money, people still figured out how they could exchange what they had in surplus
    for what they needed from someone else. Those were the days of the barter system.
    Wheat in exchange for peddy or oranges for lemons was the system. This was all
    good, but what if someone having wheat needs medicine that the other person does
    not have? Example: Alice has wheat and needs medicine, but Bob knows she has access
    to someone who has oranges, and Bob needs wheat. In this situation, the exchange
    is not working out. So, they have to find a third person, Charlie, who might need
    oranges and as well has surplus medicine. A pictorial representation of this scenario
    is shown in Figure [3-1](#Fig1).![A440588_1_En_3_Fig1_HTML.jpg](Images/A440588_1_En_3_Fig1_HTML.jpg)Figure
    3-1The primitive barter systemIt was always tough to find a person such as Charlie
    in the previous example who could fit in the puzzle so easily; this problem had
    to be solved. So, people started thinking of a commoditized system of value exchange.
    There were a few items that everyone would need, such as milk, salt, seeds, sheep,
    etc. This system almost worked out! Soon after, people realized that it was quite
    inconvenient and difficult to store such commodities.Eventually, better techniques
    were found to be used as financial instruments, such as metal pieces. People valued
    the rare metals more than the usual ones. Gold and silver metals topped the list
    as they wouldn’t corrode. Then countries started minting their own currency (metal
    coins with different weights) with their official seal in them. Though the metal
    pieces and coins were better than the previous system, as one could easily store
    and carry them, they were vulnerable to theft. Temples came into rescue as people
    trusted in them and had a strong belief that no one would steal from temples.
    The priests would give a receipt to the person depositing gold that would mention
    the amount of gold/silver received, as a promise to acknowledge their deposit
    and give back to the bearer of the receipt the same when they returned. The person
    bearing the receipt could circulate the receipt in the market to get what they
    wanted. This was the beginning of our banking system. The receipt worked, as the
    fiat currency and the temples played the role of centralized banks that people
    trusted. Refer to Figure [3-2](#Fig2) to understand how this system appeared back
    then.![A440588_1_En_3_Fig2_HTML.jpg](Images/A440588_1_En_3_Fig2_HTML.jpg)Figure
    3-2The beginning of the banking eraIn the system just mentioned, currency was
    always backed by some precious metal such as gold or silver. This system continued
    even after the goverenments and banks replaced the temples. This is how the commodity
    currency came up in the market to enable a universal medium of value exchange
    for the goods and services. Whatever currency was there in those days was all
    backed by gold/silver.Slowly, “fiat currency  ” was introduced by the governments
    as legal tender, which was no longer backed by gold or silver. It was purely trust
    based, in the sense that people did not have a choice but to trust the government.
    Fiat currency does not have any intrinsic value, it is just backed by the government.
    Today, the money that we know of is all fiat currencies. So, the value of money
    today depends on the stability and performance of the governments in whose jurisdiction
    the currency is being issued and used. Those paper currencies were the money themselves
    and there was nothing more valubale in the banks. This was the state of banking
    systems and at the same time the digital world was just forming up.Around the
    1990s, the Internet world was gaining momentum and the banking systems were getting
    digitized. Since some level of discomfort was still there with fiat currencies,
    since they were perishable and vulnerable to theft, banks assured that people
    could just go digital! This was the era when even the paper notes weren’t required
    to be printed. Money became the digital numbers in the computer systems of banks.
    Today, if every account holder went to their respectve bank and demanded the currency
    notes for the amount of money they hold in their accounts, the banks would be
    in big trouble! The total real money in circulation is extremely marginal compared
    with the amount of digital money worldwide.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有想过金钱究竟是什么，以及它为何存在？金钱主要是用于交换价值的媒介，即任何有价值的东西。它有一个历史。我们将快速回顾一下历史，以便能够理解金钱是如何演变成今天我们所知的模样，以及比特币是如何将其推向下一个阶段的。并非人人拥有的一切。在过去的好日子里，当时还没有货币或金钱的概念，人们还是想出了如何用他们过剩的东西交换他们需要的别人的东西。那是实物交换系统的日子。小麦换取大米或橙子换柠檬就是这样的系统。这很好，但如果有人需要小麦而另一个人却没有呢？例子：爱丽丝有小麦需要药品，但鲍勃知道她能从拥有橙子的人那里得到，而鲍勃需要小麦。在这种情况下，交换无法进行。所以，他们必须找到第三个人，查理，他可能需要橙子，同样也有过剩的药品。这种情况的图示如图[3-1](#Fig1)所示。![A440588_1_En_3_Fig1_HTML.jpg](Images/A440588_1_En_3_Fig1_HTML.jpg)图3-1原始实物交换系统过去，要找到像查理这样的人是很难的，这个人能如此容易地适配这个拼图；这个问题必须解决。所以，人们开始考虑一个有形价值交换的商品化系统。有一些每个人都需要的东西，比如牛奶、盐、种子、羊等。这个系统几乎行得通！不久之后，人们意识到，这样的商品存储既不方便又困难。最终，发现了可以作为金融工具使用的更好技术，比如金属片。人们更看重稀有金属而不是普通金属。因为它们不会生锈，金和银金属位居榜首。然后，国家开始铸造自己的货币（不同重量的金属硬币），并在其中印上官方印章。尽管金属片和硬币比以前的系统更好，因为一个人可以很容易地存储和携带它们，但它们容易遭到盗窃。寺庙来帮忙，因为人们信任它们，并坚信没有人会从寺庙里偷东西。僧侣会给存金的人一个收据，上面提到收到的黄金/银的数量，作为承认他们的存款并承诺在持票人回来时归还相同数量的承诺。持票人可以在市场上流通收据，以得到他们想要的东西。这就是我们银行系统的开始。收据起了作用，因为法定货币和寺庙扮演了人们信任的中心银行的角色。参考图[3-2](#Fig2)了解这个系统当时的外观。![A440588_1_En_3_Fig2_HTML.jpg](Images/A440588_1_En_3_Fig2_HTML.jpg)图3-2银行时代的开始在刚才提到的系统中，货币总是由某种珍贵金属，如金或银支持。这个系统在政府和国际银行取代寺庙后继续存在。这就是商品货币进入市场，为商品和服务提供一种普遍的价值交换媒介的原因。那些日子里有的货币都是用金/银支持的。渐渐地，“法定货币”由政府作为法定货币引入，这种货币不再由金或银支持。它完全是基于信任的，意思是人们别无选择，只能信任政府。法定货币没有任何内在价值，它只是由政府支持的。今天，我们所知道的货币都是法定货币。因此，当今货币的价值取决于发行和使用该货币的政府的稳定性和表现。那些纸币本身就是货币，银行里没有更有价值的东西。这是银行系统和同时数字世界形成的状态。在20世纪90年代左右，互联网世界势头正盛，银行系统正在数字化。由于对法定货币仍存在一定的不适感，因为它们容易损坏和被盗，银行保证人们可以完全数字化！这是连纸钞都不需要印刷的时代。货币变成了银行计算机系统中的数字。今天，如果每个账户持有者都去他们各自的银行要求把账户里持有的金额换成纸币，银行会遇到大麻烦！与全球范围内的数字货币相比，流通中的真实货币极其有限。
- en: Dawn of Bitcoin
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特币的黎明
- en: In the first chapter we looked at the technology aspects of the Internet revolution,
    and in the previous section of this chapter we looked at the evolution of money.
    We should now look at them side by side to understand Satoshi Nakamoto’s perspective
    behind designing Bitcoin—a cryptocurrency. In this section and elsewhere in this
    text, we will try to elaborate on Satoshi’s statements in the paper he wrote on
    Bitcoin.We learned about temples and then governments and banks for the role they
    played in the currency systems that eveolved from barter systems. Even today,
    the situation is just the same. If you zoom in a bit on these systems, you will
    find that the one pivotal thing that makes these systems stable is the “trust”
    element. People trusted temples, and then they trusted governments and banks.
    The entire commerce on the Internet today relies on the centralized, trusted third
    parties to process payments. Though the Internet was designed to be peer-to-peer,
    people build centralized systems on it to reflect the same old practice. Well,
    technically building a peer-to-peer system back in the 2000s was quite tough considering
    the maturity of technology during that time. Consequently, the cost of transactions,
    time taken for a transaction to settle, and other issues due to centralization
    were obvious. This wasn’t the case with physical currencies, as transactions meant
    settlement.Could there be a digital currency backed by computing power, the same
    way gold was used to back the money in circulation? The answer is “Yes,” thanks
    to Satoshi’s Bitcoins. Bitcoins are designed to enable electronic payments between
    two parties based on cryptographic proof, and not based on trust due to intermediary
    third parties. It is possible today because of the technological advancements.
    In this chapter, we will see how Satoshi Nakamoto combined cryptography, game
    theory, and computer science engineering fundamentas to design the Bitcoin system
    in 2008\. After it went live in 2009 and till today, the system is quite stable
    and robust enough to sustain any kind of cyber attacks. It stood the test of time
    and positioned itself as a global currency.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们探讨了互联网革命的科技方面，而在本章的前一部分，我们研究了货币的演变。现在，我们应该将它们并排放置，以了解设计比特币——一种加密货币背后的中本聪的观点。在本节以及本文的其他部分，我们将尝试详细阐述中本聪在关于比特币的论文中的观点。我们了解了寺庙，然后是政府和银行在货币系统中从实物交易系统中扮演的角色。时至今日，情况依然如此。如果你对这些系统稍微放大一点，你会发现使这些系统稳定的关键因素是“信任”元素。人们信任寺庙，然后信任政府和银行。今天互联网上的整个商业活动都依赖于中心化的、值得信赖的第三方来处理支付。尽管互联网被设计成点对点的方式，但人们在其上建立中心化系统，以反映同样的旧做法。技术上来说，在2000年代建立一个点对点系统是相当困难的，考虑到当时技术的成熟度。因此，由于中心化，交易成本、交易结算所需时间以及其他问题都是显而易见的。这并不是实物货币的情况，因为实物货币的交易意味着结算。有没有可能存在一种由计算能力支撑的数字货币，就像黄金被用来支撑流通中的货币一样？答案是“是的”，多亏了中本聪的比特币。比特币旨在基于加密证明，而不是基于中介第三方信任，实现两个方之间的电子支付。这之所以可能，是因为技术的进步。在本章中，我们将了解中本聪如何结合密码学、博弈论和计算机科学工程基础知识，在2008年设计比特币系统。自2009年上线以来，该系统非常稳定，足够健壮，能够承受任何网络攻击。它经住了时间的考验，将自己定位为一种全球货币。
- en: What Is Bitcoin?
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是比特币？
- en: 'Blockchain offers cryptocurrency: digital money! Just as we can transact with
    physical currency without banks or other centralized entities, Bitcoin is designed
    to facilitate peer-to-peer monetary transactions without trusted intermediaries.
    Let us look at what it is and then learn later in the chapter how it really works.
    Bitcoin is a decentralized cryptocurrency that is not limited to any nation and
    is a global currency. It is decentralized in every aspect—technical, logical,
    as well as political. As and when the transactions are validated, new Bitcoins
    get mined and a maximum of 21 million Bitcoins can ever be produced. Approximately,
    to reach 21 million Bitcoins, it would be take until the year 2140\. Anyone with
    good computing power can participate in mining and generate new Bitcoins. After
    all the Bitcoins get generated, no new coins can be minted and only the ones in
    circulation would be used. Note that Bitcoins do not have fixed denominations
    such as the national fiat currencies. As per design, the Bitcoins can have any
    value with eight decimal places of precision. So, the smallest value in Bitcoin
    is 0.00000001 BTC, which is called 1 Satoshi.The miners mine the transactions
    to mint new coins and also consume the transaction fee that the person willing
    to make a transaction is ready to pay. When the total number of coins reaches
    21 million, the miners would validate the transactions solely for the transaction
    fees. If someone tries to make a transaction without a transaction fee, it may
    still get mined because it is a valid transaction (if at all it is) and also the
    miner is more interested in the mining reward that lets him generate new coins.Are
    you wondering what decides the value of Bitcoins? When currency was backed by
    gold, it had great significance and was easy to assess the value based on gold
    standards. When we say Bitcoin is backed by the computing power that people use
    for mining, that is not enough to understand how it attains its value. Here is
    a litle bit of economics required to understand it.When fiat currency was launched
    for the first time, it was backed by gold. Since people believed in gold, they
    believed in currency as well. After a few decades, currency was no longer backed
    by gold and was totally dependent on the governments. People continued believing
    in it because they themselves form or contribute to the formation of their own
    government. Since the governments ensure its value, and people trust it, so it
    attains that value. In an international setting, the value of currency of specific
    countries depends on various factors and the most important of them is “supply
    and demand.” Please keep in mind that some countries that printed a lot of fiat
    currency notes went bankrupt; their economy went down! There has to be a balance
    and to understand this, more economics is needed, which is beyond the scope of
    this book. So, let us get back to Bitcoins for now.When Bitcoin was first launched,
    it did not have any official price or value that people would believe. If one
    would sell it for some US dollars (USD), I would never have bought those initially.
    Gradually when the exchange started taking place, it developed a price and one
    Bitcoin was not even one USD then. Since Bitcoins are generated by a competitive
    and decentralized process called “mining,” and they are generated at a fixed rate
    with an upper cap of 21 million Bitcoins in total that can ever exist, this makes
    Bitcoin a scarce resource. Now relating this context back to the game of “supply
    and demand,” the value of Bitcoin started inflating. Slowly, when the entire globe
    started believing in it, its price even skyrocketed from a few USDs to thousands
    of USDs. Bitcoin adoption among the users, merchants, start-ups, big businesses,
    and many others is growing like never before because they are being used in the
    form of money. So, the value of Bitcoin is highly influenced by “trust,” “adoption,”
    and “supply and demand” and its price is set by the market.Now, the question is
    why the value of Bitcoin is so volatile as of this writing and fluctuates quite
    a lot. One obvious reason is supply and demand. We learned that there can only
    be a limited number of Bitcoins in circulation, which is 21 million, and the rate
    at which they get generated is decreeasing with time. Because of this design,
    there is always a gap in supply and demand, which results in this volatility.
    Another reason is that Bitcoins are never traded in one place. There are so many
    exchanges in so many places across the globe, and all those exchanges have their
    own exchange prices. The indexes that you see gather Bitcoin exchange prices from
    several exchanges and then average them out. Again, since all these indexes do
    not collect data from the same set of exchanges, even they do not match. Similarly,
    the liquidity factor that implies the amount of Bitcoins flowing through the entire
    market at any given time also influences the volatility in Bitcoin price. As of
    now, it is definitely a high-risk asset but may get stabilized with time. Let
    us take a look at the following list of factors that may influence the supply
    and demand of Bitcoins, and hence their price:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链提供了加密货币：数字货币！就像我们可以不通过银行或其他中心化实体使用实体货币进行交易一样，比特币被设计成无需可信中介就能促进点对点货币交易。让我们先看看它是什么，然后再在本章中学习它是如何真正工作的。比特币是一种去中心化的加密货币，不受任何国家的限制，是一种全球货币。它在技术、逻辑以及政治方面都是去中心化的。交易一旦得到验证，新的比特币就会被挖掘出来，而且最多只能生产出2100万个比特币。大约要达到2100万个比特币，得等到2140年。任何拥有强大计算能力的人都可以参与挖掘并生成新的比特币。所有比特币生成后，就无法铸造新的硬币，只能使用流通中的那些。请注意，比特币没有像国家法定货币那样的固定面值。根据设计，比特币可以有任意价值，精确到八位小数。因此，比特币的最小值是0.00000001
    BTC，称为1 Satoshi。矿工挖掘交易以生成新硬币，同时也消耗愿意进行交易的人支付的交易费。当硬币总数达到2100万个时，矿工将仅为交易费而验证交易。如果有人尝试进行没有交易费的交易，它可能仍会被挖掘，因为这是一个有效的交易（如果有的话），而且矿工更感兴趣的是挖掘奖励，这让他能生成新硬币。您是否想知道是什么决定了比特币的价值？当货币由黄金支持时，它具有很大的意义，并且根据黄金标准很容易评估其价值。当我们说比特币是由人们用于挖掘的计算能力支持时，这并不足以理解它如何获得其价值。这里需要一点经济学知识来理解它。当法定货币首次推出时，它是由黄金支持的。由于人们相信黄金，所以他们相信货币。几十年后，货币不再由黄金支持，完全依赖于政府。人们继续相信它，因为他们自己形成或贡献了形成他们自己的政府。由于政府确保其价值，而人们信任它，所以它获得了那个价值。在国际环境中，特定国家的货币价值取决于各种因素，其中最重要的是“供求关系”。请记住，一些印刷了大量法定货币的国家破产了；他们的经济下滑了！必须保持平衡，要理解这一点，需要更多的经济学知识，这超出了本书的范围。所以，现在让我们回到比特币的话题。当比特币首次推出时，它没有人们相信的官方价格或价值。如果有人用一些美元（美元）出售它，我当初绝不会购买那些。逐渐地，当开始进行交易时，它发展出了一个价格，当时一个比特币甚至不是一美元。由于比特币是通过一个竞争性和去中心化的过程
    called “挖掘” 生成的，并且它们以固定的速率生成，总上限为2100万个比特币，这使得比特币成为一个稀缺资源。现在，将这个上下文关联到“供求关系”的游戏中，比特币的价值开始膨胀。慢慢地，当整个地球开始相信它时，它的价格甚至从几美元猛涨到几千美元。比特币在用户、商家、初创公司、大型企业等方面的采用率正以前所未有的速度增长，因为它们被用作货币。因此，比特币的价值受到“信任”、“采用”和“供求关系”的高度影响，而其价格由市场决定。现在，问题是为什么比特币的价值如此波动，并且截至撰写本文时波动很大。一个明显的原因是供求关系。我们了解到，流通中的比特币数量有限，总共2100万个，而且它们生成的速度随时间减少。由于这个设计，供应和需求之间总是存在差距，从而导致这种波动。另一个原因是比特币从未在一个地方交易。世界上有那么多地方都有那么多交易所，所有这些交易所都有自己的交易价格。您看到的指数从几个交易所收集比特币交易价格，然后平均它们。同样，由于所有这些指数没有从同一组交易所收集数据，甚至它们也不匹配。同样，流动性因素也说明在任何给定时间整个市场流动的比特币数量，也影响比特币价格的波动。到目前为止，比特币绝对是一种高风险资产，但随着时间的推移可能会稳定下来。让我们看看以下可能影响比特币供求和价格的因素列表：
- en: Confidence of people in Bitcoin and fear of uncertainty
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们对比特币的信心以及对不确定性的恐惧
- en: Press coverage with good and bad news on Bitcoin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体对比特币的好坏消息报道
- en: Some people own Bitcoins and do not allow them to flow through the market and
    some people keep buying and selling to minimize risk. This is why the liquidity
    level of Bitcoin keeps on changing.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人拥有比特币，并阻止它们流入市场，而有些人则通过买卖来最小化风险。这就是比特币流动性水平不断变化的原因。
- en: Acceptance of Bitcoins by big ecommerce giants
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型电子商务巨头接受比特币
- en: Banning of Bitcoins in specific countries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定国家对比特币的禁令
- en: If you are now wondering if there is any possibility of Bitcoin to crash completely,
    then the answer is “Yes.” There are many examples of countries whose currency
    systems have crashed. Well, there were political and economic reasons for them
    to crash such as hyperinflation, which is not the case with Bitcoins because one
    cannot generate as many Bitcoins as they want and the total number of Bitcoins
    is fixed. However, there is a possibility of technical or cryptographic failure
    of Bitcoins. Please note that Bitcoin has stood the test of time since its inception
    in 2008 and there is a possibility that it will grow much bigger with time, but
    it cannot be guaranteed!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想知道比特币是否有可能彻底崩溃，那么答案是“是的。”有许多国家的货币体系已经崩溃的例子。好吧，它们崩溃的原因可能有政治和经济因素，比如超级通货膨胀，但这不是比特币的情况，因为无法制造出尽可能多的比特币，而且比特币的总数是固定的。然而，比特币存在技术或密码学失败的可能性。请注意，自2008年创立以来，比特币已经经受了时间的考验，并且随着时间的推移，它可能会变得更大，但无法保证！
- en: Working with Bitcoins
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用比特币
- en: In order to get started with Bitcoins, no technicality is needed. You just have
    to download a Bitcoin wallet and get started with it. When you download and install
    a wallet on your laptop or mobile, it generates your first Bitcoin address (public
    key). You can generate many more, however, and you should. It is a best practice
    to use the Bitcoin addresses only once. Address reuse is an unintended practice
    in Bitcoin, though it works. Address reuse can harm privacy and confidentiality.
    As an example, if you are reusing the same address, signing a transaction with
    the same private key, the recipient can easily and reliably determine that the
    address being reused is yours. If the same address is used with multiple transactions,
    they can all be tracked and finding who you are gets even easier. Remember that
    Bitcoin is not fully anonymous; it is said to be pseudonymous and there are ways
    to trace the transaction origins that can reveal the owners.You have to disclose
    your Bitcoin address to the person willing to transfer Bitcoins to you. This is
    very safe because the public key is public anyway. We know that there is no notion
    of a closing balance in Bitcoin and all records are there as transactions. Bitcoin
    wallets can easily calculate their spendable balance, as they have the private
    keys of the corresponding public keys on which transactions are received. There
    are a variety of Bitcoin wallets available from so many wallet providers. There
    are mobile wallets, desktop wallets, browser-based web wallets, hardware wallets,
    etc., with varying levels of security. You need to be extremely careful in the
    wallet security aspect while working with Bitcoins. The Bitcoin payments are irreversible.You
    must be wondering how secured are these wallets. Well, different wallet types
    have different leves of security and it depends on how you want to use it. Many
    online wallet services suffered from security breaches. It is always a good practice
    to enable two-factor authentication whenever applicable. If you are a regular
    user of Bitcoins, it may be a good idea to use small amounts in your wallets and
    keep the remainder separately in a safe environment. An offline wallet or cold
    wallet that is not connected to the network provides the highest level of security
    for savings. Also, there should be proper backup mechanisms for your wallet in
    case you lose your computer/mobile. Remember that if you lose your private key,
    you lose all the money associated with it.If you have not joined Bitcoin as a
    miner running a full node, then you can just be a user or a trader of Bitcoins.
    You will definitely need an exchange from where you can buy some Bitcoins with
    your US dollars or other currencies as accepted by the exchanges. You should prefer
    buying Bitcoins from a legitimate and secured exchange. There have been many examples
    of exchanges that suffered from security breaches.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用比特币，你不需要任何技术知识。你只需要下载一个比特币钱包，然后开始使用。当你在笔记本电脑或手机上下载并安装钱包后，它会生成你的第一个比特币地址（公钥）。你可以生成更多的地址，这是推荐的做法。最佳实践是仅使用比特币地址一次。在比特币中，地址重复使用是不意图的行为，尽管它有效。地址重复使用可能会损害隐私和保密性。例如，如果你重复使用同一个地址，用相同的私钥签署交易，收件人可以很容易且可靠地确定被重复使用的地址是你的。如果同一个地址用于多个交易，它们都可以被追踪，找到你是越来越容易的。要记住的是，比特币并非完全匿名；它被认为是假名，有方法可以追踪交易起源，揭示所有者。你必须向愿意向你转账比特币的人透露你的比特币地址。这非常安全，因为公钥本来就是公开的。我们知道比特币中没有结余的概念，所有记录都作为交易存在。比特币钱包可以轻松计算其可支配余额，因为它们拥有相应公钥的私钥，这些公钥收到了交易。有许多比特币钱包可供选择，来自许多钱包提供商。有移动钱包、桌面钱包、基于浏览器的网络钱包、硬件钱包等，安全性各不相同。在使用比特币时，你必须在钱包安全方面保持极其谨慎。比特币支付是不可逆的。你可能想知道这些钱包有多安全。嗯，不同类型的钱包有不同的安全级别，这取决于你想要如何使用它。许多在线钱包服务遭受了安全漏洞。始终在适用的情况下启用双因素认证是一个好习惯。如果你是比特币的常用户，将少量比特币存放在钱包中，并将剩余部分保存在安全的环境中可能是个好主意。不连接到网络的离线钱包或冷钱包为储蓄提供了最高的安全级别。此外，应为你的钱包建立适当的备份机制，以防你丢失电脑/手机。记住，如果你丢失了私钥，与之关联的所有资金都会丢失。如果你没有作为运行完整节点的矿工加入比特币，那么你可以只是比特币的用户或交易者。你肯定需要一个交易所，从那里你可以用美元或其他被交易所接受的货币购买一些比特币。你应该选择从合法和安全的交易所购买比特币。已经有很多交易所遭受了安全漏洞的例子。
- en: The Bitcoin Blockchain
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特币区块链
- en: 'We already looked at the basic blockchain data structure in the previous chapter
    and also covered the basic building blocks of a blockchain data structure such
    as hashing techniques and asymmetric cryptography. We will learn the specifics
    of Bitcoin blockchain in this section.The Bitcoin blockchain, like any other blockchain,
    has a similar blockchain data structure. The Bitcoin Core client uses the LevelDB
    database of Google to store the blockchain datastructure internally. Each block
    is identified by its hash (Bitcoin uses the SHA256 hashing algorithm). Every block
    contains the hash of the previous block in its header section. Remember that this
    hash is not just the hash of the previous header but the entire block including
    header, and it continues all the way to the genesis block. The genesis block is
    the beginning of any blockchain. Typically, a Bitcoin blockchain looks as shown
    in Figure [3-3](#Fig3).![A440588_1_En_3_Fig3_HTML.jpg](Images/A440588_1_En_3_Fig3_HTML.jpg)Figure
    3-3The Bitcoin blockchainAs you can see in this blockchain, there is a block header
    part that contains the header information and there is a body part where the transactions
    are bundled in every block. Every block’s header contains the hash of the previous
    block. So, any change in any block in the chain will not be so easy; all the subsequent
    blocks have to be changed accordingly. Example: If someone tries to change a previous
    transaction that was captured in, say, block number 441, after changing the transaction,
    the hash of this block that is in the header of block number 442 will not match,
    so it has to be changed as well. Changing the header with the new hash will then
    require you to update the hash in the block header of the next block in the sequence,
    which is block number 443, and this will go on till the current block and this
    is tough work to do. It beccomes almost impossible when we know that every node
    has it’s own copy and hacking into all the nodes, or at least 51% of them, is
    infeasible.In the blockchain, there is only one true path to the genesis block.
    However, if you start from the genesis block, then there can be forks. When two
    blocks are proposed at the same time and both of them are valid, only one of them
    would become a part of the true chain and the other gets orphaned. Every node
    builds on the longest chain, and whichever it hears first and whichever becomes
    the longest chain will be the one to build on. Such a scenario can be represented
    as shown in Figure [3-4](#Fig4).![A440588_1_En_3_Fig4_HTML.jpg](Images/A440588_1_En_3_Fig4_HTML.jpg)Figure
    3-4Orphan blocks in true blockchainObserve in Figure [3-4](#Fig4) that at block
    height-3, two blocks are proposed to become block-3, but only one of them could
    make it to the final blockchain and the rest got orphaned out. It is evident that
    at a certain block height, there is a possibility of one or more blocks because
    there can as well be some orphaned blocks at this height, so block height is not
    the best way to uniquely identify a block and block hash is the right way to do
    so.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章已经介绍了区块链的基本数据结构，并且也覆盖了区块链数据结构的基本构建模块，如哈希技术和非对称加密。在本节中，我们将学习比特币区块链的具体内容。比特币区块链，像任何其他的区块链一样，有着类似的区块链数据结构。比特币核心客户端内部使用谷歌的LevelDB数据库来存储区块链数据结构。每个区块都由其哈希值（比特币使用SHA256哈希算法）来标识。每个区块的头部部分都包含前一个区块的哈希值。记住，这个哈希值不仅仅是前一个头部的哈希值，而是包括整个区块，包括头部，一直追溯到创世区块。创世区块是任何区块链的开始。通常，比特币区块链如图[3-3](#Fig3)所示。![A440588_1_En_3_Fig3_HTML.jpg](Images/A440588_1_En_3_Fig3_HTML.jpg)图3-3
    比特币区块链正如你在这个区块链中所看到的，有一个区块头部部分包含了头部信息，还有一个体部分，交易被每块捆绑在一起。每个区块的头部都包含前一个区块的哈希值。所以，链中任何区块的变化都不会那么容易；所有后续的区块都必须要相应地改变。例如：如果有人尝试改变被捕捉在，比如说，区块号码441中的先前交易，在改变交易后，这个区块中在区块号码442的头部中的哈希值将不匹配，所以它也必须要改变。用新的哈希值改变头部然后就需要你更新序列中下一个区块，即区块号码443的头部中的哈希值，这将会一直持续到当前区块，这是艰苦的工作。当我们知道每个节点都有自己的副本，或者至少51%的节点，是不可能被黑入的，所以这几乎是不可能做到的。在区块链中，只有一个真正的路径可以追溯到创世区块。然而，如果你从创世区块开始，那么可能会出现分叉。当同时提出两个区块并且它们都是有效的，只有一个会成为真正链的一部分，另一个就会被孤立。每个节点都建立在最长的链上，无论它先听到哪个，哪个成为最长的链，它就会基于哪个构建。这种情况可以如图[3-4](#Fig4)所示。![A440588_1_En_3_Fig4_HTML.jpg](Images/A440588_1_En_3_Fig4_HTML.jpg)图3-4
    真实区块链中的孤立区块观察图[3-4](#Fig4)中，在区块高度3时，有两个区块被提出成为区块3，但只有一个能最终成为最终的区块链，其他的都被孤立出去。很明显，在某个区块高度，有一个或多个区块的可能性，因为在这个高度也可能有一些被孤立的区块，所以区块高度不是唯一标识一个区块的最好方式，区块哈希值是正确的方式。
- en: Block Structure
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块结构
- en: The block structure of a Bitcoin blockchain is fixed for all blocks and has
    specific fields with their corresponding required data. Take a look at Figure
    [3-5](#Fig5), a birds-eye view of the entire block structure, and then we will
    learn more about the individual fields later in this chapter.![A440588_1_En_3_Fig5_HTML.jpg](Images/A440588_1_En_3_Fig5_HTML.jpg)Figure
    3-5Block structure of Bitcoin blockchainA typical block structure appears as shown
    in Table [3-1](#Tab1).Table 3-1Block Structure
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链的区块结构对所有区块来说是固定的，并具有特定的字段及其相应的必需数据。请查看图[3-5](#Fig5)，这是整个区块结构的全景视图，然后我们将在本章后面了解更多关于各个字段的内容。![A440588_1_En_3_Fig5_HTML.jpg](Images/A440588_1_En_3_Fig5_HTML.jpg)图3-5比特币区块链结构
- en: '| Field | Size | Description |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 大小 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Magic Number | 4 bytes | It has a fixed value 0xD9B4BEF9, which indicates
    the start of the block and also that the block is from the mainnet or the production
    network. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 魔数 | 4字节 | 它有一个固定值0xD9B4BEF9，表示块的开始，也表明该块来自主网或生产网络。 |'
- en: '| Block Size | 4 bytes | This indicates the size of the block. The original
    Bitcoin blocks are of 1MB and there is a newer version of Bitcoin called “Bitcoin
    Cash” whose block size is 2MB. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 区块大小 | 4字节 | 这指示区块的大小。原始的比特币区块是1MB，还有一种名为“比特币现金”的新比特币版本，其区块大小为2MB。 |'
- en: '| Block Header | 80 bytes | It comprises much information such as Previous
    Block’s hash, Nonce, Merkle Root, and many more. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 区块头部 | 80字节 | 它包含诸如前一个区块的哈希、Nonce、Merkle根等许多信息。 |'
- en: '| Transaction Counter | 1–9 bytes (variable length) | It indicates total number
    of transactions that are included within the block. Not every transaction is of
    the same size, and there is a variable number of transactions in every block.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 交易计数器 | 1–9字节（可变长度） | 它指示包含在区块内的交易的总数。并非每个交易的大小都相同，每个区块中都有可变数量的交易。 |'
- en: '| Transaction List | Variable in number but fixed in size | It lists all the
    transactions that are taking place in a given block. Depending on block size (whether
    1MB or 2MB), this field occupies the remaining space in a block. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 交易列表 | 数量可变但大小固定 | 它列出了给定区块中进行的所有交易。根据区块大小（1MB或2MB），此字段占用区块中的剩余空间。 |'
- en: Let us now zoom in (Table [3-2](#Tab2)) to the “Block Header” section of the
    blocks and learn the various different fields that it maintains.Table 3-2Block
    Header Components
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们放大（表[3-2](#Tab2)）到区块的“区块头部”部分，并了解它维护的各种不同字段。表3-2区块头部组件
- en: '| Field | Size | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 大小 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Version | 4 bytes | It indicates the version number of Bitcoin protocol.
    Ideally each node running Bitcoin protocol should have the same version number.
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 4字节 | 它指示比特币协议的版本号。理想情况下，运行比特币协议的每个节点都应该有相同的版本号。 |'
- en: '| Previous Block Hash | 32 bytes | It contains the hash of the block header
    of the previous block in the chain. When all the fields in the previous block
    header are combined and hashed with SHA256 algorithm, it produces a 256-bit result,
    which is 32 bytes. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 前一个区块哈希 | 32字节 | 它包含链中前一个区块的头部哈希。当将前一个块头中的所有字段组合在一起并用SHA256算法进行哈希时，它产生一个256位结果，即32字节。
    |'
- en: '| Merkle Root | 32 bytes | Hashes of the transactions in a block form a Merkle
    tree by design, and Merkle root is the root hash of this Merkle tree. If a transaction
    is modified in the block, then it won’t match with the Merkle root when computed.
    This way it ensures that keeping the hash of the previous block’s header is enough
    to maintain the secured blockchain. Also, Merkle trees help determine if a transaction
    was a part of the block in O(n) time, and are quite fast! |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Merkle根 | 32字节 | 区块中的交易通过设计形成了一个Merkle树，Merkle根是这个Merkle树的根哈希。如果区块中的交易被修改，那么当计算时它不会与Merkle根匹配。这样确保了保持前一个区块头部的哈希就足以维护安全的区块链。此外，Merkle树可以帮助确定一个交易是否是区块的一部分，时间复杂度为O(n)，并且非常快！
    |'
- en: '| Timestamp | 4 bytes | There is no notion of a global time in the Bitcoin
    network. So, this field indicates an approximate time of block creation in Unix
    time format. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | 4字节 | 在比特币网络中没有全球时间的概念。所以，这个字段用Unix时间格式指示区块创建的大致时间。 |'
- en: '| Difficulty Target | 4 bytes | The proof-of-work (PoW) difficulty level that
    was set for this block when it was mined |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 难度目标 | 4字节 | 当这个块被挖掘时，为这个块设置的证明工作（PoW）难度级别 |'
- en: '| Nonce | 4 bytes | This is the random number that satisfied the PoW puzzle
    during mining. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Nonce | 4字节 | 这是一个在挖矿过程中满足PoW谜题的随机数。 |'
- en: The block fields and their corresponding explanations as presented in the previous
    tables are good enough to start with, and we will explore more of only a few fields
    that require a more detailed explanation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 块字段及其相应的解释如前表所示，足够开始使用，我们将探索仅有几个需要更详细解释的字段。
- en: Merkle Tree
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 梅克尔树
- en: We have covered the concept of Merkle trees in the previous chapter. In this
    section, we will just take a look at how Bitcoin uses Merkle trees. Each block
    in a Bitcoin blockchain contains the hash of all the transactions, and the Merkle
    root of all these transactions is included in the header of that block. In a true
    sense, when we say that each block header contains the hash of the entire previous
    block, the trust is that it just contains the hash of the previous block’s header.
    Nonetheless, it is enough, because the header already contains the Merkle root.
    If a transaction in the block is altered, the Merkle root will not match anymore
    and such a design still preserves the integrity of the blockchain.The Merkle tree
    is a tree data structure of the hash of the transactions. The “Leaf Nodes” in
    the Merkle tree actually represent the hash of the transactions, whereas the root
    of the tree is the Merkle root. Refer to Figure [3-6](#Fig6).![A440588_1_En_3_Fig6_HTML.jpg](Images/A440588_1_En_3_Fig6_HTML.jpg)Figure
    3-6Merkle-tree representationNotice that the hash of the seven transactions A,
    B, C, D, E, F, and G form the leaf of the tree. Since there are seven transactions
    but the total leaf nodes should be even in a binary tree, the last leaf node gets
    repeated. Each transaction hash of 32 bytes (i.e., 256 bits) is calculated by
    applying SHA256 twice to the transactions. Similarly, the hash of two transactions
    are concatenated (62 bytes) and then hashed twice with SHA256 to get the parent
    hash of 32 bytes.Only the Merkle path to a transaction is enough to verify if
    a transaction was a part of any block and is quite efficient therefore. So, the
    actual blockchain can be represented as shown in Figure [3-7](#Fig7).![A440588_1_En_3_Fig7_HTML.jpg](Images/A440588_1_En_3_Fig7_HTML.jpg)Figure
    3-7Merkle tree representation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中介绍了梅克尔树的概念。在本节中，我们将看看比特币如何使用梅克尔树。比特币区块链中的每个区块都包含所有交易的哈希值，这些交易的梅克尔根包含在该区块的头部。真正地说，当我们说每个区块头包含整个前区块的哈希时，信任的是它只包含前区块头的哈希。尽管如此，这已经足够了，因为头部已经包含了梅克尔根。如果区块中的交易被更改，梅克尔根将不再匹配，这种设计仍然保持了区块链的完整性。梅克尔树是交易哈希值的树数据结构。“叶节点”在梅克尔树中实际上表示交易的哈希值，而树的根是梅克尔根。参考图[3-6](#Fig6)。![A440588_1_En_3_Fig6_HTML.jpg](Images/A440588_1_En_3_Fig6_HTML.jpg)图3-6梅克尔树表示注意到七个交易A、B、C、D、E、F和G的哈希值形成了树的叶。由于有七个交易，但二进制树的总叶节点应该是偶数，最后一个叶节点被重复。每个32字节的交易哈希（即256位）是通过将交易应用SHA256两次计算得出的。同样，两个交易的哈希被连接（62字节），然后再次用SHA256哈希两次以得到32字节的父哈希。只有到交易的梅克尔路径足以验证交易是否是任何块的一部分，因此非常有效。因此，实际的区块链可以如图[3-7](#Fig7)所示表示。![A440588_1_En_3_Fig7_HTML.jpg](Images/A440588_1_En_3_Fig7_HTML.jpg)图3-7梅克尔树表示
- en: Difficulty Target
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 难度目标
- en: 'The difficulty target is the one that drives the PoW in Bitcoin. The idea is
    that once a block is filled with valid transactions, the hash of that block’s
    header needs to be calculated to be less than the difficulty target in the same
    header. The nonce in the header starts from zero. The miner has to keep on incrementing
    this nonce and hashing the header till the hash value is less than the target.The
    difficulty bits of four bytes (32 bits) in the headers define what would be the
    target value (256 bits) for that block to be mined. The nonce should be found
    such that the hash of the entire header should be less than the target value.
    Remember that the lower the target value, the more difficult it would be to find
    a header hash that would be less than the target. Since Bitcoin uses SHA256, every
    time you hash a block header, the output is any number between 0 and 2^(256),
    which is quite a big number. If with your nonce the hash is less than the target,
    the block will be accepted by the entire network, else you have to try with a
    different nonce till it satisfies the condition. At this point, it is still not
    clear how the difficulty target is calculated with the difficulty bits in each
    header.The target can be derived from the four-byte (8 hexadecimal numbers) difficulty
    bits in the header using a predefined formula that every node has by default,
    as it came along with the binaries during installation. Following is the formula
    to compute the difficulty:target = coefficient * 2^((8 * (exponent – 3)))Notice
    that there is a “coefficient” and there is also an “exponent” term in this formula,
    which are present as a part of the four-byte difficulty bits. Let us take an example
    to explain this better. If the four-byte difficulty bits in hex form are 0x1b0404cb,
    then the first two hex digits form the exponent term, which is (0x1b), and the
    remaining form the coefficient term, which is (0x0404cb) in this case. Solving
    for the target formula with these values:target = 0x0404cb * 2^((0x08 * (0x1b –
    0x03)))target = 0x00000000000404CB000000000000000000000000000000000000000000000000Bitcoin
    is designed such that every 2,016 blocks should take two weeks to be generated
    and if you do the math, it would be around ten minutes for every block. In this
    asynchronous network, it is difficult to program like this where every block takes
    exactly ten minutes with the kind of PoW mechanism in place. In reality, it is
    the average time for a block, and there is a possibility that a Bitcoin block
    gets generated within a minute or it may very well take 15 minutes to be generated.
    So, the difficulty is designed to increase or decrease depending on whether it
    took less or more than two weeks to find 2,016 blocks. This time taken for 2,016
    blocks can be found using the time present in the timestamp fields of every block
    header. If it took, say, T amount of time for 2,016 blocks, which is never exactly
    two weeks, the difficulty target in every block is multiplied by (T / 2 weeks).
    So, the result of [difficulty target × (T / 2 weeks)] will be increased if T was
    less and decreased otherwise.It is evident by now that the difficulty target is
    adjustable; it could be set more difficult or easier depending on the situation
    we explained before. You must be wondering, who adjusts this difficulty when the
    system is decentralized? One rule of thumb that you must always keep in mind is
    that whatever happens in such a decentralized design has to happen individually
    at every node. After every 2,016 blocks, all the nodes individually compute the
    new difficulty target value and they all conclude on the same one because there
    is already a formula defined for it. To have this formula handy, here it is once
    again:    New Target= Old Target * (T / 2 weeks)⇨  New Target= Old Target * (Time
    taken for 2016 Blocks in Seconds / 12,09,600 seconds)NoteThe parameters such as
    2,016 blocks and TargetTimespan of two weeks (12,09,600 seconds) are defined in
    chainparams.cpp as shown following:consensus.nPowTargetTimespan = 14 * 24 * 60
    * 60; // two weeksconsensus.nPowTargetSpacing = 10 * 60;consensus.nMinerConfirmationWindow
    = 2016; // nPowTargetTimespan / nPowTargetSpacingNote here that it is (T / 2 weeks)
    and not (2 weeks / T). The idea is to decrease the difficulty target when it is
    required to increase the complexity, so it takes more time. The lesser the target
    hash, the more difficult it gets to find a hash that is less than this target
    hash. Example: If it took ten days to mine 2,016 blocks, then (T / 2 weeks) would
    be a fraction, which when multiplied by “Old Target” further reduces it and “New
    Target” would be a value less than the old one. This would make it difficult to
    find a hash and would require more time. This is how the time between blocks is
    maintained at ten minutes on average. Imagine that the difficulty target was fixed
    and not adjustable; what do you think the problem would be? Remember that the
    computation power of the hardware increases with time as more powerful computers
    are introduced for block mining. A situation where 10s or 100s or even 1,000s
    of blocks are proposed at the same time is not desirable for the network to function
    properly. So, the idea is that, even when more and more powerful computing nodes
    enter into the Bitcoin network, avrage time required to propose a block should
    still be ten minutes by adjusting the difficulty target. Also, a miner’s chances
    of proposing a block depends on how much hash power they have compared with the
    global hash power of all miners included.Are you thinking why ten minutes, and
    why not 12 minutes? Or why not six minutes? Just keep in mind that there has to
    be some time gap for all the nodes in a decentralized asynchronous system to agree
    on it. If there was no time gap, so many blocks would arrive with just fractional
    delays and there wouldn’t be any optimization benefit of blockchain as compared
    with transaction chain. Every transaction is a broadcast and every new block is
    also a broadcast. Also, the orderliness that a blockchain brings to the system
    is quite infeasible by the transaction chain. With the concept of blocks, it is
    possible to include the unrelated transactions from any sender to any receiver
    in blocks, which is not easy to maintain with the transaction chain. One valid
    block broadcast is more efficient compared with individual transaction broadcast
    after validation. Now, coming back to the discussion of ten minutes, it can very
    well be a little less or a little more but there should certainly be some gap
    between two consecutive blocks. Imagine that you are a miner and mining block
    number 4567, but some other miner got lucky and proposed block number 4567, which
    you just received while solving the cryptographic puzzle. What you would do now
    is validate this block and if it is valid, add it to your local copy of the blockchain
    and immediately start on mining the 4568\. You wouldn’t want someone else to propose
    4568 already while you just finished validating block 4567, which you received
    a little later compared with other miners due to network latency. Now the question
    is: is this 10 minutes the best possible option? Well, it is difficult to explain
    this in one word, but a ten-minute gap addresses a lot of issues due to an asynchronous
    network, time delays, packet drops, system capacity, and more. There is a possibility
    that it could be optimized further to, say, five minutes or so, which you can
    see in many new cryptocurrencies and other blockchain use cases.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The Genesis Block
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The very first block as you can see in the following code, the block-0, is
    called the genesis block. Remember that the genesis block has to be hardcoded
    into the blockchain applications and so is the case with Bitcoin. You can consider
    it as a special block because it does not contain any reference to the previous
    blocks. The Bitcoin’s genesis block was created in 2009 when it was launched.
    If you open the Bitcoin Core, specifically the file [chainparams.cpp](http://bit.ly/1x6rcwP)
    , you will see how the genesis block is statically encoded. Using a command line
    reference to Bitcoin Core, you can get the same information by querying with the
    hash of the genesis block as shown below:$ bitcoin-cli getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f{    "hash"
    : "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",    "confirmations"
    : 308321,    "size" : 285,    "height" : 0,    "version" : 1,    "merkleroot"
    : "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b",    "tx"
    : ["4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"],    "time"
    : 1231006505,    "nonce" : 2083236893,    "bits" : "1d00ffff",    "difficulty"
    : 1.00000000,    "nextblockhash" : "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048"}Output
    of the preceding command:If you convert the Unix time stamp as shown in the previous
    output, you will find this date-time information: Saturday 3rd January 2009 11:45:05
    PM. You can as well get the same information from the website [https://blockchain.info](https://blockchain.info/)
    . Just navigate to this site and paste the hash value in the right top search
    box and hit “Enter.” Here is what you will find (Table [3-3](#Tab3))Table 3-3Transaction
    Information'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '| Summary |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| Number Of Transactions | 1 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| Output Total | 50 BTC |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| Estimated Transaction Volume | 0 BTC |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| Transaction Fees | 0 BTC |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| Height | [0](https://blockchain.info/block-height/0) (Main Chain) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| Timestamp | 2009-01-03 18:15:05 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| Received Time | 2009-01-03 18:15:05 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| Relayed By | [Unknown](https://blockchain.info/blocks/Unknown) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| Difficulty | 1 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| Bits | 486604799 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| Size | 0.285 kB |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| Weight | 0.896 kWU |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| Nonce | 2083236893 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| Block Reward | 50 BTC |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: Table 3-4Hash Information
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '| Hashes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| Hash | [000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f](https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Previous Block | [0000000000000000000000000000000000000000000000000000000000000000](https://blockchain.info/block/0000000000000000000000000000000000000000000000000000000000000000)
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Next Block(s) | [00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048](https://blockchain.info/block/00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Merkle Root | 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: In this Block-0, there is just one transaction, which is a coinbase transaction.
    Coinbase transactions are the ones that the miners get. There are no inputs to
    such transactions and they can only generate new Bitcoins. If you explored the
    transactions associated in this block, here is how it would look (Figure [3-8](#Fig8)).![A440588_1_En_3_Fig8_HTML.jpg](Images/A440588_1_En_3_Fig8_HTML.jpg)Figure
    3-8Coinbase transaction in Block-0
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块0中，只有一个交易，即创世区块交易。创世区块交易是矿工们获得的交易。这种交易没有输入，它们只能生成新的比特币。如果您探索了与这个区块关联的交易，这里就是这样（图[3-8](#Fig8)）。![A440588_1_En_3_Fig8_HTML.jpg](Images/A440588_1_En_3_Fig8_HTML.jpg)图3-8区块0中的创世区块交易
- en: The Bitcoin Network
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特币网络
- en: The Bitcoin network is a peer-to-peer network, as discussed already. There is
    no centralized server in such a system and every node is treated equally. There
    are no master–slave phenomena and no hierarchy as well in such a system. Since
    this runs on the Internet itself, it uses the same TCP/IP protocol stack as shown
    in Figure [3-9](#Fig9).![A440588_1_En_3_Fig9_HTML.jpg](Images/A440588_1_En_3_Fig9_HTML.jpg)Figure
    3-9The Bitcoin blockchain network on the InternetThe above diagram shows how Bitcoin
    networks coexist on the same Internet stack. The Bitcoin network is quite dynamic
    in the sense that nodes can join and leave the netwrk at will and the system still
    works. Also, despite being asynchronous in nature and with network delays and
    packet drops, the system is very robust—thanks to the design of Bitcoin!The Bitcoin
    network is a decentralized network with no central point of failure and as well
    no central authority. With such a design, how would you assess how big the Bitcoin
    network is? There is no proper way of estimating this as the nodes can join and
    leave at will. However, there are some attempts at researching the Bitcoin network,
    and some claim that there are close to 10,000 nodes that are mostly connected
    to the network all the time and there can be millions of nodes at a time.Every
    node in the Bitcoin network is equal in terms of authority and has a flat structure,
    but the nodes can be full nodes or lightweight nodes. The full nodes can do almost
    every permissible activity in the Bitcoin system, such as mining transactions
    and broadcasting transactions, and can provide wallet services. The full nodes
    also provide the routing function to participate in and maintain the Bitcoin network.
    To become a full node, you have to download the entire blockchain database that
    containss the entire transactions taken place till now. Also, the node must stay
    permanently connected to the Bitcoin network and hear all transactions taking
    place. It is important that you have a good network connection, good storage (at
    least 200GB), and at least 2GB RAM dedicated to it. This requirement may further
    change and require more resources with time.On the other hand, lightweight nodes
    cannot mine new blocks but can verify transactions by using Simplified Payment
    Verification (SPV)  . They are otherwse termed “thin clients.” A vast majority
    of nodes in the Bitcoin network are SPVs. They can as well participate in pool
    mining where there are many nodes trying to mine new blocks together. Lightweight
    nodes can help verify the transactions for the full nodes. A good example of an
    SPV is a wallet (the client). If you are running a wallet and someone sends money
    to you, you can act as a node in the Bitcoin network and download the relevant
    transactions to the one made to you so you can check if the person sending you
    Bitcoins actually owned them.It is important to note that an SPV is not as secured
    as a fully validating node because it usually contains the block headers and not
    the entire blocks. As a result, SPVs cannot validate transactions since they don’t
    have them for a block and also because they do not have all the unspent transaction
    outputs (UTXOs) except for their own.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络是一个点对点网络，正如前面所讨论的。在这种系统中没有集中服务器，每个节点都被平等对待。系统中没有主从现象，也没有层级之分。由于它是运行在互联网本身之上的，所以它使用了与图[3-9](#Fig9)相同的TCP/IP协议栈。![A440588_1_En_3_Fig9_HTML.jpg](Images/A440588_1_En_3_Fig9_HTML.jpg)图3-9互联网上的比特币区块链网络上述图表展示了比特币网络是如何在相同的互联网堆栈中共存的。比特币网络在动态性方面相当强大，意味着节点可以随时加入或离开网络，而系统仍然可以正常工作。此外，尽管它本质上是异步的，存在网络延迟和数据包丢失的情况，但系统非常健壮，这要归功于比特币的设计！比特币网络是一个没有失败集中点和也没有中央权威的去中心化网络。在这种设计下，您如何评估比特币网络的大小呢？由于节点可以随时加入或离开，所以没有合适的估算方法。然而，有一些尝试去研究比特币网络，有些人声称有接近10,000个节点大部分时间都与网络连接，同时可能有数百万个节点。比特币网络中的每个节点在权威方面都是平等的，并且具有扁平结构，但节点可以是完整节点或轻量级节点。完整节点可以在比特币系统中执行几乎所有允许的活动，比如挖掘交易和广播交易，并提供钱包服务。完整节点还提供路由功能以参与和维护比特币网络。要成为完整节点，你必须下载包含到目前为止所有交易的整个区块链数据库。另外，节点必须永久连接到比特币网络并监听所有发生的交易。重要的是你需要有一个良好的网络连接，良好的存储（至少200GB），并且至少2GB的RAM分配给它。这个要求可能会进一步改变，并随着时间的推移需要更多的资源。另一方面，轻量级节点不能挖掘新块，但可以通过简化支付验证（SPV）来验证交易。它们也被称为“瘦客户端”。比特币网络中的大多数节点都是SPV。它们也可以参与池挖矿，在那里有许多节点一起尝试挖掘新块。轻量级节点可以帮助完整节点验证交易。一个SPV的好例子是一个钱包（客户端）。如果你在运行一个钱包，有人给你发送钱，你可以作为比特币网络中的一个节点，下载与你有关的交易，这样你就可以检查给你比特币的人是否真的拥有它们。需要注意的是，SPV不如完全验证节点安全，因为它通常只包含区块头而不是整个区块。因此，SPV无法验证交易，因为它们没有区块的交易，并且除了自己的未花费交易输出（UTXO）外，它们也没有全部的未花费交易输出（UTXO）。
- en: Network Discovery for a New Node
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新节点的网络发现
- en: Now think about, when a new node wants to join the network, how would it contact
    the network? It is not an intranet with a 192.168.1.X network where you can broadcast
    to the IP 192.168.1.255 so that whichever computer is a part of the 192.168.1.X
    network gets the broadcast message. The network switches are designed to allow
    such broadcast packets. However, remember that we are talking about the Internet,
    which Bitcoin is sitting on. If you are running a node in London, there is a possibility
    that there are other nodes in London, Russia, Ireland, the United States, and
    India and all of them are connected through the Internet with some public facing
    IP address.The question here is that when a fresh node joins the network, how
    does it figure out the peer nodes? There is no central server somewhere to respond
    to their request the way a typical Internet-based web application works. Blockchain
    is decentralized, remember? When started for the first time, a Bitcoin Core or
    BitcoinJ program does not have the IP address of any full node. So, they are equipped
    with several methods to find the peers. One of them is DNS seeds. Several DNS
    seeds are hardcoded in them. Also, several host names are maintained in the DNS
    system that resolve to a list of IP addresses that are running the Bitcoin nodes.
    DNS seeds are maintained by Bitcoin community members. Some community members
    provide static DNS seeds by manually entering the IP addresses and port numbers.
    Also, some community members provide dynamic DNS seed servers that can automatically
    get the IP addresses of active Bitcoin nodes that are running on default Bitcoin
    ports (8333 for mainnet and 18333 for testnet). If you perform NSLOOKUPs on the
    DNS seeds, you will get a bunch of IP addresses running Bitcoin nodes.The clients
    (Bitcoin Core or BitcoinJ) also maintain a hardcoded list of IP addresses that
    point to some (not one!) stable Bitcoin nodes. Such nodes can be called bootstrap
    nodes whose endpoints are already available with the source code itself. Every
    time one downloads the binaries, a fresh list of active nodes get downloaded along
    with the binaries. Once a Bitcoin node connection is established, it is very easy
    to pull the list of other Bitcoin nodes active at that point in time. A pictorial
    representation of how a new node becomes a part of the network can be found in
    the following figures.Step-1:Imagine that there were six nodes active at some
    point in time in the Bitcoin network. Refer to Figure [3-10](#Fig10).![A440588_1_En_3_Fig10_HTML.jpg](Images/A440588_1_En_3_Fig10_HTML.jpg)Figure
    3-10Bitcoin network in generalStep-2:There is a new node, say, a seventh node
    that just showed up and is trying to join the existing Bitcoin network, but does
    not have any connection yet. Refer to Figure [3-11](#Fig11).![A440588_1_En_3_Fig11_HTML.jpg](Images/A440588_1_En_3_Fig11_HTML.jpg)Figure
    3-11A new node trying to join the networkStep-3:The seventh node will try to reach
    out to as many nodes as it can either using DNS seeds or using the list of stable
    Bitcoin nodes in the list that it has—as shown in Figure [3-12](#Fig12).![A440588_1_En_3_Fig12_HTML.jpg](Images/A440588_1_En_3_Fig12_HTML.jpg)Figure
    3-12New Bitcoin node contacts some peersIn the diagram, we have skipped the DNS
    resolution part. It is the same as when you browse any website with its name and
    post DNS resolution the IP address is retrieved, which is then used as the destination
    webserver’s address to send TCP packets to. To connect to a new peer, the node
    establishes a TCP connection on port 8333 (port 8333 is well known for Bitcoins
    but could be different). Then the two nodes handshake with information such as
    version number, time, IP addresses, height of blockchain, etc. The actual Bitcoin
    code for “Version” message defined in net.cpp is as shown in the following:PushMessage(
    "version", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,              nLocalHostNonce,
    FormatSubVersion(CLIENT_NAME, CLIENT_VERSION,              std::vector<string>()),
    nBestHeight, true );Through this Version message, the compatibility between the
    two nodes is checked as the first step toward further communication.Step-4:In
    the fourth step, the requested nodes will respond with the list of IP addresses
    and corresponding port numbers of the other active Bitcoin nodes that they are
    aware of. Please note that it is possible for some of active nodes to not be aware
    of each and every Bitcoin node in the network at any time. The port number is
    important because once the TCP packets reach the destination node, it is the port
    number that is used by the operating system to direct the message to the correct
    application/process running on the system. Please refer to Figure [3-13](#Fig13).![A440588_1_En_3_Fig13_HTML.jpg](Images/A440588_1_En_3_Fig13_HTML.jpg)Figure
    3-13Peer Bitcoin nodes respond to the network request by a new nodeNote that,
    only one peer may be enough to bootstrap the connection of a node to the Bitcoin
    network; the node must continue to discover and connect to new peers. This is
    because nodes come and go at will and no connection is reliable.Step-5:In the
    fifth step, the new seventh node establishes connection with all the reachable
    Bitcoin nodes, depending on the list it received from the nodes contacted in the
    previous step. Figure [3-14](#Fig14) represents this.![A440588_1_En_3_Fig14_HTML.jpg](Images/A440588_1_En_3_Fig14_HTML.jpg)Figure
    3-14A new node becomes a part of the Bitcoin network
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，当一个新的节点想要加入比特币网络时，它会如何与网络联系？这并不是一个只有192.168.1.X网络的局域网，你可以向IP 192.168.1.255广播，以便192.168.1.X网络上的任何计算机都能收到广播消息。网络交换机被设计来允许这样的广播数据包。然而，记住我们正在谈论的是互联网，比特币就建立在其之上。如果你在伦敦运行一个节点，有可能在伦敦、俄罗斯、爱尔兰、美国和印度还有其他节点，并且它们都通过互联网和一些公共面向的IP地址连接起来。这里的问题是，当一个新的节点加入网络时，它如何找出对等节点？并没有某个中央服务器像基于互联网的典型web应用那样响应他们的请求。区块链是去中心化的，记住吗？当比特币核心或比特币J程序第一次启动时，它并不拥有任何完整节点的IP地址。因此，它们配备了多种寻找对等节点的方法。其中一种是DNS种子。它们中的一些在程序中硬编码了DNS种子。DNS系统中还维护着一些主机名，它们解析为运行比特币节点的IP地址列表。DNS种子由比特币社区成员维护。一些社区成员通过手动输入IP地址和端口号提供静态DNS种子。还有一些社区成员提供动态DNS种子服务器，可以自动获取运行在默认比特币端口（主网为8333，测试网为18333）上的活跃比特币节点的IP地址。如果你对DNS种子执行NSLOOKUP，你会得到运行比特币节点的的一堆IP地址。客户端（比特币核心或比特币J）还维护了一个指向一些（不是一台！）稳定比特币节点的硬编码IP地址列表。这样的节点可以被称为引导节点，它们的端点源代码本身就已经有了。每次下载二进制文件时，都会下载一个活跃节点的最新列表。一旦建立了比特币节点的连接，就可以很容易地拉取其他在那一刻活跃的比特币节点的列表。下面几幅图展示了新的节点如何成为网络的一部分。
- en: Bitcoin Transactions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比特币交易
- en: 'Bitcoin transactions are the fundamental building blocks of the Bitcoin system.
    There are basically two broader categories of Bitcoin transactions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易是比特币系统的基本构建块。比特币交易基本上可以分为两大类：
- en: 'Coinbase transaction : Every block in Bitcoin blockchain contains one coinbase
    transaction included by the miners themselves to be able to mine new coins. They
    do not have control of how many coins they can mine in every block because it
    is controlled by the network itself. It started with 50 BTC in the beginning and
    keeps halving till it reaches 21 Million Bitcoins in total.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coinbase 交易：比特币区块链中的每个区块都包含由矿工自己包含的coinbase交易，以能够挖出新的比特币。他们无法控制自己能在每个区块中挖出多少个比特币，因为这由网络本身控制。最初是50个比特币，然后不断减半，直到达到总共2100万个比特币。
- en: 'Regular transactions : The regular transactions are very similar to currency
    exchanges in general, where one is trying to transact some amount of money that
    they own with another. Typically, in Bitcoin, everything is present as transactions.
    To spend some amount, one has to consume previous transaction(s) where they received
    that amount—these are regular transactions in Bitcoin. Our main focus in this
    chapter will be on these regular transactions.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规交易：常规交易与一般的货币交易非常相似，其中一个人试图与他们交易的另一个人交易一定数量的货币。在比特币中，一切都是以交易的形式存在的。要花费一定数量的资金，必须消耗之前获得该金额的交易——这些在比特币中就是常规交易。本章我们将重点关注这些常规交易。
- en: 'Each owner of a Bitcoin can transfer the coin to someone else by digitally
    signing a hash of the previous transaction where they had received the Bitcoin
    along with the public key of the recipient. The payee or the recipient already
    has the public key of the payer so they can verify the transaction. The following
    figure (Figure [3-15](#Fig15)) is from the white paper of Satoshi Nakamoto that
    pictorially demonstrates how it works.![A440588_1_En_3_Fig15_HTML.jpg](Images/A440588_1_En_3_Fig15_HTML.jpg)Figure
    3-15Bitcoin transactionNotice only the highlighted Owner-2 section in the diagram.
    Since Owner-1 is initiating this transaction, he is using his private key for
    signing the hash of two items: one is the the previous transaction where he himself
    received the amount and the second is Owner-2’s public key. This signature can
    be easily verified using the public key of Owner-1 to ensure that it is a legitimate
    transaction. Similarly, when Owner-2 will initiate a transfer to Owner-3, he will
    use his private key to sign the hash of the previous transaction (the one he received
    from Owner-1) along with the public key of Owner-3\. Such a transaction can be,
    and will be, verified by anyone who is a part of the network. Obviously because
    every transaction is broadcast, most of the nodes will have the entire history
    of transactions to be able to prevent double-spend attempts.There is no principle
    of closing balance in a Bitcoin network, and the total amount one holds is the
    summation of all incoming transactions to the public addresses you own. You can
    create as many public addresses as you want. If you have ten public addresses,
    then whatever transactions were made to that public address, you can spend those
    transactions (unspent transactions or UTXOs) using your private key. If you have
    to spend, say, five Bitcoins, you have a coupe of choices:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比特币的所有者可以通过数字签名前一个交易的哈希值来将硬币转让给其他人，其中他们获得了比特币以及接收者的公钥。收款人或接收者已经拥有支付者的公钥，因此他们可以验证交易。下面的图（图[3-15](#Fig15)）来自中本聪的白皮书，图解了它是如何工作的。![A440588_1_En_3_Fig15_HTML.jpg](Images/A440588_1_En_3_Fig15_HTML.jpg)图
    3-15比特币交易注意图表中突出显示的Owner-2部分。由于Owner-1正在发起这笔交易，他使用自己的私钥签名两个项目的哈希值：一个是他自己收到金额的前一个交易，第二个是Owner-2的公钥。使用Owner-1的公钥可以轻松验证这笔交易的合法性。同样，当Owner-2将比特币转给Owner-3时，他将使用自己的私钥签名前一个交易的哈希值（他从Owner-1那里收到的交易）以及Owner-3的公钥。任何网络的一部分都可以验证这样的交易。显然，因为每笔交易都是广播的，大多数节点都将拥有整个交易历史，以防止双重花费尝试。比特币网络中没有关闭余额的原则，一个人所持有的总金额是他们所拥有的所有公共地址收到的交易的总额。你可以创建尽可能多的公共地址。如果你有十个公共地址，那么无论资金被转到哪个公共地址，你都可以使用你的私钥花费这些交易（未花费的交易或UTXOs）。如果你需要花费，比如说，五个比特币，你有几个选择：
- en: Use one of the previous transactions where you received five or more Bitcoins.
    Transfer five Bitcoins to the recepient, some amount as transaction fee and the
    remainder to yourself. Refer to Figure [3-16](#Fig16).![A440588_1_En_3_Fig16_HTML.jpg](Images/A440588_1_En_3_Fig16_HTML.jpg)Figure
    3-16Bitcoin transaction with one transaction input
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用之前接收的五个或更多比特币的交易之一。将五个比特币转给收款人，一部分作为交易费，剩余的转给自己。参考图[3-16](#Fig16) ![A440588_1_En_3_Fig16_HTML.jpg](Images/A440588_1_En_3_Fig16_HTML.jpg)图3-16带有单个交易输入的比特币交易
- en: Use multiple previous transactions that you had received that would sum up to
    more than five Bitcoins. Transfer five Bitcoins to the recepient, some amount
    as transaction fee and the remainder to yourself. Refer to Figure [3-17](#Fig17).![A440588_1_En_3_Fig17_HTML.jpg](Images/A440588_1_En_3_Fig17_HTML.jpg)Figure
    3-17Bitcoin transaction with multiple transactions input
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个你之前接收的交易，这些交易的总和超过五个比特币。将五个比特币转给收款人，一部分作为交易费，剩余的转给自己。参考图[3-17](#Fig17) ![A440588_1_En_3_Fig17_HTML.jpg](Images/A440588_1_En_3_Fig17_HTML.jpg)图3-17带有多个交易输入的比特币交易
- en: 'As you can see, every transaction takes as input the previous transaction(s).
    There is no account maintained that says you have eight BTC, and you can spend
    anything below this amount; if you spend five BTC, the remaining balance would
    be three BTC. In Bitcoin, everything is a transaction where there are inputs and
    outputs. If the outputs are not spent yet, they are the UTXOs.We are aware that
    every transaction in the network is broadcast to the entire network. Whether someone
    is maintaining a node or not, they can still make a transaction and that transaction
    is published to all the accessible Bitcoin nodes. The receiver Bitcoin nodes then
    further broadcast the transactions to other nodes and the entire network is usually
    flodded with transactions. This is sometimes referred to as the gossip protocol
    and plays an important role in preventing double-spend attacks. Recollect from
    Chapter [2](A440588_1_En_2_Chapter_split_000.xhtml) that the only way to prevent
    double-spend is to be aware of all transactions.Each node maintains a set of all
    the transactions that they hear about and broadcasts only the new ones, which
    were not a part of the list already. Nodes maintain the transactions in the list
    till the time the transaction gets into a block and is a part of the blockchain.
    This is because there is a chance that even if a block has all valid transactions
    and is proposed as a valid block, it can still get orphaned by not being a part
    of the longest chain. Once it is confirmed that the block is now a part of the
    longest chain, the transactions that are there in that block are taken off from
    the list of transactions. Each full node in the Bitcoin network must maintain
    the entire list of unspent transactions (UTXOs) even though they are in the millions.
    If a transaction is in the list of UTXOs, then it may not be a double-spend attempt.
    Upon confirming a transaction is not a double-spend attack and also validating
    the transactions from other perspectives, a node broadcasts such transactions.
    If you are wondering how fast it would be to search millions of UTXOs to check
    for double-spend, you are on track. Since the transaction outputs are ordered
    by their hashes, searching for an item in an ordered hash list is quite fast.Let
    us now think and dig deeper into a double-spend scenario. It is very possible
    that Alice (A) tries to pay Bob (B) and Charlie (C) the same transaction (input
    to a transaction is a previous transaction and there is no concept of closing
    balance). Such a scenario would appear as shown in Figure [3-18](#Fig18).![A440588_1_En_3_Fig18_HTML.jpg](Images/A440588_1_En_3_Fig18_HTML.jpg)Figure
    3-18A double-spend transaction scenario in Bitcoin networkNotice in the figure
    the following scenarios:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个交易都将前一个交易作为输入。并没有一个账户维持说你有八个BTC，并且你可以花费任何低于这个数额的金额；如果你花费了五个BTC，剩余的余额将是三个BTC。在比特币中，一切都是一个交易，其中包含输入和输出。如果输出还没有被花费，它们就是未花费交易输出（UTXO）。我们知道网络中的每个交易都被广播到整个网络。无论有人是否在维护节点，他们仍然可以进行交易，并且该交易会被发布到所有可访问的比特币节点。接收比特币节点然后将交易进一步广播到其他节点，整个网络通常会被交易淹没。这有时被称为八卦协议，并在防止双重花费攻击中发挥重要作用。回想一下，防止双重花费的唯一方法就是了解所有交易。[第2章](A440588_1_En_2_Chapter_split_000.xhtml)中提到，每个节点都会维护一组他们听到的所有交易，并只广播新交易，这些新交易还没有包含在列表中。节点会将这些交易维护在列表中，直到交易进入区块并成为区块链的一部分。这是因为即使一个区块拥有所有有效的交易，并且被提出作为一个有效的区块，它仍然可能因为不是最长链的一部分而被孤立。一旦确认区块现在是最长链的一部分，那么包含在那个区块中的交易就会被从交易列表中删除。比特币网络中的每个完整节点必须维护未花费交易（UTXO）的整个列表，尽管这些交易有数百万个。如果一个交易在UTXO列表中，那么它可能不是双重花费的尝试。在确认交易不是双重花费攻击，并且从其他角度也验证了交易的有效性后，节点会广播这样的交易。如果你想知道要搜索数百万个UTXO以检查双重花费会多快，你的思路是对的。由于交易输出按它们的哈希值排序，所以在有序哈希列表中搜索项目是非常快速的。现在让我们更深入地思考和挖掘双重花费场景。Alice（A）尝试向Bob（B）和Charlie（C）支付相同的交易（交易输入是一个先前交易，并且没有结账余额的概念）是非常可能的。这样的场景将如图[3-18](#Fig18)所示。
- en: A is trying to spend the same transaction to B and C.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A试图向B和C支付相同的交易。
- en: Node-2 received the transaction A Tx(1234) --> B and Node-3 received the transaction
    A Tx(1234) --> C.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点2收到了交易A Tx(1234) --> B，节点3收到了交易A Tx(1234) --> C。
- en: For Node-2 and Node-3, their respective transactions received were legitimate
    transactions.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于节点2和节点3，他们各自接收到的交易是合法的交易。
- en: When Node-3 tries to broadcast the transaction A Tx(1234) --> C to Node-2 (every
    node broadcasts new transactions), Node-2 would refuse this transaction because
    it already has a transaction A Tx(1234) --> B with the same input transaction
    Tx(1234).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Node-3 尝试将交易 A Tx(1234) --> C 广播给 Node-2 （每个节点都会广播新交易）时，Node-2 会拒绝这个交易，因为它已经有一个与相同输入交易
    Tx(1234) 的交易 A Tx(1234) --> B。
- en: Similar things happen with other nodes as well, and they may have either the
    transaction “A Tx(1234) --> B” or “A Tx(1234) --> C”, whichever reached them faster,
    but not both.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似的情况也会发生在其他节点上，它们可能接收到交易“A Tx(1234) --> B”或者“A Tx(1234) --> C”， whichever reached
    them faster, but not both.
- en: During mining, whichever node gets to propose the block will include the transaction
    it has. This transaction would be a part of the blockchain and the rest of the
    nodes that are holding the other transaction would simply drop the transaction
    with Tx(1234) because it will no longer be a UTXO.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在挖矿期间， whichever node gets to propose the block will include the transaction
    it has. This transaction would be a part of the blockchain and the rest of the
    nodes that are holding the other transaction would simply drop the transaction
    with Tx(1234) because it will no longer be a UTXO.
- en: Consensus and Block Mining
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共识和区块挖矿
- en: 'In the previous section we looked at granular transactions. We will learn how
    the transactions are bundled together to form a block and a consensus is achieved
    among nodes, so the entire network accepts that block to extend the blockchain.
    Note that “block mining” refers to successfully creating a new block in the blockchain.
    In Bitcoin, it is the distributed PoW consensus algorithm that helps mine new
    blocks by maintaining decentralization. Achieving distributed consensus in such
    a network is very difficult. Though it has been around for decades for distributed
    systems such as Facebook, Google, Amazon, and many more because they have millions
    of servers that require consistency in the data they store, the term consensus
    is very much popularized because of Bitcoins. We will get into the nuts and bolts
    of consensus and mining in this chapter.First, just keep in mind that everything
    in a Bitcoin network is represented as transactions. If you want to make a transaction,
    you have to consume one or more previous transactions as input and make another
    transaction. We already know that one has to sign a transaction using their private
    key to ensure that the right person is making the transaction. Despite such cryptographic
    security, can’t that person sign a transaction that they already spent? Example:
    Alice received ten Bitcoins in a transaction with transaction number 1234\. She
    can very well spend the same transaction 1234 and give away those ten Bitcoins
    to Bob and Charlie. Since she will sign with her private key, which means it is
    an authentic transaction, what do you think can prevent her from double-spending?
    Please note that there is no way in Bitcoin that you can prevent her from attempting
    to make a double-spend, but the system is designed so that such an attempt will
    not be successful. The only way to prevent such attempts is to be aware of all
    the transactions that are taing place. This is why all transactions in Bitcoin
    are broadcast to the entire network. Once a transaction is spent, it is no longer
    a part of the UTXOs and a new transaction number is generated to be a part of
    the UTXO, which only the recipient can spend. This is the way nodes can validate
    transactions.Also, the only way you can prevent a double-spend attack is by knowing
    all the transactions. When you are aware of all transactions, you would know the
    spend and the UTXOs. When a new block is proposed by a miner, it is required that
    all the transactions in the block are valid. Does it mean that the node proposing
    a block cannot include a invalid transaction? The answer is “Yes.” They can certainly
    inject a fraudulent transaction but the rest of the nodes will reject it. The
    PoW that the node would have done (we will get into the details shortly) by spending
    computer resources and electricity would be in vain! So, a node would never want
    to propose an invalid block, thanks to the PoW consensus. Despite not having a
    notion of global time, observe that the transactions are clubbed together to form
    a block that becomes a part of blockchain, more blocks get added to the chain
    one by one, and there is an order! Note carefully that the order in which the
    transactions took place is preserved by the blockchain. This way, consensus happens
    at block level, which propagates all the way to granular transactions.Based on
    what we have understood so far, now we know that every node in the Bitcoin network
    has its own copy of blockchain, and there is no “global blockchain” as such; it
    is a decentralized network after all. Each node in all those copies of blockchains
    comprises many transactions. It is also true that every node maintains a list
    of UTXOs and when given a chance (A node is randomly selected—we will see how)
    to propose a block, they include as many transactions as possible up to the block
    limit of 1MB or 2MB. If the block successfully makes it to the blockchain, they
    are removed from the list of UTXOs. Note here that every node may have different
    outstanding transactions lists because there is a possibility that some transactions
    are not heard by some of the nodes.It’s time now to see how the PoW algorithm
    really works. We learned about the difficulty target field in the header of each
    block. Every mining node tries to solve the cryptographic puzzle with an expectation
    to get lucky and propose a block. The reason they are so desperate in proposing
    a block is because they get great benefits when their proposed block becomes a
    part of the blockchain. Every transaction that an individual makes, they can set
    aside some transaction fee for the miners. We know that all nodes maintain the
    list of transactions that are not yet a part of the blockchain and when they get
    a chance to propose a block, they take as many transactions as they can and form
    a block. It is obvious that they will take all those transactions that would give
    them the highest profit and leave the ones with minimum or no transaction fees.
    It may take some time for the transactions with low transaction fee to get into
    the blocks, and chances are less for the ones with no transaction fee at all.
    Apart from the transaction fee, the nodes that propose a new block are rewarded
    with new Bitcoins. With every successful block, new Bitcoins get generated and
    the miner who proposed the block gets all of those; this is the only way new Bitcoins
    get created in the Bitcoin system. This is called “block reward.” Technically,
    the node that proposes a block includes a special transaction called “coin creation”
    in the proposed block where the recipient address is the one that the miner owns.
    When the Bitcoin was first launched, the block reward was 50 Bitcoins (BTC). By
    design, there can only be 21,000,000 BTCs in total, so the block reward gets halved
    every 210,000 blocks. It started at 50, then it became 25, then 12.5, and it goes
    on this way till at some point in time (when it reaches 21,000,000 BTCs) it trends
    to zero. Following is the code snippet from Bitcoin Core (main.cpp) that shows
    this halving process:int64_t GetBlockValue(int nHeight, int64_t nFees){    int64_t
    nSubsidy = 50 * COIN;    int halvings = nHeight / Params().SubsidyHalvingInterval();    //
    Force block reward to zero when right shift is undefined.    if (halvings >= 64)        return
    nFees;    // Subsidy is cut in half every 210,000 blocks which will occur approximately
    every 4 years.    nSubsidy >>= halvings;    return nSubsidy + nFees;}Notice in
    the previous code snippet how the block reward gets halved. The following explanation
    gives a better picture of this design://Block reward reduced by half, remains
    at 50%BlockReward = BlockReward >> 1;     //Block reward further reduced by half,
    remains at 25%BlockReward = BlockReward-(BlockReward>>2);     //Block reward further
    reduced by half, remains at 12.5%BlockReward = BlockReward - (BlockReward>>3);Even
    though the rewards look lucrative, it is not so easy to get lucky and be the node
    that gets to propose a block. If you are not lucky enough, all the work you did
    would be in vain; that’s a disadvantage! So, what is it that the nodes do as a
    PoW? Let’s get back to the difficulty puzzle now. Every mining node at all times
    is working to propose a block, but only one succeeds at a given point in time.
    Assume that a block is proposed already, and now all mining nodes are working
    to propose a new block. Let us go through the process step by step and understand
    the whole flow:Step-1:The miners use a software to keep track of the transactions,
    eliminate the ones that already made it to a successful block in blockchain, reject
    the fraudulent transactions, and solve the cryptographic puzzle to propose a new
    block and relay that to the entire network. The best software to mine is the official
    Bitcoin Core but there have been many other variants that people have come up
    with. If you log into this link ( [https://bitcoin.org/en/download](https://bitcoin.org/en/download)
    ) you will find that the official Bitcoin Core is supported in Windows, Linux,
    Mac OS, Ubuntu, and ARM Linux. So, when we say that the mining node selects all
    the transactions (maybe the ones that give the miner the highest profit) till
    the block limit of 1MB (2MB for Bitcoin Cash), they also hash those transactions
    and generate the Merkle root that would become a part of this new block’s header.
    This Merkle root represents all the transactions.Step-2:They prepare the block
    header. Apart from the nonce, the rest is all available at this step. It is the
    work of the mining node to find the nonce by hashing the block header twice and
    comparing it against the difficulty target to see if it is less than that. They
    keep changing the nonce till it satisfies this condition, and there is no shortcut
    to find a nonce quickly; one must try out every possible option. We already looked
    at how to compute the difficult target using the four bytes of data present in
    the header itself, and we learned how it changes every two weeks. See the following
    for how this process looks:H [ H (Version | Previous Block Hash | Merkle Root
    | Time Stamp | Difficulty Target |  Nonce) ]< [ Difficulty Target ]Step-3:The
    miner keeps on changing the nonce field in step-2, by incrementing it by “1” till
    it satisfies the condition—it is a recursive phenomenon. The difficulty target
    for every node is the same and all of them are trying to solve the same problem,
    but remember that they may have different variants of transaction pools and hence
    the Merkle root for them would be different. Since every node is trying to extend
    the longest and main blockchain, so the previous block hash would be the same.So,
    ultimately the Sha256 hash twice for the block header should be less than the
    target to be able to propose the block to the entire network. See the following
    example for a better understanding:Target   : 0000000000000074cd00000000000000000000000000000000000000000000000Hash     :
    0000000000000074cc4471deff052ced7f07347e4eda86c845a2fcf0553ed7f0Notice that the
    hash value and the target value have the same number of leading zeros (i.e., 14)
    and “74cc” is less than “74cd,” so it satisfies the condition and this block can
    now be proposed. In many places, you would find that this explanation is simplified
    with ballpark values of both the target and the hash, and counting only the leading
    zeros. If the hash has more leading zeros than the target, then it satisfies the
    condition. Remember again that the more zeros in the target, the more difficult
    it gets in finding the hash that can satisfy the condition.Let us connect this
    learning so far with the real Bitcoin implementation. We know that block creation
    time is set to ten minutes—it is coded up in Bitcoin binaries for 2,016 blocks
    in two weeks, as we discussed already, and does not change till a hard fork happens.
    You can browse blocks proposed and see the hashes that satisfied the difficulty
    target at the website [https://blockchain.info](https://blockchain.info/) and
    see for yourself that the hashes for different blocks would have different leading
    zeros, just to set the block creation time to ten minutes on average. In the initial
    days, the number of leading zeros was around nine or ten, and today it has increased
    to around 18 to 20 zeros. It may increase even further as and when more powerful
    computing nodes capable of more hash rates join the network.Step-4:Once a miner
    finds the valid block, they immediately publish the block to the entire network.
    Every node that receives this block individually checks again if the miner who
    proposed the block actually solved the mining puzzle. For these nodes to validate
    this, it is just one step, as shown below:H [H (Version| PreviousBlock Hash |
    Merkle Root | Time Stamp | Difficulty Target | Found Nonce)]< [ Difficulty Target
    ]Notice that they just use the block header that includes the nonce found by the
    proposing miner to see if the hash is less than the target and is valid. If it
    was a valid nonce and the condition satisfied, then they check for individual
    transactions proposed in the block with its Merkle root in the block header. If
    all transactions are valid, then they add this block to the local copy of their
    blockchain. This new block has the coinbase transaction that generates new coins
    (it started with 50 BTC, then 25, then 12.5, and keeps halving as discussed) as
    an award for the miner who proposed the valid block.Note here that block mining
    is not an easy job, thanks to the PoW mining algorithm. For a node to propose
    an invalid block, it has to burn a lot of electricity and CPU cycles to find the
    nonce and propose the block that would ultimately get rejected by nodes in the
    network. Had it been an easy task, many nodes would just keep trying for it and
    flood the network with bad blocks. You must understand and appreciate by now how
    Bitcoin prevents such situations in a game theoretic way! It is always profitable
    for the miners to play by the rules and they do not gain any extra benefits by
    not following the rules.In the previous steps, we learned the PoW mining procedure
    that is implemented in Bitcoins. One of the best things in this design is the
    random selection of a mining node that gets to propose a block. No one knows who
    would get lucky to find the right nonce and propose a block, it is purely a random
    phenomenon. We already know that generating a true random number is quite difficult
    and this is something that is the most vulnerable surface of attack for most cryptographic
    implementations. With such a design as Bitcoin’s, random selection of a node to
    propose a block is truly random.The next best thing in Bitcoin mining is the block
    reward. It is something that a miner who successfully proposes a new block gets,
    using the coinbase transaction in the same block. The miners also get the transaction
    fees associated with all the transactions they have included in the block. So,
    mining reward for a block is a combination of block reward and transaction fee
    as shown below:Mining Reward = Block Reward + Total transaction fees of all transactions
    in the BlockWe know that mining is the only way new Bitcoins are created in the
    Bitcoin system, but is that the purpose of mining? No! The purpose of mining is
    to mine new blocks, and generation of new Bitcoins and also the transaction fee
    is to incentivize the miners so that more and more miners are interested in mining.
    Obviously though, why would you mine if you are not making good money? This is
    again game theory. A proper incentivization mechanism is the key to make a sytem
    decentralized and self-sustainable. Notice that the Bitcoin system does not have
    a way to penalize nodes that do not play honestly, it only rewards honest behavior.
    Actors in the Bitcoin blockchain network such as individuals who just use Bitcoin
    or the miners are all identified using their public keys. It is possible for them
    to generate as many key pairs as possible and this makes it a psydonemous system.
    A node cannot be uniquely identified with its public key that it has used in the
    coinbase transaction, as in the very next moment it can create a new key pair
    and expose itself with a new network address. So, proper incentivization stands
    to be the best way to ensure the actors in the system play honestly—again the
    beauty of game theory!Here is a question for you now. After a block was broadcast,
    let’s say a node verified it, found the nonce and transactions and everything
    else to be valid, and included it in its local copy of blockchain. Does this mean
    that the transactions that were there in the block are all settled and confirmed
    now? Well, not really! There is a chance that two blocks came in at the same time
    and while one node started extending one of them, there is a chance that a majority
    of the nodes are extending on the other block. Eventually, the longest blockchain
    becomes the original chain. This is a scenario when a block that is absolutely
    valid, with all legitimate transactions and a proper nonce value that satisfied
    the mining puzzle, can still get abandoned by the Bitcoin network. Such blocks
    that do not become a part of the final blockchain are called orphaned blocks.
    Now, this explanation indicates that there is a certain possibility of one or
    more blocks getting orphaned out at any time. So, the best strategy would be to
    wait untill many blocks are added to the chain. In other words, when a transaction
    receives multiple confirmations, it is safe to think that it is a part of the
    final consensus chain and will not get orphaned out. As any number of blocks get
    added after a certain block, that many number of confirmations are received by
    the transactions in that block. Though there are no rules as such that define
    how many confirmations one should get before accepting a transaction, six confirmations
    has been the best practice. Even with four confirmations, it is quite safe to
    assume a transaction has been confirmed, but six is the best practice because
    with more confirmations, the chances of a block getting orphaned out decreases
    exponentially.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Block Propagation
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块传播
- en: Bitcoin uses PoW mining to randomly select a node that can propose a valid block.
    Once the miner finds a valid block, they broadcast that block to the entire network.
    Block propagation in the network happens the same way as transactions. Every node
    that receives the new block further broadcasts it so that eventually the block
    reaches every node in the network. Please note that a node does not broadcast
    a block unless it is a part of the longest chain from its perspective. Once the
    nodes receive the new block that is proposed, they not only verify the header
    and check the hash value in acceptable range, but also validate each and every
    transaction that was included in that block. It is clear by now that for a node
    in the Bitcoin network, validating a block is a little more complex compared with
    validating transactions. Similar to transactions, there is a possibility that
    two valid blocks are proposed at the same time. In such a scenario, the node will
    keep both the blocks and start building on the one that comes from the longest
    chain.We must understand that there is always a latency involved for a block to
    propagate through the entire network and reach every node. The relation between
    the block size and the time taken is linearly proportional, in the sense that
    for each kB added to the block size, the latency increases linearly. It is obvious
    that such network latency would impact the rate of growth of the blockchain. A
    measurement study that was conducted by Decker and Wattenhofer addresses this
    situation. Refer to Figure [3-19](#Fig19), which shows the relation between block
    size and the time it took to reach 25% (Line-1), 50% (Line-2), and 75% (Line-3)
    of monitored nodes.![A440588_1_En_3_Fig19_HTML.jpg](Images/A440588_1_En_3_Fig19_HTML.jpg)Figure
    3-19Block propagation time with respect to block sizeThe network bandwidth is
    the primary reason for such network latencies and it is never consistent in all
    areas of the globe. On top of this, we know that the broadcast packets of blocks
    go through many hops to finally reach all nodes. A typical Bitcoin block is of
    1MB and the new variant of Bitcoin with a hard fork that has come up (Bitcoin
    Cash) is of 2MB block size; you can imagine the inherent limitations due to latency.
    As per the network research, there are more than a million Bitcoin nodes that
    are connected to the Bitcoin network in a month and there are thousands of full
    nodes that are almost always connected to the network permanently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用工作量证明（PoW）挖矿随机选择一个可以提出有效区块的节点。一旦矿工找到一个有效区块，他们就会将该区块广播给整个网络。网络中的区块传播方式与交易相同。每个收到新区块的节点都会进一步广播，以便最终区块能到达网络中的每个节点。请注意，除非节点从其角度看到的最长链的一部分，否则节点不会广播区块。一旦节点收到提议的新区块，它们不仅验证头部并检查哈希值是否在可接受范围内，还要验证区块中包含的每一个交易。到现在为止，对于比特币网络中的一个节点来说，验证一个区块比验证交易要复杂得多。与交易类似，同时提出两个有效区块的可能性存在。在这种情况下，节点会保留两个区块并开始构建来自最长链的那个区块。我们必须明白，区块传播到整个网络并到达每个节点的过程中总是存在延迟。区块大小与所需时间的关系是线性成比例的，这意味着每增加
    kB 到区块大小，延迟线性增加。显然，这种网络延迟会影响区块链的增长速度。Decker和Wattenhofer进行的一项测量研究解决了这种情况。参考图[3-19](#Fig19)，它显示了区块大小与达到25%（Line-1）、50%（Line-2）和75%（Line-3）监控节点的传播时间的关系。![A440588_1_En_3_Fig19_HTML.jpg](Images/A440588_1_En_3_Fig19_HTML.jpg)图3-19区块大小与区块传播时间的关系网络带宽是此类网络延迟的主要原因，而且在全球各个地区的延迟并不一致。在此基础上，我们知道区块的广播数据包要经过许多跃点才能最终到达所有节点。典型的比特币区块大小为1MB，而具有硬分叉的新比特币变种（比特币现金）的区块大小为2MB；你可以想象由于延迟而产生的固有限制。根据网络研究，一个月内有超过一百万个比特币节点连接到比特币网络，而且有成千上万的完整节点几乎总是永久连接到网络。
- en: Putting It all Together
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 综合所有内容
- en: 'At a high level, if we just put down the events in the order they take place,
    then here is how it may look:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，如果我们只是按照事件发生的顺序记录下来，那么它可能看起来是这样的：
- en: All new transactions are broadcast to all nodes.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有新交易都会广播给所有节点。
- en: Each node that hears the new transactions collects them into a block.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个听到新交易的节点都会收集这些交易并放入一个区块。
- en: Each mining node works on finding a difficult PoW for its block to be able to
    propose it to the network.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个挖矿节点都在寻找一个难度的PoW，以便将其区块提出给网络。
- en: When a node gets lucky and finds a correct nonce to the PoW puzzle, it broadcasts
    the block to all nodes.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个节点幸运地找到PoW谜题的正确nonce时，它会将区块广播给所有节点。
- en: Nodes accept the proposed block only if the nonce and all transactions in it
    are valid and not already spent.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点只接受非once 和其中所有交易都是有效且未被花费的提案块。
- en: Bitcoin network nodes express their acceptance of the block by working on creating
    the next block in the chain, using the hash of the accepted block as the previous
    hash for the new block they would be mining.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币网络节点通过使用已接受块的哈希作为他们将要挖矿的新块的前一个哈希来创建链中下一个块，表达他们对块的接受。
- en: Bitcoin Scripts
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bitcoin 脚本
- en: We learned about Bitcoin transactions in previous sections at a high level.
    In this section we will delve deep into the actual programming constructs that
    make the transactions happen. Every Bitcoin transactions’ input and output are
    embedded with scripts. Bitcoin scripts are stack based, which we will see shortly,
    and are evaluated from left to right. Remember that Bitcoin scripts are not Turing-complete,
    so you cannot really do anything and everything that is possible through other
    Turing-complete languages such as C, C++, or Java, etc. There are no concepts
    of loops in Bitcoin script, hence the execution time for scripts is not variable
    and is proportional to the number of instructions. This means that the scripts
    execute in a limited amount of time and there is no possibility for them to get
    stuck inside a loop. Also, most importantly, the scripts definitely terminate.
    Now that we know a little about the scripts, where do they run? Whenever transactions
    are made, whether programmatically, or through a wallet software or any other
    program, the scripts are injected inside the transactions and it is the work of
    the miners to run those scripts while mining. The purpose of Bitcoin scripts is
    to enable the network nodes to ensure the available funds are claimed and spent
    only by the entitled parties that really own them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经在较高层面上了解了比特币交易。在本节中，我们将深入探讨实际编程构造，这些构造使得交易得以进行。比特币交易的输入和输出都嵌入了脚本。比特币脚本是基于栈的，我们很快就会看到，并且是从左到右进行评估的。请记住，比特币脚本不是图灵完备的，所以你不能真正通过其他图灵完备语言如
    C、C++ 或 Java 等做到任何和一切事情。比特币脚本中没有循环的概念，因此脚本的执行时间是不变的，与指令数量成比例。这意味着脚本在有限的时间内执行，并且不可能陷入循环中。此外，最重要的是，脚本肯定会终止。现在我们已经对脚本有所了解，那么它们在哪里运行呢？无论交易是程序化地、通过钱包软件还是通过其他程序进行，脚本都注入到交易中，矿工在挖矿时运行这些脚本。比特币脚本的目的是使网络节点能够确保可用的资金仅由真正拥有它们的有权限的各方声称和花费。
- en: Bitcoin Transactions Revisited
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再访比特币交易
- en: A transaction in the Bitcoin network is a tranfer of value, which is a broadcast
    to the entire network and ends up in some block in the blockchain. Typically,
    it appears that Bitcoins get transferred from one account or wallet to another,
    but in reality, it is from one transaction to another. Well, before getting into
    further details, keep in mind that the Bitcoin addresses are basically the double-hashed
    output of the public key of the participants. The public key is first hashed using
    SHA256 and then by RIPEMD160 hashing algorithms, respectively, to generate 160-bit
    Bitcoin addresses. We have already covered these hashing techniques in the previous
    chapter. Let us zoom in a bit more into the transactions now. Take a look at the
    following transaction tree (Figure [3-20](#Fig20)), the way it happens in Bitcoin.![A440588_1_En_3_Fig20_HTML.jpg](Images/A440588_1_En_3_Fig20_HTML.jpg)Figure
    3-20A typical Bitcoin transaction structureObserve that the output of previous
    transactions become input to new transactions and this process continues forever.
    In the previous figure, if it was you who got the 100K from some previous output,
    it became the spendable input to a new transaction. Notice that in Tx 0, you spent
    40K and 50K and paid up those amounts, and the remaining amount (10K) became the
    fee to the miner. By default, the remaining amount is paid to the miner, so you
    need to be careful not to ignore such situations, which are always the case. In
    this same situation, out of the remaining 10K amount, you could transfer say 9K
    to your own address and leave aside 1K for the mining fee. When an amount is not
    spent, in the sense that a transaction is not used as an input to a new transaction,
    it remains a UTXO, which can be spent later. Obviously, the ones previous to it
    are already spent. So, all the UTXOs combined for all the accounts (public keys)
    that you hold are your wallet balance.Pause for a moment here, and think about
    how it must have been programmed. Remember that both the inputs and outputs of
    transactions are equipped with relevant scripts to make it possible. It is only
    through the scripts that it can be ensured that you are the authorized user to
    make a transaction and you have the necessary amount that you have received from
    a previous transaction. This means that both the inputs and outputs are equally
    important. Here is how the transaction’s contents look:Transaction Output = Amount
    of Bitcoins to transfer + Output ScriptTransaction Input = Reference to previous
    transaction output + Input ScriptWhether to look into the output script first
    or the input script first is actually an egg-chicken problem. But we will see
    the output script first because it is the one that is being consumed by the input
    script of the next transaction. Let us repeat and get this right, that while making
    a transaction, the output script of the current transaction is there just to enable
    the future transaction that can consume this as input, but for this current transaction,
    it is the previous transaction’s output script that lets you spend it. This is
    why the output scripts have the public key of the recipient and the value (amount
    of Bitcoins) being transferred. When the output scripts are being used as inputs,
    their primary purpose is to check the signature against the public key. The output
    scripts are also called ScriptPubKey . Unless this output is spent, it remains
    a UTXO waiting to be spent.The input script in the transaction input data structure
    has the mechanism of how to consume the previous transaction that you are trying
    to spend. So, it has to have the reference to that previous transaction. The hash
    of the previous transaction and the index number {hash, index} pinpoints the exact
    place where you had received the amount that you are now spending. The purpose
    of the “index” is to identify the intended output in the previous transaction.
    If you were the recipient of the previous transaction, you have to provide your
    signature to claim that you are the rightful owner of the public key to which
    the transaction was made. This will let you spend that transaction. Also, you
    have to provide your public key, which will hash to the one used as destination
    address in previous transaction. Input scripts are also known as ScriptSigs. The
    ultimate objective of the script is to push the signatures and keys onto the stack.A
    typical Bitcoin transaction has the following fields (Table [3-5](#Tab5)).Table
    3-5Bitcoin Transaction Fields
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络中的交易是价值的转移，它广播给整个网络，并最终存储在区块链的某个区块中。通常，看起来比特币是从一个账户或钱包转移到另一个，但实际上，是从一个交易到另一个交易。嗯，在深入了解之前，请记住比特币地址实际上是参与者公钥的双重哈希输出。公钥首先使用SHA256哈希算法，然后使用RIPEMD160哈希算法分别生成160位的比特币地址。我们在上一章已经介绍了这些哈希技术。现在让我们更详细地了解一下交易。看看以下的交易树（图[3-20](#Fig20)），比特币中的交易方式。![A440588_1_En_3_Fig20_HTML.jpg](Images/A440588_1_En_3_Fig20_HTML.jpg)图3-20典型的比特币交易结构请注意，先前交易的输出成为新交易的输入，这个过程将持续下去。在前面的图中，如果你从某个先前的输出中获得了100K，它就成为了新交易的可花费输入。注意，在Tx
    0中，你花费了40K和50K并支付了这些金额，剩余的金额（10K）成为了矿工的手续费。默认情况下，剩余的金额支付给矿工，所以你需要小心，不要忽略这种情况，这种情况总是存在的。在这种情况下，剩余的10K金额，你可以将9K转移到自己的地址，留下1K作为挖矿费用。当一个金额没有被花费，即交易没有作为新交易的输入使用时，它保留为一个未花费交易输出（UTXO），稍后可以花费。显然，之前的都已经花费了。所以，你持有的所有账户（公钥）的UTXO总和就是你的钱包余额。暂停片刻，思考一下它是如何被编程的。记住，交易的输入和输出都配备了相关的脚本以使之成为可能。只有通过脚本才能确保你是授权用户进行交易，并且你有从先前交易中接收到的必要金额。这意味着输入和输出都同样重要。交易内容的外观如下：交易输出
    = 要转移的比特币金额 + 输出脚本交易输入 = 先前交易输出的引用 + 输入脚本是先查看输出脚本还是输入脚本实际上是一个先有鸡还是先有蛋的问题。但我们先看输出脚本，因为它是下一个交易的输入脚本将要消费的部分。让我们重复并弄清楚这一点，在制作交易时，当前交易的输出脚本只是为了启用未来的交易，该交易可以将其作为输入，但对于这个当前交易来说，是先前的交易的输出脚本让你可以花费它。这就是为什么输出脚本具有接收者的公钥和转移的值（比特币金额）。当输出脚本作为输入使用时，它们的主要目的是检查签名与公钥是否一致。输出脚本也被称为ScriptPubKey。除非这个输出被花费，否则它保留为一个等待花费的UTXO。交易输入数据结构中的输入脚本具有如何消耗你试图花费的先前交易的方法。所以，它必须有对那个先前交易的引用。先前交易的哈希和索引号{哈希，索引}可以精确地指出你在哪里收到了你现在要花费的金额。索引的目的是为了识别先前交易中打算的目标输出。如果你是先前交易的接收者，你必须提供你的签名，以声明你是公钥的所有者，该公钥是交易的目标。这将让你花费那个交易。此外，你必须提供你的公钥，它将哈希为先前交易中使用的目标地址。输入脚本也被称为ScriptSigs。脚本的最终目标是将签名和密钥推送到栈上。典型的比特币交易具有以下字段（表[3-5](#Tab5)）。表3-5比特币交易字段
- en: '| Field | Size | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 大小 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Version no | 4 bytes | Currently 1\. It tells Bitcoin peers and miners which
    set of rules to use to validate this transaction. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 版本号 | 4字节 | 目前为1。它告诉比特币对等节点和矿工使用哪些规则来验证此交易。|'
- en: '| In-counter | 1 - 9 bytes | Positive integer ([VI = VarInt](https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer%23Protocol%20specification)).
    It indicates total number of inputs. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 输入计数器 | 1 - 9字节 | 正整数（[VI = VarInt](https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer%23Protocol%20specification)）。它指示输入总数。|'
- en: '| list of inputs | Variabe length | [It](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin%23Transaction)
    lists all the inputs for a transaction. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 输入列表 | 可变长度 | 它列出了一个交易的所有的输入。|'
- en: '| Out-counter | 1 - 9 bytes | Positive integer ([VI = VarInt](https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer%23Protocol%20specification)).
    It indicates total number of outputs. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 输出计数器 | 1 - 9字节 | 正整数（[VI = VarInt](https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer%23Protocol%20specification)）。它指示输出总数。|'
- en: '| list of outputs | Variable length | [It](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin%23Transaction)
    lists all the outputs for a transaction. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 输出列表 | 可变长度 | 它列出了一个交易的所有的输出。|'
- en: '| lock_time | 4 bytes | Not being used currently. It indicates if the transaction
    should be included in the blockchain block immediately after it is validated by
    the miner or there should be some lock time before it gets included in the block.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 锁定时间 | 4字节 | 目前未使用。它指示在矿工验证后是否应立即将交易包含在区块链块中，或者在包含在块之前是否需要一定的锁定时间。|'
- en: 'Let us now take a look at a different representation of the same transaction
    structure that we discussed in the previous section. This is to see a more detailed
    view of the transaction structure and the various components of it. Now refer
    to Figure [3-21](#Fig21).![A440588_1_En_3_Fig21_HTML.jpg](Images/A440588_1_En_3_Fig21_HTML.jpg)Figure
    3-21Granular components of a Bitcoin transactionAs you can see in the previous
    figure, the data items such as signatures or public keys are all embedded inside
    the scripts and are a part of the transaction. Just by looking at the granular
    components of Bitcoin transactions, many of your queries would be answered up
    front. The instructions in the script get pushed onto the stack and executed,
    which we wil explore in detail shortly.When Bitcoin nodes receive the transaction
    broadcasts, they all validate those transactions individually, by combining the
    output script of the previous transaction with the input script of the current
    transaction following the steps mentioned as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下在前一部分中讨论的同一交易结构的另一种表示。这是为了更详细地了解交易结构及其各个组成部分。现在参考图[3-21](#Fig21)。![A440588_1_En_3_Fig21_HTML.jpg](Images/A440588_1_En_3_Fig21_HTML.jpg)图3-21比特币交易的细粒度组件如您在前一图中所见，诸如签名或公钥之类的数据项都嵌入在脚本中，并成为交易的一部分。只需查看比特币交易的细粒度组件，很多您的查询就可以得到解答。脚本中的指令会被推送到栈上并执行，我们将在稍后详细探讨。当比特币节点接收到交易广播时，它们会单独验证这些交易，通过按照以下步骤将前一个交易的输出脚本与当前交易的输入脚本结合来验证：|
- en: Find the previous transaction whose output is being used as input to make this
    transaction. The “Prev. Txn ID (Hash)” field contains the hash of that previous
    transaction.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到之前的交易，其输出被用作当前交易的输入。 “Prev. Txn ID (Hash)”字段包含那个之前交易的哈希值。|
- en: In the previous transaction output, find the exact index where the amount was
    received. There could be multiple receivers in a transaction, so the index is
    used to identify the initiator of this current transaction whose address was used
    as recipient in the previous transaction.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前一个交易输出中找到确切的索引，在该索引处接收了金额。在一个交易中可能有多个接收者，因此索引用于标识当前交易的发起者，该发起者的地址在前一个交易中被用作接收者。|
- en: Consume the output script used in the previous transaction using the Unlocking
    Script called “ ScriptSig .” Notice in Figure [3-21](#Fig21) that there is a field
    before it that specifies the length of this Unlocking Script.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用称为“ ScriptSig ”的解锁脚本消耗前一个交易中使用的输出脚本。注意在图[3-21](#Fig21)中，它前面有一个字段，指定了这个解锁脚本的长度。|
- en: Join this output script with the input script by just appending it to form the
    validation script and execute this validation script (remember this is a stack-based
    scripting language).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需将这个输出脚本附加到输入脚本上来形成验证脚本，并执行这个验证脚本（记住，这是一个基于栈的脚本语言）。
- en: The amount value is actually present in the Output Script, i.e., the “ScriptPubKey.”
    It is the locking script that locks the transaction output with the spending conditions
    and ensures that only the rightful owner of the Bitcoin address to which this
    transaction has been made can later claim it. Observe that it also has the Locking
    Script Length field right before it. For the current transaction, this output
    script is only for information, and plays its role in the future when the owner
    tries to spend it.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金额值实际上存在于输出脚本中，即“ScriptPubKey”。这是一个锁定脚本，它通过锁定交易输出和花费条件来确保只有这笔交易所发送的比特币地址的合法所有者才能以后声称它。注意它前面还有一个锁定脚本长度字段。对于当前交易，这个输出脚本只是为了提供信息，在将来所有者尝试花费它时才会发挥其作用。
- en: It is the validation script that decides if the current transaction input has
    the right to spend the previous UTXO by validating the signatures. If the validation
    script runs successfully, it is confirmed that the transaction is valid and the
    transaction went through.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证脚本决定了当前交易输入是否有权通过验证签名来花费之前的未花费交易输出（UTXO）。如果验证脚本成功运行，那么可以确认交易是有效的，交易已经完成。
- en: 'Let us explore the previous explanation through a diagramatic representation
    to get a better understanding. Assume that Alice is paying Bob, say, five BTC.
    This means that Alice had received 5BTC in one of the previous transactions that
    was locked using ScriptPubKey . Alice can claim that she is the rightful owner
    of that transaction by unlocking it with ScriptSig and can spend it to Bob. Similarly,
    now if Bob tries to spend three BTC to Charlie and two BTC to himself, then here
    is how it would look (Figure [3-22](#Fig22)).![A440588_1_En_3_Fig22_HTML.jpg](Images/A440588_1_En_3_Fig22_HTML.jpg)Figure
    3-22A practical example of Bitcoin scriptsWhen the Bitcoin network, more precisely
    the miners, receive the transaction from Alice, they check and confirm that it
    is a valid transaction and approve it by including it in their blocks (well, the
    one who proposes a block does it). When that happens, the output of this transaction
    becomes a part of the UTXO in the name of Bob, who could later spend it. And this
    is what happens in our example—that Bob also spends it to Charlie. Bob did so
    by consuming the previous transaction, unlocking it with his signature and public
    key, to prove that he is the owner of the Bitcoin address that Alice had used.
    Observe that there are two outputs in Bob’s transaction. Since he had received
    five BTC from Alice and is paying three BTC to Charlie, he must transfer the remainder
    to himself so that it becomes two BTC of UTXO bound to Bob himself and he could
    spend it in future. In Bob’s transaction, the three BTC to Charlie is locked using
    the locking script for only Charlie to spend later.Are you now thinking about
    how the scripts are combined and executed together? Remember that the unlocking
    script of current transaction is run along with the locking script of the previous
    transaction. As discussed already, running the scripts is a miner’s job and they
    do not happen at the wallet software. In the previous example, when Bob makes
    the transactions, miners execute the ScriptSig unlocking script from Bob’s transaction,
    and then immediately execute the ScriptPubKey locking script from Alice’s transaction
    in order. If the sequential execution in a stack-based fashion for the combined
    validation script runs successfully by returning TRUE, then Bob’s transaction
    is excepted by all the nodes validating it. We will take a look at Bitcoin scripts
    and how a Bitcoin-scripting virtual machine executes the stack during the execution
    of the combined script commands in more detail in the following section. In this
    section, however, take a look at the following example that represents the transaction
    from a developer’s standpoint:{    "hash": "a320ba8bbe163f26cafb2092306c153f87c1c2609b25db0c13664ae1afca78ce",  "ver":
    1,  "vin_sz": 1,  "vout_sz": 1,  "lock_time": 0,  "size": 51,  "in":[        {           "prev_out":{              "hash":"83cd5e9b704c0a4cb6066e3a1642b483adc8f73a76791c82a73dfa381281d32f",            "n":0         },         "scriptSig":"63883d3d2dea35029d17d25b8a926675def0045c397d3df55b0ae145ef80db7849599b930220ab13bd2dda2ca0a67e2c5cd28030bb9b7b3dcacf176652dac82fe9d5873f3409661281d32f6d35b46906cd562bf8b48f4f938c077bcb29d46b0560fa5c61813d3d2d"      }   ],  "out":[        {           "value":"0.08",         "scriptPubKey":"OP_DUP
    OP_HASH160 b3a2c0d84ec82cff932b5c3231567a0d48ab4c78OP_EQUALVERIFY OP_CHECKSIG"      }   ]}Example
    code with just one input and one outputNote that Bitcoin transactions are not
    encrypted, so it is possible to browse and view every transaction ever collected
    into blocks.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过图解来探索之前的解释，以获得更好的理解。假设爱丽丝在支付鲍勃，比如说五个比特币。这意味着爱丽丝在前面的某个交易中收到了5BTC，而这个交易是使用`ScriptPubKey`锁定的。爱丽丝可以通过使用`ScriptSig`解锁并证明她是该交易的合法所有者，然后将其支付给鲍勃。同样，现在如果鲍勃试图支付三个比特币给查理和两个比特币给自己，那么情况就是这样（图[3-22](#Fig22)）。![A440588_1_En_3_Fig22_HTML.jpg](Images/A440588_1_En_3_Fig22_HTML.jpg)图3-22比特币脚本的实际示例当比特币网络，更确切地说是矿工，收到爱丽丝的交易时，他们会检查并确认这是一个有效的交易，并通过将其包含在他们的区块中来批准它（好吧，提出区块的人这样做）。当发生这种情况时，这个交易的输出成为鲍勃名下的UTXO，他可以在稍后花费它。在我们的例子中，鲍勃也把它给了查理。鲍勃是通过消耗之前的交易，用他的签名和公钥解锁它，以证明他是爱丽丝使用的比特币地址的所有者。注意鲍勃的交易中有两个输出。由于他从爱丽丝那里收到了五个BTC，并且支付给查理三个BTC，他必须将剩余的两个BTC转给自己，这样它就成为了与鲍勃本人绑定的两个BTC的UTXO，他可以在将来花费它。在鲍勃的交易中，三个BTC给查理是使用仅查理可以稍后花费的锁定脚本锁定的。你现在是否在思考脚本是如何组合和一起执行的？记住，当前交易的解锁脚本与之前交易的锁定脚本一起运行。正如已经讨论过的，运行脚本是矿工的工作，并且它们不会在钱包软件中发生。在前一个例子中，当鲍勃进行交易时，矿工执行鲍勃交易中的`ScriptSig`解锁脚本，然后立即执行爱丽丝交易中的`ScriptPubKey`锁定脚本。如果顺序执行在基于堆栈的方式中的组合验证脚本成功返回TRUE，那么鲍勃的交易被所有验证它的节点接受。我们将在下一节中更详细地查看比特币脚本以及比特币脚本虚拟机在执行组合脚本命令期间如何处理栈。然而，在本节中，请看以下例子，它从开发者的角度代表了交易:{    "hash":
    "a320ba8bbe163f26cafb2092306c153f87c1c2609b25db0c13664ae1afca78ce",  "ver": 1,  "vin_sz":
    1,  "vout_sz": 1,  "lock_time": 0,  "size": 51,  "in":[        {           "prev_out":{              "hash":"83cd5e9b704c0a4cb6066e3a1642b483adc8f73a76791c82a73dfa381281d32f",            "n":0         },         "scriptSig":"63883d3d2dea35029d17d25b8a926675def0045c397d3df55b0ae145ef80db7849599b930220ab13bd2dda2ca0a67e2c5cd28030bb9b7b3dcacf176652dac82fe9d5873f3409661281d32f6d35b46906cd562bf8b48f4f938c077bcb29d46b0560fa5c61813d3d2d"      }   ],  "out":[        {           "value":"0.08",         "scriptPubKey":"OP_DUP
    OP_HASH160 b3a2c0d84ec82cff932b5c3231567a0d48ab4c78OP_EQUAL'
- en: Scripts
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本
- en: 'A script is actually a list of instructions recorded with each transaction
    that describes how the next person can gain access to those Bitcoins received
    and spend them. Bitcoin uses stack-based, non–Turing-complete scripting language
    where the instructions get processed from left to right. Keep in mind that it
    is non–Turing-complete by design!We looked at the input and output scripts in
    the previous section. We are now aware that the input script ScriptSig is the
    unlocking script and has two components, the public key and the signature. The
    public key is used because it hashes to the Bitcoin address that the transaction
    was spent to, in the previous transaction. The ECDSA digital signature’s purpose
    is to prove the ownership of the public key, hence the Bitcoin address to be able
    to spend it further. Similarly, the output script ScriptPubKey in the previous
    transaction was to lock the transaction to the rightful owner of the Bitcoin address.
    These two scripts, ScriptSig of current transaction and ScriptPubKey of previous
    transaction, are combined and run. Take a look at its appearance after they are
    combined (Figure [3-23](#Fig23)).![A440588_1_En_3_Fig23_HTML.jpg](Images/A440588_1_En_3_Fig23_HTML.jpg)Figure
    3-23Formation of combined validation scriptAs we learned already, it is important
    to note that the Bitcoin script either runs successfully or it fails. When the
    transactions are valid, it runs successfully without any errors. Bitcoin scripting
    language is a very simplified version of programming languages and is quite small,
    with just 256 instructions in total. Out of these 256, 15 are disabled and 75
    are kept reserved maybe for later usage. These basic instructions comprise mathematical,
    logical (if/then), error reporting, and just return statements. Apart from these,
    there are some additional cryptographic instructions such as hashing, signature
    verification, etc. We will not get into all the available instruction sets, and
    focus only on the ones we will use in this chapter. Following are a few:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，脚本是一系列记录在每笔交易中的指令，它描述了下一个人如何获取接收到的比特币以及如何花费它们。比特币使用基于栈的非图灵完备脚本语言，其中指令从左到右处理。请注意，这是设计上的非图灵完备！我们在上一节中查看了输入和输出脚本。现在我们知道输入脚本ScriptSig是解锁脚本，有两个组成部分：公钥和签名。公钥之所以被使用，是因为它在之前的交易中对交易进行了哈希，得到了比特币地址。ECDSA数字签名的目的是证明公钥的所有权，因此可以进一步花费比特币地址。同样，在前一个交易的输出脚本ScriptPubKey是为了将交易锁定在比特币地址的合法所有者上。这两个脚本（当前交易的ScriptSig和前一个交易的ScriptPubKey）被组合并运行。看看它们组合后的外观（图[3-23](#Fig23)）。![A440588_1_En_3_Fig23_HTML.jpg](Images/A440588_1_En_3_Fig23_HTML.jpg)图3-23组合验证脚本的形成
- en: 'OP_DUP: It just duplicates the top item in the stack.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_DUP：它只是复制了栈顶的元素。
- en: 'OP_HASH160: It hashes twice, first with SHA256 and then RIPEMD160.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_HASH160：它先用SHA256哈希，然后用RIPEMD160哈希。
- en: 'OP_EQUALVERIFY: It returns TRUE if the inputs are matched, and FALSE otherwise
    and marks the transaction invalid.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_EQUALVERIFY：如果输入匹配，则返回真，否则返回假，并标记交易无效。
- en: 'OP_CHECKSIG: Checks if the input signature is a valid signature using the input
    Public Key itself for the hash of the current transaction.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_CHECKSIG：通过使用输入的公钥本身来对当前交易的哈希进行验证，以检查输入签名是否有效。
- en: To execute these instructions, we just have to push these instructions on to
    the stack and then execute. Apart from the memory that the stack takes, there
    is no extra memory required and this makes the Bitcoin scripts efficient. As you
    have seen, there are two kinds of instructions in the script, one is data instruction
    and the other is opcodes. The previous bullet list entries are all opcodes, and
    the combined validation script that we saw before has both of these kinds of instructions.
    Data instructions are just to push data onto the stack and not really to perform
    any function, and the sole purpose of opcodes is to execute some functions on
    the data in the stack and pop out as applicable. Let us discuss how Bob’s transaction
    would get executed with such a stack-based implementation. Recollect the combined
    script where Bob is trying to spend a previously received transaction in the current
    transaction to Charlie (Figure [3-24](#Fig24)).![A440588_1_En_3_Fig24_HTML.jpg](Images/A440588_1_En_3_Fig24_HTML.jpg)Figure
    3-24Combined script of ScriptPubKey and CheckSigThe corresponding stack-based
    implemention would be as follows (Figure [3-25](#Fig25)).![A440588_1_En_3_Fig25_HTML.jpg](Images/A440588_1_En_3_Fig25_HTML.jpg)Figure
    3-25Example of stack-based implementation of Bitcoin scriptThough the previous
    stack-based implementation is self explanatory, we will quickly run through what
    happened here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些指令，我们只需将这些指令推入栈中，然后执行。除了栈占用的内存外，不需要额外的内存，这使得比特币脚本变得高效。正如你所见，脚本中有两种指令，一种是数据指令，另一种是操作码。之前的子弹列表条目都是操作码，我们之前看到的组合验证脚本包含了这两种类型的指令。数据指令只是为了将数据推入栈中，实际上并不执行任何功能，而操作码的唯一目的是在栈中执行一些函数，并根据需要弹出。让我们讨论一下在栈
    based 实现下，鲍勃的交易是如何执行的。回想一下之前的组合脚本，鲍勃试图在当前交易中花费之前收到的交易给查理（图 [3-24](#Fig24)）。![A440588_1_En_3_Fig24_HTML.jpg](Images/A440588_1_En_3_Fig24_HTML.jpg)图
    3-24ScriptPubKey 和 CheckSig 的组合脚本相应的基于栈的实现如下（图 [3-25](#Fig25)）。![A440588_1_En_3_Fig25_HTML.jpg](Images/A440588_1_En_3_Fig25_HTML.jpg)图
    3-25比特币脚本的基于栈的实现示例尽管之前的基于栈的实现已经很明了，但我们将快速回顾一下这里发生了什么。
- en: First was Bob’s signature–a data instruction and so was pushed onto the stack
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是鲍勃的签名——一个数据指令，因此被推入栈中。
- en: Then was his public key–again a data instruction and was pushed on to the stack
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是他的公钥——又是数据指令，并被推入栈中。
- en: Then it was OP_DUP, an opcode. It duplicates the first item in the stack, so
    the public key of Bob was duplicated and became the third item on the stack.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是OP_DUP操作码。它复制栈中的第一个元素，因此鲍勃的公钥被复制，成为了栈的第三个元素。
- en: Next was OP_HASH160, an Opcode, which hashed Bob’s public key twice, once with
    SHA256 and then with RIPEMD160, and the final 160 bits output replaced Bob’s public
    key and became the top of the stack.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是OP_HASH160，一个操作码，它先用SHA256，再用RIPEMD160对鲍勃的公钥进行两次哈希处理，最后的160位输出替换了鲍勃的公钥，成为了栈顶元素。
- en: Then it was Bob’s Bitcoin address (160 bits)–a data instruction, which was pushed
    to the stack.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是鲍勃的比特币地址（160位）——一个数据指令，它被推入栈中。
- en: Next was an opcode, OP_EQUALVERIFY, which checks the top two items in the stack
    and if they match, it pops them both else an error is thrown and the script would
    terminate.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个操作码，OP_EQUALVERIFY，它检查栈顶的两个元素是否匹配，如果匹配，则将它们都弹出，否则将抛出错误并终止脚本。
- en: Then was again an opcode OP_CHECKSIG, which checks the public key against the
    signature to validate the authenticity of the owner. This opcode is also capable
    of consuming both inputs and popping them off the stack.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是另一个操作码OP_CHECKSIG，它通过将公钥与签名对比来验证所有者的真实性。这个操作码还能消耗两个输入并将它们从栈中弹出。
- en: You must be wondering what if someone tries to inject some fraudulent scripts
    or tries to misuse them. Please note that Bitcoin scripts are standardized and
    the miners are aware of them. Anything that does not follow the standard gets
    dropped by the miners, as they wouldn’t waste their time executing such transactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，如果有人试图注入一些欺诈脚本，或者试图滥用它们怎么办。请注意，比特币脚本是标准化的，矿工们也清楚它们。任何不符合标准的东西都会被矿工抛弃，因为它们不会浪费时间执行此类交易。
- en: Full Nodes vs. SPVs
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整节点与SPV节点的比较。
- en: We already got a heads-up on the full nodes and SPVs in this chapter. It is
    obvious that the notion of full node and lightweight node is implemented to ease
    out the usage of Bitcoins and make them more adaptable. In this section, we will
    zoom in to the technicalities for these variants and understand their purpose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经对完整节点和SPV有所了解。很显然，完整节点和轻量级节点的概念是为了简化比特币的使用，使它们更加适应而实现的。在本节中，我们将深入研究这些变体的技术细节，并了解它们的目的。
- en: Full Nodes
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整节点
- en: The full nodes are the most integral components in a Bitcoin network. They are
    the ones that maintain and run Bitcoin from various places across the globe. As
    discussed already, download the entire blockchain with all transactions, starting
    all the way from the genesis block to the latest discovered block. The latest
    block defines the height of the blockchain.The full nodes are extremely secure
    because they have the entire chain. For an adversary to be successful in cheating
    a node, an alternative blockchain needs to be presented, which is practically
    impossible. The true chain is the most cumulative PoW chain, and it gets computationally
    infeasible to propose a new fraudulent block. If all transactions are not valid
    in a block, PoW mining performed by the adversary will be in vain, because other
    miners will not mine on top of it. Such a block gets orphaned out soon enough.
    Full nodes build and maintain their own copy of blockchain locally. They do not
    rely on the network for transaction validation because they are self-sufficient.
    They are just interested in knowing the new blocks that get proposed by other
    nodes so that they can update their local copy after validating blocks. So, we
    learned that each full node must process all transactions; they must store the
    entire database, every transaction that is currently being brioadcast, every transaction
    that is ever spent, and the list of UTXOs; participate in maintaining the entire
    Bitcoin network; and they also have to serve the SPV clients.Note that there are
    so many varities of Bitcoin software that the full nodes use that are quite different
    in software architecture and programmed in different language constructs. However,
    the most widely used one is the “Bitcoin Core” software; more than three fourths
    of the network uses it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完整节点是比特币网络中最重要的组成部分。它们负责维护并运行比特币，分布在全球各地。正如前面所讨论的，完整节点会下载整个区块链以及所有的交易记录，从创世区块开始，一直到最新的区块。最新的区块定义了区块链的高度。完整节点非常安全，因为它们拥有整个链。对于一个敌手来说，要想成功欺骗一个节点，必须提供一个替代的区块链，这在实际中是不可能的。真正的链是最累积的工作量证明（PoW）链，提出一个新的欺诈区块在计算上是不切实际的。如果一个区块中的所有交易都不有效，敌手所进行的工作量证明（PoW）挖掘将徒劳无功，因为其他矿工会不会在它上面进行挖掘。这样的区块很快就会被孤立。完整节点会在本地构建和维护自己的区块链副本。它们不需要依赖网络进行交易验证，因为它们是自给自足的。它们只是关心其他节点提出的新的区块，以便在验证区块后更新它们的本地副本。因此，我们了解到每个完整节点必须处理所有交易；它们必须存储整个数据库，包括当前正在广播的所有交易，所有已花费的交易，以及未花费交易输出（UTXO）列表；参与维护整个比特币网络；同时它们还必须服务于简化支付验证（SPV）客户端。需要注意的是，比特币软件有许多不同的版本，完整节点所使用的软件在软件架构上差异很大，且采用不同的语言构造编写。然而，最广泛使用的是“比特币核心”（Bitcoin
    Core）软件；超过四分之三的网络在使用它。
- en: SPVs
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化支付验证（SPV）
- en: 'Bitcoin design has this nice concept of Simple Payment Verification(SPV) nodes
    that can be used to verify transactions without running full nodes. The way SPVs
    work is that they download only the header of all the blocks during the initial
    syncing to the Bitcoin network. In Bitcoin, the block headers are of 80 bytes
    each, and downloading all the headers is not much and ranges to a few MBs in total.The
    purpose of SPVs is to provide a mechanism to verify that a particular transaction
    was in a block in a blockchain without requiring the entire blockchain data. Every
    block header has the Merkle root, which is the block hash. We know that every
    transaction has a hash and that transaction hash can be linked to the block hash
    using the Merkle tree proof which we discussed in the previous chapter. All the
    transactions in a block form the Merkle leafs and the block hash forms the Merkle
    root. The beauty of the Merkle tree is that only a small part of the block is
    needed to prove that a transaction was actually a part of the block. So, to confirm
    a transaction an SPV does two things. First, it checks the Merkle tree proof for
    a transaction to accertain it is a part of the block and second, if that block
    is a part of the main chain or not; and there should be at least six more blocks
    created after it to confirm it is a part of the longest chain. Figure [3-26](#Fig26)
    depicts this process.![A440588_1_En_3_Fig26_HTML.jpg](Images/A440588_1_En_3_Fig26_HTML.jpg)Figure
    3-26Merkle root in block header of SPVLet us dig deeper into the technicality
    of how SPVs really work in verifying transactions. At a high level, it takes the
    following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币设计有一个很好的简单支付验证（SPV）节点的概念，可以用来验证交易而不必运行完整节点。SPV的工作方式是，在初始同步比特币网络时，仅下载所有块的头部。在比特币中，每个块头都是80字节，下载所有块头总的来说并不多，总计只有几MB。SPV的目的是提供一个机制，以验证特定交易是否在区块链的某个区块中，而不需要整个区块链数据。每个块头都有Merkle根，即块哈希。我们知道每个交易都有一个哈希，这个交易哈希可以通过我们在上一章讨论的Merkle树证明与块哈希相关联。一个区块中的所有交易构成了Merkle叶节点，而块哈希构成了Merkle根。Merkle树的美妙之处在于，只需要块的一部分就可以证明一个交易实际上是块的一部分。所以，为了确认一个交易，SPV需要做两件事。首先，它检查交易的Merkle树证明以确定它是否是块的一部分；其次，检查该块是否为最长链的一部分，并且在其之后至少还要有六个区块被创建来确认它是最长链的一部分。图[3-26](#Fig26)描述了这一过程。![A440588_1_En_3_Fig26_HTML.jpg](Images/A440588_1_En_3_Fig26_HTML.jpg)图3-26
    SPV中的区块头Merkle根
- en: To the peers an SPV is connected to, it establishes Bloom filters with many
    of them and ideally not just to one peer, because there could be a chance for
    that peer to perform denial of service or cheat. The purpose of Bloom filters
    is to match only the transactions an SPV is interested in, and not the rest in
    a block without revealing which addresses or keys the SPV is interested in.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与SPV连接的同行，它与许多同行建立Bloom过滤器，理想情况下不仅仅是一个同行，因为那个同行可能会执行服务拒绝或欺诈。Bloom过滤器的目的是只匹配SPV感兴趣的交易，而不揭示SPV感兴趣的哪些地址或密钥。
- en: Peers send back the relevant transactions in a merkleblock message that contains
    the Merkle root and the Merkle path to the transaction of interest as shown in
    the figure above. The merkleblock message sze is in a few kB and quite efficient.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同行的节点在包含Merkle根和指向感兴趣交易Merkle路径的merkleblock消息中发送回相关交易，如图所示。merkleblock消息的大小只有几kB，非常高效。
- en: It is then easy for the SPVs to verify if a transaction truly belongs to a block
    in the blockchain.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于SPV连接到的同行来说，验证一个交易是否真正属于区块链中的一个区块是很简单的。
- en: Once the transaction is verified, the next step is to check if that Block is
    actually a part of the true longest blockchain.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦交易被验证，下一步是检查该区块是否实际上是真正的最长区块链的一部分。
- en: The following (Figure [3-27](#Fig27)) represents this SPV communication steps
    with its peers.![A440588_1_En_3_Fig27_HTML.jpg](Images/A440588_1_En_3_Fig27_HTML.jpg)Figure
    3-27SPV communication mechanism with the Bitcoin network
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下（图[3-27](#Fig27)）代表了SPV与其同行之间的通信步骤。![A440588_1_En_3_Fig27_HTML.jpg](Images/A440588_1_En_3_Fig27_HTML.jpg)图3-27
    SPV与比特币网络之间的通信机制
- en: Bitcoin Wallets
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特币钱包
- en: Bitcoin wallets are very similar to the wallet you use in your daily life, in
    the sense you have access to it and you can spend when you want. Bitcoin wallets,
    however, are a digital phenomenon. Recollect the example we used in the previous
    section, where Alice paid some amount to Bob. How would she do it if Bob did not
    have an account? In the Bitcoin setting, the accounts or wallets are represented
    by the Bitcoin address. Bob must first generate a key pair (private/public keys).
    Bitcoin uses the ECDSA algorithm with secp256k1 curve (don’t worry, it is just
    the curve type—a standard recommendation). First a random bit string is generated
    to serve as private key, which is then deterministically transformed to public
    key. As we learned before in Chapter [2](A440588_1_En_2_Chapter_split_000.xhtml),
    the private/public keys are mathematically related and the public key can be generated
    from the private key any time (deterministic). So, it is not really a requirement
    to save the public keys. as such. True randomness is not possible through software
    implementations, so many servers or applications use hardware security modules
    (HSMs) to generate true random bits and also to protect the private keys. Unlike
    public keys, private keys definitely require saving them with maximum security.
    If you lose them, you cannot generate a signature that would justify the ownership
    of the public key (or Bitcoin address) that received some amount in any transaction.
    The public keys are hashed twice to generate the Bitcoin adress, first with SHA256
    and then with RIPEMD160\. This is also deterministic, so given a public key, it
    is just a matter of a couple of hashes to generate the Bitcoin address.Note carefully
    that the Bitcoin address does not really reveal the public key. This is because
    the addresses are double-hashed public keys and it’s quite infeasible to find
    the public key given the Bitcoin address. However, for someone with a public key,
    it is easy to claim the ownership of a Bitcoin address. The hashing technique
    in Bitcoin shortens and obfuscates the [public key](https://bitcoin.org/en/glossary/public-key#The%20public%20portion%20of%20a%20keypair%20which%20can%20be%20used%20to%20verify%20signatures%20made%20with%20the%20private%20portion%20of%20the%20keypair.).
    While it makes the manual transcription easier, it also provides security against
    unanticipated problems that might allow reconstruction of [private keys](https://bitcoin.org/en/glossary/private-key#The%20private%20portion%20of%20a%20keypair%20which%20can%20create%20signatures%20that%20other%20people%20can%20verify%20using%20the%20public%20key.)
    from [public key](https://bitcoin.org/en/glossary/public-key#The%20public%20portion%20of%20a%20keypair%20which%20can%20be%20used%20to%20verify%20signatures%20made%20with%20the%20private%20portion%20of%20the%20keypair.)s.
    This is possibly the safest implementation! Public keys are revealed only when
    the transaction output is being claimed by the owner, not when it was transacted
    to them, as you can see in Figure [3-28](#Fig28).![A440588_1_En_3_Fig28_HTML.jpg](Images/A440588_1_En_3_Fig28_HTML.jpg)Figure
    3-28Revealing public key to claim a transactionBitcoin wallets are nothing but
    the SPVs and are served by the full nodes. We already looked at the functioning
    of SPVs, so in this section we will take a look at some wallet-specific activities.
    We all understand that to make a transaction, or to receive a transaction, you
    need not be running a full node. All you want is a wallet to be able to save your
    private/public key pair, to be able to make and receive transactions (actually
    view and verify the ones made to you). We already learned the verification part
    while going through the SPVs section. Let us take a look at how to initiate a
    transaction using a wallet.It is advisible that you run your own full node and
    connect your wallet to it, as it would be the most secured way of working on Bitcoin.
    However, it is not a mandate and you can still work without maintaining your own
    node. Keep in mind that when you query a node, you have to mention your public
    address to get the list of UTXOs, and the full node is becoming aware of your
    public address, which is a privacy leak! All a wallet has to do is get the list
    of UTXOs so it can spend a transaction by signing it with its private key and
    publish that transaction into the Bitcoin network. This can be done by creating
    your own wallet software or by using a third-party wallet service. However, be
    careful with the wallet service providers because you are allowing them to take
    control of your private key. Whether they deliberately take your Bitcoins or they
    themselves are hacked, which has been the case with many wallet services, you
    lose your Bitcoins. At the end of the day, all wallet-service providers are centralized,
    though the Bitcoin network is decentralized. A typical pictorial representation
    of initiating a Bitcoin transaction through the wallet software can be represented
    as shown in the following (Figure [3-29](#Fig29)).![A440588_1_En_3_Fig29_HTML.jpg](Images/A440588_1_En_3_Fig29_HTML.jpg)Figure
    3-29A wallet application interacting with the Bitcoin networkAn example of an
    SPV client that can serve as a Bitcoin wallet is “BitcoinJ.” BitcoinJ  is actually
    a library to work with the Bitcoin protocol, maintain a wallet, and initiate/validate
    transactions. It does not require a full node such as a Bitcoin Core node locally
    and can function as a thin client node. Though it is implemented in Java, it can
    be used from any JVM-compatible language such as JavaScript and Python.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币钱包与您日常生活中使用的钱包非常相似，在您可以使用它并且可以随时花费资金这一点上。然而，比特币钱包是一个数字现象。回想一下我们在前一节中使用的例子，爱丽丝向鲍勃支付了一些金额。如果鲍勃没有账户，她该如何操作呢？在比特币设置中，账户或钱包由比特币地址表示。鲍勃必须首先生成一个密钥对（私钥/公钥）。比特币使用ECDSA算法与secp256k1曲线（不用担心，它只是曲线类型——一个标准的推荐）。首先生成一个随机位串作为私钥，然后确定性地转换为公钥。正如我们在第[2](A440588_1_En_2_Chapter_split_000.xhtml)章学到的，私钥/公钥在数学上是相关的，公钥可以随时（确定性）从私钥生成。因此，实际上并不需要保存公钥。真正的随机性不可能通过软件实现，因此许多服务器或应用程序使用硬件安全模块（HSMs）来生成真正的随机位，同时也保护私钥。与公钥不同，私钥肯定需要以最大安全性的方式保存。如果您丢失了它们，您无法生成一个签名来证明接收了某些金额的公共密钥（或比特币地址）的所有权。公钥被哈希两次以生成比特币地址，首先使用SHA256，然后使用RIPEMD160。这也是确定性的，所以给定一个公钥，生成比特币地址只是几个哈希的问题。请注意，比特币地址实际上并不揭示公钥。这是因为地址是双哈希的公钥，而且根据比特币地址找到公钥是非常困难的。然而，对于拥有公钥的人来说，声称拥有比特币地址是非常容易的。比特币中的哈希技术缩短并模糊了公钥。虽然这使得手动转录变得容易，但它也为可能允许重建私钥的问题提供了安全保护。这是最安全的实现！公钥只在所有者声称交易输出时揭示，而不是在它们被交易给他们的时
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how blockchain concepts we discussed in the previous
    chapter were put together to build Bitcoin as a cryptocurrency use case of blockchain
    technology. We covered the evolution of Bitcoin, the history of it, what it is,
    the design benefits, and why it is so important. We got to know about granular
    details on the Bitcoin network, transactions, blocks, the blockchain, consensus,
    and how all these are stitched together. Then we learned about the requirement
    of a wallet solution to interact with the Bitcoin blockchain system.In the 1990s,
    mass adoption of the Internet changed the way people did business. It removed
    friction from creation and distribution of information. This paved the way for
    new markets, more opportunities, and possibilities. Similarly, blockchain is here
    today to take the Internet to a whole new level. Bitcoin is just one cryptocurrency
    application of blockchain, and the possibilities are limitless. In the next chapter,
    we will learn about how Ethereum works and how it has become a defacto standard
    for various decentralized applications on one public blockchain network.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了前一章讨论的区块链概念是如何组合在一起构建比特币作为区块链技术的一种加密货币用例的。我们涵盖了比特币的演变、历史、它是什么、设计优势以及为什么它如此重要。我们了解了比特币网络、交易、区块、区块链、共识以及这些是如何交织在一起的细枝末节。然后我们学习了钱包解决方案与比特币区块链系统互动的需求。在20世纪90年代，互联网的广泛采用改变了人们的经商方式。它消除了信息创建和分发的摩擦。这为新的市场、更多机会和可能性铺平了道路。同样，区块链今天在这里，将互联网带到一个全新的水平。比特币只是区块链的一种加密货币应用，可能性无穷无尽。在下一章中，我们将学习以太坊是如何工作的，以及它是如何在一条公共区块链网络上成为各种去中心化应用的事实标准。
- en: References
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Bitcoin: A Peer-to-Peer Electronic Cash SystemNakamoto, Satoshi, “Bitcoin:
    A Peer-to-Peer Electronic Cash System,” [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)
    .All about Bitcoin Network and TransactionsBitcoin wiki, [https://en.bitcoin.it/](https://en.bitcoin.it/)
    .Blockchain TechnologyCrosby, Michael, Nachiappan; Pattanayak, Pradhan, Verma,
    Sanjeev, Kalyanaraman, Vignesh, “BlockChain Technology: Beyond Bitcoin,” Sutardja
    Center for Entrepreneurship & Technology, University of California, Berkeley,
    [http://scet.berkeley.edu/wp-content/uploads/BlockchainPaper.pdf](http://scet.berkeley.edu/wp-content/uploads/BlockchainPaper.pdf)
    , October 16, 2015.Accelerating Bitcoin’s Transaction ProcessingSompolinsky, Yonatan,
    Zohar, Aviv, “Secure High-Rate Transaction Processing inBitcoin,” Hebrew University
    of Jerusalem, Israel, School of Engineering and Computer Science, [https://eprint.iacr.org/2013/881.pdf](https://eprint.iacr.org/2013/881.pdf)
    .'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bitcoin: A Peer-to-Peer Electronic Cash SystemNakamoto, Satoshi, “Bitcoin:
    A Peer-to-Peer Electronic Cash System,” [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)
    。关于比特币网络和交易的一切Bitcoin wiki, [https://en.bitcoin.it/](https://en.bitcoin.it/) 。区块链技术Crosby,
    Michael, Nachiappan; Pattanayak, Pradhan, Verma, Sanjeev, Kalyanaraman, Vignesh,
    “BlockChain Technology: Beyond Bitcoin,” Sutardja Center for Entrepreneurship
    & Technology, University of California, Berkeley, [http://scet.berkeley.edu/wp-content/uploads/BlockchainPaper.pdf](http://scet.berkeley.edu/wp-content/uploads/BlockchainPaper.pdf)
    ，2015年10月16日。加速比特币的交易处理Sompolinsky, Yonatan, Zohar, Aviv, “Secure High-Rate Transaction
    Processing inBitcoin,” Hebrew University of Jerusalem, Israel, School of Engineering
    and Computer Science, [https://eprint.iacr.org/2013/881.pdf](https://eprint.iacr.org/2013/881.pdf)
    。'
