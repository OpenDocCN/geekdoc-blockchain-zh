- en: Chapter Eight
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain based access control framework for the security and privacy of
    IoT with strong anonymity unlinkability and intractability guarantees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aafaf Ouaddah    ^(Mchain, Admirals Way, Canary Wharf E14 9UH, London, United
    Kingdom)
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Motivated by the recent explosion of interest around the blockchain, we examine
    whether they make a good fit to build a lightweight and robust access control
    framework to address security and privacy issues in the Internet of Things (IoT)
    sector. In this direction, this chapter discusses the limitations of the centralized
    model to secure IoT and proposes the blockchain approach as example of successful
    distributed system to bring security and privacy to IoT devices. In this direction,
    we introduce FairAccess and PPDAC, as a lightweight and privacy-preserving access
    control framework based on the emergent blockchain technology, mainly the permissionless
    and public type, to ensure fine-grained access control functions for IoT devices
    with strong anonymity guarantee for IoT end-users. The proposed framework retains
    the benefits of the blockchain to meet IoT security and privacy arising needs
    while overcoming the challenges in integrating the blockchain to IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain; IoT; Privacy; SmartContracts; Access control; CP-ABE
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two decades ago, a world where everyday objects could sense, analyze, store,
    or exchange information existed only in science-fiction novels [[1]](S0065245818300676.xhtml#bb0010).
    Today, with the rapid grow of hardware technologies, such scenarios are increasingly
    becoming reality. In fact, Gartner identifies IoT as one of the top 10 strategic
    technology trends,^([a](S0065245818300676.xhtml#fn0010)) Cisco forecasts 50 billion
    devices connected by 2020^([b](S0065245818300676.xhtml#fn0015)) a potential market
    in excess of $14 trillion.^([c](S0065245818300676.xhtml#fn0020)) IoT is actually
    already here. Things are extending the world we live in by enabling a whole new
    range of applications. Being able to put a bunch of powerful, tiny, and cheap
    computers everywhere around us making it possible to monitor and interact with
    the physical world with a much finer spatial and temporal resolution than ever
    before. And yet the application scenarios and market opportunities offered by
    objects communicating actively and autonomously extend far beyond the foreseeable
    horizon [[2]](S0065245818300676.xhtml#bb0015).
  prefs: []
  type: TYPE_NORMAL
- en: IoT is both a global physical infrastructure and an umbrella term for conceiving
    many existing and evolving interoperable Information and Communication Technologies
    (ICT)’s, interconnected, devices, objects and services [[3]](S0065245818300676.xhtml#bb0020),
    increasingly deployed in various range of domains such as industrial control,
    health care, aviation, home automation, retail, transport, wearable, and more
    [[4](S0065245818300676.xhtml#bb0025),[5]](S0065245818300676.xhtml#bb0030). This
    revolution, also known as web of things [[6]](S0065245818300676.xhtml#bb0035),
    Internet of Everything or Fog networks [[7]](S0065245818300676.xhtml#bb0040) where
    smart things are communicating among each other and with computers in the Internet
    in an intelligent [[8]](S0065245818300676.xhtml#bb0045) and a machine-to-machine
    way [[9]](S0065245818300676.xhtml#bb0050), aims at redefining the whole relationship
    of humans, work, and technology [[10]](S0065245818300676.xhtml#bb0055).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as quoted by the French theorist and urbanist Paul Virilio: “When
    you invent the ship, you also invent the shipwreck … Every technology carries
    its own negativity, which is invented at the same time as technical progress”
    [[11]](S0065245818300676.xhtml#bb0060). This wise adage gives us an eloquent understanding
    of how IoT will be a revolutionary technology if we can overcome its drawbacks
    mainly its security and privacy issues. Actually, in one hand, IoT is arising
    new security challenges due to the use of simple processors and operating systems
    that are not supporting sophisticated security approaches by the majority of IoT
    devices. In addition, the lack of authentication and authorization standards for
    IoT edge devices gives birth to malicious attacks on secrecy and authentication,
    silent attacks on service integrity, or attacks on network availability such as
    denial-of-sleep attacks that drain batteries, or denial-of-service (DoS) attacks
    [[12](S0065245818300676.xhtml#bb0065),[13]](S0065245818300676.xhtml#bb0070).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, privacy is no less serious issue. Actually, IoT devices
    are, by nature, “collectors and distributors of information” [[8]](S0065245818300676.xhtml#bb0045),
    so they constitute a huge challenge to individual privacy [[14](S0065245818300676.xhtml#bb0075),[15]](S0065245818300676.xhtml#bb0080),
    especially, the omnipresence of IoT devices in user''s everyday life and his ubiquitous
    interaction with smart objects. In addition to the uncontrolled, automated and
    unseen collection of fine-grained data by third parties lacking in transparency
    may consistently exhibit users to several threats, such as: identification, localization
    and tracking, monitoring, surveillance, manipulation, profiling, data linkage,
    privacy-violating interaction and presentation and even social engineering [[16](S0065245818300676.xhtml#bb0085),[17]](S0065245818300676.xhtml#bb0090).
    Privacy-by-policy and privacy-by- design are two emergent approaches, elicited
    by the academic literature [[18](S0065245818300676.xhtml#bb0095)–[20](S0065245818300676.xhtml#bb0105)]
    to enhance privacy in IoT. Privacy-by-policy aims to protect data from accidental
    disclosure or misuses, also promoting informed costumer choice [[21](S0065245818300676.xhtml#bb0110),[22]](S0065245818300676.xhtml#bb0115),
    while privacy-by-design prompts to implement privacy throughout the engineering
    process, with a proactive and preventative approach, rather than ex post [[23](S0065245818300676.xhtml#bb0120),[24]](S0065245818300676.xhtml#bb0125).
    Combining both approaches has proven crucial to conceptualize and alleviate potential
    risks associated with the IoT, which nevertheless still a highly controversial
    issue.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, current solutions can hardly keep up with those new arisen challenges.
    Therefore, new security and privacy-engineering practices and distributed architectures
    are increasingly urgently needed to properly address the IoT major challenges.
    Thus, our research is concerned about how decentralization through blockchain
    technology, mainlythe permissionless and public type, can be applied to provide
    a privacy-preserving access control solution to IoT objects and what are the strengths
    and weaknesses in doing so. For that purpose, we introduced FairAccess [[25](S0065245818300676.xhtml#bb0130),[26]](S0065245818300676.xhtml#bb0135)
    as a novel Distributed Privacy Preserving Access Control framework in IoT scenario
    that combines access control models and cryptocurrency blockchain mechanisms.
    In FairAccess, we propose the use of SmartContract to express fine-grained access
    control policies to make authorization decisions. We opt for authorization tokens
    as access control mechanism, delivered through emergent cryptocurrency solutions.
    We use the public blockchain first to ensure evaluating access policies in distributed
    environments where there is no central authority/administrator, and guarantee
    that policies will be properly enforced by all interacting entities and second
    to ensure token reuse detection. However, the public aspect of the blockchain
    ledger might initially appear to be at odds with the private aspect of some access
    control policies. To tackle this issue, this position chapter proposes a privacy-preserving
    distributed access control (PPDAC) scheme to be integrated with FairAccess. PPDAC
    uses a white box version of Distributed Cipher-text Policy Attribute Based Encryption
    “DCP-ABE” technique to add a privacy layer hiding sensitive attributes and private
    access control policies in the public blockchain while keeping the verification
    process transparent and public. In addition, the use of recent protocol in cryptography
    such as zero proof of knowledge protocol “zk-SNARK” enables our framework to guarantee
    high anonymity and intractability to IoT end users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reminder of this chapter is organized as follow: [Section 2](S0065245818300676.xhtml#s0015)
    begins with the definition of IoT''s specific requirements in security and privacy.
    It discusses the drawbacks of the centralized approach and the advantages of the
    distributed one in IoT context. [Section 3](S0065245818300676.xhtml#s0035) proposes
    the blockchain approach as a promising distributed technology to enable security
    in IoT. This will be followed by some brief overview of the blockchain technology.
    [Section 4](S0065245818300676.xhtml#s0050) investigates our proposed approach
    to ensure smart objects security through a decentralized and user-driven access
    control framework based on the blockchain named FairAccess and discusses the limitations
    we have faced using the public blockchain mainly the privacy and traceability
    problems. [Section 5](S0065245818300676.xhtml#s0070) overcomes the defined problems
    by adding a privacy layer on top of the blockchain through PPDAC scheme. Finally,
    [Section 6](S0065245818300676.xhtml#s0140) concludes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 Problem statement and research questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.1 IoT security and privacy requirement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 'IoT is exposed to significant privacy and security risks due to its heterogeneous
    devices, dynamics, multiple domain application and undefined perimeters. As a
    result, it becomes more difficult for security researchers to find comprehensive
    solutions to the current security challenges. Therefore, the importance of understanding,
    defining and analyzing those requirement becomes paramount. In fact, each domain
    application presents peculiarities that often depend on the context and the devices
    interacting in that field, and that must be considered when dealing with security
    and privacy requirements. To meet this end, we have conducted a deep analysis
    that supports the specification of security and privacy requirements in a structured
    form in ref. [[27](S0065245818300676.xhtml#bb0140)]. During our study, we began
    by defining those requirements into six groups: Privacy, Confidentiality and Integrity,
    Reliability and availability, social and economic aspects, technologies constraints
    and usability. The six main security and privacy requirements along with their
    subcomponents are shown in [Fig. 1](S0065245818300676.xhtml#f0010).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 1](images/S0065245818300676/f08-01-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 1 IoT's security and privacy requirements [[27]](S0065245818300676.xhtml#bb0140).
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we listed different application fields of IoT and specify the characteristics
    and security requirements of each one. Indeed, we have categorized these applications
    into three domains: (1) Personal and home: at the scale of individual, home and
    healthcare. (2) Government and utilities: at the scale of community nation and
    region. (3) Enterprise and industry: at the scale of industries and big companies.
    Moreover, we gave an overview of different taxonomies and classification of constrained
    devices in IoT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The study conducted to the following findings: In a glance, it is shown that
    with regard to personal and home category, access control solutions targeting
    this category are required to preserve the privacy of end users in a proprietary,
    primordial but user-friendly way. In addition, the availability and reliability
    needs are the outstanding objectives of security solutions targeting enterprise
    and industry category, while the confidentiality and integrity needs overwhelm
    when it comes to government and utilities applications. However, it is observed
    that the whole categories commonly share the following needs on principles of
    cooperation and collaboration, openness/interoperability, high scalability, flexibility
    and distribution. [Fig. 2](S0065245818300676.xhtml#f0015) depicts the relationship
    between the various IoT domain application and the security requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 2](images/S0065245818300676/f08-02-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2 IoT domain application taxonomy and their security requirements [[27]](S0065245818300676.xhtml#bb0140).
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 The state of current access control architectures in IoT and related challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The integration of physical objects in the internet infrastructure requires
    the application of lightweight security mechanisms to be used even in constrained
    environments. However, current security standards and access control solutions
    were not designed with such aspects in mind. They are not sufficient to meet the
    needs of these nascent ecosystems regarding scalability, interoperability, lightness
    and end-to-end security [[27]](S0065245818300676.xhtml#bb0140). These challenges
    have attracted more and more attention from research community and recently several
    efforts are starting to emerge in this direction. However, those solutions could
    be categorized within three approaches as follow (see [Fig. 3](S0065245818300676.xhtml#f0020)):'
  prefs: []
  type: TYPE_NORMAL
- en: • The Centralized architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This approach consists in outsourcing IoT device''s access control related
    operations to a trusted third entity. This entity, also known as a Policy Decision
    Point (PDP), could be instantiated by a back-end server or gateway directly connected
    to the device that it manages. It is responsible for analyzing access requests
    based on the stored access control policies. Therefore, requesters wishing to
    get access to the data provided by end devices are asked to pass by those trusted
    third parties. The bright side of this architecture consists in relieving constrained
    devices (i.e., sensors, actuators) from the burden of processing heavy access
    control functionalities, which enables the use of standard access control technologies
    such as SAML and HTTPS (to transport in a secure way authentication information),
    XACML (to define complex access control policies) among many others. However,
    this architecture presents major disadvantages, in the context of IoT, listed
    as follow: First, end to end security is dropped by the introduction of a trusted
    third party. Second, the role of IoT devices is strictly limited, within this
    architecture, in the decision making process. As a result, the elaboration of
    smart authorization policies, where access control decision are based on contextual
    information instantaneously collected from the environment of IoT end devices,
    is hardly challenging. Third, the Resource Owner (RO) access control policies
    as well as the users'' authorization requests are revealed to the trusted party.
    As a result, the privacy of either the resource owner or the requester is corrupted.
    Fourth, the PDP remains a bottleneck and point of failure that can disrupt the
    entire network. This is particularly important when it is directly tied to critical
    IoT services.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: • The Decentralized architecture with trustful entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this approach, the device participates partially in the elaboration of the
    access control decision. Its main role consists in gathering the contextual information
    from its surrounding environment (location, temperature, humidity, power level,
    etc.) and send it to a trusted third party. This trusted third party receives
    the access control requests and makes the decision based on a pre-defined policies
    and the contextual information received from the smart object. Like the centralized
    approach, this architecture enables the use of already existing authorization
    technologies with the need to elaborate a connection between the trusted third
    party and the connected device to transfer the contextual information. However,
    in this scenario, additional security measures have to be taken to secure the
    communication channel between the trusted third party and the end-device to protect
    the transferred information. In addition, end-device has to be configured to providing
    or not its collected data. Moreover, the transfer of contextual information to
    the trusted party could not be achieved in instantaneous way, meaning that this
    architecture is not recommended in use cases where real time decisions access
    is required such as health-care scenario, or with SCADA systems. Finally, the
    privacy of the resource owner and the requester is not considered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: • The Distributed architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distributed approach consists in locating and embedding the intelligence
    of processing an access control decision in the device side. This approach matches
    perfectly with the real essence of IoT where intelligence is located in the edge
    of the network. It presents many impressive and promising advantages regarding
    the privacy of the resource owner and the requester as no trusted third party
    is involved. With the edge-intelligence principal, end-users are more empowered
    to control access over their own devices by defining their own policies. Furthermore,
    the possibility of making a smart access control decision in a real time is given.
    Moreover, the cost management of data generated by IoT devices is less expensive
    than the one in the two precedent approaches where providing a cloud back end
    for each connected smart object is required. In the distributed approach, devices
    are authorized to send information just when it is necessary. Finally end-to-end
    security could be achieved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fig. 3](images/S0065245818300676/f08-03-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3 Existing access control architectures in IoT.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most challenging hurdle in this approach arises from the inherent
    features of existing access control technologies such as RBAC [[28]](S0065245818300676.xhtml#bb0145)
    and ABAC [[29]](S0065245818300676.xhtml#bb0150) and OAUTH [[30]](S0065245818300676.xhtml#bb0155)
    that make their implementation unfeasible in resource-constrained devices [[31]](S0065245818300676.xhtml#bb0160).
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, much effort has to be conducted to deeply analyze the viability
    of adapting existing access control models or defining new proposals that meet
    the requirements of a distributed access control approach.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The centralized and decentralized with trustful entity approaches where all
    devices are identified, authenticated and connected through cloud-based servers
    support huge processing and storage capacities. While this model has been used
    for decades to connect standards computing devices and will continue to fit small-scale
    IoT networks [[32]](S0065245818300676.xhtml#bb0165), it severely struggles to
    respond to the growing needs of the huge IoT ecosystems of tomorrow [[33](S0065245818300676.xhtml#bb0170)–[35](S0065245818300676.xhtml#bb0180)]
    for the following reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '• Cost: Existing IoT solutions are expensive due to two main reasons: (1) high
    maintenance cost: from the manufacturer''s side, the centralized clouds, large
    server farms, and networking equipment have a high maintenance cost considering
    the distribution of software updates to millions of devices for years after they
    have been long discontinued [[36]](S0065245818300676.xhtml#bb0185). (2) High infrastructure
    cost: the sheer amount of communications that will have to be handled when there
    are tens of billions of IoT devices needs to cater to a very high volume of messages
    (communication costs), data generated by the devices (storage costs), and analytical
    processes (server costs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Bottleneck and single point of failure: cloud servers and farms will remain
    a bottleneck and point of failure that can disrupt the entire network. This is
    particularly important when it is directly tied to critical IoT services such
    as healthcare services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Scalability: within the centralized paradigm, cloud-based IoT application
    platforms acquire information from entities located in data acquisition networks,
    and provide raw data and services to other entities. These application platforms
    control the reception of the whole information flow. This enforcement creates
    a bottleneck to scaling the IoT solutions to the exponentially growing number
    of devices and the amount of data generated and processed by those devices (i.e.,
    the concept of “Big Data”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Insufficient security: The tremendous amount of data collected from millions
    of devices raises information security and privacy concerns for either individuals,
    corporations, or governments. As proven by recent denial-of-service attacks on
    IoT devices [[37]](S0065245818300676.xhtml#bb0190), the huge number of low-cost
    and insecure devices connected to the internet is proving to be a major challenge
    in assuring IoT security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Privacy breaches and Lack of transparency: in the centralized models, from
    the consumer''s side, there is an undebatable lack of a trust in service providers
    getting access to data collected by billions of entities creating information.
    There is a need for a “security through transparency” approach allowing users
    to retain their anonymity in this super connected world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3 The solution: Decentralizing IoT networks in trustless way through the blockchain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A decentralized approach to IoT networking would solve many of the centralized
    related issues described above. The concept of a distributed IoT is not novel.
    In fact, many academic and industrial documents consider it as one of the most
    promising approaches that can push the dream of the IoT into the real world. Panikkar
    et al. [[36]](S0065245818300676.xhtml#bb0185) point out the need for a shift toward
    a decentralized architecture for the ever-expanding IoT device ecosystem to be
    sustainable. It has been explicitly mentioned that the development of decentralized
    autonomic architectures and the location of intelligence at the very edge of the
    networks are issues that need to be addressed. We argue that the blockchain provides
    an elegant solution to the aforementioned problems.
  prefs: []
  type: TYPE_NORMAL
- en: '3.1 The blockchain phenomenon: A new wave of decentralization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Originally introduced by Satoshi Nakamoto in 2008 [[38]](S0065245818300676.xhtml#bb0195)
    to underpin the Bitcoin cryptocurrency network, the blockchain has taken up the
    bulk of technology industry and financial world attention. As a secure and decentralized
    computational infrastructure, it is widely acknowledged as a disruptive and efficient
    solution for the problems of centralization, privacy and security when recording
    tracking, monitoring, managing and sharing not only financial transactions but
    also any other value such as birth and death certificates, marriage licenses,
    deeds and titles of ownership, educational degrees, financial accounts, medical
    procedures, insurance claims, votes, provenance of food, and anything else that
    can be expressed in code [[39](S0065245818300676.xhtml#bb0200)–[41](S0065245818300676.xhtml#bb0210)].
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we focus our study on the public and permissionless type of
    the blockcain. Then, we define this later as a distributed database for transaction
    processing. All transactions in a blockchain are stored into a single ledger.
    The blockchain technology is built on top of four fundamental building blocks,
    each building block has key properties, and each property is achieved through
    specific mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider that the blockchain technology relies on the following building
    blocks as described below:'
  prefs: []
  type: TYPE_NORMAL
- en: '(1) Identifying the source and destination of a transaction: in a blockchain
    based ecosystem, users serve from digital identities called “addresses” to send
    and receive transactions. Those addresses should have the following key features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '• Self-issued and independent: users should be able to self-generate anonymous
    (e.g., using software) transaction identities (e.g., a cryptographic hash of the
    public-key, in Bitcoin system) in an independent way from any given authority
    (e.g., government, businesses, etc.).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Anonymous: transaction identities should be anonymous in the sense that it
    reveals nothing about the real identity of its owner to fulfill the needs of user
    privacy, then true anonymity in digital identities requires more than self-issuance
    feature. It requires also the possession of the unlikability and intractability
    features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Privacy-preserving verifiable: any entities in the system should be able
    to verify the security of the digital identity. A publicly verification algorithms
    to validate the source of trust for any given (anonymous) transaction-identity
    is required while preserving the privacy of the owner of the identity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(2) Transactions: A transaction records the transfer of a value (altcoin) from
    some source address to destination addresses. Transactions are generated by the
    sender and broadcasted the network of peers. Transactions are invalid unless they
    have been recorded in the public history of transactions, the blockchain. Ultimately,
    transaction processing with blockchain technology should satisfy the following
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '• Proprietary: Only the owner who is authorized to perform transactions using
    her own identifying addresses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Irreversible: Once transaction has entered the ledger, it should be impossible
    to modify its information, or delete it, which would effectively reverse the transaction.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Publically verifiable: The verification algorithm of a transaction should
    enable any node in the network to verify the validity of the transaction.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Immunity: Once a transaction is recorded in the blockchain it cannot be altered
    without that alteration being detected and rejected by the other nodes in the
    network. In addition, if a transaction conforms to a ledger protocol, it should
    be eventually added to the ledger.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(3) Condition for auto-processing a transaction: The transfer of any value
    (e.g., altcoins, tokens) with the blockchain or the execution of any function
    through the blockchain should be locked by logic conditions (e.g., low, contract)
    that must be written as a code and automatically executed by nodes in the network.
    This condition should be self-executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(4) Consensus: Every user or node in the network relies on algorithmically
    enforced rules to process transactions with no human interaction required to verify
    in an independent way the correct execution of the protocol and obtains the same
    results. Each node has exactly the same ledger as all of the other users or nodes
    in the network. This ensures a complete consensus from all users or nodes in the
    corresponding currencies blockchain.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The blockchain Mechanisms: To satisfy the properties cited above, a suit of
    cryptographic mechanisms has been introduced as explained below and described
    in [Fig. 4](S0065245818300676.xhtml#f0025):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 4](images/S0065245818300676/f08-04-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4 Blockchain's building blocks and mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Public key cryptography: enables a self-issued, pseudonymous and a privacy-preserving
    identification. Digital signature: is used to satisfy the feature of transaction
    proprietary and publically verifiable properties: Each user in the system possesses
    at least a pair of private and public keys; the public key is published publically
    to determine the digital identity, while the private key is used to sign the corresponding
    transaction by it owner (or a trusted party on her behalf).'
  prefs: []
  type: TYPE_NORMAL
- en: • The validity of the signature is tied to the knowledge of the sender's private
    key (proprietary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A signature can be verified by anyone knowing the sender's public key (publically
    verifiable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A signature is invalidated if any parameters of the transaction are changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hash function [[42]](S0065245818300676.xhtml#bb0215) and Merkle tree [[43]](S0065245818300676.xhtml#bb0220):
    are used to solve the problem of Immutability, irreversibility and public verification
    of transactions in blockchain systems. Those features are achieved by distributing
    transactions into time-ordered blocks and time stamping each of these blocks by
    its cryptographic hash.'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are summarized in each block using a Merkle tree, also known as
    a binary hash tree. It is an efficient data structure that serves to summarize
    and verify the integrity of large sets of data. Organizing blocks in an ordered
    chain called (blockchain), where each block refers to the previous one, is a clever
    technique introduced by Nakamoto to make it infeasible to delete or replace the
    whole blocks. To simplify blockchain verification, key block parameters (such
    as a Merkle root) are collected in a block header. Thus, providing immutability
    of transactions is equivalent to providing immutability of block headers.
  prefs: []
  type: TYPE_NORMAL
- en: The Immunity feature of transactions is achieved through the properties of hashing
    functions. Actually, any alteration in the transaction results in changes in the
    Merkle root of the block, which is a part of its header. Hence, to change a single
    block, an attacker must also change all succeeding blocks in the ledger which
    is infeasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof of X where X ∈ (Work/stack/Space etc.) consensus protocols: Once the
    transactions have been created, it is broadcasted in the network and each node
    verifies independently the received transaction and includes it in a block. However,
    each node may have different view of the blockchain leading to a divergence of
    branches of a blockchain. To mitigate this problem, there is a need of a distributed
    mechanism to reach consensus among the untrusted participants in the network.
    This problem is historically known as “Byzantine Generals” (BG) Problem, which
    was raised in ref. [[44](S0065245818300676.xhtml#bb0225)]. Reaching consensus
    in distributed environment is a challenging task. Actually, the consensus of the
    network could be achieved in a variety of ways, including proof of work (e.g.,
    as used in Bitcoin), proof of stake (e.g., Nxt), delegated proof of stake (e.g.,
    BitShares) and Practical byzantine fault tolerance (hyper ledger project). For
    more details, we refer the reader to a comprehensive survey of those four approaches
    in refs. [[45](S0065245818300676.xhtml#bb0230), [46](S0065245818300676.xhtml#bb0235)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'SmartContract/scripting language: are used to satisfy the auto-processing properties.
    The scripting language describes the execution of a certain program on a stack
    machine. Each transaction contains a script which locks, or encumbers, the value
    transferred by this transaction. A script is a part of each input and each output
    of a transaction. When we generalize this scripting language computation to arbitrary
    Turing complete logic, we obtain an expressive smart contract system. The interest
    in smart contract applications steadily risen since 2014 due to the appearance
    of Bitcoin-like technologies, such as Ethereum [[47]](S0065245818300676.xhtml#bb0240)
    and many other works designed specifically to decentralized smart contract system.
    SmartContracts are self-executed cryptographic “boxes” that are stored in the
    blockchain and contain value only unlocked if certain conditions are met.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Why the blockchain as a solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Blockchain technology and IoT offer a new world of promise and fascinating
    possibilities. Actually, the decentralized, autonomous, and trustless inherent
    capabilities of the blockchain make it an ideal component to become a foundational
    element of IoT solutions. It can potentially improve the IoT sector [[48]](S0065245818300676.xhtml#bb0245),
    and significantly help in achieving the vision of decentralized [[49]](S0065245818300676.xhtml#bb0250)
    and private-by-design IoT [[50]](S0065245818300676.xhtml#bb0255).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following salient features of the blockchain, illustrated in [Fig. 5](S0065245818300676.xhtml#f0030),
    make it an attractive technology for addressing the aforementioned security and
    privacy challenges in IoT:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Decentralization and trustlessness: The lack of central control ensures scalability
    and robustness by using resources of all participating nodes and eliminating many-to-one
    traffic flows, which in turn decreases delay and overcomes the problem of a single
    point of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Append-only. The major design goal of the blockchain is to make it such that
    deleting information from the blockchain (i.e., reversing transactions) is impossible
    or at least prohibitively expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Pseudo-anonymity: The inherent anonymity afforded is well-suited for most
    IoT use cases where the identity of the users must be kept private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Transparency: Each node in the network can independently verify the current
    state of the ledger and arrive to the same conclusion as the rest of the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Cryptography model: The trust in the blockchain does not arise from an authority
    maintaining the ledger, but rather from the mathematical soundness of the cryptographic
    protocols used in the system and a prohibitive economic cost of an attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Fig. 5](images/S0065245818300676/f08-05-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 5 The benefits of combining the blockchain with IoT.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, adopting the blockchain to handle authorization functions in IoT is
    not straightforward and will require addressing the following critical challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: • The public nature of the blockchain versus the private aspect of access control
    policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Tractability problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Consensus process is particularly computationally intensive, time consuming
    while the majority of IoT devices are resource restricted and most IoT applications
    low latency is desirable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previously defined problem statement leads to the following research questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 How to solve access control challenges in IoT by leveraging the public and
    permissionless blockchain technology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 How to provide a lightweight access control framework for constrained IoT
    devices despite the intensive computation power required by the consensus protocol
    adopted in the public blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3 How to enable a privacy preserving access control solution that hides user's
    access control policy and overcomes the problem of traceability and profiling
    commonly known in the public blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4 FairAccess: Using blockchain technology as access control infrastructure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To answer the aforementioned questions, we propose a framework composed of
    two main modules that are: FairAccess and PPDAC as shown in [Fig. 6](S0065245818300676.xhtml#f0035).
    In the next section we will give an overview and brief description of the both
    protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 6](images/S0065245818300676/f08-06-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 6 Our proposed solution.
  prefs: []
  type: TYPE_NORMAL
- en: '4.1 FairAccess: Using blockchain technology as an access control infrastructure'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FairAccess [[25](S0065245818300676.xhtml#bb0130), [51](S0065245818300676.xhtml#bb0260)]
    is a new distributed access control framework based on Blockchain technology that
    has combined, for the first time, access control models and cryptocurrency blockchain
    mechanisms. In FairAccess, we propose the use of SmartContract [[47]](S0065245818300676.xhtml#bb0240)
    to express fine-grained and contextual access control policies to make authorization
    decisions. We opt for authorization tokens as an access control mechanism, delivered
    through emergent cryptocurrency solutions. We use blockchain to ensure enforcing
    access policies in distributed environments where there is no central authority/administrator,
    and guarantee that policies will be properly implemented by all interacting entities
    ([Fig. 7](S0065245818300676.xhtml#f0040)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 7](images/S0065245818300676/f08-07-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 7 FairAccess's building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization token: In our FairAccess framework, we define an Authorization
    Token as a data structure that represents the access right or the entitlement
    defined by the creator of the SmartContract, generating the authorization token,
    to the entity interacting with this SmartContract in order to access a specific
    resource identified by its address. If the authorization token presented by the
    device was delivered by a SmartContract that matches with the one that is associated
    with the other device or service that manages that device, then the access is
    granted. Actually, the token-based access control enforced by the blockchain technology
    provides many advantages in IoT context. Actually, having the token securely held
    on the blockchain means smart devices can easily verify the validity of the access
    token relieving IoT constrained devices from the burden of handling a vast amount
    of access control-related information and at the same time mitigates the need
    for outsourcing these functionalities to a trusted powerful entity that prevents
    end-to-end security to be achieved. Moreover, it reduces communication cost, since
    no further authentication mechanisms are required to get the token since only
    signature is sufficient. Similarly, the resource owner can manage and update access
    to his numerous and heterogeneous devices by placing a resource hash of the requested
    data on the blockchain. Then the device can read the hash and check the update
    access control configurations. This hash can be updated with every new connection
    to the blockchain. This could enable easier management and updating of access
    control policies if the access control logics would be located in the device side,
    especially for devices that are placed in unreachable or hardly attended location
    such as a smart parking systems, where devices may be embedded directly in the
    asphalt. In addition, the token could be used for many access control operations
    such as getting, delegating, revoking and even updating access in an easier and
    flexible way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchain: FairAccess provides several useful mechanisms using the blockchain.
    In fact, in FairAccess, the blockchain is considered as a database or a policy
    retrieval point where all access control policies are stored in form of transactions;
    it serves also as logging databases that ensure auditing functions. Furthermore,
    it prevents forgery of token through transactions integrity checks and detects
    token reuse through the double spending detection mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SmartContract: The SmartContract has its own account on the blockchain, and
    the blockchain supports an account-based model [[47]](S0065245818300676.xhtml#bb0240).
    It allows us to express logic functions in code. It operates as autonomous actors,
    whose behavior is completely predictable. As such they can be trusted to drive
    forward any on-chain logic that can be expressed as a function of on-chain data
    inputs, provided that the data they need to manage are within their own reach
    (in the example above, the contract would not be able to trade assets that it
    did not own). In addition, its code can be inspected by every network participant
    since all the interactions with a contract occur via signed messages on the blockchain,
    all the network participants get a cryptographically verifiable trace of the contract''s
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: This enables our framework to express fine grained access control policies.
    Actually, a policy is a set of rules and conditions (based on a specific context
    or attribute, etc.) that a requester entity has to fulfill in order to obtain
    the Access Token and gets access to the specific resource. This rules could be
    expressed by any access control model but must be transformed to a script language
    considered as locking script placed on the output of a transaction. Fortunately,
    new blockchain protocols are being developed including full Turing completeness
    capability, allowing anyone to write smart contracts and decentralized applications
    with their own arbitrary rules for ownership, transaction formats and state transition
    functions [[47]](S0065245818300676.xhtml#bb0240). The use of those advanced languages,
    such as Ethereum, will certainly enable our FairAccess framework to express fine-grained
    context-aware access control policies. We believe that SmartContracts are a promising
    emergent field to express, granular, contextual and contractual access control
    model in general and in IoT in particular.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 FairAccess's architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The vision of our decentralized access control framework is a system of autonomous
    organizations hinged around one or many Resource Owners in possession of one or
    many resources identified with addresses and interacting between each other through
    transactions (requesting, granting, delegating and revoking access) under the
    control of their RO. The blockchain is a ledger keeping track and ensures the
    validity of access transaction among interacting organization. Each manages its
    own access policy, under only the control of his Resource Owner, resulting in
    an “Internet of Decentralized, Autonomous Organization” and thus the fairness
    of our access control framework ([Fig. 8](S0065245818300676.xhtml#f0045)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 8](images/S0065245818300676/f08-08-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 8 FairAccess's architecture overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the following scenario, see [Fig. 9](S0065245818300676.xhtml#f0050),
    where a subject (e.g., a device A, identified with the address rq) wants to perform
    an action (e.g., modify) on a protected resource (e.g., Device B temperature,
    identified with address rs). We assume that the requester already knows the access
    control policy regulating access to Device B. FairAccess workflow is as follow:
    the Rq fulfills the conditions specified in the access control policy and submits
    his request through his wallet in form of a RequestAccess Transaction. Afterword,
    the wallet broadcasts this transaction to the network nodes till it reaches miners.
    Those later act as distributed Policy Decision Point (dPDP), and evaluate the
    transaction and check the request with the defined policy, by executing a PolicyContract
    already deployed, by the owner of Device B, in the blockchain through a previous
    transaction called GrantAccess. The execution of PolicyContract determines whether
    the request should be permitted or denied. Finally, if it is being successfully
    executed, the PolicyContract generates and assigns an authorization token to the
    requester address through an AllowAccess transaction. Then the authorization token
    is recorded in the blockchain and appears in the requester''s authorization token
    list. Finally, the requester presents the authorization token to the end device
    through a GetAccess Transaction. The end device B checks the validity of the authorization
    token by referring to the blockchain; if this authorization token was delivered
    by the SmartContract corresponding to the device B, it allows access else it denies.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 9](images/S0065245818300676/f08-09-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 9 FairAccess workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The faced challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FairAccess has successfully achieved the following IoT''s security and privacy-preserving
    requirements, fixed in the beginning of this chapter, that are: (1) Distributed
    nature and the lack of a central authority. User-driven and transparency. (2)
    Lightweightness. (3) Fine-granularity. (4) Identification enabling thing to thing
    interaction. (5) Pseudonymity and Unlikability. However, adopting the blockchain
    technology to handle access control functions is not straightforward and additional
    critical issues emerge that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '(1) The public and transparent aspect of the blockchain comes at odds with
    the private aspect of access control policies publically recorded in the blockchain:
    Often times, the policies for determining who can access the resources are sensitive
    also and need protection as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (2) Traceability issue such as the structure of the transaction graph [[52](S0065245818300676.xhtml#bb0265),[53]](S0065245818300676.xhtml#bb0270)
    as well as the value and dates of transactions may conduct to learning devices
    authorization functionality pattern, as well as if a particular device is trying
    to communicate with other devices
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5 Toward privacy through transparency: A privacy-preserving distributed access
    control (PPDAC) scheme to enhance privacy and anonymity in FairAccess'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we will show how to overcome those two identified challenges
    by introducing PPDAC as a fully anonymous Privacy-Preserving Distributed Access
    Control scheme (PPDAC) to be integrated over FairAccess. PPDAC provides a strong
    privacy guarantees access control scheme that preserves the resource owner's access
    control policies and the requester's sensitive attributes and then preserves in
    a strong way the anonymity of both the requester and the Resource owner, see [Fig.
    10](S0065245818300676.xhtml#f0060). The proposed scheme aims to maintain Blockchain
    transparency features while ensuring strong privacy guarantees for users. We develop
    a policy-hiding access control scheme that protects both sensitive attributes
    and sensitive policies. That is, nodes in the public blockchain can decide whether
    Alice's certified attribute values satisfy Bob's policy, without learning any
    other information about Alice's attribute values nor Bob's policy. To enable policy-hiding
    access control, and untraceability of authorization tokens, our construction for
    PPDAC uses a novel technique that combines a white box distributed multi-authority
    CP-ABE [[54](S0065245818300676.xhtml#bb0275),[55]](S0065245818300676.xhtml#bb0280),
    zk-SNARKs [[56]](S0065245818300676.xhtml#bb9000) protocols and SmartContract ([Fig.
    11](S0065245818300676.xhtml#f0055)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 10](images/S0065245818300676/f08-11-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 10 PPDAC buildings blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 11](images/S0065245818300676/f08-10-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 11 PPDAC based technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 PPDAC building blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a traditional CP-ABE scheme, an encryptor can encrypt data with a hidden
    access structure. A decryptor obtains his secret key associated with his attributes
    from a certifying authority in advance and if the attributes associated with the
    decryptor''s secret key do not satisfy the access structure associated with the
    encrypted data, the decryptor cannot decrypt the data or even guess what access
    structure was specified by the encryptor. In our setting, due to the fact that
    our framework is built on a public blockchain, the aim to use the CP-ABE technique
    is not to decrypt data as it was introduced in the literature, but instead to
    ensure two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Hiding the RO access control policies in the blockchain network
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2. Enabling the requester to prove, in a public way to the network (miners),
    that his hidden attributes fit the hidden policies. For this purpose, we introduce
    two new notions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A challenge: is an arbitrary string chosen at random by the resource owner
    and encrypted to get a ciphertext CT. It is considered as a proof of access control
    policy fulfillment used by the requester to prove, in a public way, to the blockchain
    network, his fulfillment of access control policy without revealing his attribute
    nor the access control policy, since the evaluation of access control policy is
    reduced to the ability of the requester to decrypt the ciphertext CT and obtain
    the publically known challenge. Actually, the requester will be able to decrypt
    the cipher text CT if and only if his attributes match with the hidden access
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An identity key (IDkey): in our setting, we introduce the notion of IDkey which
    plays the same role of a private key, but it is public. This IDkey holds the features
    of a cryptocurrency coin. The IDkey should fulfill three important properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Anonymous: in the sense that it reveals no information about the real identity
    of his owner. Untraceable: we cannot guess the origin who sends the token to the
    blockchain. We acheive the anonymity and untraceability of IDkey using the zero-knowledge
    Succinct Non-interactive ARguments of Knowledge (zk-SNARKs) by hiding the origin
    of transaction spending the IDkey.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Usage is controlled by the owner: We argue that the identity token IDkey,
    which is cryptographically secured by the blockchain as a coin, could not be secret,
    since the usage of this identity token is restricted to his owner or ceded under
    his consentement. To achieve this property, we will “tie” the usage of an IDkey
    to spending an associated IDcoin which is, at its turn, controlled by the possession
    of a private key only known by the owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our protocol runs between the following entities: a Resource owner (RO) who
    owns IoT device (D), one or many requesters that could be service providers the
    (RO) wants to collaborate with to get smart services over his device. A set of
    authorities responsible for certifying a set of attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '• Certifying authorities: the certifying authorities are trusted and manage
    their attributes set in an independent way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• FairAccess node: A FairAccess node is equivalent to the role of miners. We
    suppose that those nodes are honest but curious. Hence, not only the identity
    of interacting entities should be anonymous but also the access control policy
    held in SmartContract should be hidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Ro: the resource owner is responsible for defining an access control policy
    over his devices and obfuscating this access control policy inside a SmartContract
    using decentralized multi-authority CP-ABE with hidden policy. Then he deploys
    the SmartContract to the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Requester: the certifying authorities generates relevant IDkeys for each
    requester. Furthermore, only requesters who''s IDkeys satisfy the access control
    policy get an authorization token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 PPDAC phases and functionalities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The proposed protocol divides the interaction between parties into five phases
    as follows: a set up phase, a Grant Access phase, a RequestAccess phase, a GetAccess
    phase, an evaluating access control policy phase and an AllowAccess phase ([Figs.
    12](S0065245818300676.xhtml#f0065)–[14](S0065245818300676.xhtml#f0085)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 12](images/S0065245818300676/f08-12-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 12 PPDAC's phases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 13](images/S0065245818300676/f08-13-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 13 Hiding the private access control policies inside the public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 14](images/S0065245818300676/f08-16-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 14 Unlinkability and intractability of authorization tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Background and definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To construct the PPDAC scheme, the following building blocks and definitions
    are adopted.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Pseudorandom function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Definition 1\. Collision-resistant hashing
  prefs: []
  type: TYPE_NORMAL
- en: We use a collision-resistant hash function
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi>CRH</mi><mo>:</mo><msup><mfenced close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si1_e](images/S0065245818300676/si1_e.png)  (1)'
  prefs: []
  type: TYPE_IMG
- en: Definition 2\. Pseudorandom functions
  prefs: []
  type: TYPE_NORMAL
- en: We use a pseudorandom function family PRF
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi>PRF</mi><mo>=</mo><msub><mfenced close="}" open="{"><mrow><msub><mi>PRF</mi><mi
    mathvariant="normal">λ</mi></msub><mo>:</mo><msup><mfenced close="}" open="{"
    separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></mrow></mfenced><mi mathvariant="normal">λ</mi></msub></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si2_e](images/S0065245818300676/si2_e_u1.png)  (2)'
  prefs: []
  type: TYPE_IMG
- en: 'where λ denotes the seed. We derive, in arbitrary way, three pseudo random
    functions that are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><msubsup><mi mathvariant="italic">PRF</mi><mi>λ</mi><mi mathvariant="italic">address</mi></msubsup><mfenced
    close=")" open="("><mi>x</mi></mfenced><mo>∶</mo><mo>=</mo><msub><mi mathvariant="italic">PRF</mi><mi>λ</mi></msub><mfenced
    close=")" open="("><mrow><mn>00</mn><mo>∥</mo><mi>x</mi></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si3_e](images/S0065245818300676/si3_e.png)  (3)'
  prefs: []
  type: TYPE_IMG
- en: <math><msubsup><mi mathvariant="italic">PRF</mi><mi>λ</mi><mi mathvariant="italic">apk</mi></msubsup><mfenced
    close=")" open="("><mi>x</mi></mfenced><mo>∶</mo><mo>=</mo><msub><mi mathvariant="italic">PRF</mi><mi>λ</mi></msub><mfenced
    close=")" open="("><mrow><mn>01</mn><mo>∥</mo><mi>x</mi></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si4_e](images/S0065245818300676/si4_e.png)  (4)'
  prefs: []
  type: TYPE_IMG
- en: We assume that PRF[λ]^(Tsn) is also collision-resistant in the sense that it
    is infeasible to find
  prefs: []
  type: TYPE_NORMAL
- en: (λ, x) ≠ (λ′, x′) such that PRF[λ]^(Tsn)(x) = PRF[λ′]^(Tsn)(x′).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 One-time strongly-unforgeable digital signatures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We use a digital signature scheme Sign = <math><mfenced close=")" open="("
    separators=",,,"><mrow><mi mathvariant="script">G</mi><mi mathvariant="italic">en</mi></mrow><mrow><mi
    mathvariant="script">KS</mi><mi>i</mi><mi mathvariant="script">G</mi></mrow><mrow><mi
    mathvariant="italic">sig</mi></mrow><mrow><mi mathvariant="italic">check</mi></mrow></mfenced></math>![si5_e](images/S0065245818300676/si5_e.png)
    that works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-script">G</mi><mi mathvariant="bold-italic">en</mi><mfenced
    close=")" open="("><msup><mn mathvariant="bold">1</mn><mi mathvariant="bold-italic">k</mi></msup></mfenced><mo
    mathvariant="bold-italic">→</mo><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub></math>![si6_e](images/S0065245818300676/si6_e.png).
    Given a security parameter 1^k, <math><mi mathvariant="script">G</mi><mi mathvariant="italic">en</mi></math>![si7_e](images/S0065245818300676/si7_e.png)
    samples public parameters param[sig] for the signature scheme
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-script">KS</mi><mi mathvariant="bold-italic">i</mi><mi
    mathvariant="bold-script">G</mi><mfenced close=")" open="("><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><msub><mi mathvariant="bold-italic">pk</mi><mi
    mathvariant="bold-italic">sig</mi></msub><msub><mi mathvariant="bold-italic">sk</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced></math>![si8_e](images/S0065245818300676/si8_e.png).
    Given public parameters <math><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub><mo>,</mo><mi mathvariant="script">KS</mi><mi>i</mi><mi
    mathvariant="script">G</mi></math>![si9_e](images/S0065245818300676/si9_e.png)
    samples a public key and a secret key for a single user
  prefs: []
  type: TYPE_NORMAL
- en: sig[sk[sig]](m) → σ. Given a secret key sk[sig] and a message m, sig[sk[sig]]
    signs m to obtain a signature σ
  prefs: []
  type: TYPE_NORMAL
- en: check[pk[sig]](m, σ) → b. Given a public key pk[sig], message m, and signature
    σ, check[pk[sig]]outputs
  prefs: []
  type: TYPE_NORMAL
- en: b = 1 if the signature σ is valid for message m; else it outputs b = 0.
  prefs: []
  type: TYPE_NORMAL
- en: The signature scheme Sign satisfies the security property of one-time strong
    unforgeability against chosen-message attacks (SUF-1CMA security).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 Access structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Definition 3\. (Access Structure [57])
  prefs: []
  type: TYPE_NORMAL
- en: Let {P[1],P[2] ,…,P[n]} be a set of parties, a collection <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1], P[2], …, P[n]})is
    monotone if <math><mo>∀</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>:</mo><mi mathvariant="italic">if</mi><mi>B</mi><mo>∈</mo><mi
    mathvariant="script">A</mi></math>![si11_e](images/S0065245818300676/si11_e.png)
    and B ⊆ C then <math><mi>C</mi><mo>∈</mo><mi mathvariant="script">A</mi></math>![si12_e](images/S0065245818300676/si12_e.png).
    An access structure (respectively, monotone access structure) is a collection
    (respectively, monotone collection) <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    of non-empty subsets of {P[1],P[2] ,…, P[n]}, i.e. <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1], P[2], …, P[n]}) ∖ {ϕ},
    the sets in <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    are called the authorized sets, and the sets not in <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    are called the unauthorized sets.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4 Linear secret-sharing schemes (LSSS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our construction, we will use linear secret-sharing schemes (LSSS). Thus,
    we use the definition adapted from ref. [[57]](S0065245818300676.xhtml#bb9005).
  prefs: []
  type: TYPE_NORMAL
- en: Definition 4\. (Linear Secret-Sharing Schemes (LSSS))
  prefs: []
  type: TYPE_NORMAL
- en: 'A secret sharing scheme ∏ over a set of parties P is called linear (over ℤ[p])
    if the following properties can be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) The shares for each party form a vector over ℤ[p].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(2) For ∏, there exists a matrix M with ℓ rows and n columns called the share-generating
    matrix. For i = 1, 2,…, ℓ, the ith row is labeled with a party ρ(i) where ρ: {1,
    2,…, ℓ} → ℤ[p]. To share a secret s ∈ ℤ[p], a vector <math><mover accent="true"><mi>v</mi><mo
    stretchy="true">→</mo></mover></math>![si17_e](images/S0065245818300676/si17_e.png) = (s,
    v2,…, vn) is selected, where v2,…, vn are randomly selected from ℤ[p]. <math><mi>M</mi><mover
    accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si18_e](images/S0065245818300676/si18_e.png)
    is the vector of the ℓ shares according to ∏. The share <math><msub><mi>M</mi><mi>i</mi></msub><mover
    accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si19_e](images/S0065245818300676/si19_e.png)
    belongs to the party ρ(i), where M[i] is the ith row of M.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.3.5 Distributed multi-authority CP-ABE scheme
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our setting we use a distributed multi-authority CP-ABE scheme based on the
    one introduced in [[58]](S0065245818300676.xhtml#bb9010).
  prefs: []
  type: TYPE_NORMAL
- en: Definition 5
  prefs: []
  type: TYPE_NORMAL
- en: 'DCP-ABE scheme comprises four fundamental algorithms as follows: system Setup,
    Authority setup, Encrypt, KeyGen, and Decrypt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syetem Setup (1^k) → (PP): The setup algorithm takes in a security parameter
    1^k. It outputs the public parameters PP.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that there are N Certifying Authorities {CÅ[1], CÅ[2], …, CÅ[N]}, and
    each authority CÅ[i] monitors a set of attributes Ã[i]. Each user U has a unique
    global identifier GID[U] and holds a set of attributes Û.
  prefs: []
  type: TYPE_NORMAL
- en: Authority setup(1^k) → (SK[i], PK[i]). Taking as input the security parameter1^k,
    and it outputs secret key and public key pair (SK[i]; PK[i]) for each authority
    Ã, where KeyGen(1^k) → (SK[i], PK[i]).
  prefs: []
  type: TYPE_NORMAL
- en: '<math><mi mathvariant="bold-italic">Encrypt</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="italic">PP</mi><mi mathvariant="script">M</mi><msub><mfenced
    close=")" open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></math>![si20_e](images/S0065245818300676/si20_e.png).
    It takes as inputs: the public parameters PP, the plaintext message<math><mi mathvariant="script">M</mi></math>![si21_e](images/S0065245818300676/si21_e.png),
    a set of access structures (Mi, ρi)i ∈ I and a set of public keys (PKi) ∈ I It
    outputs the cipher-text CT.'
  prefs: []
  type: TYPE_NORMAL
- en: keyGen (GID; PP; Û∩ Ã; SK[i]) → idKey[GID,i] Taking as input the public parameter
    PP, the secret keySK[i], the requester's global identifier GID[U] and a set of
    attributes Û∩ Ã, the IDkeyGen generation algorithm outputs an idKey[GID,i].
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt(PP, (idKey[GID,i])[i ∈ I], CT) → M. The decrypt algorithm takes as input
    the public parameter PP, the cipher-text CT and the secret keys idKey[GID,i].
    If the set of attributes satisfies the access structure A then the algorithm will
    decrypt the cipher-text and return a message m else it returns ⊥.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 6
  prefs: []
  type: TYPE_NORMAL
- en: The decentralized cipher text-policy attribute-based encryption (DCP-ABE) is
    correct if
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="|" open="|"><mtable><mtr><mtd><mi
    mathvariant="italic">Decrypt</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">PP</mi><msub><mfenced close=")" open="("><msub><mi mathvariant="italic">idKey</mi><mrow><mi
    mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi
    mathvariant="italic">CT</mi></mfenced></mtd></mtr><mtr><mtd><mo>→</mo><mi>M</mi></mtd></mtr></mtable></mfenced><mfenced
    close="|" open=""><mtable><mtr><mtd><mi mathvariant="italic">Syetem</mi><mi mathvariant="italic">Setup</mi><mfenced
    close=")" open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced
    close=")" open="("><mi mathvariant="italic">PP</mi></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">Authority</mi><mi mathvariant="italic">setup</mi><mfenced
    close=")" open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced
    close=")" open="(" separators=","><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">Encrypt</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">PP</mi><mi mathvariant="script">M</mi><msub><mfenced close=")"
    open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></mtd></mtr></mtable></mfenced><mo>=</mo><mn>1</mn></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si22_e](images/S0065245818300676/si22_e.png)'
  prefs: []
  type: TYPE_IMG
- en: where the probability is token over the random bits used by all the algorithms
    in the scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 7\. (Selective-Access Structure Secure DCPABE (IND-sAS-CPA))
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized cipher text-policy attribute-based encryption (DCP-ABE) scheme
    is (T, q, ϵ(k)) secure in the selective-access structure model if no probably
    polynomial-time adversary A. Making q secret key queries can win the above game
    with the advantage
  prefs: []
  type: TYPE_NORMAL
- en: <math><msubsup><mi mathvariant="italic">Adv</mi><mi>A</mi><mrow><mi mathvariant="italic">ACP</mi><mo>−</mo><mi
    mathvariant="italic">ABE</mi></mrow></msubsup><mo>=</mo><mfenced close="|" open="|"><mrow><mi
    mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><msup><mi>b</mi><mo>′</mo></msup><mo>=</mo><mi>b</mi></mrow></mfenced><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mfenced><mo>></mo><mi>ϵ</mi><mfenced
    close=")" open="("><mi>k</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si23_e](images/S0065245818300676/si23_e.png)'
  prefs: []
  type: TYPE_IMG
- en: where the probability is token over all the bits consumed by the challenger
    and the adversary.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.6 zk-SNARKs protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Definition 8
  prefs: []
  type: TYPE_NORMAL
- en: We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer
    the reader to, e.g., ref. [[56](S0065245818300676.xhtml#bb9000)] for a formal
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a field <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    an <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit takes inputs that are elements in <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    and its gates output elements in <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png).
    We naturally associate a circuit with the function it computes. To model non-determinism
    we consider circuits that have an input x ∈ F^n and an auxiliary input a <math><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup></math>![si28_e](images/S0065245818300676/si28_e.png),
    called a witness. The circuits we consider only have bilinear gates. Arithmetic
    circuit satisfiability is defined analogously to the boolean case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition 9
  prefs: []
  type: TYPE_NORMAL
- en: 'The arithmetic circuit satisfiability problem of an <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'C: <math><msup><mi mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo></math>![si30_e](images/S0065245818300676/si30_e.png) <math><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mo>→</mo><msup><mi mathvariant="double-struck">F</mi><mi>l</mi></msup></math>![si31_e](images/S0065245818300676/si31_e.png)
    is captured by the relation <math><msub><mi mathvariant="normal">ℝ</mi><mi>C</mi></msub><mo>=</mo><mfenced
    close="}" open="{"><mrow><mfenced close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo><msup><mi mathvariant="double-struck">F</mi><mi>p</mi></msup><mi>C</mi><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced><mo>;</mo><mi
    mathvariant="italic">its</mi><mi mathvariant="italic">language</mi><mi mathvariant="italic">is</mi><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub><mo>=</mo><mfenced close="}" open="{"><mrow><mi>x</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>:</mo><mo>∃</mo><mi>a</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mi mathvariant="italic">such</mi><mi
    mathvariant="italic">that</mi><mi>C</mi><mfenced close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced></math>![si32_e](images/S0065245818300676/si32_e.png)![si999_e](images/S0065245818300676/si999_e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Given a field <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    a (publicly-verifiable preprocessing)
  prefs: []
  type: TYPE_NORMAL
- en: 'zk-SNARK for <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit satisfiability is a triple of polynomial-time algorithms (KeyGen; Prove;
    Verify):'
  prefs: []
  type: TYPE_NORMAL
- en: keyGen(1^k, C) → (pk, vk) Takes as Input a security parameter k and an <math><mi
    mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit C, the key generator keyGen probabilistically samples a proving key pk
    and a verification key vk. Both keys are published as public parameters and can
    be used, any number of times, to prove/verify membership in <math><msub><mi mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png).
  prefs: []
  type: TYPE_NORMAL
- en: Prove(pk, x, a) → π Takes on input a proving key pk and any (x, a) ∈ ℝ[C], the
    prover Prove outputs a non-interactive proof π for the statement x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png)
  prefs: []
  type: TYPE_NORMAL
- en: Verify( vk, x, π) → b Takes on input a verification key vk, an input x, and
    a proof π, the verifier Verify outputs b = 1 if he is convinced that x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'A zk-SNARK satisfies the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Completeness. For every security parameter k, any <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit C, and any (x, a) ∈ ℝ[C], the honest prover can convince the verifier.
    Namely, b = 1 with probability 1 − negl (k) in the following experiment: (pk, vk) ← keyGen(1^k, C),
    π ← Prove(pk, x, a), b ← Verify( vk, x, π)'
  prefs: []
  type: TYPE_NORMAL
- en: Succinctness. An honestly-generated proof π has <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub><mfenced
    close=")" open="("><mn>1</mn></mfenced></math>![si40_e](images/S0065245818300676/si40_e.png)
    bit and Verify(vk, x, π) runs in time <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub><mfenced
    close=")" open="(" separators="||"><mi>x</mi></mfenced></math>![si41_e](images/S0065245818300676/si41_e.png).
    (Here, <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub></math>![si42_e](images/S0065245818300676/si42_e.png)
    hides a fixed polynomial factor in k.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof of knowledge (and soundness). If the verifier accepts a proof output
    by a bounded prover, then the prover “knows” a witness for the given instance.
    (In particular, soundness holds against bounded provers.) Namely, for every poly(k)-size
    adversary<math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png),
    there is a poly(k)-size extractor <math><mi mathvariant="script">E</mi></math>![si44_e](images/S0065245818300676/si44_e.png)
    such that Verify( vk, x, π) = 1 and (x, a) ∈ ℝ[C] with probability negl (k) in
    the following experiment: (pk, vk) ← keyGen(1^k, C); <math><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>π</mi></mfenced><mo>←</mo><mi mathvariant="script">A</mi><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></math>![si45_e](images/S0065245818300676/si45_e.png);
    <math><mi>a</mi><mo>←</mo><mi mathvariant="script">E</mi><mfenced close=")" open="("
    separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></math>![si46_e](images/S0065245818300676/si46_e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect zero knowledge. An honestly-generated proof is perfect zero knowledge.
    Namely, there is a poly(k)-size simulator <math><mi mathvariant="script">S</mi><mi
    mathvariant="italic">im</mi></math>![si47_e](images/S0065245818300676/si47_e.png)
    such that for all stateful poly(k)-size distinguishers <math><mi mathvariant="script">D</mi></math>![si48_e](images/S0065245818300676/si48_e.png)
    the following two probabilities are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. The probability that <math><mi mathvariant="script">D</mi><mfenced close=")"
    open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png)= 1
    on an honest proof.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced><mo
    mathvariant="bold">←</mo><mi mathvariant="bold-italic">keyGen</mi><mfenced close=")"
    open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi mathvariant="script">D</mi><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Prove</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi>a</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si50_e](images/S0065245818300676/si50_e.png)'
  prefs: []
  type: TYPE_IMG
- en: 2. The probability that <math><mi mathvariant="script">D</mi><mfenced close=")"
    open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png) = 1
    on a simulated proof.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=",,"><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi><mi
    mathvariant="italic">trap</mi></mfenced><mo mathvariant="bold">←</mo><mi mathvariant="bold-italic">Sim</mi><mfenced
    close=")" open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi
    mathvariant="script">D</mi><mfenced close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi
    mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Sim</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi mathvariant="italic">trap</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si52_e](images/S0065245818300676/si52_e.png)'
  prefs: []
  type: TYPE_IMG
- en: 5.4 Formal definition of privacy-preserving distributed access control scheme
    (PPDAC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We begin by describing, and giving intuition about, the data structures used
    by a PPDAC scheme, the algorithms that use and let the details of the construction
    of each one in [Section 5.5](S0065245818300676.xhtml#s0135).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Data structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Public Parameters (PP): A list of public parameters PP is available to all
    users in the system. These are generated by a trusted party at the “launch time”
    of the system and are used by the system''s algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Addresses: As in FairAccess, each user in the system generates as many addresses
    as he wants. Each address corresponds to a pair of key (a[pk]; a[sk]). The public
    key a[pk] is published and enables others to interact with user. The secret key
    a[sk] is used to spend the authorization token owned by user who possesses the
    a[pk].'
  prefs: []
  type: TYPE_NORMAL
- en: 'IDkey: is a vector of idKey[GID,i] as IDkey = (idKey[GID,i])[i ∈ N]'
  prefs: []
  type: TYPE_NORMAL
- en: Where idKey[GID,i] is a private key delivered by a certifying authority CÅ[i]
    monitoring a set of attribute Û ∩ Ã[i] and GID. Where GID corresponds to the notion
    of global identifiers introduced by chaise in [[59]](S0065245818300676.xhtml#bb9015)
    to link private keys together that were issued to the same user by different authorities.
  prefs: []
  type: TYPE_NORMAL
- en: The requester gets an IDkey by running an IDkeygen algorithm with the certifying
    authorities. Then it is recorded in the blockchain by its owners as a public value
    when minting an IDcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDcoin: For each IDkey, we associate an IDcoin. An IDcoin is a data object
    idc, to which we associate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '• An IDcoin commitment, denoted cm (idc): a string that appears on the ledger
    once idc is minted by the requester.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• An IDcoin serial number, denoted sn (idc): a unique string associated with
    the idc, used to prevent double spending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• An IDcoin address, denoted a[pk] (idc): an address public key, representing
    who owns idc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authorization token TKN: is a data structure constructed as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">TKN</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mtext>SmartContract
    address</mtext><mo stretchy="true">‖</mo><mi>cm</mi></mrow></mfenced><mo>.</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si53_e](images/S0065245818300676/si53_e.png)'
  prefs: []
  type: TYPE_IMG
- en: It is added in the TKNList by the SmartContract in a simultaneous way as the
    commitment of IDcoin appears in IDCMlist.
  prefs: []
  type: TYPE_NORMAL
- en: Commitments of minted IDcoins and serial numbers of spent IDcoins. For any given
    time T,
  prefs: []
  type: TYPE_NORMAL
- en: IDCMList[T] denotes the list of all IDcoin commitments appearing in Request
    Access RqTx and GetAccess GtATx recorded in the blockchain at time T.
  prefs: []
  type: TYPE_NORMAL
- en: TKNList[T] denotes the list of all authorization tokens appearing in GetAccess
    GtATx transaction recorded in the blockchain at time T.
  prefs: []
  type: TYPE_NORMAL
- en: SNListT[T] denotes the list of all serial numbers appearing in GetAccess transaction
    in the ledger at time T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Merkle tree over commitments IDcoin: For any given time T, IDCTree[T] denotes
    a Merkle tree over IDCMList[T] and rt[T] its root. Moreover, the function Path[T]
    (idcm) gives the authentication path from a IDcoin commitment idcm appearing in
    IDCMList[T] to the root of Tree[T]. For convenience, we assume that the ledger
    at time T L[T] also stores rt[T ∗] for all T* < T (i.e., it stores all past Merkle
    tree roots).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Merkle tree over authorization token: For any given time T, AUTree[T] denotes
    a Merkle tree over TKNList[T] and rt ∗[T] its root. Moreover, the function Path ∗[T]
    (idcm) gives the authentication path from a authorization token TKN appearing
    in TKNList[T] to the root of TKNTree[T]. For convenience, we assume that the ledger
    at time T L[T] also stores rt ∗[T ∗] for all T* < T (i.e., it stores all past
    Merkle tree roots).'
  prefs: []
  type: TYPE_NORMAL
- en: 'SmartContract: is a program running in the blockchain that stores two values:
    (1) a Cipher text CT. (2) its corresponding challenge CH which is a random number
    linked to CT as: CT ≔ Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]). The SmartContract
    embedded three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: (i) Decrypt(PP,IDkey,CT) → M
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (ii) A boolean function IsEqual(M, CH)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (iii) AddToTKNList(TKN)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'New transactions: We use three new types of transactions in our framework that
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '(1) GrantAccess transaction: it serves to deploy the SmartContract in the blockchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">GrATx</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mi
    mathvariant="italic">SmartContract</mi><mi mathvariant="italic">SC</mi></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si54_e](images/S0065245818300676/si54_e.png)'
  prefs: []
  type: TYPE_IMG
- en: '(2) RequestAccess transaction: triggers the SmartContract and mint IDcoin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">RqTx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">IDkey</mi><mi>k</mi><mi>s</mi><mi mathvariant="italic">cm</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si55_e](images/S0065245818300676/si55_e.png)'
  prefs: []
  type: TYPE_IMG
- en: '(3) GetAccess transaction: pour the RequestAccess IDcoin and holds the authorization
    token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">GtATx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">rt</mi><mi mathvariant="italic">sn</mi><mi
    mathvariant="italic">cm</mi><mi>π</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si56_e](images/S0065245818300676/si56_e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Blockchain: Our protocol is applied on top of a public permissionless ledger
    such as Ethereum. At any given time T, all users have access to the ledger at
    time T, which is a sequence of transactions. The ledger is append-only.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Algorithms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will next describe functions that are needed in our system. The protocols
    that implement these functions will be described in the later section. Most, if
    not all, of these functions will be performed with respect to a given blockchain
    B, or need to make calls to the public parameters in our system. These are implicit
    inputs of the protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'A (PPDAC) scheme Π is a tuple of polynomial-time algorithms: (SystemSetup,
    Authority Setup, IDkeyGen, encrypt, decrypt, CreateAddress, GrantAccess, RequestAccess,
    GetAccess, ValidateTransaction, executeSmartContract, AllowAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: 'System Setup: (1^k) → PP. Taking as input a security parameter 1^k, the global
    setup algorithm outputs the public parameter PP.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm Setup is executed by a trusted party. The resulting public parameters
    PP are published and made available to all parties (e.g., by embedding them into
    the protocol's implementation). The setup is done only once. Afterward, no trusted
    party is needed, and no global secrets or trapdoors are kept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authority Setup: KG(1^k) → (SK[i], PK[i]). Each authority in the system runs
    the authority setup algorithm with the security parameter 1^k, as input to produce
    its own secret key and public key pair (SK[i]; PK[i]).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT. It takes as inputs: the public
    parameters PP, a random plaintext string CH, a set of access structures (Mi, ρi)[i ∈ I]
    and a set of public keys (PKi)[i ∈ I]. It outputs the cipher-text CT associated
    with this set of access structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ExecuteSmartContract (RqT[x], SmartContract SC) → True or ⊥ . It takes as input
    the RequestAccess transaction. It returns true or false. This algorithm recalls
    tree sub-algorithms that are: (Decrypt, IsEqual, AddtoTKNList) defined as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypt(PP, IDkey, CT) → M.Taking as input the public parameter PP, the cipher-text
    CT and IDkey from the RequestAccess transaction triggering the SmartContract.
    Where a Request Access transaction RqTx is as follow: RqTx ≔ (IDkey, k, s, cm)'
  prefs: []
  type: TYPE_NORMAL
- en: 'IsEqual(M, CH). A Boolean function that compares the resulting message M and
    the recorded challenge CH as follow: If the Requester''s attribute, associated
    to IDkey, satisfies the set of access structures (Mi, ρi)i ∈ I, then M will be
    equal to CH and the function returns true, else the function returns false ⊥.'
  prefs: []
  type: TYPE_NORMAL
- en: AddtoTKNList(idcm) → (rt, path(idcm)). It takes as input the IDcoin commitment
    and returns its authentication path in the Merkle tree having as root rt.
  prefs: []
  type: TYPE_NORMAL
- en: 'CreateAddress(PP) ⟶ (a[pk]; a[sk]). The algorithm generates a new pseudonym
    address keypair: (a[pk]; a[sk]). Each user generates at least one address key
    pair in order to receive authorization tokens. The public key a[pk] is published,
    while the secret key a[sk] is used to redeem tokens sent to a[pk]. A user may
    generate any number of address key pairs; doing so does not require any interaction'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">GrantAccess</mi><mfenced close=")" open="("><mi
    mathvariant="bold-italic">CH</mi><mi>,</mi><mrow><mfenced close=")" open="("><mi
    mathvariant="bold-italic">PKi</mi></mfenced><mo mathvariant="bold-italic">∈</mo><mi
    mathvariant="bold-italic">I</mi></mrow><mrow><mfenced close=")" open="(" separators=","><mi
    mathvariant="bold-italic">Mi</mi><mi mathvariant="bold-italic">ρi</mi></mfenced><mi
    mathvariant="bold-italic">i</mi><mo mathvariant="bold-italic">∈</mo><mi mathvariant="bold-italic">I</mi></mrow></mfenced><mo
    mathvariant="bold-italic">→</mo><mi mathvariant="bold-italic">GrATx</mi><mo mathvariant="bold-italic">≔</mo><mfenced
    close=")" open="("><mrow><mi mathvariant="bold-italic">SmartContract</mi><mi mathvariant="bold-italic">SC</mi></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si57_e](images/S0065245818300676/si57_e.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm GrantAccess gives as output a GrantAccess Transaction holding
    hidden RO access control policies, in form of SmartContract and managing access
    control for each device.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes as inputs: implicitly the public parameters PP, the plaintext CH,
    a set of access structures(Mi, ρi)i ∈ I, and set of public keys(PKi) ∈ I for relevant
    authorities.'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">IDkeyGen</mi><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="bold-italic">GID</mi><mi mathvariant="bold-italic">PP</mi><mrow><mi
    mathvariant="bold">Û</mi><mo mathvariant="bold-italic">∩</mo><mi mathvariant="bold">Ã</mi></mrow><msub><mi
    mathvariant="bold-italic">SK</mi><mi mathvariant="bold-italic">i</mi></msub></mfenced><mo
    mathvariant="bold-italic">→</mo><msub><mi mathvariant="bold-italic">idKey</mi><mrow><mi
    mathvariant="bold-italic">GID</mi><mo mathvariant="bold-italic">,</mo><mi mathvariant="bold-italic">i</mi></mrow></msub><mi
    mathvariant="bold-italic">and IDkey</mi><mo mathvariant="bold-italic">=</mo><msub><mfenced
    close=")" open="("><msub><mi mathvariant="bold-italic">idKey</mi><mrow><mi mathvariant="bold-italic">GID</mi><mo
    mathvariant="bold-italic">,</mo><mi mathvariant="bold-italic">i</mi></mrow></msub></mfenced><mrow><mi
    mathvariant="bold-italic">i</mi><mo mathvariant="bold-italic">∈</mo><mi mathvariant="bold-italic">N</mi></mrow></msub></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si58_e](images/S0065245818300676/si58_e.png)'
  prefs: []
  type: TYPE_IMG
- en: A requester and an authority engage in the IDkeyGen algorithm that takes as
    input the public parameter PP, the secret keySK[i], the requester's global identifier
    GID[U] and a set of attributes Û ∩ Ã. It produces an IDkey for Rq.
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">RequestAccess</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="bold-italic">PP</mi><msub><mi mathvariant="bold-italic">GID</mi><mi
    mathvariant="bold-italic">U</mi></msub><mrow><msub><mi mathvariant="bold-italic">a</mi><mi
    mathvariant="bold-italic">pk</mi></msub></mrow></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><mi mathvariant="bold-italic">IDcoin</mi><mrow><mi
    mathvariant="bold-italic">RqTx</mi><mo mathvariant="bold-italic">≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="bold-italic">IDkey</mi><mi
    mathvariant="bold-italic">k</mi><mi mathvariant="bold-italic">s</mi><mi mathvariant="bold-italic">cm</mi></mfenced></mrow></mfenced><mo
    mathvariant="bold-italic">.</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si59_e](images/S0065245818300676/si59_e.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm RequestAccess takes as inputs the public parameters PP, the requester's
    global identifier GID[U], and the public address of the requester a[pk] in which
    he wants to receive an authorization token. The algorithm outputs an IDcoin and
    a RequestAccess transaction RqTx
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">GetAccess</mi><mfenced close=")" open="("
    separators=",,,,"><mi mathvariant="italic">PP</mi><mi mathvariant="italic">rt</mi><mi
    mathvariant="italic">idcoin</mi><mrow><mi mathvariant="italic">path</mi><mfenced
    close=")" open="("><mi mathvariant="italic">idcm</mi></mfenced></mrow><msub><mi>a</mi><mi
    mathvariant="italic">sk</mi></msub></mfenced><mo>→</mo><mi mathvariant="italic">GtATx</mi><mo>≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="italic">rt</mi><mi mathvariant="italic">sn</mi><mi
    mathvariant="italic">cm</mi><mi>π</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si60_e](images/S0065245818300676/si60_e.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm GetAccess takes as inputs an IDcoin with its corresponding secret
    key a[sk] (required to redeem idcoin). To ensure that IDcoin have not been previously
    minted, the GetAccess algorithm also takes as input the Merkle root rt with the
    authentication paths path form Idcm. It outputs a GetAccess transaction GtATx
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold">ValidateTransaction</mi><mfenced close=")" open="("
    separators=",,"><mrow><mi mathvariant="bold">GrantAccess</mi><mi mathvariant="bold-italic">GrATx</mi></mrow><mrow><mi
    mathvariant="bold">RequestAccess</mi><mi mathvariant="bold-italic">RqTx</mi></mrow><mrow><mi
    mathvariant="bold">GetAccess</mi><mi mathvariant="bold">transaction</mi><mi mathvariant="bold-italic">GtATx</mi></mrow></mfenced><mo
    mathvariant="bold-italic">→</mo><mfenced close=")" open="(" separators=","><mi
    mathvariant="bold-italic">true</mi><mi mathvariant="bold-italic">false</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si61_e](images/S0065245818300676/si61_e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The algorithm ValidateTransaction checks the validity of a transaction: All
    transactions must be verified before being considered well-formed. In practice,
    transactions can be verified by nodes in the distributed system maintaining the
    ledger, as well as by users who rely on these transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold">AllowAccess</mi><mfenced close=")" open="(" separators=","><mrow><mi
    mathvariant="bold">GrantAccess</mi><mi mathvariant="bold">Transaction</mi><mi
    mathvariant="bold-italic">GrATx</mi></mrow><mi mathvariant="bold-italic">SNlist</mi></mfenced><mo
    mathvariant="bold">→</mo><mfenced close=")" open="(" separators=","><mi mathvariant="bold-italic">true</mi><mi
    mathvariant="bold-italic">false</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si62_e](images/S0065245818300676/si62_e.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm AllowAccess takes as input GrantAccess transaction and SNList
    from the current ledger, if the IDCoin spent by this GrantAccess transaction appears
    in SNlist then access is allowed, else no.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 PPDAC construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Phase 1: Setting up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System Setup: (1^k) → PP. Taking as input a security parameter 1^k, the global
    setup algorithm outputs the public parameter PP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authority setup: Suppose that there are N Certifying Authorities {CÅ[1], CÅ[2], …, CÅ[N]},
    and each authority CÅ[i] monitors a set of attributes Ã[i]. Each user U has a
    unique global identifier GID[U] and holds a set of attributes Û. Each authority
    in the system runs the authority setup algorithm with the security parameter 1^k
    as input to produce its own secret key and public key pair (SK[i]; PK[i]) as follow:
    KG(1^k) → (SK[i], PK[i]).'
  prefs: []
  type: TYPE_NORMAL
- en: 'NB: It is worth to note that this phase is conducted outside the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 2: The GrantAccess phase consists in defining access control policies
    over devices and hiding them inside SmartContracts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource owner is responsible for defining access policy and obfuscating
    the policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each device, the RO acts as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '1. He generates a random number that we call a challenges: CH'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2. He defines an Access structure (Mi, ρi)i ∈ I
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3. He employs the distributed DCP-ABE scheme to encrypt challenge CH under
    the corresponding access structure Mi, ρi and gets cipher texts CT through the
    following function: Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It takes as inputs: the public parameters PP, the plaintext message CH, a set
    of access structures (Mi, ρi)i ∈ I and a set of public keys (PKi) ∈ I. It outputs
    the cipher-text CT associated with this set of access structures.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4. He defines a SmartContract that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. stores two values: (1) a Cipher text CT, (2) and its corresponding CH'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b. embeds three functions:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: (1) Decrypt(PP, IDkey, CT) → M.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Taking as input the public parameter PP, the cipher-text and IDkey from the
    RequestAccess transaction triggering the SmartContract. Where a Request Access
    transaction RqTx is as follow: RqTx ≔ (IDkey, k, s, cm), the details of this transaction
    will be elaborated in the next phase.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '(2) A Boolean function that compares the resulting message M and the recorded
    challenge CH as follow: IsEqual(M, CH)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Requester's attribute, associated to IDkey, satisfies the set of access
    structures (Mi, ρi)i ∈ I, then M will be equal to CH, else the function returns
    false ⊥.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (3) If the output of compare function is true, then the SmartContract adds idcm
    associated to IDkey in RqTx transaction to Authorization token list TKNList.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '5. Then the RO deploys the defined SmartContract in the blockchain through
    a GrantAccess transaction: GrATx:= (SmartContract SC)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, to prevent SmartContract and transaction malleability we use a digital
    signature. This digital signature plays the role of “MACS” to tie a SmartContract
    to the RO and his devices. The Ro samples a key pair(pk[sig], sk[sig]), and computes
    σ = sig[sk[sig]](SC). Then, sets
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">GrATx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=",,"><mrow><mi mathvariant="italic">SmartContract</mi><mi mathvariant="italic">SC</mi></mrow><msub><mi
    mathvariant="italic">pk</mi><mi mathvariant="italic">sig</mi></msub><mi>σ</mi></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si63_e](images/S0065245818300676/si63_e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Phase 3: The RequestAccess phase consists in successfully executing the SmartContract
    to get an access token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This phase is divided into two sub-phases as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Requester (RQ)—Authority Interaction. In this sub-phase, the Rq interacts with
    the certifying authorities (CÅ[i])[i ∈ I] and runs the IDkey extraction algorithms
    as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">IDkey</mi><mi>Gen</mi><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">GID</mi><mi mathvariant="italic">PP</mi><mrow><mi>Û</mi><mo>∩</mo><mi
    mathvariant="normal">Ã</mi></mrow><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub></mfenced><mo>→</mo><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub><mtext>and</mtext><mi
    mathvariant="italic">IDkey</mi><mo>=</mo><msub><mfenced close=")" open="("><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>N</mi></mrow></msub></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![si64_e](images/S0065245818300676/si64_e.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking as input the public parameter PP, the secret keySK[i], the requester's
    global identifier GID[U] and a set of attributes Û∩ Ã, the IDkeyGen generation
    algorithm outputs an IDkey for Rq. We assume that the communication between the
    RQ and the authorities is secured and private. This phase is running outside the
    blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requester-SmartContract Interaction. After getting the address of the SmartContract
    managing access to the target device, the requester triggers the SmartContract
    with a Request Access transaction RqTx to correctly decrypt the challenge and
    get an authorization token. As mentioned, in the beginning of this section, in
    our setting, we do not use private keys as in traditional CP-ABE schemes, but
    instead we are using identity keys: IDKey imbedded inside an IDcoin. In order
    to release the intractability property of IDKey, we make use of zk-SNARKs (described
    above) and a commitment scheme as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Let COMM denotes a statistically-hiding non-interactive commitment scheme (i.e.,
    given randomness r and message m, the commitment is c ∶ = COMM[r](m) subsequently,
    c is opened by revealing r and m, and one can verify that COMM[r](m)equals c).
  prefs: []
  type: TYPE_NORMAL
- en: 'The requester mint IDcoins holding the IDKey to the ledger through a RequestAccess
    RqTx transaction. Unlike traditional CP-ABE schemes, where private keys are used
    to decrypt the cipher text and they are kept secret to their owner in order to
    be used only by him, in our setting we provide the same property of restricting
    the use of the IDKey to his owner even if it is public. To do so, we derive the
    IDcoins associated to IDkey in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: We use three pseudorandom functions (derived from a single one). For a seed
    x these are denoted PRF[x]^(address). We assume that PRF[x]^(address) is moreover
    collision-resistant.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide targets for IDcoins, we use addresses: each user u generates an
    address key pair (a[pk];a[sk]). The IDcoins tied to IDkey contains the value a[pk]
    and can be spent only with knowledge of a[sk]. In this way, the usage of IDkey
    is controlled by his owner who possesses the a[sk]. A key pair (a[pk]; a[sk])
    is sampled by selecting a random seed a[sk] and setting a[pk]: = PRF[ask]^(address)(0).
    A user can generate and use any number of address key pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: To “tie” an IDcoin to a specified IDkey, the requester Rq first samples ρ which
    is a secret value and computes ρ′ = PRF[ask]^(IDkey)(ρ) then determines the ID
    coin's serial number sn as sn:= PRF[ask]^(sn)( ρ′).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the requester commits to the tuple (a[pk]:IDkey;ρ′) in two phases: (a)
    u computes k ∶ = COMM[r](a[pk] ∥ ρ′) for a random r; and then (b) the requester
    computes cm ∶ = COMM[s](IDkey ∥ k) for a random s. The minting results in an IDcoin
    idc:= (a[pk]; IDkey; ρ; r; s; cm) and a RequestAccess transaction RqTx:= (IDkey;
    k; s; cm).'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, due to the interlinked commitment, anyone can verify that cm in
    RequestAccess transaction is a coin commitment of an IDcoin of IDkey (by checking
    that COMM[S]( IDkey ∥ k) equals cm) but cannot discern the owner (by learning
    the address key a[pk]) or serial number (derived from ρ′) because these are hidden
    in k. In this way the anonymity and untraceability of the IDkey is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: The RequestAccess transaction is accepted by the ledger only if the requester
    presents the correct IDkey that matches the hidden access control policy by decrypting
    the cipher text Decrypt(PP, IDkey, CT) → M and in one hand.in the other hand,
    if the commitment is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this phase, the IDcoin commitment and respectively a corresponding authorization
    token signed with the SmartContract are recorded in the blockchain in two lists:
    an IDcoin commitment list IDcList and respectively an authorization token list
    TKNList.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The authorization token is an IDcoin commitment signed with the address of
    a SmartContract that added the IDcoin to the ledger. Subsequently, letting IDcoinList
    denotes the list of all IDcoin commitments on the ledger and respectively the
    TKNList denotes all the authorization token on the ledger. The requester may spend
    the authorization token by posting a GetAccess transaction that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: (i) An ID coin's serial number sn, the address of the SmartContract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (ii) A zk-SNARK proof π of the NP statement “I know r such that COMM[r](sn)
    appears in the list IDcoinList of IDcoin commitments.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (iii) An IDcoin commitment idcm with the address of the SmartContract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TKN: = (SmartContract address || idcm) appears in TKNList'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that sn does not already appear on the ledger (as part of a past spend
    transaction), the requester can redeem the authorization token. (If sn does already
    appear on the ledger, this is considered double spending, and the transaction
    is discarded.) Furthermore, the end device will be able to verify that this authorization
    token was delivered by his corresponding SmartContract by checking the SmartContract
    address. The Requester anonymity is achieved because the proof π is zero knowledge,
    while sn is revealed, no information about r is, and finding which of the numerous
    commitments in TKNList corresponds to a particular GetAccess transaction is equivalent
    to inverting f(x): = COMM[x](sn), which is assumed to be infeasible. Thus, the
    origin of the transactions is anonymous ([Fig. 15](S0065245818300676.xhtml#f0075)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 4: Getting access and spending the authorization token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Fig. 15](images/S0065245818300676/f08-14-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 15 Generation of IDcoins and authorization tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get access to the protected device, the requester spends the authorization
    token using a GetAccess transaction as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a requester, with address key pair (a[pk]; a[sk]), wishes to consume
    his IDcoin:= (a[pk]; IDkey; ρ; ρ′, r; s; cm), the requester produces a zk-SNARK
    proof π for the following NP statement, which we call GetAccess:'
  prefs: []
  type: TYPE_NORMAL
- en: '“Given the Merkle-tree root rt, serial number sn, and IDcoin commitments cm,
    I know IDcoin and address secret key a[sk] such that: i) the IDcoin is well formed,
    for IDcoin it holds that: k ∶ = COMM[r](a[pk] ∥ ρ′) and cm ∶ = COMM[s](IDkey ∥ k).ii)
    The address secret key matches the public key: a[pk] = PRF[ask]^(address)(0).
    iii) the IDcoin is correctly tied to Ideky: ρ′ = PRF[ask]^(IDkey)(ρ). iv) The
    serial number is computed correctly: sn:= PRF[ask]^(sn)( ρ′). v) The coin commitment
    cm appears as a leaf of a Merkle- tree with root rt.”'
  prefs: []
  type: TYPE_NORMAL
- en: A resulting GetAccess transaction gets GtATx the form GtATx:= (rt; sn; cm; π)
    is appended to the ledger and it is rejected if the serial number sn appears in
    a previous transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, if the requester does not know the address secret key a[sk] that
    is associated with the public key a[pk]. Then, the requester cannot spend the
    authorization token neither uses the IDkey because he cannot provide a new a[sk]
    as part of the witness of a subsequent GetAccess transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to prevent transaction malleability, and tie each IDkey to its
    owner, we use digital signature. The Requester samples a key pair(pk[sig], sk[sig]),
    set <math><mi>m</mi><mo>=</mo><mfenced close=")" open="(" separators=","><mover
    accent="true"><mi>u</mi><mo stretchy="true">→</mo></mover><msub><mi>π</mi><mi
    mathvariant="italic">grant</mi></msub></mfenced><mo>,</mo></math>![si65_e](images/S0065245818300676/si65_e.png)
    Compute σ = sig[sk[sig]](m). Then, Set GtATx ≔ (rt; sn; cm; IDkey, π, pk[sig], σ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 5: The AllowAccess phase consists in checking the validity of the token
    by end-device and decide either allow or deny access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the requester presents the authorization token to the end device, this
    later verifies that the authorization token that exists in the TKNList was added
    by the end device's SmartContract. If yes the access is allowed else no.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compressing the authorization token list for lightweight verification: In the
    above NP statement, IDCMList is specified explicitly as a list of IDcoin commitment.
    This straightforward representation severely limits scalability because the time
    and space complexity of most protocol algorithms (e.g., the proof verification
    algorithm) grows linearly with IDCMList. Furthermore, authorization token corresponding
    to already spent IDcoins cannot be dropped from IDCMList to reduce costs, since
    they cannot be identified (due to the same zero-knowledge property that provides
    anonymity). As in [[60]](S0065245818300676.xhtml#bb9020), we rely on a collision-resistant
    hash function CRH to avoid an explicit representation of IDCMList. We maintain
    an efficiently updatable append-only CRH-based Merkle tree Tree(IDCMList) over
    the (growing) list IDCMList. Letting rt denote the root of Tree(IDCMList), it
    is well-known that updating rt to account for insertion of new leaves can be done
    with time and space proportional to the tree depth. Hence, the time and space
    complexity is reduced from linear in the size of IDCMList to logarithmic. With
    this in mind, we modify the NP statement to the following one: “I know r such
    that COMM[r](sn) appears as a leaf in a CRH-based Merkle tree whose root is rt.”
    Compared with the naive data structure for IDCMList, this modification increases
    exponentially the size of IDCMList which a given zk-SNARK implementation can support.
    We do the same things with the authorization token List TKNList (see [Fig. 16](S0065245818300676.xhtml#f0080)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 16](images/S0065245818300676/f08-15-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 16 CRH-based tree over Authorization token (tkn).
  prefs: []
  type: TYPE_NORMAL
- en: This ends the outline of the construction. We conclude by noting that, due to
    the zk-SNARK, our construction requires a one-time trusted setup of public parameters.
    The trust affects soundness of the proofs, though anonymity continues to hold
    even if the setup is corrupted by a malicious party.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms Constructions: We describe the construction of the PPDAP scheme = (SystemSetup;
    AuthoritySetup, CreateAddress, GrantAccess, RequestAccess, GetAccess, VerifyTransaction;
    AllowAccess) in [Figs. 17](S0065245818300676.xhtml#f0090) and [18](S0065245818300676.xhtml#f0095).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 17](images/S0065245818300676/f08-17-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 17 PPDAC Privacy-preserving distributed access control (part1/2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 18](images/S0065245818300676/f08-18-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 18 PPDAC Privacy-preserving distributed access control (part2/2).
  prefs: []
  type: TYPE_NORMAL
- en: 6 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter we have presented our approach to tackle privacy and security
    issues in IoT. More specifically, this approach consisted in providing a distributed
    access control framework that respects the following principles: edge intelligence,
    security through transparency, privacy by design and user-driven policy. Then,
    we have introduced FairAccess as a novel, stronger and transparent access control
    solution that met the four defined principles. FairAccess leverages the consistency
    offered by blockchain-based cryptocurrencies to solve all IoT-related access control
    challenges. While FairAccess leverages the consistency offered by blockchain-based
    cryptocurrencies to solve the problem of centralized and decentralized access
    control in IoT and provide a promising user-driven and transparent access control
    tool, it fails to guarantee a strong anonymity for users due to the public nature
    of the blockchain and its inherent traceability problem. To overcome this issue,
    a fully anonymous privacy-preserving Distributed access control scheme (PPDAC)
    was introduced in this chapter. PPDAC was integrated over FairAccess to maintain
    Blockchain transparency features while ensuring strong privacy guarantees for
    users. In this direction, attribute-based access control systems have been used,
    where access control decisions are based on the attributes (rather than the identity).
    A policy-hiding access control scheme that protects both sensitive attributes
    and sensitive policies has been developed using a white box version of distributed
    multi-authority cipher-text policy attribute based encryption DMCP-ABE. In addition,
    to face the traceability problem of authorization tokens a sufficient non-interactive
    zero proof of knowledge (zk-SNARK) protocol has been introduced. Finally, the
    formal definition and a construction of the proposed scheme were provided.'
  prefs: []
  type: TYPE_NORMAL
- en: To conclude we summarize the answers to the research questions formulated in
    [Section 3](S0065245818300676.xhtml#s0035).
  prefs: []
  type: TYPE_NORMAL
- en: 1. How to solve access control challenges in IoT by leveraging the blockchain
    technology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The vision of our decentralized access control framework is a system of autonomous
    organizations hinged around one or many Resource Owners in possession of one or
    many resources identified with addresses and interacting between each other through
    transactions (requesting, granting, delegating and revoking access) under the
    control of their RO. The blockchain is a ledger keeping track and ensures the
    validity of access transaction among interacting organization. Each manages its
    own access policy, under only the control of his Resource Owner. Actually, in
    FairAccess, we use Bitcoin-like addresses to identify all interacting entities
    and SmartContract (a.k.a. chain code) to express fine-grained and contextual access
    control policies enveloped inside transactions. We opt for authorization tokens
    distributed by the blockchain. FairAccess provides several useful mechanisms using
    the blockchain. In fact, in FairAccess, the blockchain is considered as a database
    or a policy retrieval point, where all access control policies are stored in form
    of transactions; it serves also as logging databases that ensure auditing functions.
    Furthermore, it prevents forgery of token through transactions integrity checks
    and detects token reuse through the double spending detection mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2. How to provide a lightweight access control framework for constrained IoT
    devices despite the intensive computation power required by the consensus protocol
    adopted by the public blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We answer to this question by proposing a hierarchical architecture where devices
    in the IoT support different degrees of FairAccess functionality, depending on
    their performance and storage capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3. How to enable a privacy preserving access control that hides user's access
    control policy and overcome the problem of traceability and profiling commonly
    known in the public blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We overcome this issue by introducing PPDAC a fully anonymous privacy-preserving
    Distributed access control scheme to be integrated over FairAccess to get a strong
    privacy guarantees access control scheme that preserves the Resource owner''s
    access control policies and the requester''s sensitive attributes and preserves
    in a strong way the anonymity of the requester and the Ro. The proposed scheme
    aims to maintain Blockchain transparency features while ensuring strong privacy
    guarantees for users. We use attribute-based access control systems, where access
    control decisions are based on the attributes (rather than the identity) of the
    requester: Access is granted if Alice''s attributes in her certificates satisfy
    Bob''s access policy. We develop a policy-hiding access control scheme that protects
    both sensitive attributes and sensitive policies. That is, nodes in the public
    blockchain can decide whether Alice''s certified attribute values satisfy Bob''s
    policy, without learning any other information about Alice''s attribute values
    nor Bob''s policy. Our construction for PPDAC uses a novel technique that combines
    CP-ABE, szNARK protocols and SmartContract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] Benessia A., Pereira Â.G. The dream of the Internet of things. In: *Science,
    Philosophy and Sustainability: The End of the Cartesian Dream 5, vol. 78.* 2015\.
    Retrieved from [https://books.google.com/books?hl=fr&lr=&id=_K7ABgAAQBAJ&oi=fnd&pg=PA78&dq=decentralizing++internet+of+things+ibm+watson+&ots=O98rKriJQ1&sig=Kz5bB4EJ80hSktroqnbo_ScvSZM](https://books.google.com/books?hl=fr&lr=&id=_K7ABgAAQBAJ&oi=fnd&pg=PA78&dq=decentralizing++internet+of+things+ibm+watson+&ots=O98rKriJQ1&sig=Kz5bB4EJ80hSktroqnbo_ScvSZM).'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Gubbi J., Buyya R., Marusic S., Palaniswami M. Internet of things (IoT):
    a vision, architectural elements, and future directions. *Future Gener. Comput.
    Syst.* 2013;29(7):1645–1660\. [https://doi.org/10.1016/j.future.2013.01.010](https://doi.org/10.1016/j.future.2013.01.010).'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Miorandi D., Sicari S., De Pellegrini F., et al. Internet of things: vision,
    applications and research challenges. *Ad Hoc Netw.* 2012;10(7):1497–1516\. Retrieved
    from [http://www.sciencedirect.com/science/article/pii/S1570870512000674](http://www.sciencedirect.com/science/article/pii/S1570870512000674).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Borgia E. The internet of things vision: key features, applications and
    open issues. *Comput. Commun.* 2014;54:1–31\. [https://doi.org/10.1016/j.comcom.2014.09.008](https://doi.org/10.1016/j.comcom.2014.09.008).'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Mattern F., Floerkemeier C. *From the Internet of Computers to the Internet
    of Things.* Springer Berlin Heidelberg; 2010.242–259\. [https://doi.org/10.1007/978-3-642-17226-7_15](https://doi.org/10.1007/978-3-642-17226-7_15).'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] Guinard D. *A Web of Things Application Architecture—Integrating the Real-World
    Into the Web.* PhD Thesis, ETH Zurich (19891), 220 [https://doi.org/10.3929/ethz-a-006713673](https://doi.org/10.3929/ethz-a-006713673).
    2011.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Bonomi F., Milito R., Zhu J., Addepalli S. *Fog computing and its role
    in the internet of things.* In: Proceedings of the First Edition of the MCC Workshop
    on Mobile Cloud Computing—MCC’12; New York: ACM Press; 2012:13\. [https://doi.org/10.1145/2342509.2342513](https://doi.org/10.1145/2342509.2342513).'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] Jardak C., Walewski J.W. *Enabling Things to Talk.* [https://doi.org/10.1007/978-3-642-40403-0](https://doi.org/10.1007/978-3-642-40403-0).
    2013.'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] Holler J., Tsiatsis V., Mulligan C., Avesand S. *From Machine-to-Machine
    to the Internet of Things: Introduction to a New Age of Intelligence.* Academic
    Press; 2014\. Retrieved from [https://books.google.com/books?hl=fr&lr=&id=wtfEAgAAQBAJ&oi=fnd&pg=PP1&dq=From+Machine-To-Machine+to+the+Internet+of+Things:+Introduction+to+a+New+Age+of+Intelligence+&ots=mICCLT9hgD&sig=UNQUKzbr7Co6cDF9jn8P9FL_01Q](https://books.google.com/books?hl=fr&lr=&id=wtfEAgAAQBAJ&oi=fnd&pg=PP1&dq=From+Machine-To-Machine+to+the+Internet+of+Things:+Introduction+to+a+New+Age+of+Intelligence+&ots=mICCLT9hgD&sig=UNQUKzbr7Co6cDF9jn8P9FL_01Q).'
  prefs: []
  type: TYPE_NORMAL
- en: '[10] Vermesan O., Friess P., eds. *Internet of Things: Converging Technologies
    for Smart Environments and Integrated Ecosystems.* River Publishers; 2013.'
  prefs: []
  type: TYPE_NORMAL
- en: '[11] Armitage J. *Paul Virilio: From Modernism to Hypermodernism and Beyond.*
    Retrieved from [https://books.google.com/books?hl=fr&lr=&id=-WL75BiQBRYC&oi=fnd&pg=PP1&dq=PAUL++virilio+Politics+of+the+Very+Worst+&ots=0AmM0dctMV&sig=QpI5pdafuGVLP4hr88N3kSb9i_A](https://books.google.com/books?hl=fr&lr=&id=-WL75BiQBRYC&oi=fnd&pg=PP1&dq=PAUL++virilio+Politics+of+the+Very+Worst+&ots=0AmM0dctMV&sig=QpI5pdafuGVLP4hr88N3kSb9i_A).
    2000.'
  prefs: []
  type: TYPE_NORMAL
- en: '[12] Kumar J.S., Patel D.R. A survey on Internet of things: Security and privacy
    issues. *Int. J. Comput. Appl.* 2014;90(11) MLA.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] Decker C., Seidel J., Wattenhofer R. Bitcoin meets strong consistency.
    *Proceedings of the 17th International Conference on Distributed Computing and
    Networking.* 2016;13: ACM.'
  prefs: []
  type: TYPE_NORMAL
- en: '[14] Vasilomanolakis E., Daubert J., Luthra M., Gazis V., Wiesmaier A., Kikiras
    P. On the security and privacy of Internet of things architectures and systems.
    In: *Secure Internet of Things (SIoT).* International Workshop on IEEE.ISO; 49–57\.
    2015;690.'
  prefs: []
  type: TYPE_NORMAL
- en: '[15] Ziegeldorf J.H., Morchon O.G., Wehrle K. Privacy in the internet of things:
    threats and challenges. *Secur. Commun. Netw.* 2014;7(12):2728–2742\. [https://doi.org/10.1002/sec.795](https://doi.org/10.1002/sec.795).'
  prefs: []
  type: TYPE_NORMAL
- en: '[16] Langheinrich M. *Privacy by Design—Principles of Privacy-Aware Ubiquitous
    Systems.* Springer Berlin Heidelberg; 2001.273–291\. [https://doi.org/10.1007/3-540-45427-6_23](https://doi.org/10.1007/3-540-45427-6_23).'
  prefs: []
  type: TYPE_NORMAL
- en: '[17] Ziegeldorf J.H., Morchon O.G., Wehrle K. Privacy in the internet of things:
    threats and challenges. *Secur. Commun. Netw.* 2014;7(12):2728–2742\. [https://doi.org/10.1002/sec.795](https://doi.org/10.1002/sec.795).'
  prefs: []
  type: TYPE_NORMAL
- en: '[18] Berman F., Cerf V.G. Social and ethical behavior in the internet of things.
    *Commun. ACM.* 2017;60(2):6–7\. [https://doi.org/10.1145/3036698](https://doi.org/10.1145/3036698).'
  prefs: []
  type: TYPE_NORMAL
- en: '[19] E.P. Goodman, The atomic age of data: Policies for the Internet of things,
    The Report Explores Some of These Policy Questions in the Context of the “Smart
    City” Use Case, ISO 690, 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[20] Diaz C., Gürses S., Troncoso C. Engineering privacy by design. *Comput.
    Priv. Data Prot.* 2011\. Retrieved from [https://software.imdea.org/~carmela.troncoso/papers/Gurses-CPDP11.pdf](https://software.imdea.org/~carmela.troncoso/papers/Gurses-CPDP11.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[21] Gurses S., del Alamo J.M. Privacy engineering: shaping an emerging field
    of research and practice. *IEEE Secur. Priv.* 2016;14(2):40–46\. [https://doi.org/10.1109/MSP.2016.37](https://doi.org/10.1109/MSP.2016.37).'
  prefs: []
  type: TYPE_NORMAL
- en: '[22] Spiekermann S., Cranor L.F. Engineering privacy. *IEEE Trans. Softw. Eng.*
    2009;35(1):67–82\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/4657365/](http://ieeexplore.ieee.org/abstract/document/4657365/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[23] Sánchez Alcón J.A., López L., Martínez J.F., et al. Trust and privacy
    solutions based on holistic service requirements. *Sensors (Basel).* 2015;16(1):16\.
    Retrieved from [http://www.mdpi.com/1424-8220/16/1/16/htm](http://www.mdpi.com/1424-8220/16/1/16/htm).'
  prefs: []
  type: TYPE_NORMAL
- en: '[24] Cavoukian A. Privacy by design in law, policy and practice. In: *A White
    Paper for Regulators, Decision-Makers and Policy-Makers.* 2011.'
  prefs: []
  type: TYPE_NORMAL
- en: '[25] Ouaddah A., Abou Elkalam A., Ait Ouahman A. FairAccess: a new blockchain-based
    access control framework for the internet of things. *Secur. Commun. Netw.* 2016;9(18):5943–5964\.
    [https://doi.org/10.1002/sec.1748](https://doi.org/10.1002/sec.1748).'
  prefs: []
  type: TYPE_NORMAL
- en: '[26] Ouaddah A., Elkalam A.A., Ouahman A.A. *Towards a Novel Privacy-Preserving
    Access Control Model Based on Blockchain Technology in IoT.* Cham: Springer; 2017.523–533\.
    [https://doi.org/10.1007/978-3-319-46568-5_53](https://doi.org/10.1007/978-3-319-46568-5_53).'
  prefs: []
  type: TYPE_NORMAL
- en: '[27] Ouaddah A., Mousannif H., Abou Elkalam A., Ait Ouahman A. Access control
    in the internet of things: big challenges and new opportunities. *Comput. Netw.*
    2017;112:237–262\. [https://doi.org/10.1016/j.comnet.2016.11.007](https://doi.org/10.1016/j.comnet.2016.11.007).'
  prefs: []
  type: TYPE_NORMAL
- en: '[28] Sandhu R.S. Role-based access control. *Adv. Comput.* 1998;46:237–286\.
    [https://doi.org/10.1016/S0065-2458(08)60206-5](https://doi.org/10.1016/S0065-2458(08)60206-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '[29] Yuan E., Tong J. *Attributed based access control (ABAC) for Web services.*
    In: IEEE International Conference on Web Services (ICWS’05); IEEE; 2005\. [https://doi.org/10.1109/ICWS.2005.25](https://doi.org/10.1109/ICWS.2005.25).'
  prefs: []
  type: TYPE_NORMAL
- en: '[30] Seitz L., Selander G., Wahlstroem E., Erdtman S., Tschofenig H. *Authorization
    for the Internet of Things Using OAuth 2.0.* Retrieved from [https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-01](https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-01).
    2016.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31] Cirani S., Picone M., Gonizzi P., Veltri L., Ferrari G. IoT-OAS: an oauth-based
    authorization service architecture for secure services in IoT scenarios. *IEEE
    Sensors J.* 2015;15(2):1224–1234\. [https://doi.org/10.1109/JSEN.2014.2361406](https://doi.org/10.1109/JSEN.2014.2361406).'
  prefs: []
  type: TYPE_NORMAL
- en: '[32] Roman R., Zhou J., Lopez J. On the features and challenges of security
    and privacy in distributed internet of things. *Comput. Netw.* 2013;57(10):2266–2279\.
    [https://doi.org/10.1016/j.comnet.2012.12.018](https://doi.org/10.1016/j.comnet.2012.12.018).'
  prefs: []
  type: TYPE_NORMAL
- en: '[33] Cirani S., Davoli L., Ferrari G., Léone R. A scalable and self-configuring
    architecture for service discovery in the internet of things. *IEEE Internet Things
    J.* 2014;1:508–521\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/6899579/](http://ieeexplore.ieee.org/abstract/document/6899579/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[34] Said O., Masud M. Towards internet of things: survey and future vision.
    *Int. J. Comput. Netw.* 2013;5(1):1–17\. Retrieved from [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.741.3655&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.741.3655&rep=rep1&type=pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[35] Tsai C.-W., Lai C.-F., Vasilakos A.V. Future internet of things: open
    issues and challenges. *Wirel. Netw.* 2014;20(8):2201–2217\. [https://doi.org/10.1007/s11276-014-0731-0](https://doi.org/10.1007/s11276-014-0731-0).'
  prefs: []
  type: TYPE_NORMAL
- en: '[36] Panikkar S., Nair S., Brody P., Pureswaran V. *ADEPT: An IoT Practitioner
    Perspective.* Retrieved from [http://ibm.biz/devicedemocracy](http://ibm.biz/devicedemocracy).
    2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[37] Antonakakis M., April T., Bailey M., et al. Understanding the mirai botnet.
    In: *USENIX Security Symposium.* 2017 1092–1110.'
  prefs: []
  type: TYPE_NORMAL
- en: '[38] Nakamoto S. *Bitcoin: A Peer-to-Peer Electronic Cash System.* 2008.1–9.'
  prefs: []
  type: TYPE_NORMAL
- en: '[39] Underwood S. Blockchain beyond bitcoin. *Commun. ACM.* 2016;59(11):15–17.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40] Swan M. *Blockchain: Blueprint for a New Economy.* Retrieved from [https://books.google.com/books?hl=fr&lr=&id=RHJmBgAAQBAJ&oi=fnd&pg=PR3&dq=BLOCKCHAIN+APPLICATION+BEYOND+FINANCE&ots=XPyHHY-Rg4&sig=xZ1yJTxrIgXGqd22L30op9po8-s](https://books.google.com/books?hl=fr&lr=&id=RHJmBgAAQBAJ&oi=fnd&pg=PR3&dq=BLOCKCHAIN+APPLICATION+BEYOND+FINANCE&ots=XPyHHY-Rg4&sig=xZ1yJTxrIgXGqd22L30op9po8-s).
    2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[41] Ulieru M. Blockchain 2.0 and beyond: adhocracies. In: *Banking Beyond
    Banks and Money.* 2016\. Retrieved from [http://link.springer.com/chapter/10.1007/978-3-319-42448-4_15](http://link.springer.com/chapter/10.1007/978-3-319-42448-4_15).'
  prefs: []
  type: TYPE_NORMAL
- en: '[42] Carter J.L., Wegman M.N. Universal classes of hash functions. *J. Comput.
    Syst. Sci.* 1979;18(2):143–154\. Retrieved from [http://www.sciencedirect.com/science/article/pii/0022000079900448](http://www.sciencedirect.com/science/article/pii/0022000079900448).'
  prefs: []
  type: TYPE_NORMAL
- en: '[43] Merkle R.C. *A digital signature based on a conventional encryption function.*
    In: Conference on the Theory and Application of Cryptographic Techniques; Berlin,
    Heidelberg: Springer; 1987\. 369–378, Retrieved from [http://link.springer.com/chapter/10.1007/3-540-48184-2_32](http://link.springer.com/chapter/10.1007/3-540-48184-2_32).'
  prefs: []
  type: TYPE_NORMAL
- en: '[44] Lamport L., Shostak R., Pease M. The byzantine generals problem. *ACM
    Trans. Program. Lang. Syst.* 1982;4(3):382–401\. Retrieved from [http://dl.acm.org/citation.cfm?id=357176](http://dl.acm.org/citation.cfm?id=357176).'
  prefs: []
  type: TYPE_NORMAL
- en: '[45] Tschorsch F., Scheuermann B. Bitcoin and beyond: a technical survey on
    decentralized digital currencies. *IEEE Commun. Surv. Tutor.* 2016;18(3):2084–2123\.
    Retrieved from [http://ieeexplore.ieee.org/abstract/document/7423672/](http://ieeexplore.ieee.org/abstract/document/7423672/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[46] Wang W., Hoang D.T., Xiong Z., et al. *A Survey on consensus mechanisms
    and mining management in blockchain networks.* 2018 arXiv preprint arXiv:1805.02707.'
  prefs: []
  type: TYPE_NORMAL
- en: '[47] Buterin V. A next-generation smart contract and decentralized application
    platform. In: *Ethereum.* 2014:1–36\. Retrieved from [http://buyxpr.com/build/pdfs/EthereumWhitePaper.pdf](http://buyxpr.com/build/pdfs/EthereumWhitePaper.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[48] Christidis K., Devetsikiotis M. Blockchains and smart contracts for the
    internet of things. *IEEE Access.* 2016;4:2292–2303\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/7467408/](http://ieeexplore.ieee.org/abstract/document/7467408/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[49] Caldwell J. *IBM Internet of Things Point of View and Strategy.* 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[50] Conoscenti M., Vetrò A., Martin J.D. *Blockchain for the Internet of Things:
    A Systematic Literature Review.* Retrieved from [http://porto.polito.it/id/eprint/2650266](http://porto.polito.it/id/eprint/2650266).
    2016.'
  prefs: []
  type: TYPE_NORMAL
- en: '[51] Ouaddah A., Bellaj B. FairAccess 2.0: a smart contract-based authorization
    framework for enabling granular access control in IoT. *Int. J. Inf. Comput. Secur.
    (IJICS).* 2018.'
  prefs: []
  type: TYPE_NORMAL
- en: '[52] Reid F., Harrigan M. *An analysis of anonymity in the bitcoin system,
    in: Security and Privacy in Social Networks.* New York: Springer New York; 2013.197–223\.
    [https://doi.org/10.1007/978-1-4614-4139-7_10](https://doi.org/10.1007/978-1-4614-4139-7_10).'
  prefs: []
  type: TYPE_NORMAL
- en: '[53] Ron D., Shamir A. *Quantitative Analysis of the Full Bitcoin Transaction
    Graph.* Berlin Heidelberg: Springer; 2013.6–24\. [https://doi.org/10.1007/978-3-642-39884-1_2](https://doi.org/10.1007/978-3-642-39884-1_2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[54] Bethencourt J., Sahai A., Waters B. Ciphertext-policy attribute-based
    encryption. [IEEE]. In: *2007 IEEE Symposium on Security and Privacy (SP’07).*
    2007:321–334\. [https://doi.org/10.1109/SP.2007.11](https://doi.org/10.1109/SP.2007.11).'
  prefs: []
  type: TYPE_NORMAL
- en: '[55] Cheung L., Newport C. Provably secure ciphertext policy ABE. In: *Proceedings
    of the 14th ACM Conference on Computer and Communications Security, ACM.* 2007:456–465\.
    Retrieved from [http://dl.acm.org/citation.cfm?id=1315302](http://dl.acm.org/citation.cfm?id=1315302).'
  prefs: []
  type: TYPE_NORMAL
- en: '[56] Bitansky N., Chiesa A., Ishai Y., Paneth O., Ostrovsky R. *Succinct Non-interactive
    Arguments via Linear Interactive Proofs.* Berlin, Heidelberg: Springer; 2013.315–333\.
    [https://doi.org/10.1007/978-3-642-36594-2_18](https://doi.org/10.1007/978-3-642-36594-2_18).'
  prefs: []
  type: TYPE_NORMAL
- en: '[57] Beimel A., סומע למיב. *Secure schemes for secret sharing and key distribution.*
    Technion-Israel Institute of Technology, Faculty of Computer Science; 1996.'
  prefs: []
  type: TYPE_NORMAL
- en: '[58] Han J., Susilo W., Mu Y., Zhou J., Ho Allen Au M. Improving privacy and
    security in decentralized ciphertext-policy attribute-based encryption. *IEEE
    Trans. Inf. Forensics Secur.* 2015;10(3):665–678.'
  prefs: []
  type: TYPE_NORMAL
- en: '[59] Chase M. Multi-authority attribute based encryption. In: *Theory of Cryptography.*
    Berlin, Heidelberg: Springer Berlin Heidelberg; 2007:515–534.'
  prefs: []
  type: TYPE_NORMAL
- en: '[60] Sander T., Ta-Shma A. Auditable, anonymous electronic cash. In: *Advances
    in Cryptology—CRYPTO’ 99.* Berlin, Heidelberg: Springer; 1999:555–572\. [http://link.springer.com/10.1007/3-540-48405-1_35](http://link.springer.com/10.1007/3-540-48405-1_35)
    (cit. on p. 122).'
  prefs: []
  type: TYPE_NORMAL
- en: '![u08-01-9780128171899](images/S0065245818300676/u08-01-9780128171899.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Dr Aafaf Ouaddah** holds a PhD in Computer Science on her work on security
    and privacy in IoT through the blockchain technology from the Cadi Ayyad University,
    Marrakesh (Morocco) in 2017\. She received the Engineer degree in Networking and
    Information Technology in 2013, from the National Institute of Posts and Telecommunication
    (INPT) graduate school engineering. Since 2017, she is a Chief Scientist at Mchain
    enterprise. Her research interests include the blockchain and new distributed
    ledgers as well as security and privacy in distributed systems, IoT, and Fog computing.
    She has published more than 10 research papers in various conferences, workshops
    and International Journals of repute including IEEE, Springer and Elsevier.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([a](S0065245818300676.xhtml#xfn0010 "label")) [http://www.gartner.com/newsroom/id/2209615](http://www.gartner.com/newsroom/id/2209615).
  prefs: []
  type: TYPE_NORMAL
- en: ^([b](S0065245818300676.xhtml#xfn0015 "label")) [http://share.cisco.com/internet-of-things.html](http://share.cisco.com/internet-of-things.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([c](S0065245818300676.xhtml#xfn0020 "label")) [http://iotevent.eu/cisco-sees-14-trillion-opportunity-in-iot/](http://iotevent.eu/cisco-sees-14-trillion-opportunity-in-iot/).
  prefs: []
  type: TYPE_NORMAL
