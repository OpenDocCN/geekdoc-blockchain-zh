- en: Chapter Eight
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第八章
- en: A blockchain based access control framework for the security and privacy of
    IoT with strong anonymity unlinkability and intractability guarantees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于区块链的 IoT 安全和隐私访问控制框架，具有强大的匿名性、不可链接性和难以推测性保证。
- en: Aafaf Ouaddah    ^(Mchain, Admirals Way, Canary Wharf E14 9UH, London, United
    Kingdom)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Aafaf Ouaddah    ^(Mchain, Admirals Way, Canary Wharf E14 9UH, London, United
    Kingdom)
- en: Abstract
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Motivated by the recent explosion of interest around the blockchain, we examine
    whether they make a good fit to build a lightweight and robust access control
    framework to address security and privacy issues in the Internet of Things (IoT)
    sector. In this direction, this chapter discusses the limitations of the centralized
    model to secure IoT and proposes the blockchain approach as example of successful
    distributed system to bring security and privacy to IoT devices. In this direction,
    we introduce FairAccess and PPDAC, as a lightweight and privacy-preserving access
    control framework based on the emergent blockchain technology, mainly the permissionless
    and public type, to ensure fine-grained access control functions for IoT devices
    with strong anonymity guarantee for IoT end-users. The proposed framework retains
    the benefits of the blockchain to meet IoT security and privacy arising needs
    while overcoming the challenges in integrating the blockchain to IoT.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 受到区块链近期爆炸性增长的兴趣的启发，我们检查它们是否适合构建一个轻量级且健壮的访问控制框架，以解决物联网（IoT）领域的安全和隐私问题。在这个方向上，本章讨论了中心化模型保护物联网的局限性，并提出区块链方法作为成功的分布式系统的例子，以为物联网设备带来安全和隐私。在这个方向上，我们介绍了
    FairAccess 和 PPDAC，作为一个基于新兴区块链技术的轻量级和隐私保护访问控制框架，主要是无许可和公共类型，以确保对物联网设备的细粒度访问控制功能，为
    IoT 最终用户提供强大的匿名保证。所提出的框架保留了区块链的优势，以满足 IoT 安全和隐私的需求，同时克服了将区块链整合到物联网中所面临的挑战。
- en: Keywords
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键词
- en: Blockchain; IoT; Privacy; SmartContracts; Access control; CP-ABE
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链；物联网；隐私；智能合约；访问控制；CP-ABE
- en: 1 Introduction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 引言
- en: Two decades ago, a world where everyday objects could sense, analyze, store,
    or exchange information existed only in science-fiction novels [[1]](S0065245818300676.xhtml#bb0010).
    Today, with the rapid grow of hardware technologies, such scenarios are increasingly
    becoming reality. In fact, Gartner identifies IoT as one of the top 10 strategic
    technology trends,^([a](S0065245818300676.xhtml#fn0010)) Cisco forecasts 50 billion
    devices connected by 2020^([b](S0065245818300676.xhtml#fn0015)) a potential market
    in excess of $14 trillion.^([c](S0065245818300676.xhtml#fn0020)) IoT is actually
    already here. Things are extending the world we live in by enabling a whole new
    range of applications. Being able to put a bunch of powerful, tiny, and cheap
    computers everywhere around us making it possible to monitor and interact with
    the physical world with a much finer spatial and temporal resolution than ever
    before. And yet the application scenarios and market opportunities offered by
    objects communicating actively and autonomously extend far beyond the foreseeable
    horizon [[2]](S0065245818300676.xhtml#bb0015).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 二十年前，科幻小说中描述的日常物品可以感知、分析、存储或交换信息的世界只存在于科幻小说中[[1]](S0065245818300676.xhtml#bb0010)。如今，随着硬件技术的快速发展，这样的场景越来越成为现实。事实上，Gartner将物联网（IoT）确定为十大战略技术趋势之一^([a](S0065245818300676.xhtml#fn0010))，思科预测到2020年将有500亿台连接设备^([b](S0065245818300676.xhtml#fn0015))，市场潜力超过14万亿美元^([c](S0065245818300676.xhtml#fn0020))。物联网已经在这里。物品通过启用全新范围的应用程序来扩展我们所处的世界。能够在我们周围随处放置一堆强大、微小和廉价的计算机，使得我们能够以比以往任何时候都更精细的空间和时间分辨率监控和与物理世界进行交互。然而，由物体主动和自主地进行通信所提供的应用场景和市场机遇远远超出可预见的地平线[[2]](S0065245818300676.xhtml#bb0015)。
- en: IoT is both a global physical infrastructure and an umbrella term for conceiving
    many existing and evolving interoperable Information and Communication Technologies
    (ICT)’s, interconnected, devices, objects and services [[3]](S0065245818300676.xhtml#bb0020),
    increasingly deployed in various range of domains such as industrial control,
    health care, aviation, home automation, retail, transport, wearable, and more
    [[4](S0065245818300676.xhtml#bb0025),[5]](S0065245818300676.xhtml#bb0030). This
    revolution, also known as web of things [[6]](S0065245818300676.xhtml#bb0035),
    Internet of Everything or Fog networks [[7]](S0065245818300676.xhtml#bb0040) where
    smart things are communicating among each other and with computers in the Internet
    in an intelligent [[8]](S0065245818300676.xhtml#bb0045) and a machine-to-machine
    way [[9]](S0065245818300676.xhtml#bb0050), aims at redefining the whole relationship
    of humans, work, and technology [[10]](S0065245818300676.xhtml#bb0055).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）既是一个全球物理基础设施，也是一个涵盖许多现有和不断发展的互操作信息和通信技术（ICT）的大伞术语，这些技术相互连接，设备、物体和服务
    [[3]](S0065245818300676.xhtml#bb0020)，越来越多地部署在工业控制、医疗保健、航空、家庭自动化、零售、交通、可穿戴设备等各个领域
    [[4](S0065245818300676.xhtml#bb0025),[5]](S0065245818300676.xhtml#bb0030)。这场革命，也被称为物联网
    [[6]](S0065245818300676.xhtml#bb0035)，万物互联或雾计算网络 [[7]](S0065245818300676.xhtml#bb0040)，在这里智能物体相互通信，并与互联网中的计算机以智能
    [[8]](S0065245818300676.xhtml#bb0045)和机器对机器的方式进行通信 [[9]](S0065245818300676.xhtml#bb0050)，旨在重新定义人类、工作和技术的整个关系
    [[10]](S0065245818300676.xhtml#bb0055)。
- en: 'However, as quoted by the French theorist and urbanist Paul Virilio: “When
    you invent the ship, you also invent the shipwreck … Every technology carries
    its own negativity, which is invented at the same time as technical progress”
    [[11]](S0065245818300676.xhtml#bb0060). This wise adage gives us an eloquent understanding
    of how IoT will be a revolutionary technology if we can overcome its drawbacks
    mainly its security and privacy issues. Actually, in one hand, IoT is arising
    new security challenges due to the use of simple processors and operating systems
    that are not supporting sophisticated security approaches by the majority of IoT
    devices. In addition, the lack of authentication and authorization standards for
    IoT edge devices gives birth to malicious attacks on secrecy and authentication,
    silent attacks on service integrity, or attacks on network availability such as
    denial-of-sleep attacks that drain batteries, or denial-of-service (DoS) attacks
    [[12](S0065245818300676.xhtml#bb0065),[13]](S0065245818300676.xhtml#bb0070).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如法国理论家和城市规划师保罗·维里奥所引用的：“当你发明了船，你也发明了沉船……每一项技术都伴随着自己的负面，这在技术进步的同时也被发明出来”[[11]](S0065245818300676.xhtml#bb0060)。这句智慧的格言给了我们一个雄辩的理解，即如果我们能够克服其主要的安全和隐私问题，物联网将成为一项革命性的技术。实际上，在某种程度上，由于大多数物联网设备使用的简单处理器和操作系统不支持复杂的安全方法，物联网正在带来新的安全挑战。此外，物联网边缘设备缺乏身份验证和授权标准，导致了对机密性和身份验证的恶意攻击，对服务完整性的悄无声息的攻击，或对网络可用性的攻击，如耗尽电池的睡眠拒绝服务攻击，或服务拒绝（DoS）攻击[[12](S0065245818300676.xhtml#bb0065),[13]](S0065245818300676.xhtml#bb0070)。
- en: 'On the other hand, privacy is no less serious issue. Actually, IoT devices
    are, by nature, “collectors and distributors of information” [[8]](S0065245818300676.xhtml#bb0045),
    so they constitute a huge challenge to individual privacy [[14](S0065245818300676.xhtml#bb0075),[15]](S0065245818300676.xhtml#bb0080),
    especially, the omnipresence of IoT devices in user''s everyday life and his ubiquitous
    interaction with smart objects. In addition to the uncontrolled, automated and
    unseen collection of fine-grained data by third parties lacking in transparency
    may consistently exhibit users to several threats, such as: identification, localization
    and tracking, monitoring, surveillance, manipulation, profiling, data linkage,
    privacy-violating interaction and presentation and even social engineering [[16](S0065245818300676.xhtml#bb0085),[17]](S0065245818300676.xhtml#bb0090).
    Privacy-by-policy and privacy-by- design are two emergent approaches, elicited
    by the academic literature [[18](S0065245818300676.xhtml#bb0095)–[20](S0065245818300676.xhtml#bb0105)]
    to enhance privacy in IoT. Privacy-by-policy aims to protect data from accidental
    disclosure or misuses, also promoting informed costumer choice [[21](S0065245818300676.xhtml#bb0110),[22]](S0065245818300676.xhtml#bb0115),
    while privacy-by-design prompts to implement privacy throughout the engineering
    process, with a proactive and preventative approach, rather than ex post [[23](S0065245818300676.xhtml#bb0120),[24]](S0065245818300676.xhtml#bb0125).
    Combining both approaches has proven crucial to conceptualize and alleviate potential
    risks associated with the IoT, which nevertheless still a highly controversial
    issue.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，隐私问题同样严重。实际上，物联网设备本质上是“信息的收集者和分发者”[[8]](S0065245818300676.xhtml#bb0045)，因此它们对个人隐私构成了巨大挑战[[14](S0065245818300676.xhtml#bb0075)，[15]](S0065245818300676.xhtml#bb0080)，特别是物联网设备无处不在地存在于用户的日常生活中，并且用户与智能物体的无所不在的互动。除了第三方无序、自动和隐蔽地收集细粒度数据外，缺乏透明度还可能不断地让用户面临诸多威胁，例如：身份识别、定位和跟踪、监视、监控、操纵、个人资料、数据关联、侵犯隐私的互动和呈现，甚至社会工程学[[16](S0065245818300676.xhtml#bb0085)，[17]](S0065245818300676.xhtml#bb0090)。隐私策略和隐私设计是两种新兴方法，由学术文献引发[[18](S0065245818300676.xhtml#bb0095)–[20](S0065245818300676.xhtml#bb0105)]，用于增强物联网中的隐私。隐私策略旨在保护数据免受意外披露或滥用，并促进知情的消费者选择[[21](S0065245818300676.xhtml#bb0110)，[22]](S0065245818300676.xhtml#bb0115)，而隐私设计则促使在整个工程过程中实施隐私，采用积极主动和预防性的方法，而不是事后[[23](S0065245818300676.xhtml#bb0120)，[24]](S0065245818300676.xhtml#bb0125)。结合这两种方法已被证明对于概念化和缓解与物联网相关的潜在风险至关重要，尽管这仍然是一个高度争议的问题。
- en: Unfortunately, current solutions can hardly keep up with those new arisen challenges.
    Therefore, new security and privacy-engineering practices and distributed architectures
    are increasingly urgently needed to properly address the IoT major challenges.
    Thus, our research is concerned about how decentralization through blockchain
    technology, mainlythe permissionless and public type, can be applied to provide
    a privacy-preserving access control solution to IoT objects and what are the strengths
    and weaknesses in doing so. For that purpose, we introduced FairAccess [[25](S0065245818300676.xhtml#bb0130),[26]](S0065245818300676.xhtml#bb0135)
    as a novel Distributed Privacy Preserving Access Control framework in IoT scenario
    that combines access control models and cryptocurrency blockchain mechanisms.
    In FairAccess, we propose the use of SmartContract to express fine-grained access
    control policies to make authorization decisions. We opt for authorization tokens
    as access control mechanism, delivered through emergent cryptocurrency solutions.
    We use the public blockchain first to ensure evaluating access policies in distributed
    environments where there is no central authority/administrator, and guarantee
    that policies will be properly enforced by all interacting entities and second
    to ensure token reuse detection. However, the public aspect of the blockchain
    ledger might initially appear to be at odds with the private aspect of some access
    control policies. To tackle this issue, this position chapter proposes a privacy-preserving
    distributed access control (PPDAC) scheme to be integrated with FairAccess. PPDAC
    uses a white box version of Distributed Cipher-text Policy Attribute Based Encryption
    “DCP-ABE” technique to add a privacy layer hiding sensitive attributes and private
    access control policies in the public blockchain while keeping the verification
    process transparent and public. In addition, the use of recent protocol in cryptography
    such as zero proof of knowledge protocol “zk-SNARK” enables our framework to guarantee
    high anonymity and intractability to IoT end users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前的解决方案几乎无法跟上这些新出现的挑战。因此，迫切需要新的安全和隐私工程实践和分布式架构，以便妥善解决物联网的主要挑战。因此，我们的研究关注的是如何通过区块链技术的去中心化，主要是无许可和公共类型，来提供隐私保护的物联网对象访问控制解决方案，以及在这样做时的优势和劣势。为此，我们在物联网场景中引入了FairAccess
    [[25](S0065245818300676.xhtml#bb0130),[26]](S0065245818300676.xhtml#bb0135)作为一种新颖的分布式隐私保护访问控制框架，其结合了访问控制模型和加密货币区块链机制。在FairAccess中，我们提出使用智能合约来表达细粒度的访问控制策略，以做出授权决策。我们选择授权令牌作为访问控制机制，通过新兴的加密货币解决方案进行交付。我们首先使用公共区块链来确保在无中央权威/管理员的分布式环境中评估访问策略，并确保所有互动实体将正确执行策略，其次是确保令牌重用检测。然而，区块链账本的公共性可能初看起来似乎与某些访问控制策略的私密性相抵触。为了解决这个问题，本立场章节提出了一个隐私保护的分布式访问控制（PPDAC）方案，以与FairAccess集成。PPDAC使用分布式密文策略属性基加密(DCP-ABE)技术的白盒版本，以在公共区块链中增加一个隐藏敏感属性和私密访问控制策略的隐私层，同时保持验证过程透明和公开。此外，利用密码学中最近的零知识证明协议“zk-SNARK”等协议，使我们的框架能够保证物联网最终用户的高匿名性和难以追踪性。
- en: 'The reminder of this chapter is organized as follow: [Section 2](S0065245818300676.xhtml#s0015)
    begins with the definition of IoT''s specific requirements in security and privacy.
    It discusses the drawbacks of the centralized approach and the advantages of the
    distributed one in IoT context. [Section 3](S0065245818300676.xhtml#s0035) proposes
    the blockchain approach as a promising distributed technology to enable security
    in IoT. This will be followed by some brief overview of the blockchain technology.
    [Section 4](S0065245818300676.xhtml#s0050) investigates our proposed approach
    to ensure smart objects security through a decentralized and user-driven access
    control framework based on the blockchain named FairAccess and discusses the limitations
    we have faced using the public blockchain mainly the privacy and traceability
    problems. [Section 5](S0065245818300676.xhtml#s0070) overcomes the defined problems
    by adding a privacy layer on top of the blockchain through PPDAC scheme. Finally,
    [Section 6](S0065245818300676.xhtml#s0140) concludes the chapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '本章的剩余部分组织如下：[第 2 节](S0065245818300676.xhtml#s0015) 从定义物联网在安全和隐私方面的具体要求开始。它讨论了集中式方法的缺点和在物联网环境中分布式方法的优势。[第
    3 节](S0065245818300676.xhtml#s0035) 提出了区块链方法作为一种有望实现物联网安全的分布式技术。接下来将简要概述区块链技术。[第
    4 节](S0065245818300676.xhtml#s0050) 通过名为 FairAccess 的基于区块链的分散式和用户驱动的访问控制框架来调查我们提出的确保智能对象安全的方法，并讨论了我们在使用公共区块链时所面临的限制，主要是隐私和可追溯性问题。[第
    5 节](S0065245818300676.xhtml#s0070) 通过 PPDAC 方案在区块链上添加隐私层来解决定义的问题。最后，[第 6 节](S0065245818300676.xhtml#s0140)
    总结了本章。  '
- en: <hgroup>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 Problem statement and research questions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 问题陈述和研究问题
- en: 2.1 IoT security and privacy requirement
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 物联网安全和隐私需求
- en: </hgroup>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: 'IoT is exposed to significant privacy and security risks due to its heterogeneous
    devices, dynamics, multiple domain application and undefined perimeters. As a
    result, it becomes more difficult for security researchers to find comprehensive
    solutions to the current security challenges. Therefore, the importance of understanding,
    defining and analyzing those requirement becomes paramount. In fact, each domain
    application presents peculiarities that often depend on the context and the devices
    interacting in that field, and that must be considered when dealing with security
    and privacy requirements. To meet this end, we have conducted a deep analysis
    that supports the specification of security and privacy requirements in a structured
    form in ref. [[27](S0065245818300676.xhtml#bb0140)]. During our study, we began
    by defining those requirements into six groups: Privacy, Confidentiality and Integrity,
    Reliability and availability, social and economic aspects, technologies constraints
    and usability. The six main security and privacy requirements along with their
    subcomponents are shown in [Fig. 1](S0065245818300676.xhtml#f0010).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物联网具有异构设备、动态性、多领域应用和未定义的边界，因此其面临重大的隐私和安全风险。因此，安全研究人员更难以找到当前安全挑战的综合解决方案。因此，理解、定义和分析这些要求的重要性变得至关重要。事实上，每个领域应用都有其特殊性，这些特殊性通常取决于该领域中的上下文和设备之间的交互，当处理安全和隐私要求时必须考虑到这一点。为了实现这一目标，我们进行了深入分析，支持以结构化形式规范安全和隐私要求的说明。在我们的研究中，我们首先将这些要求定义为六个组：隐私、机密性和完整性、可靠性和可用性、社会和经济方面、技术约束和可用性。主要的六个安全和隐私要求以及它们的子组件显示在[图
    1](S0065245818300676.xhtml#f0010)中。
- en: '![Fig. 1](images/S0065245818300676/f08-01-9780128171899.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 1](images/S0065245818300676/f08-01-9780128171899.jpg)'
- en: Fig. 1 IoT's security and privacy requirements [[27]](S0065245818300676.xhtml#bb0140).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1 物联网的安全和隐私要求 [[27]](S0065245818300676.xhtml#bb0140)。
- en: 'Afterward, we listed different application fields of IoT and specify the characteristics
    and security requirements of each one. Indeed, we have categorized these applications
    into three domains: (1) Personal and home: at the scale of individual, home and
    healthcare. (2) Government and utilities: at the scale of community nation and
    region. (3) Enterprise and industry: at the scale of industries and big companies.
    Moreover, we gave an overview of different taxonomies and classification of constrained
    devices in IoT.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们列出了物联网的不同应用领域，并详细说明了每个领域的特点和安全要求。事实上，我们将这些应用程序分为三个领域：（1）个人和家庭：个人、家庭和医疗保健的规模。(2)政府和公用事业：社区、国家和地区的规模。(3)企业和产业：产业和大公司的规模。此外，我们概述了物联网中受限设备的不同分类和分类。
- en: 'The study conducted to the following findings: In a glance, it is shown that
    with regard to personal and home category, access control solutions targeting
    this category are required to preserve the privacy of end users in a proprietary,
    primordial but user-friendly way. In addition, the availability and reliability
    needs are the outstanding objectives of security solutions targeting enterprise
    and industry category, while the confidentiality and integrity needs overwhelm
    when it comes to government and utilities applications. However, it is observed
    that the whole categories commonly share the following needs on principles of
    cooperation and collaboration, openness/interoperability, high scalability, flexibility
    and distribution. [Fig. 2](S0065245818300676.xhtml#f0015) depicts the relationship
    between the various IoT domain application and the security requirements.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该研究得出以下结果：一目了然，就个人和家庭类别而言，针对该类别的访问控制解决方案需要以专有、原始但用户友好的方式保护终端用户的隐私。此外，安全解决方案针对企业和工业类别的可用性和可靠性需求是突出的目标，而针对政府和公用事业应用程序来说，机密性和完整性需求占主导地位。然而，观察到整个类别通常在合作与协作原则、开放性/互操作性、高可扩展性、灵活性和分布方面有共同需求。[图
    2](S0065245818300676.xhtml#f0015) 描绘了各种物联网领域应用与安全需求之间的关系。
- en: '![Fig. 2](images/S0065245818300676/f08-02-9780128171899.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2](images/S0065245818300676/f08-02-9780128171899.jpg)'
- en: Fig. 2 IoT domain application taxonomy and their security requirements [[27]](S0065245818300676.xhtml#bb0140).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2 物联网领域应用分类及其安全需求[[27]](S0065245818300676.xhtml#bb0140)。
- en: 2.2 The state of current access control architectures in IoT and related challenges
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 当前物联网访问控制架构的状态及相关挑战
- en: 'The integration of physical objects in the internet infrastructure requires
    the application of lightweight security mechanisms to be used even in constrained
    environments. However, current security standards and access control solutions
    were not designed with such aspects in mind. They are not sufficient to meet the
    needs of these nascent ecosystems regarding scalability, interoperability, lightness
    and end-to-end security [[27]](S0065245818300676.xhtml#bb0140). These challenges
    have attracted more and more attention from research community and recently several
    efforts are starting to emerge in this direction. However, those solutions could
    be categorized within three approaches as follow (see [Fig. 3](S0065245818300676.xhtml#f0020)):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将物理对象集成到互联网基础设施中需要应用轻量级安全机制，即使在受限环境中也要使用。然而，当前的安全标准和访问控制解决方案并未考虑到这些方面。它们无法满足这些新生态系统在可扩展性、互操作性、轻量级和端到端安全方面的需求[[27]](S0065245818300676.xhtml#bb0140)。这些挑战引起了研究界越来越多的关注，最近一些努力开始朝着这个方向出现。然而，这些解决方案可以分为以下三种方法（见[图
    3](S0065245818300676.xhtml#f0020)）：
- en: • The Centralized architecture
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 集中式架构
- en: 'This approach consists in outsourcing IoT device''s access control related
    operations to a trusted third entity. This entity, also known as a Policy Decision
    Point (PDP), could be instantiated by a back-end server or gateway directly connected
    to the device that it manages. It is responsible for analyzing access requests
    based on the stored access control policies. Therefore, requesters wishing to
    get access to the data provided by end devices are asked to pass by those trusted
    third parties. The bright side of this architecture consists in relieving constrained
    devices (i.e., sensors, actuators) from the burden of processing heavy access
    control functionalities, which enables the use of standard access control technologies
    such as SAML and HTTPS (to transport in a secure way authentication information),
    XACML (to define complex access control policies) among many others. However,
    this architecture presents major disadvantages, in the context of IoT, listed
    as follow: First, end to end security is dropped by the introduction of a trusted
    third party. Second, the role of IoT devices is strictly limited, within this
    architecture, in the decision making process. As a result, the elaboration of
    smart authorization policies, where access control decision are based on contextual
    information instantaneously collected from the environment of IoT end devices,
    is hardly challenging. Third, the Resource Owner (RO) access control policies
    as well as the users'' authorization requests are revealed to the trusted party.
    As a result, the privacy of either the resource owner or the requester is corrupted.
    Fourth, the PDP remains a bottleneck and point of failure that can disrupt the
    entire network. This is particularly important when it is directly tied to critical
    IoT services.'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法是将物联网设备的访问控制相关操作外包给可信的第三方实体。这个实体，也称为策略决策点（PDP），可以由后端服务器或直接连接到它管理的设备的网关实例化。它负责根据存储的访问控制策略分析访问请求。因此，希望访问由终端设备提供的数据的请求者被要求经过这些受信任的第三方。这种架构的好处在于解除了受限设备（即传感器、执行器）处理繁重访问控制功能的负担，从而使得可以使用标准访问控制技术，如SAML和HTTPS（以安全方式传输身份验证信息），XACML（定义复杂的访问控制策略）等。然而，在物联网环境中，这种架构存在一些主要缺点，列举如下：首先，引入可信的第三方导致端到端安全性受损。其次，在这种架构中，物联网设备的角色在决策过程中受到严格限制。因此，制定智能授权策略，其中访问控制决策基于即时从物联网终端设备环境收集的上下文信息，是非常具有挑战性的。第三，资源所有者（RO）访问控制策略以及用户的授权请求都被透露给了可信方。因此，资源所有者或请求者的隐私被破坏。第四，PDP仍然是一个可能破坏整个网络的瓶颈和故障点。当它直接与关键的物联网服务挂钩时，这一点尤为重要。
- en: • The Decentralized architecture with trustful entity
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 分布式架构与可信实体
- en: In this approach, the device participates partially in the elaboration of the
    access control decision. Its main role consists in gathering the contextual information
    from its surrounding environment (location, temperature, humidity, power level,
    etc.) and send it to a trusted third party. This trusted third party receives
    the access control requests and makes the decision based on a pre-defined policies
    and the contextual information received from the smart object. Like the centralized
    approach, this architecture enables the use of already existing authorization
    technologies with the need to elaborate a connection between the trusted third
    party and the connected device to transfer the contextual information. However,
    in this scenario, additional security measures have to be taken to secure the
    communication channel between the trusted third party and the end-device to protect
    the transferred information. In addition, end-device has to be configured to providing
    or not its collected data. Moreover, the transfer of contextual information to
    the trusted party could not be achieved in instantaneous way, meaning that this
    architecture is not recommended in use cases where real time decisions access
    is required such as health-care scenario, or with SCADA systems. Finally, the
    privacy of the resource owner and the requester is not considered.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种方法中，设备部分参与访问控制决策的制定。其主要作用是收集其周围环境的上下文信息（位置、温度、湿度、电力水平等），并将其发送给受信任的第三方。这个受信任的第三方接收访问控制请求，并根据预定义的策略和从智能对象收到的上下文信息做出决策。与集中式方法一样，这种架构使得可以利用已有的授权技术，而无需在受信任的第三方和连接设备之间制定连接来传输上下文信息。然而，在这种情况下，必须采取额外的安全措施来保护受信任的第三方和终端设备之间的通信渠道，以保护传输的信息。此外，终端设备必须配置为提供或不提供其收集的数据。此外，将上下文信息传输给受信任方可能无法以即时方式完成，这意味着不推荐在需要实时决策访问的用例中使用此架构，例如医疗保健场景或SCADA系统。最后，不考虑资源所有者和请求者的隐私。
- en: • The Distributed architecture
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 分布式架构
- en: The distributed approach consists in locating and embedding the intelligence
    of processing an access control decision in the device side. This approach matches
    perfectly with the real essence of IoT where intelligence is located in the edge
    of the network. It presents many impressive and promising advantages regarding
    the privacy of the resource owner and the requester as no trusted third party
    is involved. With the edge-intelligence principal, end-users are more empowered
    to control access over their own devices by defining their own policies. Furthermore,
    the possibility of making a smart access control decision in a real time is given.
    Moreover, the cost management of data generated by IoT devices is less expensive
    than the one in the two precedent approaches where providing a cloud back end
    for each connected smart object is required. In the distributed approach, devices
    are authorized to send information just when it is necessary. Finally end-to-end
    security could be achieved.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分布式方法包括在设备端定位和嵌入处理访问控制决策的智能。这种方法与物联网的真正本质完美匹配，物联网的智能位于网络边缘。就资源所有者和请求者的隐私而言，它提供了许多令人印象深刻和有前景的优势，因为没有信任的第三方参与。通过边缘智能原则，最终用户更能够通过定义自己的策略来控制对自己设备的访问。此外，实时进行智能访问控制决策的可能性得到了提供。此外，与前两种方法相比，由物联网设备生成的数据的成本管理更为廉价，因为前两种方法需要为每个连接的智能对象提供云后端。在分布式方法中，设备只有在必要时才被授权发送信息。最终，端到端的安全性可以得到实现。
- en: '![Fig. 3](images/S0065245818300676/f08-03-9780128171899.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 3](images/S0065245818300676/f08-03-9780128171899.jpg)'
- en: Fig. 3 Existing access control architectures in IoT.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3 物联网中的现有访问控制架构。
- en: However, the most challenging hurdle in this approach arises from the inherent
    features of existing access control technologies such as RBAC [[28]](S0065245818300676.xhtml#bb0145)
    and ABAC [[29]](S0065245818300676.xhtml#bb0150) and OAUTH [[30]](S0065245818300676.xhtml#bb0155)
    that make their implementation unfeasible in resource-constrained devices [[31]](S0065245818300676.xhtml#bb0160).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该方法中最具挑战性的障碍源自现有访问控制技术的固有特性，如RBAC [[28]](S0065245818300676.xhtml#bb0145)和ABAC
    [[29]](S0065245818300676.xhtml#bb0150)以及OAUTH [[30]](S0065245818300676.xhtml#bb0155)，这使得它们在资源受限设备上的实现不可行[[31]](S0065245818300676.xhtml#bb0160)。
- en: Consequently, much effort has to be conducted to deeply analyze the viability
    of adapting existing access control models or defining new proposals that meet
    the requirements of a distributed access control approach.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，必须付出大量努力来深入分析调整现有访问控制模型的可行性，或者定义满足分布式访问控制方法要求的新提议。
- en: 2.3 Summary
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 总结
- en: The centralized and decentralized with trustful entity approaches where all
    devices are identified, authenticated and connected through cloud-based servers
    support huge processing and storage capacities. While this model has been used
    for decades to connect standards computing devices and will continue to fit small-scale
    IoT networks [[32]](S0065245818300676.xhtml#bb0165), it severely struggles to
    respond to the growing needs of the huge IoT ecosystems of tomorrow [[33](S0065245818300676.xhtml#bb0170)–[35](S0065245818300676.xhtml#bb0180)]
    for the following reasons.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式和去中心化的信任实体方法是通过云服务器支持巨大的处理和存储容量来识别、验证和连接所有设备的方法。尽管这种模式几十年来一直用于连接标准计算设备，并且将继续适用于小规模的物联网网络[[32]](S0065245818300676.xhtml#bb0165)，但由于以下原因，它严重难以满足明天庞大物联网生态系统的增长需求[[33](S0065245818300676.xhtml#bb0170)–[35](S0065245818300676.xhtml#bb0180)]。
- en: '• Cost: Existing IoT solutions are expensive due to two main reasons: (1) high
    maintenance cost: from the manufacturer''s side, the centralized clouds, large
    server farms, and networking equipment have a high maintenance cost considering
    the distribution of software updates to millions of devices for years after they
    have been long discontinued [[36]](S0065245818300676.xhtml#bb0185). (2) High infrastructure
    cost: the sheer amount of communications that will have to be handled when there
    are tens of billions of IoT devices needs to cater to a very high volume of messages
    (communication costs), data generated by the devices (storage costs), and analytical
    processes (server costs).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 成本：现有的物联网解决方案很昂贵，主要有两个原因：（1）高维护成本：从制造商的角度来看，集中式云、大型服务器农场和网络设备由于在设备停产多年后仍需要分发软件更新而具有高昂的维护成本[[36]](S0065245818300676.xhtml#bb0185)。（2）高基础设施成本：当存在数十亿物联网设备时，需要处理的通信量庞大，需要处理非常大量的消息（通信成本）、设备生成的数据（存储成本）和分析过程（服务器成本）。
- en: '• Bottleneck and single point of failure: cloud servers and farms will remain
    a bottleneck and point of failure that can disrupt the entire network. This is
    particularly important when it is directly tied to critical IoT services such
    as healthcare services.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 瓶颈和单点故障：云服务器和农场将继续是可能导致整个网络中断的瓶颈和故障点。这在它直接与关键物联网服务（如医疗保健服务）紧密联系时尤为重要。
- en: '• Scalability: within the centralized paradigm, cloud-based IoT application
    platforms acquire information from entities located in data acquisition networks,
    and provide raw data and services to other entities. These application platforms
    control the reception of the whole information flow. This enforcement creates
    a bottleneck to scaling the IoT solutions to the exponentially growing number
    of devices and the amount of data generated and processed by those devices (i.e.,
    the concept of “Big Data”).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 可扩展性：在集中式范式中，基于云的物联网应用平台从位于数据采集网络中的实体获取信息，并向其他实体提供原始数据和服务。这些应用平台控制着整个信息流的接收。这种执行创建了一个瓶颈，无法将物联网解决方案扩展到呈指数增长的设备数量以及这些设备生成和处理的数据量（即“大数据”概念）。
- en: '• Insufficient security: The tremendous amount of data collected from millions
    of devices raises information security and privacy concerns for either individuals,
    corporations, or governments. As proven by recent denial-of-service attacks on
    IoT devices [[37]](S0065245818300676.xhtml#bb0190), the huge number of low-cost
    and insecure devices connected to the internet is proving to be a major challenge
    in assuring IoT security.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 安全性不足：从数百万设备收集的大量数据引发了个人、企业或政府的信息安全和隐私担忧。正如最近对物联网设备进行的拒绝服务攻击所证明的那样[[37]](S0065245818300676.xhtml#bb0190)，连接到互联网的大量低成本和不安全的设备正在成为确保物联网安全的主要挑战。
- en: '• Privacy breaches and Lack of transparency: in the centralized models, from
    the consumer''s side, there is an undebatable lack of a trust in service providers
    getting access to data collected by billions of entities creating information.
    There is a need for a “security through transparency” approach allowing users
    to retain their anonymity in this super connected world.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 隐私泄露和缺乏透明度：在集中式模式中，从消费者的角度来看，服务提供商获取数十亿实体收集的数据的行为缺乏可辩驳的信任。在这个超级连接的世界中，需要一种“透明度安全”的方法，允许用户保持匿名。
- en: '3 The solution: Decentralizing IoT networks in trustless way through the blockchain'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 解决方案：通过区块链以无需信任的方式去中心化物联网网络
- en: A decentralized approach to IoT networking would solve many of the centralized
    related issues described above. The concept of a distributed IoT is not novel.
    In fact, many academic and industrial documents consider it as one of the most
    promising approaches that can push the dream of the IoT into the real world. Panikkar
    et al. [[36]](S0065245818300676.xhtml#bb0185) point out the need for a shift toward
    a decentralized architecture for the ever-expanding IoT device ecosystem to be
    sustainable. It has been explicitly mentioned that the development of decentralized
    autonomic architectures and the location of intelligence at the very edge of the
    networks are issues that need to be addressed. We argue that the blockchain provides
    an elegant solution to the aforementioned problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式的物联网网络化方法将解决上述许多与中心化相关的问题。分布式物联网的概念并不新颖。事实上，许多学术和工业文件将其视为将物联网梦想推向现实世界的最有前途的方法之一。Panikkar等人[[36]](S0065245818300676.xhtml#bb0185)指出，对于不断扩大的物联网设备生态系统而言，向去中心化架构转变是可持续的需求。已经明确提到，发展去中心化的自主架构和将智能定位在网络的边缘是需要解决的问题。我们认为，区块链为上述问题提供了一种优雅的解决方案。
- en: '3.1 The blockchain phenomenon: A new wave of decentralization'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 区块链现象：去中心化的新浪潮
- en: Originally introduced by Satoshi Nakamoto in 2008 [[38]](S0065245818300676.xhtml#bb0195)
    to underpin the Bitcoin cryptocurrency network, the blockchain has taken up the
    bulk of technology industry and financial world attention. As a secure and decentralized
    computational infrastructure, it is widely acknowledged as a disruptive and efficient
    solution for the problems of centralization, privacy and security when recording
    tracking, monitoring, managing and sharing not only financial transactions but
    also any other value such as birth and death certificates, marriage licenses,
    deeds and titles of ownership, educational degrees, financial accounts, medical
    procedures, insurance claims, votes, provenance of food, and anything else that
    can be expressed in code [[39](S0065245818300676.xhtml#bb0200)–[41](S0065245818300676.xhtml#bb0210)].
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最初由Satoshi Nakamoto在2008年[[38]](S0065245818300676.xhtml#bb0195)引入，用于支撑比特币加密货币网络，区块链已经吸引了科技行业和金融界的大部分关注。作为一个安全和去中心化的计算基础设施，它被广泛认为是解决中心化、隐私和安全问题的颠覆性和高效的解决方案，用于记录、跟踪、监视、管理和共享不仅仅是金融交易，还包括出生和死亡证明、结婚证书、产权证书、教育学位、金融账户、医疗程序、保险索赔、投票、食品溯源以及任何可以用代码表示的价值[[39](S0065245818300676.xhtml#bb0200)–[41](S0065245818300676.xhtml#bb0210)]。
- en: In this chapter, we focus our study on the public and permissionless type of
    the blockcain. Then, we define this later as a distributed database for transaction
    processing. All transactions in a blockchain are stored into a single ledger.
    The blockchain technology is built on top of four fundamental building blocks,
    each building block has key properties, and each property is achieved through
    specific mechanisms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点研究区块链的公共和无需许可类型。然后，我们将后文定义为用于交易处理的分布式数据库。区块链中的所有交易都存储在单个分类帐中。区块链技术是建立在四个基本构件之上的，每个构件都具有关键属性，并且每个属性都通过特定的机制实现。
- en: 'We consider that the blockchain technology relies on the following building
    blocks as described below:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为区块链技术依赖于以下构件，如下所述：
- en: '(1) Identifying the source and destination of a transaction: in a blockchain
    based ecosystem, users serve from digital identities called “addresses” to send
    and receive transactions. Those addresses should have the following key features:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1) 识别交易的来源和目的地：在基于区块链的生态系统中，用户使用称为“地址”的数字身份来发送和接收交易。这些地址应具备以下关键特征：
- en: '• Self-issued and independent: users should be able to self-generate anonymous
    (e.g., using software) transaction identities (e.g., a cryptographic hash of the
    public-key, in Bitcoin system) in an independent way from any given authority
    (e.g., government, businesses, etc.).'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 自我发行和独立：用户应能够自动生成匿名的（例如使用软件）交易身份（例如，在比特币系统中使用公钥的加密哈希）与任何给定的权威（例如政府、企业等）无关。
- en: '• Anonymous: transaction identities should be anonymous in the sense that it
    reveals nothing about the real identity of its owner to fulfill the needs of user
    privacy, then true anonymity in digital identities requires more than self-issuance
    feature. It requires also the possession of the unlikability and intractability
    features.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 匿名性：交易身份应该是匿名的，即不透露其所有者的真实身份，以满足用户隐私的需求，因此数字身份的真正匿名性需要具备自我发布功能以外的特征。它还需要具备不可链接性和不可追踪性的特征。
- en: '• Privacy-preserving verifiable: any entities in the system should be able
    to verify the security of the digital identity. A publicly verification algorithms
    to validate the source of trust for any given (anonymous) transaction-identity
    is required while preserving the privacy of the owner of the identity.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 保护隐私的可验证性：系统中的任何实体都应能够验证数字身份的安全性。在保护所有者身份隐私的同时，需要一种公开验证算法来验证任何给定（匿名）交易身份的信任来源。
- en: '(2) Transactions: A transaction records the transfer of a value (altcoin) from
    some source address to destination addresses. Transactions are generated by the
    sender and broadcasted the network of peers. Transactions are invalid unless they
    have been recorded in the public history of transactions, the blockchain. Ultimately,
    transaction processing with blockchain technology should satisfy the following
    properties:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (2) 交易：交易记录了价值（代币）从某个源地址到目标地址的转移。交易由发送方生成并广播给对等网络。除非交易已记录在交易的公共历史记录中，即区块链中，否则交易无效。最终，使用区块链技术进行交易处理应满足以下属性：
- en: '• Proprietary: Only the owner who is authorized to perform transactions using
    her own identifying addresses.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 专有：只有授权执行交易的所有者可以使用自己的身份地址。
- en: '• Irreversible: Once transaction has entered the ledger, it should be impossible
    to modify its information, or delete it, which would effectively reverse the transaction.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 不可逆：一旦交易进入账本，就应无法修改其信息或删除它，否则将有效地撤销交易。
- en: '• Publically verifiable: The verification algorithm of a transaction should
    enable any node in the network to verify the validity of the transaction.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 公开可验证：交易的验证算法应使网络中的任何节点能够验证交易的有效性。
- en: '• Immunity: Once a transaction is recorded in the blockchain it cannot be altered
    without that alteration being detected and rejected by the other nodes in the
    network. In addition, if a transaction conforms to a ledger protocol, it should
    be eventually added to the ledger.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 免疫性：一旦交易记录在区块链中，就不能在未被其他节点检测到并拒绝的情况下进行更改。此外，如果交易符合账本协议，它应最终被添加到账本中。
- en: '(3) Condition for auto-processing a transaction: The transfer of any value
    (e.g., altcoins, tokens) with the blockchain or the execution of any function
    through the blockchain should be locked by logic conditions (e.g., low, contract)
    that must be written as a code and automatically executed by nodes in the network.
    This condition should be self-executed.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (3) 自动处理交易的条件：通过区块链传输任何价值（例如，代币）或通过区块链执行任何函数都应受到逻辑条件（例如，合约）的限制，这些条件必须编写为代码并由网络中的节点自动执行。此条件应自动执行。
- en: '(4) Consensus: Every user or node in the network relies on algorithmically
    enforced rules to process transactions with no human interaction required to verify
    in an independent way the correct execution of the protocol and obtains the same
    results. Each node has exactly the same ledger as all of the other users or nodes
    in the network. This ensures a complete consensus from all users or nodes in the
    corresponding currencies blockchain.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (4) 共识：网络中的每个用户或节点都依赖于算法强制执行的规则来处理交易，无需人为干预即可验证协议的正确执行，并获得相同的结果。每个节点的账本与网络中的所有其他用户或节点完全相同。这确保了所有用户或节点在相应货币的区块链中达成完全共识。
- en: 'The blockchain Mechanisms: To satisfy the properties cited above, a suit of
    cryptographic mechanisms has been introduced as explained below and described
    in [Fig. 4](S0065245818300676.xhtml#f0025):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链机制：为了满足上述特性，一套密码学机制已经被引入，如下所述并在[图4](S0065245818300676.xhtml#f0025)中描述：
- en: '![Fig. 4](images/S0065245818300676/f08-04-9780128171899.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图4](images/S0065245818300676/f08-04-9780128171899.jpg)'
- en: Fig. 4 Blockchain's building blocks and mechanisms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4 区块链的构建模块和机制。
- en: 'Public key cryptography: enables a self-issued, pseudonymous and a privacy-preserving
    identification. Digital signature: is used to satisfy the feature of transaction
    proprietary and publically verifiable properties: Each user in the system possesses
    at least a pair of private and public keys; the public key is published publically
    to determine the digital identity, while the private key is used to sign the corresponding
    transaction by it owner (or a trusted party on her behalf).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学：实现了自行颁发的、匿名的、且保护隐私的身份识别。数字签名：用于满足交易的专有性和公开可验证属性：系统中的每个用户至少拥有一对私钥和公钥；公钥公开发布用于确定数字身份，而私钥用于由其所有者（或代表其的值得信赖的方）签署相应的交易。
- en: • The validity of the signature is tied to the knowledge of the sender's private
    key (proprietary)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 签名的有效性与发送者私钥的掌握有关（专有）
- en: • A signature can be verified by anyone knowing the sender's public key (publically
    verifiable)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 任何知道发送者公钥的人都可以验证签名（公开可验证）
- en: • A signature is invalidated if any parameters of the transaction are changed.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 如果交易的任何参数发生改变，签名将无效。
- en: 'Hash function [[42]](S0065245818300676.xhtml#bb0215) and Merkle tree [[43]](S0065245818300676.xhtml#bb0220):
    are used to solve the problem of Immutability, irreversibility and public verification
    of transactions in blockchain systems. Those features are achieved by distributing
    transactions into time-ordered blocks and time stamping each of these blocks by
    its cryptographic hash.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数[[42]](S0065245818300676.xhtml#bb0215)和默克尔树[[43]](S0065245818300676.xhtml#bb0220)：用于解决区块链系统中交易的不可变性、不可逆转性和公开验证的问题。将交易分布到时间顺序块中，并通过其密码哈希对每个块进行时间戳，从而实现了这些特性。
- en: Transactions are summarized in each block using a Merkle tree, also known as
    a binary hash tree. It is an efficient data structure that serves to summarize
    and verify the integrity of large sets of data. Organizing blocks in an ordered
    chain called (blockchain), where each block refers to the previous one, is a clever
    technique introduced by Nakamoto to make it infeasible to delete or replace the
    whole blocks. To simplify blockchain verification, key block parameters (such
    as a Merkle root) are collected in a block header. Thus, providing immutability
    of transactions is equivalent to providing immutability of block headers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 交易使用默克尔树（Merkle tree），也称为二进制哈希树，在每个块中进行总结。它是一种有效的数据结构，用于总结和验证大量数据的完整性。将块组织成有序链（区块链），其中每个块都指向前一个块，是中本聪引入的一种巧妙技术，使得删除或替换整个块变得不可行。为了简化区块链的验证，关键块参数（如默克尔根）被收集在块头中。因此，提供交易的不可变性等同于提供区块头的不可变性。
- en: The Immunity feature of transactions is achieved through the properties of hashing
    functions. Actually, any alteration in the transaction results in changes in the
    Merkle root of the block, which is a part of its header. Hence, to change a single
    block, an attacker must also change all succeeding blocks in the ledger which
    is infeasible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的不可变性特性是通过哈希函数的属性实现的。实际上，交易中的任何更改都会导致块的默克尔根发生变化，而默克尔根是其头部的一部分。因此，要更改单个块，攻击者还必须更改分类帐中的所有后续块，这是不可行的。
- en: 'Proof of X where X ∈ (Work/stack/Space etc.) consensus protocols: Once the
    transactions have been created, it is broadcasted in the network and each node
    verifies independently the received transaction and includes it in a block. However,
    each node may have different view of the blockchain leading to a divergence of
    branches of a blockchain. To mitigate this problem, there is a need of a distributed
    mechanism to reach consensus among the untrusted participants in the network.
    This problem is historically known as “Byzantine Generals” (BG) Problem, which
    was raised in ref. [[44](S0065245818300676.xhtml#bb0225)]. Reaching consensus
    in distributed environment is a challenging task. Actually, the consensus of the
    network could be achieved in a variety of ways, including proof of work (e.g.,
    as used in Bitcoin), proof of stake (e.g., Nxt), delegated proof of stake (e.g.,
    BitShares) and Practical byzantine fault tolerance (hyper ledger project). For
    more details, we refer the reader to a comprehensive survey of those four approaches
    in refs. [[45](S0065245818300676.xhtml#bb0230), [46](S0065245818300676.xhtml#bb0235)].'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在（工作/堆栈/空间等）共识协议中证明 X 的方法：一旦交易被创建，就会在网络中广播，并且每个节点都会独立验证收到的交易并将其包含在一个区块中。然而，每个节点可能对区块链有不同的视图，导致区块链的分支发散。为了缓解这个问题，在网络中需要一种分布式机制来在不信任的参与者之间达成共识。这个问题在历史上被称为“拜占庭将军”（BG）问题，这在文献中提出过[[44](S0065245818300676.xhtml#bb0225)]。在分布式环境中达成共识是一项具有挑战性的任务。实际上，网络的共识可以通过多种方式实现，包括工作证明（例如比特币中使用的方式）、权益证明（例如
    Nxt）、委托权益证明（例如 BitShares）和实用拜占庭容错（超级账本项目）。有关更多详细信息，我们建议读者参考这四种方法的全面调查文献[[45](S0065245818300676.xhtml#bb0230),
    [46](S0065245818300676.xhtml#bb0235)]。
- en: 'SmartContract/scripting language: are used to satisfy the auto-processing properties.
    The scripting language describes the execution of a certain program on a stack
    machine. Each transaction contains a script which locks, or encumbers, the value
    transferred by this transaction. A script is a part of each input and each output
    of a transaction. When we generalize this scripting language computation to arbitrary
    Turing complete logic, we obtain an expressive smart contract system. The interest
    in smart contract applications steadily risen since 2014 due to the appearance
    of Bitcoin-like technologies, such as Ethereum [[47]](S0065245818300676.xhtml#bb0240)
    and many other works designed specifically to decentralized smart contract system.
    SmartContracts are self-executed cryptographic “boxes” that are stored in the
    blockchain and contain value only unlocked if certain conditions are met.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约/脚本语言：用于满足自动处理属性。脚本语言描述了在堆栈机器上执行某个程序的过程。每个交易包含一个脚本，该脚本锁定或附加了该交易转移的价值。脚本是每个交易的输入和输出的一部分。当我们将这种脚本语言计算推广到任意图灵完备逻辑时，我们就得到了一个富有表现力的智能合约系统。自2014年以来，对智能合约应用的兴趣稳步增长，这是因为出现了类似比特币的技术，如以太坊[[47]](S0065245818300676.xhtml#bb0240)和许多其他专门设计用于分散式智能合约系统的工作。智能合约是存储在区块链中的自执行的加密“盒子”，只有在满足某些条件时才能解锁其中的价值。
- en: 3.2 Why the blockchain as a solution
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 为什么选择区块链作为解决方案
- en: The Blockchain technology and IoT offer a new world of promise and fascinating
    possibilities. Actually, the decentralized, autonomous, and trustless inherent
    capabilities of the blockchain make it an ideal component to become a foundational
    element of IoT solutions. It can potentially improve the IoT sector [[48]](S0065245818300676.xhtml#bb0245),
    and significantly help in achieving the vision of decentralized [[49]](S0065245818300676.xhtml#bb0250)
    and private-by-design IoT [[50]](S0065245818300676.xhtml#bb0255).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术和物联网提供了一个充满希望和迷人可能性的新世界。实际上，区块链的去中心化、自治和无需信任的固有能力使其成为物联网解决方案的基础组成部分的理想选择。它有可能改善物联网行业[[48]](S0065245818300676.xhtml#bb0245)，并显著有助于实现去中心化[[49]](S0065245818300676.xhtml#bb0250)和私有设计的物联网[[50]](S0065245818300676.xhtml#bb0255)的愿景。
- en: 'The following salient features of the blockchain, illustrated in [Fig. 5](S0065245818300676.xhtml#f0030),
    make it an attractive technology for addressing the aforementioned security and
    privacy challenges in IoT:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的以下显著特点，如图[5](S0065245818300676.xhtml#f0030)所示，使其成为解决物联网中上述安全性和隐私挑战的理想技术：
- en: '• Decentralization and trustlessness: The lack of central control ensures scalability
    and robustness by using resources of all participating nodes and eliminating many-to-one
    traffic flows, which in turn decreases delay and overcomes the problem of a single
    point of failure.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 去中心化和无需信任：缺乏中央控制确保了通过使用所有参与节点的资源并消除多对一的流量流向来实现可伸缩性和健壮性，从而减少了延迟并克服了单点故障的问题。
- en: • Append-only. The major design goal of the blockchain is to make it such that
    deleting information from the blockchain (i.e., reversing transactions) is impossible
    or at least prohibitively expensive.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 追加方式。区块链的主要设计目标是使得从区块链中删除信息（即，撤销交易）是不可能的，或者至少成本过高。
- en: '• Pseudo-anonymity: The inherent anonymity afforded is well-suited for most
    IoT use cases where the identity of the users must be kept private.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 伪匿名性：所提供的固有匿名性非常适合大多数物联网用例，其中用户的身份必须保密。
- en: '• Transparency: Each node in the network can independently verify the current
    state of the ledger and arrive to the same conclusion as the rest of the network.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 透明性：网络中的每个节点都可以独立验证分类帐的当前状态，并得出与网络其余部分相同的结论。
- en: '• Cryptography model: The trust in the blockchain does not arise from an authority
    maintaining the ledger, but rather from the mathematical soundness of the cryptographic
    protocols used in the system and a prohibitive economic cost of an attack.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 密码学模型：对区块链的信任不是来自维护分类帐的权威，而是来自系统中使用的密码协议的数学合理性和攻击的经济成本的限制。
- en: '![Fig. 5](images/S0065245818300676/f08-05-9780128171899.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 5](images/S0065245818300676/f08-05-9780128171899.jpg)'
- en: Fig. 5 The benefits of combining the blockchain with IoT.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5 结合区块链与物联网的好处。
- en: 'However, adopting the blockchain to handle authorization functions in IoT is
    not straightforward and will require addressing the following critical challenges:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，采用区块链处理物联网中的授权功能并不直接，需要解决以下关键挑战：
- en: • The public nature of the blockchain versus the private aspect of access control
    policies
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 区块链的公共性与访问控制策略的私密性
- en: • Tractability problem
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 可解性问题
- en: • Consensus process is particularly computationally intensive, time consuming
    while the majority of IoT devices are resource restricted and most IoT applications
    low latency is desirable.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 共识过程特别是在计算上密集，耗时，而大多数物联网设备资源受限，大多数物联网应用程序需要低延迟。
- en: 'The previously defined problem statement leads to the following research questions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 先前定义的问题陈述导致以下研究问题：
- en: 1 How to solve access control challenges in IoT by leveraging the public and
    permissionless blockchain technology?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 如何通过利用公共且无许可的区块链技术解决物联网中的访问控制挑战？
- en: 2 How to provide a lightweight access control framework for constrained IoT
    devices despite the intensive computation power required by the consensus protocol
    adopted in the public blockchain?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 如何为受限制的物联网设备提供轻量级访问控制框架，尽管公共区块链中采用的共识协议需要大量计算资源？
- en: 3 How to enable a privacy preserving access control solution that hides user's
    access control policy and overcomes the problem of traceability and profiling
    commonly known in the public blockchain?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 如何实现隐私保护的访问控制解决方案，隐藏用户的访问控制策略，并解决公共区块链中常见的可追踪性和个人资料问题？
- en: '4 FairAccess: Using blockchain technology as access control infrastructure'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 FairAccess：使用区块链技术作为访问控制基础设施
- en: 'To answer the aforementioned questions, we propose a framework composed of
    two main modules that are: FairAccess and PPDAC as shown in [Fig. 6](S0065245818300676.xhtml#f0035).
    In the next section we will give an overview and brief description of the both
    protocols.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答上述问题，我们提出了一个由两个主要模块组成的框架，即 FairAccess 和 PPDAC，如 [图 6](S0065245818300676.xhtml#f0035)
    所示。在下一节中，我们将概述并简要描述这两个协议。
- en: '![Fig. 6](images/S0065245818300676/f08-06-9780128171899.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 6](images/S0065245818300676/f08-06-9780128171899.jpg)'
- en: Fig. 6 Our proposed solution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6 我们提出的解决方案。
- en: '4.1 FairAccess: Using blockchain technology as an access control infrastructure'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 FairAccess：使用区块链技术作为访问控制基础设施
- en: FairAccess [[25](S0065245818300676.xhtml#bb0130), [51](S0065245818300676.xhtml#bb0260)]
    is a new distributed access control framework based on Blockchain technology that
    has combined, for the first time, access control models and cryptocurrency blockchain
    mechanisms. In FairAccess, we propose the use of SmartContract [[47]](S0065245818300676.xhtml#bb0240)
    to express fine-grained and contextual access control policies to make authorization
    decisions. We opt for authorization tokens as an access control mechanism, delivered
    through emergent cryptocurrency solutions. We use blockchain to ensure enforcing
    access policies in distributed environments where there is no central authority/administrator,
    and guarantee that policies will be properly implemented by all interacting entities
    ([Fig. 7](S0065245818300676.xhtml#f0040)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: FairAccess [[25](S0065245818300676.xhtml#bb0130), [51](S0065245818300676.xhtml#bb0260)]
    是基于区块链技术的新型分布式访问控制框架，首次将访问控制模型和加密货币区块链机制结合起来。在 FairAccess 中，我们提议使用 SmartContract
    [[47]](S0065245818300676.xhtml#bb0240) 来表达细粒度和上下文访问控制策略，以做出授权决策。我们选择授权令牌作为访问控制机制，通过新兴的加密货币解决方案进行交付。我们使用区块链来确保在没有中央权威/管理员的分布式环境中执行访问策略，并保证所有交互实体都能正确实施策略（[图
    7](S0065245818300676.xhtml#f0040)）。
- en: '![Fig. 7](images/S0065245818300676/f08-07-9780128171899.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 7](images/S0065245818300676/f08-07-9780128171899.jpg)'
- en: Fig. 7 FairAccess's building blocks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7 FairAccess 的构建模块。
- en: 'Authorization token: In our FairAccess framework, we define an Authorization
    Token as a data structure that represents the access right or the entitlement
    defined by the creator of the SmartContract, generating the authorization token,
    to the entity interacting with this SmartContract in order to access a specific
    resource identified by its address. If the authorization token presented by the
    device was delivered by a SmartContract that matches with the one that is associated
    with the other device or service that manages that device, then the access is
    granted. Actually, the token-based access control enforced by the blockchain technology
    provides many advantages in IoT context. Actually, having the token securely held
    on the blockchain means smart devices can easily verify the validity of the access
    token relieving IoT constrained devices from the burden of handling a vast amount
    of access control-related information and at the same time mitigates the need
    for outsourcing these functionalities to a trusted powerful entity that prevents
    end-to-end security to be achieved. Moreover, it reduces communication cost, since
    no further authentication mechanisms are required to get the token since only
    signature is sufficient. Similarly, the resource owner can manage and update access
    to his numerous and heterogeneous devices by placing a resource hash of the requested
    data on the blockchain. Then the device can read the hash and check the update
    access control configurations. This hash can be updated with every new connection
    to the blockchain. This could enable easier management and updating of access
    control policies if the access control logics would be located in the device side,
    especially for devices that are placed in unreachable or hardly attended location
    such as a smart parking systems, where devices may be embedded directly in the
    asphalt. In addition, the token could be used for many access control operations
    such as getting, delegating, revoking and even updating access in an easier and
    flexible way.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 授权令牌：在我们的FairAccess框架中，我们将授权令牌定义为一种数据结构，表示由智能合约的创建者定义的访问权限或权利，生成授权令牌，以便与此智能合约进行交互的实体访问由其地址标识的特定资源。如果设备呈现的授权令牌是由与管理该设备的其他设备或服务关联的智能合约提供的，则访问将被授予。实际上，区块链技术强制执行的基于令牌的访问控制在物联网环境中提供了许多优势。实际上，在区块链上安全保存令牌意味着智能设备可以轻松验证访问令牌的有效性，从而减轻了物联网受限设备处理大量与访问控制相关信息的负担，同时减少了将这些功能外包给可信强大实体的需要，从而阻止了端到端安全性的实现。此外，它减少了通信成本，因为获取令牌只需要签名而不需要进一步的身份验证机制。同样，资源所有者可以通过在区块链上放置所请求数据的资源哈希来管理和更新他的众多和异构设备的访问权限。然后，设备可以读取哈希并检查更新的访问控制配置。该哈希可以随着与区块链的每次新连接而更新。如果访问控制逻辑位于设备端，特别是对于放置在难以到达或几乎无人关注的位置的设备，例如智能停车系统中直接嵌入沥青中的设备，这可能会使访问控制策略的管理和更新变得更加容易。此外，令牌可以用于许多访问控制操作，例如更轻松灵活地获取、委托、撤销甚至更新访问。
- en: 'Blockchain: FairAccess provides several useful mechanisms using the blockchain.
    In fact, in FairAccess, the blockchain is considered as a database or a policy
    retrieval point where all access control policies are stored in form of transactions;
    it serves also as logging databases that ensure auditing functions. Furthermore,
    it prevents forgery of token through transactions integrity checks and detects
    token reuse through the double spending detection mechanism.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链：FairAccess 使用区块链提供了几种有用的机制。实际上，在 FairAccess 中，区块链被视为数据库或策略检索点，所有访问控制策略都以交易形式存储；它还充当日志数据库，确保审计功能。此外，它通过交易完整性检查防止令牌伪造，并通过双重支付检测机制检测令牌重复使用。
- en: 'SmartContract: The SmartContract has its own account on the blockchain, and
    the blockchain supports an account-based model [[47]](S0065245818300676.xhtml#bb0240).
    It allows us to express logic functions in code. It operates as autonomous actors,
    whose behavior is completely predictable. As such they can be trusted to drive
    forward any on-chain logic that can be expressed as a function of on-chain data
    inputs, provided that the data they need to manage are within their own reach
    (in the example above, the contract would not be able to trade assets that it
    did not own). In addition, its code can be inspected by every network participant
    since all the interactions with a contract occur via signed messages on the blockchain,
    all the network participants get a cryptographically verifiable trace of the contract''s
    operations.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约：智能合约在区块链上有自己的账户，而区块链支持基于账户的模型[[47]](S0065245818300676.xhtml#bb0240)。它允许我们在代码中表达逻辑功能。它作为自主的参与者运行，其行为完全可预测。因此，它们可以被信任驱动任何可以表达为对链上数据输入函数的链上逻辑向前推进，只要它们需要管理的数据在它们自己的范围内（在上面的示例中，合同将无法交易它不拥有的资产）。此外，由于所有与合同的交互都通过区块链上的签名消息进行，所有网络参与者都可以检查其代码，所有与合同的交互都可以得到加密可验证的合同操作的痕迹。
- en: This enables our framework to express fine grained access control policies.
    Actually, a policy is a set of rules and conditions (based on a specific context
    or attribute, etc.) that a requester entity has to fulfill in order to obtain
    the Access Token and gets access to the specific resource. This rules could be
    expressed by any access control model but must be transformed to a script language
    considered as locking script placed on the output of a transaction. Fortunately,
    new blockchain protocols are being developed including full Turing completeness
    capability, allowing anyone to write smart contracts and decentralized applications
    with their own arbitrary rules for ownership, transaction formats and state transition
    functions [[47]](S0065245818300676.xhtml#bb0240). The use of those advanced languages,
    such as Ethereum, will certainly enable our FairAccess framework to express fine-grained
    context-aware access control policies. We believe that SmartContracts are a promising
    emergent field to express, granular, contextual and contractual access control
    model in general and in IoT in particular.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的框架能够表达细粒度的访问控制策略。实际上，策略是一组规则和条件（基于特定上下文或属性等），请求者实体必须满足才能获得访问令牌并访问特定资源。这些规则可以由任何访问控制模型表示，但必须转换为被视为锁定脚本的脚本语言，放置在交易输出上。幸运的是，正在开发新的区块链协议，包括完全的图灵完备性能力，允许任何人编写智能合约和具有自己任意规则的分散应用程序，用于所有权、交易格式和状态转换功能[[47]](S0065245818300676.xhtml#bb0240)。使用这些高级语言，如以太坊，肯定会使我们的FairAccess框架能够表达细粒度的上下文感知访问控制策略。我们相信智能合约是一个有前途的新兴领域，可以用来表达一般和特别是在物联网中的细粒度、上下文和合同访问控制模型。
- en: 4.2 FairAccess's architecture
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 FairAccess的架构
- en: The vision of our decentralized access control framework is a system of autonomous
    organizations hinged around one or many Resource Owners in possession of one or
    many resources identified with addresses and interacting between each other through
    transactions (requesting, granting, delegating and revoking access) under the
    control of their RO. The blockchain is a ledger keeping track and ensures the
    validity of access transaction among interacting organization. Each manages its
    own access policy, under only the control of his Resource Owner, resulting in
    an “Internet of Decentralized, Autonomous Organization” and thus the fairness
    of our access control framework ([Fig. 8](S0065245818300676.xhtml#f0045)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分散式访问控制框架的愿景是一个围绕一个或多个资源所有者的自治组织系统，其拥有一个或多个资源，这些资源被识别为具有地址，并通过交易（请求、授予、委派和撤销访问）在彼此之间进行交互，在其RO的控制下。区块链是一个记录和确保交互组织之间访问交易有效性的分类帐。每个组织都管理自己的访问策略，只受其资源所有者的控制，从而产生了一个“分散自治组织的互联网”，因此我们的访问控制框架的公平性（[图8](S0065245818300676.xhtml#f0045)）。
- en: '![Fig. 8](images/S0065245818300676/f08-08-9780128171899.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图8](images/S0065245818300676/f08-08-9780128171899.jpg)'
- en: Fig. 8 FairAccess's architecture overview.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 FairAccess的架构概述。
- en: 'Considering the following scenario, see [Fig. 9](S0065245818300676.xhtml#f0050),
    where a subject (e.g., a device A, identified with the address rq) wants to perform
    an action (e.g., modify) on a protected resource (e.g., Device B temperature,
    identified with address rs). We assume that the requester already knows the access
    control policy regulating access to Device B. FairAccess workflow is as follow:
    the Rq fulfills the conditions specified in the access control policy and submits
    his request through his wallet in form of a RequestAccess Transaction. Afterword,
    the wallet broadcasts this transaction to the network nodes till it reaches miners.
    Those later act as distributed Policy Decision Point (dPDP), and evaluate the
    transaction and check the request with the defined policy, by executing a PolicyContract
    already deployed, by the owner of Device B, in the blockchain through a previous
    transaction called GrantAccess. The execution of PolicyContract determines whether
    the request should be permitted or denied. Finally, if it is being successfully
    executed, the PolicyContract generates and assigns an authorization token to the
    requester address through an AllowAccess transaction. Then the authorization token
    is recorded in the blockchain and appears in the requester''s authorization token
    list. Finally, the requester presents the authorization token to the end device
    through a GetAccess Transaction. The end device B checks the validity of the authorization
    token by referring to the blockchain; if this authorization token was delivered
    by the SmartContract corresponding to the device B, it allows access else it denies.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 9](images/S0065245818300676/f08-09-9780128171899.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Fig. 9 FairAccess workflow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The faced challenges
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FairAccess has successfully achieved the following IoT''s security and privacy-preserving
    requirements, fixed in the beginning of this chapter, that are: (1) Distributed
    nature and the lack of a central authority. User-driven and transparency. (2)
    Lightweightness. (3) Fine-granularity. (4) Identification enabling thing to thing
    interaction. (5) Pseudonymity and Unlikability. However, adopting the blockchain
    technology to handle access control functions is not straightforward and additional
    critical issues emerge that are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: FairAccess已成功实现了本章开头所述的以下物联网安全和隐私保护要求，即：（1）分布式性质和缺乏中央权威。用户驱动和透明度。 （2）轻量级。 （3）细粒度。
    （4）使物联网设备之间的交互成为可能。 （5）假名和不可追溯性。然而，采用区块链技术处理访问控制功能并不简单，会出现额外的关键问题：
- en: '(1) The public and transparent aspect of the blockchain comes at odds with
    the private aspect of access control policies publically recorded in the blockchain:
    Often times, the policies for determining who can access the resources are sensitive
    also and need protection as well.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1) 区块链的公开和透明方面与公开记录在区块链上的访问控制策略的私密性相冲突：通常，确定谁可以访问资源的策略也是敏感的，需要保护。
- en: (2) Traceability issue such as the structure of the transaction graph [[52](S0065245818300676.xhtml#bb0265),[53]](S0065245818300676.xhtml#bb0270)
    as well as the value and dates of transactions may conduct to learning devices
    authorization functionality pattern, as well as if a particular device is trying
    to communicate with other devices
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (2) 追溯问题，例如交易图的结构[[52](S0065245818300676.xhtml#bb0265)，[53]](S0065245818300676.xhtml#bb0270)，以及交易的价值和日期，可能会导致学习设备授权功能模式，以及某个特定设备是否试图与其他设备通信。
- en: '5 Toward privacy through transparency: A privacy-preserving distributed access
    control (PPDAC) scheme to enhance privacy and anonymity in FairAccess'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 通过透明度实现隐私：一种隐私保护的分布式访问控制（PPDAC）方案，以增强FairAccess中的隐私和匿名性。
- en: In this section we will show how to overcome those two identified challenges
    by introducing PPDAC as a fully anonymous Privacy-Preserving Distributed Access
    Control scheme (PPDAC) to be integrated over FairAccess. PPDAC provides a strong
    privacy guarantees access control scheme that preserves the resource owner's access
    control policies and the requester's sensitive attributes and then preserves in
    a strong way the anonymity of both the requester and the Resource owner, see [Fig.
    10](S0065245818300676.xhtml#f0060). The proposed scheme aims to maintain Blockchain
    transparency features while ensuring strong privacy guarantees for users. We develop
    a policy-hiding access control scheme that protects both sensitive attributes
    and sensitive policies. That is, nodes in the public blockchain can decide whether
    Alice's certified attribute values satisfy Bob's policy, without learning any
    other information about Alice's attribute values nor Bob's policy. To enable policy-hiding
    access control, and untraceability of authorization tokens, our construction for
    PPDAC uses a novel technique that combines a white box distributed multi-authority
    CP-ABE [[54](S0065245818300676.xhtml#bb0275),[55]](S0065245818300676.xhtml#bb0280),
    zk-SNARKs [[56]](S0065245818300676.xhtml#bb9000) protocols and SmartContract ([Fig.
    11](S0065245818300676.xhtml#f0055)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '本节将介绍如何通过引入PPDAC作为完全匿名的隐私保护分布式访问控制方案（PPDAC）来克服这两个确定的挑战，并将其集成到FairAccess中。 PPDAC提供了一种强大的隐私保证访问控制方案，保留了资源所有者的访问控制策略和请求者的敏感属性，然后以强大的方式保护了请求者和资源所有者的匿名性，参见[图10](S0065245818300676.xhtml#f0060)。该方案旨在保持区块链的透明特性，同时确保用户的强大隐私保证。我们开发了一个政策隐藏的访问控制方案，既保护了敏感属性，又保护了敏感策略。也就是说，在公共区块链中的节点可以决定Alice的认证属性值是否满足Bob的策略，而不了解Alice的属性值或Bob的策略的任何其他信息。为了实现政策隐藏的访问控制和授权令牌的不可追踪性，我们构建PPDAC的方法使用了一种新颖的技术，结合了白盒分布式多权威CP-ABE
    [[54](S0065245818300676.xhtml#bb0275),[55]](S0065245818300676.xhtml#bb0280), zk-SNARKs
    [[56]](S0065245818300676.xhtml#bb9000) 协议和智能合约（[图11](S0065245818300676.xhtml#f0055)）。  '
- en: '![Fig. 10](images/S0065245818300676/f08-11-9780128171899.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图10](images/S0065245818300676/f08-11-9780128171899.jpg)'
- en: Fig. 10 PPDAC buildings blocks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10 PPDAC 构建模块。
- en: '![Fig. 11](images/S0065245818300676/f08-10-9780128171899.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图11](images/S0065245818300676/f08-10-9780128171899.jpg)'
- en: Fig. 11 PPDAC based technologies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图11 基于PPDAC的技术。
- en: 5.1 PPDAC building blocks
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 PPDAC 构建模块
- en: 'In a traditional CP-ABE scheme, an encryptor can encrypt data with a hidden
    access structure. A decryptor obtains his secret key associated with his attributes
    from a certifying authority in advance and if the attributes associated with the
    decryptor''s secret key do not satisfy the access structure associated with the
    encrypted data, the decryptor cannot decrypt the data or even guess what access
    structure was specified by the encryptor. In our setting, due to the fact that
    our framework is built on a public blockchain, the aim to use the CP-ABE technique
    is not to decrypt data as it was introduced in the literature, but instead to
    ensure two properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 CP-ABE 方案中，加密器可以使用隐藏的访问结构加密数据。解密器预先从认证机构获取与其属性相关联的秘密密钥，如果解密器的秘密密钥相关联的属性不满足与加密数据相关联的访问结构，则解密器无法解密数据，甚至无法猜测加密器指定的访问结构是什么。在我们的设置中，由于我们的框架建立在公共区块链上，使用
    CP-ABE 技术的目的不是像文献中介绍的那样解密数据，而是确保两个属性：
- en: 1. Hiding the RO access control policies in the blockchain network
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 在区块链网络中隐藏 RO 访问控制策略
- en: '2. Enabling the requester to prove, in a public way to the network (miners),
    that his hidden attributes fit the hidden policies. For this purpose, we introduce
    two new notions:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 启用请求者以公开方式向网络（矿工）证明其隐藏属性符合隐藏策略。为此，我们引入了两个新概念：
- en: 'A challenge: is an arbitrary string chosen at random by the resource owner
    and encrypted to get a ciphertext CT. It is considered as a proof of access control
    policy fulfillment used by the requester to prove, in a public way, to the blockchain
    network, his fulfillment of access control policy without revealing his attribute
    nor the access control policy, since the evaluation of access control policy is
    reduced to the ability of the requester to decrypt the ciphertext CT and obtain
    the publically known challenge. Actually, the requester will be able to decrypt
    the cipher text CT if and only if his attributes match with the hidden access
    structure.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战：是由资源所有者随机选择的任意字符串，并加密以获得密文 CT。它被视为请求者以公开方式向区块链网络证明其满足访问控制策略的证据，而不暴露其属性或访问控制策略，因为访问控制策略的评估被简化为请求者解密密文
    CT 并获取公开已知的挑战的能力。实际上，仅当请求者的属性与隐藏的访问结构匹配时，请求者才能解密密文 CT。
- en: 'An identity key (IDkey): in our setting, we introduce the notion of IDkey which
    plays the same role of a private key, but it is public. This IDkey holds the features
    of a cryptocurrency coin. The IDkey should fulfill three important properties:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 身份密钥（IDkey）：在我们的设置中，我们引入了 IDkey 的概念，它扮演着私钥的同等角色，但是它是公开的。这个 IDkey 拥有加密货币币的特征。IDkey
    应该满足三个重要属性：
- en: '• Anonymous: in the sense that it reveals no information about the real identity
    of his owner. Untraceable: we cannot guess the origin who sends the token to the
    blockchain. We acheive the anonymity and untraceability of IDkey using the zero-knowledge
    Succinct Non-interactive ARguments of Knowledge (zk-SNARKs) by hiding the origin
    of transaction spending the IDkey.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 匿名性：指不透露所有者的真实身份信息。不可追踪性：我们无法猜测将令牌发送到区块链的原始来源。我们通过使用零知识的 Succinct Non-interactive
    ARguments of Knowledge（zk-SNARKs）来隐藏花费 IDkey 的交易的起源，从而实现 IDkey 的匿名性和不可追踪性。
- en: '• Usage is controlled by the owner: We argue that the identity token IDkey,
    which is cryptographically secured by the blockchain as a coin, could not be secret,
    since the usage of this identity token is restricted to his owner or ceded under
    his consentement. To achieve this property, we will “tie” the usage of an IDkey
    to spending an associated IDcoin which is, at its turn, controlled by the possession
    of a private key only known by the owner.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用由所有者控制：我们认为，由区块链作为硬币加密保护的身份令牌 IDkey 不可能是秘密的，因为此身份令牌的使用仅限于其所有者或在其同意下被让渡。为了实现这一属性，我们将
    IDkey 的使用“绑定”到消耗相关的 IDcoin 上，而该 IDcoin 又是由所有者私钥控制的。
- en: 'Our protocol runs between the following entities: a Resource owner (RO) who
    owns IoT device (D), one or many requesters that could be service providers the
    (RO) wants to collaborate with to get smart services over his device. A set of
    authorities responsible for certifying a set of attributes'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协议在以下实体之间运行：一个拥有物联网设备（D）的资源所有者（RO），一个或多个请求者，他们可能是 RO 想要与之合作以获得其设备上智能服务的服务提供商。负责认证一组属性的一组权威机构。
- en: '• Certifying authorities: the certifying authorities are trusted and manage
    their attributes set in an independent way.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 认证机构：认证机构是受信任的，并以独立的方式管理其属性集。
- en: '• FairAccess node: A FairAccess node is equivalent to the role of miners. We
    suppose that those nodes are honest but curious. Hence, not only the identity
    of interacting entities should be anonymous but also the access control policy
    held in SmartContract should be hidden.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • FairAccess 节点：FairAccess 节点相当于矿工的角色。我们假设这些节点是诚实但好奇的。因此，不仅交互实体的身份应匿名，而且智能合约中保存的访问控制策略也应该是隐藏的。
- en: '• Ro: the resource owner is responsible for defining an access control policy
    over his devices and obfuscating this access control policy inside a SmartContract
    using decentralized multi-authority CP-ABE with hidden policy. Then he deploys
    the SmartContract to the network.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 资源所有者（Ro）负责定义他的设备上的访问控制策略，并使用具有隐藏策略的分散式多权威 CP-ABE（基于属性的加密）将此访问控制策略模糊化在智能合约中。然后他将智能合约部署到网络上。
- en: '• Requester: the certifying authorities generates relevant IDkeys for each
    requester. Furthermore, only requesters who''s IDkeys satisfy the access control
    policy get an authorization token.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 请求者：认证机构为每个请求者生成相关的 IDkeys。此外，只有符合访问控制策略的请求者才会获得授权令牌。
- en: 5.2 PPDAC phases and functionalities
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 PPDAC 阶段和功能
- en: 'The proposed protocol divides the interaction between parties into five phases
    as follows: a set up phase, a Grant Access phase, a RequestAccess phase, a GetAccess
    phase, an evaluating access control policy phase and an AllowAccess phase ([Figs.
    12](S0065245818300676.xhtml#f0065)–[14](S0065245818300676.xhtml#f0085)).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的协议将参与方的交互分为五个阶段：设置阶段、授予权限阶段、请求权限阶段、获取权限阶段、评估访问控制策略阶段和允许访问阶段（[图 12](S0065245818300676.xhtml#f0065)–[14](S0065245818300676.xhtml#f0085)）。
- en: '![Fig. 12](images/S0065245818300676/f08-12-9780128171899.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 12](images/S0065245818300676/f08-12-9780128171899.jpg)'
- en: Fig. 12 PPDAC's phases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12 PPDAC 的阶段。
- en: '![Fig. 13](images/S0065245818300676/f08-13-9780128171899.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 13](images/S0065245818300676/f08-13-9780128171899.jpg)'
- en: Fig. 13 Hiding the private access control policies inside the public blockchain.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13 将私有访问控制策略隐藏在公共区块链中。
- en: '![Fig. 14](images/S0065245818300676/f08-16-9780128171899.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 14](images/S0065245818300676/f08-16-9780128171899.jpg)'
- en: Fig. 14 Unlinkability and intractability of authorization tokens.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14 授权令牌的不可链接性和不可解性。
- en: 5.3 Background and definitions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 背景和定义
- en: To construct the PPDAC scheme, the following building blocks and definitions
    are adopted.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建PPDAC方案，采用以下基本组成部分和定义。
- en: 5.3.1 Pseudorandom function
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1 伪随机函数
- en: Definition 1\. Collision-resistant hashing
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 1\. 抗碰撞哈希
- en: We use a collision-resistant hash function
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用抗碰撞哈希函数
- en: <math><mi>CRH</mi><mo>:</mo><msup><mfenced close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></math>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi>CRH</mi><mo>:</mo><msup><mfenced close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></math>
- en: '![si1_e](images/S0065245818300676/si1_e.png)  (1)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![si1_e](images/S0065245818300676/si1_e.png)  (1)'
- en: Definition 2\. Pseudorandom functions
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 2\. 伪随机函数
- en: We use a pseudorandom function family PRF
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用伪随机函数系列 PRF
- en: <math><mi>PRF</mi><mo>=</mo><msub><mfenced close="}" open="{"><mrow><msub><mi>PRF</mi><mi
    mathvariant="normal">λ</mi></msub><mo>:</mo><msup><mfenced close="}" open="{"
    separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></mrow></mfenced><mi mathvariant="normal">λ</mi></msub></math>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi>PRF</mi><mo>=</mo><msub><mfenced close="}" open="{"><mrow><msub><mi>PRF</mi><mi
    mathvariant="normal">λ</mi></msub><mo>:</mo><msup><mfenced close="}" open="{"
    separators=","><mn>0</mn><mn>1</mn></mfenced><mo>∗</mo></msup><mo>→</mo><msup><mfenced
    close="}" open="{" separators=","><mn>0</mn><mn>1</mn></mfenced><msup><mi mathvariant="normal">Ο</mi><mi
    mathvariant="normal">Υ</mi></msup></msup></mrow></mfenced><mi mathvariant="normal">λ</mi></msub></math>
- en: '![si2_e](images/S0065245818300676/si2_e_u1.png)  (2)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![si2_e](images/S0065245818300676/si2_e_u1.png)  (2)'
- en: 'where λ denotes the seed. We derive, in arbitrary way, three pseudo random
    functions that are:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其中λ表示种子。我们以任意方式推导出三个伪随机函数：
- en: <math><msubsup><mi mathvariant="italic">PRF</mi><mi>λ</mi><mi mathvariant="italic">address</mi></msubsup><mfenced
    close=")" open="("><mi>x</mi></mfenced><mo>∶</mo><mo>=</mo><msub><mi mathvariant="italic">PRF</mi><mi>λ</mi></msub><mfenced
    close=")" open="("><mrow><mn>00</mn><mo>∥</mo><mi>x</mi></mrow></mfenced></math>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![si3_e](images/S0065245818300676/si3_e.png)  (3)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: <math><msubsup><mi mathvariant="italic">PRF</mi><mi>λ</mi><mi mathvariant="italic">apk</mi></msubsup><mfenced
    close=")" open="("><mi>x</mi></mfenced><mo>∶</mo><mo>=</mo><msub><mi mathvariant="italic">PRF</mi><mi>λ</mi></msub><mfenced
    close=")" open="("><mrow><mn>01</mn><mo>∥</mo><mi>x</mi></mrow></mfenced></math>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![si4_e](images/S0065245818300676/si4_e.png)  (4)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: We assume that PRF[λ]^(Tsn) is also collision-resistant in the sense that it
    is infeasible to find
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: (λ, x) ≠ (λ′, x′) such that PRF[λ]^(Tsn)(x) = PRF[λ′]^(Tsn)(x′).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 One-time strongly-unforgeable digital signatures
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We use a digital signature scheme Sign = <math><mfenced close=")" open="("
    separators=",,,"><mrow><mi mathvariant="script">G</mi><mi mathvariant="italic">en</mi></mrow><mrow><mi
    mathvariant="script">KS</mi><mi>i</mi><mi mathvariant="script">G</mi></mrow><mrow><mi
    mathvariant="italic">sig</mi></mrow><mrow><mi mathvariant="italic">check</mi></mrow></mfenced></math>![si5_e](images/S0065245818300676/si5_e.png)
    that works as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-script">G</mi><mi mathvariant="bold-italic">en</mi><mfenced
    close=")" open="("><msup><mn mathvariant="bold">1</mn><mi mathvariant="bold-italic">k</mi></msup></mfenced><mo
    mathvariant="bold-italic">→</mo><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub></math>![si6_e](images/S0065245818300676/si6_e.png).
    Given a security parameter 1^k, <math><mi mathvariant="script">G</mi><mi mathvariant="italic">en</mi></math>![si7_e](images/S0065245818300676/si7_e.png)
    samples public parameters param[sig] for the signature scheme
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-script">KS</mi><mi mathvariant="bold-italic">i</mi><mi
    mathvariant="bold-script">G</mi><mfenced close=")" open="("><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><msub><mi mathvariant="bold-italic">pk</mi><mi
    mathvariant="bold-italic">sig</mi></msub><msub><mi mathvariant="bold-italic">sk</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced></math>![si8_e](images/S0065245818300676/si8_e.png).
    Given public parameters <math><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub><mo>,</mo><mi mathvariant="script">KS</mi><mi>i</mi><mi
    mathvariant="script">G</mi></math>![si9_e](images/S0065245818300676/si9_e.png)
    samples a public key and a secret key for a single user
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold-script">KS</mi><mi mathvariant="bold-italic">i</mi><mi
    mathvariant="bold-script">G</mi><mfenced close=")" open="("><msub><mi mathvariant="bold-italic">param</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><msub><mi mathvariant="bold-italic">pk</mi><mi
    mathvariant="bold-italic">sig</mi></msub><msub><mi mathvariant="bold-italic">sk</mi><mi
    mathvariant="bold-italic">sig</mi></msub></mfenced></math>![si8_e](images/S0065245818300676/si8_e.png)。给定公共参数
    <math><msub><mi mathvariant="bold-italic">param</mi><mi mathvariant="bold-italic">sig</mi></msub><mo>,</mo><mi
    mathvariant="script">KS</mi><mi>i</mi><mi mathvariant="script">G</mi></math>![si9_e](images/S0065245818300676/si9_e.png)，对于单个用户，样本生成一个公钥和一个密钥。
- en: sig[sk[sig]](m) → σ. Given a secret key sk[sig] and a message m, sig[sk[sig]]
    signs m to obtain a signature σ
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: sig[sk[sig]](m) → σ。给定私钥 sk[sig] 和消息 m，sig[sk[sig]] 签署 m 以获得签名 σ。
- en: check[pk[sig]](m, σ) → b. Given a public key pk[sig], message m, and signature
    σ, check[pk[sig]]outputs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: check[pk[sig]](m, σ) → b。给定公钥 pk[sig]、消息 m 和签名 σ，check[pk[sig]] 输出 b。
- en: b = 1 if the signature σ is valid for message m; else it outputs b = 0.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名 σ 对消息 m 有效，则 b = 1；否则输出 b = 0。
- en: The signature scheme Sign satisfies the security property of one-time strong
    unforgeability against chosen-message attacks (SUF-1CMA security).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 签名方案 Sign 满足针对选择消息攻击的一次强不可伪造性安全性属性（SUF-1CMA 安全）。
- en: 5.3.3 Access structure
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3 访问结构
- en: Definition 3\. (Access Structure [57])
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 3\.（访问结构[57]）
- en: Let {P[1],P[2] ,…,P[n]} be a set of parties, a collection <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1], P[2], …, P[n]})is
    monotone if <math><mo>∀</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>:</mo><mi mathvariant="italic">if</mi><mi>B</mi><mo>∈</mo><mi
    mathvariant="script">A</mi></math>![si11_e](images/S0065245818300676/si11_e.png)
    and B ⊆ C then <math><mi>C</mi><mo>∈</mo><mi mathvariant="script">A</mi></math>![si12_e](images/S0065245818300676/si12_e.png).
    An access structure (respectively, monotone access structure) is a collection
    (respectively, monotone collection) <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    of non-empty subsets of {P[1],P[2] ,…, P[n]}, i.e. <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1], P[2], …, P[n]}) ∖ {ϕ},
    the sets in <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    are called the authorized sets, and the sets not in <math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)
    are called the unauthorized sets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 设{P[1]，P[2]，…，P[n]}为一组参与方，集合<math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1]，P[2]，…，P[n]})是单调的，如果<math><mo>∀</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>:</mo><mi
    mathvariant="italic">if</mi><mi>B</mi><mo>∈</mo><mi mathvariant="script">A</mi></math>![si11_e](images/S0065245818300676/si11_e.png)，且B ⊆ C，则<math><mi>C</mi><mo>∈</mo><mi
    mathvariant="script">A</mi></math>![si12_e](images/S0065245818300676/si12_e.png)。访问结构（分别为单调访问结构）是一组（分别为单调组）<math><mi
    mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)的非空子集合{P[1]，P[2]，…，P[n]}，即<math><mi
    mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png) ⊆ 2^({P[1]，P[2]，…，P[n]}) ∖ {ϕ}，<math><mi
    mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)中的集合称为授权集合，而不在<math><mi
    mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)中的集合称为未授权集合。
- en: 5.3.4 Linear secret-sharing schemes (LSSS)
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4 线性秘密共享方案（LSSS）
- en: In our construction, we will use linear secret-sharing schemes (LSSS). Thus,
    we use the definition adapted from ref. [[57]](S0065245818300676.xhtml#bb9005).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造中，我们将使用线性秘密共享方案（LSSS）。 因此，我们使用从参考文献[[57]](S0065245818300676.xhtml#bb9005)中改编的定义。
- en: Definition 4\. (Linear Secret-Sharing Schemes (LSSS))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 定义4。 （线性秘密共享方案（LSSS））
- en: 'A secret sharing scheme ∏ over a set of parties P is called linear (over ℤ[p])
    if the following properties can be satisfied:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果秘密共享方案∏涉及参与方P的一个集合，并且满足以下属性，则称为线性（在ℤ[p]上）。
- en: (1) The shares for each party form a vector over ℤ[p].
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （1）每个参与方的份额形成一个ℤ[p]上的向量。
- en: '(2) For ∏, there exists a matrix M with ℓ rows and n columns called the share-generating
    matrix. For i = 1, 2,…, ℓ, the ith row is labeled with a party ρ(i) where ρ: {1,
    2,…, ℓ} → ℤ[p]. To share a secret s ∈ ℤ[p], a vector <math><mover accent="true"><mi>v</mi><mo
    stretchy="true">→</mo></mover></math>![si17_e](images/S0065245818300676/si17_e.png) = (s,
    v2,…, vn) is selected, where v2,…, vn are randomly selected from ℤ[p]. <math><mi>M</mi><mover
    accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si18_e](images/S0065245818300676/si18_e.png)
    is the vector of the ℓ shares according to ∏. The share <math><msub><mi>M</mi><mi>i</mi></msub><mover
    accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si19_e](images/S0065245818300676/si19_e.png)
    belongs to the party ρ(i), where M[i] is the ith row of M.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （2）对于∏，存在一个具有ℓ行和n列的矩阵M，称为共享生成矩阵。对于i = 1, 2,…，ℓ，第i行带有一个标有方 ρ(i)的 party，其中ρ：{1,
    2,…，ℓ}→ℤ[p]。为了共享一个秘密s∈ℤ[p]，选择一个向量<math><mover accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si17_e](images/S0065245818300676/si17_e.png)
    = (s, v2,…，vn)，其中v2,…，vn是从ℤ[p]随机选择的。 <math><mi>M</mi><mover accent="true"><mi>v</mi><mo
    stretchy="true">→</mo></mover></math>![si18_e](images/S0065245818300676/si18_e.png)是根据∏的ℓ个分享的向量。份额<math><msub><mi>M</mi><mi>i</mi></msub><mover
    accent="true"><mi>v</mi><mo stretchy="true">→</mo></mover></math>![si19_e](images/S0065245818300676/si19_e.png)
    属于 party ρ(i)，其中M[i]是M的第i行。
- en: 5.3.5 Distributed multi-authority CP-ABE scheme
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5 分布式多权威CP-ABE方案
- en: In our setting we use a distributed multi-authority CP-ABE scheme based on the
    one introduced in [[58]](S0065245818300676.xhtml#bb9010).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设置中，我们使用了基于[[58]](S0065245818300676.xhtml#bb9010)中介绍的分布式多权威CP-ABE方案。
- en: Definition 5
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 定义5
- en: 'DCP-ABE scheme comprises four fundamental algorithms as follows: system Setup,
    Authority setup, Encrypt, KeyGen, and Decrypt.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DCP-ABE方案包括以下四个基本算法：系统设置，权威设置，加密，密钥生成和解密。
- en: 'Syetem Setup (1^k) → (PP): The setup algorithm takes in a security parameter
    1^k. It outputs the public parameters PP.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 系统设置（1^k）→（PP）：设置算法接受一个安全参数1^k作为输入。它输出公共参数PP。
- en: Suppose that there are N Certifying Authorities {CÅ[1], CÅ[2], …, CÅ[N]}, and
    each authority CÅ[i] monitors a set of attributes Ã[i]. Each user U has a unique
    global identifier GID[U] and holds a set of attributes Û.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在N个认证机构{CÅ[1]，CÅ[2]，…，CÅ[N]}，每个机构CÅ[i]监控一组属性Ã[i]。每个用户U都有一个唯一的全局标识符GID[U]，并持有一组属性Û。
- en: Authority setup(1^k) → (SK[i], PK[i]). Taking as input the security parameter1^k,
    and it outputs secret key and public key pair (SK[i]; PK[i]) for each authority
    Ã, where KeyGen(1^k) → (SK[i], PK[i]).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 权威设置（1^k）→（SK[i]，PK[i]）。接受安全参数1^k作为输入，并为每个权威Ã输出密钥对（SK[i]；PK[i]），其中KeyGen（1^k）→（SK[i]，PK[i]）。
- en: '<math><mi mathvariant="bold-italic">Encrypt</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="italic">PP</mi><mi mathvariant="script">M</mi><msub><mfenced
    close=")" open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></math>![si20_e](images/S0065245818300676/si20_e.png).
    It takes as inputs: the public parameters PP, the plaintext message<math><mi mathvariant="script">M</mi></math>![si21_e](images/S0065245818300676/si21_e.png),
    a set of access structures (Mi, ρi)i ∈ I and a set of public keys (PKi) ∈ I It
    outputs the cipher-text CT.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold-italic">Encrypt</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="italic">PP</mi><mi mathvariant="script">M</mi><msub><mfenced
    close=")" open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></math>![si20_e](images/S0065245818300676/si20_e.png)。它将公共参数
    PP、明文消息<math><mi mathvariant="script">M</mi></math>![si21_e](images/S0065245818300676/si21_e.png)、一组访问结构（Mi, ρi）i ∈ I
    和一组公钥（PKi） ∈ I 作为输入，并输出密文 CT。
- en: keyGen (GID; PP; Û∩ Ã; SK[i]) → idKey[GID,i] Taking as input the public parameter
    PP, the secret keySK[i], the requester's global identifier GID[U] and a set of
    attributes Û∩ Ã, the IDkeyGen generation algorithm outputs an idKey[GID,i].
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: keyGen（GID；PP；Û∩ Ã；SK[i]） → idKey[GID,i] 将公共参数 PP、密钥 SK[i]、请求者的全局标识符 GID[U]
    和一组属性 Û∩ Ã 作为输入，IDkeyGen 生成算法输出 idKey[GID,i]。
- en: Decrypt(PP, (idKey[GID,i])[i ∈ I], CT) → M. The decrypt algorithm takes as input
    the public parameter PP, the cipher-text CT and the secret keys idKey[GID,i].
    If the set of attributes satisfies the access structure A then the algorithm will
    decrypt the cipher-text and return a message m else it returns ⊥.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Decrypt(PP, (idKey[GID,i])[i ∈ I], CT) → M。解密算法以公共参数 PP、密文 CT 和秘密密钥 idKey[GID,i]
    作为输入。如果属性集满足访问结构 A，则算法将解密密文并返回消息 m；否则返回 ⊥。
- en: Definition 6
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 6
- en: The decentralized cipher text-policy attribute-based encryption (DCP-ABE) is
    correct if
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式密文策略属性加密（DCP-ABE）如果正确的话
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="|" open="|"><mtable><mtr><mtd><mi
    mathvariant="italic">Decrypt</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">PP</mi><msub><mfenced close=")" open="("><msub><mi mathvariant="italic">idKey</mi><mrow><mi
    mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi
    mathvariant="italic">CT</mi></mfenced></mtd></mtr><mtr><mtd><mo>→</mo><mi>M</mi></mtd></mtr></mtable></mfenced><mfenced
    close="|" open=""><mtable><mtr><mtd><mi mathvariant="italic">Syetem</mi><mi mathvariant="italic">Setup</mi><mfenced
    close=")" open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced
    close=")" open="("><mi mathvariant="italic">PP</mi></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">Authority</mi><mi mathvariant="italic">setup</mi><mfenced
    close=")" open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced
    close=")" open="(" separators=","><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">Encrypt</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">PP</mi><mi mathvariant="script">M</mi><msub><mfenced close=")"
    open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></mtd></mtr></mtable></mfenced><mo>=</mo><mn>1</mn></math>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">Pr</mi><mfenced close="|" open="|"><mtable><mtr><mtd><mi
    mathvariant="italic">解密</mi><mfenced close=")" open="(" separators=",,"><mi mathvariant="italic">PP</mi><msub><mfenced
    close=")" open="("><msub><mi mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi
    mathvariant="italic">CT</mi></mfenced></mtd></mtr><mtr><mtd><mo>→</mo><mi>M</mi></mtd></mtr></mtable></mfenced><mfenced
    close="|" open=""><mtable><mtr><mtd><mi mathvariant="italic">系统</mi><mi mathvariant="italic">设置</mi><mfenced
    close=")" open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced
    close=")" open="("><mi mathvariant="italic">PP</mi></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">权威</mi><mi mathvariant="italic">设置</mi><mfenced close=")"
    open="("><msup><mn>1</mn><mi>k</mi></msup></mfenced><mo>→</mo><mfenced close=")"
    open="(" separators=","><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced></mtd></mtr><mtr><mtd><mi
    mathvariant="italic">加密</mi><mfenced close=")" open="(" separators=",,"><mi mathvariant="italic">PP</mi><mi
    mathvariant="script">M</mi><msub><mfenced close=")" open="(" separators=",,"><msub><mi>M</mi><mi>i</mi></msub><msub><mi>ρ</mi><mi>j</mi></msub><msub><mi
    mathvariant="italic">PK</mi><mi>i</mi></msub></mfenced><mi mathvariant="italic">iϵI</mi></msub></mfenced><mo>→</mo><mi
    mathvariant="italic">CT</mi></mtd></mtr></mtable></mfenced><mo>=</mo><mn>1</mn></math>
- en: '![si22_e](images/S0065245818300676/si22_e.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![si22_e](images/S0065245818300676/si22_e.png)'
- en: where the probability is token over the random bits used by all the algorithms
    in the scheme.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其中概率是对方案中所有算法使用的随机比特的令牌。
- en: Definition 7\. (Selective-Access Structure Secure DCPABE (IND-sAS-CPA))
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 7\. (选择性访问结构安全的 DCPABE (IND-sAS-CPA))
- en: A decentralized cipher text-policy attribute-based encryption (DCP-ABE) scheme
    is (T, q, ϵ(k)) secure in the selective-access structure model if no probably
    polynomial-time adversary A. Making q secret key queries can win the above game
    with the advantage
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择性访问结构模型中，如果没有可能的多项式时间对手 A 能够以概率多项式时间赢得上述游戏，则分布式密文策略属性加密（DCP-ABE）方案在（T，q，ϵ(k)）上是安全的，其中
    q 为秘密密钥查询次数。
- en: <math><msubsup><mi mathvariant="italic">Adv</mi><mi>A</mi><mrow><mi mathvariant="italic">ACP</mi><mo>−</mo><mi
    mathvariant="italic">ABE</mi></mrow></msubsup><mo>=</mo><mfenced close="|" open="|"><mrow><mi
    mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><msup><mi>b</mi><mo>′</mo></msup><mo>=</mo><mi>b</mi></mrow></mfenced><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mfenced><mo>></mo><mi>ϵ</mi><mfenced
    close=")" open="("><mi>k</mi></mfenced></math>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <math><msubsup><mi mathvariant="italic">Adv</mi><mi>A</mi><mrow><mi mathvariant="italic">ACP</mi><mo>−</mo><mi
    mathvariant="italic">ABE</mi></mrow></msubsup><mo>=</mo><mfenced close="|" open="|"><mrow><mi
    mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><msup><mi>b</mi><mo>′</mo></msup><mo>=</mo><mi>b</mi></mrow></mfenced><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mfenced><mo>></mo><mi>ϵ</mi><mfenced
    close=")" open="("><mi>k</mi></mfenced></math>
- en: '![si23_e](images/S0065245818300676/si23_e.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![si23_e](images/S0065245818300676/si23_e.png)'
- en: where the probability is token over all the bits consumed by the challenger
    and the adversary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其中概率是在挑战者和对手消耗的所有比特上进行的。
- en: 5.3.6 zk-SNARKs protocol
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.6 zk-SNARKs 协议
- en: Definition 8
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 8
- en: We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer
    the reader to, e.g., ref. [[56](S0065245818300676.xhtml#bb9000)] for a formal
    definition.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非正式地定义了算术电路可满足性的 zk-SNARKs。我们建议读者参考，例如，引用[[56](S0065245818300676.xhtml#bb9000)]以获取正式定义。
- en: 'For a field <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    an <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit takes inputs that are elements in <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    and its gates output elements in <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png).
    We naturally associate a circuit with the function it computes. To model non-determinism
    we consider circuits that have an input x ∈ F^n and an auxiliary input a <math><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup></math>![si28_e](images/S0065245818300676/si28_e.png),
    called a witness. The circuits we consider only have bilinear gates. Arithmetic
    circuit satisfiability is defined analogously to the boolean case, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个域<math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)，一个<math><mi
    mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)算术电路接受作为输入的元素，这些元素属于<math><mi
    mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)，其门输出<math><mi
    mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)中的元素。我们自然地将电路与其计算的函数相关联。为了模拟非确定性，我们考虑具有输入<math>x ∈ F^n</math>和辅助输入<math>a <mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup></math>![si28_e](images/S0065245818300676/si28_e.png)的电路，称为证明。我们考虑的电路只有双线性门。算术电路可满足性类似于布尔情况，定义如下：
- en: Definition 9
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 9
- en: 'The arithmetic circuit satisfiability problem of an <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)算术电路的可满足性问题：
- en: 'C: <math><msup><mi mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo></math>![si30_e](images/S0065245818300676/si30_e.png) <math><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mo>→</mo><msup><mi mathvariant="double-struck">F</mi><mi>l</mi></msup></math>![si31_e](images/S0065245818300676/si31_e.png)
    is captured by the relation <math><msub><mi mathvariant="normal">ℝ</mi><mi>C</mi></msub><mo>=</mo><mfenced
    close="}" open="{"><mrow><mfenced close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo><msup><mi mathvariant="double-struck">F</mi><mi>p</mi></msup><mi>C</mi><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced><mo>;</mo><mi
    mathvariant="italic">its</mi><mi mathvariant="italic">language</mi><mi mathvariant="italic">is</mi><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub><mo>=</mo><mfenced close="}" open="{"><mrow><mi>x</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>:</mo><mo>∃</mo><mi>a</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mi mathvariant="italic">such</mi><mi
    mathvariant="italic">that</mi><mi>C</mi><mfenced close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced></math>![si32_e](images/S0065245818300676/si32_e.png)![si999_e](images/S0065245818300676/si999_e.png)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'C: <math><msup><mi mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo></math>![si30_e](images/S0065245818300676/si30_e.png) <math><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mo>→</mo><msup><mi mathvariant="double-struck">F</mi><mi>l</mi></msup></math>![si31_e](images/S0065245818300676/si31_e.png)
    被关系 <math><msub><mi mathvariant="normal">ℝ</mi><mi>C</mi></msub><mo>=</mo><mfenced
    close="}" open="{"><mrow><mfenced close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>×</mo><msup><mi mathvariant="double-struck">F</mi><mi>p</mi></msup><mi>C</mi><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced><mo>;</mo><mi
    mathvariant="italic">其</mi><mi mathvariant="italic">语言</mi><mi mathvariant="italic">为</mi><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub><mo>=</mo><mfenced close="}" open="{"><mrow><mi>x</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>n</mi></msup><mo>:</mo><mo>∃</mo><mi>a</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">F</mi><mi>p</mi></msup><mi mathvariant="italic">，</mi><mi
    mathvariant="italic">使</mi><mi mathvariant="italic">得</mi><mi>C</mi><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>=</mo><msup><mn>0</mn><mi>l</mi></msup></mrow></mfenced></math>![si32_e](images/S0065245818300676/si32_e.png)![si999_e](images/S0065245818300676/si999_e.png)'
- en: Given a field <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png),
    a (publicly-verifiable preprocessing)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个域 <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)，一个（公开可验证的预处理）
- en: 'zk-SNARK for <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit satisfiability is a triple of polynomial-time algorithms (KeyGen; Prove;
    Verify):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-算术电路可满足性的
    zk-SNARK 是一组多项式时间算法（KeyGen；Prove；Verify）：
- en: keyGen(1^k, C) → (pk, vk) Takes as Input a security parameter k and an <math><mi
    mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit C, the key generator keyGen probabilistically samples a proving key pk
    and a verification key vk. Both keys are published as public parameters and can
    be used, any number of times, to prove/verify membership in <math><msub><mi mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: keyGen(1^k, C) → (pk, vk) 接受安全参数 k 和一个 <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-算术电路
    C，密钥生成器 keyGen 概率性地采样一个证明密钥 pk 和一个验证密钥 vk。这两个密钥被发布为公共参数，并且可以被使用任意次数，来证明/验证属于 <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png)
    的成员资格。
- en: Prove(pk, x, a) → π Takes on input a proving key pk and any (x, a) ∈ ℝ[C], the
    prover Prove outputs a non-interactive proof π for the statement x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 证明（pk，x，a）→ π 接受证明密钥 pk 和任何 (x, a) ∈ ℝ[C]，证明者 Prove 输出关于命题 x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png)
    的非交互式证明 π。
- en: Verify( vk, x, π) → b Takes on input a verification key vk, an input x, and
    a proof π, the verifier Verify outputs b = 1 if he is convinced that x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 验证（vk，x，π）→ b 接受验证密钥 vk、输入 x 和证明 π，验证器 Verify 输出 b = 1 如果他确信 x ∈ <math><msub><mi
    mathvariant="script">L</mi><mi>C</mi></msub></math>![si36_e](images/S0065245818300676/si36_e.png)。
- en: 'A zk-SNARK satisfies the following properties:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 zk-SNARK 满足以下属性：
- en: 'Completeness. For every security parameter k, any <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-arithmetic
    circuit C, and any (x, a) ∈ ℝ[C], the honest prover can convince the verifier.
    Namely, b = 1 with probability 1 − negl (k) in the following experiment: (pk, vk) ← keyGen(1^k, C),
    π ← Prove(pk, x, a), b ← Verify( vk, x, π)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完备性。对于每个安全参数 k，任何 <math><mi mathvariant="double-struck">F</mi></math>![si24_e](images/S0065245818300676/si24_e.png)-算术电路
    C 和任何 (x, a) ∈ ℝ[C]，诚实的证明者可以说服验证者。也就是说，在以下实验中，b = 1 的概率为 1 − negl (k)：(pk, vk)
    ← keyGen(1^k, C)，π ← Prove(pk, x, a)，b ← Verify( vk, x, π)。
- en: Succinctness. An honestly-generated proof π has <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub><mfenced
    close=")" open="("><mn>1</mn></mfenced></math>![si40_e](images/S0065245818300676/si40_e.png)
    bit and Verify(vk, x, π) runs in time <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub><mfenced
    close=")" open="(" separators="||"><mi>x</mi></mfenced></math>![si41_e](images/S0065245818300676/si41_e.png).
    (Here, <math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub></math>![si42_e](images/S0065245818300676/si42_e.png)
    hides a fixed polynomial factor in k.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁性。一个诚实生成的证明π具有<math><msub><mi mathvariant="script">O</mi><mi>k</mi></msub><mfenced
    close=")" open="("><mn>1</mn></mfenced></math>![si40_e](images/S0065245818300676/si40_e.png)比特，而Verify(vk, x, π)在时间<math><msub><mi
    mathvariant="script">O</mi><mi>k</mi></msub><mfenced close=")" open="(" separators="||"><mi>x</mi></mfenced></math>![si41_e](images/S0065245818300676/si41_e.png)内运行。（这里，<math><msub><mi
    mathvariant="script">O</mi><mi>k</mi></msub></math>![si42_e](images/S0065245818300676/si42_e.png)隐藏了k的固定多项式因子。）
- en: 'Proof of knowledge (and soundness). If the verifier accepts a proof output
    by a bounded prover, then the prover “knows” a witness for the given instance.
    (In particular, soundness holds against bounded provers.) Namely, for every poly(k)-size
    adversary<math><mi mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png),
    there is a poly(k)-size extractor <math><mi mathvariant="script">E</mi></math>![si44_e](images/S0065245818300676/si44_e.png)
    such that Verify( vk, x, π) = 1 and (x, a) ∈ ℝ[C] with probability negl (k) in
    the following experiment: (pk, vk) ← keyGen(1^k, C); <math><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>π</mi></mfenced><mo>←</mo><mi mathvariant="script">A</mi><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></math>![si45_e](images/S0065245818300676/si45_e.png);
    <math><mi>a</mi><mo>←</mo><mi mathvariant="script">E</mi><mfenced close=")" open="("
    separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></math>![si46_e](images/S0065245818300676/si46_e.png)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 知识证明（以及声音性）。如果验证器接受有界证明者生成的证明，则证明者“知道”给定实例的见证人。（特别是，声音性针对有界证明者保持。）即，对于每个poly(k)-size对手<math><mi
    mathvariant="script">A</mi></math>![si10_e](images/S0065245818300676/si10_e.png)，存在一个poly(k)-size提取器<math><mi
    mathvariant="script">E</mi></math>![si44_e](images/S0065245818300676/si44_e.png)，使得在以下实验中Verify(vk, x, π) = 1且(x, a) ∈ ℝ[C]的概率为negl(k)：(pk, vk) ← keyGen(1^k, C);
    <math><mfenced close=")" open="(" separators=","><mi>x</mi><mi>π</mi></mfenced><mo>←</mo><mi
    mathvariant="script">A</mi><mfenced close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi
    mathvariant="italic">vk</mi></mfenced></math>![si45_e](images/S0065245818300676/si45_e.png);
    <math><mi>a</mi><mo>←</mo><mi mathvariant="script">E</mi><mfenced close=")" open="("
    separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></math>![si46_e](images/S0065245818300676/si46_e.png)
- en: 'Perfect zero knowledge. An honestly-generated proof is perfect zero knowledge.
    Namely, there is a poly(k)-size simulator <math><mi mathvariant="script">S</mi><mi
    mathvariant="italic">im</mi></math>![si47_e](images/S0065245818300676/si47_e.png)
    such that for all stateful poly(k)-size distinguishers <math><mi mathvariant="script">D</mi></math>![si48_e](images/S0065245818300676/si48_e.png)
    the following two probabilities are equal:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的零知识。一个诚实生成的证明是完美的零知识。也就是说，存在一个多项式大小的模拟器 <math><mi mathvariant="script">S</mi><mi
    mathvariant="italic">im</mi></math>![si47_e](images/S0065245818300676/si47_e.png)，对于所有有状态的多项式大小的区分器
    <math><mi mathvariant="script">D</mi></math>![si48_e](images/S0065245818300676/si48_e.png)，以下两个概率相等：
- en: 1. The probability that <math><mi mathvariant="script">D</mi><mfenced close=")"
    open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png)= 1
    on an honest proof.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 在诚实证明中，<math><mi mathvariant="script">D</mi><mfenced close=")" open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png)= 1
    的概率。
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced><mo
    mathvariant="bold">←</mo><mi mathvariant="bold-italic">keyGen</mi><mfenced close=")"
    open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi mathvariant="script">D</mi><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Prove</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi>a</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced><mo
    mathvariant="bold">←</mo><mi mathvariant="bold-italic">keyGen</mi><mfenced close=")"
    open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced close=")"
    open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi mathvariant="script">D</mi><mfenced
    close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Prove</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi>a</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
- en: '![si50_e](images/S0065245818300676/si50_e.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![si50_e](images/S0065245818300676/si50_e.png)'
- en: 2. The probability that <math><mi mathvariant="script">D</mi><mfenced close=")"
    open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png) = 1
    on a simulated proof.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 在模拟证明中，<math><mi mathvariant="script">D</mi><mfenced close=")" open="("><mi>π</mi></mfenced></math>![si49_e](images/S0065245818300676/si49_e.png) = 1
    的概率。
- en: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=",,"><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi><mi
    mathvariant="italic">trap</mi></mfenced><mo mathvariant="bold">←</mo><mi mathvariant="bold-italic">Sim</mi><mfenced
    close=")" open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi
    mathvariant="script">D</mi><mfenced close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi
    mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Sim</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi mathvariant="italic">trap</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">Pr</mi><mfenced close="]" open="["><mrow><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>∈</mo><msub><mi
    mathvariant="normal">ℝ</mi><mi>C</mi></msub><mi mathvariant="script">D</mi><mfenced
    close=")" open="("><mi>π</mi></mfenced><mo>=</mo><mn>1</mn><mfenced close="" open="|"><mtable><mtr><mtd><mfenced
    close=")" open="(" separators=",,"><mi mathvariant="italic">pk</mi><mi mathvariant="italic">vk</mi><mi
    mathvariant="italic">trap</mi></mfenced><mo mathvariant="bold">←</mo><mi mathvariant="bold-italic">Sim</mi><mfenced
    close=")" open="("><mrow><mi>C</mi></mrow></mfenced></mtd></mtr><mtr><mtd><mfenced
    close=")" open="(" separators=","><mi>x</mi><mi>a</mi></mfenced><mo>←</mo><mi
    mathvariant="script">D</mi><mfenced close=")" open="(" separators=","><mi mathvariant="italic">pk</mi><mi
    mathvariant="italic">vk</mi></mfenced></mtd></mtr><mtr><mtd><mi>π</mi><mo>←</mo><mi
    mathvariant="bold-italic">Sim</mi><mfenced close=")" open="(" separators=",,"><mi
    mathvariant="italic">pk</mi><mi>x</mi><mi mathvariant="italic">trap</mi></mfenced></mtd></mtr></mtable></mfenced></mrow></mfenced></math>
- en: '![si52_e](images/S0065245818300676/si52_e.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![si52_e](images/S0065245818300676/si52_e.png)'
- en: 5.4 Formal definition of privacy-preserving distributed access control scheme
    (PPDAC)
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 隐私保护分布式访问控制方案（PPDAC）的正式定义
- en: We begin by describing, and giving intuition about, the data structures used
    by a PPDAC scheme, the algorithms that use and let the details of the construction
    of each one in [Section 5.5](S0065245818300676.xhtml#s0135).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述并直观地解释了PPDAC方案中使用的数据结构，这些算法使用并在第[5.5节](S0065245818300676.xhtml#s0135)详细介绍了每一个构造细节。
- en: 5.4.1 Data structure
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1 数据结构
- en: 'Public Parameters (PP): A list of public parameters PP is available to all
    users in the system. These are generated by a trusted party at the “launch time”
    of the system and are used by the system''s algorithms.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 公共参数（PP）：系统中所有用户都可以访问的公共参数PP列表。这些参数由系统的“启动时间”上的受信方生成，并由系统的算法使用。
- en: 'Addresses: As in FairAccess, each user in the system generates as many addresses
    as he wants. Each address corresponds to a pair of key (a[pk]; a[sk]). The public
    key a[pk] is published and enables others to interact with user. The secret key
    a[sk] is used to spend the authorization token owned by user who possesses the
    a[pk].'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 地址：与 FairAccess 中一样，系统中的每个用户都可以生成任意多个地址。每个地址对应于一对密钥（a[pk]; a[sk]）。公钥 a[pk] 被发布，使其他人能够与用户交互。密钥
    a[sk] 用于花费由拥有 a[pk] 的用户拥有的授权令牌。
- en: 'IDkey: is a vector of idKey[GID,i] as IDkey = (idKey[GID,i])[i ∈ N]'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: IDkey：是 idKey[GID,i] 的向量，如 IDkey = (idKey[GID,i])[i ∈ N]
- en: Where idKey[GID,i] is a private key delivered by a certifying authority CÅ[i]
    monitoring a set of attribute Û ∩ Ã[i] and GID. Where GID corresponds to the notion
    of global identifiers introduced by chaise in [[59]](S0065245818300676.xhtml#bb9015)
    to link private keys together that were issued to the same user by different authorities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 idKey[GID,i] 是由监控一组属性 Û ∩ Ã[i] 和 GID 的认证机构 CÅ[i] 颁发的私钥。其中 GID 对应于 chaise
    在 [[59]](S0065245818300676.xhtml#bb9015) 中引入的全局标识符概念，用于将由不同机构颁发给同一用户的私钥链接在一起。
- en: The requester gets an IDkey by running an IDkeygen algorithm with the certifying
    authorities. Then it is recorded in the blockchain by its owners as a public value
    when minting an IDcoin.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者通过与认证机构运行 IDkeygen 算法来获得一个 IDkey。然后在铸造 IDcoin 时由其所有者记录在区块链中作为一个公共值。
- en: 'IDcoin: For each IDkey, we associate an IDcoin. An IDcoin is a data object
    idc, to which we associate the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: IDcoin：对于每个 IDkey，我们关联一个 IDcoin。IDcoin 是一个数据对象 idc，我们将其与以下内容关联：
- en: '• An IDcoin commitment, denoted cm (idc): a string that appears on the ledger
    once idc is minted by the requester.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • IDcoin 承诺，表示为 cm (idc)：一串字符串，一旦 idc 被请求者铸造，就会出现在总账上。
- en: '• An IDcoin serial number, denoted sn (idc): a unique string associated with
    the idc, used to prevent double spending.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • IDcoin 序列号，表示为 sn (idc)：与 idc 关联的唯一字符串，用于防止双重支付。
- en: '• An IDcoin address, denoted a[pk] (idc): an address public key, representing
    who owns idc.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • IDcoin 地址，表示为 a[pk] (idc)：公钥地址，表示谁拥有 idc。
- en: 'Authorization token TKN: is a data structure constructed as follow:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 授权令牌 TKN：是按照以下方式构造的数据结构：
- en: <math><mi mathvariant="italic">TKN</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mtext>SmartContract
    address</mtext><mo stretchy="true">‖</mo><mi>cm</mi></mrow></mfenced><mo>.</mo></math>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">TKN</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mtext>智能合约地址</mtext><mo
    stretchy="true">‖</mo><mi>cm</mi></mrow></mfenced><mo>.</mo></math>
- en: '![si53_e](images/S0065245818300676/si53_e.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![si53_e](images/S0065245818300676/si53_e.png)'
- en: It is added in the TKNList by the SmartContract in a simultaneous way as the
    commitment of IDcoin appears in IDCMlist.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IDcoin 被请求者铸造时，它以与 IDCMlist 中 IDcoin 的承诺同时出现的方式被智能合约添加到 TKNList 中。
- en: Commitments of minted IDcoins and serial numbers of spent IDcoins. For any given
    time T,
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 铸造的 IDcoin 和花费的 IDcoin 的承诺。对于任何给定时间 T，
- en: IDCMList[T] denotes the list of all IDcoin commitments appearing in Request
    Access RqTx and GetAccess GtATx recorded in the blockchain at time T.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: IDCMList[T] 表示在时间 T 区块链中记录的 Request Access RqTx 和 GetAccess GtATx 中出现的所有 IDcoin
    承诺的列表。
- en: TKNList[T] denotes the list of all authorization tokens appearing in GetAccess
    GtATx transaction recorded in the blockchain at time T.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: TKNList[T] 表示记录在时间 T 区块链中的 GetAccess GtATx 交易中出现的所有授权令牌的列表。
- en: SNListT[T] denotes the list of all serial numbers appearing in GetAccess transaction
    in the ledger at time T.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: SNListT[T] 表示在时间 T 的分类账中出现的所有序列号的列表。
- en: 'Merkle tree over commitments IDcoin: For any given time T, IDCTree[T] denotes
    a Merkle tree over IDCMList[T] and rt[T] its root. Moreover, the function Path[T]
    (idcm) gives the authentication path from a IDcoin commitment idcm appearing in
    IDCMList[T] to the root of Tree[T]. For convenience, we assume that the ledger
    at time T L[T] also stores rt[T ∗] for all T* < T (i.e., it stores all past Merkle
    tree roots).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: IDcoin 承诺的 Merkle 树：对于任何给定的时间 T，IDCTree[T] 表示 IDCMList[T] 上的 Merkle 树，rt[T]
    表示其根。此外，函数 Path[T] (idcm) 给出了出现在 IDCMList[T] 中的 IDcoin 承诺 idcm 到 Tree[T] 根的身份验证路径。为方便起见，我们假设时间
    T 的分类账 L[T] 也存储了所有 T* < T（即，它存储了所有过去的 Merkle 树根）。
- en: 'Merkle tree over authorization token: For any given time T, AUTree[T] denotes
    a Merkle tree over TKNList[T] and rt ∗[T] its root. Moreover, the function Path ∗[T]
    (idcm) gives the authentication path from a authorization token TKN appearing
    in TKNList[T] to the root of TKNTree[T]. For convenience, we assume that the ledger
    at time T L[T] also stores rt ∗[T ∗] for all T* < T (i.e., it stores all past
    Merkle tree roots).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 授权令牌的 Merkle 树：对于任何给定的时间 T，AUTree[T] 表示 TKNList[T] 上的 Merkle 树，rt ∗[T] 表示其根。此外，函数
    Path ∗[T] (idcm) 给出了出现在 TKNList[T] 中的授权令牌 TKN 到 TKNTree[T] 根的身份验证路径。为方便起见，我们假设时间
    T 的分类账 L[T] 也存储了所有 T* < T（即，它存储了所有过去的 Merkle 树根）。
- en: 'SmartContract: is a program running in the blockchain that stores two values:
    (1) a Cipher text CT. (2) its corresponding challenge CH which is a random number
    linked to CT as: CT ≔ Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]). The SmartContract
    embedded three functions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约：是在区块链中运行的程序，存储着两个值：（1）密文 CT。 （2）其对应的挑战 CH，它是与 CT 相关联的随机数，如下所示：CT ≔ Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI])。智能合约嵌入了三个函数：
- en: (i) Decrypt(PP,IDkey,CT) → M
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （i）Decrypt(PP,IDkey,CT) → M
- en: (ii) A boolean function IsEqual(M, CH)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （ii）一个布尔函数 IsEqual(M, CH)
- en: (iii) AddToTKNList(TKN)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （iii）AddToTKNList(TKN)
- en: 'New transactions: We use three new types of transactions in our framework that
    are:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 新交易：我们在我们的框架中使用了三种新类型的交易，分别是：
- en: '(1) GrantAccess transaction: it serves to deploy the SmartContract in the blockchain:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （1）授权访问交易：它用于在区块链中部署智能合约：
- en: <math><mi mathvariant="italic">GrATx</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mi
    mathvariant="italic">SmartContract</mi><mi mathvariant="italic">SC</mi></mrow></mfenced></math>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">GrATx</mi><mo>≔</mo><mfenced close=")" open="("><mrow><mi
    mathvariant="italic">智能合约</mi><mi mathvariant="italic">SC</mi></mrow></mfenced></math>
- en: '![si54_e](images/S0065245818300676/si54_e.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![si54_e](images/S0065245818300676/si54_e.png)'
- en: '(2) RequestAccess transaction: triggers the SmartContract and mint IDcoin:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">RqTx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">IDkey</mi><mi>k</mi><mi>s</mi><mi mathvariant="italic">cm</mi></mfenced></math>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![si55_e](images/S0065245818300676/si55_e.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: '(3) GetAccess transaction: pour the RequestAccess IDcoin and holds the authorization
    token:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">GtATx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">rt</mi><mi mathvariant="italic">sn</mi><mi
    mathvariant="italic">cm</mi><mi>π</mi></mfenced></math>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![si56_e](images/S0065245818300676/si56_e.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Blockchain: Our protocol is applied on top of a public permissionless ledger
    such as Ethereum. At any given time T, all users have access to the ledger at
    time T, which is a sequence of transactions. The ledger is append-only.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Algorithms
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will next describe functions that are needed in our system. The protocols
    that implement these functions will be described in the later section. Most, if
    not all, of these functions will be performed with respect to a given blockchain
    B, or need to make calls to the public parameters in our system. These are implicit
    inputs of the protocols.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'A (PPDAC) scheme Π is a tuple of polynomial-time algorithms: (SystemSetup,
    Authority Setup, IDkeyGen, encrypt, decrypt, CreateAddress, GrantAccess, RequestAccess,
    GetAccess, ValidateTransaction, executeSmartContract, AllowAccess)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'System Setup: (1^k) → PP. Taking as input a security parameter 1^k, the global
    setup algorithm outputs the public parameter PP.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm Setup is executed by a trusted party. The resulting public parameters
    PP are published and made available to all parties (e.g., by embedding them into
    the protocol's implementation). The setup is done only once. Afterward, no trusted
    party is needed, and no global secrets or trapdoors are kept.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Authority Setup: KG(1^k) → (SK[i], PK[i]). Each authority in the system runs
    the authority setup algorithm with the security parameter 1^k, as input to produce
    its own secret key and public key pair (SK[i]; PK[i]).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'Authority Setup: KG(1^k) → (SK[i], PK[i])。系统中的每个权威都运行具有安全参数1^k的权威设置算法，作为输入产生自己的秘密密钥和公钥对(SK[i];
    PK[i])。'
- en: 'Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT. It takes as inputs: the public
    parameters PP, a random plaintext string CH, a set of access structures (Mi, ρi)[i ∈ I]
    and a set of public keys (PKi)[i ∈ I]. It outputs the cipher-text CT associated
    with this set of access structures.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT。它以公共参数PP、随机明文字符串CH、一组访问结构(Mi,
    ρi)[i ∈ I]和一组公钥(PKi)[i ∈ I]作为输入。它输出与此访问结构相关联的密文CT。
- en: 'ExecuteSmartContract (RqT[x], SmartContract SC) → True or ⊥ . It takes as input
    the RequestAccess transaction. It returns true or false. This algorithm recalls
    tree sub-algorithms that are: (Decrypt, IsEqual, AddtoTKNList) defined as follow:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ExecuteSmartContract(RqT[x], SmartContract SC) → True or ⊥. 它以RequestAccess交易作为输入。它返回true或false。该算法调用了三个子算法，分别是：(Decrypt,
    IsEqual, AddtoTKNList)，定义如下：
- en: 'Decrypt(PP, IDkey, CT) → M.Taking as input the public parameter PP, the cipher-text
    CT and IDkey from the RequestAccess transaction triggering the SmartContract.
    Where a Request Access transaction RqTx is as follow: RqTx ≔ (IDkey, k, s, cm)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Decrypt(PP, IDkey, CT) → M. 以公共参数PP、密文CT和来自触发智能合约的RequestAccess交易的IDkey作为输入。其中Request
    Access交易RqTx如下所示：RqTx ≔ (IDkey, k, s, cm)
- en: 'IsEqual(M, CH). A Boolean function that compares the resulting message M and
    the recorded challenge CH as follow: If the Requester''s attribute, associated
    to IDkey, satisfies the set of access structures (Mi, ρi)i ∈ I, then M will be
    equal to CH and the function returns true, else the function returns false ⊥.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: IsEqual(M, CH)。一个布尔函数，用于比较生成的消息M和记录的挑战CH，如下所示：如果请求者的属性，与IDkey关联的属性，满足访问结构集合(Mi,
    ρi)i ∈ I，则M将等于CH，并且函数返回true，否则函数返回false ⊥。
- en: AddtoTKNList(idcm) → (rt, path(idcm)). It takes as input the IDcoin commitment
    and returns its authentication path in the Merkle tree having as root rt.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: AddtoTKNList(idcm) → (rt, path(idcm))。它以IDcoin承诺作为输入，并返回其在根为rt的默克尔树中的身份验证路径。
- en: 'CreateAddress(PP) ⟶ (a[pk]; a[sk]). The algorithm generates a new pseudonym
    address keypair: (a[pk]; a[sk]). Each user generates at least one address key
    pair in order to receive authorization tokens. The public key a[pk] is published,
    while the secret key a[sk] is used to redeem tokens sent to a[pk]. A user may
    generate any number of address key pairs; doing so does not require any interaction'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: CreateAddress(PP) ⟶ (a[pk]; a[sk])。该算法生成一个新的假名地址密钥对：(a[pk]; a[sk])。每个用户至少生成一个地址密钥对，以接收授权令牌。公钥a[pk]被公开，而秘密密钥a[sk]用于赎回发送到a[pk]的令牌。用户可以生成任意数量的地址密钥对；这样做不需要任何交互。
- en: <math><mi mathvariant="bold-italic">GrantAccess</mi><mfenced close=")" open="("><mi
    mathvariant="bold-italic">CH</mi><mi>,</mi><mrow><mfenced close=")" open="("><mi
    mathvariant="bold-italic">PKi</mi></mfenced><mo mathvariant="bold-italic">∈</mo><mi
    mathvariant="bold-italic">I</mi></mrow><mrow><mfenced close=")" open="(" separators=","><mi
    mathvariant="bold-italic">Mi</mi><mi mathvariant="bold-italic">ρi</mi></mfenced><mi
    mathvariant="bold-italic">i</mi><mo mathvariant="bold-italic">∈</mo><mi mathvariant="bold-italic">I</mi></mrow></mfenced><mo
    mathvariant="bold-italic">→</mo><mi mathvariant="bold-italic">GrATx</mi><mo mathvariant="bold-italic">≔</mo><mfenced
    close=")" open="("><mrow><mi mathvariant="bold-italic">SmartContract</mi><mi mathvariant="bold-italic">SC</mi></mrow></mfenced></math>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![si57_e](images/S0065245818300676/si57_e.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: The algorithm GrantAccess gives as output a GrantAccess Transaction holding
    hidden RO access control policies, in form of SmartContract and managing access
    control for each device.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes as inputs: implicitly the public parameters PP, the plaintext CH,
    a set of access structures(Mi, ρi)i ∈ I, and set of public keys(PKi) ∈ I for relevant
    authorities.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">IDkeyGen</mi><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="bold-italic">GID</mi><mi mathvariant="bold-italic">PP</mi><mrow><mi
    mathvariant="bold">Û</mi><mo mathvariant="bold-italic">∩</mo><mi mathvariant="bold">Ã</mi></mrow><msub><mi
    mathvariant="bold-italic">SK</mi><mi mathvariant="bold-italic">i</mi></msub></mfenced><mo
    mathvariant="bold-italic">→</mo><msub><mi mathvariant="bold-italic">idKey</mi><mrow><mi
    mathvariant="bold-italic">GID</mi><mo mathvariant="bold-italic">,</mo><mi mathvariant="bold-italic">i</mi></mrow></msub><mi
    mathvariant="bold-italic">and IDkey</mi><mo mathvariant="bold-italic">=</mo><msub><mfenced
    close=")" open="("><msub><mi mathvariant="bold-italic">idKey</mi><mrow><mi mathvariant="bold-italic">GID</mi><mo
    mathvariant="bold-italic">,</mo><mi mathvariant="bold-italic">i</mi></mrow></msub></mfenced><mrow><mi
    mathvariant="bold-italic">i</mi><mo mathvariant="bold-italic">∈</mo><mi mathvariant="bold-italic">N</mi></mrow></msub></math>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![si58_e](images/S0065245818300676/si58_e.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: A requester and an authority engage in the IDkeyGen algorithm that takes as
    input the public parameter PP, the secret keySK[i], the requester's global identifier
    GID[U] and a set of attributes Û ∩ Ã. It produces an IDkey for Rq.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="bold-italic">RequestAccess</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="bold-italic">PP</mi><msub><mi mathvariant="bold-italic">GID</mi><mi
    mathvariant="bold-italic">U</mi></msub><mrow><msub><mi mathvariant="bold-italic">a</mi><mi
    mathvariant="bold-italic">pk</mi></msub></mrow></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><mi mathvariant="bold-italic">IDcoin</mi><mrow><mi
    mathvariant="bold-italic">RqTx</mi><mo mathvariant="bold-italic">≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="bold-italic">IDkey</mi><mi
    mathvariant="bold-italic">k</mi><mi mathvariant="bold-italic">s</mi><mi mathvariant="bold-italic">cm</mi></mfenced></mrow></mfenced><mo
    mathvariant="bold-italic">.</mo></math>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold-italic">RequestAccess</mi><mfenced close=")" open="("
    separators=",,"><mi mathvariant="bold-italic">PP</mi><msub><mi mathvariant="bold-italic">GID</mi><mi
    mathvariant="bold-italic">U</mi></msub><mrow><msub><mi mathvariant="bold-italic">a</mi><mi
    mathvariant="bold-italic">pk</mi></msub></mrow></mfenced><mo mathvariant="bold-italic">→</mo><mfenced
    close=")" open="(" separators=","><mi mathvariant="bold-italic">IDcoin</mi><mrow><mi
    mathvariant="bold-italic">RqTx</mi><mo mathvariant="bold-italic">≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="bold-italic">IDkey</mi><mi
    mathvariant="bold-italic">k</mi><mi mathvariant="bold-italic">s</mi><mi mathvariant="bold-italic">cm</mi></mfenced></mrow></mfenced><mo
    mathvariant="bold-italic">.</mo></math>
- en: '![si59_e](images/S0065245818300676/si59_e.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![si59_e](images/S0065245818300676/si59_e.png)'
- en: The algorithm RequestAccess takes as inputs the public parameters PP, the requester's
    global identifier GID[U], and the public address of the requester a[pk] in which
    he wants to receive an authorization token. The algorithm outputs an IDcoin and
    a RequestAccess transaction RqTx
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 算法**GetAccess**的输入包括公共参数**PP**，请求者的全局标识符**GID[U]**，以及请求者想要接收授权令牌的公共地址**a[pk]**。该算法输出一个**IDcoin**和一个**RequestAccess**交易**RqTx**。
- en: <math><mi mathvariant="bold-italic">GetAccess</mi><mfenced close=")" open="("
    separators=",,,,"><mi mathvariant="italic">PP</mi><mi mathvariant="italic">rt</mi><mi
    mathvariant="italic">idcoin</mi><mrow><mi mathvariant="italic">path</mi><mfenced
    close=")" open="("><mi mathvariant="italic">idcm</mi></mfenced></mrow><msub><mi>a</mi><mi
    mathvariant="italic">sk</mi></msub></mfenced><mo>→</mo><mi mathvariant="italic">GtATx</mi><mo>≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="italic">rt</mi><mi mathvariant="italic">sn</mi><mi
    mathvariant="italic">cm</mi><mi>π</mi></mfenced></math>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold-italic">GetAccess</mi><mfenced close=")" open="("
    separators=",,,,"><mi mathvariant="italic">PP</mi><mi mathvariant="italic">rt</mi><mi
    mathvariant="italic">idcoin</mi><mrow><mi mathvariant="italic">path</mi><mfenced
    close=")" open="("><mi mathvariant="italic">idcm</mi></mfenced></mrow><msub><mi>a</mi><mi
    mathvariant="italic">sk</mi></msub></mfenced><mo>→</mo><mi mathvariant="italic">GtATx</mi><mo>≔</mo><mfenced
    close=")" open="(" separators=";;;"><mi mathvariant="italic">rt</mi><mi mathvariant="italic">sn</mi><mi
    mathvariant="italic">cm</mi><mi>π</mi></mfenced></math>
- en: '![si60_e](images/S0065245818300676/si60_e.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![si60_e](images/S0065245818300676/si60_e.png)'
- en: The algorithm GetAccess takes as inputs an IDcoin with its corresponding secret
    key a[sk] (required to redeem idcoin). To ensure that IDcoin have not been previously
    minted, the GetAccess algorithm also takes as input the Merkle root rt with the
    authentication paths path form Idcm. It outputs a GetAccess transaction GtATx
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 算法GetAccess的输入是带有相应秘钥a[sk]（用于赎回idcoin）的IDcoin。为了确保IDcoin未曾被铸造过，GetAccess算法还将从Idcm的认证路径路径形式中获取的Merkle根rt作为输入。它输出一个GetAccess事务GtATx。
- en: <math><mi mathvariant="bold">ValidateTransaction</mi><mfenced close=")" open="("
    separators=",,"><mrow><mi mathvariant="bold">GrantAccess</mi><mi mathvariant="bold-italic">GrATx</mi></mrow><mrow><mi
    mathvariant="bold">RequestAccess</mi><mi mathvariant="bold-italic">RqTx</mi></mrow><mrow><mi
    mathvariant="bold">GetAccess</mi><mi mathvariant="bold">transaction</mi><mi mathvariant="bold-italic">GtATx</mi></mrow></mfenced><mo
    mathvariant="bold-italic">→</mo><mfenced close=")" open="(" separators=","><mi
    mathvariant="bold-italic">true</mi><mi mathvariant="bold-italic">false</mi></mfenced></math>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold">ValidateTransaction</mi><mfenced close=")" open="("
    separators=",,"><mrow><mi mathvariant="bold">GrantAccess</mi><mi mathvariant="bold-italic">GrATx</mi></mrow><mrow><mi
    mathvariant="bold">RequestAccess</mi><mi mathvariant="bold-italic">RqTx</mi></mrow><mrow><mi
    mathvariant="bold">GetAccess</mi><mi mathvariant="bold">transaction</mi><mi mathvariant="bold-italic">GtATx</mi></mrow></mfenced><mo
    mathvariant="bold-italic">→</mo><mfenced close=")" open="(" separators=","><mi
    mathvariant="bold-italic">true</mi><mi mathvariant="bold-italic">false</mi></mfenced></math>
- en: '![si61_e](images/S0065245818300676/si61_e.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![si61_e](images/S0065245818300676/si61_e.png)'
- en: 'The algorithm ValidateTransaction checks the validity of a transaction: All
    transactions must be verified before being considered well-formed. In practice,
    transactions can be verified by nodes in the distributed system maintaining the
    ledger, as well as by users who rely on these transactions.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 算法ValidateTransaction检查交易的有效性：所有交易在被视为格式良好之前都必须经过验证。在实践中，交易可以由维护账本的分布式系统中的节点验证，也可以由依赖这些交易的用户验证。
- en: <math><mi mathvariant="bold">AllowAccess</mi><mfenced close=")" open="(" separators=","><mrow><mi
    mathvariant="bold">GrantAccess</mi><mi mathvariant="bold">Transaction</mi><mi
    mathvariant="bold-italic">GrATx</mi></mrow><mi mathvariant="bold-italic">SNlist</mi></mfenced><mo
    mathvariant="bold">→</mo><mfenced close=")" open="(" separators=","><mi mathvariant="bold-italic">true</mi><mi
    mathvariant="bold-italic">false</mi></mfenced></math>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="bold">AllowAccess</mi><mfenced close=")" open="(" separators=","><mrow><mi
    mathvariant="bold">GrantAccess</mi><mi mathvariant="bold">Transaction</mi><mi
    mathvariant="bold-italic">GrATx</mi></mrow><mi mathvariant="bold-italic">SNlist</mi></mfenced><mo
    mathvariant="bold">→</mo><mfenced close=")" open="(" separators=","><mi mathvariant="bold-italic">true</mi><mi
    mathvariant="bold-italic">false</mi></mfenced></math>
- en: '![si62_e](images/S0065245818300676/si62_e.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![si62_e](images/S0065245818300676/si62_e.png)'
- en: The algorithm AllowAccess takes as input GrantAccess transaction and SNList
    from the current ledger, if the IDCoin spent by this GrantAccess transaction appears
    in SNlist then access is allowed, else no.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 算法AllowAccess的输入是来自当前账本的GrantAccess事务和SNList，如果由该GrantAccess事务所花费的IDCoin出现在SNlist中，则允许访问，否则不允许。
- en: 5.5 PPDAC construction
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 PPDAC构造
- en: 'Phase 1: Setting up'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1阶段：设置
- en: 'System Setup: (1^k) → PP. Taking as input a security parameter 1^k, the global
    setup algorithm outputs the public parameter PP.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 系统设置：(1^k) → PP。输入安全参数 1^k，全局设置算法输出公共参数 PP。
- en: 'Authority setup: Suppose that there are N Certifying Authorities {CÅ[1], CÅ[2], …, CÅ[N]},
    and each authority CÅ[i] monitors a set of attributes Ã[i]. Each user U has a
    unique global identifier GID[U] and holds a set of attributes Û. Each authority
    in the system runs the authority setup algorithm with the security parameter 1^k
    as input to produce its own secret key and public key pair (SK[i]; PK[i]) as follow:
    KG(1^k) → (SK[i], PK[i]).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 权威设置：假设存在 N 个认证机构 {CÅ[1], CÅ[2], …, CÅ[N]}，每个机构 CÅ[i] 监控一组属性 Ã[i]。每个用户 U 具有唯一的全局标识符
    GID[U]，并持有一组属性 Û。系统中的每个机构运行权限设置算法，以安全参数 1^k 为输入生成其自身的秘密密钥和公钥对 (SK[i]; PK[i])，如下所示：KG(1^k) → (SK[i], PK[i])。
- en: 'NB: It is worth to note that this phase is conducted outside the blockchain.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注：值得注意的是，此阶段在区块链之外进行。
- en: 'Phase 2: The GrantAccess phase consists in defining access control policies
    over devices and hiding them inside SmartContracts:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二阶段：GrantAccess 阶段包括在设备上定义访问控制策略并将其隐藏在智能合约中：
- en: The resource owner is responsible for defining access policy and obfuscating
    the policy.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者负责定义访问策略和混淆策略。
- en: 'For each device, the RO acts as follow:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个设备，RO的操作如下：
- en: '1. He generates a random number that we call a challenges: CH'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 他生成一个我们称之为挑战的随机数：CH
- en: 2. He defines an Access structure (Mi, ρi)i ∈ I
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 他定义一个访问结构 (Mi, ρi)i ∈ I。
- en: '3. He employs the distributed DCP-ABE scheme to encrypt challenge CH under
    the corresponding access structure Mi, ρi and gets cipher texts CT through the
    following function: Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 他使用分布式 DCP-ABE 方案，根据相应的访问结构 Mi，ρi 加密挑战 CH，并通过以下函数获得密文 CT：Encrypt(PP, CH, (M[i], ρ[j], PK[i])[iϵI]) → CT。
- en: 'It takes as inputs: the public parameters PP, the plaintext message CH, a set
    of access structures (Mi, ρi)i ∈ I and a set of public keys (PKi) ∈ I. It outputs
    the cipher-text CT associated with this set of access structures.'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入公共参数 PP、明文消息 CH、一组访问结构 (Mi, ρi)i ∈ I 和一组公钥 (PKi) ∈ I。输出与这组访问结构相关联的密文 CT。
- en: '4. He defines a SmartContract that:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 他定义一个智能合约：
- en: 'a. stores two values: (1) a Cipher text CT, (2) and its corresponding CH'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 存储两个值：(1) 密文 CT，(2) 及其对应的 CH。
- en: 'b. embeds three functions:'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 嵌入三个函数：
- en: (1) Decrypt(PP, IDkey, CT) → M.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1) Decrypt(PP, IDkey, CT) → M。
- en: 'Taking as input the public parameter PP, the cipher-text and IDkey from the
    RequestAccess transaction triggering the SmartContract. Where a Request Access
    transaction RqTx is as follow: RqTx ≔ (IDkey, k, s, cm), the details of this transaction
    will be elaborated in the next phase.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入公共参数 PP、来自触发智能合约的 RequestAccess 交易的密文和 IDkey。其中一个 Request Access 交易 RqTx 如下：RqTx ≔ (IDkey, k, s, cm)，这个交易的详细信息将在下一阶段详述。
- en: '(2) A Boolean function that compares the resulting message M and the recorded
    challenge CH as follow: IsEqual(M, CH)'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Requester's attribute, associated to IDkey, satisfies the set of access
    structures (Mi, ρi)i ∈ I, then M will be equal to CH, else the function returns
    false ⊥.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (3) If the output of compare function is true, then the SmartContract adds idcm
    associated to IDkey in RqTx transaction to Authorization token list TKNList.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '5. Then the RO deploys the defined SmartContract in the blockchain through
    a GrantAccess transaction: GrATx:= (SmartContract SC)'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, to prevent SmartContract and transaction malleability we use a digital
    signature. This digital signature plays the role of “MACS” to tie a SmartContract
    to the RO and his devices. The Ro samples a key pair(pk[sig], sk[sig]), and computes
    σ = sig[sk[sig]](SC). Then, sets
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">GrATx</mi><mo>≔</mo><mfenced close=")" open="("
    separators=",,"><mrow><mi mathvariant="italic">SmartContract</mi><mi mathvariant="italic">SC</mi></mrow><msub><mi
    mathvariant="italic">pk</mi><mi mathvariant="italic">sig</mi></msub><mi>σ</mi></mfenced></math>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![si63_e](images/S0065245818300676/si63_e.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: 'Phase 3: The RequestAccess phase consists in successfully executing the SmartContract
    to get an access token'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This phase is divided into two sub-phases as follow:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Requester (RQ)—Authority Interaction. In this sub-phase, the Rq interacts with
    the certifying authorities (CÅ[i])[i ∈ I] and runs the IDkey extraction algorithms
    as follow:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: <math><mi mathvariant="italic">IDkey</mi><mi>Gen</mi><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">GID</mi><mi mathvariant="italic">PP</mi><mrow><mi>Û</mi><mo>∩</mo><mi
    mathvariant="normal">Ã</mi></mrow><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub></mfenced><mo>→</mo><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub><mtext>and</mtext><mi
    mathvariant="italic">IDkey</mi><mo>=</mo><msub><mfenced close=")" open="("><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>N</mi></mrow></msub></math>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mi mathvariant="italic">IDkey</mi><mi>Gen</mi><mfenced close=")" open="("
    separators=";;;"><mi mathvariant="italic">GID</mi><mi mathvariant="italic">PP</mi><mrow><mi>Û</mi><mo>∩</mo><mi
    mathvariant="normal">Ã</mi></mrow><msub><mi mathvariant="italic">SK</mi><mi>i</mi></msub></mfenced><mo>→</mo><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub><mtext>和</mtext><mi
    mathvariant="italic">IDkey</mi><mo>=</mo><msub><mfenced close=")" open="("><msub><mi
    mathvariant="italic">idKey</mi><mrow><mi mathvariant="italic">GID</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced><mrow><mi>i</mi><mo>∈</mo><mi>N</mi></mrow></msub></math>
- en: '![si64_e](images/S0065245818300676/si64_e.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![si64_e](images/S0065245818300676/si64_e.png)'
- en: Taking as input the public parameter PP, the secret keySK[i], the requester's
    global identifier GID[U] and a set of attributes Û∩ Ã, the IDkeyGen generation
    algorithm outputs an IDkey for Rq. We assume that the communication between the
    RQ and the authorities is secured and private. This phase is running outside the
    blockchain network.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将公共参数 PP、秘密密钥 SK[i]、请求者的全局标识符 GID[U] 和一组属性 Û∩ Ã 作为输入，IDkeyGen 生成算法输出 Rq 的 IDkey。我们假设
    RQ 与机构之间的通信是安全和私密的。该阶段在区块链网络之外运行。
- en: 'Requester-SmartContract Interaction. After getting the address of the SmartContract
    managing access to the target device, the requester triggers the SmartContract
    with a Request Access transaction RqTx to correctly decrypt the challenge and
    get an authorization token. As mentioned, in the beginning of this section, in
    our setting, we do not use private keys as in traditional CP-ABE schemes, but
    instead we are using identity keys: IDKey imbedded inside an IDcoin. In order
    to release the intractability property of IDKey, we make use of zk-SNARKs (described
    above) and a commitment scheme as follow:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者-智能合约交互。在获取管理目标设备访问权限的智能合约地址之后，请求者通过发送请求访问事务 RqTx 来触发智能合约，以正确解密挑战并获取授权令牌。正如本节开头所述，在我们的设置中，我们不像传统的
    CP-ABE 方案那样使用私钥，而是使用身份密钥：嵌入在 IDcoin 中的 IDKey。为了释放 IDKey 的不可互操作性属性，我们利用了 zk-SNARKs（如上所述）和以下承诺方案：
- en: Let COMM denotes a statistically-hiding non-interactive commitment scheme (i.e.,
    given randomness r and message m, the commitment is c ∶ = COMM[r](m) subsequently,
    c is opened by revealing r and m, and one can verify that COMM[r](m)equals c).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让 COMM 表示一个统计隐藏的非交互式承诺方案（即，给定随机数 r 和消息 m，承诺为 c ∶= COMM[r](m)，随后，通过揭示 r 和 m 来打开
    c，并且可以验证 COMM[r](m) 等于 c）。
- en: 'The requester mint IDcoins holding the IDKey to the ledger through a RequestAccess
    RqTx transaction. Unlike traditional CP-ABE schemes, where private keys are used
    to decrypt the cipher text and they are kept secret to their owner in order to
    be used only by him, in our setting we provide the same property of restricting
    the use of the IDKey to his owner even if it is public. To do so, we derive the
    IDcoins associated to IDkey in the following way:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者通过请求访问RqTx事务将持有IDKey的ID币铸造到总账上。与传统的CP-ABE方案不同，其中私钥用于解密密文并且保密给其所有者以便仅由其使用，我们在我们的设置中提供了IDKey限制使用的相同属性，即使它是公共的。为此，我们以下面的方式派生与IDkey相关联的ID币：
- en: We use three pseudorandom functions (derived from a single one). For a seed
    x these are denoted PRF[x]^(address). We assume that PRF[x]^(address) is moreover
    collision-resistant.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个伪随机函数（从一个函数派生）。对于一个种子x，这些被标记为PRF[x]^(address)。我们假设PRF[x]^(address)此外是抗碰撞的。
- en: 'To provide targets for IDcoins, we use addresses: each user u generates an
    address key pair (a[pk];a[sk]). The IDcoins tied to IDkey contains the value a[pk]
    and can be spent only with knowledge of a[sk]. In this way, the usage of IDkey
    is controlled by his owner who possesses the a[sk]. A key pair (a[pk]; a[sk])
    is sampled by selecting a random seed a[sk] and setting a[pk]: = PRF[ask]^(address)(0).
    A user can generate and use any number of address key pairs.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '为了为ID币提供目标，我们使用地址：每个用户u生成一个地址密钥对(a[pk];a[sk])。绑定到ID密钥的ID币包含值a[pk]，只有知道a[sk]的情况下才能使用。通过这种方式，ID密钥的使用由拥有a[sk]的所有者控制。通过选择随机种子a[sk]并设置a[pk]:
    = PRF[ask]^(address)(0)来采样密钥对(a[pk]; a[sk])。用户可以生成并使用任意数量的地址密钥对。'
- en: To “tie” an IDcoin to a specified IDkey, the requester Rq first samples ρ which
    is a secret value and computes ρ′ = PRF[ask]^(IDkey)(ρ) then determines the ID
    coin's serial number sn as sn:= PRF[ask]^(sn)( ρ′).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将ID币“绑定”到指定的ID密钥，请求者Rq首先对ρ进行抽样，这是一个秘密值，并计算ρ′ = PRF[ask]^(IDkey)(ρ)，然后确定ID币的序列号sn为sn:=
    PRF[ask]^(sn)( ρ′)。
- en: 'Then, the requester commits to the tuple (a[pk]:IDkey;ρ′) in two phases: (a)
    u computes k ∶ = COMM[r](a[pk] ∥ ρ′) for a random r; and then (b) the requester
    computes cm ∶ = COMM[s](IDkey ∥ k) for a random s. The minting results in an IDcoin
    idc:= (a[pk]; IDkey; ρ; r; s; cm) and a RequestAccess transaction RqTx:= (IDkey;
    k; s; cm).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，请求者以两个阶段承诺元组(a[pk]:IDkey;ρ′)：(a) u计算k ∶ = COMM[r](a[pk] ∥ ρ′)为一个随机r; 然后(b)
    请求者计算cm ∶ = COMM[s](IDkey ∥ k)为一个随机s。铸造产生一个ID币idc:= (a[pk]; IDkey; ρ; r; s; cm)和一个请求访问事务RqTx:=
    (IDkey; k; s; cm)。
- en: Specifically, due to the interlinked commitment, anyone can verify that cm in
    RequestAccess transaction is a coin commitment of an IDcoin of IDkey (by checking
    that COMM[S]( IDkey ∥ k) equals cm) but cannot discern the owner (by learning
    the address key a[pk]) or serial number (derived from ρ′) because these are hidden
    in k. In this way the anonymity and untraceability of the IDkey is achieved.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The RequestAccess transaction is accepted by the ledger only if the requester
    presents the correct IDkey that matches the hidden access control policy by decrypting
    the cipher text Decrypt(PP, IDkey, CT) → M and in one hand.in the other hand,
    if the commitment is correct.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'At this phase, the IDcoin commitment and respectively a corresponding authorization
    token signed with the SmartContract are recorded in the blockchain in two lists:
    an IDcoin commitment list IDcList and respectively an authorization token list
    TKNList.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The authorization token is an IDcoin commitment signed with the address of
    a SmartContract that added the IDcoin to the ledger. Subsequently, letting IDcoinList
    denotes the list of all IDcoin commitments on the ledger and respectively the
    TKNList denotes all the authorization token on the ledger. The requester may spend
    the authorization token by posting a GetAccess transaction that contains:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: (i) An ID coin's serial number sn, the address of the SmartContract.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (ii) A zk-SNARK proof π of the NP statement “I know r such that COMM[r](sn)
    appears in the list IDcoinList of IDcoin commitments.”
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (iii) An IDcoin commitment idcm with the address of the SmartContract.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TKN: = (SmartContract address || idcm) appears in TKNList'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that sn does not already appear on the ledger (as part of a past spend
    transaction), the requester can redeem the authorization token. (If sn does already
    appear on the ledger, this is considered double spending, and the transaction
    is discarded.) Furthermore, the end device will be able to verify that this authorization
    token was delivered by his corresponding SmartContract by checking the SmartContract
    address. The Requester anonymity is achieved because the proof π is zero knowledge,
    while sn is revealed, no information about r is, and finding which of the numerous
    commitments in TKNList corresponds to a particular GetAccess transaction is equivalent
    to inverting f(x): = COMM[x](sn), which is assumed to be infeasible. Thus, the
    origin of the transactions is anonymous ([Fig. 15](S0065245818300676.xhtml#f0075)).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 4: Getting access and spending the authorization token'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Fig. 15](images/S0065245818300676/f08-14-9780128171899.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Fig. 15 Generation of IDcoins and authorization tokens.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'To get access to the protected device, the requester spends the authorization
    token using a GetAccess transaction as follow:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a requester, with address key pair (a[pk]; a[sk]), wishes to consume
    his IDcoin:= (a[pk]; IDkey; ρ; ρ′, r; s; cm), the requester produces a zk-SNARK
    proof π for the following NP statement, which we call GetAccess:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '“Given the Merkle-tree root rt, serial number sn, and IDcoin commitments cm,
    I know IDcoin and address secret key a[sk] such that: i) the IDcoin is well formed,
    for IDcoin it holds that: k ∶ = COMM[r](a[pk] ∥ ρ′) and cm ∶ = COMM[s](IDkey ∥ k).ii)
    The address secret key matches the public key: a[pk] = PRF[ask]^(address)(0).
    iii) the IDcoin is correctly tied to Ideky: ρ′ = PRF[ask]^(IDkey)(ρ). iv) The
    serial number is computed correctly: sn:= PRF[ask]^(sn)( ρ′). v) The coin commitment
    cm appears as a leaf of a Merkle- tree with root rt.”'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: A resulting GetAccess transaction gets GtATx the form GtATx:= (rt; sn; cm; π)
    is appended to the ledger and it is rejected if the serial number sn appears in
    a previous transaction.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In this way, if the requester does not know the address secret key a[sk] that
    is associated with the public key a[pk]. Then, the requester cannot spend the
    authorization token neither uses the IDkey because he cannot provide a new a[sk]
    as part of the witness of a subsequent GetAccess transaction.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to prevent transaction malleability, and tie each IDkey to its
    owner, we use digital signature. The Requester samples a key pair(pk[sig], sk[sig]),
    set <math><mi>m</mi><mo>=</mo><mfenced close=")" open="(" separators=","><mover
    accent="true"><mi>u</mi><mo stretchy="true">→</mo></mover><msub><mi>π</mi><mi
    mathvariant="italic">grant</mi></msub></mfenced><mo>,</mo></math>![si65_e](images/S0065245818300676/si65_e.png)
    Compute σ = sig[sk[sig]](m). Then, Set GtATx ≔ (rt; sn; cm; IDkey, π, pk[sig], σ).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 5: The AllowAccess phase consists in checking the validity of the token
    by end-device and decide either allow or deny access'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the requester presents the authorization token to the end device, this
    later verifies that the authorization token that exists in the TKNList was added
    by the end device's SmartContract. If yes the access is allowed else no.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Compressing the authorization token list for lightweight verification: In the
    above NP statement, IDCMList is specified explicitly as a list of IDcoin commitment.
    This straightforward representation severely limits scalability because the time
    and space complexity of most protocol algorithms (e.g., the proof verification
    algorithm) grows linearly with IDCMList. Furthermore, authorization token corresponding
    to already spent IDcoins cannot be dropped from IDCMList to reduce costs, since
    they cannot be identified (due to the same zero-knowledge property that provides
    anonymity). As in [[60]](S0065245818300676.xhtml#bb9020), we rely on a collision-resistant
    hash function CRH to avoid an explicit representation of IDCMList. We maintain
    an efficiently updatable append-only CRH-based Merkle tree Tree(IDCMList) over
    the (growing) list IDCMList. Letting rt denote the root of Tree(IDCMList), it
    is well-known that updating rt to account for insertion of new leaves can be done
    with time and space proportional to the tree depth. Hence, the time and space
    complexity is reduced from linear in the size of IDCMList to logarithmic. With
    this in mind, we modify the NP statement to the following one: “I know r such
    that COMM[r](sn) appears as a leaf in a CRH-based Merkle tree whose root is rt.”
    Compared with the naive data structure for IDCMList, this modification increases
    exponentially the size of IDCMList which a given zk-SNARK implementation can support.
    We do the same things with the authorization token List TKNList (see [Fig. 16](S0065245818300676.xhtml#f0080)).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 16](images/S0065245818300676/f08-15-9780128171899.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Fig. 16 CRH-based tree over Authorization token (tkn).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: This ends the outline of the construction. We conclude by noting that, due to
    the zk-SNARK, our construction requires a one-time trusted setup of public parameters.
    The trust affects soundness of the proofs, though anonymity continues to hold
    even if the setup is corrupted by a malicious party.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms Constructions: We describe the construction of the PPDAP scheme = (SystemSetup;
    AuthoritySetup, CreateAddress, GrantAccess, RequestAccess, GetAccess, VerifyTransaction;
    AllowAccess) in [Figs. 17](S0065245818300676.xhtml#f0090) and [18](S0065245818300676.xhtml#f0095).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 17](images/S0065245818300676/f08-17-9780128171899.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: Fig. 17 PPDAC Privacy-preserving distributed access control (part1/2).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig. 18](images/S0065245818300676/f08-18-9780128171899.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Fig. 18 PPDAC Privacy-preserving distributed access control (part2/2).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 6 Conclusion
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter we have presented our approach to tackle privacy and security
    issues in IoT. More specifically, this approach consisted in providing a distributed
    access control framework that respects the following principles: edge intelligence,
    security through transparency, privacy by design and user-driven policy. Then,
    we have introduced FairAccess as a novel, stronger and transparent access control
    solution that met the four defined principles. FairAccess leverages the consistency
    offered by blockchain-based cryptocurrencies to solve all IoT-related access control
    challenges. While FairAccess leverages the consistency offered by blockchain-based
    cryptocurrencies to solve the problem of centralized and decentralized access
    control in IoT and provide a promising user-driven and transparent access control
    tool, it fails to guarantee a strong anonymity for users due to the public nature
    of the blockchain and its inherent traceability problem. To overcome this issue,
    a fully anonymous privacy-preserving Distributed access control scheme (PPDAC)
    was introduced in this chapter. PPDAC was integrated over FairAccess to maintain
    Blockchain transparency features while ensuring strong privacy guarantees for
    users. In this direction, attribute-based access control systems have been used,
    where access control decisions are based on the attributes (rather than the identity).
    A policy-hiding access control scheme that protects both sensitive attributes
    and sensitive policies has been developed using a white box version of distributed
    multi-authority cipher-text policy attribute based encryption DMCP-ABE. In addition,
    to face the traceability problem of authorization tokens a sufficient non-interactive
    zero proof of knowledge (zk-SNARK) protocol has been introduced. Finally, the
    formal definition and a construction of the proposed scheme were provided.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: To conclude we summarize the answers to the research questions formulated in
    [Section 3](S0065245818300676.xhtml#s0035).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 1. How to solve access control challenges in IoT by leveraging the blockchain
    technology?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The vision of our decentralized access control framework is a system of autonomous
    organizations hinged around one or many Resource Owners in possession of one or
    many resources identified with addresses and interacting between each other through
    transactions (requesting, granting, delegating and revoking access) under the
    control of their RO. The blockchain is a ledger keeping track and ensures the
    validity of access transaction among interacting organization. Each manages its
    own access policy, under only the control of his Resource Owner. Actually, in
    FairAccess, we use Bitcoin-like addresses to identify all interacting entities
    and SmartContract (a.k.a. chain code) to express fine-grained and contextual access
    control policies enveloped inside transactions. We opt for authorization tokens
    distributed by the blockchain. FairAccess provides several useful mechanisms using
    the blockchain. In fact, in FairAccess, the blockchain is considered as a database
    or a policy retrieval point, where all access control policies are stored in form
    of transactions; it serves also as logging databases that ensure auditing functions.
    Furthermore, it prevents forgery of token through transactions integrity checks
    and detects token reuse through the double spending detection mechanism.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2. How to provide a lightweight access control framework for constrained IoT
    devices despite the intensive computation power required by the consensus protocol
    adopted by the public blockchain?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We answer to this question by proposing a hierarchical architecture where devices
    in the IoT support different degrees of FairAccess functionality, depending on
    their performance and storage capabilities.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3. How to enable a privacy preserving access control that hides user's access
    control policy and overcome the problem of traceability and profiling commonly
    known in the public blockchain?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We overcome this issue by introducing PPDAC a fully anonymous privacy-preserving
    Distributed access control scheme to be integrated over FairAccess to get a strong
    privacy guarantees access control scheme that preserves the Resource owner''s
    access control policies and the requester''s sensitive attributes and preserves
    in a strong way the anonymity of the requester and the Ro. The proposed scheme
    aims to maintain Blockchain transparency features while ensuring strong privacy
    guarantees for users. We use attribute-based access control systems, where access
    control decisions are based on the attributes (rather than the identity) of the
    requester: Access is granted if Alice''s attributes in her certificates satisfy
    Bob''s access policy. We develop a policy-hiding access control scheme that protects
    both sensitive attributes and sensitive policies. That is, nodes in the public
    blockchain can decide whether Alice''s certified attribute values satisfy Bob''s
    policy, without learning any other information about Alice''s attribute values
    nor Bob''s policy. Our construction for PPDAC uses a novel technique that combines
    CP-ABE, szNARK protocols and SmartContract.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] Benessia A., Pereira Â.G. The dream of the Internet of things. In: *Science,
    Philosophy and Sustainability: The End of the Cartesian Dream 5, vol. 78.* 2015\.
    Retrieved from [https://books.google.com/books?hl=fr&lr=&id=_K7ABgAAQBAJ&oi=fnd&pg=PA78&dq=decentralizing++internet+of+things+ibm+watson+&ots=O98rKriJQ1&sig=Kz5bB4EJ80hSktroqnbo_ScvSZM](https://books.google.com/books?hl=fr&lr=&id=_K7ABgAAQBAJ&oi=fnd&pg=PA78&dq=decentralizing++internet+of+things+ibm+watson+&ots=O98rKriJQ1&sig=Kz5bB4EJ80hSktroqnbo_ScvSZM).'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Gubbi J., Buyya R., Marusic S., Palaniswami M. Internet of things (IoT):
    a vision, architectural elements, and future directions. *Future Gener. Comput.
    Syst.* 2013;29(7):1645–1660\. [https://doi.org/10.1016/j.future.2013.01.010](https://doi.org/10.1016/j.future.2013.01.010).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Miorandi D., Sicari S., De Pellegrini F., et al. Internet of things: vision,
    applications and research challenges. *Ad Hoc Netw.* 2012;10(7):1497–1516\. Retrieved
    from [http://www.sciencedirect.com/science/article/pii/S1570870512000674](http://www.sciencedirect.com/science/article/pii/S1570870512000674).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Borgia E. The internet of things vision: key features, applications and
    open issues. *Comput. Commun.* 2014;54:1–31\. [https://doi.org/10.1016/j.comcom.2014.09.008](https://doi.org/10.1016/j.comcom.2014.09.008).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Mattern F., Floerkemeier C. *From the Internet of Computers to the Internet
    of Things.* Springer Berlin Heidelberg; 2010.242–259\. [https://doi.org/10.1007/978-3-642-17226-7_15](https://doi.org/10.1007/978-3-642-17226-7_15).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[6] Guinard D. *A Web of Things Application Architecture—Integrating the Real-World
    Into the Web.* PhD Thesis, ETH Zurich (19891), 220 [https://doi.org/10.3929/ethz-a-006713673](https://doi.org/10.3929/ethz-a-006713673).
    2011.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Bonomi F., Milito R., Zhu J., Addepalli S. *Fog computing and its role
    in the internet of things.* In: Proceedings of the First Edition of the MCC Workshop
    on Mobile Cloud Computing—MCC’12; New York: ACM Press; 2012:13\. [https://doi.org/10.1145/2342509.2342513](https://doi.org/10.1145/2342509.2342513).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[8] Jardak C., Walewski J.W. *Enabling Things to Talk.* [https://doi.org/10.1007/978-3-642-40403-0](https://doi.org/10.1007/978-3-642-40403-0).
    2013.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[9] Holler J., Tsiatsis V., Mulligan C., Avesand S. *From Machine-to-Machine
    to the Internet of Things: Introduction to a New Age of Intelligence.* Academic
    Press; 2014\. Retrieved from [https://books.google.com/books?hl=fr&lr=&id=wtfEAgAAQBAJ&oi=fnd&pg=PP1&dq=From+Machine-To-Machine+to+the+Internet+of+Things:+Introduction+to+a+New+Age+of+Intelligence+&ots=mICCLT9hgD&sig=UNQUKzbr7Co6cDF9jn8P9FL_01Q](https://books.google.com/books?hl=fr&lr=&id=wtfEAgAAQBAJ&oi=fnd&pg=PP1&dq=From+Machine-To-Machine+to+the+Internet+of+Things:+Introduction+to+a+New+Age+of+Intelligence+&ots=mICCLT9hgD&sig=UNQUKzbr7Co6cDF9jn8P9FL_01Q).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[10] Vermesan O., Friess P., eds. *Internet of Things: Converging Technologies
    for Smart Environments and Integrated Ecosystems.* River Publishers; 2013.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[11] Armitage J. *Paul Virilio: From Modernism to Hypermodernism and Beyond.*
    Retrieved from [https://books.google.com/books?hl=fr&lr=&id=-WL75BiQBRYC&oi=fnd&pg=PP1&dq=PAUL++virilio+Politics+of+the+Very+Worst+&ots=0AmM0dctMV&sig=QpI5pdafuGVLP4hr88N3kSb9i_A](https://books.google.com/books?hl=fr&lr=&id=-WL75BiQBRYC&oi=fnd&pg=PP1&dq=PAUL++virilio+Politics+of+the+Very+Worst+&ots=0AmM0dctMV&sig=QpI5pdafuGVLP4hr88N3kSb9i_A).
    2000.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[12] Kumar J.S., Patel D.R. A survey on Internet of things: Security and privacy
    issues. *Int. J. Comput. Appl.* 2014;90(11) MLA.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[13] Decker C., Seidel J., Wattenhofer R. Bitcoin meets strong consistency.
    *Proceedings of the 17th International Conference on Distributed Computing and
    Networking.* 2016;13: ACM.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[14] Vasilomanolakis E., Daubert J., Luthra M., Gazis V., Wiesmaier A., Kikiras
    P. On the security and privacy of Internet of things architectures and systems.
    In: *Secure Internet of Things (SIoT).* International Workshop on IEEE.ISO; 49–57\.
    2015;690.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[15] Ziegeldorf J.H., Morchon O.G., Wehrle K. Privacy in the internet of things:
    threats and challenges. *Secur. Commun. Netw.* 2014;7(12):2728–2742\. [https://doi.org/10.1002/sec.795](https://doi.org/10.1002/sec.795).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[16] Langheinrich M. *Privacy by Design—Principles of Privacy-Aware Ubiquitous
    Systems.* Springer Berlin Heidelberg; 2001.273–291\. [https://doi.org/10.1007/3-540-45427-6_23](https://doi.org/10.1007/3-540-45427-6_23).'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[17] Ziegeldorf J.H., Morchon O.G., Wehrle K. Privacy in the internet of things:
    threats and challenges. *Secur. Commun. Netw.* 2014;7(12):2728–2742\. [https://doi.org/10.1002/sec.795](https://doi.org/10.1002/sec.795).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[18] Berman F., Cerf V.G. Social and ethical behavior in the internet of things.
    *Commun. ACM.* 2017;60(2):6–7\. [https://doi.org/10.1145/3036698](https://doi.org/10.1145/3036698).'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[19] E.P. Goodman, The atomic age of data: Policies for the Internet of things,
    The Report Explores Some of These Policy Questions in the Context of the “Smart
    City” Use Case, ISO 690, 2015.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[20] Diaz C., Gürses S., Troncoso C. Engineering privacy by design. *Comput.
    Priv. Data Prot.* 2011\. Retrieved from [https://software.imdea.org/~carmela.troncoso/papers/Gurses-CPDP11.pdf](https://software.imdea.org/~carmela.troncoso/papers/Gurses-CPDP11.pdf).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[21] Gurses S., del Alamo J.M. Privacy engineering: shaping an emerging field
    of research and practice. *IEEE Secur. Priv.* 2016;14(2):40–46\. [https://doi.org/10.1109/MSP.2016.37](https://doi.org/10.1109/MSP.2016.37).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[22] Spiekermann S., Cranor L.F. Engineering privacy. *IEEE Trans. Softw. Eng.*
    2009;35(1):67–82\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/4657365/](http://ieeexplore.ieee.org/abstract/document/4657365/).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[23] Sánchez Alcón J.A., López L., Martínez J.F., et al. Trust and privacy
    solutions based on holistic service requirements. *Sensors (Basel).* 2015;16(1):16\.
    Retrieved from [http://www.mdpi.com/1424-8220/16/1/16/htm](http://www.mdpi.com/1424-8220/16/1/16/htm).'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[24] Cavoukian A. Privacy by design in law, policy and practice. In: *A White
    Paper for Regulators, Decision-Makers and Policy-Makers.* 2011.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[25] Ouaddah A., Abou Elkalam A., Ait Ouahman A. FairAccess: a new blockchain-based
    access control framework for the internet of things. *Secur. Commun. Netw.* 2016;9(18):5943–5964\.
    [https://doi.org/10.1002/sec.1748](https://doi.org/10.1002/sec.1748).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[26] Ouaddah A., Elkalam A.A., Ouahman A.A. *Towards a Novel Privacy-Preserving
    Access Control Model Based on Blockchain Technology in IoT.* Cham: Springer; 2017.523–533\.
    [https://doi.org/10.1007/978-3-319-46568-5_53](https://doi.org/10.1007/978-3-319-46568-5_53).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[27] Ouaddah A., Mousannif H., Abou Elkalam A., Ait Ouahman A. Access control
    in the internet of things: big challenges and new opportunities. *Comput. Netw.*
    2017;112:237–262\. [https://doi.org/10.1016/j.comnet.2016.11.007](https://doi.org/10.1016/j.comnet.2016.11.007).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[28] Sandhu R.S. Role-based access control. *Adv. Comput.* 1998;46:237–286\.
    [https://doi.org/10.1016/S0065-2458(08)60206-5](https://doi.org/10.1016/S0065-2458(08)60206-5).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[29] Yuan E., Tong J. *Attributed based access control (ABAC) for Web services.*
    In: IEEE International Conference on Web Services (ICWS’05); IEEE; 2005\. [https://doi.org/10.1109/ICWS.2005.25](https://doi.org/10.1109/ICWS.2005.25).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[30] Seitz L., Selander G., Wahlstroem E., Erdtman S., Tschofenig H. *Authorization
    for the Internet of Things Using OAuth 2.0.* Retrieved from [https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-01](https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-01).
    2016.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[31] Cirani S., Picone M., Gonizzi P., Veltri L., Ferrari G. IoT-OAS: an oauth-based
    authorization service architecture for secure services in IoT scenarios. *IEEE
    Sensors J.* 2015;15(2):1224–1234\. [https://doi.org/10.1109/JSEN.2014.2361406](https://doi.org/10.1109/JSEN.2014.2361406).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[32] Roman R., Zhou J., Lopez J. On the features and challenges of security
    and privacy in distributed internet of things. *Comput. Netw.* 2013;57(10):2266–2279\.
    [https://doi.org/10.1016/j.comnet.2012.12.018](https://doi.org/10.1016/j.comnet.2012.12.018).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[33] Cirani S., Davoli L., Ferrari G., Léone R. A scalable and self-configuring
    architecture for service discovery in the internet of things. *IEEE Internet Things
    J.* 2014;1:508–521\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/6899579/](http://ieeexplore.ieee.org/abstract/document/6899579/).'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[34] Said O., Masud M. Towards internet of things: survey and future vision.
    *Int. J. Comput. Netw.* 2013;5(1):1–17\. Retrieved from [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.741.3655&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.741.3655&rep=rep1&type=pdf).'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[35] Tsai C.-W., Lai C.-F., Vasilakos A.V. Future internet of things: open
    issues and challenges. *Wirel. Netw.* 2014;20(8):2201–2217\. [https://doi.org/10.1007/s11276-014-0731-0](https://doi.org/10.1007/s11276-014-0731-0).'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[36] Panikkar S., Nair S., Brody P., Pureswaran V. *ADEPT: An IoT Practitioner
    Perspective.* Retrieved from [http://ibm.biz/devicedemocracy](http://ibm.biz/devicedemocracy).
    2015.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[37] Antonakakis M., April T., Bailey M., et al. Understanding the mirai botnet.
    In: *USENIX Security Symposium.* 2017 1092–1110.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[38] Nakamoto S. *Bitcoin: A Peer-to-Peer Electronic Cash System.* 2008.1–9.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[39] Underwood S. Blockchain beyond bitcoin. *Commun. ACM.* 2016;59(11):15–17.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[40] Swan M. *Blockchain: Blueprint for a New Economy.* Retrieved from [https://books.google.com/books?hl=fr&lr=&id=RHJmBgAAQBAJ&oi=fnd&pg=PR3&dq=BLOCKCHAIN+APPLICATION+BEYOND+FINANCE&ots=XPyHHY-Rg4&sig=xZ1yJTxrIgXGqd22L30op9po8-s](https://books.google.com/books?hl=fr&lr=&id=RHJmBgAAQBAJ&oi=fnd&pg=PR3&dq=BLOCKCHAIN+APPLICATION+BEYOND+FINANCE&ots=XPyHHY-Rg4&sig=xZ1yJTxrIgXGqd22L30op9po8-s).
    2015.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[41] Ulieru M. Blockchain 2.0 and beyond: adhocracies. In: *Banking Beyond
    Banks and Money.* 2016\. Retrieved from [http://link.springer.com/chapter/10.1007/978-3-319-42448-4_15](http://link.springer.com/chapter/10.1007/978-3-319-42448-4_15).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[42] Carter J.L., Wegman M.N. Universal classes of hash functions. *J. Comput.
    Syst. Sci.* 1979;18(2):143–154\. Retrieved from [http://www.sciencedirect.com/science/article/pii/0022000079900448](http://www.sciencedirect.com/science/article/pii/0022000079900448).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[43] Merkle R.C. *A digital signature based on a conventional encryption function.*
    In: Conference on the Theory and Application of Cryptographic Techniques; Berlin,
    Heidelberg: Springer; 1987\. 369–378, Retrieved from [http://link.springer.com/chapter/10.1007/3-540-48184-2_32](http://link.springer.com/chapter/10.1007/3-540-48184-2_32).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[44] Lamport L., Shostak R., Pease M. The byzantine generals problem. *ACM
    Trans. Program. Lang. Syst.* 1982;4(3):382–401\. Retrieved from [http://dl.acm.org/citation.cfm?id=357176](http://dl.acm.org/citation.cfm?id=357176).'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[45] Tschorsch F., Scheuermann B. Bitcoin and beyond: a technical survey on
    decentralized digital currencies. *IEEE Commun. Surv. Tutor.* 2016;18(3):2084–2123\.
    Retrieved from [http://ieeexplore.ieee.org/abstract/document/7423672/](http://ieeexplore.ieee.org/abstract/document/7423672/).'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[46] Wang W., Hoang D.T., Xiong Z., et al. *A Survey on consensus mechanisms
    and mining management in blockchain networks.* 2018 arXiv preprint arXiv:1805.02707.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[47] Buterin V. A next-generation smart contract and decentralized application
    platform. In: *Ethereum.* 2014:1–36\. Retrieved from [http://buyxpr.com/build/pdfs/EthereumWhitePaper.pdf](http://buyxpr.com/build/pdfs/EthereumWhitePaper.pdf).'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[48] Christidis K., Devetsikiotis M. Blockchains and smart contracts for the
    internet of things. *IEEE Access.* 2016;4:2292–2303\. Retrieved from [http://ieeexplore.ieee.org/abstract/document/7467408/](http://ieeexplore.ieee.org/abstract/document/7467408/).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[49] Caldwell J. *IBM Internet of Things Point of View and Strategy.* 2015.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[50] Conoscenti M., Vetrò A., Martin J.D. *Blockchain for the Internet of Things:
    A Systematic Literature Review.* Retrieved from [http://porto.polito.it/id/eprint/2650266](http://porto.polito.it/id/eprint/2650266).
    2016.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[51] Ouaddah A., Bellaj B. FairAccess 2.0: a smart contract-based authorization
    framework for enabling granular access control in IoT. *Int. J. Inf. Comput. Secur.
    (IJICS).* 2018.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[52] Reid F., Harrigan M. *An analysis of anonymity in the bitcoin system,
    in: Security and Privacy in Social Networks.* New York: Springer New York; 2013.197–223\.
    [https://doi.org/10.1007/978-1-4614-4139-7_10](https://doi.org/10.1007/978-1-4614-4139-7_10).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[53] Ron D., Shamir A. *Quantitative Analysis of the Full Bitcoin Transaction
    Graph.* Berlin Heidelberg: Springer; 2013.6–24\. [https://doi.org/10.1007/978-3-642-39884-1_2](https://doi.org/10.1007/978-3-642-39884-1_2).'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[54] Bethencourt J., Sahai A., Waters B. Ciphertext-policy attribute-based
    encryption. [IEEE]. In: *2007 IEEE Symposium on Security and Privacy (SP’07).*
    2007:321–334\. [https://doi.org/10.1109/SP.2007.11](https://doi.org/10.1109/SP.2007.11).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[55] Cheung L., Newport C. Provably secure ciphertext policy ABE. In: *Proceedings
    of the 14th ACM Conference on Computer and Communications Security, ACM.* 2007:456–465\.
    Retrieved from [http://dl.acm.org/citation.cfm?id=1315302](http://dl.acm.org/citation.cfm?id=1315302).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[56] Bitansky N., Chiesa A., Ishai Y., Paneth O., Ostrovsky R. *Succinct Non-interactive
    Arguments via Linear Interactive Proofs.* Berlin, Heidelberg: Springer; 2013.315–333\.
    [https://doi.org/10.1007/978-3-642-36594-2_18](https://doi.org/10.1007/978-3-642-36594-2_18).'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[57] Beimel A., סומע למיב. *Secure schemes for secret sharing and key distribution.*
    Technion-Israel Institute of Technology, Faculty of Computer Science; 1996.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[58] Han J., Susilo W., Mu Y., Zhou J., Ho Allen Au M. Improving privacy and
    security in decentralized ciphertext-policy attribute-based encryption. *IEEE
    Trans. Inf. Forensics Secur.* 2015;10(3):665–678.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[59] Chase M. Multi-authority attribute based encryption. In: *Theory of Cryptography.*
    Berlin, Heidelberg: Springer Berlin Heidelberg; 2007:515–534.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[60] Sander T., Ta-Shma A. Auditable, anonymous electronic cash. In: *Advances
    in Cryptology—CRYPTO’ 99.* Berlin, Heidelberg: Springer; 1999:555–572\. [http://link.springer.com/10.1007/3-540-48405-1_35](http://link.springer.com/10.1007/3-540-48405-1_35)
    (cit. on p. 122).'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![u08-01-9780128171899](images/S0065245818300676/u08-01-9780128171899.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: '**Dr Aafaf Ouaddah** holds a PhD in Computer Science on her work on security
    and privacy in IoT through the blockchain technology from the Cadi Ayyad University,
    Marrakesh (Morocco) in 2017\. She received the Engineer degree in Networking and
    Information Technology in 2013, from the National Institute of Posts and Telecommunication
    (INPT) graduate school engineering. Since 2017, she is a Chief Scientist at Mchain
    enterprise. Her research interests include the blockchain and new distributed
    ledgers as well as security and privacy in distributed systems, IoT, and Fog computing.
    She has published more than 10 research papers in various conferences, workshops
    and International Journals of repute including IEEE, Springer and Elsevier.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: ^([a](S0065245818300676.xhtml#xfn0010 "label")) [http://www.gartner.com/newsroom/id/2209615](http://www.gartner.com/newsroom/id/2209615).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: ^([b](S0065245818300676.xhtml#xfn0015 "label")) [http://share.cisco.com/internet-of-things.html](http://share.cisco.com/internet-of-things.html).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: ^([c](S0065245818300676.xhtml#xfn0020 "label")) [http://iotevent.eu/cisco-sees-14-trillion-opportunity-in-iot/](http://iotevent.eu/cisco-sees-14-trillion-opportunity-in-iot/).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
