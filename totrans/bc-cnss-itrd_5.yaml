- en: as a single leader to propose a new value. Proposers handle client
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单一领导者提出一个新的值。提议者处理客户端
- en: requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 请求。
- en: '• **Acceptor**: Acceptors evaluate and accept or reject proposals'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: • **接受者**：接受者评估并接受或拒绝提议
- en: proposed by the proposers according to several rules and conditions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几个规则和条件由提议者提出。
- en: '• **Learner**: Learns the decision, that is, the agreed-upon value.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: • **学习者**：学习决策，即达成一致的值。
- en: '296'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '296'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: There are also some rules associated with Paxos nodes. Paxos nodes must be
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些与Paxos节点相关的规则。Paxos节点必须是
- en: persistent, that is, they must store what their action is and must remember
    what they’ve
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 持久的，即它们必须存储自己的操作，并且必须记住他们
- en: accepted. Nodes must also know how many acceptors make a majority.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受。节点还必须知道多少接受者构成了多数。
- en: Paxos can be seen as similar to the two-phase commit protocol. A two-phase commit
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos可以被看作类似于两阶段提交协议。两阶段提交
- en: (2PC) is a standard atomic commitment protocol to ensure that the transactions
    are
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: (2PC)是一个标准的原子提交协议，用来确保事务
- en: committed in distributed databases only if all participants agree to commit.
    Even if a
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在所有参与者同意提交的情况下，分布式数据库才能提交。即使一个
- en: single node does not agree to commit the transaction, it is rolled back completely.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单个节点不同意提交事务，事务将被完全回滚。
- en: Similarly, in Paxos, the proposer sends a proposal to the acceptors in the first
    phase.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Paxos中，提议者在第一阶段向接受者发送提议。
- en: Then, the proposer broadcasts a request to commit to the acceptors if and when
    they
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，提议者向接受者广播请求以提交，如果他们
- en: accept the proposal. Once the acceptors commit and report back to the proposer,
    the
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接受提议。一旦接受者提交并回报给提议者，协议
- en: proposal is deemed final, and the protocol concludes. In contrast with the two-phase
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提议被认为是最终的，并且协议结束。与两阶段相比
- en: commit, Paxos introduced ordering, that is, sequencing, to achieve the total
    order of
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提交，Paxos引入了有序性，即顺序化，以实现提案的总排序
- en: the proposals. In addition, it also introduced a majority quorum–based acceptance
    of
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提议。此外，它还引入了基于多数法定人数的接受
- en: the proposals rather than expecting all nodes to agree. This scheme allows the
    protocol
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是期望所有节点都同意。此方案允许协议
- en: to make progress even if some nodes fail. Both improvements ensure the safety
    and
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一些节点失败，也能取得进展。这两项改进确保了安全和
- en: liveness of the Paxos algorithm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos算法的健壮性。
- en: The protocol is composed of two phases, the prepare phase and the accept phase.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 协议由两个阶段组成，准备阶段和接受阶段。
- en: At the end of the prepare phase, a majority of acceptors have promised a specific
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备阶段结束时，多数接受者已经承诺了一个特定的
- en: proposal number. At the end of the accept phase, a majority of acceptors have
    accepted a
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提议号。在接受阶段结束时，多数接受者已经接受了一个
- en: proposed value, and consensus is reached.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的值，并且达成了一致。
- en: 'The algorithm works as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 算法工作如下：
- en: '**Phase 1 – prepare phase**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段1 - 准备阶段**'
- en: • The proposer receives a request to reach consensus on a value by
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: • 提议者收到要通过接受者就某个值达成共识的请求
- en: a client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个客户端。
- en: • The proposer sends a message *prepare*( *n*) to a majority or all
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: • 提议者向大多数或所有接受者发送消息 *prepare*( *n*)
- en: acceptors. At this stage, no value is proposed for a decision yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，还没有为决定提出任何值。
- en: The majority of acceptors is enough under the assumption that
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设的情况下，多数接受者已经足够了
- en: all acceptors in the majority will respond. Here, the *n* represents
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受者中的多数会做出响应。在这里，*n*代表
- en: the proposal number which must be globally unique and must be
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 必须是全局唯一的提议号，并且必须是
- en: greater than any proposal number this proposer has used before.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 比该提议者以往使用的任何提议号更大。
- en: For example, *n* can be a timestamp in nanoseconds or some other
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*n*可以是纳秒级的时间戳或其他某个时间
- en: incrementing value. If a timeout occurs, then the proposer will retry
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 递增值。如果发生超时，那么提议者将重试
- en: with a higher *n*. In other words, if the proposer is unable to make
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高的 *n*。换句话说，如果提议者无法
- en: progress due to a lack of responses from the acceptors, it can retry
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有来自接受者的响应而无法取得进展，它可以重试
- en: with a higher proposal number.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高的提议号。
- en: '297'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '297'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: • When an acceptor receives this *prepare*( *n*) message, it makes a
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • 当接受者收到这个 *prepare*( *n*) 消息时，它会
- en: '“promise.” It performs the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “承诺”。它执行以下操作：
- en: • If no previous promise has been made by responding to the
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果没有通过响应这个
- en: prepare message, then the acceptor now promises to ignore any
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 准备消息，那么接受者现在承诺忽略任何
- en: request less than the proposal number *n*. It records *n* and replies
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 小于提议编号*n*的请求。它记录*n*并回复
- en: with message *promise*( *n*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 带有消息*promise*(*n*)。
- en: • If the acceptor has previously promised, that is, already
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果接受者之前承诺过，也就是，已经
- en: responded to another prepare message with some proposal
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 响应另一个带有一些提议的准备消息
- en: 'number lower than *n*, the acceptor performs the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编号低于*n*，接受者执行以下操作：
- en: • If the acceptor has not received any accept messages already
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果接受者还没有收到任何接受消息
- en: from a proposer in the accept phase, it stores the higher proposal
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受阶段来自提议者，它存储更高的提议
- en: number *n* and then sends a promise message to the proposer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编号*n*，然后向提议者发送承诺消息。
- en: • If the acceptor has received an accept message earlier with some
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果接受者之前收到过带有一些接受消息
- en: other lower proposal number, it must have already accepted a
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其他更低的提议编号，它必须已经接受过
- en: proposed value from some proposer. This previous full proposal
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个提议者提议的值。此前完整提议
- en: is now sent along with the promise message to the proposer,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将带着承诺消息发送给提议者，
- en: indicating that the acceptor has already accepted a value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表示接受者已经接受了一个值。
- en: '**Phase 2 – accept phase**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二阶段——接受阶段**'
- en: Phase 2 starts when the proposer has received enough responses, that is, promise
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当提议者收到足够的响应时，即承诺
- en: 'messages, from the majority of the acceptors for a specific *n*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从多数接受者，对于特定的*n*：
- en: • The proposer waits until it gets responses from the majority of the
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: • 提议者等待直到获得大多数的响应
- en: acceptors for *n*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者对*n*的确定值学习。
- en: • When responses are received, the proposer evaluates what value *v* to
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: • 当收到响应时，提议者评估值*v*该如何
- en: 'be sent in the accept message. It performs the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到接受消息。它执行以下操作：
- en: • If the proposer received one or more promise messages with full
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果提议者收到一个或多个包含完整承诺消息
- en: proposals, it chooses the value *v* in the proposal with the highest
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提议，它选择提议中拥有最高部价值*v*的值
- en: proposal number.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提议编号。
- en: • If no promise messages received by the proposer include a full
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果提议者收到的承诺消息中没有包括完整的
- en: proposal, the proposer can choose any value it wants.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提议，提议者可以选择任何它想要的值。
- en: • The proposer now sends an accept message – a full proposal of the
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: • 现在提议者发送接受消息——完整提议的
- en: form *accept*( *n*, *v*) – to the acceptors, where *n* is the promised proposal
    number and *v* is the actual proposed value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 形式*accept*(*n*, *v*)——发送给接受者，其中*n*是承诺的提议编号，*v*是实际提议的值。
- en: '298'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '298'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '• When an acceptor receives this *accept*( *n*, *v*) message, it does the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: • 当接受者收到这个*accept*(*n*, *v*)消息时，它会执行以下操作：
- en: • If the acceptor has promised not to accept this proposal number
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果接受者承诺不接受这个提议编号
- en: previously, it will ignore the message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，它将忽略消息。
- en: • Otherwise, if it has responded to the corresponding prepare
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: • 否则，如果它已经响应了对应的准备
- en: request with the same *n*, that is, *prepare*( *n*), only then it replies with
    *accepted*( *n*, *v*) indicating acceptance of the proposal.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 带有相同*n*的请求，也就是*prepare*(*n*)，然后才回复*accepted*(*n*, *v*)表示接受提议。
- en: • Finally, the acceptor sends *accepted*( *n*, *v*) to all learners.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: • 最后，接受者向所有学习者发送*accepted*(*n*, *v*)。
- en: • If a majority of acceptors accept the value *v* in the proposal, then *v*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果大多数接受者接受提议中的值*v*，那么*v*
- en: becomes the decided value of the protocol i.e., consensus is reached.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 成为协议的决定值，即达成共识。
- en: Sometimes, there is a distinction made between the accept phase and a third
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会对接受阶段和第三阶段进行区分
- en: phase called the learning phase where learners learn about the decided value
    from the
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段称为学习阶段，学习者从
- en: acceptors. We have not shown that separately in the preceding algorithm, as
    learning
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者。在前面的算法中，我们没有单独显示这一点，因为学习
- en: is considered part of the second phase. As soon as a proposal is accepted in
    the accept
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是第二阶段的一部分。一旦提议在接受阶段被接受
- en: phase, the acceptor informs the learners. Figur[e 7-3 do](#p315)es show a third
    phase called the learn phase, but it is just for visualizing the protocol in a
    simpler way; learning is in fact part of phase 2, the accept phase.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段，接受者向学习者通知。图[7-3 do](#p315)es显示一个称为学习阶段的第三阶段，但这只是为了以更简单的方式可视化协议；学习实际上是第2阶段——接受阶段的一部分。
- en: We have used the term majority indicating that a majority of acceptors have
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“多数”这个术语表示大多数接受者已经
- en: responded to or accepted a message. Majority comes from a quorum. In the majority
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 响应或接受的消息。多数来自选民。在多数情况下
- en: '*n*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*'
- en: quorum, every quorum has
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 法定人数，每个法定人数都有
- en: +1 nodes. Also note that in order to tolerate *f* faulty
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: +1 节点。此外请注意，为了容忍*f*个故障
- en: '2'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: acceptors, at least a set consisting of 2 *f* + 1 acceptors is required. We
    discussed quorum systems in Chapter [3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者，至少需要一个由 2 *f* + 1 个接受者组成的集合。我们在 [3](https://doi.org/10.1007/978-1-4842-8179-6_3)
    章讨论了法定系统。
- en: The protocol is illustrated in Figur[e 7-3](#p315).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议如图 [7-3](#p315) 所示。
- en: '299'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '299'
- en: '![](index-315_1.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](index-315_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章 经典共识
- en: '***Figure 7-3\.** A normal run of Paxos*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-3.** Paxos 的正常运行*'
- en: Note that the Paxos algorithm once reached a single consensus will not proceed
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Paxos 算法一旦达成单一共识就不会继续
- en: to another consensus. Another run of Paxos is needed to reach another consensus.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到达另一个共识。需要再次运行 Paxos 来达成另一个共识。
- en: Moreover, Paxos cannot make progress if half or more than half of the nodes
    are faulty
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一半或一半以上的节点是错误的，Paxos 无法取得进展
- en: because in such a case a majority cannot be achieved, which is essential for
    making
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这种情况下无法达到多数，这对于制定是至关重要的
- en: progress. It is safe because once a value is agreed, it is never changed. Even
    though Paxos is guaranteed to be safe, liveness of the protocol is not guaranteed.
    The assumption here is that a large portion of the network is correct (nonfaulty)
    for adequately enough time, and then the protocol reaches consensus; otherwise,
    the protocol may never terminate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 进展。它是安全的，因为一旦达成协议，就不会再改变。虽然 Paxos 被保证是安全的，但是协议的活性没有得到保证。这里的假设是网络的大部分正确（非故障）足够长时间，那么协议就会达成一致；否则，协议可能永远不会终止。
- en: Usually, learners learn the decision value directly from the acceptors; however,
    it is
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，学习者会直接从接受者那里学到决定值；然而，这是
- en: possible that in a large network learners may learn values from each other by
    relaying
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型网络中，学习者可能通过中继相互学习值。
- en: what some of them (a small group) have learned directly from acceptors. Alternatively,
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 他们中的一些（少数人）直接从接受者那里学到了什么。或者，
- en: learners can poll the acceptors at intervals to check if there’s a decision.
    There can also be an elected learner node which is notified by the acceptors,
    and this elected learner
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 学习者可以定期轮询接受者，以检查是否已经做出了决定。也可以有一个被选举的学习者节点，由接受者通知，这个被选举的学习者
- en: disseminates the decision to other learners.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将决定传播给其他学习者。
- en: Now let’s consider some failure scenarios.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一些故障场景。
- en: '300'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '300'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章 经典共识
- en: '**Failure Scenarios**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障场景**'
- en: Imagine if an acceptor fails in the first phase, that is, the prepare phase,
    then it won’t send the promise message back to the proposer. However, if a majority
    quorum can
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果接受者在第一阶段失败，也就是准备阶段，那它就不会将承诺消息发送回给提出者。但是，如果大多数法定人数可以
- en: respond back, the proposer will receive the responses, and the protocol will
    make
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回应后，提议者将收到回应，并且协议将制定
- en: progress. If an acceptor fails in the second phase, that is, the accept phase,
    then the
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 进展。如果接受者在第二阶段失败，也就是接受阶段，然后
- en: acceptor will not send the accepted message back to the proposer. Here again,
    if the
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者不会将接受的消息发回给提出者。同样，如果
- en: majority of the acceptors is correct and available, the proposer and learners
    will receive enough responses to proceed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 多数接受者是正确的和可用的，提出者和学习者将收到足够的回应继续进行。
- en: What if the proposer failed either in the prepare phase or the accept phase?
    If a
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在准备阶段或接受阶段中提出者失败了会怎么样？如果一个
- en: proposer fails before sending any prepare messages, there is no impact; some
    other
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提出者在发送任何准备消息之前失败了，没有影响；另一些
- en: proposer will run, and the protocol will continue. If a proposer fails in phase
    1, after
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提出者将运行，并且协议将继续。如果提议者在第一阶段失败之后
- en: sending the prepare messages, then acceptors will not receive any accept messages,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 发送准备消息，那么接受者将不会收到任何接受消息，
- en: because promise messages did not make it to the proposer. In this case, some
    other
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有承诺消息传递给了提出者。在这种情况下，其他一些
- en: proposer will propose with a higher proposal number, and the protocol will progress.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提出者将提出更高的提议编号，协议将继续进行。
- en: The old prepare will become history. If a proposer fails during the accept phase
    after
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的准备将变成历史。如果提议者在接受阶段失败后
- en: sending the accept message which was received by at least one acceptor, some
    other
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 发送至少一个接受者接收的接受消息，一些其他
- en: proposer will send a prepare message with a higher proposal number, and the
    acceptor
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提出者将发送一个带有更高提议编号的准备消息，接受者
- en: will respond to the proposer with a promise message that an earlier value is
    already
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将会回复给提案者一个承诺消息，说明较早的值已经被接受。
- en: accepted. At this point, the proposer will switch to proposing the same earlier
    value
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受。此时，提案者会转而提议相同的较早值
- en: bearing the highest accepted proposal number, that is, send an accept message
    with the
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 携带最高已接受提案编号，即，发送一条携带
- en: same earlier value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的较早值。
- en: Another scenario could be if there are two proposers trying to propose their
    value at
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况可能是如果有两位提案者试图在
- en: the same time. Imagine there are two proposers who have sent their prepare messages
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有两位提案者已经发送了他们的准备消息
- en: to the acceptors. In this case, any acceptor who had accepted a larger proposal
    number
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 给接受者。在这种情况下，任何接受者如果接受了更大的提案编号
- en: previously from P1 would ignore the proposal if the proposal number proposed
    by the
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前从P1收到的提案将忽略
- en: proposer P2 is lower than what acceptors had accepted before. If there is an
    acceptor
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提案者P2较低于接受者以前接受的提案编号。如果有接受者
- en: A3 who has not seen any value before, it would accept the proposal number from
    P2
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有看到任何之前的值的A3，则会接受来自P2的提案编号
- en: even if it is lower than the proposal number that the other acceptors have received
    and
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它低于其他接受者接受的提案编号，并
- en: accepted from P1 before because the acceptor A3 has no idea what other acceptors
    are
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前从P1接受的，因为接受者A3不知道其他接受者是什么意思
- en: doing. The acceptor will then respond as normal back to P2\. However, as proposers
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 做到。接受者将正常回复给P2\. 然而，由于提案者
- en: wait for a majority of acceptors to respond, P2 will not receive promise messages
    from a
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 等待大多数的接受者回复，P2将不会收到来自承诺消息的回复
- en: majority, because A3 only is not a majority. On the other hand, P1 will receive
    promise
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 多数，因为仅A3不构成多数。另一方面，P1将收到承诺
- en: messages from the majority, because A1 and A2 (other proposers) are in the majority
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 多数的消息，因为A1和A2（其他提案者）在多数派中
- en: and will respond back to P1\. When P2 doesn’t hear from a majority, it times
    out and can
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 并将回复给P1\. 当P2没有听到多数的回复时，它会超时并可以
- en: retry with a higher proposal number.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高提案编号重试。
- en: '301'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '301'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: Now imagine a scenario where with P1 the acceptors have already reached a
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个情景，P1已经到达了接受者
- en: consensus, but there is another proposer P2 which doesn’t know that and sends
    a
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 共识，但是还有另一名提案者P2不知道这一点并发送了一个
- en: prepare message with a higher than before proposal number. The acceptors at
    this point,
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 准备消息用一个比之前更高的提案编号。这时的接受者
- en: after receiving the higher proposal number message from P2, will check if they
    have
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 收到P2的更高提案编号消息后，将检查它们是否在同一时间。
- en: accepted any message at all before; if yes, the acceptors will respond back
    to P2 with
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前是否接受过任何消息；如果是的话，接收者将用承诺消息回复给P2
- en: the promise message of the form promise(nfromp2,(nfromp1, vfromp1)) containing
    the
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 包含承诺消息承诺（nfromp2，（nfromp1，vfromp1））的
- en: previous highest proposal number they have accepted, along with the previous
    accepted
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所接受的之前的最高提案编号，以及之前的已接受
- en: value. Otherwise, they will respond normally back to P2 with a promise message.
    When
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值。否则，他们将用承诺消息正常地回应给P2。当
- en: P2 receives this message, promise(nfromp2,(nfromp1, vfromp1)), it will check
    the
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: P2收到此消息，承诺（nfromp2，（nfromp1，vfromp1）），它将检查
- en: message, and value v will become vfromp1 if nfromp1 is the highest previous
    proposal
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 消息，并且如果nfromp1是先前提案的最高提案
- en: number. Otherwise, P2 will choose any value v it wants. In summary, if P2 has
    received
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 号。否则，P2将选择任何它想要的值。总之，如果P2已经接收
- en: promise messages indicating that another value has already been chosen, it will
    propose
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 发出承诺消息指示另一个值已经被选择，它将提议
- en: the previously chosen value with the highest proposal number. At this stage,
    P2 will
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最高提案编号的之前选择值。此阶段，P2将
- en: send an accept message with its n and v already chosen (vfromp1). Now acceptors
    are
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以其n和v已经选择的接受消息。现在接受者是
- en: happy because they see the highest n and will respond back with an accepted
    message
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 高兴因为他们看到最高的n并会回复已接受的消息
- en: as normal and will inform learners too. Note that the previously chosen value
    is still the value proposed by P2, just with the highest proposal number n now.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 会如常并通知学习者。请注意，之前选择的值仍然是P2提议的值，只是现在有了最高提案编号n。
- en: There are scenarios where the protocol could get into a livelock state and progress
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能让协议陷入活锁状态并且无法进展
- en: can halt. A scenario could be where two different proposers are competing with
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以停止。一个场景可能是两个不同的提议者正在竞争
- en: proposals. This situation is also known as “dueling proposers.” In such cases,
    the liveness of Paxos cannot be guaranteed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 提议。这种情况也被称为“对决提议者”。在这种情况下，Paxos的活跃性无法得到保证。
- en: Imagine we have two proposers, P1 and P2\. We have three acceptors, A1, A2,
    and A3\.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有两个提议者，P1和P2。我们有三个接受者，A1，A2和A3。
- en: Now, P1 sends the prepare messages to the majority of acceptors, A1 and A2\.
    A1 and A2
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，P1将准备消息发送给大多数接受者，A1和A2。A1和A2
- en: reply with promise messages to P1\. Imagine now the other proposer, P2, also
    proposes
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回答P1的承诺消息。现在想象另一个提议者P2，也提出
- en: and sends a prepare message with a higher proposal number to A2 and A3\. A3
    and A2
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并发送一个更高提议号的准备消息给A2和A3。A3和A2
- en: send the promise back to P2 because, by protocol rules, acceptors will promise
    back to
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 发送承诺消息回应P2，因为按照协议规则，接受者将会在回应P2
- en: the prepare message if the prepare message comes with a higher proposal number
    than
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果准备消息携带的提议号比
- en: what the acceptors have seen before. In phase 2, when P1 sends the accept message,
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者看到过的。在第2阶段，当P1发送接受消息时
- en: A1 will accept it and reply with accepted, but A2 will ignore this message because
    it has already promised a higher proposal number from P2\. In this case, P1 will
    eventually time
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: A1将接受并回复接受消息，但A2将忽略该消息，因为已经承诺从P2获得更高的提议号。在这种情况下，P1最终会超时
- en: out, waiting for a majority response from acceptors because the majority will
    now never
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 等待从接受者那里得到多数回应，因为现在多数永远不可能
- en: respond. Now, P1 will try again with a higher proposal number and send the prepare
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 响应。现在，P1将再次尝试使用更高的提议号发送准备消息
- en: message to A1 and A2\. Assume both A1 and A2 have responded with promise messages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 消息发送给A1和A2。假设A1和A2都回应了承诺消息。
- en: Now suppose P2 sends an accept message to get its value chosen to A2 and A3\.
    A3 will
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设P2发送一个接受消息以使其值被A2和A3选择。A3将
- en: respond with an accepted message, but A2 will not respond to P2 because it has
    already
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回应一个接受消息，但A2不会回应P2，因为它已经
- en: '302'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '302'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: promised another higher proposal number from P1\. Now, P2 will time out, waiting
    for
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺另一个更高的提议号从P1。现在P2将超时，等待
- en: the majority response from the acceptors. P2 now will try again with a higher
    proposal
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从接受者那里得到多数反馈。现在P2将尝试使用更高的提议号
- en: number. This cycle can repeat again and again, and consensus will never be reached
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 号。这个循环可能一次又一次地重复，共识将永远不会达成
- en: because there is never a majority response from the acceptors to any proposers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因为从未有多数反馈从接受者到任何提议者。
- en: This issue is typically handled by electing a single proposer as the leader
    to
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的做法是通过选举一个单一的提议者作为领导者来处理这个问题
- en: administer all clients’ incoming requests. This way, there is no competition
    among
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 管理所有客户端的进入请求。这样，就不会有竞争
- en: different proposers, and this livelock situation cannot occur. However, electing
    a leader is also not straightforward. A unique leader election is equivalent to
    solving consensus. For leader election, an instance of Paxos will have to run,
    that election consensus may get a livelock too, and we are in the same situation
    again. One possibility is to use a different type of election mechanism, for example,
    the bully algorithm. Some other leader
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的提议者，这种活锁情况不会发生。然而，选举一个领导者也并不是一件简单的事情。唯一的领导者选举等同于解决共识问题。对于领导者选举，Paxos的一个实例将必须运行，该领导者选举共识可能也会产生一个活锁，然后我们又面临同样的情况。一个可能的选择是使用一种不同类型的选举机制，例如霸王算法。一些其他领导
- en: election algorithms are presented in works of Aguilera et.al. We may use some
    other
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选举算法在阿吉莱拉等人的作品中有介绍。我们可以使用其他一些
- en: kind of consensus mechanism to elect a leader that perhaps guarantees termination
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一种共识机制来选举一个领导者也许能够保证终止
- en: but somewhat sacrifices safety. Another way to handle the livelock problem is
    to use
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某种程度上牺牲了安全性。处理活锁问题的另一种方式是使用
- en: random exponentially increasing delays, resulting in a client having to wait
    for a while
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随机指数递增的延迟，导致客户端必须等待一段时间
- en: before proposing again. I think these delays may well also be introduced at
    proposers,
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提议。我认为这些延迟可能也出现在提议者身上，
- en: which will result in one proposer taking a bit of precedence over another and
    getting
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个提议者在一定程度上优先于另一个，并且得到
- en: its value accepted before the acceptors could receive another prepared message
    with a
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受者接收另一个准备好的消息之前，其值就被接受了
- en: higher proposal number. Note that there is no requirement in classical Paxos
    to have a
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的提案数量。请注意，经典Paxos中没有要求必须有一个
- en: single elected leader, but in practical implementations, it is commonly the
    case to elect a leader. Now if that single leader becomes the single point of
    failure, then another leader must be elected.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 单个选举出的领导者，但在实际实现中，通常会选择一名领导者。现在如果这个单一的领导者成为了单点故障，那么必须选举出另一名领导者。
- en: A key point to remember is that 2 *f* + 1 acceptors are required for *f* crash
    faults to be tolerated. Paxos can also tolerate omission faults. Suppose a prepare
    message is lost and didn’t make it to acceptors, the proposer will wait and time
    out and retry with a higher
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关键点要记住，即对于*t*个崩溃故障，需要2 *f* + 1个接受者。Paxos也可以容忍遗漏故障。假设一个准备消息丢失了，没有传递给接受者，提议者将等待超时并重新尝试以更高的
- en: proposal number. Also, another proposer can propose meanwhile with a higher
    proposal
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提议编号。另外一名提议者也可以提出更高的提案
- en: number, and the protocol can still work. Also, as only a majority of acceptor
    responses
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数量，并且协议仍然可以工作。此外，由于只有大多数接受者的响应
- en: are required, as long as a majority of messages (2 *f* + 1) made it through
    to the proposer from acceptors, the protocol will progress. It is however possible
    that due to omission
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是必需的，只要大多数消息(2 *f* + 1)从接受者传递给提议者，协议就会进展。然而，由于遗漏可能
- en: faults, the protocol takes longer to reach consensus or may never terminate
    under some
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 故障，协议达成共识所需的时间更长，或者在某些情况下可能永远不会终止
- en: scenarios, but it will always be safe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 情景，但它将始终是安全的。
- en: '303'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '303'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章经典共识
- en: '**Safety and Liveness**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性和活性**'
- en: The Paxos algorithm solves the consensus problem by achieving **safety** and
    **liveness** properties. We have some requirements for each property. Under safety,
    we mainly
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos算法通过实现**安全**和**活性**属性来解决共识问题。我们对每个属性有一些要求。在安全性下，我们主要
- en: have the agreement and validity. An **agreement** means that no two different
    values are chosen. **Validity** or sometimes called **nontriviality** means no
    value is decided unless proposed by some process participating in the protocol.
    Another safety requirement
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一致性和有效性。**一致性**意味着没有选择两个不同的值。**有效性**或者有时称为**非平凡性**意味着没有值被决定，除非是由参与协议的某个过程提出的。另一个安全要求
- en: which stems from the validity property and may be called “**valid learning**”
    is that if a process **learns** a value, the value must have been decided by a
    process. An agreement ensures that all processes decide on the same value. Validity
    and valid learning
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这源自有效性属性，可以称为“**有效学习**”，即如果一个过程**学习**一个值，则该值必须已被一个过程决定。协议确保所有过程都对相同的值做出决定。有效性和有效学习
- en: requirements ensure that processes decide only on a proposed value and do not
    trivially
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要求确保过程只决定提议的值，而不是平凡的
- en: choose to not decide or just choose some predefined value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 选择不决定或者只是选择一些预定义的值。
- en: Under **liveness**, there are two requirements. First, the protocol eventually
    **decides**, that is, a proposed value is eventually decided. Second, if a value
    is decided, the learners eventually **learn** that value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在**活性**下，有两个要求。首先，协议最终会**决定**，也就是说，提议的值最终会被确定。其次，如果一个值被决定，那么学习者最终会**学习**该值。
- en: Let’s now discuss how these safety and liveness requirements are met.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下这些安全性和活性要求是如何满足的。
- en: Intuitively, the agreement is achieved by ensuring that a majority of acceptors
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，协议通过确保大多数接受者
- en: can vote for only one proposal. Imagine two different values v1 and v2 are somehow
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 只能投票支持一个提案。想象一下两个不同的值v1和v2以某种方式
- en: chosen (decided). We know that the protocol will choose a value only if a majority
    of the acceptors accept the same accept message from a proposer. This condition
    implies that
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 选择(已决定)。我们知道只有当大多数接受者接受来自提议者的相同接受消息时，协议才会选择一个值。这个条件意味着
- en: a set of majority acceptors A1 must have accepted an accept message with a proposal
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一组多数接受者A1必须接受一个带有提议的接收消息
- en: (n1,v1). Also, another accept message with proposal (n2, v2) must have been
    accepted
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (n1,v1)。另外，另一个接受与提议(n2,v2)的消息必须已被接受
- en: by another set of majority acceptors A2\. Assuming that two majority sets A1
    and A2 must
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假定另一组多数接受者A2。假设两个多数集A1和A2必须
- en: intersect, meaning they will have at least one acceptor in common due to the
    quorum
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相交，意味着它们至少有一个接受者具有共同的接收者，因为法定份额
- en: intersection rule. This acceptor must have accepted two different proposals
    with the
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 相交规则。这个接收者必须接受了两个不同的提案
- en: same proposal number. Such a scenario is impossible because an acceptor will
    ignore
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的提议编号。这样的情况是不可能的，因为接受者会忽略
- en: any prepare or accept messages with the same proposal number they have already
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 任何准备或接受消息都具有与已经具有的相同的提议编号
- en: accepted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接受。
- en: If n1 <> n2 and n1 < n2 and n1 and n2 are consecutive proposal rounds, then
    this means that A1 must have accepted the accept message with proposal number
    n1 before
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n1 <> n2并且n1 < n2并且n1和n2是连续的提议轮次，那么这意味着A1必须在之前接受了提议编号n1的接受消息
- en: A2 accepted the accept messages with n2\. This is because an acceptor ignores
    any
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: A2接受了带有n2的接受消息。这是因为接受者忽略了任何
- en: prepare or accept messages if they have a smaller proposal number than the previously
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 准备或接受消息，如果它们具有比之前更小的提议编号
- en: promised proposal number. Also, the proposed value by a proposer must be from
    either
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的提议编号。此外，提议者的提议值必须是来自
- en: an earlier proposal with the highest proposal number or the proposer’s own proposed
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 具有较高提议编号的更早提议或提议者自己提出的
- en: value if no proposed value is included in the accepted message. As we know,
    A1 and A2
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接受的消息中不包括提议的价值，则返回值。正如我们所知，A1和A2
- en: must intersect with at least one common acceptor; this common acceptor must
    have
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 必须与至少一个常见的接受者交集；这个常见的接受者必须有
- en: '304'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '304'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: accepted the accept messages for both proposals (n1,v1) and (n2,v2). This scenario
    is
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接受了对两个提议（n1，v1）和（n2，v2）的接受消息。这种情况是
- en: also impossible because the acceptor would have replied with (n1,v1) in response
    to the
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 也是不可能的，因为接受者会答复（n1，v1）作为回应
- en: prepare message with proposal number n2, and the proposer must have selected
    the
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 准备消息与提议编号n2，且提议者必须已选择了
- en: value v1 instead of v2\. Even with nonconsecutive proposals, any intermediate
    proposals
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 等于v2而不是v1。即使有非连续的提议，也有可能有中间提议
- en: must also select v1 as the chosen value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须选择v1作为已选择的值。
- en: Validity is ensured by allowing only the input values of proposers to be proposed.
    In
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许提议者的输入值提出来确保有效性。在
- en: other words, the decided value is never predefined, nor is it proposed by any
    other entity that is not part of the cluster running Paxos.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，决定的值从未预先定义，也不是由Paxos运行的群集中的任何其他实体提出的。
- en: Liveness is not guaranteed in Paxos due to asynchrony. However, if some synchrony
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步性，Paxos不能保证存活性。但是，如果一些同步性
- en: assumption, that is, a partially synchronous environment, is assumed, then progress
    can
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，即部分同步环境的假设，则可以取得进展
- en: be made, and termination is achievable. We assume that after GST, at least a
    majority of
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可以做出，并且可以实现终止。我们假设在GST之后，至少大多数人
- en: acceptors is correct and available. Messages are delivered within a known upper
    bound,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者是正确并且可用的。消息在已知的上限内传递，
- en: and an elected unique nonfaulty leader proposer is correct and available.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 并且当选的唯一非故障领导提议者是正确的并且可用的。
- en: '**In Practice**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**实践中**'
- en: Paxos has been implemented in many practical systems. Even though the Paxos
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos已经在许多实际系统中得到实现。即使是Paxos
- en: algorithm is quite simple at its core, it is often viewed as difficult to understand.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在其核心非常简单，但通常被视为难以理解。
- en: As a result, many papers have been written to explain it. Still, it is often
    considered
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多文章已编写以解释它。尽管如此，它通常被认为
- en: complicated and tricky to comprehend fully. Nevertheless, this slight concern
    does
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解起来非常复杂和棘手。尽管如此，这个轻微的担忧确实
- en: not mean that it has not been implemented anywhere. On the contrary, it has
    been
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 并不意味着它没有在任何地方得到实现。相反，它已经
- en: implemented in many production systems, such as Google’s Spanner and Chubby.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 已在许多生产系统中实施，例如Google的Spanner和Chubby。
- en: The first deployment of Paxos was in a Petal distributed storage system. Some
    other
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos的第一个部署是在Petal分布式存储系统中。还有其他一些
- en: randomly chosen examples include Apache ZooKeeper, NoSQL Azure Cosmos database,
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择的例子包括Apache ZooKeeper、NoSQL Azure Cosmos数据库、
- en: and Apache Cassandra. It proves to be the most efficient protocol to solve the
    consensus
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 和Apache Cassandra。
- en: problem. It has been shown that the two-phase commit is a special case of Paxos,
    and
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 经证明，两阶段提交是Paxos的特例，且
- en: PBFT is a refinement of Paxos.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT是Paxos的一种改进。
- en: '**Variants**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**变种**'
- en: There are many variants of classical Paxos, such as multi-Paxos, Fast Paxos,
    Byzantine
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Paxos的变种，如多Paxos，快速Paxos，拜占庭式
- en: Paxos, Dynamic Paxos, Vertical Paxos, Disk Paxos, Egalitarian Paxos, Stoppable
    Paxos,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos、动态Paxos、垂直Paxos、磁盘Paxos、平等Paxos、可停止Paxos、
- en: and Cheap Paxos.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 和Cheap Paxos。
- en: '305'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '305'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '**Multi-Paxos**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**多Paxos**'
- en: In classical Paxos, even in an all-correct environment, it takes two round trips
    to achieve consensus on a single value. This approach is slow, and if consensus
    is required on a
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典Paxos中，即使在一个全正确的环境中，也需要两次往返来就单个值达成共识。这种方法很慢，而且如果需要对一个
- en: growing sequence of values (which is practically the case), this single value
    consensus
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 增长值序列（这实际上是这种情况），这个单一值共识
- en: must repeatedly run, which is not efficient. However, an optimization can make
    classical
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 必须反复运行，这是不高效的。然而，优化可以使经典的
- en: Paxos efficient enough to be used in practical systems. Recall that Paxos has
    two phases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos足够高效以被用于实际系统。记住Paxos有两个阶段。
- en: Once phases 1 and 2 both have completely run once, then, at that point, a majority
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦阶段1和2都完全运行一次，然后，此时，大多数
- en: of acceptors is now available to that proposer who ran this round of phases
    1 and 2\.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者现在可用于运行这一轮阶段1和2的提议者\.
- en: This proposer is now a recognized leader. Instead of rerunning phase 1, the
    proposer
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提议者现在是一个公认的领导者。与其重新运行第一阶段，提议者
- en: (leader) can keep running phase 2 only, with the available majority of acceptors.
    As long as it does not crash, or some other proposer doesn’t come along and propose
    with a
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: （领导者）可以继续运行第二阶段，使用可用的大多数接受者。只要它不崩溃，或者其他提议者不过来并提出一个
- en: higher proposal number, this process of successive accept messages can continue.
    The
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的提议号码，连续接受消息的这个过程可以继续下去。这
- en: proposer can keep running the accept/accepted round (phase 2) with even the
    same
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提议者可以继续运行接受/接受的循环（第2阶段），甚至是相同的
- en: proposal number without running the prepare/promise round (phase 1). In other
    words,
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提案号，而无需运行准备/许诺轮（第1阶段）。换句话说，
- en: the message delays are reduced from four to two. When another proposer comes
    along
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 消息延迟从四个减少到两个。当另一个提议者过来时
- en: or the previous one fails, this new proposer can run another round of phases
    1 and 2
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或上一个失败，这个新的提议者可以运行另一轮阶段1和2
- en: by following classical Paxos. When this new proposer becomes the leader by receiving
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循经典Paxos。当这个新的提议者通过接收
- en: a majority from the acceptors, the basic classical Paxos protocol upgrades to
    multi-
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 多数来自接受者,基本的经典Paxos协议升级为multi-
- en: Paxos, and it can start running phase 2 only. As long as there is only a single
    leader in the network, no acceptor would notify the leader that it has accepted
    any other proposal,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos，并且可以仅开始运行第2阶段。只要网络中只有一个领导者，没有接受者会通知领导者已经接受了任何其他提议，
- en: which will let the leader choose any value. This condition allows omitting the
    first phase when only one elected proposer is the leader.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让领导者选择任何值。这种条件允许在只有一个当选的提议者是领袖时省略第一阶段。
- en: This protocol is known as optimization Paxos or multi-Paxos. A normal run of
    multi-
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议被称为优化Paxos或多Paxos。多数的运行情况
- en: Paxos is shown in Figur[e 7-4](#p322).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos在图[7-4](#p322)中显示。
- en: '306'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '306'
- en: '![](index-322_1.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](index-322_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '***Figure 7-4\.** Multi-Paxos – note the first phase, prepare phase, skipped*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-4** 多Paxos - 注意第一阶段，准备阶段，被跳过*'
- en: Original Paxos is a leaderless (also called symmetric) protocol, whereas multi-
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Paxos是无领导的（也称为对称）协议，而multi-
- en: Paxos is leader driven (also called asymmetric). It is used in practical systems
    instead of classical Paxos to enable state machine replication. Commonly in implementations,
    the
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos是领导者驱动的（也称为不对称）。它用于实际系统而不是经典的Paxos以实现状态机复制。通常在实现中
- en: role of the proposer, acceptor, and learner is contracted to so-called servers,
    which may all assume these three roles. Eventually, only a client-server model
    emerges. With roles
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 提议者，接受者和学习者的角色被收缩为所谓的服务器，它们都可以扮演这三个角色。最终，只有一个客户机-服务器模型出现。有角色
- en: collapsed, a steady leader and prepare phase removed, the protocol becomes efficient
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃，稳定领导者和去掉准备阶段，协议变得高效。
- en: and simple.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 和简单的。
- en: Paxos is seen as a difficult protocol to understand. This is mostly due to
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos被视为一个难以理解的协议。这主要是由于
- en: underspecification. Also, the original protocol described by Lamport is a single
    decree
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 未详细说明。此外，Lamport描述的原始协议是单一法令
- en: protocol, which is not practical to implement. There have been several attempts,
    such
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，不太实际实现。已经有过几次尝试，这样
- en: as multi-Paxos, and several papers that try to explain Paxos, but, overall,
    the protocol is still considered a bit tricky to understand and implement. With
    these and several other
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与多Paxos一样，并且有几篇论文试图解释Paxos，但总的来说，该协议仍然被认为是有点难以理解和实现的。有鉴于此和其他几个
- en: points in mind, a protocol called RAFT was developed. We introduce RAFT next.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容，就开发了一种名为RAFT的协议。接下来我们介绍RAFT。
- en: '307'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '307'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '**RAFT**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAFT**'
- en: RAFT is designed in response to shortcomings in Paxos. RAFT stands for Replicated
    And
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT设计是为了弥补Paxos的缺陷。 RAFT代表Replicated And
- en: Fault Tolerant. The authors of RAFT had the main aim of developing a protocol
    which is
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 容错。RAFT的作者的主要目的是开发一个协议，该协议
- en: easy to understand and easy to implement. The key idea behind RAFT is to enable
    state
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 容易理解和实现。RAFT背后的关键思想是实现状态
- en: machine replication with a persistent log. The state of the state machine is
    determined
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 具有持久日志的机器复制。状态机的状态由此确定
- en: by the persistent log. RAFT allows cluster reconfiguration which enables cluster
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持久日志。RAFT允许集群重新配置，从而实现集群
- en: membership changes without service interruption. Moreover, as logs can grow
    quite
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 成员变化而不中断服务。此外，由于日志可能会变得很大
- en: large on high throughput systems, RAFT allows log compaction to alleviate the
    issue of
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在高吞吐量系统上体积庞大。RAFT允许日志压缩以缓解这个问题
- en: consuming too much storage and slow rebuild after node crashes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗太多存储空间，并在节点崩溃后重建速度慢。
- en: 'RAFT operates under a system model with the following assumptions:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT在以下假设的系统模型下运作：
- en: • No Byzantine failures.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: • 无拜占庭故障。
- en: • Unreliable network communication.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: • 不可靠的网络通信。
- en: • Asynchronous communication and processors.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: • 异步通信和处理器。
- en: • Deterministic state machine on each node that starts with the same
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个节点上都有确定性状态机，从相同的地方开始
- en: initial state on each node.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点上的初始状态。
- en: • Nodes have uncorruptible persistent storage with write-ahead
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: • 节点具有不可破坏的持久性存储，具有预写日志
- en: logging, meaning any write to storage will complete before crashing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 记录，意味着在崩溃之前，任何写入都将完成。
- en: • The Client must communicate strictly with only the current leader.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: • 客户端必须严格与当前领导者通信。
- en: It is the Client’s responsibility as clients know all nodes and are
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端负责，因为客户端知道所有节点，并且已经
- en: statically configured with this information.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 静态配置了这些信息。
- en: RAFT is a leader-based (asymmetric) protocol, where one node is elected as a
    leader.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT是一种基于领导人的（不对称的）协议，其中一个节点被选举为领导者。
- en: This leader accepts client requests and manages the log replication. There can
    only
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领导者接受客户端的请求并管理日志复制。只能有
- en: be one leader at a time in a RAFT cluster. If a current leader fails, then a
    new leader is elected. There are three roles that nodes (more precisely the consensus
    module within
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在RAFT集群中一次只能有一个领导者。如果当前的领导者失败，那么将选举新的领导者。节点（更准确地说是共识模块）担任的三种角色是：
- en: 'nodes) can assume in a RAFT cluster: leader, follower, and candidate.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 节点）可以在RAFT集群中担任的三种角色：领导者、追随者和候选者。
- en: • The **leader** receives client requests, manages replication logs, and
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: • **领导者**接收客户端请求，管理复制日志，并
- en: manages communication with the followers.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 管理与追随者的交流。
- en: • **Follower** nodes are passive in nature and only respond to Remote
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: • **跟随者**节点是被动的，只响应远程
- en: Procedure Call (RPCs). They never initiate any communication.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 过程调用（RPCs）。它们从不启动任何通信。
- en: • A **candidate** is a role that is used by a node that is trying to become
    a
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: • **候选者**是一个节点使用的角色，试图成为
- en: leader by requesting votes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过请求选票竞选领导者。
- en: '308'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '308'
- en: '![](index-324_1.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](index-324_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: Time in RAFT is logically divided into terms. A term (or epoch) is basically
    a
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT中的时间在逻辑上分为任期。一个任期（或时代）基本上是一个
- en: monotonically increasing value which acts as a logical clock to achieve global
    partial
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 单调递增的值，作为逻辑时钟以实现全局部分
- en: ordering on events in the absence of a global synchronized clock. Each term
    starts with
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏全局同步时钟的情况下事件的顺序。每个任期都以
- en: an election of a new leader, where one or more candidates compete to become
    the
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 选举新领导者开始，其中一个或多个候选人竞争成为
- en: leader. Once a leader is elected, it serves as a leader until the end of the
    term. The key role of terms is to identify stale information, for example, stale
    leaders. Each node stores a current term number. When current terms are exchanged
    between nodes, it is checked
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者。一旦选举出领导者，它就会一直担任领导者直到任期结束。任期的关键作用是识别陈旧信息，例如陈旧的领导者。每个节点都存储当前的任期号。当节点之间交换当前任期时，将检查
- en: if one node’s current term number is lower than the other node’s term number;
    if it is,
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点的当前任期号小于另一个节点的任期号；如果是的话，
- en: then the node with the lower term number updates its current term to the larger
    value.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当前任期号较低的节点更新其当前任期为较大的值。
- en: When a candidate or a leader finds out that its current term number is stale,
    it transitions its state to follower mode. Any requests with a stale term number
    received by a node are
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当候选者或领导者发现自己的当前任期号已过时时，它会将其状态转换为追随者模式。节点收到的任期号过时的任何请求
- en: rejected.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 被拒绝。
- en: Terms can be visualized in Figure [7-5](#p324).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 任期可以在图[7-5](#p324)中可视化。
- en: '***Figure 7-5\.** Terms in RAFT*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-5\.** RAFT 中的任期*'
- en: A RAFT protocol works using two RPCs, AppendEntries RPC, which is invoked by
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT 协议使用两个 RPC，AppendEntries RPC，由
- en: a leader to replicate log entries and is also used as a heartbeat, and RequestVote
    RPC,
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者用于复制日志条目，也用作心跳，并且用于RequestVote RPC，
- en: which is invoked by candidates to collect votes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由候选者调用以收集选票。
- en: RAFT consists of two phases. The first is leader election, and the second is
    log
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT 由两个阶段组成。第一个是领导者选举，第二个是日志
- en: replication. In the first phase, the leader is elected, and the second phase
    is where
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 复制。在第一阶段，选举领导者，第二阶段是
- en: the leader accepts the clients’ requests, updates the logs, and sends a heartbeat
    to all
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者接受客户端的请求，更新日志，并向所有发送心跳
- en: followers to maintain its leadership.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 追随者以维持其领导地位。
- en: First, let’s see how leader election works.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看领导者选举是如何工作的。
- en: '309'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '309'
- en: '![](index-325_1.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](index-325_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章经典共识
- en: '**Leader Election**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者选举**'
- en: A heartbeat mechanism is used to trigger a leader election process. All nodes
    start up as followers. Followers will run as followers as long as they keep receiving
    valid RPCs from a leader or a candidate. If a follower does not receive heartbeats
    from the leader for some time, then an “election timeout” occurs, which indicates
    that the leader has failed. The
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 心跳机制用于触发领导者选举流程。所有节点都启动为追随者。只要追随者不断地接收来自领导者或候选者的有效 RPC，追随者就会继续作为追随者运行。如果追随者在一段时间内未收到领导者的心跳，那么就会发生“选举超时”，这表明领导者已经失败。这
- en: election timeout is randomly set to be between 150ms and 300ms.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 选举超时随机设置为 150ms 至 300ms 之间。
- en: Now the follower node undertakes the candidate role and attempts to become
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在追随者节点承担候选者角色，并尝试成为
- en: the leader by starting the election process. The candidate increments the current
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 候选者通过增加当前
- en: term number, votes for itself, resets election timer, and seeks votes from others
    via the RequestVote RPC. If it receives votes from the majority of the nodes,
    then it becomes the leader and starts sending heartbeats to other nodes, which
    are now followers. If another
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 任期号，为自己投票，重置选举计时器，通过 RequestVote RPC 从其他节点寻求投票。如果它从大多数节点那里获得了选票，那么它将成为领导者，并开始向其他节点发送心跳，这些节点现在是追随者。如果另一个
- en: candidate has won and became a valid leader, then this candidate would start
    receiving
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 候选者赢得并成为有效领导者，那么这个候选者就会开始接收
- en: heartbeats and will return to a follower role. If no one wins the elections
    and election
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 心跳并会返回到追随者角色。如果没有谁赢得选举和选举
- en: timeout occurs, the election process starts again with a new term.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 超时发生时，选举过程会以新任期重新启动。
- en: Note that votes will only be granted by the receiver node in response to the
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，投票仅在接收者节点响应的情况下被授予
- en: RequestVote RPC if a candidate’s log is at least as up to date as the receiver’s
    log. Also, a
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果候选者的日志至少与接收者的日志同步，则在响应中只有接收者节点会授予投票。
- en: “false” will be replied if the received term number is lower than the current
    term.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到的任期号低于当前任期，则会回复“false”。
- en: The specific process of a leader election is shown in Figur[e 7-6\.](#p325)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者选举的具体流程如图 7-6\. 所示（#p325）
- en: '***Figure 7-6\.** RAFT leader election*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-6\.** RAFT 领导者选举*'
- en: '310'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '310'
- en: '![](index-326_1.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](index-326_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章经典共识
- en: A node can be in three states; we can visualize server states in the state diagram
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点可以处于三种状态；我们可以在状态图中可视化服务器状态
- en: shown in Figure [7-7](#p326), which also shows leader election.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[7-7](#p326)所示，也展示了领导者选举。
- en: '***Figure 7-7\.** Node states in RAFT*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-7\.** RAFT 中的节点状态*'
- en: Once a leader is elected, it is ready to receive requests from clients. Now
    the log
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者一旦当选，就准备接收来自客户端的请求。现在日志
- en: replication can start.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 复制可以开始。
- en: '**Log Replication**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志复制**'
- en: The log replication phase of RAFT is straightforward. First, the client sends
    commands/
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT 的日志复制阶段很简单。首先，客户端发送命令/
- en: requests to the leader to be executed by the replicated state machines. The
    leader
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 请求领导者由复制的状态机执行。 领导者
- en: then assigns a term and index to the command so that the command can be uniquely
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 随后为该命令分配任期和索引，以便该命令可以唯一
- en: identified in the logs held by nodes.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 节点日志中标识。
- en: It appends this command to its log. When the leader has a new entry in its log,
    at the
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它将此命令附加到其日志中。 当领导者的日志中有新的条目时，就会
- en: same time it sends out the requests to replicate this command via the AppendEntries
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，它向外发送请求，通过附加条目
- en: RPC to the follower nodes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 发送到追随者结点。
- en: When the leader is able to replicate the command to the majority of the follower
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当领导者能够将命令复制给大多数追随者时
- en: nodes, that is, acknowledged, the entry is considered committed on the cluster.
    Now the
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，即已确认，该条目在集群上被认为是已提交的。 现在
- en: leader executes the command in its state machine and returns the result to the
    client. It also notifies the followers that the entry is committed via the AppendEntries
    RPC, and
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 领袖在其状态机中执行命令，并将结果返回给客户端。 它还通过附加条目的 RPC 通知跟随者条目已经提交，并
- en: the followers execute committed commands in their state machines. A set of logs
    from
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随者在其状态机中执行提交的命令。 一组来自
- en: five nodes is shown in Figur[e 7-8\.](#p327)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图[7-8](#p327) 所示的五个节点。
- en: '311'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '311'
- en: '![](index-327_1.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](index-327_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: '***Figure 7-8\.** Logs in RAFT nodes*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-8\.** RAFT 节点中的日志*'
- en: Notice that entries up to log index number 6 are replicated on a majority of
    servers
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，直到日志索引号为 6 的条目都在大多数服务器上复制
- en: as the leader, follower 3, and follower 4 all have these entries, resulting
    in a majority –
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 作为领导者，跟随者 3 和跟随者 4 都拥有这些条目，从而产生了多数 –
- en: three out of five nodes. This means that they are committed and are safe to
    apply to their respective state machines. The log on followers 1 and 3 is not
    up to date, which could
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 五个节点中的三个节点。 这意味着它们已经提交并且可以应用于各自的状态机。 追随者 1 和 3 的日志不是最新的，这可能
- en: be due to a fault on the node or communication link failure. If there is a crashed
    or slow follower, the leader will keep retrying via the AppendEntries RPC until
    it succeeds.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是由节点或通信链路故障引起的。 如果有崩溃或迟缓的追随者，领导者将通过附加条目的 RPC 一直重试，直到成功为止。
- en: The log replication process is shown in Figure [7-9](#p328).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 日志复制过程如图[7-9](#p328) 所示。
- en: '312'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '312'
- en: '![](index-328_1.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](index-328_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: '***Figure 7-9\.** RAFT log replication and state machine replication*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-9\.** RAFT 日志复制和状态机复制*'
- en: When a follower receives an AppendEntries RPC for replication of log entries,
    it
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当一名追随者接收到附加条目的 RPC 以复制日志条目时，它
- en: checks if the term is less than the current term it replies false. It appends
    only new
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前任期是否小于当前任期时，则回复 false。 它仅附加新的
- en: entries that are not already in the logs. If an existing entry has the same
    index as the new one, but different terms, it will delete the existing entry and
    all entries following it. It will also reply false if the log does not have an
    entry at the index of the log entry immediately preceding the new one but the
    term matches.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未在日志中。 如果现有条目与新条目具有相同的索引，但不同的任期，它将删除现有条目和其后的所有条目。 如果日志没有新条目前立即的日志条目索引位置，则回复
    false，但任期匹配。
- en: If there is a failed follower or candidate, the protocol will keep retrying
    via the
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有失败的追随者或候选人，则协议将通过
- en: AppendEntries RPC until it succeeds.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 直到成功。
- en: If a command is committed, the RAFT cluster will not lose it. This is the guarantee
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个命令已经提交，RAFT 集群将不会丢失它。 这是保证
- en: provided by RAFT despite any failures such as network delays, packet loss, reboots,
    or
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在诸如网络延迟、数据包丢失、重启或
- en: crash faults. However, it does not handle Byzantine failures.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃故障。 但是，它不能处理拜占庭故障。
- en: Each log entry consists of a term number, an index, and a state machine command.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志条目包括一个任期号、一个索引和一个状态机命令。
- en: A term number helps to discover inconsistencies between logs. It gives an indication
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 任期号有助于发现日志之间的不一致性。 它给出了一个指示
- en: about the time of the command. An index identifies the position of an entry
    in the log. A command is the request made by the client for execution.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命令的时间。 索引标识日志中条目的位置。 命令是客户端的执行请求。
- en: '313'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '313'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: '**Guarantees and Correctness**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**保证和正确性**'
- en: Guarantees provided by RAFT are
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT 提供的保证是
- en: • **Election correctness**
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: • **选举正确性**
- en: '• **Election safety**: At most, one leader can be elected in each term.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: • **选举安全性**：每次最多只能选出一个领袖。
- en: '• **Election liveness**: Some candidate must eventually become'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: • **选举活跃性**：一些候选人最终必须成为
- en: a leader.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一个领导者。
- en: '• **Leader append-only**: A leader can only append to the log. No'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: • **领导者仅追加**：领导者只能追加日志。没有
- en: overwrite or deletion of entries in the log is allowed.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 允许重写或删除日志中的条目。
- en: '• **Log matching**: If two logs on two different servers have an entry with'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: • **日志匹配**：如果两个不同服务器上的两个日志具有具有条目
- en: the same index and term, then these logs are identical in all previous
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与相同的索引和任期，然后这些日志在所有之前都是相同的
- en: entries, and they store the same command.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 条目，并且它们存储相同的命令。
- en: '• **Leader completeness**: A log entry committed in a given term will'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: • **领导者完成性**：在给定的任期内提交的日志条目将
- en: always be present in the logs of the future leaders, that is, leaders
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 总是出现在将来领导者的日志中，也就是说，领袖
- en: for higher-numbered terms. Also, nodes with incomplete logs must
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高的序列号术语。此外，具有不完整日志的节点必须
- en: never be elected.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不会被选中。
- en: '• **State machine safety**: If a node has applied a log entry at a given'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: • **状态机安全性**：如果节点在特定的时间应用了日志条目
- en: index to its state machine, no other node will ever apply a different
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 到其状态机的索引，那么其他节点将永远不会应用不同的
- en: log entry for the same index.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的索引的日志条目。
- en: Election correctness requires safety and liveness. Safety means that at most
    one
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 选举正确性需要安全性和活跃性���安全性意味着最多一个
- en: leader is allowed per term. Liveness requires that some candidate must win and
    become
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任期只允许一个领导者。活跃性要求一些候选人最终必须获胜并成为
- en: a leader eventually. To ensure safety, each node votes only once in a term which
    it
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最终成为领导者。为了确保安全性，每个节点在本任期中只能投票一次
- en: persists on storage. The majority is required to win the election; no two different
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持在存储中。赢得选举需要大多数人；没有两个不同的
- en: candidates will get a majority at the same time.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 候选人将在同一时间得到多数。
- en: Split votes can occur during leader election. If two nodes get elected simultaneously,
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在领导者选举期间可以发生分裂投票。如果两个节点同时当选，
- en: then the so-called “split vote” can occur. RAFT uses randomized election timeouts
    to
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所谓的“分割投票”就会发生。RAFT使用随机选举超时来
- en: ensure that this problem resolves quickly. This helps because random timeouts
    allow
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 确保此问题能够快速解决。这很有帮助，因为随机超时允许
- en: only one node to time out and win the election before other nodes time out.
    In practice,
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个节点在其他节点之前超时并赢得选举。在实践中，
- en: this works well if the random time chosen is greater than the network broadcast
    time.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随机选择的时间大于网络广播时间，则此功能效果很好。
- en: Log matching achieves a high level of consistency between logs. We assume that
    the
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 日志匹配实现了日志之间的高度一致性。我们假设该
- en: leader is not malicious. A leader will never add more than one entry with the
    same index
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者不是恶意的。领导者永远不会添加超过一个具有相同索引的条目
- en: and same term. Log consistency checks ensure that all previous entries are identical.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 和相同的任期。日志一致性检查确保所有先前的条目都是相同的。
- en: The leader keeps track of the latest index that it has committed in its log.
    The leader
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者跟踪其日志中已提交的最新索引。领导者
- en: '314'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '314'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章经典共识
- en: broadcasts this information in every AppendEntries RPC. If a follower node doesn’t
    have
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 播发此信息在每个AppendEntries RPC中。如果跟随者节点没有
- en: an entry in its log with the same index number, it will not accept the incoming
    entry.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 与其日志中具有相同索引编号的条目，则不会接受传入的条目。
- en: However, if the follower accepts the AppendEntries RPC, the leader knows that
    the
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果跟随者接受了追加条目的RPC，则领导者知道
- en: logs are identical on both. Logs are generally consistent unless there are failures
    on the network. In that case, the log consistency check ensures that nodes eventually
    catch up
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 日志在两者上是相同的。日志通常是一致的，除非网络发生故障。在这种情况下，日志一致性检查确保节点最终赶上
- en: and become consistent. If a log is inconsistent, the leader will retransmit
    missing entries to followers that may not have received the message before or
    crashed and now have
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 并变得一致。如果日志不一致，则领导者将重新传输缺失的条目给之前可能没有收到消息或崩溃并且现在有
- en: recovered.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复。
- en: Reconfiguration and log compaction are two useful features of RAFT. I have not
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 重配置和日志压缩是RAFT的两个有用的特性。我没有
- en: discussed those here as they are not related directly to the core consensus
    protocol. You can refer to the original RAFT paper mentioned in the bibliography
    for more details.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些功能进行讨论，因为它们与核心共识协议没有直接相关。你可以参考参考文献中提到的原始RAFT论文以获取更多细节。
- en: '**PBFT**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBFT**'
- en: Remember, we discussed the oral message protocol and the Byzantine generals
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们讨论了口头信息协议和拜占庭将军们
- en: problem earlier in the book. While it solved the Byzantine agreement, it was
    not a
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 书中问题。虽然它解决了拜占庭协议，但并不是一个
- en: practical solution. The oral message protocol only works in synchronous environments,
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的解决方案。口头信息协议只能在同步环境下工作，
- en: and computational complexity (runtime) is also high unless there is only one
    faulty
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 和计算复杂性（运行时间）也很高，除非只有一个有故障的
- en: processor, which is not practical. However, systems show some level of communication
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器，这是不切实际的。然而，系统在某种程度上表现出了一些通信
- en: and processor asynchrony in practice. A very long algorithm runtime is also
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 和处理器的异步性。非常长的算法运行时间也是
- en: unacceptable in real environments.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实环境中是不可接受的。
- en: A practical solution was developed by Castro and Liskov in 1999 called practical
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年由卡斯特罗和利斯科夫开发了一个实际的解决方案，称为实际的
- en: Byzantine fault tolerance (PBFT). As the name suggests, it is a protocol designed
    to
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭容错（PBFT）。顾名思义，它是一种旨在
- en: provide consensus in the presence of Byzantine faults. Before PBFT, Byzantine
    fault
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在拜占庭错误的情况下提供共识。在PBFT之前，拜占庭错误
- en: tolerance was considered impractical. With PBFT, the duo demonstrated that practical
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 容错被认为是不切实际的。通过PBFT，这对证明了切实可行
- en: Byzantine fault tolerance is possible for the first time.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭容错首次成为可能。
- en: PBFT constitutes three subprotocols called normal operation, view change, and
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT包括三个名为正常运行、视图更改和
- en: checkpointing. The normal operation subprotocol refers to a mechanism executed
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点。正常操作子协议是指一种在正常运行时执行的机制
- en: when everything is running normally, and the system is error-free. The view
    change is a
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切运行正常，系统没有错误的时候。视图更改是
- en: subprotocol that runs when a faulty leader node is detected in the system. Checkpointing
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统中检测到有故障的领导节点时运行的子协议。检查点
- en: is used to discard the old data from the system.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从系统中丢弃旧数据。
- en: The PBFT protocol consists of three phases. These phases run one after another
    to
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT协议由三个阶段组成。这些阶段依次运行
- en: complete a single protocol run. These phases are pre-prepare, prepare, and commit,
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 完成单个协议运行。这些阶段是预准备、准备和提交，
- en: which we will cover in detail shortly. In normal conditions, a single protocol
    run is
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快详细介绍。在正常情况下，单个协议运行是
- en: enough to achieve consensus.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 足以实现共识。
- en: '315'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '315'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章经典共识
- en: The protocol runs in rounds where, in each round, a leader node, called the
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 协议以每轮次的形式运行，在每一轮中，一个领导者节点，称为
- en: primary node, handles the communication with the client. In each round, the
    protocol
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点，处理与客户端的通信。在每一轮中，协议
- en: progresses through the three previously mentioned phases. The participants in
    the PBFT
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 依次进入前面提到的三个阶段。PBFT的参与者
- en: protocol are called replicas. One of the replicas becomes primary as a leader
    in each
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 协议被称为副本。其中一个副本成为每次领导者的主节点
- en: round, and the rest of the nodes act as backups. PBFT enables state machine
    replication,
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 轮，其他节点充当备份。PBFT实现了状态机复制，
- en: which we discussed earlier. Each node maintains a local log, and the logs are
    kept in sync with each other via the consensus protocol, PBFT.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过。每个节点维护一个本地日志，并通过共识协议PBFT使这些日志保持同步。
- en: We know by now that to tolerate Byzantine faults, the minimum number of nodes
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道为了容忍拜占庭错误，节点的最小数量
- en: required is *n* = 3 *f* + 1 in a partially synchronous environment, where *n*
    is the number of nodes and *f* is the number of faulty nodes. PBFT ensures Byzantine
    fault tolerance as long as the number of nodes in a system stays *n* ≥ 3 *f* +
    1\.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的是*n* = 3 *f* + 1（在部分同步环境中），其中*n*是节点数，*f*是故障节点数。只要系统中的节点数保持*n* ≥ 3 *f* + 1\，PBFT就能确保拜占庭容错。
- en: When a client sends a request to the primary (leader), a sequence of operations
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向主节点（领导者）发送请求时，会进行一系列操作
- en: between replicas runs, leading to consensus and a reply to the client.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 之间的副本运行，导致共识并回复给客户。
- en: 'This sequence of operations is composed of three phases:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作序列由三个阶段组成：
- en: • Pre-prepare
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: • 预准备
- en: • Prepare
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: • 准备
- en: • Commit
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: • 提交
- en: 'In addition, each replica maintains a local state containing three main elements:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个副本维护一个包含三个主要元素的本地状态：
- en: • A service state
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: • 服务状态
- en: • A message log
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: • 消息日志
- en: • A number representing that replica’s current view
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: • 代表该副本当前视图的数字
- en: Let’s look at each of the phases in detail.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个阶段。
- en: '**Pre-prepare phase – phase 1**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**预准备阶段-阶段1**'
- en: When the primary node receives a request from the client, it assigns a sequence
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当主节点接收到客户端的请求时，它会为其分配一个序列
- en: number to the request. It then sends the pre-prepare message with the request
    to all
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的序列号。然后，将包含请求的预准备消息发送给所有
- en: backup replicas.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 备份副本
- en: When the backup replicas receive the pre-prepare message, they check several
    things
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当备份副本收到预准备消息时，他们检查了几件事情
- en: 'to ensure the validity of the message:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 确保消息的有效性：
- en: • Whether the digital signature is valid.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: • 数字签名是否有效。
- en: • Whether the current view number is valid, that is, the replica is in the
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: • 当前视图编号是否有效，即副本位于
- en: same view.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 相同视图。
- en: '316'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '316'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: • Whether the sequence number of the operation’s request message
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: • 操作的请求消息的序列号是否有效
- en: is valid, for example, if the same sequence number is used again,
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 有效，例如，如果再次使用相同的序列号，
- en: the replica will reject the subsequent request with the same
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 副本将拒绝序列号相同的后续请求
- en: sequence number.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号。
- en: • If the hash of the request message is valid.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果请求消息的哈希值有效。
- en: • No previous pre-prepare message received with the same sequence
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: • 未收到相同序列号的先前预准备消息
- en: number and view but a different hash.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 序号和视图，但哈希值不同。
- en: If all these checks pass, the backup replicas accept the message, update their
    local
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些检查都通过，备份副本接受消息，更新其本地
- en: state, and move to the prepare phase.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 状态，并进入准备阶段。
- en: In summary, the pre-prepare phase
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，预准备阶段
- en: • Accepts a request from the client.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: • 接受来自客户端的请求。
- en: • Assigns to it the next sequence number. This sequence number is the
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: • 为其分配下一个序列号。这个序列号是
- en: order in which the request is going to be executed.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 请求即将执行的顺序。
- en: • Broadcasts this information as the pre-prepare message to all backup
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: • 将此信息作为预准备消息广播给所有备份
- en: replicas.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 副本。
- en: This phase assigns a unique sequence number to the client request. We can think
    of
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 此阶段为客户端请求分配一个唯一的序列号。我们可以将其看作是
- en: it as an orderer that applies order to the client requests.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为一种应用于客户端请求的排序器。
- en: '**Prepare phase – phase 2**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**准备阶段 – 第 2 阶段**'
- en: Each backup replica sends the prepare message to all other replicas in the system.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 每个备份副本都向系统中所有其他副本发送准备消息。
- en: Each backup replica waits for at least 2 *f* + 1 prepare messages to arrive
    from other replicas. They check
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 每个备份副本等待至少 2 *f* + 1 来自其他副本的准备消息到达。它们检查
- en: • Whether the prepare message has a valid digital signature.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: • 准备消息是否有一个有效的数字签名。
- en: • The replica is in the same view as in the message.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: • 副本与消息中相同的视图中。
- en: • The sequence number is valid and within the expected range.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: • 序列号有效且在预期范围内。
- en: • The message digest (hash) value is correct.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: • 消息摘要（哈希）值是否正确。
- en: If all these checks pass, the replica updates its local state and moves to the
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些检查都通过，副本更新其本地状态并转至
- en: commit phase.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段。
- en: '317'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '317'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: 'In summary, the prepare phase performs the following steps:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，准备阶段执行以下步骤：
- en: • Accepts the pre-prepare message only if the replica has not
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: • 仅在副本尚未
- en: accepted any pre-prepare messages for the same view or sequence
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接受过相同视图或序列号的任何预准备消息
- en: number before
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前
- en: • Sends the prepare message to all replicas
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: • 将准备消息发送给所有副本
- en: This phase ensures that honest replicas in the network agree on the total order
    of
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 该阶段确保网络中的诚实副本就
- en: requests within a view.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 视图内的请求。
- en: '**Commit phase**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交阶段**'
- en: Each replica sends a commit message to all other replicas in the network in
    the
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本都向网络中的所有其他副本发送一条提交消息
- en: commit phase. Like the prepare phase, replicas wait for 2 *f* + 1 commit messages
    to arrive from other replicas. The replicas also check the view number, sequence
    number,
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段。与准备阶段一样，副本等待来自其他副本的 2 *f* + 1 个提交消息到达。副本还检查视图编号、序列号，
- en: digital signature, and message digest values. If they are valid for 2 *f* +
    1 commit messages received from other replicas, the replica executes the request,
    produces a result, and
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名和消息摘要值。如果它们对于来自其他副本的 2 *f* + 1 个提交消息有效，则副本执行该请求，生成结果，并
- en: finally updates its state to reflect a commit. If some messages are queued up,
    the replica will execute those requests first before processing the latest sequence
    numbers. Finally, the replica sends the result to the client in a reply message.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 最后更新其状态以反映提交情况。如果有一些消息排队等待，副本将先执行这些请求，然后再处理最新的序列号。最后，副本会以回复消息的形式将结果发送给客户端。
- en: The client accepts the result only after receiving 2 *f* + 1 reply messages
    containing the same result.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只有在收到 2 *f* + 1 条包含相同结果的回复消息后才接受结果。
- en: The commit subprotocol steps
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 提交子协议的步骤
- en: • The replica waits for 2 *f* + 1 prepare messages with the same view,
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: • 复制节点等待 2 *f* + 1 个相同视图的准备消息，
- en: sequence, and request.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化，并且请求。
- en: • It sends a commit message to all replicas.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: • 它发送提交消息给所有副本。
- en: • It waits until a 2 *f* + 1 valid commit message arrives and is accepted.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: • 它等待 2 *f* + 1 条有效的提交消息到达并被接受。
- en: • It executes the received request.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: • 它执行接收到的请求。
- en: • It sends a reply containing the execution result to the client.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: • 它发送包含执行结果的回复给客户端。
- en: This phase ensures that honest replicas in the network agree on the total order
    of
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这一阶段确保了网络中诚实的副本对消息的总排序达成一致
- en: client requests across views.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 跨视图的客户请求。
- en: In essence, the PBFT protocol ensures that enough replicas process each request
    so
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，PBFT 协议确保足够的复制节点处理每个请求，所以
- en: that the same requests are processed and in the same order.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以确保处理相同请求的副本顺序相同。
- en: We can visualize the normal mode of operation of the protocol in Figur[e 7-10](#p334).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过[图 7-10](#p334)来可视化协议的正常操作模式。
- en: '318'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '318'
- en: '![](index-334_1.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![](index-334_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: '***Figure 7-10\.** PBFT normal mode operation*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 7-10\.** PBFT 正常操作模式*'
- en: During the execution of the protocol, the protocol must maintain the integrity
    of the
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议执行过程中，协议必须维持消息的完整性
- en: messages and operations to deliver an adequate level of security and assurance.
    Digital
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和操作，传递足够安全和保障水平。数字
- en: signatures fulfill this requirement. It is assumed that digital signatures are
    unforgeable, and hash functions are collision resistant. In addition, certificates
    are used to ensure the proper majority of participants (nodes).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 签名满足此要求。假设数字签名不可伪造，哈希函数不发生冲突。此外，证书被用来确保参与者（节点）的适当多数。
- en: '**Certificates in PBFT**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBFT 中的证书**'
- en: Certificates in PBFT protocols establish that at least 2 *f* + 1 replicas have
    stored the required information. In other words, the collection of 2 *f* + 1 messages
    of a particular type is considered a certificate. For example, suppose a node
    has collected 2 *f* + 1
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT 协议中的证书确保了至少有 2 *f* + 1 个复制节点已经存储了所需的信息。换句话说，特定类型的 2 *f* + 1 条消息的集合被视为证书。例如，假设一个节点收集到了
    2 *f* + 1
- en: messages of type prepare. In that case, combining it with the corresponding
    pre-prepare
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 准备消息类型的消息。在这种情况下，结合相应的预准备
- en: message with the same view, sequence, and request represents a certificate,
    called a
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同视图、序列和请求的消息代表一份被称为证书的证明，
- en: prepared certificate. Likewise, a collection of 2 *f* + 1 commit messages is
    called a commit certificate.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 准备证明。同样地，集合中的 2 *f* + 1 条提交消息被称为提交证书。
- en: '319'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '319'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: There are also several variables that the PBFT protocol maintains to execute
    the
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT 协议要维护的还有几个变量
- en: 'algorithm. These variables and the meanings of these are listed as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 算法。这些变量及其含义如下所列：
- en: '• **v**: View number'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '• **v**: 视图编号'
- en: '• **o**: Operation requested by a client'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '• **o**: 客户端请求的操作'
- en: '• **t**: Timestamp'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '• **t**: 时间戳'
- en: '• **c**: Client identifier'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '• **c**: 客户端标识'
- en: '• **r**: Reply'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '• **r**: 回复'
- en: '• **m**: Client’s request message'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '• **m**: 客户端请求消息'
- en: '• **n**: Sequence number of the message'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '• **n**: 消息的序列号'
- en: '• **h**: Hash of the message m'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '• **h**: 消息 m 的哈希值'
- en: '• **i**: Identifier of the replica'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '• **i**: 复制节点的标识'
- en: '• **s**: Stable checkpoint – last'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '• **s**: 稳定的检查点 – 最后'
- en: '• **C**: Certificate of the stable checkpoint (2f + 1 checkpoint messages)'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '• **C**: 稳定检查点的证书（2f+1检查点消息）'
- en: '• **P**: Set of prepared certificates for requests'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '• **P**: 用于请求的准备证书的集合'
- en: '• **O**: Set of pre-prepare messages to be processed'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '• **O**: 待处理的预先准备消息的集合'
- en: '• **V**: Proof of the new view (2f + 1 view change messages)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '• **V**: 新视图的证明（2*f + 1 视图改变消息）'
- en: Let’s now look at the types of messages and their formats. These messages are
    easy to
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下消息的类型及其格式。这些消息很容易
- en: understand if we refer to the preceding variable list.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考前面的变量列表就能理解。
- en: '**Types of Messages**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息的类型**'
- en: The PBFT protocol works by exchanging several messages. A list of these messages
    is
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT 协议工作通过交换多个消息。这些消息的列表是
- en: shown in Ta[ble 7-1 w](#p336)ith their format and direction.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 7-1](#p336)和图示中显示。
- en: '320'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '320'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章 经典共识
- en: '***Table 7-1\.** PBFT protocol messages*'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '***表 7-1\.** PBFT 协议消息*'
- en: '**Message**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**'
- en: '**From**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自**'
- en: '**To**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**对**'
- en: '**Format**'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式**'
- en: '**Signed by**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**由…签名**'
- en: request
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 请求
- en: Client
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: primary
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 主
- en: <reQuest, o, t, c>
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: <请求，o，t，c>
- en: Client
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: pre-prepare
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 预准备
- en: primary
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 主
- en: replicas
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <<pre-prepare, v, n, h>, m>>
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: <<预准备，v，n，h>，m>>
- en: primary
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 主
- en: prepare
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 准备
- en: replica
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: replicas
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <prepare, v, n, h, i>
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: <准备，v，n，h，i>
- en: replica
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: Commit
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 提交
- en: replica
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: replicas
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <CoMMit, v, n, h, i>
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: <提交，v，n，h，i>
- en: replica
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: reply
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 回复
- en: replicas
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: Client
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: <replY, r, i>
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: <回复，r，i>
- en: replica
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: View change
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改
- en: replica
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: replicas
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <VieWChanGe, v+1, n, s, C, p, i>
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: <视图更改，v+1，n，s，C，p，i>
- en: replica
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: new view
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 新视图
- en: primary
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 主
- en: replicas
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <neWVieW, v + 1, V, o>
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: <新视图，v+1，V，o>
- en: replica
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: Checkpoint
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点
- en: replica
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: replicas
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: <CheCKpoint, n, h, i>
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: <检查点，n，h，i>
- en: replica
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品
- en: Note that all messages are signed with digital signatures, which enable every
    node to
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有消息都带有数字签名，这使得每个节点可以
- en: identify which replica or client generated any given message.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 辨别生成任何给定消息的复制品或客户端。
- en: '**View Change**'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图更改**'
- en: A view change occurs when a primary replica is suspected faulty by other replicas.
    This
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他复制品怀疑主复制品有故障时，将发生视图更改
- en: phase ensures protocol progress. A new primary is selected with a view change,
    which
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段确保协议进展。通过视图更改选择新的主
- en: starts normal mode operation again. The new primary is chosen in a round-robin
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动正常模式操作。新主是通过轮询选择的
- en: fashion using the formula *p* = *v mod n*, where v is the view number and n
    is the total number of nodes in the system.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式*p* = *v mod n*来构建这样的*葫芦*，其中v是视图号，n是系统中节点的总数
- en: When a backup replica receives a request, it tries to execute it after validating
    the
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 当备份复制品接收到请求时，它会在验证后尝试执行请求
- en: message, but for any reason, if it does not execute it for a while, the replica
    times out. It then initiates the view change subprotocol.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 消息，但是出于任何原因，如果它一段时间内没有执行
- en: During the view change, the replica stops accepting messages related to the
    current
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图更改期间，复制品停止接受与当前
- en: view and updates its state to a view change. The only messages it can receive
    in this state are *checkpoint*, *view change*, and *new view* messages. After
    that, it broadcasts a view change message with the next view number to all replicas.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 视图并将其状态更新为视图更改。在此状态下它只能接收*检查点*、*视图更改*和*新视图*消息。之后，它向所有复制品广播下一个视图号的视图更改消息。
- en: When this message reaches the new primary, the primary waits for at least 2
    *f* view change messages for the next view. If at least 2 *f* + 1 view change
    messages are acquired, it broadcasts a new view message to all replicas and runs
    normal operation mode
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 当此消息到达新主时，主等待至少2 *f*个视图更改消息，以进行下一个视图。如果获得至少2 *f* + 1个视图更改消息，则向所有复制品广播新视图消息，并运行正常操作模式
- en: once again.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 再次。
- en: '321'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '321'
- en: '![](index-337_1.png)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![](index-337_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: When other replicas receive a new view message, they update their local state
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他复制品接收到新的视图消息时，它们会更新其本地状态
- en: accordingly and start the normal operation mode.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 并开始正常操作模式。
- en: 'The algorithm for the view change protocol is as follows:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改协议的算法如下：
- en: 1\. Stop accepting pre-prepare, prepare, and commit messages for
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 停止接受预准备、准备和提交消息
- en: the current view.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 当前视图
- en: 2\. Construct a set of all the certificates prepared so far.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 构建到目前为止准备的所有证书的集合。
- en: 3\. Broadcast a view change message with the next view number and
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 向所有复制品广播具有下一个视图号和
- en: a set of all the prepared certificates to all replicas.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 所有已准备的证书的集合发送给所有复制品。
- en: Figur[e 7-11 illus](#p337)trates the view change protocol.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-11说明了视图更改协议。
- en: '***Figure 7-11\.** View change protocol*'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-11\.** 视图更改协议*'
- en: The view change subprotocol is a means to achieve liveness. Three clever techniques
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改子协议是实现活性的一种手段。三个巧妙的技术
- en: 'are used in this subprotocol to ensure that:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子协议中使用，以确保：
- en: 1\. A replica that has broadcast the view change message waits for
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 已广播视图更改消息的复制品等待
- en: 2f+1 view change messages and then starts its timer. If the timer
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 2f+1视图更改消息，然后启动其计时器。如果计时器
- en: expires before the node receives a new view message for the next
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点接收下一个视图消息之前过期
- en: view, the node will start the view change for the next sequence
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 视图，节点将开始为下一个序列启动视图更更
- en: but increase its timeout value. This situation will also occur if the
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 但增加其超时值。如果
- en: replica times out before executing the new unique request in the
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行新的唯一请求之前，复制品超时
- en: new view.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 新视图
- en: 2\. As soon as the replica receives f+1 view change messages for a
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 2、一旦复本收到了 f+1 个视图变更消息
- en: view number greater than its current view, the replica will send
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 视图编号大于其当前视图的复本将发送
- en: the view change message for the smallest view it knows of in the
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 对其知道的最小视图发送视图变更消息
- en: '322'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '322'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章 经典共识
- en: set so that the next view change does not occur too late. This is
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 设置得足够早，以确保下一次视图变更不会发生得太晚。
- en: also the case even if the timer has not expired; it will still send the
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 即使定时器尚未到期，它仍将发送
- en: view change for the smallest view.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 最小视图的视图变更。
- en: 3\. As the view change will only occur if at least *f* + 1 replicas have
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 3、只要至少 *f* + 1 个复本接收到
- en: sent the view change message, this mechanism ensures that a
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 发送了视图变更消息后，这个机制会保证
- en: faulty primary cannot indefinitely stop progress by successively
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 有缺陷的主体不能无限制地通过连续
- en: requesting view changes.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 请求视图变更。
- en: It can happen especially in busy environments that storage becomes a bottleneck.
    To
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在繁忙的环境中特别容易出现存储成为瓶颈的情况。要
- en: solve this issue, checkpointing is used in the PBFT protocol.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题，PBFT 协议中使用了检查点。
- en: '**The Checkpoint Subprotocol**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查点子协议**'
- en: Checkpointing is a crucial subprotocol. It is used to discard old messages in
    the log of
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点是一项关键的子协议。它用于丢弃日志中的旧消息
- en: all replicas. With this, the replicas agree on a stable checkpoint that provides
    a snapshot of the global state at a certain point in time. This is a periodic
    process carried out by each replica after executing the request and marking that
    as a checkpoint in its log. A
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 所有复本。通过这个，复本们就能对一个提供全局状态快照的稳定检查点达成一致意见。这是每个复本在执行请求并将其标记为日志中的检查点后进行的周期性过程。
- en: variable called “low watermark” (in PBFT terminology) is used to record the
    last stable
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 称为“低水位标记”（在 PBFT 术语中）用于记录最后一个稳定
- en: checkpoint sequence number. This checkpoint is broadcast to other nodes. As
    soon as
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点序列号。这个检查点会广播给其他节点。一旦
- en: a replica has at least 2 *f* + 1 checkpoint messages, it saves these messages
    as proof of a stable checkpoint. It discards all previous pre-prepare, prepare,
    and commit messages
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复本至少有 2 *f* + 1 个检查点消息，它会把这些消息保存作为稳定检查点的证明。它会丢弃之前的 pre-prepare、prepare 和 commit
    消息
- en: from its logs.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中删除。
- en: '**PBFT Advantages and Disadvantages**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBFT 的优点和缺点**'
- en: PBFT is a groundbreaking protocol that has introduced a new research area of
    practical
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT 是一个开创性的协议，引入了一个实用的新研究领域
- en: Byzantine fault–tolerant protocols. The original PBFT have many strengths, but
    it also
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭容错协议。原始的 PBFT 具有许多优点，但也有
- en: has some weaknesses. We introduce those next.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些弱点。我们接下来介绍这些。
- en: '**Strengths**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**'
- en: • PBFT provides immediate and deterministic transaction finality. In
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: • PBFT 提供即时和确定的交易最终性。在
- en: comparison, in the PoW protocol, several confirmations are required
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PoW 协议中，需要多个确认
- en: to finalize a transaction with high probability.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 以很大概率完成交易。
- en: • PBFT is also energy efficient as compared to PoW, which consumes a
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: • 与 PoW 相比，PBFT 也是节能的，后者消耗了
- en: tremendous amount of electricity.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的电力。
- en: '323'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '323'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章 经典共识
- en: '**Weaknesses**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱点**'
- en: • PBFT is not very scalable. This limitation is why it is more suitable
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: • PBFT 不太具有伸缩性。这一限制是它更适合
- en: for consortium networks than public blockchains. It is, however,
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 对财团网络比公共区块链更适用。不过，
- en: considerably faster than PoW protocols.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 比 PoW 协议快得多。
- en: • Sybil attacks are possible to perform on a PBFT network, where a
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: • Sybil 攻击可能在 PBFT 网络上执行，一个
- en: single entity can control many identities to influence the voting and,
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 单一实体可以控制许多身份来影响投票，并且
- en: consequently, the decision.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定。
- en: • High communication complexity.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: • 高通信复杂性。
- en: • Not suitable for public blockchains with anonymous participants.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: • 不适用于具有匿名参与者的公共区块链。
- en: PBFT guarantees safety and liveness. Let’s see how.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT 保证安全性和活性。让我们看一下。
- en: '**Safety and Liveness**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性和活性**'
- en: Liveness means that a client eventually gets a response to its request if the
    message
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 活性意味着如果消息
- en: delivery delay does not increase quicker than the time itself indefinitely.
    In other words, the protocol ensures progress if latency increases slower than
    the timeout threshold.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 交付延迟并不会比时间本身增加得更快，而是无限期地增加。换句话说，如果延迟比超时阈值慢增长，协议会确保进展。
- en: A Byzantine primary may induce delay on purpose. However, this delay cannot
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 腐败的主体可能故意引发延迟。然而，这种延迟不能太大
- en: be indefinite because every honest replica has a view change timer. This timer
    starts
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 超时值并重新启动其视图更改计时器。这个想法是超时计时器
- en: whenever the replica receives a request. Suppose the replica times out before
    the request is executed; the replica suspects the primary replica and broadcasts
    a view change
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 每当复制品收到请求时。假设在请求被执行之前复制品超时；复制品怀疑主复制品并广播视图更改
- en: message to all replicas. As soon as *f* + 1 replicas suspect the primary as
    faulty, all honest replicas enter the view change process. This scenario will
    result in a view change, and
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*f* + 1 个复制品怀疑主体有故障，所有诚实的复制品都会进入视图更改过程。
- en: the next replica will take over as the primary, and the protocol will progress.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 只要不超过
- en:  *n* −1
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 将等待时间加倍以等待更长时间，因为消息延迟可能会更长
- en: Liveness is guaranteed, as long as no more than
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是无限的，因为每个诚实的复制品都有一个视图更改计时器。这个计时器开始
- en: replicas are faulty, and the
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品都有缺陷，并且
- en:  3 
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 具体。最终，计时器值会变得大于消息延迟，这意味着
- en: message delay does not grow faster than the time itself. It means that the protocol
    will
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 消息延迟不会增长得比时间本身更快。这意味着协议将
- en: eventually make progress with the preceding two conditions. This weak synchrony
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 使系统停止运行。这是因为只有一名诚实的复制品在满足以下两个条件后才参与视图更改。
- en: assumption is closer to realistic environments and enables the system to circumvent
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章经典共识
- en: the FLP result. A clever trick here is that if the view change timer expires
    before a replica receives a valid new view message for the expected new view,
    the replica doubles the
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 最终会进展到前面两个条件。这种弱同步性
- en: timeout value and restarts its view change timer. The idea is that the timeout
    timer
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品等待2 *f* + 1个视图更改消息并启动一个计时器来开始一个新视图，以避免过早地开始视图更改。同样，如果一个复制品接收到大于当前视图的视图的*f*
    + 1个视图更改消息，它会广播一个视图更改。
- en: doubles the wait time to wait for a longer time as the message delays might
    be more
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 消息最终会在计时器到期之前到达。这个机制确保
- en: extensive. Ultimately, the timer values become larger than the message delays,
    meaning
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* −1
- en: '324'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '324'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: the FLP result。这里的一个聪明的技巧是，如果视图更改计时器在一个复制品收到预期新视图的有效新视图消息之前到期，该复制品会将
- en: messages will eventually arrive before the timer expires. This mechanism ensures
    that
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个复制品将接管为主体，协议将前进。
- en: eventually a new view will be available on all honest replicas, and the protocol
    will make progress.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 假设更接近于现实环境并使系统能够回避
- en: Also, a Byzantine primary cannot do frequent view changes successively to slow
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景将导致一个视图更改，
- en: down the system. This is so because an honest replica joins the view change
    only when
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的总排序，即在所有阶段以相同顺序执行相同请求。
- en: it has received at least *f* + 1 view change messages. As there are at most
    *f* faulty replicas, only f replicas cannot cause a view change when all honest
    replicas are live, and the
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 收到的至少*f* +1个视图更改消息执行对应客户端请求。由于至多有*f*个有故障的复制品，只有f个复制品在所有诚实复制品存活时无法引起视图更改，而
- en: protocol is making progress. In other words, as at most *f* successive primary
    replicas can be faulty, the system eventually makes progress after at most *f*
    + 1 view changes.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: protocol is making progress。换句话说，至多*f* 个连续的主副本可能存在故障，系统在进行至多*f* + 1次视图更改后最终取得进展。
- en: Replicas wait for 2 *f* + 1 view change messages and start a timer to start
    a new view which avoids starting a view change too soon. Similarly, if a replica
    receives *f* + 1 view change messages for a view greater than its current view,
    it broadcasts a view change.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 最终在所有诚实的复制品上会有一个新视图，协议将取得进展。
- en: This prevents starting the next view change too late.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以防止下一个视图更改开始得太晚。
- en: Safety requires that each honest replica execute the received client request
    in the
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性要求每个诚实的复制品根据
- en: same total order, that is, execute the same request in the same order in all
    phases.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，拜占庭主体无法连续进行频繁的视图更改以减慢系统。
- en: PBFT is assumed safe if the total number of nodes is 3 *f* + 1\. In that case,
    f Byzantine nodes are tolerated.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点总数为3 *f* + 1，则假设PBFT是安全的\. 在这种情况下，可以容忍f个拜占庭节点。
- en: Let’s first recall what a quorum intersection is. If there are two sets, say
    S1 and S2,
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下什么是关于法定人数交集。如果有两组，比如S1和S2，
- en: with ≥2 *f* + 1 nodes each, then there is always a correct node in *S* 1 ∩ *S*
    2\. This is true because if there are two sets of at least 2 *f* + 1 nodes each,
    and there are 3 *f* + 1 nodes in total, then the pigeonhole principle implies
    that the intersection of S1 and S2 will have at least *f* + 1 nodes. As there
    are at most *f* faulty nodes, the intersection, *S* 1 ∩ *S* 2 must contain at
    least 1 correct node.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 每个至少有2 *f* +1 个节点的节点中获得准备好的证书，那么总是有一个正确的节点在 *S* 1 ∩ *S* 2 中。这是因为如果有两组至少有2 *f*
    + 1 个节点，并且总共有 3 *f* +1 个节点，然后鸽巢原理意味着S1和S2的交集将至少包含 *f* + 1 个节点。由于至多 *f* 个故障节点，所以交集，
    *S* 1 ∩ *S* 2 必须包含至少 1 个正确的节点。
- en: Each phase in PBFT must acquire 2 *f* + 1 certificate/votes to be accepted.
    It turns out that at least one honest node must vote twice on the same sequence
    number to result in
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT中的每个阶段必须获取 2*f* + 1 证书/选票才能被接受。结果显示，至少有一个诚实的节点必须在相同的序列号上投两次票才能导致
- en: a safety violation, which is not possible because an honest node cannot vote
    maliciously.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 一种安全违规，这是不可能的，因为一个诚实的节点不能恶意投票。
- en: In other words, if the same sequence number is assigned to two different messages
    by a
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果相同的顺序号被一个
- en: malicious primary to violate safety, then at least one honest replica will reject
    it due to a quorum intersection property. This is because a 2 *f* + 1 quorum means
    that there is at least one honest intersecting replica.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意的主体来违反安全性，那么至少有一个诚实的副本会因为有交叉的选区属性而拒绝它。这是因为一个 2 *f* + 1 的选区意味着至少有一个诚实的相交副本。
- en: The commit phase ensures that the correct order is achieved even across views.
    If a
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段确保甚至在视图间也实现了正确顺序。如果一个
- en: view change occurs, the new primary replica acquires prepared certificates from
    2 *f* + 1
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改发生时，新的主要副本从 2*f* +1
- en: replicas, which ensures that the new primary gets at least one prepared certificate
    for
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 副本，这确保新的主体获得至少一个准备好的证书。
- en: every client request executed by a correct replica.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由正确副本执行的客户端请求。
- en: '325'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '325'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典一致性
- en: '**Order Within a View**'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图内的排序**'
- en: If a replica acquires a prepared certificate for a request within a view and
    a unique
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个副本在一个视图和一个独特的准备好的证书内获得了一个请求
- en: sequence number, then no replica can get a prepared certificate for a different
    request
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号，那么没有副本可以为不同的请求获得准备好的证书
- en: with the same view and sequence number. Replicas can only get a prepared certificate
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同的视图和序列号。副本只能得到一个准备好的证书
- en: for the same request with the same view and sequence number.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同的请求和相同的视图和序列号。
- en: Imagine two replicas have gathered prepared certificates for two different requests
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 想象两个副本已经为两个不同的请求收集了准备好的证书
- en: with the same view and sequence number. We know that a prepared certificate
    contains
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同视图和序列号。我们知道准备好的证书包含
- en: 2f+1 messages, which implies that a correct node must have sent a pre-prepare
    or
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 2f+1 条消息，这意味着一个正确的节点必须发送了一个预准备或
- en: prepare message for two different requests with the same sequence and view due
    to
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在交叉选区，因此无法为具有相同序列和视图的两个不同请求准备两个不同的请求
- en: quorum intersection. However, a correct replica only ever sends a single pre-prepare
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 选区交叉。但是，一个正确的副本只会发送一个预准备
- en: for each view and sequence, that is, a sequence number is always incremented
    when
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个视图和序列，也就是说，当一个序列号总是增加时。
- en: the client request is received by the primary and assigned to the request. Also,
    a correct replica only sends one prepare message in each view and for a sequence.
    It sends out a
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 主要接收到客户端请求并分配给该请求。此外，正确的副本仅在每个视图和序列中发送一个准备消息。它发送一个
- en: prepare message only if it has not accepted any pre-prepare messages for the
    same view
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当它没有接受任何相同视图的预准备消息时，才接收准备消息
- en: or sequence number before. This means that the prepare must be for the same
    request.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 或序列号。这意味着准备必须是相同的请求。
- en: This achieves order within a view.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了视图内的顺序。
- en: '**Order Across Views**'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图间的排序**'
- en: The protocol guarantees that if a correct replica has executed a client request
    in a view with a specific sequence number, then no correct replica will execute
    any other client
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议确保，如果一个正确的副本在一个特定序列号的视图中执行了客户端请求，那么没有一个正确的副本会执行任何其他顾客
- en: request with the same sequence number in any future view or current view. In
    other
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未来视图中或当前视图中具有相同序列号的请求。换句话说
- en: words, every request executed by an honest replica must make it to the next
    view in the
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 字样，每个由诚实副本执行的请求必须在下一个视图中
- en: same order assigned to it previously.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 具有先前分配给它的相同顺序。
- en: We know that a request only executes at a replica if it has received 2 *f* +
    1 commit messages. Suppose an honest replica has acquired 2 *f* + 1 commit messages.
    In that case, it means that the client request must have been prepared at, at
    least, *f* + 1 honest replicas, and each of these replicas has a prepare certificate
    for it and all the previous client
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如果一个诚实的副本收到了2 *f* + 1的提交消息，那么请求只会在副本上执行。假设一个诚实的副本已经获得了2 *f* + 1的提交消息。这意味着客户端请求必须至少在*f*
    + 1个诚实的副本上准备，并且每个副本都有一个准备证书，所有之前的客户端
- en: requests. We also know that at least one of these *f* + 1 honest replicas will
    participate in the view change protocol and report these requests along with their
    certificates. This
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 请求。我们也知道这些 *f* + 1 诚实的副本中至少有一个会参与视图更改协议，并报告这些请求以及它们的证书。这
- en: implies that the request will always carry the same sequence number in the new
    view.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着请求在新视图中始终携带相同的序列号。
- en: This completes our discussion on PBFT. However, it’s a vast subject, and you
    can
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对PBFT的讨论。但是，这是一个广阔的课题，你可以
- en: further explore the original papers and thesis to learn more.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步探索原始论文和论文以获得更多信息。
- en: '326'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '326'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '**Blockchain and Classical Consensus**'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链和经典共识**'
- en: We can implement classical algorithms in the blockchain. However, the challenge
    is
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在区块链中实施经典算法。但挑战在于
- en: modifying these protocols to make them suitable for blockchain implementations.
    The
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这些协议，使它们适用于区块链实现。该
- en: core algorithm remains the same, but some aspects are changed to make the protocol
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 核心算法保持不变，但某些方面被改变以使协议
- en: suitable for the blockchain. One issue is that these traditional consensus algorithms
    are for permissioned environments where all participants are known and identifiable.
    But
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于区块链。一个问题是这些传统共识算法是为可知和可识别的所有参与者的许可环境设计的。但
- en: blockchain networks are public and anonymous, for example, Bitcoin and Ethereum.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链网络是公开和匿名的，例如，比特币和以太坊。
- en: Therefore, classical algorithms are primarily suitable for permissioned blockchain
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经典算法主要适用于许可链
- en: networks for enterprise use cases where all participants are known. Also, blockchain
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 企业使用情景的网络，所有参与者都是已知的。另外，区块链
- en: network environments are Byzantine, where malicious actors may try to deviate
    from
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 网络环境是拜占庭式的，那里可能有恶意行为者试图偏离
- en: the protocol. And Paxos and RAFT are CFT protocols that are not suitable for
    Byzantine
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。而Paxos和RAFT是不适合拜占庭的CFT协议
- en: environments. As such, either these protocols need to be modified to BFT protocols
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 环境。因此，这些协议需要被修改为BFT协议
- en: to tolerate Byzantine faults, or different BFT protocols need to be used. These
    BFT
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 耐受拜占庭错误，或需要使用不同的BFT协议。这些BFT
- en: protocols can be a modification of existing classical CFT or BFT protocols or
    can be
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以修改现有的经典CFT或BFT协议，也可以是
- en: developed specifically for blockchains from scratch. One attempt to modify an
    existing
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 专门为区块链从头开始开发。试图修改现有的
- en: classical protocol to suit a permissioned blockchain environment is IBFT, which
    we will
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于区块链的经典协议是IBFT，我们将在以下介绍
- en: introduce in Chapter [8](https://doi.org/10.1007/978-1-4842-8179-6_8). We will
    discuss more about blockchain protocols in the next chapter.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[8](https://doi.org/10.1007/978-1-4842-8179-6_8) 章中介绍。我们将在下一章更多地讨论区块链协议。
- en: Dynamic membership (reconfiguration) and log compaction using snapshots are
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 动态成员资格（重新配置）和使用快照的日志紧缩是
- en: two very useful features which RAFT supports. These two features are particularly
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT支持的两个非常有用的特性。这两个特性尤其
- en: useful in consortium blockchains. Over time, the blockchain can grow significantly
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在联盟链中很有用。随着时间的推移，区块链可以显著增长
- en: large, and snapshotting would be a useful way to handle that storage issue.
    Also,
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 大，并且快照是处理该存储问题的一种有用方式。另外
- en: membership management can be a useful feature where a new consortium member
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 成员管理可以是一个有用的功能，其中一个新的财团成员
- en: can be onboarded in an automated fashion. RAFT, however, is CFT only, which
    is
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以自动化方式接入。然而，RAFT只是CFT，这是
- en: not quite suitable for consortium chains. Nevertheless, introducing Byzantine
    fault
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 不太适合联盟链。然而，引入拜占庭故障
- en: tolerance in RAFT is possible, as Tangaroa shows - a BFT extension to RAFT.
    Some
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在RAFT中可以容忍拜占庭错误，正如Tangaroa所示 - RAFT的BFT扩展。一些
- en: issues however are reported in Tangaroa, but it is quite possible to build a
    BFT version
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: issues 但是在Tangaroa中有报道，但完全可以构建一个BFT版本
- en: of RAFT. Alternatively, these two features can be implemented in a PBFT variant
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT的公正。此外，这两个特性可以在PBFT变体中实现
- en: for blockchain networks. Variants of PBFT include IBFT, HotStuff, LibraBFT,
    and
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 用于区块链网络。PBFT的变体包括IBFT、HotStuff、LibraBFT等
- en: many others.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 其他很多。
- en: '327'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '327'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '**Summary**'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In this chapter, we covered a number of topics including viewstamped replication,
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多主题，包括视图复制，
- en: practical Byzantine fault tolerance, RAFT, and Paxos. Paxos and viewstamped
    replication
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的拜占庭容错、RAFT和Paxos。Paxos和视图复制
- en: are fundamentally important because they provide very fundamental ideas in the
    history
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常重要，因为它们提供了历史上非常基础的想法
- en: of the distributed consensus problem. Paxos especially provided formal description
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式共识问题。Paxos尤其提供了正式描述
- en: and proofs of protocol correctness. VR bears resemblance with multi-Paxos. RAFT
    is a
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 和协议正确性的证明。VR与多Paxos有相似之处。RAFT是一种
- en: refinement of Paxos. PBFT is in fact seen as a Byzantine-tolerant version of
    Paxos, though PBFT was developed independently.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos的改进。实际上，PBFT被视为Paxos的拜占庭容错版本，尽管PBFT是独立开发的。
- en: This chapter serves as a foundation to understand classical protocols before
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章作为理解经典协议的基础
- en: blockchain age protocols in the next chapter. Many ideas originate from these
    classical
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链年代的协议。许多想法源于这些经典
- en: protocols that lead to the development of newer protocols for the blockchain.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 导致了新的区块链协议的发展。
- en: '**Bibliography**'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: 1\. A Google TechTalk, 2/2/18, presented by Luis Quesada Torres.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. Google TechTalk，2018年2月2日，Luis Quesada Torres主讲。
- en: '[https://youtu.be/d7nAGI_NZPk](https://youtu.be/d7nAGI_NZPk)'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://youtu.be/d7nAGI_NZPk](https://youtu.be/d7nAGI_NZPk)'
- en: '2\. Lindsey Kuper’s lectures on distributed systems[: https://youtu.](https://youtu.be/fYfX9IGUiVw)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. Lindsey Kuper关于分布式系统的讲座[: https://youtu。](https://youtu.be/fYfX9IGUiVw)'
- en: '[be/fYfX9IGUiVw](https://youtu.be/fYfX9IGUiVw)'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '[be/fYfX9IGUiVw](https://youtu.be/fYfX9IGUiVw)'
- en: '3\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '3\. 巴希尔（Bashir，I.），2020年。 《区块链技术深度探究: 在历史中提供非常基础的重要概念》'
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式分类账、共识协议、智能合约、DApp等，
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币、以太坊等。Packt Publishing Ltd.
- en: '4\. Bully algorithm[: https://en.wikipedia.org/wiki/Bully_](https://en.wikipedia.org/wiki/Bully_algorithm)'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '4\. Bully算法[: https://en.wikipedia.org/wiki/Bully_](https://en.wikipedia.org/wiki/Bully_algorithm)'
- en: '[algorithm](https://en.wikipedia.org/wiki/Bully_algorithm)'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '[算法](https://en.wikipedia.org/wiki/Bully_algorithm)'
- en: 5\. Zhao, W., 2014\. Building dependable distributed systems. John
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 赵乌，2014年。建立可靠的分布式系统。约翰
- en: Wiley & Sons.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: Wiley & Sons。
- en: 6\. Unique Leader election is equivalent to solving consensus – Gray,
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 独特的领导者选举等同于解决共识- 格雷，
- en: J. and Lamport, L., 2006\. Consensus on transaction commit. ACM
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: J.和Lamport，L.，2006年。《交易提交的一致性》。ACM
- en: Transactions on Database Systems (TODS), 31(1), pp. 133–160\.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统交易（TODS），31（1），pp. 133–160。
- en: 7\. Leader election algorithms – Aguilera, M.K., Delporte-Gallet,
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 领导者选举算法- Aguilera，M.K.，Delporte-Gallet，
- en: C., Fauconnier, H., and Toueg, S., 2001, October. Stable leader
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: C.，Fauconnier，H.和Toueg，S.，2001年10月。稳定领导者
- en: election. In International Symposium on Distributed Computing
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 选举。在国际分布式计算研讨会
- en: (pp. 108–122). Springer, Berlin, Heidelberg.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: （pp. 108–122）。Springer，柏林，海德堡。
- en: '328'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '328'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: 8\. [https://en.wikipedia.org/wiki/Paxos_(computer_science)](https://en.wikipedia.org/wiki/Paxos_(computer_science))
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. [https://en.wikipedia.org/wiki/Paxos_(计算机科学)](https://en.wikipedia.org/wiki/Paxos_(computer_science))
- en: 9\. Aspnes, J., 2020\. Notes on theory of distributed systems. arXiv
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 阿斯普内斯（Aspnes，J.），2020年。《分布式系统理论笔记》。arXiv
- en: preprint arXiv:2001.04235\.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 预印本arXiv：2001.04235。
- en: '10\. Howard, H., 2014\. ARC: analysis of Raft consensus (No. UCAM-'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. Howard，H.，2014年。ARC：Raft共识分析（编号UCAM-
- en: CL-TR-857). University of Cambridge, Computer Laboratory.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: CL-TR-857）。剑桥大学，计算机实验室。
- en: 11\. Ongaro, D. and Ousterhout, J., 2015\. The raft consensus algorithm.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. Ongaro，D.和Ousterhout，J.，2015年。Raft共识算法。
- en: 12\. Ongaro, D. and Ousterhout, J., 2014\. In search of an
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. Ongaro，D.和Ousterhout，J.，2014年。寻找一个
- en: understandable consensus algorithm. In 2014 USENIX Annual
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 可理解的共识算法。2014年USENIX年度
- en: Technical Conference (Usenix ATC 14) (pp. 305–319).
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 享技术大会（Usenix ATC 14）（pp. 305–319）。
- en: '13\. Tangaroa issues: Cachin, C. and Vukolić, M., 2017\. Blockchain'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 13\. Tangaroa问题：Cachin，C.和Vukolić，M.，2017年。区块链
- en: consensus protocols in the wild. arXiv preprint arXiv:1707.01873\.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 野生状态的共识协议。arXiv预印本arXiv：1707.01873。
- en: 14\. Liskov, B., 2010\. From viewstamped replication to Byzantine
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 14\. 到拜占庭
- en: fault tolerance. In *Replication* (pp. 121–149). Springer, Berlin,
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 容错性。在 *复制* (pp. 121–149). Springer, Berlin,
- en: Heidelberg.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 海德堡。
- en: 15\. Wattenhofer, R., 2016\. *The science of the blockchain*. Inverted
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 15\. Wattenhofer, R., 2016\. *区块链的科学*. Inverted
- en: Forest Publishing.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: Forest Publishing.
- en: '329'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '329'
- en: '**CHAPTER 8**'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章**'
- en: '**Blockchain Age Protocols**'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链时代协议**'
- en: This chapter covers blockchain age protocols. Some novel protocols and some
    variants
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了区块链时代协议。一些新颖的协议和一些变体
- en: of classical blockchain consensus protocols were discussed in Chapter [7](https://doi.org/10.1007/978-1-4842-8179-6_7).
    We start with Ethereum and finish this chapter with a discussion on Solana. Along
    the way, we will
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 古典区块链共识协议在[第7章](https://doi.org/10.1007/978-1-4842-8179-6_7). 我们开始讨论以太坊，并在本章讨论Solana。在此过程中，我们将
- en: cover in detail the characteristics, strengths, weaknesses, properties, and
    inner workings of major consensus protocols used in platforms such as Cosmos,
    Ethereum 2.0, and
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细介绍在诸如Cosmos、以太坊2.0和
- en: Polkadot.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: Polkadot.
- en: We already covered proof of work in detail in Chapt[er 5\. S](https://doi.org/10.1007/978-1-4842-8179-6_5)o,
    I will not repeat that here; however, Ethereum’s PoW will be discussed in this
    chapter.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中我们已经详细讨论了工作证明，所以我这里不会重复了；但是，以太坊的PoW会在本章讨论。
- en: '**Introduction**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**介绍**'
- en: Consensus protocols are at the core of any blockchain. A new class of consensus
    protocols emerged with Bitcoin. Therefore, we can categorize all consensus protocols
    for a
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议是任何区块链的核心。一类新的共识协议随着比特币的出现而出现。因此，我们可以将所有共识协议归类为
- en: blockchain that emerged with and after Bitcoin as “blockchain age consensus
    protocols.”
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 随着比特币的出现和之后的区块链，它们被称为“区块链时代共识协议。”
- en: The primary aim of a consensus protocol in a blockchain is to achieve an agreement
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中共识协议的主要目标是实现一致性和进展的协议
- en: on the state of the blockchain while preserving the safety and liveness of the
    system. The state generally refers to the value, history, and rules of the blockchain.
    An agreement on the canonical history of the blockchain is vital, and so is the
    agreement on the governing rules of the chain. Additionally, consensus on values
    (data) added to the chain is
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 对区块链状态的一致。状态通常指的是区块链的值、历史和规则。对区块链的规范历史达成一致很重要，对链的治理规则达成一致也很重要。此外，对添加到链上的值（数据）的一致也很重要。
- en: fundamentally critical.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上是至关重要的。
- en: Like traditional pre-blockchain protocols, safety and liveness are two key properties
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的区块链前协议一样，安全性和活跃性是两个关键属性
- en: that should be fulfilled by a consensus protocol to ensure the consistency and
    progress
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 由共识协议需满足以确保一致性和进展
- en: of the blockchain.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: 'Blockchain consensus protocols can be divided into two main categories: the'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链共识协议可以分为两大类：概率
- en: probabilistic finality protocols and absolute finality protocols – in other
    words,
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 概率最终性协议和绝对最终性协议-换句话说，
- en: probabilistic termination protocols and deterministic termination protocols.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 概率终止协议和确定终止协议。
- en: Probabilistic protocols are abundantly used in cryptocurrency public blockchains
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 概率协议在加密货币公共区块链中广泛使用
- en: like Ethereum and Bitcoin. Deterministic protocols, usually from the BFT class
    of
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 如以太坊和比特币。确定性协议通常来自BFT类
- en: '331'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '331'
- en: © Imran Bashir 2022
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: © Imran Bashir 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_8](https://doi.org/10.1007/978-1-4842-8179-6_8#DOI)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: I. Bashir，*区块链一致性*，[https://doi.org/10.1007/978-1-4842-8179-6_8](https://doi.org/10.1007/978-1-4842-8179-6_8#DOI)
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代协议
- en: protocols, are commonly used in enterprise blockchains; however, they are also
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，在企业区块链中通常使用；然而，它们也
- en: used in some public blockchains. While PBFT variants are more commonly used
    in
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些公共区块链中使用。而PBFT变体更常用于
- en: enterprise blockchains, their usage in public chains is somewhat limited only
    to some
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 企业区块链，它们在公共链的使用仅局限于一些
- en: public blockchains. For example, TowerBFT used in Solana is a deterministic
    finality
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 共有区块链。例如，Solana中使用的TowerBFT是一个确定性最终性
- en: consensus protocol. BFT-DPOS used in EOSIO is another example. Deterministic
    finality
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议。EOSIO中使用的BFT-DPOS就是另一个例子。确定性的最终性
- en: is also known as *forward security* where a guarantee is provided that a transaction
    once finalized will not be rolled back.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为*前向安全*，一旦交易完成，将提供保证不会被回滚。
- en: From the perspective of how the consensus algorithms work, blockchains or
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 从共识算法是如何工作的角度考虑，区块链或
- en: distributed ledgers are based on one or a combination of the following types
    of
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式账本基于以下一种或组合类型
- en: 'consensus algorithms:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法：
- en: '• **PoW based**: Such as Nakamoto consensus in Bitcoin, which relies on'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: • **基于PoW的**：比如比特币中的中本聪共识，依赖于
- en: solving a math puzzle using brute force.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 brute force 解决数学难题。
- en: '• **Leader based**: Such as usual BFT protocols where a leader acts as a'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: • **基于领导者的**：比如通常的BFT协议，其中领导者充当
- en: primary proposer of blocks/values.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 区块/值的首要提议者。
- en: '• **Voting based**: Usually applicable in BFT protocols where a leader'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: • **基于投票的**：通常适用于BFT协议，其中领导者
- en: gathers votes from followers to finalize a decision. Also called
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 从追随者那里收集投票以最终确定决策。也称为
- en: “quorum based.”
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: “基于法定人数”的。
- en: '• **Virtual voting**: Usually, voting in BFT protocols is complex from'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: • **虚拟投票**：通常，在BFT协议中，投票是复杂的
- en: a communication point of view, where each voter has to send and
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 从通信角度看，每个投票者都必须发送
- en: receive several messages to the leader. Virtual voting is a technique in
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者收到领导者的几条信息。虚拟投票是一种技术，可以
- en: the Hashgraph algorithm used in Hedera where votes are evaluated
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hedera中使用的Hashgraph算法，其中对投票进行了评估
- en: by looking at the local copies of the Hashgraph instead of complex
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Hashgraph的本地副本而不是复杂的
- en: communication with other nodes. This process eventually leads to
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他节点通信。这个过程最终会导致
- en: achieving a Byzantine agreement.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 达成拜占庭协议。
- en: '• **Economy based**: Such as proof of stake mechanisms that rely on a'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: • **基于经济的**：比如依赖于股份证明机制的机制
- en: stake bonded in the network.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中抵押的利益。
- en: After Bitcoin’s inception, many blockchains emerged, and alternative PoW algorithms
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币问世后，许多区块链涌现出来，并出现了替代的PoW算法
- en: were introduced, for example, Litecoin. As PoW consumes excessive amounts of
    energy,
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 被引入，例如莱特币。由于PoW消耗大量能源，
- en: the community felt very early that alternatives that are not excessively energy
    consuming need to be designed. In the wake of introducing less energy-consuming
    protocols,
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 社区很早就感到需要设计一些不过度消耗能源的替代方案。在引入消耗较少能量的协议之后，
- en: developers introduced proof of stake. With PoS, the sustainable public blockchain
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员引入了股权证明。通过PoS，可持续公共区块链
- en: networks have become possible to build. There are, however, some challenges
    and caveats.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 网络变得可能。但是，也存在一些挑战和注意事项。
- en: After going through the mechanics of how PoS works, we will discuss these limitations.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 研究PoS的工作原理之后，我们将讨论这些限制。
- en: '332'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '332'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代的协议
- en: '**Proof of Stake**'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '**股权证明**'
- en: 'Even though Bitcoin’s PoW has proven to be a resilient and robust protocol,
    it has several limitations:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比特币的PoW已被证明是一种弹性和健壮的协议，但它有一些局限性：
- en: • Excessive energy consumption
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: • 能源消耗过高
- en: • Slow rate of block generation
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块生成速度缓慢
- en: • Becoming centralized due to the requirement of specialized
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于需要专门设备
- en: hardware and large mining pools
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和大型矿池，变得集中化
- en: • Probabilistic finality which is not suitable for most of the applications
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: • 不适合大多数应用的概率最终性
- en: • Not a perfect consensus algorithm, some attacks exist, for example,
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: • 不是完美的共识算法，存在一些攻击，例如，
- en: Goldfinger attack, 51% attack
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 高前需要的攻击，51%的攻击
- en: • Barrier to entry getting higher as a special hardware
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: • 入门门槛越来越高，因为特殊硬件
- en: requirement to mine
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 需要挖掘的要求
- en: • Not scalable enough to support usual high throughput applications
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: • 不够可扩展，无法支持常见的高吞吐量应用程序
- en: Significant research has been ongoing to address the abovementioned weaknesses.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 已经进行了重要研究，以解决上述弱点。
- en: Especially, high energy consumption from the limitations mentioned earlier led
    to the
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，由于前面提到的限制，高能耗导致了
- en: development of alternatives. Proof of stake is one such alternative.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 开发替代方案。股权证明就是这样一种替代方案。
- en: Proof of stake first appeared in Peercoin in 2012\. Later, many blockchains
    adopted
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 股权证明最早出现在2012年的Peercoin中。后来，许多区块链采用了
- en: this mechanism, such as EOS, NxT, Steem, Tezos, and Cardano. In addition, Ethereum,
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 例如EOS、NxT、Steem、Tezos和Cardano等项目。此外，以太坊，
- en: with its Serenity release, will soon transition to a PoS-based consensus mechanism.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 随着其Serenity版本的发布，以后将很快过渡到基于PoS的共识机制。
- en: Proof of stake is also called virtual mining. This is so because in PoS instead
    of requiring miners to allocate compute resources to solve a puzzle, the right
    to produce the
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 股权证明也被称为虚拟挖矿。这是因为在PoS中，不需要矿工分配计算资源来解决谜题，而是需要产生
- en: next block is decided on the basis of what value the miner possesses. This valuable
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个区块的决定是基于矿工所拥有的价值。这个有价值的
- en: possession can be anything of value (usually coins) that aligns with the interest
    of the
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权可以是任何有价值的东西（通常是硬币），与利益一致
- en: network. PoW’s motto was one CPU = one vote, whereas we can think of PoS as
    one coin
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。PoW 的座右铭是一个 CPU = 一票，而我们可以认为 PoS 是一枚硬币
- en: = one vote.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: = 一票。
- en: The next proposer is usually elected randomly. Proposers are incentivized either
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个提议者通常是随机选出的。提议者会得到激励
- en: with transaction fees or block rewards. Like PoW, control over the majority
    of the
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 需要是交易手续费或区块奖励。像 PoW 一样，通过拥有网络大部分
- en: network in the form of controlling a large portion of the stake is required
    to attack and control the network.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制大部分押金来攻击和控制网络形式。
- en: PoS protocols usually select stakeholders and grant suitable rights based on
    their
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: PoS 协议通常选择利益相关者，并基于其授予相应的权利
- en: staked assets. The stake calculation is application specific but is typically
    based on
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 押在资产上。押金计算是特定于应用程序，但通常基于
- en: the total balance, deposited value, or voting between the validators. Once the
    stake is
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 总余额、存款价值或验证者之间的投票。一旦确认押金
- en: '333'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '333'
- en: '![](index-348_1.png)'
  id: totrans-965
  prefs: []
  type: TYPE_IMG
  zh: '![](index-348_1.png)'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章区块链时代协议
- en: calculated and a stakeholder is selected as the block proposer, the block proposed
    by the proposer is readily accepted. The higher the stake, the better the chances
    of winning the right to propose the next block.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和选举成为区块提议者，提议者提议的区块会被立即接受。押金越多，下一个提议区块的机会越大。
- en: A general scheme of a PoS scheme is shown in Figur[e 8-1\.](#p348)
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: PoS 方案的一般方案如图[e 8-1\.](#p348)所示
- en: '***Figure 8-1\.** Proof of stake scheme*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 8-1\.** 权益证明方案*'
- en: As shown in Figur[e 8-1](#p348), PoS uses a stake calculator function to calculate
    the amount of staked funds, and, based on that, it selects a new proposer.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[e 8-1](#p348)所示，PoS 使用押金计算器函数来计算押金金额，并且基于此选择新的提议者。
- en: The next proposer is usually elected randomly. Proposers are incentivized either
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个提议者通常是随机选出的。提议者会得到激励
- en: with transaction fees or block rewards. Control over most of the network by
    having a
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 需要交易手续费或区块奖励。通过拥有网络大部分的控制
- en: large portion of the stake is needed to attack the network.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 需要大部分押金来攻击网络。
- en: There is some element of randomness introduced in the selection process to ensure
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 选择过程中引入了一些随机性元素，以确保
- en: fairness and decentralization. Other factors in electing a proposer include
    the age of the tokens, which takes into account for how long the staked tokens
    have been unspent; the
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '公平性和分散化。选举提议者的另一个因素是代币的年龄，这考虑了押在账户中的代币已经花费了多久; '
- en: longer the tokens have been unspent, the better the chances to be elected.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 票据未花费的时间越长，当选的机会越大。
- en: 'There are several types of PoS:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种 PoS：
- en: • Chain-based PoS
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: • 链式 PoS
- en: • BFT-based PoS
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: • 基于 BFT 的 PoS
- en: • Committee-based PoS
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: • 基于委员会的 PoS
- en: • Delegated proof of stake
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: • 委托权益证明
- en: • Liquid proof of stake
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: • 液体权益证明
- en: '334'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '334'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章区块链时代协议
- en: '**Chain-Based PoS**'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '**链式 PoS**'
- en: This scheme is the first alternative proposed to PoW. It was used first in Peercoin
    in 2012\.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案是首次提出的 PoW 的替代方案。它首次在 2012 年的 Peercoin 中使用.
- en: This mechanism is like PoW; however, the block generation method is changed,
    which
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制类似于 PoW; 但是，区块生成方法被改变了，这
- en: 'finalizes blocks in two steps:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '完成两个步骤来定稿区块:'
- en: • Pick transactions from the memory pool and create a
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: • 从内存池中选择交易并创建
- en: candidate block.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 候选区块。
- en: • Set up a clock with a constant tick interval. At each clock tick, check
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: • 建立具有恒定滴答间隔的时钟。在每次时钟滴答时，检查
- en: whether the hash of the block header concatenated with the clock
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 区块头部与时钟的哈希
- en: time is less than the product of the target value and the stake value.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 时间小于目标值和押金值的乘积。
- en: 'We can show this simple formula as follows:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将这个简单的公式表示如下:'
- en: '*Hash* ( *B*'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hash*（*B*'
- en: ) <
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: ) <
- en: ×
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: ×
- en: '*h* || *clock tim*'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '*h* || *时钟时间*'
- en: '*e target stake valu*'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '*e 目标押金*'
- en: '*e*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*'
- en: The stake value depends on how the algorithm works. In some chains, it is
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 押金价值取决于算法的运行方式。在某些链中，它是
- en: proportional to the amount of stake. In others, it is based on the amount of
    time the
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 与押金数量成比例。在其他情况下，它是基于时间的
- en: participant has held the stake. The target is the mining difficulty per unit
    of the value of the stake.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者所持有的押金。目标是每单位押金价值的挖矿难度。
- en: This mechanism uses hashing puzzles, as in PoW. But, instead of competing to
    solve
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制使用哈希谜题，就像PoW一样。但是，与解决竞争不同
- en: the hashing puzzle by consuming high energy and using specialized hardware,
    the hashing
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消耗大量能量和使用专门的硬件，散列
- en: puzzle in PoS is solved only once at regular clock intervals. A hashing puzzle
    becomes
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: PoS中的谜题只在定期的时钟间隔内解决。一个哈希谜题变成了
- en: proportionally easier to solve if the stake value of the miner is high. This
    contrasts with PoW where repeated brute-force hashing is required to solve the
    math puzzle.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 从而更容易地解决如果矿工的股份价值更高。这与需要重复的PoW对比
- en: '**Committee-Based PoS**'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于委员会的PoS**'
- en: In this scheme, a group of stakeholders is chosen randomly, usually using a
    verifiable
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，一组利益相关者通常是随机选择的，通常使用可验证的
- en: random function (VRF). The VRF produces a random set of stakeholders based on
    their
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 随机功能(VRF)。VRF基于他们产生一组随机的利益相关者
- en: stake and the current state of the blockchain. The chosen group of stakeholders
    becomes
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 股份和区块链的当前状态。被选择的利益相关者组成
- en: responsible for proposing blocks in sequential order.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 负责按顺序提出区块。
- en: '335'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 一般方案的操作方式如下：
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章区块链时代协议
- en: 'A general scheme is described as follows:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 一般方案描述如下：
- en: • A validator joins the network and deposits a stake.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: •验证者加入网络并存入股份。
- en: • Participate in the committee election process and keep checking
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: •参与委员会选举过程并继续检查
- en: its turns.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 轮流。
- en: • When it’s the turn, collect transaction, generate block, append the
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: •该轮到您时，收集交易，生成区块，附加
- en: new block in the chain, and finally broadcast the block.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 链中的新区块，并最终广播该区块。
- en: • At the other receiver nodes, verify the block; if valid, append the
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: • 在其他接收节点上，验证区块；如果有效，则附加
- en: block into the blockchain and gossip the block to others.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 将区块添加到区块链并向其他人传播该区块。
- en: The committee election produces a pseudorandom sequence of turns for validators
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 委员会选举为验证者产生一个伪随机的轮次序列
- en: to produce blocks. Ouroboros Praos and BABE are common examples of committee-
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 生成区块。Ouroboros Praos和BABE是委员会常见的例子-
- en: based PoS.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: PoS。
- en: '**BFT-Based PoS**'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力的散列是需要解决数学谜题的工作。
- en: In this scheme, the blocks are generated using a proof of stake mechanism where
    a block
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，区块是使用股权机制生成的，其中一个区块
- en: proposer is chosen based on the proof of stake which proposes new blocks. The
    proposer
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 根据股权的提名者被选择出来，提出新的区块。提议者
- en: is elected based on the stake deposited in the system. The chance of being chosen
    is
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 是基于系统存放的股份选择的。被选中的机会是
- en: proportional to the amount of stake deposited in the system. The proposer generates
    a
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 正比于系统中存入的股份数量。提议者生成一个
- en: block and appends it to a temporary pool of blocks from which the BFT protocol
    finalizes
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 区块并将其附加到BFT协议最终确定的临时区块池中
- en: one block.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块。
- en: 'A general scheme works as follows:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章区块链时代协议
- en: • Elect a block proposed based on the PoS mechanism, proportional to
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: •根据PoS机制选择提议的区块，与
- en: a stake.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 一种股权。
- en: '• Proposer: Propose a new block, add to a temporary block pool, and'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: •提出者：提出一个新的区块，添加到临时的区块池中，并且
- en: broadcast the new block.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 广播新的区块。
- en: '• Receiver: When other nodes receive this, they validate the block and,'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: • 接收者：其他节点接收到这一点时，它们会验证该区块，并且
- en: if valid, add to the local temporary block pool.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于BFT的PoS**'
- en: • During the consensus epoch
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: •在共识纪元期间
- en: • Run BFT consensus to finalize a valid (most voted) block.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: •运行BFT共识来最终确定一个有效（得到最多投票）的区块。
- en: • Add the most voted valid block to the main blockchain.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: •将得票最多的有效区块添加到主区块链。
- en: • Remove other blocks from the temporary block pool.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: •从临时区块池中删除其他区块。
- en: '336'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '336'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，区块会立即完成。
- en: Tendermint in Cosmos is one example where the validator is chosen based on a
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos中的Tendermint是一个例子，其中验证者是根据
- en: stake, and the rest of the protocol works on BFT principles. Other examples
    include
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 股份，协议的其余部分基于BFT原则运作。其他示例包括
- en: Casper FFG.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 堡垒地。
- en: BFT-based PoS is fault tolerant as long as two-thirds of validators remain honest.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 基于BFT的PoS在至少三分之二的验证者保持诚实的情况下是容错的。
- en: Also, blocks are finalized immediately.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有效，将其添加到本地临时区块池中。
- en: '**Delegated PoS**'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '**委托PoS**'
- en: DPoS works like proof of stake, but a critical difference is a voting and delegation
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: DPoS的工作方式类似于PoS，但一个关键的区别在于投票和代表
- en: mechanism which incentivizes users to secure the network. DPoS limits the size
    of
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 机制，鼓励用户保护网络。DPoS限制了
- en: the chosen consensus committee, which reduces the communication complexity in
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的共识委员会，这减少了通信复杂性
- en: the protocol. The consensus committee is composed of so-called delegates elected
    by
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。共识委员会由所谓的代表组成，他们是由选出的
- en: a delegation mechanism. The process works by stakeholders voting for delegates
    by
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 一种委托机制。这个过程是由利益相关者通过投票选出代表
- en: using their stake. Delegates (also called witnesses) are identifiable, and voters
    know
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 利用他们的赌注。代表（也称为见证人）是可识别的，选民知道
- en: who they are, thus reducing the delegates’ chance of misbehavior. Also, a reputation-
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 他们是谁，从而降低代表们的不端行为的机会。此外，声誉-
- en: based mechanism can be implemented, allowing delegates to earn a reputation
    based
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 基于机制可以实施，使代表根据
- en: on the services they offer and their behavior on the network. Delegates can
    represent
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供的服务和他们在网络上的行为。代表可以代表
- en: themselves for earning more votes. Delegates who get the most votes become members
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 他们自己为了赢得更多票数。得到最多票数的代表成为成员
- en: of the consensus committee or group. Usually, a BFT-style protocol runs between
    the
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 共识委员会或组。通常，一个BFT风格的协议在
- en: members of the chosen consensus committee to produce and finalize blocks. Each
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 被选择的共识委员会的成员制作和最终确定区块。每个
- en: member can take a round-robin fashion to propose the next block, but this activity
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 成员可以轮流提出下一个区块，但这种活动
- en: remains within the elected consensus committee. Delegates earn incentives to
    produce
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然留在选举的共识委员会中。代表获得激励来产生
- en: blocks. Again, under the BFT assumptions, the protocol within the consensus
    committee
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 区块。同样，在BFT假设下，共识委员会内部的协议
- en: can tolerate f faults in a 3f+1 member group. In other words, it can tolerate
    one-third
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 可以容忍一个3f+1成员组中的f个错误。换句话说，它可以容忍三分之一
- en: or 33% of delegates being faulty. This protocol provides instant finality and
    incentives
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 或有33%的代表是有故障的。这一协议提供即时的最终性和激励。
- en: in proportion to the stake of the stakeholders. As network-wide consensus is
    not
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 与利益相关者的赌注相匹配。由于网络范围内的共识不是
- en: required and only a smaller group of delegators oversee making decisions, the
    efficiency
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 需要并且只有一个更小的代表团队监督做决定，效率
- en: increases significantly. Delegated PoS is implemented in EOS, Lisk, Tron, and
    quite a few other chains.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 增加显着。委托PoS实施在EOS、Lisk、Tron等许多其他链中。
- en: '**Liquid PoS**'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '**流动PoS**'
- en: LPoS is a variant of DPoS. Token holders delegate their validation rights to
    validators
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: LPoS是DPoS的一个变种。代币持有人将他们的验证权委托给验证者
- en: without requiring transferring the ownership of the tokens. There exists a delegation
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 无需转让代币的所有权。存在一种委托
- en: market where delegates compete to become the chosen validator. Here, the competition
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 代表竞争成为被选中的验证者的市场。在这里，竞争
- en: '337'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '337'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代协议
- en: is primarily on fees, services offered, reputation, payout frequency, and possibly
    other
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 主要集中在费用、提供的服务、声誉、支付频率及可能的其他因素上
- en: factors. Any misbehavior such as charging high fees by a validator is detectable
    quickly
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 因素。任何像收取高费用的验证者这样的错误行为是可以迅速检测到的
- en: and will be penalized accordingly. Token holders are also free to move to any
    other
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 且将受到相应的处罚。代币持有者也可以自由转移到任何其他
- en: validator. LPoS supports a dynamic number of validators as compared to DPoS’s
    fixed
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者。LPoS支持动态数量的验证者，与DPoS的固定数量对比
- en: validator set. Token holders are also allowed to become validators themselves
    by self-
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者组。代币持有人也被允许成为自己的验证者，通过自我-
- en: electing. Token holders with small amount can delegate to larger amount holders.
    Also, a
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 选举。拥有少量代币持有者可以委托给拥有更多代币持有者。此外，一个
- en: number of small token holders can form a syndicate. Such “liquid” protocol allows
    much
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 多个小代币持有者可以组成一个联盟。这种“流动”协议允许更多
- en: flexibility as compared to other PoS protocols and helps to thwart creation
    of lobbies to become a fixed validator set. LPoS is used in the Tezos blockchain.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 比其他PoS协议更具灵活性，并能帮助阻止创建游说团体成为固定的验证者组。LPoS被用在Tezos区块链中。
- en: There are some attacks against PoS, such as the nothing-at-stake attack, long-range
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些针对PoS的攻击，例如无所作为攻击，远程攻击
- en: attack, and stake grinding attack. We explain these attacks as follows.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击和赌注磨攻击。我们将这些攻击解释如下。
- en: '**Attacks**'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击**'
- en: PoS suffers generally from a costless simulation problem where an adversary
    can
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: PoS通常存在着一个免费模拟问题，其中对手可以
- en: simulate any history of the chain without incurring any additional cost, as
    opposed to
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟链的任何历史，而不会带来任何额外成本，与
- en: PoW where the cost is computational power. This no-cost block generation is
    the basis of
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: PoW其中成本是计算能力。这种无成本的区块生成是
- en: many attacks in PoS.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 在PoS中存在许多攻击。
- en: '**Nothing-at-Stake Problem**'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '**无所谓问题**'
- en: The nothing-at-stake or double bet problem occurs when multiple forks occur.
    An
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '当出现多次分叉时，就会出现无所谓或双重下注问题。 '
- en: attacker can generate a block on top of each fork without any additional cost.
    To solve
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以在每个分叉的顶部产生一个块，而不需要额外的成本。 为了解决
- en: this problem, economic penalties are introduced in protocols that prevent attackers
    from
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题，协议中引入经济处罚，以防止攻击者
- en: launching this attack. If a significant number of nodes do this, then an attacker
    holding even less than 50% of tokens can launch a double-spend attack.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '发动此攻击。 如果有大量的节点这样做，那么即使持有的令牌少于 50% 的攻击者也可以发动双重花费攻击。 '
- en: '**Long-Range Attacks**'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '**长距离攻击**'
- en: Long-range attacks exist due to weak subjectivity and costless simulation. Long-range
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 长距离攻击由于弱主观性和无成本模拟而存在。 长距离
- en: attacks are also possible because of costless simulation where an adversary
    creates a
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无成本模拟，攻击也是可能的，其中对手会创建
- en: new branch starting from the genesis block with the aim to take over the main
    good
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '以试图接管主链的目标开始了新的分支 '
- en: chain, once the bad chain becomes longer than the real main chain. This can
    create an
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 链 ，一旦坏链比真正的主链长了。 这可能创造出一个
- en: alternate history which is detrimental to the blockchain.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '对网络造成破坏 ，因为它可能导致诚实的验证者浪费资源。 '
- en: A weak subjectivity problem affects new nodes and the nodes which were offline
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 弱主观性问题影响新节点和长时间离线的节点
- en: for a long time and rejoined the network. As nodes are not synchronized and
    there are
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间并重新加入网络。 由于节点不同步并且有
- en: '338'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '338'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '第 8 章 区块链年代协议 '
- en: usually multiple forks available in the network, these nodes are unable to differentiate
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 可用多个分叉 ，这些节点无法区分
- en: between which node is correct and which one is malicious; they may as well accept
    a
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个节点是正确的，哪个是恶意的; 他们可能接受一个
- en: malicious fork as valid.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '恶意的分叉也被视为有效。 '
- en: '**Other Attacks**'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他攻击**'
- en: '**Liveness denial** is another attack that PoS can suffer from. In this attack,
    some or all validators collectively decide to stop validating the blocks, resulting
    in halting block'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期否定** 是 PoS 可以遭受的另一种攻击。 在这种攻击中，一些或所有验证器共同决定停止验证区块，导致区块停滞的结果'
- en: production. Penalizing such activities by the protocol can prevent these types
    of attacks.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '生产。 协议对此类活动进行惩罚可以预防这些类型的攻击。 '
- en: A **selfish mining** or block withholding attack occurs when an adversary mines
    their
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 自私挖矿 或阻止攻击当对手开采他们自己的
- en: own chain offline. Once the chain is at a desired length, the adversary releases
    this chain to the network with the expectation that the bad chain will take over
    the main good
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 自己的链离线。 一旦链长度达到期望的长度，对手将该链发布到网络上，期望坏链将接管主要的好
- en: chain. It can cause disruption on the network as it can result in causing honest
    validators to waste resources.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '链 。 它可以在网络上造成中断，因为它可能导致诚实的验证者浪费资源。 '
- en: A **grinding attack** on PoS occurs if a slot leader election process is not
    random. If no randomness is introduced in this process, then a slot leader can
    increase the frequency
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PoS 上发生 **磨攻击** ，如果 slot leader 选举过程不是随机的。 如果在这个过程中没有引入随机性，那么 slot leader
    可以增加频率
- en: of its own election again and again, which can result in censorship or disproportionate
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '一直自己选举，结果可能导致审查或不成比例 '
- en: rewards. An easy way to solve this is to use some good random selection process,
    usually
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励。解决这个问题的简单方法是使用一些良好的随机选择过程，通常是
- en: based on verifiable random functions (VRFs).
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于可验证随机函数（VRFs） 。
- en: Next, we discuss Ethereum’s proof of work – Ethash.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们讨论以太坊的工作证明—— Ethash 。 '
- en: '**Ethereum’s Proof of Work**'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊的工作证明**'
- en: We discussed PoW for Bitcoin in detail in Chapt[er 5](https://doi.org/10.1007/978-1-4842-8179-6_5).
    In this section, we’ll see how ETHASH works, the PoW used in Ethereum.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在 Chapt[er 5](https://doi.org/10.1007/978-1-4842-8179-6_5) 详细讨论了比特币的 PoW
    。 在本节中，我们将看到 ETHASH 的工作原理，以太坊使用的 PoW 。 '
- en: Ethash is the evolved form of the Dagger-Hashimoto algorithm. The key idea behind
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: Ethash 是 Dagger-Hashimoto 算法的发展形式。 基本想法
- en: mining is to find a nonce (an arbitrary random number), which, once concatenated
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 采矿是找到一个随机数（任意随机数），一旦连接
- en: with the block header and hashed, results in a lower number than the current
    network
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 与块头部和哈希的当前网络
- en: difficulty level. Initially, the difficulty was low when Ethereum was new, and
    even CPU
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 困难级别。 最初，以太坊刚起步时，困难很低，甚至是 CPU
- en: and single GPU mining was profitable to a certain extent, but that is no longer
    the case.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 GPU 挖矿在一定程度上是有利可图的，但现在不再是这样了。
- en: So now, only pooled mining or large GPU mining farms are used for profitable
    mining
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有合并挖矿或大型 GPU 挖矿场用于有利可图的挖矿
- en: purposes.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 目的。
- en: Ethash is a memory-hard algorithm, making it challenging to implement on
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: Ethash 是一种内存密集型算法，这使得它难以实现在
- en: specialized hardware due to the requirement of large and fast memories on ASICS,
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 专用硬件要求 ASICS 上具有大型和快速内存，
- en: which is generally not practical.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是不切实际的。
- en: '339'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '339'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 块链年龄协议
- en: Note that for quite some time, this memory hardness of Ethash prevented the
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有相当长的时间，Ethash 的内存硬度防止了
- en: development of ASICs, but now various ASIC miners are available for Ethereum
    mining.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: ASIC 的发展，但现在各种 ASIC 挖矿机器可用于以太坊挖矿。
- en: This algorithm requires subsets of a fixed resource called a directed acyclic
    graph
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法需要一种称为有向无环图的固定资源的子集。
- en: (DAG) to be chosen, depending on the nonce and block headers.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: （DAG），取决于 nonce 和区块头。
- en: DAG is a large, pseudorandomly generated dataset. This graph is represented
    as
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: DAG 是一个大型、伪随机生成的数据集。该图被表示为
- en: a matrix in the DAG file created during the Ethereum mining process. The Ethash
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: DAG 文件中创建的矩阵。 Ethash
- en: algorithm has the DAG as a two-dimensional array of 32-bit unsigned integers.
    Mining
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将 DAG 转换为 32 位无符号整数的二维数组。挖矿
- en: only starts when DAG is fully created the first time a mining node starts.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 DAG 首次完全创建时，挖矿节点才会开始。
- en: This DAG is used as a seed by the Ethash algorithm. The Ethash algorithm requires
    a
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 此 DAG 被 Ethash 算法用作种子。 Ethash 算法需要
- en: DAG file to work. A DAG file is generated every epoch, 30,000 blocks. DAG grows
    linearly
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: DAG 文件的工作。每个时代生成一个 DAG 文件，30,000 个区块。DAG 线性增长
- en: as the chain size grows.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着链的增长。
- en: 'The protocol works as follows:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的工作方式如下：
- en: • The header from the latest block and a 32-bit random nonce are
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: • 从最新区块的头和一个 32 位随机 nonce
- en: combined using the Keccak-256 hash function.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Keccak-256 哈希函数组合。
- en: • This produces a 128-bit structure called mix which determines which
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: • 这产生一个称为 mix 的 128 位结构，该结构确定了
- en: data, that is, a 128-byte page, to select from the DAG.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 数据，也就是一张 128 字节的页，从 DAG 中选择。
- en: • Once the data is fetched from the DAG, it is “mixed” with the mix to
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: • 一旦数据从 DAG 获取，它就会与混合一起“混合”以
- en: produce the next mix, which is then used to fetch data from the DAG
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 产生下一个 mix，然后用它从 DAG 获取数据
- en: and subsequently mixed again. This process repeats 64 times.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次混合。这个过程重复 64 次。
- en: • Eventually, the 64th mix is run through a digest function to produce a
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: • 最终，第 64 个 mix 通过摘要函数运行以产生一个
- en: 32-byte sequence called the mix digest.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 32 字节序列，称为 mix 摘要。
- en: • This sequence is compared with the difficulty target. If it is less than
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: • 这个序列与难度目标进行比较。如果小于
- en: the difficulty target, the nonce is valid, and the PoW is solved. As a
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 难度目标，nonce 有效，PoW 已解决。作为
- en: result, the block is mined. If not, then the algorithm repeats with a
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，区块被挖出。如果没有，那么算法将重复执行
- en: new nonce.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 新 nonce。
- en: We can visualize this process in Figure [8-2\.](#p355)
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图 [8-2\.](#p355) 中可视化这个过程
- en: '340'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '340'
- en: '![](index-355_1.png)'
  id: totrans-1163
  prefs: []
  type: TYPE_IMG
  zh: '![](index-355_1.png)'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 块链年龄协议
- en: '***Figure 8-2\.** Ethash process*'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 8-2\.** Ethash 过程*'
- en: 'Ethash has several objectives:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: Ethash 有几个目标：
- en: • The algorithm consumes almost all available memory access
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: • 该算法几乎消耗了所有可用内存访问
- en: bandwidth, which is an ASIC resistance measure.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽，这是一种 ASIC 抗性措施。
- en: • Mining with Ethash using GPUs is easier to perform.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 GPU 进行 Ethash 挖矿更容易进行。
- en: • Light clients can verify mining rounds much efficiently and should be
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: • 轻客户端可以更有效地验证挖矿轮次，并且应该
- en: able to become operational quickly.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速投入运行。
- en: • The algorithm runs prohibitively slow on light clients as they are not
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于轻客户端运行速度非常慢，所有该算法在轻客户端上都无法
- en: expected to mine.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的挖掘。
- en: As the Ethereum execution layer (formerly Eth1) advances toward the consensus
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着以太坊执行层（曾称为 Eth1）向共识演进
- en: layer (formerly Ethereum 2), this PoW will eventually phase out. When the current
    EVM
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 层（以前的以太坊 2），此 PoW 最终将淘汰。当前 EVM
- en: chain is docked into the beacon chain, that is, the so-called “the merge” happens,
    Casper FFG will run on top of PoW. Eventually, however, Casper CBC, the pure PoS
    algorithm,
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 链被纳入信标链，即所谓的“合并”发生，Casper FFG 将在 PoW 之上运行。然而，最终，Casper CBC，纯 PoS 算法，
- en: will finally take over.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终接管。
- en: Also, with ice age activation, the PoW will become almost impossible to mine
    due to
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着冰河时代的到来，由于
- en: the extreme difficulty level induced by the “ice age,” and users will have no
    choice but to switch to PoS.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“冰河时代”引起的极高的难度，用户将别无选择，只能转向PoS。
- en: '341'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '341'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章区块链时代协议
- en: '**Solana**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solana**'
- en: Solana is a layer 1 blockchain with smart contract support introduced in 2018\.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: Solana是一个在2018年推出的具有智能合约支持的第1层区块链。
- en: Developers of Solana aimed for speed, security, scalability, and decentralization.
    At
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: Solana的开发人员旨在提高速度，安全性，可扩展性和分散性。 在
- en: the time of writing, it is in Beta, and it is growing in popularity quickly.
    Though it is an operational network with production systems running on it, there
    are some technical
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时间，它处于Beta阶段，并且快速增长。 尽管这是一个具有生产系统的运行网络，但其中存在一些技术
- en: issues which are being addressed.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 正在解决的问题。
- en: The ledger is a verifiable delay function where time is a data structure, that
    is, data
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 分类帐是一个可以验证的延迟函数，其中时间是一种数据结构，即数据
- en: is time. It potentially supports millions of nodes and utilizes GPUs for acceleration.
    SOL
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 是时间。 它可能支持数百万个节点，并利用GPU进行加速。 SOL
- en: coin is the native token on the platform used for governance and incentivization.
    The
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 币是该平台上用于治理和激励的本地代币。 该
- en: main innovations include the following.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 主要创新包括以下内容。
- en: Proof of history (PoH) enables ordering of events using a data structure–based
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 历史证明（PoH）使用基于数据结构的事件排序
- en: cryptographic clock instead of an external source of time, which then leads
    to consensus.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 导致共识的密码时钟，而不是外部时间来源。 由此导致
- en: TowerBFT is a protocol for consensus derived from PBFT. Note that PoH is not
    a
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: TowerBFT是一种从PBFT派生的共识协议。 请注意，PoH不是
- en: consensus protocol, it is simply a mechanism to enable ordering of events using
    a data
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议，它只是一种启用使用基于数据的事件排序
- en: structure–based clock. A consensus mechanism is still needed to enable nodes
    to vote
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 结构为基础的时钟。 仍然需要一种共识机制来使节点投票
- en: on a correct branch of the ledger.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类帐的正确分支上。
- en: Turbine is another innovation which enables block propagation in small chunks
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 涡轮是另一种创新，使得区块以小块传播
- en: called shreds, which helps to achieve speed and efficiency. There are no memory
    pools
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 名为碎片，这有助于实现速度和效率。 没有内存池
- en: in Solana as transactions are processed so fast that memory pools do not form.
    This
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solana中，交易处理得如此之快，以至于不会形成内存池。 这
- en: mechanism has been named the Gulf stream.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 机制被命名为Gulf stream。
- en: Solana supports parallel execution of smart contracts, which again results in
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: Solana支持智能合约的并行执行，这又导致
- en: efficiency gains.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 效率收益。
- en: Transactions are validated in an optimized fashion using pipelining in the so-called
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 交易以所谓的优化方式进行验证
- en: transaction processing unit residing within validators.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在验证器内的事务处理单元。
- en: Cloud break is a name given to the database which is horizontally scalable.
    Finally,
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud break是一个名称，用于横向扩展的数据库。 最后，
- en: archivers or replicators are nodes which allow for distributed ledger storage,
    as in a
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在分布式分类帐存储器中的存档或复制程序节点，如在
- en: high throughput system such as Solana data storage can become a bottleneck.
    For this
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 高吞吐量系统，例如Solana数据存储可能成为瓶颈。 为此
- en: purpose, archivers are used which are incentivized to store data.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 目的，使用了受激励存储的存档者。
- en: As our main focus is consensus algorithms, I will leave the introduction to
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的主要重点是共识算法，我将不介绍
- en: blockchains here and move on to discussing the actual consensus and relevant
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链在这里，我们接着讨论实际共识和相关
- en: mechanisms in Solana.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: Solana的机制。
- en: Solana uses proof of stake and TowerBFT consensus algorithms. One of the key
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: Solana使用股权证明和TowerBFT共识算法。 其中的其中一个
- en: innovations in Solana is proof of history, which is not a consensus algorithm
    but allows
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: Solana的创新是历史证明，它不是一种共识算法，但允许
- en: to create a self-consistent record of events proving that some event occurred
    before
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自洽的事件记录，证明某个事件发生在之前
- en: and after some point in time. This then leads to consensus. It results in reducing
    the
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在某个时间点之后。 这随后导致共识。 它有助于减少
- en: '342'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '342'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章区块链时代协议
- en: message complexity in a BFT protocol where effectively communication is replaced
    by
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: BFT协议中的消息复杂性，实际上通信被替换为
- en: local computations. This immediately results in high throughput and subsecond
    finality
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 本地计算。 这立即导致高吞吐量和亚秒级的最终性
- en: times. It has been long known in the distributed systems research community
    that if
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 时间。长期以来，分布式系统研究界一直知道，如果
- en: somehow communication can be replaced with local computation, then significant
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，通信可以被本地计算所替代，那么显著
- en: performance can be achieved, and many clock synchronization protocols emerged
    as
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以实现性能，而且许多时钟同步协议应运而生
- en: a result. However, generally all of these relied on an external source of time
    either via atomic clocks or GPS and then use an NTP type of protocol to synchronize.
    PoH is a
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 结果。然而，通常所有这些都依赖于一个外部时间来源，要么通过原子时钟或GPS，然后使用NTP类型的协议进行同步。PoH是一个
- en: proof for cryptographically proving order and passage of time between events
    without
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在事件之间以密码方式证明顺序和时间的证明
- en: relying on an external source of time.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖外部时间源。
- en: '**Proof of History**'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史证明**'
- en: As discussed in Chapt[er 1](https://doi.org/10.1007/978-1-4842-8179-6_1), time
    in distributed systems is crucial. If time is synchronized among processes, that
    is, a synchronized clock is available in a distributed network, then communication
    can be reduced, which results in improved performance. A node can
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 如第[1章](https://doi.org/10.1007/978-1-4842-8179-6_1)所讨论的，分布式系统中的时间至关重要。如果进程间的时间是同步的，也就是说，在分布式网络中有一个同步的时钟，那么通信就可以减少，这会导致性能提升。一个节点可以
- en: deduce information from past events instead of asking another node repeatedly
    about
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 推断过去事件的信息，而不是反复询问另一个节点
- en: some information. For example, with the availability of a global clock where
    all nodes
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 一些信息。例如，当所有节点都有全局时钟可用
- en: are synchronized, the system can establish a notion of the system-wide history
    of events.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 同步，系统可以建立一个系统范围的事件历史概念。
- en: For example, a timestamp on an event can inform a node when this event occurred
    in
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，事件上的时间戳可以告诉一个节点这个事件发生在
- en: reference to the globally synchronized time across the network, instead of asking
    a node
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 引用网络范围内的全局同步时间，而不是询问一个节点
- en: again who produced that event when this event occurred.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当这个事件发生时，谁产生了这个事件。
- en: Another application of a synchronized clock is that entities in the system can
    deduce
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 同步时钟的另一个应用是，系统中的实体可以推断
- en: if something has expired, for example, a timestamped security token can immediately
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些东西已经过期，比如一个带有时间戳的安全令牌可以立即
- en: tell a node how much time has elapsed since its creation. The node can infer
    if it is valid anymore or not and not something that occurred in the distant past,
    making this token
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉一个节点它的创建以来经过了多少时间。节点可以推断它是否仍然有效，还是已经是过去发生的事情，使得这个令牌
- en: no longer applicable and expired.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 不再适用且已经过期。
- en: In replication protocols, clock synchronization also plays a crucial role. If
    nodes
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制协议中，时钟同步也起着至关重要的作用。如果节点
- en: don’t have clocks synchronized, that can lead to inconsistency because every
    node will
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点没有时钟同步，就会导致不一致，因为每个节点都会
- en: have a different view of the order of events.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 有对事件顺序的不同看法。
- en: If the time is not synchronized among nodes, the system cannot establish a global
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点之间的时间不同步，系统就无法建立一个全局的
- en: notion of time and history. It is usually possible in practical systems using
    an NTP
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 时间和历史的概念。在实际系统中通常可以使用NTP
- en: protocol. We discussed this in Chapt[er 2](https://doi.org/10.1007/978-1-4842-8179-6_2)
    before in the context of time and order in distributed systems.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。在第[2章](https://doi.org/10.1007/978-1-4842-8179-6_2)中，我们在分布式系统中的时间和顺序的环境中讨论过这个问题。
- en: '343'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '343'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代协议
- en: So far, we have established that synchronized time is indeed a valuable construct
    in
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确立了同步的时间的确是在
- en: distributed systems for performance gains. In other words, if we can somehow
    replace
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能而采用分布式系统。换句话说，如果我们可以以某种方式取代
- en: communication with local computation, then we can gain tremendous efficiency.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本地计算进行通信，那我们就可以获得巨大的效率。
- en: Also, synchrony and time together solve consensus easily. Safety and liveness,
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，同步和时间可以轻松解决共识问题。安全性和活性性，
- en: the two fundamental requirements, are easy to implement with a trusted clock
    and
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个基本要求是通过一个可信的时钟和容易实现的
- en: synchronous network. However, networks are empirically asynchronous. We also
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 同步网络。但是，网络是经验性的异步的。我们还介绍了
- en: know that a trusted synchronized clock in distributed networks is difficult
    to maintain.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在分布式网络中维护一个可信的同步时钟是困难的。
- en: Blockchains and distributed systems are characterized by no clocks, which make
    them
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链和分布式系统的特点是没有时钟，这使它们
- en: slow due to inherent asynchrony and the need for complex message passing for
    ordering
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于固有的异步性和需要复杂的消息传递来排序
- en: of events and agreement.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和协议的一致性。
- en: On the other hand, a reliable, trusted clock makes network synchronization much
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个可靠、信任的时钟可以使网络同步得多
- en: simpler and quicker, which leads to very fast networks. Solana’s PoH is a solution
    where
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单，更快速，从而导致非常快速的网络。Solana的PoH是一个解决方案，其中
- en: the system can keep time reliably between nontrusting computers. In short, PoH
    enables
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可以在不信任的计算机之间可靠地保持时间。简而言之，PoH使
- en: clocks in clockless blockchains.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的时钟。
- en: Solana’s PoH is a way to establish the history and provide that global notion
    of
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: Solana的PoH是建立历史和提供全球概念的一种方法
- en: synchronized time among nodes in a distributed network. The key innovation here
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式网络中节点之间同步的关键创新在于此处
- en: is that it does not use any external source of time and synchronize nodes using
    that,
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 是它不使用任何外部时间来源并使用该时间同步节点，
- en: for example, via an NTP protocol; instead, it uses a cryptographic proof to
    show that
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过NTP协议；相反，它使用密码证明来显示
- en: some time has passed, and other nodes directly accept this history of events
    due
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 已经过一些时间，其他节点由于
- en: to cryptographic guarantees. So instead of relying on a source of global time,
    this
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码保证。所以，它不依赖于全球时间的来源，这
- en: mechanism is built into validators that generate a sequence of events with a
    proof when
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 机制内置于生成具有证明的事件序列的验证者
- en: an event has occurred. The following describes how it works.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 事件已发生。以下描述了它的工作原理。
- en: In a blockchain network, the right of adding a new block is won after solving
    a
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链网络中，解密获得添加新块的权利是在解决了之后赢得的
- en: puzzle, that is, PoW, which takes a long time. Although this mechanism is secure
    and
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 谜题，即PoW，需要很长时间。尽管这种机制是安全的，并且
- en: thwarts Sybil attacks (as we saw in Chapter [5](https://doi.org/10.1007/978-1-4842-8179-6_5)),
    it is slow. If BFT-style consensus is used, the leader validator that proposes
    a block only gets to commit after at least two
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止了Sybil攻击（正如我们在[第5章](https://doi.org/10.1007/978-1-4842-8179-6_5)中看到的那样），它很慢。如果使用BFT式共识，提出区块的领先验证者只有在至少两名
- en: sequential phases, which is also time-consuming even under a normal environment.
    In
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序阶段，即使在正常环境下也是耗时的。在
- en: case of failures, it can ever further slow down with new leader selection (election)
    and
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障情况下，它可能随着新的领导者选择（选举）而变得更加缓慢。
- en: view changes. What if somehow there is a deterministic leader election algorithm
    that
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改。如果以某种方式有一种确定性的领导者选举算法
- en: can select leaders in quick successions, and each leader quickly proposes, and
    then the
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 可以快速连续地选择领导者，每个领导者快速提出，然后
- en: algorithm moves to the next leader and so on? All this without going through
    complex
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 算法移向下一位领导者，依此类推？所有这些无需经过复杂
- en: leader election, acknowledgment from other nodes, and running multiple phases
    to
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者选举，其他节点的确认以及运行多个阶段以及运行多个阶段
- en: reach consensus. The problem here is that it’s quick to create a deterministic
    algorithm
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 达成共识。这里的问题是很快就能创建一个确定性算法
- en: that can select the next leader, but how do I ensure that what they propose
    is correct and that selected leaders are not malicious and will not censor transactions
    or exhibit other malicious behaviors?
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择下一个领导者，但是我如何确保他们提出的是正确的，选择的领导者不是恶意的，不会审查交易或表现出其他恶意行为？
- en: '344'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '344'
- en: '![](index-359_1.png)'
  id: totrans-1280
  prefs: []
  type: TYPE_IMG
  zh: '![](index-359_1.png)'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章区块链时代的协议
- en: This is where PoH comes in. In Solana, one leader at a time processes transactions
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是PoH的作用。在Solana中，一次只有一个领导者处理交易
- en: and updates the state. Other validators read the state and send votes to the
    leader
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 并更新状态。其他验证者读取状态并向领导者发送投票
- en: to confirm them. This activity is split into very short successive sessions
    where one
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 来确认它们。这个活动被分成非常短的连续会话，其中一个
- en: leader after another performs this. It can be thought of as if the ledger is
    split into
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接一个地执行领导者。可以将分类账分为
- en: small intervals. These small intervals are of 400ms each. The leader rotation
    schedule
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 小间隔。这些小间隔每次为400ms。领导轮换时间表
- en: is predetermined and deterministic based on several factors such as the stake
    and
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 是基于几个因素如股份和
- en: behavior of previous transactions. But how can we ensure that the leader rotation
    is done at the right time and does not skip the leader’s turn?
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 先前交易的行为。但我们如何确保领导者轮换是在正确的时间进行并且不会跳过领导者的轮换？
- en: In PoH, the passage of time is proven by creating a sequence of these hashes,
    as
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PoH 中，时间的流逝是通过创建这些哈希的序列来证明的，就像
- en: shown in Figure [8-3](#p359).
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [8-3](#p359) 中所示。
- en: '***Figure 8-3\.** Solana proof of history sequence*'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 8-3\.** Solana 历史证明序列*'
- en: In Figur[e 8-3, a s](#p359)equence of hash operations is shown. The genesis
    input (shown at the left in the diagram) is first provided to the hash function.
    In the next iteration, the output of the previous hash function is used as an
    input to the hash function, and
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[8-3](#p359)中，显示了一系列哈希操作。起源输入（在图表左侧显示）首先提供给哈希函数。在下一次迭代中，上一个哈希函数的输出被用作哈希函数的输入，并
- en: this process continues indefinitely. This sequence is generated using the SHA-256
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会无限地进行下去。这个序列是使用 SHA-256 生成的
- en: function on a single core. This process cannot parallelize it because the output
    of the
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 单核心上的函数。这个过程不能并行化，因为输出
- en: previous hash function can only be known if and only if the hash function has
    processed
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的哈希函数只有在哈希函数已经处理了
- en: the previous input. It is assumed that the functions are cryptographic hash
    functions
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的输入。假设这些函数是密码哈希函数
- en: that are preimage resistant. Therefore, this is a purely sequential function.
    However,
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 具有预像抵抗能力。因此，这是一个纯粹的顺序函数。但是，
- en: this sequence can be verified in parallel using multicore GPUs. As all the inputs
    and
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列可以使用多核 GPU 并行验证。因为所有的输入和
- en: outputs are available, it becomes just a matter of verifying each output, which
    GPUs
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可用后，只需要验证每个输出，GPUs
- en: can do in parallel. This property makes this sequence a verifiable delay function
    (VDF)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 可以并行进行。这个特性使得这个序列成为可验证的延迟函数（VDF）
- en: because the time taken (i.e., delay) in generating the hash sequence can be
    verified
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所花费的时间（即延迟）在生成哈希序列中可以被验证
- en: using quick parallel verification. However, there is some debate between cryptographic
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速并行验证。然而，密码学之间存在一些争议
- en: VDFs introduced by researchers at Stanford and hardware VDF introduced by Solana
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员在斯坦福大学引入的 VDF 和 Solana 引入的硬件 VDF
- en: researchers. See the reference in the bibliography.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员。参见参考文献。
- en: '345'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '345'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 区块链年代协议
- en: We can then sample this sequence at regular intervals to provide a notion of
    the
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以定期取样这个序列，提供时间流逝的概念
- en: passage of time. This is so because hash generation takes some CPU time (roughly
    1.75
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 时间的流逝。这是因为哈希生成需要一些 CPU 时间（大约 1.75
- en: cycles for SHA-256 instruction on an Intel or AMD CPU), and this process is
    purely
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256 指令周期），而且这个过程纯粹
- en: sequential; we can infer from looking at this sequence, that since the first
    hash is
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序；我们可以从这个序列看出来，自第一个哈希以来，
- en: generated, up to a later hash in the sequence, some time has passed. If we can
    also add
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 生成，在序列的后续哈希中，一些时间已经过去。如果我们还可以添加
- en: some data with the input hash to the hash function, then we can also deduce
    that this
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据与哈希函数的输入一起提供给哈希函数，然后我们也可以推断出这样
- en: data must have existed before the next hash and after the previous hash. This
    sequence
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 数据必须在下一个哈希之前和上一个哈希之后存在。这个序列
- en: of hashes thus becomes a proof of history, proving cryptographically that some
    event,
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的哈希就成为历史的证明，以密码学方式证明某个事件，
- en: let’s say event e, occurred before event f and after event d.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 假设事件 e 比事件 f 发生在事件 d 之前和之后。
- en: It is a sequential process that runs SHA-256 repeatedly and continuously, using
    its
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个顺序过程，使用其连续地重复运行 SHA-256
- en: previous output as its input. It periodically records a counter for each output
    sample,
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的输出作为其输入。它定期记录每个输出样本的计数器，
- en: for example, every one second, and current state (hash output), which acts like
    clock
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每秒钟一次，并且当前状态（哈希输出），作为时钟
- en: ticks. Looking at this structure of sampled hashes at regular intervals, we
    can infer that some time has passed. It is impossible to parallelize because the
    previous output is the
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: ticks。通过定期间隔取样的哈希结构，我们可以推断一定的时间已经过去。它不能并行化，因为先前的输出是
- en: input for the next iteration. For example, we can say time has passed between
    counter
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代之间的输入。例如，我们可以说在计数器之间已经经过了一段时间
- en: 1 and counter N (Figure [8-3), wher](#p359)e time is the SHA-256 counter. We
    can approximate real time from this count. We can also associate some data, which
    we can append to
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 1 和计数器 N（图[8-3](#p359)），时间就是 SHA-256 计数器。我们可以从这个计数中近似得到真实时间。我们还可以关联一些数据，可以附加到
- en: the input of the hash function; once hashed, we can be sure that data must have
    existed
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的输入；一旦经过哈希，我们就可以确定数据必须存在
- en: before the hash is generated. This structure can only be generated in sequence;
    however,
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成哈希之前。这种结构只能按顺序生成；然而，
- en: we can verify it in parallel. For example, if 4000 samples took 40 seconds to
    produce, it will take only 1 second to verify the entire data structure with a
    4000 core GPU.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以并行验证它。例如，如果 4000 个样本花费了 40 秒来生产，那么用4000个核心 GPU 只需要 1 秒就可以验证整个数据结构。
- en: The key idea is that PoH transactional throughput is separated from consensus,
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是 PoH 事务吞吐量与共识分离，
- en: which is key to scaling. Note that the order of events generated, that is, the
    sequence, is not globally unique. Therefore, a consensus mechanism is needed to
    ascertain the true
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 还有关键的扩展性。请注意，生成的事件顺序并不是全局唯一的。因此，需要共识机制来确定正确的
- en: chain, as anyone can generate an alternate history.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 链，因为任何人都可以生成一个备用历史。
- en: Proof of history is a cryptographically proven way of saying that time has elapsed.
    It
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 历史证明是密码学上已经证实时间已经流逝的方式。它
- en: can be seen as an application-specific verifiable delay function. It encodes
    the passage
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被视为特定应用的可验证延迟函数。它编码了经过
- en: of time as data using SHA-256 hashing to hash the incoming events and transactions.
    It
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SHA-256 哈希化事件和交易数据来将时间作为数据化处理。它
- en: produces a unique hash and count of each event, which produces a verifiable
    ordering of
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 生成每个事件的唯一哈希值和数量，这样就能够得到可验证的事件排序
- en: events as a function of time. This means that time and ordering of events can
    be agreed
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 事件作为时间的函数。这意味着时间和事件的顺序可以得到一致
- en: without waiting to hear from other nodes – in other words, no weak subjectivity
    where
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 不等待来自其他节点的回复——换句话说，没有弱主观性，其中
- en: nodes must rely on other nodes to determine the current state of the system.
    This results in high throughput, because the information that is usually required
    to be provided by
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 节点必须依赖其他节点来确定系统的当前状态。这导致了高吞吐量，因为通常需要提供的信息
- en: other nodes is already there in the sequence generated by the PoH mechanism
    and is
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 其他节点已经在 PoH 机制生成的序列中，而且
- en: cryptographically verifiable, ensuring integrity. This means that a global order
    of events 346
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 经过加密验证，确保完整性。这意味着全局事件的顺序 346
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 区块链时代协议
- en: can be enforced without going through a communication-wise complex agreement
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不经过复杂的通信协议就能够执行。
- en: protocol or trusting an external source of time for clock synchronization. In
    summary,
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 协议或信任时钟同步的外部时间源。总的来说，
- en: instead of trusting the timestamp, proof of history allows to create a historical
    record
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是依赖时间戳，历史证明允许创建一个历史记录
- en: proving that an event e occurred at a particular point in time t, before another
    event f
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 证明事件 e 发生在时间点 t 之前
- en: and after an event d.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在事件 d 之后。
- en: Using PoH, leadership can be switched without needing to communicate with other
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PoH，领导权可以在无需与其他节点通信的情况下转换。
- en: nodes, which results in increased block production frequency. PoH results in
    high node
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，这导致增加了区块的产生频率。PoH 导致节点高
- en: scalability and low communication complexity as compared to BFT-style protocols
    with
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 与 BFT 风格协议相比，具有可扩展性和低通信复杂性
- en: high communication complexity and limited node capacity.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 通信复杂度高，节点容量有限。
- en: It provides global read consistency and cryptographically verifiable passage
    of time
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供全局的读取一致性和经过加密验证的时间
- en: between two events. With PoH, nodes can trust the ordering and timing of events,
    even
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个事件之间达成一致。使用 PoH，节点可以信任事件的顺序和时间
- en: before the consensus stage is reached. In other words, it’s a clock before consensus
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到共识阶段之前。换句话说，它是一个在共识之前的时钟。
- en: approach. Consensus then simply works by voting on different branches where
    nodes
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。然后共识只需要在不同的分支上进行投票，节点
- en: vote on a branch that they believe is the main chain. Over time, by keep voting
    on the
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 投票支持他们认为是主链的分支。随着时间的推移，通过继续投票支持
- en: chain they first voted on, and by voting on any other branch, they earn rewards
    and
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 他们首先投票的链，并通过投票任何其他分支，他们赚取奖励并
- en: eventually the other branches orphan.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 最终其他分支就会孤立。
- en: TowerBFT is a variant of PBFT. It is basically a fork selection and voting algorithm.
    It
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: TowerBFT 是 PBFT 的一个变种。基本上，它是一个分叉选择和投票算法。它
- en: is used to vote on the chains produced by PoH to select the true canonical chain.
    It is less communication-wise complex because PoH has already provided an order,
    and now the
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 用于投票 PoH 生成的链以选择真实的规范链。这样做在通信方面更简单，因为 PoH 已经提供了一个顺序，现在
- en: decision is only required on the choice of canonical chain. PoH provides timing
    of events before consensus initiates, and TowerBFT is then used for voting on
    the canonical chain.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在选择规范链时才需要做出决定。PoH提供一致性启动前的事件时间，然后TowerBFT用于对规范链进行投票。
- en: TowerBFT is BFT in the sense that once two-thirds of validators have voted on
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: TowerBFT是BFT的一种形式，一经2/3的验证者都投票
- en: a chain (hash), then it cannot be rolled back. Validators vote on a PoH hash
    for two
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 链（哈希），则无法回滚。验证者对一个PoH哈希进行投票
- en: 'reasons: first, the ledger is valid up until that hash, that is, a point in
    time, and, second, to support for a fork at a given height as many forks can exist
    at a given height.'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 原因：首先，分类账在那个哈希之前是有效的，也就是说，在某个时间点，其次，支持在给定高度出现分叉，因为在给定高度可以存在许多分叉。
- en: Furthermore, PoS in Solana is used for economics and governance to control
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Solana中的PoS用于经济和治理来控制
- en: slashing, inflation, supply, and penalties.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 减少、通货膨胀、供应和惩罚。
- en: '**Tendermint**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tendermint**'
- en: Tendermint is inspired by the DLS protocol that we covered in Chapter [6](https://doi.org/10.1007/978-1-4842-8179-6_6)
    and was originally introduced in the DLS paper. It can be seen as a variant of
    PBFT too with
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint受到我们在第[6](https://doi.org/10.1007/978-1-4842-8179-6_6)章中 cover 的DLS协议的启发，并最初在DLS论文中引入。它也可以被视为PBFT的一种变体，具有
- en: similarities in the phases.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段中的相似之处。
- en: '347'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '347'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链 年代 协议
- en: The Tendermint protocol works in rounds. In each round, an elected leader proposes
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint协议按轮次运行。在每个轮次中，选定的领导者提出
- en: the next block. In Tendermint, the view change process is part of the normal
    operation.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个块。在Tendermint中，视图更改过程是正常操作的一部分。
- en: This concept is different from PBFT, where a view change only occurs in the
    event of a
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 这与PBFT不同的地方在于，只有在出现
- en: suspected faulty leader. Tendermint works similarly to PBFT, where three phases
    are
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑的有故障领导者。Tendermint的工作方式类似于PBFT，其中有三个阶段
- en: required to achieve consensus. A key innovation in Tendermint is the design
    of a new
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 要达成共识所需。Tendermint中的一个关键创新是设计了一个新的
- en: termination mechanism. Unlike other PBFT-like protocols, Tendermint has developed
    a
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 终止机制。与其他类PBFT的协议不同，Tendermint开发出了一个
- en: more straightforward mechanism like a PBFT-style normal operation. Instead of
    having
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接的机制，如类PBFT的正常操作。而不是
- en: two subprotocols for normal mode and view change mode (recovery in case of a
    faulty
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 正常模式和视图更改模式（在节点出现故障时进行恢复
- en: leader), Tendermint terminates without additional communication costs.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者），Tendermint在无需额外通信成本的情况下终止。
- en: Tendermint works under some assumptions about the operating environment,
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint在操作环境方面作出了一些假设
- en: 'which we describe next:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来描述的内容：
- en: '**Processes:** A process is a participant on the network. Processes'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程：** 进程是网络上的参与者。进程'
- en: are expected to be honest, but they can turn faulty. Each process
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 预期是诚实的，但也可能变得有故障。每个进程
- en: has a voting power that serves as a confirmation to the leader.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 具有投票权，可以作为领导者的确认。
- en: Processes can connect loosely or with their immediate subset of
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以松散连接或与其直接子集
- en: processes/nodes. They are not necessarily connected directly.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 进程/节点。它们不一定直接相連。
- en: Processes have a local timer that they use to measure timeout.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 进程具有一个本地定时器，用于测量超时时间。
- en: '**Network model:** The network is a message-passing network'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络模型：** 网络是一个消息传递网络'
- en: where a gossip protocol is used for communication between
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个消息传递协议用于进程之间的通信
- en: processes. The standard BFT assumption of *n* ≥ 3 *f* + 1 applies
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。标准的BFT假设*n*≥3*f*+1适用于
- en: here, which means that the protocol operates correctly only if the
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这意味着协议只有在
- en: number of nodes in the network stays more than 3F, where F is
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的节点数大于3F时，Tendermint需要保持更多的节点，其中F是
- en: the number of faulty nodes and N represents the total number of
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题节点的数量，N代表总节点数
- en: nodes in the network. In practice, this means that there must be at
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的节点。实际上，这意味着网络中必须至少存在
- en: least four nodes in a network to tolerate Byzantine faults.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 四个节点来容忍拜占庭故障。
- en: '**Timing assumptions:** Tendermint assumes a partially'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间假设：** Tendermint假设部分'
- en: synchronous network. There is an unknown bound on the
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 同步网络。对于
- en: communication delay, but it only applies after an unknown
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 通信延迟，但仅适用于未知
- en: instance of time called global stabilization time or GST.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全局稳定时间点。
- en: '**Security and cryptography:** The security assumption in the'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全和密码学：** 在'
- en: system is that the public key cryptography used is secure. Also, the
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用的公钥加密是安全的。此外，
- en: impersonation or spoofing of identities is not possible. All messages
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 冒充或伪造身份都是不可能的。所有消息
- en: on the network are authenticated and verified via digital signatures.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上经由数字签名进行认证和验证。
- en: The protocol ignores any messages with an invalid digital signature.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议忽略任何带有无效数字签名的消息。
- en: '348'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '348'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代协议
- en: '**State machine replication:** SMR is used to achieve replication'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机复制:** SMR 用于实现复制'
- en: among the nodes. SMR ensures that all processes on the network
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点之间。SMR 确保网络上的所有进程
- en: receive and process the same sequence of requests. In addition,
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 接收并处理相同的请求序列。此外，
- en: the agreement and order provide that the sequence in which
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 协议中的协议确保顺序以及
- en: the nodes have received requests is the same on all nodes. Both
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 节点收到的请求在所有节点上是相同的。两者
- en: requirements ensure the total order in the system. The protocol
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 要求确保系统的总排序。该协议
- en: only accepts valid transactions.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 只接受有效的交易。
- en: 'Tendermint solves consensus by fulfilling the properties listed as follows:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 通过满足以下列出的属性来解决共识问题：
- en: '• **Agreement**: No two correct processes decide on different values.'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: • **协议：** 没有两个正确的进程可以决定不同的数值。
- en: '• **Termination**: All correct processes eventually decide on a value.'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: • **终止：** 所有正确的进程最终会决定一个数值。
- en: '• **Validity**: A decided-upon value is valid if it satisfies an application'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: • **有效性：** 如果决定的数值满足应用程序
- en: specific predefined predicate denoted valid( ).
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 特定预定义的断言表示为 valid( )。
- en: State transition at processes in Tendermint depends on the messages received
    and
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 中进程的状态转换取决于接收到的消息，并且
- en: timeouts. The timeout mechanism guarantees liveness and prevents indefinite
    waiting.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 超时。超时机制保证活性并防止无限等待。
- en: Here, the assumption is that eventually, after some period of asynchrony, there
    will be a synchronous communication period during which all processes can communicate
    in a
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，假设最终，在一段异步期之后，会有一个同步通信期，在此期间所有的进程都可以以一种
- en: timely fashion, ensuring that processes eventually decide on a value.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 及时地确保进程最终决定一个数值。
- en: 'A Tendermint protocol has three types of messages: proposal, pre-vote, and
    pre-'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 协议有三种类型的消息：提议、预投票和预-
- en: commit. These messages can be viewed as equivalent to the PBFT protocol’s PRE-
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 提交。可以将这些消息视为等同于 PBFT 协议的 PRE-
- en: 'PREPARE, PREPARE, and COMMIT messages:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 准备、准备和提交消息：
- en: • **Proposal:** This message is used by the leader of the current round to
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: • **提议：** 此消息由当前轮次的领导者使用
- en: propose a value or block.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 提议一个数值或区块。
- en: • **Pre-vote:** This message is used to vote on a proposed value.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: • **预投票：** 此消息用于对提议的数值进行投票。
- en: • **Pre-commit:** This message is also used to vote on a proposed value.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: • **预提交：** 此消息也用于对提议的数值进行投票。
- en: Only the proposal message contains the original value. The other two messages,
    pre-
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 只有提议消息包含原始数值。另外两种消息，预-
- en: vote and pre-commit, use a value identifier representing the initially proposed
    value.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 投票和预提交，使用表示最初提议的数值的数值标识符。
- en: 'There are three timeouts in the protocol, corresponding to each message type:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 协议中有三种超时，对应每种消息类型：
- en: • Timeout-propose
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: • 超时-提议
- en: • Timeout-prevote
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: • 超时-预投票
- en: • Timeout-precommit
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: • 超时-预提交
- en: '349'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '349'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章 区块链时代协议
- en: These timeouts prevent the algorithm from waiting indefinitely for certain
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 这些超时防止算法无限等待某些
- en: conditions to be met. They also ensure that processes make progress through
    the rounds.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 需要满足条件。它们还确保进程通过回合取得进展。
- en: A mechanism to increase timeout with every new round assures that after reaching
    GST,
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮结束后增加超时机制可以确保在达到全局稳定状态后，
- en: the communication between correct processes eventually becomes reliable, nodes
    can
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 正确进程之间的通信最终变得可靠，节点可以
- en: reach a decision, and protocol terminates.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 达成决定，并且协议终止。
- en: 'All processes maintain some necessary variables in the protocol:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 所有进程在协议中维护一些必要的变量：
- en: • **Step:** This variable holds the current state of the Tendermint state
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: • **步骤：** 此变量保存 Tendermint 状态的当前状态
- en: machine in the current round.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 当前轮次中的机器。
- en: • **lockedValue:** This variable stores the most recent value (concerning
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: • **lockedValue：** 此变量存储最近的数值（涉及
- en: the round number) for which a pre-commit message has been sent.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 发送预提交消息的回合数)。
- en: • **lockedRound:** This variable holds information about the last round
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: • **锁定轮次：** 此变量保存了关于上次轮次的信息
- en: where the process sent a non-nil pre-commit message which implies
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器能做出决定之前计时器到期，处理器
- en: that this is the round where a possible decision value has been
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，可能已经做出决策的轮次
- en: locked. This means that if a proposal message and corresponding
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 被锁定。这意味着如果有一个提议消息和相应的
- en: 2F + 1 messages have been received for a value in a round, then, due
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 2F + 1个消息已经收到一个轮次的值，然后，由于
- en: to the reason that 2F + 1 pre-votes have already been accepted for this
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 有2F + 1个先前-vote（pre-votes）为该决定
- en: value, this is a possible decision value.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 值，这是一个可能的决策值。
- en: • **validValue:** The role of the validValue variable is to store the most
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: • **validValue：** validValue变量的作用是存储最
- en: recent possible decision value.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的可能决策值。
- en: • **validRound:** The validRound variable is the last round in which
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: • **有效轮次：** 有效轮次变量是上一轮，在这一轮发生了
- en: validValue was updated.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的有效值。
- en: • **Height:** Stores the current consensus instance.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: • **高度：** 存储当前共识实例。
- en: • Current round number
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: • 当前轮次编号
- en: • An array of decisions
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个决策数组
- en: 'Tendermint proceeds in rounds. Each round contains three phases: propose,'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint按轮次进行。每一轮包含三个阶段：提出、
- en: 'pre-vote, pre-commit. The algorithm works as follows:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: pre-vote，pre-commit。该算法的工作方式如下：
- en: • Every round starts with a proposal value proposed by a proposer.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: • 每一轮都以由提议者提出的提议值开始。
- en: The proposer proposes a new value at the start of the first round for
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 提议人在第一轮开始时提出一个新值
- en: each height.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 每个高度（each height）。
- en: '350'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '350'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 8区块链年代协议（BloCkChain age protoCols）
- en: • Any subsequent rounds will only have a proposer proposing a
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: • 任何后续的轮次只有一个提议者提出一个
- en: new value if there is no valid value already present, that is, null.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有已经存在的有效值，即null的话，提议一个新值。
- en: Otherwise, the validValue, the possible decision value, is proposed,
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，提出有效值，即可能的决策值
- en: already locked from a previous round. The proposal message also
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一轮已经锁定了。提议消息也
- en: includes a value denoting the last valid round in which there was a
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 包括指示上一次发生的有效轮次的值
- en: valid value updated.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的有效值。
- en: • A correct process accepts the proposal only if
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个正确的进程只有在
- en: • The proposed value is valid.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: • 提议的值是有效的。
- en: • The process has not locked on a value.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: • 进程未锁定某个值。
- en: • Or the process has a value locked.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: • 或者该进程被锁定
- en: • The correct process accepts the proposal and sends a pre-vote
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: • 正确的进程接受提议并发送一个pre-vote
- en: message if the preceding conditions meet.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 消息（message）是否满足前述条件。
- en: • If the conditions do not meet, the process will send a pre-vote
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果条件不满足，进程将发送一个pre-vote
- en: message with a nil value.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 带有空值的消息。
- en: • A timeout mechanism associated with the proposal phase triggers
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: • 与提议阶段关联的超时机制触发
- en: timeout if a process has not sent a pre-vote message in the current
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 超时，如果一个进程在当前
- en: round or the timer expires in the proposal stage.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 轮次或计时器在提议阶段到期。
- en: • If a correct process receives a proposal message with a valid value
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果一个正确的进程收到一个带有有效值的提议消息
- en: and 2F + 1 pre-vote messages, it sends the pre-commit message.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 和2F + 1个pre-vote消息，它发送pre-commit消息。
- en: • Otherwise, it sends out a nil pre-commit.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: • 否则，它发送一个空的pre-commit。
- en: • A timeout mechanism associated with the pre-commit will initialize
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: • 与pre-commit相关联的超时机制将会初始化
- en: if the associated timer expires or if the process has not sent a pre-
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关联的计时器到期，或者进程没有发送一个pre-
- en: commit message after receiving a proposal message and 2F + 1 pre-
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到提议消息和2F + 1的pre-
- en: commit messages.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 提交消息。
- en: • A correct process decides on a value if it has received the proposal
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果正确的进程收到提议
- en: message in some round and 2F + 1 pre-commit messages for the ID
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 某一轮和2F + 1的预提交消息为ID
- en: of the proposed value.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提议值的消息。
- en: • This step also has an associated timeout mechanism, ensuring that
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: • 这个步骤还有一个关联的超时机制，确保
- en: the processor does not wait indefinitely to receive 2F + 1 messages.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不会无限期地等待接收2F + 1个消息。
- en: If the timer expires before the processor can decide, the processor
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计时器在处理器决定之前到期，处理器
- en: starts the next round.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 开始下一轮。
- en: '351'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '351'
- en: '![](index-366_1.png)'
  id: totrans-1497
  prefs: []
  type: TYPE_IMG
  zh: '![](index-366_1.png)'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 8区块链年代协议（BloCkChain age protoCols）
- en: • When a processor eventually decides, it triggers the next consensus
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: • 当处理器最终做出决定时，会触发下一个共识
- en: instance for the following block proposal, and the entire cycle of a
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下一个块提议的实例，整个周期的
- en: proposal, pre-vote, and pre-commit starts again.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 提议、pre-vote和pre-commit再次开始。
- en: The protocol can be simply depicted as a recurring sequence of proposal ➤ pre-vote
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议可以简单地描述为一个不断重复的提案 ➤ 预投票的序列。
- en: ➤ pre-commit, and after every commit, a new height is achieved and a new round
    starts,
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: ➤ 预提交，每次提交后都将达到新的高度并开始新的轮次，
- en: as shown in Figur[e 8-4\.](#p366)
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[8-4\.](#p366)所示
- en: '***Figure 8-4\.** Tendermint flow – single run*'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 8-4\.** Tendermint 流程 - 单次运行*'
- en: '352'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '352'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 区块链时代协议
- en: Tendermint introduced a new termination mechanism. There are two variables,
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 引入了一种新的终止机制。有两个变量，
- en: namely, validValue and validRound, used by the proposal message. Both are updated
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 即 validValue 和 validRound，由提案消息使用。这两者被更新
- en: by a correct process when receiving a valid proposal message and subsequent
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确的进程在接收到有效提案消息和随后
- en: corresponding 2f + 1 pre-vote messages.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 2f + 1 预投票消息。
- en: This termination process benefits from the gossip protocol and synchrony
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 这个终止过程受益于 gossip 协议和同步性
- en: assumptions. For example, suppose a correct process has locked a value in a
    round.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正确的进程锁定了某轮的值。
- en: Then all other correct processes will update their validValue and validRound
    variables
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 这样所有其他正确的进程将更新它们的有效值和有效轮次变量
- en: with the locked values by the end of the very round during which they were locked.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 到达它们被锁定的那一轮结束时，所有其他正确的进程将更新它们的有效值和有效轮次变量
- en: The fundamental presumption is that a gossip protocol will propagate them to
    other
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 基本假设是 gossip 协议会把它们传播给其他
- en: nodes within the same round once a correct processor has locked these values.
    Each
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个轮次内，一旦正确的处理器锁定了这些值，节点们会进行同步。每个
- en: processor will know the locked value and round, that is, the valid values. Now,
    when the
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器将知道被锁定的值和轮次，即有效值。现在，当新的提案消息
- en: next proposal is made, the same locked values will be picked up by the proposer,
    which
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个提案被提出时，同样的被锁定的值将被提议者选取，这样
- en: has already been locked due to the valid proposal and corresponding 2 *f* +
    1 pre-vote messages. This way, it can be ensured that the value that processes
    eventually decide
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有了有效的提案和对应的 2 *f* + 1 预投票消息，所以已经被锁定。这样就可以确保进程最终决定的值
- en: upon is acceptable as specified by the validity condition.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 根据有效条件指定，上述是可以接受的。
- en: This completes our discussion on the Tendermint protocol. Next, we explore HotStuff,
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 Tendermint 协议的讨论。接下来，我们将探讨 HotStuff，
- en: which improves on several limitations in previous PBFT and its variant protocols.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 这在改善以前的 PBFT 及其变体协议中存在的一些限制方面有所改进。
- en: '**HotStuff**'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '**HotStuff**'
- en: HotStuff is a BFT protocol for state machine replication. Several innovations
    make
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: HotStuff 是用于状态机复制的 BFT 协议。几项创新
- en: it a better protocol than traditional PBFT. However, like PBFT, it works under
    partial
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 它比传统的 PBFT 协议更好。但是，与 PBFT 一样，它在部分情况下有效
- en: synchrony in a message-passing network with minimum *n* = 3 *f* + 1 and relies
    on a leader-based primary backup approach. It utilizes reliable and authenticated
    communication
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 最小 *n* = 3 *f* + 1，并依赖于基于领衔的主备方法的消息传递网络中的同步性。它利用可靠和经过验证的通信
- en: links. HotStuff makes use of threshold signatures where all nodes use a single
    public key, but each replica uses a unique private key. The use of threshold signatures
    results in
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 链接。HotStuff 使用阈值签名，其中所有节点使用同一个公钥，但每个副本使用唯一的私钥。 使用阈值签名可以减少
- en: reduced communication complexity.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 通信复杂性。
- en: HotStuff introduced some innovations which we introduce as follows.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: HotStuff 引入了一些创新，我们将在下文中介绍。
- en: '**Linear View Change**'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性视图更改**'
- en: A view change in a HotStuff protocol requires only *O*( *n*) messages. It is
    part of the normal run instead of a separate subprotocol. In a worst-case scenario
    where leaders fail successively, the communication cost increases to *O*( *n*
    2), quadratic. Instead of a stable leader like PBFT, a leader rotation in HotStuff
    occurs every three rounds even if the
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: HotStuff 协议中的视图更改仅需要 *O*( *n*) 个消息。这是正常运行的一部分，而不是一个单独的子协议。在最坏情况下，即使领导者连续失败，通信成本也会增加到
    *O*( *n* 2) ，是二次的。与 PBFT 一样拥有稳定的领导者不同，HotStuff 中的领导者每三轮进行一次轮换，即使
- en: leader doesn’t fail.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者不会失败。
- en: '353'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '353'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章 区块链时代协议
- en: In simpler words, quadratic complexity means that the algorithm’s performance
    is
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，二次复杂度意味着算法的性能是
- en: proportional to the squared size of the input.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入大小的平方成正比。
- en: In a linear view change, after GST, any honest selected leader sends only *O*(
    *n*) authenticators to drive a decision, including the case where a leader fails
    and a new
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性视图更改中，在GST之后，任何经过选择的诚实领导者仅发送 *O*( *n*) 的认证者来推动决策，包括领导者失败并且新的
- en: one is elected. So even in the worst case where leaders fail one after another,
    the
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 之一当选。因此，即使在领导者一个接一个地失败的最坏情况下，这个
- en: communication cost to reach consensus after GST is *O*( *n* 2).
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 在GST之后达成共识的通信成本为 *O*( *n* 2)。
- en: '**Optimistic Responsiveness**'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '**乐观的响应**'
- en: Optimistic responsiveness allows any correct leader after GST to only need the
    first *n* − *f* responses to ensure progress instead of waiting for *n* − *f*
    from every replica. This means that it operates at network speed instead of waiting
    unnecessarily for more messages
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观的响应允许在GST之后的任何正确的领导者只需第一个 *n* − *f* 的响应就能确保进展，而不是等待每个复本的 *n* − *f* 的消息。这意味着它能以网络速度运作，而不是不必要地等待更多的消息
- en: from other nodes and move to the next phase.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他节点中获得，并进入下一个阶段。
- en: '**Chain Quality**'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '**链质量**'
- en: This property provides fairness and liveness in the system by allowing frequent
    leader
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性通过允许频繁的领导者来提供系统中的公平性和活力
- en: rotation.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转。
- en: '**Hidden Lock**'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏锁**'
- en: It also solves the hidden lock problem. A “hidden lock” problem occurs when
    a leader
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 它还解决了隐藏锁问题。当领导者
- en: validator does not wait for the expiration time of a round. The highest lock
    may not
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者不需要等待一个轮次的过期时间。最高锁定值可能不存在
- en: get to the leader if we rely only on receiving *n* – *f* messages. The highest
    locked value may be held in another replica from which the leader did not wait
    to get a response,
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 只依靠接收 *n* – *f* 消息，就能到达领导者。最高锁定值可能由另一个未等待得到响应的复本持有，
- en: thus resulting in a situation where the leader is unaware of the highest locked
    value. If a leader then proposes a lower lock value and some other nodes already
    have a higher
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 因此导致了领导者不知道最高的锁定值。如果领导者提议了一个更低的锁定值，而其他一些节点已经有了更高的
- en: value locked, this can lead to liveness issues. The nodes will wait for a higher
    lock or the same lock reply, but the leader is unaware of the highest lock value
    and will keep sending a lower lock value, resulting in a race condition and liveness
    violation.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定值，这可能导致活力问题。节点将等待更高的锁定或相同的锁定回复，但领导者不知道最高的锁定值，并将继续发送一个更低的锁定值，导致比赛条件和活力违规。
- en: HotStuff has solved this problem by adding the precursor lock round before the
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: HotStuff通过在实现之前增加前锁轮来解决了这个问题
- en: actual lock round. The insight here is that if 2 *f* + 1 nodes accept the precursor
    lock, the leader will get a response from them and learn the highest locked value.
    So now the
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 实际锁轮次。这里的见解是，如果有2 *f* +1个节点接受前置锁定，领导者将从它们那里获得响应并学习最高锁定的值。因此现在
- en: leader doesn’t have to wait for *Δ* (delta – an upper bound on a message delivery
    delay) time and can learn the highest lock with *n* − *f* responses.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者不必等待 *Δ*（delta –消息传递延迟的上限）时间，就能通过 *n* − *f* 的响应学到最高锁定。
- en: '354'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '354'
- en: Chapter 8 BloCkChain age protoCols
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章BloCkChain age protoCols
- en: '**Pacemaker**'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '**起搏器**'
- en: HotStuff innovatively separates the safety and liveness mechanisms. Safety is
    ensured
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: HotStuff创新地分离了安全性和活力机制。安全性得到保证
- en: through voting and commit rules for participants in the network. On the other
    hand,
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 通过投票和网络中的参与者的提交规则。另一方面，
- en: liveness is the responsibility of a separate module, called pacemaker, which
    ensures a
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 活力性是一个独立模块的责任，称为起搏器，它确保了
- en: new, correct, and unique leader is elected. Furthermore, pacemaker guarantees
    progress
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 新的，正确的，唯一的领导者被选举。此外，起搏器保证进展
- en: after GST is reached. The first responsibility it has is to bring all honest
    replicas and a unique leader to a common height for a sufficiently long period.
    For synchronization,
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 在GST之后。它的第一个责任是在足够长的时间内将所有诚实的副本和一个唯一的领导者提升到同一高度。为了同步，
- en: replicas keep increasing their timeouts gradually until progress is made. As
    we assume a
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 复本逐渐增加其超时时间，直到取得进展为止。因为我们假设一个
- en: partially synchronous model, this mechanism is likely to work. Also, the leader
    election
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步模型，这种机制很可能会发挥作用。此外，领导者选举
- en: process is based on a simple rotating coordinator paradigm, where a specific
    schedule,
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 过程基于一个简单的轮换协调器范式，一个特定的时间表，
- en: usually round-robin, is followed by replicas to select a new leader. Pacemaker
    also
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 通常是轮询，由复本来选择一个新的领导者。起搏器也
- en: ensures that the leader chooses a proposal that replicas will accept.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 确保领导者选择复本将接受的提案。
- en: '**Better Participant Organization Topology**'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的参与者组织拓扑**'
- en: A PBFT protocol organizes nodes in a clique (mesh topology), resulting in a
    quadratic
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PBFT协议将节点组织成一个圈（网状拓扑），导致一个二次的...
