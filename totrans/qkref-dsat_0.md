![](img/image-vghl32yj.jpg)快速参考数据结构和计算机算法 By Raji Ramakrishnan Nair Divya Joseph Alen Joseph ![](img/image-kmg9gkor.jpg)2019 年第一版 版权所有 © BPB 出版社，印度 ISBN：978-93-88176-58-3 保留所有权利。未经出版商事先书面许可，不得以任何形式或任何方式存储本出版物的任何部分或复制本出版物。 责任限制和免责声明 本书的作者和出版商已尽力确保本书中描述的程序、程序和功能是正确的。但是，作者和出版商对这些程序或本书中包含的文档不做任何明示或暗示的担保。作者和出版商不对与提供、执行或使用这些程序、程序和功能有关的任何损害或后果承担责任。提到的产品名称仅用于识别目的，可能是其各自公司的商标。 书中提到的所有商标均承认为其各自所有者的财产。 分销商： BPB 出版社 安萨里路 20 号，达里亚甘杰，新德里-110002 电话：23254990/23254991 MICRO MEDIA 马亨德拉大道 150 号，首都电影院旁，V.T.（C.S.T.）站，孟买-400 001 电话：22078296/22078297 BPB BOOK CENTRE 旧拉杰帕特莱市场 376 号，德里-110006 电话：23861747 DECCAN AGENCIES 银行街 4-3-329 号，海得拉巴-500195 电话：24756967/24756400 由 Manish Jain 为 BPB 出版社出版，地址：新德里，达里亚甘杰，安萨里路 20 号，印度，由 Repro India Pvt Ltd 印刷 致力于 我的学生们…我的力量和我的弱点 “书是你手中的梦想。”— 尼尔·盖曼前言 《数据结构和计算机的快速参考》以非常简单易懂的方式编写。理论以逐步示例的方式描述得很好。本书完全理解每个理论主题，并在编程中易于实现。本书将帮助学生自学数据结构，并理解这些概念如何在程序中实现。本书包含大量图表，这将帮助学生有效地可视化概念。图表帮助学生理解涉及数据结构概念的程序如何在计算机系统内部实现。 算法包括以清晰的概念数据结构。通过图表解释每个算法，以使学生更清楚地了解概念。在书中提供了取样数据集，并提供了算法的逐步执行，以确保学生对所讨论的概念有深入的了解。 我们设计这本书是出于必要。目前，在这个领域可用的参考资料，仅关注特定领域。要研究特定主题，我们必须参考至少 3 本教科书。那真的很繁琐和耗时。一些教科书专注于编程部分，一些专注于算法，一些专注于使用图表进行说明。因为所有这些限制，我们想写一本书，可以在各个方面满足学生的需求。我们的书可以是某些人的手册，竞争性考试的快速参考，并且它肯定可以成为任何提供计算机科学课程的大学的教科书。 这本书对 B. Tech、B.E.、MCA、BCA、B.Sc.（计算机科学）等所有学生都有用。具有该领域基本知识的学生可以从本书的开头就理解概念。 我们认为我们的书是独一无二的。我们试图在这里连接过去

| 1. | 算法

&#124; 1.1 &#124; 介绍 &#124;

&#124; 1.2 &#124; 基本概念 - 数据结构和数据结构的类型

&#124; 1.2.1 &#124; 数据类型 &#124;

&#124;

&#124; 1.3 &#124; 算法性能分析

&#124; 1.3.1 &#124; 空间复杂度 &#124;

&#124; 1.3.2 &#124; 时间复杂度 &#124;

&#124;

&#124; 1.4 &#124; 多项式

&#124; 1.4.1 &#124; 介绍 &#124;

&#124; 1.4.2 &#124; 多项式的用途 &#124;

&#124; 1.4.3 &#124; 多项式加法 &#124;

&#124; 1.4.4 &#124; 多项式结构 &#124;

&#124;

&#124; 1.5 &#124; 多项式加法的数组实现 &#124;

&#124; 1.6 &#124; 稀疏矩阵 &#124;

&#124; 1.7 &#124; 转置 &#124;

&#124; 1.8 &#124; 程序 &#124;

&#124;  &#124; 练习 &#124;

|

第二模块：链表

| 2. | 链表

&#124; 2.1 &#124; 介绍 &#124;

&#124; 2.1 &#124; 单链表

&#124; 2.2.1 &#124; 内存中链表的表示 &#124;

&#124; 2.2.2 &#124; 单链表上的操作 &#124;

&#124;

&#124; 2.3 &#124; 一些重要的过程 &#124;

&#124; 2.4 &#124; 双链表

&#124; 2.4.1 &#124; 双链表上的操作 &#124;

&#124;

&#124; 2.5 &#124; 使用链表进行多项式加法 &#124;

&#124; 2.6 &#124; 使用链表实现 POLYADD 过程 &#124;

&#124; 2.7 &#124; 程序 &#124;

&#124;  &#124; 练习 &#124;

|

第三模块：栈和队列

| 3. | 栈和队列

&#124; 3.1 &#124; 定义与概念 &#124;

&#124; 3.2 &#124; 栈 &#124;

&#124; 3.3 &#124; 内存中栈的表示

&#124; 3.3.1 &#124; 使用数组表示栈 &#124;

&#124; 3.3.2 &#124; 栈的链表表示 &#124;

&#124;

&#124; 3.4 &#124; 栈的操作 &#124;

&#124; 3.5 &#124; 栈的应用 &#124;

&#124; 3.6 &#124; 队列

&#124; 3.6.1 &#124; 队列的表示 &#124;

&#124;

&#124; 3.7 &#124; 循环队列 &#124;

&#124; 3.8 &#124; 双端队列 &#124;

&#124; 3.9 &#124; 优先队列 &#124;

&#124; 3.10 &#124; 队列的应用 &#124;

&#124; 3.11 &#124; 程序 &#124;

&#124;  &#124; 练习题 &#124;

|

模块 IV: 树和图

| 4. | 树和图

&#124; 4.1 &#124; 简介 &#124;

&#124; 4.2 &#124; 基本术语 &#124;

&#124; 4.3 &#124; 树 &#124;

&#124; 4.4 &#124; 二叉树

&#124; 4.4.1 &#124; 严格二叉树 &#124;

&#124; 4.4.2 &#124; 完全二叉树 &#124;

&#124; 4.4.3 &#124; 扩展二叉树 &#124;

&#124;

&#124; 4.5 &#124; 树的二叉树表示法 &#124;

&#124; 4.6 &#124; 二叉树遍历 &#124;

&#124; 4.7 &#124; 更多关于二叉树的内容 &#124;

&#124; 4.8 &#124; 线索二叉树 &#124;

&#124; 4.9 &#124; 树的二叉树表示法 &#124;

&#124; 4.10 &#124; 二叉搜索树 &#124;

&#124; 4.11 &#124; 从二叉搜索树中删除的过程 &#124;

&#124; 4.12 &#124; 权路径长度 &#124;

&#124; 4.13 &#124; B 树 &#124;

&#124; 4.13.1 &#124; B 树中的插入 &#124;

&#124;

&#124; 4.14 &#124; B + 树 &#124;

&#124; 4.15 &#124; AVL 树（平衡二叉树）&#124;

&#124; 4.15.1 &#124; AVL 树中的插入 &#124;

&#124;

&#124; 4.16 &#124; 图 &#124;

&#124; 4.17 &#124; 图的表示 &#124;

&#124; 4.18 &#124; 图的遍历 &#124;

&#124;  &#124; 练习题 &#124;

|

模块 V: 搜索和排序

| 5. | 搜索和排序

&#124; 5.1 &#124; 搜索

&#124; 5.1.1 &#124; SEQSRCH 过程 (*R*, *n*, *i*, *K*) &#124;

&#124; 5.1.2 &#124; BINSRCH 过程 (*F*, *n*, *i*, *K*) &#124;

&#124;

&#124; 5.2 &#124; 斐波那契搜索

&#124; 5.2.1 &#124; FIBSEARCH 过程 (G, n, i, x) &#124;

&#124;

&#124; 5.3 &#124; 排序 &#124;

&#124;  &#124; 练习题 &#124;

|

模块 VI: 贪婪方法

| 6. | 贪婪方法

&#124; 6.1 &#124; 贪婪方法：基本概念 &#124;

&#124; 6.2 &#124; 最小生成树 &#124;

&#124; 6.2.1 &#124; Prim 算法 &#124;

&#124; 6.2.2 &#124; Kruskal 算法 &#124;

&#124;

&#124;  &#124; 练习题 &#124;

|

MODULE VII：区块链的美

| 7. | 区块链的美

&#124; 7.1 &#124; 区块链的起源 &#124;

&#124; 7.2 &#124; 区块链哲学（普通生态系统与区块链生态系统的区别）

&#124; 7.2.1 &#124; 普通生态系统 &#124;

&#124; 7.2.2 &#124; 区块链生态系统 &#124;

&#124;

&#124; 7.3 &#124; 分布式账本 &#124;

&#124; 7.4 &#124; 区块链的原理 &#124;

&#124; 7.5 &#124; 区块链数据结构及其工作方式（案例研究：比特币） &#124;

&#124; 7.6 &#124; 共识算法 &#124;

&#124; 7.7 &#124; 工作量证明 &#124;

&#124; 7.8 &#124; 股权证明（PoS） &#124;

&#124; 7.9 &#124; 委托权益证明 &#124;

&#124; 7.10 &#124; 智能合约 &#124;

&#124; 7.11 &#124; 区块链类型 &#124;

&#124; 7.12 &#124; 区块链的优势 &#124;

&#124; 7.13 &#124; 区块链的劣势 &#124;

&#124; 7.14 &#124; 区块链的未来 &#124;

|

| 1. | 在循环链表中

&#124; (a) &#124; 所有组件都以某种线性顺序链接在一起。 &#124;

&#124; (b) &#124; 没有开始也没有结束。 &#124;

&#124; (c) &#124; 组件按层次排列。 &#124;

&#124; (d) &#124; 可以向前和向后遍历。 &#124;

|

(b)

| 2. | 一个数据元素的顺序集合，其中顺序由指针给出的数据结构是？

&#124; (a) &#124; 链表 &#124; (b) &#124; 节点列表 &#124;

&#124; (c) &#124; 原始列表 &#124; (d) &#124; 无 &#124;

|

(a)

| 3. | 在以下操作中，双向链表比单向链表更有效执行的是？

&#124; (a) &#124; 删除给定位置的节点。 &#124;

&#124; (b) &#124; 在给定的未排序列表中搜索给定数据。 &#124;

&#124; (c) &#124; 遍历列表以处理每个节点。 &#124;

&#124; (d) &#124; 以上都不是。 &#124;

|

(a)

| 4. | 在链表中，每个节点包含至少两个字段。一个字段用于存储原始数据，另一个字段是？

&#124; (a) &#124; 指向字符的指针 &#124; (b) &#124; 指向整数的指针 &#124;

&#124; (c) &#124; 指向节点的指针 &#124; (d) &#124; 节点 &#124;

|

(c)

| 5. | 考虑一个未排序的双向链表的实现。假设它仅使用头指针表示。在给定的表示法下，以下哪种操作可以在 O(1)时间内实现？i）在链表的开头插入。ii）在给定的工作链表的末尾插入。iii）删除链表的起始节点。iv）删除当前工作链表的最后一个节点。

&#124; (a) &#124; I 和 II &#124; (b) &#124; I 和 III &#124;

&#124; (c) &#124; I，II 和 III &#124; (d) &#124; I，II，III 和 IV &#124;

|

(b)

| 6. | 在循环链表中，插入节点需要修改什么？

&#124; (a) &#124; 一个指针 &#124; (b) &#124; 两个指针 &#124;

&#124; (c) &#124; 三指针 &#124; (d) &#124; 无 &#124;

|

(b)

| 7. | 一种链表的变体，其中没有节点包含 NULL 指针是？

&#124; (a) &#124; 单向链表 &#124; (b) &#124; 双向链表 &#124;

&#124; (c) &#124; 循环链表 &#124; (d) &#124; 无 &#124;

|

(c)

| 8. | 关于数据结构链表的以下哪些描述是正确的？

&#124; (a) &#124; 在当前工作链表中进行添加和删除需要修改现有指针。 &#124;

&#124; (b) &#124; 链表指针不提供一种良好的有序方式来在链表中搜索项目。 &#124;

&#124; (c) &#124; 链表中的指针始终保持非递减顺序。 &#124;

&#124; (d) &#124; 链表数据结构提供了一种系统化的方法来在列表中找到第 k 个元素 &#124;

|

(b)

| 9. | 链表不适合实现哪些内容？

&#124; (a) &#124; 插入排序 &#124; (b) &#124; 基数排序 &#124;

&#124; (c) &#124; 多项式操作 &#124; (d) &#124; 二分搜索 &#124;

|

(d)

| 10. | 在链表中的第二个位置插入一个元素，渐进时间复杂度将是多少？

&#124; (a) &#124; O(1) &#124; (b) &#124; O(n) &#124;

&#124; (c) &#124; O(n²) &#124; (d) &#124; 无 &#124;

|

(a)(a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)

| 1. | 以下哪一项是堆栈数据结构的应用之一？

&#124; (a) &#124; 管理函数调用 &#124;

&#124; (b) &#124; 股票跨度问题 &#124;

&#124; (c) &#124; 算术表达式求值 &#124;

&#124; (d) &#124; 以上全部 &#124;

|

答案：(d)

| 2. | 使用链表实现的堆栈的以下哪项是真实的？

&#124; (a) &#124; 在推送操作中，如果新节点添加到链表的开头，则在弹出操作中，必须从末尾删除节点。 &#124;

&#124; (b) &#124; 在推送操作中，如果新节点添加到末尾，则在弹出操作中，必须从开头删除节点。 &#124;

&#124; (c) &#124; 以上两者都是 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

答案：(d)

| 3. | 使用堆栈计算具有单个数字操作数的后缀表达式：8 2 3 ^ / 2 3 * + 5 1 * - 其中 ^ 是指数运算符。在第一个 * 计算后堆栈的前两个元素如下：

&#124; (a) &#124; 6,1 &#124; (b) &#124; 5,7 &#124;

&#124; (c) &#124; 3,2 &#124; (d) &#124; 1,5 &#124;

|

答案：(a)

| 4. | 计算后缀表达式 10 5 + 60 6 / * 8 – 的结果如下：

&#124; (a) &#124; 284 &#124; (b) &#124; 213 &#124;

&#124; (c) &#124; 142 &#124; (d) &#124; 71 &#124;

|

答案：(c)

| 5. | 在显示的顺序中将元素 71、65、84、69、67、83 插入到空二叉搜索树（BST）中时，最低级别的元素是：

&#124; (a) &#124; 65 &#124; (b) &#124; 67 &#124;

&#124; (c) &#124; 69 &#124; (d) &#124; 83 &#124;

|

答案：(b)

| 6. | 以下哪项可以作为队列的示例？

&#124; (a) &#124; 当资源被多个终端用户共享时。 &#124;

&#124; (b) &#124; 在两个进程之间异步传输数据（数据不一定以相同的速率接收和发送）时。 &#124;

&#124; (c) &#124; 负载平衡 &#124;

&#124; (d) &#124; 以上全部 &#124;

|

答案：(d)

| 7. | 在哪种类型的数据结构上，可以执行这些操作？推入（Push）、弹出（Pop）、查看（Peek）

&#124; (a) &#124; 队列（Queue） &#124; (b) &#124; 优先队列（Priority Queue） &#124;

&#124; (c) &#124; 堆栈（Stack） &#124; (d) &#124; 1 和 2 都是（Both 1 and 2） &#124;

|

答案为 (d)

| 8. | 要实现一个优先队列，需要多少个堆栈。假设情况是，你没有其他数据结构如数组、链表可供使用。

&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;

&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;

|

答案为 (b)

| 9. | 优先队列可以有效地使用哪些给定的数据结构来实现？考虑到插入、查看（查看当前最高优先级项的操作）和提取（移除最高优先级项的操作）操作的数量几乎相同。

&#124; (a) &#124; 数组（Array） &#124;

&#124; (b) &#124; 链表（Linked List） &#124;

&#124; (c) &#124; 堆数据结构，如二叉堆、斐波那契堆（Heap Data Structures like Binary Heap, Fibonacci Heap） &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

答案为 (c)

| 10. | 在队列中，前指针 f 和后指针 r 的初始值应分别为……和……。

&#124; (a) &#124; -1, -1 &#124; (b) &#124; 0, -1 &#124;

&#124; (c) &#124; 0, 0 &#124; (d) &#124; -1, 0 &#124;

|

答案为 (b)

| 11. | 表达式 (H+I )*(J*K- L)*M / N 的后缀形式是？

&#124; (a) &#124; HI + JK * L - MN / ** &#124; (b) &#124; HI + JK * L - M ** N / &#124;

&#124; (c) &#124; HI + JK * L - *M * N / &#124; (d) &#124; HI + JKL * - * M * N / &#124;

|

答案为 (a)

| 12. | 在递归算法的非递归实现中，最有可能使用哪种数据结构？

&#124; (a) &#124; 链表（Linked List） &#124; (b) &#124; 堆栈（Stack） &#124;

&#124; (c) &#124; 队列（Queue） &#124; (d) &#124; 树（Tree） &#124;

|

答案为 (b)

| 13. | 在顺序访问内存中访问存储数据的过程类似于在 ------ 上操作数据？

&#124; (a) &#124; 堆栈（Heap） &#124; (b) &#124; 二叉树（Binary Tree） &#124;

&#124; (c) &#124; 数组（Array） &#124; (d) &#124; 堆栈（Stack） &#124;

|

答案为 (d)

| 14. | 表达式 E*F+G/H 的后缀形式是？

&#124; (a) &#124; *EF/GH+ &#124; (b) &#124; EF*GH/+ &#124;

&#124; (c) &#124; E*FG+/H &#124; (d) &#124; EFGH+/* &#124;

|

答案 (b)

| 15. | *H-I/ (J * K* ⋀ *L)*的前缀形式是？

&#124; (a) &#124; -/*⋀HJIKL &#124; (b) &#124; -HIJK*⋀KL &#124;

&#124; (c) &#124; -H/I*J⋀KL &#124; (d) &#124; -H/IJ*⋀KL &#124;

|

答案 (c)

| 16. | 下面操作 Top (Push (S, Y)) 的输出是什么？

&#124; (a) &#124; Y &#124; (b) &#124; 空 &#124;

&#124; (c) &#124; S &#124; (d) &#124; 无 &#124;

|

答案 (a)

| 17. | 下列哪种数据结构适合实现递归？

&#124; (a) &#124; 队列 &#124; (b) &#124; 栈 &#124;

&#124; (c) &#124; 数组 &#124; (d) &#124; 列表 &#124;

|

答案 (b)

| 18. | 评估后缀表达式 2, 4, 6, +, *, 4, 6, 3, /, +, * 的输出是？

&#124; (a) &#124; 600 &#124; (b) &#124; 120 &#124;

&#124; (c) &#124; 650 &#124; (d) &#124; 588 &#124;

|

答案 (b)

| 19. | 将以下中缀表达式转换为后缀形式，使用栈*a + b * c + (d * e + f) * g*是:

&#124; (a) &#124; abc*+de*f+g*+ &#124; (b) &#124; abc*+de*f+g+* &#124;

&#124; (c) &#124; abc+*de*f+g*+ &#124; (d) &#124; 无 &#124;

|

答案 (a)

| 20. | 关于栈数据结构的以下哪种陈述是/不正确的？

&#124; (a) &#124; 栈数据结构也可以使用链表执行。 &#124;

&#124; (b) &#124; 新节点只能被限制在栈顶添加。 &#124;

&#124; (c) &#124; 栈也被称为**先进先出** (**FIFO**) 数据结构。 &#124;

&#124; (d) &#124; 栈的最底部节点具有 NULL 链接。 &#124;

|

答案 (c)

| 21. | 当使用链表实现栈时，下列哪个节点被视为栈的顶部？

&#124; (a) &#124; 第一个节点 &#124; (b) &#124; 最后一个节点 &#124;

&#124; (c) &#124; 任何节点 &#124; (d) &#124; 中间节点 &#124;

|

答案 (a)

| 22. | 在数组实现的栈中，以下哪些操作在最坏情况下需要线性时间？

&#124; (a) &#124; 入栈 &#124; (b) &#124; 出栈 &#124;

&#124; (c) &#124; 是否为空 &#124; (d) &#124; 都不是 &#124;

|

答案：(d)

| 23. | 在以下应用中，栈最常用于：

&#124; (a) &#124; 括号平衡程序 &#124;

&#124; (b) &#124; 编译器中的语法分析器 &#124;

&#124; (c) &#124; 在运行时跟踪本地变量 &#124;

&#124; (d) &#124; 以上所有选项 &#124;

|

答案：(d)

| 24. | 在队列的链表实现中，跟踪前端和后端指针。在向非空队列插入元素时，哪些指针会改变？

&#124; (a) &#124; 只有前指针 &#124;

&#124; (b) &#124; 只有后指针 &#124;

&#124; (c) &#124; 前指针和后指针都需要 &#124;

&#124; (d) &#124; 前指针和后指针都不需要 &#124;

|

答案：(b)

| 25. | 栈用于

&#124; (a) &#124; CPU 资源分配 &#124; (b) &#124; 广度优先遍历 &#124;

&#124; (c) &#124; 递归 &#124; (d) &#124; 以上都不是 &#124;

|

答案：(c)

| 26. | push() 和 pop() 函数常见于

&#124; (a) &#124; 队列 &#124; (b) &#124; 列表 &#124;

&#124; (c) &#124; 栈 &#124; (d) &#124; 树 &#124;

|

答案：(c)

| 27. | 实现优先队列所需的最小队列数是多少？

&#124; (a) &#124; 5 &#124; (b) &#124; 4 &#124;

&#124; (c) &#124; 3 &#124; (d) &#124; 2 &#124;

|

答案：(d)

| 28. | 在图的广度优先遍历中，使用的数据结构是？

&#124; (a) &#124; 队列 &#124; (b) &#124; 栈 &#124;

&#124; (c) &#124; 列表 &#124; (d) &#124; 以上都不是 &#124;

|

答案：(a)

| 29. | 队列数据结构可以用于

&#124; (a) &#124; 表达式解析 &#124; (b) &#124; 递归 &#124;

&#124; (c) &#124; 资源分配 &#124; (d) &#124; 以上全部选项 &#124;

|

答案：(c)

| 30. | 如果关注局部性，则可以使用 ________ 图的遍历方法。

&#124; (a) &#124; 广度优先搜索（BFS） &#124; (b) &#124; 深度优先搜索（DFS） &#124;

&#124; (c) &#124; 要么广度优先搜索（BFS），要么深度优先搜索（DFS） &#124; (d) &#124; 以上都不是！ &#124;

|

答案：(b)

| 31. | 在使用栈数据结构从前缀转换为后缀时，如果运算符和操作数被推送和弹出恰好一次，那么运行时复杂度是

&#124; (a) &#124; Ο(1) &#124; (b) &#124; Ο(n) &#124;

&#124; (c) &#124; Ο(log n) &#124; (d) &#124; Ο(n2) &#124;

|

答案：(b)

| 32. | 如果使用数组实现队列，那么队列和出队操作的最坏运行时间复杂度将是多少？

&#124; (a) &#124; Ο(n), Ο(n) &#124; (b) &#124; Ο(n), Ο(1) &#124;

&#124; (c) &#124; Ο(1), Ο(n) &#124; (d) &#124; Ο(1), Ο(1) &#124;

|

答案：(c)

| 33. | 使用队列实现栈（仅使用入队和出队操作），需要多少个队列？

&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;

&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;

|

|  |
| --- |

&#124; (a) &#124; B 和 E &#124; (b) &#124; C 和 D &#124;

&#124; (c) &#124; A 和 E &#124; (d) &#124; C 和 B &#124;

|

答案为 (d)(d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) ![](img/image-os3obvyq.jpg)

|  |
| --- |

&#124; (a) &#124; 图是一个完全图 &#124;

&#124; (b) &#124; 图是一个不连通的图 &#124;

&#124; (c) &#124; 图的顶点连通度为二。 &#124;

&#124; (d) &#124; 图的边连通度为一。 &#124;

|

答案为 (c)

| 3. | 一个具有 n 个顶点的完全图中有多少条边？

&#124; (a) &#124; (n*(n+1))/2 &#124;

&#124; (b) &#124; (n*(n-1))/2 &#124;

&#124; (c) &#124; n &#124;

&#124; (d) &#124; 给定的信息不足 &#124;

|

答案为 (b)

| 4. | 对于简单图，边的数量是顶点度数之和的两倍。

&#124; (a) &#124; 正确 &#124; (b) &#124; 错误 &#124;

|

答案为 (b)

| 5. | 以下哪项是正确的？

&#124; (a) &#124; 图中不包含边且包含许多顶点 &#124;

&#124; (b) &#124; 图中不包含顶点且包含许多边 &#124;

&#124; (c) &#124; 图中不包含边且不包含顶点 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

答案为 (b)

| 6. | 当图包含度相等的顶点时，被称为 __________

&#124; (a) &#124; 多重图 &#124; (b) &#124; 正则图 &#124;

&#124; (c) &#124; 简单图 &#124; (d) &#124; 完全图 &#124;

|

答案为 (b)(b) (b) (b) (b) (b) ![](img/image-sj7ub021.jpg)

|   |
| --- |

&#124; (a) &#124; 正确 &#124; (b) &#124; 错误 &#124;

|

答案为 (a)

| 8. | 在以下哪种方式中，可以用来表示内存中的图？

&#124; (a) &#124; 邻接矩阵和邻接表 &#124;

&#124; (b) &#124; 是一个关联矩阵的矩阵 &#124;

&#124; (c) &#124; 邻接矩阵，邻接表和关联矩阵 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

答案为 (c)

| 9. | 所有图的邻接矩阵都是对称的。

&#124; (a) &#124; 错误 &#124; (b) &#124; 正确 &#124;

|

答案为 (a)

| 10. | 一棵有 n 个内部节点的满二叉树中的外部节点数量是多少？

&#124; (a) &#124; n &#124; (b) &#124; n+1 &#124;

&#124; (c) &#124; 2n &#124; (d) &#124; 2n + 1 &#124;

|

答案：(b)

| 11. | 从给定节点到叶节点的包含边数最多的路径被称为树的 _________。

&#124; (a) &#124; 高度 &#124; (b) &#124; 深度 &#124;

&#124; (c) &#124; 长度 &#124; (d) &#124; 上述都不是 &#124;

|

答案：(a)

| 12. | 当:

&#124; (a) &#124; 每个节点有零个或最多两个子节点。 &#124;

&#124; (b) &#124; 每个节点恰好有两个子节点。 &#124;

&#124; (c) &#124; 给定的满二叉树的所有叶子位于同一级别。 &#124;

&#124; (d) &#124; 每个节点恰好有一个或两个子节点。 &#124;

|

答案：(a)

| 13. | 以下哪项是树的一个缺点？

&#124; (a) &#124; 分层结构 &#124;

&#124; (b) &#124; 更快的搜索 &#124;

&#124; (c) &#124; 路由器算法 &#124;

&#124; (d) &#124; 记事本中的撤销/重做操作 &#124;

|

答案：(d)

| 14. | 二叉搜索树的中序遍历有什么特点？

&#124; (a) &#124; 它以非递增的顺序遍历 &#124;

&#124; (b) &#124; 它以递增的顺序遍历 &#124;

&#124; (c) &#124; 它以随机的方式遍历 &#124;

&#124; (d) &#124; 上述都不是 &#124;

|

答案：(b)

| 15. | AVL 树是什么？

&#124; (a) &#124; 一棵平衡且是高度平衡树的树 &#124;

&#124; (b) &#124; 一棵不平衡且是高度平衡树的树 &#124;

&#124; (c) &#124; 一个有三个子节点的树 &#124;

&#124; (d) &#124; 最多有 3 个子节点的树 &#124;

|

答案：(a)

| 16. | 权重平衡树是什么？

&#124; (a) &#124; 一个二叉树，它保存每个节点中与所有子树大小相关的数据 &#124;

&#124; (b) &#124; 包含额外权重信息的二叉树 &#124;

&#124; (c) &#124; 一棵高度平衡的二叉树 &#124;

&#124; (d) &#124; 一个普通的二叉树 &#124;

|

答案 (a)

| 17. | 权重平衡树的节点具有：

&#124; (a) &#124; 关键字，左右指针，大小 &#124;

&#124; (b) &#124; 关键字，值 &#124;

&#124; (c) &#124; 关键字，大小 &#124;

&#124; (d) &#124; 关键字 &#124;

|

答案 (a)

| 18. | 有向图的另一个名称是……？  |
| --- | --- |
| 19. | 带线索的二叉树称为……？  |
| 20. | 图 G 是……如果对于 G 中的任意节点对 u，v，存在从 u 到 v 的路径或从 v 到 u 的路径。 |
| 21. | 什么是 B 树？ |
| 22. | 什么是伸展树？ |
| 23. | 解释如何找到二叉树的深度？ |
| 24. | 解释先序遍历和中序遍历树。 |
| 25. | 什么是 B+ 树？解释其用途。 |
| 26. | 定义线索二叉树。解释其常见用途 |
| 27. | 解释二叉树遍历是如何实现的。 |
| 28. | 解释从二叉树中删除的实现。 |
| 29. | 解释树和图的区别。 |

| 30. | 以下哪一项对于二叉搜索树不正确？

&#124; (a) &#124; 左子节点始终小于其父节点 &#124;

&#124; (b) &#124; 右子节点大于其父节点 &#124;

&#124; (c) &#124; 每个节点的个别子树，即任何节点的左子树和右子树也应该是二叉搜索树 &#124;

&#124; (d) &#124; 以上都不是。 &#124;

|

| 31. | 以下哪一项被认为是二叉搜索树中中序遍历的独特特点？

&#124; (a) &#124; 它以非递增的顺序遍历 &#124;

&#124; (b) &#124; 它以递增顺序遍历 &#124;

&#124; (c) &#124; 它以随机方式遍历 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

| 32. | 什么是满二叉树？ |
| --- | --- |
| 33. | 什么是完全二叉树？ |
| 34. | 查找二叉树高度的时间复杂度是多少？ |

| 35. | 在简单图中，边的数量等于顶点度数的两倍之和。

&#124; (a) &#124; 是的 &#124;

&#124; (b) &#124; 错误 &#124;

|

| 36. | 简单图不具备以下哪种属性？

&#124; (a) &#124; 必须连通 &#124;

&#124; (b) &#124; 必须是无权的 &#124;

&#124; (c) &#124; 不能有环或多重边 &#124;

&#124; (d) &#124; 所有提到的都是 &#124;

|

| 37. | 以下哪种方法可以用来表示图？

&#124; (a) &#124; 邻接表和邻接矩阵 &#124;

&#124; (b) &#124; 关联矩阵 &#124;

&#124; (c) &#124; 邻接表、邻接矩阵以及关联矩阵 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

| 38. | 所有顶点度数相等的图称为 __________

&#124; (a) &#124; 多重图 &#124;

&#124; (b) &#124; 正则图 &#124;

&#124; (c) &#124; 简单图 &#124;

&#124; (d) &#124; 完全图 &#124;

|

| 39. | 以下哪种顶点度数组合将得到欧拉连通图？

&#124; (a) &#124; 1,2,3 &#124; (b) &#124; 2,3,4 &#124;

&#124; (c) &#124; 2,4,5 &#124; (d) &#124; 1,3,5 &#124;

|

MODULE VSearching and Sorting  CHAPTER 5 Searching and Sorting5.1 Searching A file comprises of records, where each record having one or more fields. The fields which are used to distinguish these records, are called keys. The key fields which are used for record identification will depend on the particular applications, because the same file can be utilised for several different applications. When there is a collection of records, there are at least two ways in which they are used to store them in memory: sequentially or non-sequentially. Let us assume, there is a sequential file F and we need to retrieve a record with a certain key value Suppose F has n number of records with the key informatiom stored in the record then one is able to carry out the retrieval by inspecting the key values Kn – 1, ..., in that order, until the correct record is located. Such a search process is known as sequential search, since the records are scrutinized linearly.5.1.1 Procedure SEQSRCH (R, a file R containing key data ..., Kn for a record Ri such that K. If there is no such record found, then i is set to K0 ← K; i ← n While Ki ≠ K do i ← i – 1 end end SEQSRCH When a successful search is encountered, then the number of key comparisons made in such case, depends on the position where the concerned key has been placed in the file. If all keys present in the given file are unique and key Ki is being searched for, then – i + 1) key comparisons are made. If no such record is found in the file, then the file has key value K, which lead to i = 0, and the above algorithm requires + 1) comparisons. The average number of comparisons, which can occur in a successful search is, therefore, that is, ![](img/image-wjblcyez.jpg) For large n this many comparison is very inefficient. So, if the file is arranged in some predefined order, then one should be able to search for specific records quickly. One of the common methods available for searching an ordered linear file is called binary search. In this method, the search begins by inspecting the record in the middle of the file rather than the records present at either of the ends in linear search or sequential search. Let us assume that the file being searched is ordered in non-decreasing values of the key. Then, based on the results of the comparison with the middle key, the following conclusions are drawn:drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn:drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn:drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: Consequently, after each comparison either the search terminates successfully or the size of the file remaining to be searched is about one half of the original size. Whereas, in the case of sequential search, after each comparison the size of the file remaining to the searched decreases by only 1\. Hence, in the worst case, this method requires O (log key comparisons to search a file.5.1.2 Procedure BINSRCH (F, n, i, K) // Search an ordered sequential file F with records ..., Rn and the keys £ K2 £ º £ Kn for a record Ri such that Ki – i – 0 if there is no such record else Ki=K// l u ← n while l ≤ u do m ← + // compute index of middle record // Case : K > Km : l ← m + 1 // look in upper half // : K = Km : i ← return : K < Km : u ← m – 1 // look in lower half // End Case End While i

| 1. | 找到大于或等于 n 的最小斐波那契数。让这个数字为 *F**[k]* [– 1]。让它之前的两个斐波那契数分别为 *F**[k]* [– 2] 和 *F**[k]* [– 3]。 |
| --- | --- |
| 2. | 当数组还有要检查的元素时： |

| 3. | 将 x 与 *F**[k]* [– 3] 所覆盖的范围的最后一个元素进行比较。

&#124; **1.** &#124; **如果** x 匹配，返回索引 &#124;

&#124; **2.** &#124; **否则如果** x 小于该元素，则将三个斐波那契变量向下移动两个斐波那契数，指示大约剔除了剩余数组的后三分之二。 &#124;

&#124; **3.** &#124; **否则** x 大于该元素，则将三个斐波那契变量向下移动一个斐波那契数。将偏移量重置为索引。这些指示大约剔除了剩余数组的前三分之一。 &#124;

|

Illustration: 让我们通过下面的示例来理解算法：![](img/image-o6zccrlm.jpg) 考虑上述长度为（n）= 11 的数组 A，索引从 1 开始。让搜索的元素 x = 85。![](img/image-10b0vr28.jpg) 让 F 是包含斐波那契数列的数组。因此，大于或等于 11 的最小斐波那契数是 13。因此，- 1 = 13，- 2 = 8，- 3 = 5。下表总结了这些变量的变化以及斐波那契搜索的过程：![](img/image-i6xosr6t.jpg) ![](img/image-6dosc0ww.jpg) 因此，元素 (x) = 85 被找到在索引 9\.5.3。排序。排序方法主要分为以下几类：内部方法是当要排序的文件足够小以至于整个排序可以在主存储器中完成时要使用的方法。外部方法是用于更大文件的方法。内部排序方法的示例如下：外部排序方法的示例如下：

| 1. | 以下哪种排序算法具有最低的最坏情况复杂度？

&#124; (a) &#124; Merge Sort &#124; (b) &#124; Bubble Sort &#124;

&#124; (c) &#124; Quick Sort &#124; (d) &#124; Selection Sort &#124;

|

Ans. (a)

| 2. | 如果要排序的记录数量很少，那么……排序可能是高效的。

&#124; (a) &#124; Merge &#124; (b) &#124; Heap &#124;

&#124; (c) &#124; Selection &#124; (d) &#124; Bubble &#124;

|

Ans. (c)

| 3. | 排序算法的复杂度衡量……作为要排序的 n 个项的函数。

&#124; (a) &#124; average time &#124; (b) &#124; running time &#124;

&#124; (c) &#124; average-case complexity &#124; (d) &#124; case-complexity &#124;

|

Ans. (b)

| 4. | 冒泡排序算法的复杂度是……

&#124; (a) &#124; O (n) &#124; (b) &#124; O(logn) &#124;

&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n logn) &#124;

|

Ans. (c)

| 5. | 在集合中找到给定项目的位置称为……

&#124; (a) &#124; Discovering &#124; (b) &#124; Finding &#124;

&#124; (c) &#124; Searching &#124; (d) &#124; Mining &#124;

|

Ans. (c)

| 6. | 以下哪项是外部排序？

&#124; (a) &#124; Insertion Sort &#124; (b) &#124; Bubble Sort &#124;

&#124; (c) &#124; Merge Sort &#124; (d) &#124; Tree Sort &#124;

|

Ans. (c)

| 7. | 冒泡排序中的总比较次数是……

&#124; (a) &#124; O (n logn) &#124; (b) &#124; O(2n) &#124;

&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n) &#124;

|

Ans. (a)

| 8. | 将 k 个已排序的表合并成一个单一的排序表称为……

&#124; (a) &#124; k way merging &#124; (b) &#124; k th merge &#124;

&#124; (c) &#124; k+1 merge &#124; (d) &#124; k-1 merge &#124;

|

Ans. (a)

| 9. | 对文件 F 进行排序通常指的是根据一个称为……的特定键对 F 进行排序。

&#124; (a) &#124; Basic key &#124; (b) &#124; Primary key &#124;

&#124; (c) &#124; Starting key &#124; (d) &#124; Index key &#124;

|

Ans. (b)

| 10. | 如果要排序的记录数很大且键值很长，则……排序可以很有效率。

&#124; (a) &#124; 合并 &#124; (b) &#124; 堆 &#124;

&#124; (c) &#124; 快速 &#124; (d) &#124; 冒泡 &#124;

|

答案 (c)

| 11. | 用于修改记录键排序方式的函数称为……..

&#124; (a) &#124; 索引函数 &#124; (b) &#124; 哈希函数 &#124;

&#124; (c) &#124; 寻址函数 &#124; (d) &#124; 以上全部 &#124;

|

答案 (b)

| 12. | 以下哪种排序算法属于分而治之类型？

&#124; (a) &#124; 冒泡排序 &#124; (b) &#124; 插入排序 &#124;

&#124; (c) &#124; 快速排序 &#124; (d) &#124; 归并排序 &#124;

|

答案 (c)

| 13. | ……….排序适用于对大量姓名进行字母排序。

&#124; (a) &#124; 合并 &#124; (b) &#124; 堆 &#124;

&#124; (c) &#124; 基数 &#124; (d) &#124; 冒泡 &#124;

|

答案 (c)

| 14. | 将元素 A 和 B 合并成一个单独的排序列表 C，其中 n = r + s 元素的操作称为……。

&#124; (a) &#124; 插入 &#124; (b) &#124; 混合 &#124;

&#124; (c) &#124; 合并 &#124; (d) &#124; 分享 &#124;

|

答案 (c)

| 15. | 快速排序也称为……..

&#124; (a) &#124; 归并排序 &#124; (b) &#124; 树排序 &#124;

&#124; (c) &#124; 希尔排序 &#124; (d) &#124; 分区和交换排序 &#124;

|

答案 (d)

| 16. | 用于分区未排序列表的主元素用于。

&#124; (a) &#124; 归并排序 &#124; (b) &#124; 快速排序 &#124;

&#124; (c) &#124; 插入排序 &#124; (d) &#124; 选择排序 &#124;

|

答案 (b)

| 17. | 以下哪种技术用于在数组中查找值？

&#124; (a) &#124; 冒泡排序 &#124; (b) &#124; 二分查找算法 &#124;

&#124; (c) &#124; 线性搜索算法 &#124; (d) &#124; 以上全部 &#124;

|

答案 (d)

| 18. | 以下哪种不是稳定的排序算法？

&#124; (a) &#124; 插入排序 &#124; (b) &#124; 选择排序 &#124;

&#124; (c) &#124; 冒泡排序 &#124; (d) &#124; 归并排序 &#124;

|

答案：(b)

| 19. | 堆排序的最坏情况时间复杂度是多少？

&#124; (a) &#124; O (logn) &#124; (b) &#124; O (n) &#124;

&#124; (c) &#124; O(nlogn) &#124; (d) &#124; O(n²) &#124;

|

答案：(c)

| 20. | 计数排序执行……输入元素之间的比较次数。

&#124; (a) &#124; 0 &#124; (b) &#124; n &#124;

&#124; (c) &#124; nlogn &#124; (d) &#124; n² &#124;

|

答案：(a)

| 21. | 如果排序技术是稳定的，则它

&#124; (a) &#124; 需要 O (nlogn) 次 &#124;

&#124; (b) &#124; 维护非不同元素的出现顺序 &#124;

&#124; (c) &#124; 使用分治范式 &#124;

&#124; (d) &#124; 需要 O (n) 空间 &#124;

|

答案：(b)

| 22. | 以下哪种算法具有最低的最坏情况时间复杂度？

&#124; (a) &#124; 插入排序 &#124; (b) &#124; 选择排序 &#124;

&#124; (c) &#124; 快速排序 &#124; (d) &#124; 堆排序 &#124;

|

答案：(d)

| 23. | 选择排序的缺点是什么？

&#124; (a) &#124; 它需要辅助内存 &#124;

&#124; (b) &#124; 它不可扩展 &#124;

&#124; (c) &#124; 它可以用于小键值 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

Ans. (b) 短答案问题 问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题-   Greedy Method  CHAPTER 6 贪婪方法 6.1 贪婪方法：基本概念 这是解决问题的一种方法。正如我们有分而治之方法一样，这种设计也用于解决问题。 让我们了解一下这个方法在说什么。这种方法用于解决优化问题。什么是优化问题？一个要求最小结果或最大结果的问题。 所以，为此，让我们了解一下通过下面的一个例子解释的一些术语。 假设，有一个问题 P。问题说，我必须从城市 A 去到城市 B。我必须完成这段旅程，这将成为我的问题。对于这个问题，我可能有很多解决方案。 P：A ⟶ B；其中 P 是问题，A 和 B 表示城市。 我可以步行完成旅程，让它成为解决方案一，S1，或者我可以骑自行车，解决方案二，S2，或者我可以开车，解决方案三，S3，或者我可以坐火车，解决方案四，S4，或者我可以坐飞机，解决方案五，S5。我们可以看到，对于特定的问题 P，有许多解决方案，S1，S2，S3，S4，S5，….Sn。如果我没有任何限制，我可以采取任何解决方案来解决问题。但是这里我有一个约束或限制，那就是我必须在 12 小时内完成旅程。 然后，在许多可用的解决方案中，解决方案 S4 和 S5 满足给定的约束条件。 S4 是乘火车，S5 是乘飞机完成旅程。在这里，解决方案 S4 和 S5 被称为可行解决方案，因为它们是满足所述问题的给定约束条件的解决方案。 因此，可行解决方案被定义为满足问题中给定条件的解决方案（尽管对于给定问题，我们可能有许多解决方案）。 现在，如果我说我想以最低成本完成这段旅程。也就是说，我希望尽可能少地花费金额，那么给定的问题就变成了最小化问题。由于问题要求结果应最小，因此此类问题属于最小化问题。 假设，在两个可行解决方案 S4 和 S5 中，一个解决方案给出了完成旅程的最低成本。让该解决方案为 S4。那么，此解决方案 S4 称为最优解。 因此，最优解被定义为一个可行解决方案，同时也给出了最佳结果。 肯定地说，对于任何问题，只能有一个最优解。可能会有很多解决方案，也可能会有多个可行解决方案，但是，所有时间，问题将仅有一个最优解。 这个问题需要最小的结果，而另一些问题需要最大的结果。所以，如果一个问题要求最小或最大的结果，那么我们称这种类型的问题为优化问题。我们也可以用其他话来说，优化问题要求最小结果或最大结果。 因此，贪婪方法用于解决优化问题。 这里是贪婪技术的一般方法。贪婪方法的控制抽象如下所示： 算法 GREEDYMETHOD（g，m） { 对于

| 1. | 创建集合 A，最初等于空集，并创建集合 P，最初等于 E，即所有边的集合。  |
| --- | --- |

| 2. | 在 P 中选择距离最小的边，称为‘e’，并

&#124; (a) &#124; 如果将 e 添加到 A 中会形成环路，则将 e 从 P 中移除。 &#124;

&#124; (b) &#124; 否则，将 e 从 P 移至 A。 &#124;

|

| 3. | 如果 P 不为空，则转到步骤 2。  |
| --- | --- |
| 4. | 输出最小生成树（V，A）（其中 V 是所有顶点的集合）。 |

上述过程是使用克鲁斯卡尔算法生成最小生成树（MST）的方法。让我们解决一下“精灵宝可梦 Go”的问题。![](img/image-6k6836os.jpg) 第一步我们有一个初始为空的集合 A，并且显示为以下图形:- ![](img/image-c6ysx2qs.jpg) 现在，在第二步中，它说，选择一个具有最小成本的边‘e’，在这里，我们有边（4，7），成本最小为 2。我们必须将这条边从 P 移动到 A，图示这种变化如下所示: ![](img/image-5cnk9d96.jpg) 步骤 ![](img/image-wehow6ia.jpg) 接下来，再次检查 P 是否为空。显然，P 不为空。让我们再次进入步骤 2 进行下一次迭代，并再次选择具有最小成本的下一条边。我们可以看到，边（4，6）的成本最小，由于此边不形成任何环，因此我们将该边从 P 移动到 A，以下图形显示了这些更改: ![](img/image-jd6f1vkq.jpg) 步骤 ![](img/image-stg4oiz4.jpg) 再次进入第 3 步检查 P 是否为空，并发现 P 不为空。再次转到第 2 步，以寻找下一条具有最小成本的边。在这里，边（1，2）的成本最小，我们检查加入此边是否在 A 中创建任何环。由于它不创建任何环，我们将此边从 P 移动到 A，以下图形显示了更改: ![](img/image-7lwjanaw.jpg) 步骤 ![](img/image-t55g0fw2.jpg) 再次转到第 3 步，并发现 P 不为空。再次转到第 2 步，以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（5，7），成本为 7。由于将此边包含到 A 中不会创建任何环，因此将此边从 P 移动到 A。更改如下图所示: ![](img/image-rmbzv4y3.jpg) 步骤 2: ![](img/image-14zdtdbo.jpg) 检查第 3 步是否为空，由于 P 不为空，因此再次执行第 2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（4，5），成本为 11。由于将此边包含到 A 中会在 A 中创建环，因此将此边丢弃。并且将此边（4，5）从 P 中移除，并显示更改如下图所示: ![](img/image-rv5ka3rl.jpg) 检查第 3 步是否为空，由于 P 不为空，因此再次执行第 2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（3，6）和（6，因此，这里的边（3，6）被包含在 A 中，因为其包含不会在 A 中创建任何环。更改如下图所示: ![](img/image-7pe0814h.jpg) 步骤 ![](img/image-tbgqnj6z.jpg) 再次执行第 3 步，发现 P 不为空，因此执行第 2 步以查找具有最小成本的下一条边，并找到成本最小的边（6，7）。但是，将其包含在 A 中会在 A 中创建环，因此将其从 P 中移除。以下图形显示了更改: ![](img/image-3qea1lny.jpg) 现在，再次执行第 3 步，并发现 P 不为空，因此必须再次执行第 2 步。我们找到具有最小成本的下一条边是（1，但是，将其包含在 A 中会在 A 中创建环，因此将其从 P 中移除。以下图形显示了更改: ![](img/image-h2wtgwz7.jpg) 再次执行第 3 步，并发现 P 不为空，因此必须再次执行第 2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（2，4），成本为 31。由于将此边包含到 A 中会在 A 中创建环，因此必须将此边从 P 中移除。以下图形显示了更改- ![](img/image-24y37uw0.jpg) 现在，执行第 3 步，并发现 P 为空。因此，调用第 4 步，它输出了最小生成树（V，A），如下图所示- ![](img/image-naekynbq.jpg) 在这里，获得的最小生成树的成本是 2 + 3 + 5 + 7 + 13 + 17 + 19 = 66 注意:  克鲁斯卡尔算法是一种生成给定连接加权图的最小生成树的算法。 它是一种贪婪的 MST 算法。 与普林姆算法的区别在于，普林姆算法仅增长一棵树，而克鲁斯卡尔算法增长一组树。 使用不相交 - 集数据结构检查循环的克鲁斯卡尔算法的伪代码如下- 1.按权重对所有边进行排序，以便 w_1 < = w_2 <= w_3 <= ……..<= w_n。 2.最初，A 是一个空集（ø

| 4. | 要构造最小生成树（MST），Prim 算法总是选择一条边

&#124; (a) &#124; 具有最小权重，导致 MST 成本最小增加的边 &#124;

&#124; (b) &#124; 具有最大顶点数的 MST 直径最小 &#124;

&#124; (c) &#124; 不会导致环形成的边 &#124;

&#124; (d) &#124; 将新顶点添加到部分构建的 MST 中，使 MST 成本最小增加的情况。 &#124;

|

| 5. | 最小生成树问题使用以下策略 ____

&#124; (a) &#124; 贪心算法 &#124;

&#124; (b) &#124; 动态规划 &#124;

&#124; (c) &#124; 分治法 &#124;

&#124; (d) &#124; 以上都不是 &#124;

|

| 6. | 使用给定的图回答问题 a 到 c。 |
| --- | --- |

![](img/image-2452zn9w.jpg) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c)(c) (c) (c) (c)(c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c)(c) (c) (c) (c)(c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c) (c) (c)

| 7. | 以下哪个标准算法不是贪心算法？

&#124; (a) &#124; Dijkstra 最短路径算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Kruskal 算法 &#124;

&#124; (d) &#124; Huffman 编码 &#124;

&#124; (e) &#124; 贝尔曼-福特最短路径算法 &#124;

|

| 8. | 关于 Kruskal 和 Prim MST 算法，以下哪项是正确的？假设 Prim 使用二叉堆实现邻接表表示，而 Kruskal 使用按秩合并实现。

&#124; (a) &#124; 两种算法的最坏情况时间复杂度相同 &#124;

&#124; (b) &#124; Kruskal 的最坏情况时间复杂度优于 Prim &#124;

&#124; (c) &#124; Prim 的最坏情况时间复杂度优于 Kruskal &#124;

|

| 9. | Huffman 编码以下哪项是正确的？

&#124; (a) &#124; Huffman 编码在某些情况下可能会丢失信息 &#124;

&#124; (b) &#124; 在某些情况下，哈夫曼编码可能不是最优的无损编码。&#124;

&#124; (c) &#124; 在哈夫曼编码中，没有任何码字是其他码字的前缀。&#124;

&#124; (d) &#124; 所有上述 &#124;

|

| 10. | 假设字母 a, b, c, d, e, f 的概率分别为 1/2, 1/4, 1/8, 1/16, 1/32, 1/32。以下哪个是字母 a, b, c, d, e, f 的哈夫曼编码？

&#124; (a) &#124; 0, 10, 110, 1110, 11110, 11111 &#124;

&#124; (b) &#124; 11, 10, 011, 010, 001, 000 &#124;

&#124; (c) &#124; 11, 10, 01, 001, 0001, 0000 &#124;

&#124; (d) &#124; 110, 100, 010, 000, 001, 111 &#124;

|

| 11. | 假设字母 a, b, c, d, e, f 的概率分别为 1/2, 1/4, 1/8, 1/16, 1/32, 1/32。哈夫曼编码的平均长度是多少？

&#124; (a) &#124; 3 &#124; (b) &#124; 2.1875 &#124;

&#124; (c) &#124; 2.25 &#124; (d) &#124; 1.9375 &#124;

|

| 12. | 考虑下面的无向图： |
| --- | --- |

![](img/image-ht1ixyz1.jpg) 使用 Prim 算法构建以节点 A 开始的最小生成树，以下哪个边序列表示构建最小生成树时可能添加边的顺序？

| 13. | 一段文本由字符 a, b, c, d, e 组成，各自的概率分别为 0.11, 0.40, 0.16, 0.09 和 0.24。最优哈夫曼编码技术的平均长度是：

&#124; (a) &#124; 2.40 &#124; (b) &#124; 2.16 &#124;

&#124; (c) &#124; 2.26 &#124; (d) &#124; 2.15 &#124;

|

| 14. | 六个文件 F1, F2, F3, F4, F5 和 F6 分别有 100, 200, 50, 80, 120, 150 条记录。为了优化访问顺序，应该如何存储这些文件？假设每个文件的访问频率相同。

&#124; (a) &#124; F3, F4, F1, F5, F6, F2 &#124;

&#124; (b) &#124; F2, F6, F5, F1, F4, F3 &#124;

&#124; (c) &#124; F1, F2, F3, F4, F5, F6 &#124;

&#124; (d) &#124; 排序是不重要的，因为所有文件的访问频率相同。 &#124;

|

| 15. | 考虑一个作业调度问题，有 4 个作业 J1、J2、J3、J4，对应的截止时间为：(d1, d2, d3, d4) = (4, 2, 4, 2)。以下哪个不是一个可行的调度，而且没有违反任何作业调度？

&#124; (a) &#124; J2, J4, J1, J3 &#124;

&#124; (b) &#124; J4, J1, J2, J3 &#124;

&#124; (c) &#124; J4, J2, J1, J3 &#124;

&#124; (d) &#124; J4, J2, J3, J1 &#124;

|

| 16. | 什么是贪婪算法？ |
| --- | --- |
| 17. | 贪婪算法的用途是什么？ |
| 18. | 何时方便使用贪婪算法解决问题？ |
| 19. | 戴克斯特拉算法是贪婪算法还是动态规划算法？ |
| 20. | 贪婪算法的直观解释是什么？ |
| 21. | 我们为什么需要贪婪算法？ |
| 22. | 贪婪算法的最佳应用是什么？ |
| 23. | “贪婪”分类器是什么？ |
| 24. | 贪婪算法的特点是什么？ |
| 25. | 为什么这个贪婪算法无法准确确定图是否完全匹配？ |

| 26. | 克鲁斯卡尔算法执行以下哪些操作？

&#124; (i) &#124; 按长度递增顺序排序图 G 的边 &#124;

&#124; (ii) &#124; 保持图 G 的子图 S 最初为空 iii) 逐顶点构建树 &#124;

&#124; (a) &#124; 仅 i 和 ii &#124;

&#124; (b) &#124; 仅 ii 和 iii &#124;

&#124; (c) &#124; 仅 i 和 iii &#124;

&#124; (d) &#124; 全部 i、ii 和 iii &#124;

|

| 27. | 不是逐边构建子图，而是逐顶点构建树…………………………

&#124; (a) &#124; 克鲁斯卡尔算法 &#124;

&#124; (b) &#124; 普里姆算法 &#124;

&#124; (c) &#124; 戴克斯特拉算法 &#124;

&#124; (d) &#124; 贝尔曼-福特算法 &#124;

|

| 28. | ……………… 被称为贪心算法，因为它在每一步都选择添加到子图 S 的最便宜的边。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman Ford 算法 &#124;

|

| 29. | Prim 算法的结果是………………的总时间界限。

&#124; (a) &#124; O(logn) &#124;

&#124; (b) &#124; O(m+n logn) &#124;

&#124; (c) &#124; O(mn) &#124;

&#124; (d) &#124; O(m logn) &#124;

|

| 30. | 如果我们通过将(U,V)包含在到 V 的路径中来改进对 V 的最短路径的最佳估计，那么连接到顶点 U 的所有顶点 V 的成本将被更新。

&#124; (a) &#124; 松弛 &#124;

&#124; (b) &#124; 改进 &#124;

&#124; (c) &#124; 缩短 &#124;

&#124; (d) &#124; 成本估算 &#124;

|

| 31. | 原来可以在同一时间内从给定源到图中所有点找到最短路径。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman Ford 算法 &#124;

|

| 32. | ……………. 保留两组顶点；S，已经确定了从源到达的最短路径的顶点集和 V-S，其余顶点。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman Ford 算法 &#124;

|

| 33. | …………….. 是更广义的单源最短路径算法，它可以在具有负权边的图中找到最短路径。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman Ford 算法 &#124;

|

| 34. | 一个示例应用……算法的是解决关键路径问题，即找到 DAG 中的最长路径。

&#124; (a) &#124; DAG 应用路径算法 &#124;

&#124; (b) &#124; DAG 最短路径算法 &#124;

&#124; (c) &#124; DAG 关键路径算法 &#124;

&#124; (d) &#124; 贝尔曼-福特算法 &#124;

|

| 35. | 在有向图中，……………… 可以在 O(n³) 的时间内计算传递闭包。

&#124; (a) &#124; 传递闭包问题 &#124;

&#124; (b) &#124; 最小最大距离 &#124;

&#124; (c) &#124; 最大最小距离 &#124;

&#124; (d) &#124; 最安全路径 &#124;

|

| 36. | 在有向图中，……………… 可以在 O(n³) 的时间内计算传递闭包。

&#124; (a) &#124; 传递闭包问题 &#124;

&#124; (b) &#124; 最小最大距离 &#124;

&#124; (c) &#124; 最大最小距离 &#124;

&#124; (d) &#124; 最安全路径 &#124;

|

| 37. | ……………… 意味着，对于所有顶点，计算其可达性。

&#124; (a) &#124; 传递闭包问题 &#124;

&#124; (b) &#124; 最小最大距离 &#124;

&#124; (c) &#124; 最大最小距离 &#124;

&#124; (d) &#124; 最安全路径 &#124;

|

| 38. | 对于带有边长度的有向图，弗洛伊德-沃尔沙尔算法可以在 O(n³) 的时间内计算每对节点之间的 ………………。

&#124; (a) &#124; 传递闭包问题 &#124;

&#124; (b) &#124; 最小最大距离 &#124;

&#124; (c) &#124; 最大最小距离 &#124;

&#124; (d) &#124; 最安全路径 &#124;

|

| 39. | 给定一个有向图，其中边缘带有生存概率标签，我们可以使用弗洛伊德-沃尔沙尔算法计算两个节点之间的 ………………。

&#124; (a) &#124; 传递闭包问题 &#124;

&#124; (b) &#124; 最小最大距离 &#124;

&#124; (c) &#124; 最大最小距离 &#124;

&#124; (d) &#124; 最安全路径 &#124;

|

| 40. | ………………… 描述了计算 G^T 从 G 的有效算法，适用于 G 的邻接表和邻接矩阵表示。

&#124; (a) &#124; 图转置问题 &#124;

&#124; (b) &#124; 强连通分量问题 &#124;

&#124; (c) &#124; 拓扑排序问题 &#124;

&#124; (d) &#124; 欧拉路径问题 &#124;

|

| 41. | 在 …………… 输入是一个有向无环图（DAG）G=(V,E)。

&#124; (a) &#124; 图转置问题 &#124;

&#124; (b) &#124; 强连通分量问题 &#124;

&#124; (c) &#124; 拓扑排序问题 &#124;

&#124; (d) &#124; 欧拉路径问题 &#124;

|

| 42. | 在………………中，如果有向图 G 是无环的，那么对 G 进行 DFS 将不产生后向边。

&#124; (a) &#124; 图转置问题 &#124;

&#124; (b) &#124; 强连通分量问题 &#124;

&#124; (c) &#124; 拓扑排序问题 &#124;

&#124; (d) &#124; 欧拉路径问题 &#124;

|

| 43. | …………….. 是一种最广义的单源最短路径算法，即使在带负权重的图中也可以找到最短路径。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (C) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman-Ford 算法 &#124;

|

| 44. | ………………… 解决了在图中从一个点到目的地的最短路径问题。

&#124; (a) &#124; Kruskal 算法 &#124;

&#124; (b) &#124; Prim 算法 &#124;

&#124; (c) &#124; Dijkstra 算法 &#124;

&#124; (d) &#124; Bellman-Ford 算法 &#124;

|

| 45. | 贪婪算法的用途是什么？给出一个实际例子。 |
| --- | --- |
| 46. | 解释 Dijkstra 算法 |
| 47. | 解释 Prim 算法 |

[区块链的魅力](https://wiki.example.org/beauty_of_blockchain)MODULE VIIBlockchain 的魅力　章节 7 区块链的魅力
