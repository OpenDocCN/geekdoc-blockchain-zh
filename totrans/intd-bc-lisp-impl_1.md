© 作者授权 APress Media, LLC, Springer Nature 2021B. Sitnikovski 与 Lisp 介绍区块链[`doi.org/10.1007/978-1-4842-6969-5_1`](https://doi.org/10.1007/978-1-4842-6969-5_1)

# 1. 区块链简介

Boro Sitnikovski^(1  )(1)北马其顿斯科普里![../images/510363_1_En_1_Chapter/510363_1_En_1_Figa_HTML.jpg](img/510363_1_En_1_Figa_HTML.jpg)

*《区块链集市》，作者 D. Bozhinovski*

本章介绍了一些重要的区块链定义和示例。我们将看到区块链具有哪些属性，它允许我们做什么，以及它有什么用处。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figb_HTML.gif](img/510363_1_En_1_Figb_HTML.gif) 定义 1-1

**区块链** 是一个在多台计算机之间维护交易记录的系统，这些计算机连接在一个点对点网络中^(1)。

我们将提供一个示例，作为动机，并定义加密和哈希技术是什么，以及它们如何帮助我们的系统。

注意，在本章中，我们会简化一些技术细节，因为它作为介绍材料。当我们开始构建区块链时，技术细节将被揭示。

## 1.1 动机和基本定义

假设你和你的朋友经常交换钱，例如，在付账或喝酒时。一直用现金交换可能不太方便。

一个可能的解决方案是记录你和你的朋友所欠的所有账单。这被称为*分类账*，在图 1-1 中有所描述。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig1_HTML.jpg](img/510363_1_En_1_Fig1_HTML.jpg)

图 1-1

一个分类账和一组连接的朋友（同行）

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figc_HTML.gif](img/510363_1_En_1_Figc_HTML.gif) 定义 1-2

**分类帐**是一本包含交易记录的书籍。

此外，每天结束时，你们都会坐在一起并参考分类帐进行计算以结算账目。让我们想象一下，有一个罐子，那是存放所有钱的地方。如果你花费的比你收到的多，你就把钱放进罐子里；否则，你就拿出钱来。

我们希望设计一个类似于常规银行账户的系统。一个钱包的持有人（银行账户）只能从他们的钱包向其他钱包发送资金。因此，系统中的每个人都将拥有一种*钱包*，这也可以用来确定他们的余额。请注意，使用当前设置使用分类帐，我们必须查看所有现有记录才能确定特定钱包的余额。

如果我们想避免查看所有现有记录，我们可以通过使用*未花费的交易输出*（UTXOs）来优化，正如我们将在第 3.5 节中看到的那样。

可能出现的问题是所谓的*双重支付*问题，其中 Bob 可以试图同时向 Alice 和你发送所有的钱。这实际上会使他发送的金额翻倍。有几种方法可以解决这个问题，我们将提供的解决方案是对输入和输出（UTXO）的金额进行简单的检查。

这种类型系统可能出现的另一个问题是任何人都可以添加交易。例如，Bob 可以添加一笔交易，其中 Alice 向他支付几美元，而不需要 Alice 的批准。我们需要重新思考我们的系统，使每笔交易都经过验证/签名。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figd_HTML.gif](img/510363_1_En_1_Figd_HTML.gif) 定义 1-3

**数字签名**是验证数字消息和文档真实性的一种方式。

为了签署和验证交易，我们将依赖数字签名（图 1-2）。现在，让我们假设将信息添加到账本的任何人也都会在每个记录上添加一个签名，其他人无法修改签名，只能验证签名。我们将在 1.2 节中详细介绍技术细节。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig2_HTML.jpg](img/510363_1_En_1_Fig2_HTML.jpg)

图 1-2

我们的账本现在包含了签名

现在假设 Bob 将账本保留给自己，并且所有人都同意这一点。账本现在存储在所谓的*中心化位置*。如果当大家在一天结束时聚在一起结算时，Bob 不可用，那么没有人将能够参考账本。

我们需要找到一种去中心化账本的方法，以便在任何时候，任何人都可以进行交易。为此，每个参与者将保留账本的副本，并在一天结束时同步他们的账本。

你和你的朋友们连接在一起，他们也连接在你身上。非正式地说，这使得它成为一个点对点网络。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Fige_HTML.gif](img/510363_1_En_1_Fige_HTML.gif) 定义 1-4

当两台或更多计算机相互连接时，形成了一个**点对点网络**。

例如，当你使用浏览器在互联网上访问网页时，你的浏览器是“客户端”，而你正在访问的网页是由“服务器”托管的。这代表着一种集中化系统，因为每个用户都是从一个地方——“服务器”获取信息的。

在对比之下，在点对点网络——代表着一种分散化系统——“客户端”和“服务器”的区分变得模糊。每个对等方同时是“客户端”和“服务器”。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig3_HTML.jpg](img/510363_1_En_1_Fig3_HTML.jpg)

图 1-3

一个去中心化账本

在一个去中心化系统中（参见图 1-3），随着节点（人员）列表的增长，我们可能会遇到*信任*问题。当每个人在一天结束时同步他们的账本时，他们如何相信其他人账本中列出的交易是真实的？即使每个人都相信其他人的账本，但如果一个新人想要加入这个网络呢？现有用户自然会要求这位新来者证明他们是可信的。我们需要修改我们的系统以支持这种信任。我们引入*工作证明*，是实现这种信任的一种方式，接下来我们会介绍它。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figf_HTML.gif](img/510363_1_En_1_Figf_HTML.gif) 定义 1-5

**工作证明**是一种耗时计算的数据，易于他人验证。

对于每条记录，我们还将包括一个特殊的数字（或哈希），它将表示*工作证明*，即它将提供证明交易是有效的。我们将在第 1.3 节中详细介绍技术细节。

在一天结束时，我们同意我们将信任将大部分工作投入其中的人的账本。如果 Bob 有一些差事要处理，他可以在第二天通过相信网络中的其他节点来赶上进度。

除此之外，我们希望交易有一个顺序，因此每条记录还将包含到前一条记录的链接。这代表了实际的区块链，如图 1-4 所示。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig4_HTML.jpg](img/510363_1_En_1_Fig4_HTML.jpg)

图 1-4

一个区块链，恰如其名

如果每个人都同意使用这个账本作为真相的来源，那么根本就不需要交换实体货币。每个人只需使用账本来存入或取回钱。

为了理解数字签名和工作证明的技术细节，我们将分别查看加密和哈希。幸运的是，我们将使用的编程语言内置了加密和哈希的功能。我们不必深入研究哈希、加密和解密的工作原理，因为基本的理解就足够了。

观察我们是如何从简单的分类账定义逐渐发展成一个复杂系统的。我们在编程中将采用相同的方法。

## 1.2 加密

我们将首先定义加密和解密。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figg_HTML.gif](img/510363_1_En_1_Figg_HTML.gif) 定义 1-6

**加密**是一种编码值的方法，只有授权人员才能查看原始内容。**解密**是解码加密值的方法。

注意，在这一节中，我们将主要讨论数字，但字符和字母也可以使用相同的方法进行加密/解密，即使用字符的 ASCII^(2)值。

在我们讨论加密之前，我们首先要回忆一下 *函数* 是什么，因为编码/解码值是通过使用函数实现的。

### 1.2.1 函数

图 1-5 显示了一个函数的可视表示。输入进入函数，产生一个输出。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig5_HTML.jpg](img/510363_1_En_1_Fig5_HTML.jpg)

图 1-5

一个函数

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figh_HTML.gif](img/510363_1_En_1_Figh_HTML.gif) 定义 1-7

**函数**是将给定的输入分配给唯一输出的数学实体。

例如，您可能有一个接受人员作为输入然后返回人员年龄或姓名作为输出的函数。另一个例子是函数 f(x) = x + 1。这个函数可以接受许多输入：1、2 和 3.14。例如，当我们输入 2 时，它会给我们一个输出 3，因为 f(2) = 2 + 1 = 3。

一种简单的理解函数的方式是以表格形式呈现。对于接受单个参数 *x* 的函数 f(x)，我们有一个两列的表格，第一列是输入，第二列是输出。对于接受两个参数 *x* 和 *y* 的函数 f(x, y)，我们有一个三列的表格，其中第一列和第二列表示输入，第三列是输出。因此，要以表格形式显示上述讨论的函数，它看起来像这样：

| **x** | ***f*****(*****x*****)** |
| --- | --- |
| 1 | 2 |
| 2 | 3 |
| … | … |

### 1.2.2 对称密钥算法

我们可以假设存在加密函数 *E*(*x*) 和解密函数 *D*(*x*)。我们希望这些函数具有以下属性：

+   *E*(*x*) ≠ *x*，意味着加密后的值不应该与原始值相同。

+   *E*(*x*) ≠ *D*(*x*)，意味着加密和解密函数生成不同的值。

+   *D*(*E*(*x*)) = *x*，意味着加密值的解密应该返回原始值。

例如，假设有一种加密方案，比如 E(“Boro”) = 426f726f。我们可以“安全地”传递值 426f726f，而不会实际暴露我们的原始值，只有那些知道解密方案 D(x) 的人才能看到 D(426f726f) = “Boro”。

另一个加密方案的例子是 *E*(*x*) 将 *x* 中的每个字符向前移动，*D*(*x*) 将 *x* 中的每个字符向后移动。这种方案称为凯撒密码。要加密文本 “abc”，我们有 E(“abc”) = “bcd”，要解密它，我们有 D(“bcd”) = “abc”。

然而，这个方案制造了一个*对称算法*，如图 1-6 所示，这意味着我们必须与涉及的各方分享函数 E 和 D。这使得它容易受到攻击。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig6_HTML.jpg](img/510363_1_En_1_Fig6_HTML.jpg)

图 1-6

对称密钥算法

### 1.2.3 非对称密钥算法

为了解决对称密钥算法引发的问题，我们将使用所谓的*非对称算法*或*公钥密码*（见图 1-7）。在这个方案中，我们有两种类型的密钥：公钥和私钥。我们与世界分享公钥，并保留私钥给自己。

这个算法方案具有一个很好的属性，即只有私钥才能解码消息，而只有公钥才能编码消息。

我们有两个函数，应该具有与对称密钥算法相同的属性：

+   *E*(*x*, *p*) 用公钥 *p* 加密消息 *x*

+   *D*(*x*′, *s*) 解密使用私钥（秘密） *s* 加密的消息 *x*′

![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig7_HTML.jpg](img/510363_1_En_1_Fig7_HTML.jpg)

图 1-7

非对称密钥算法

在我们的示例中，我们将依赖于模运算。回想一下，从高中开始，*a* mod *b* 表示当 *a* 被 *b* 整除时的余数。例如，4 mod 2 = 0，因为当 4 除以 2 时没有余数，然而，5 mod 2 = 1。

这是一个基于加法和模运算的基本加密算法的示例：

1.  1.

    选择一个随机数，例如 100。这将代表一个常见的，公开可用的密钥。

1.  2.

    在范围 (1, 100) 中选择另一个随机数，例如，97。这将代表私钥 *s*。

1.  3.

    公钥 *p* 是通过从私钥中减去常见密钥得到的：100 − 97 = 3。

1.  4.

    要加密数据，将其加到公钥上，然后取模 100。*E*(*x*, *p*) = (*x* + *p*) mod 100。

1.  5.

    要解密数据，我们使用相同的逻辑，但是使用我们的私钥，所以 *D*(*x*′, *s*) = (*x*′ + *s*) mod 100。

例如，假设我们想要加密 5。那么 *E*(5, 3) = (5 + 3) mod 100 = 8。要解密 8，我们有 *D*(8, 97) = (8 + 97) mod 100 = 105 mod 100 = 5。

这个例子使用了一个非常简单的生成对：(*x* + *y*) mod *c*。但是，在实践中，生成对算法要复杂得多，对攻击者更难以突破。毕竟，算法计算的复杂性是导致其难以破解的原因。

我们可以使用类似的算法进行数字签名：

+   *S*(*x*, *s*) 使用私钥 *s* 对消息 *x* 进行签名（加密）。

+   *V*(*x*′, *sig*, *p*) 使用签名 *sig* 和公钥 *p* 验证已签名的消息 *x*′（解密）。

正如我们之前所说，每个记录还将包括一个特殊数字（或哈希）。这个哈希将由 *S*(*x*, *s*)（加密）生成，并且可以通过使用验证函数来确认记录的所有权（解密）。

钱包将包含一对公钥和私钥。这些密钥将用于接收或发送货币。有了私钥，就可以向区块链写入新块（或交易），有效地花费货币。有了公钥，其他人可以使用它向钱包发送货币并验证签名。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figi_HTML.gif](img/510363_1_En_1_Figi_HTML.gif) 练习 1-1

想出一个函数表，使得：

1.  1.

    输入是一个数字，输出也是一个数字。

1.  2.

    输入是一个数字，输出是公司员工的名字，给定该数字。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figj_HTML.gif](img/510363_1_En_1_Figj_HTML.gif)**练习 1-2**

检查对称密钥算法的三个属性，以确保凯撒密码与它们兼容。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figk_HTML.gif](img/510363_1_En_1_Figk_HTML.gif)**练习 1-3**

设计一种基于数学替换的加密方案。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figl_HTML.gif](img/510363_1_En_1_Figl_HTML.gif)**练习 1-4**

使用我们定义的非对称密钥算法对消息进行签名和验证。

**提示**：这类似于我们展示的加密/解密示例。

## 1.3 哈希运算

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figm_HTML.gif](img/510363_1_En_1_Figm_HTML.gif)

定义 1-8

**哈希运算**是一种单向函数，它对文本进行编码，没有办法检索到原始值。

哈希运算比之前描述的加密方案更简单。一个哈希函数的例子是返回字符长度的函数 - *H*（“abc”）= 3，但是 *H*（“bcd”）= 3。这意味着我们没有办法通过除了使用返回值 3 之外的其他方式检索原始值。

正如我们之前提到的，使用这种技术的原因是它具有一些有趣的特性，比如为我们提供工作证明。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Fign_HTML.gif](img/510363_1_En_1_Fign_HTML.gif) 定义 1-9

**挖矿**是验证交易的过程。成功的挖矿者将获得货币作为奖励。

Hashcash 是一种工作量证明系统的一种。^(3) 我们将使用它来实现挖矿。在后面的章节中，当我们实现它时，我们将详细了解此算法的工作原理。

哈希函数还有另一个有用的属性，允许我们通过在每个块中具有当前块哈希（current-hash）和前一个块哈希（previous-hash）的信息来连接两个或更多不同的块。例如，block-1 可能有一个哈希值，如 123456，而 block-2 可能有一个哈希值，如 345678。现在，block-2 的 previous-hash 将是 block-1 的 current-hash，也就是 123456。在这里，我们链接了这两个块，有效地创建了一个包含交易账本的块链。此链接在图 1-4 中显示。

块的哈希基于块的数据本身，因此要验证哈希，我们只需哈希块的数据并将其与 current-hash 进行比较。

两个或更多连接的块（或交易）形成一个区块链。区块链的有效性将取决于每个交易的有效性。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figo_HTML.gif](img/510363_1_En_1_Figo_HTML.gif) 练习 1-5

想出自己的哈希函数。

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figp_HTML.gif](img/510363_1_En_1_Figp_HTML.gif) 练习 1-6

图 1-4 中所示的链表如何遍历？这一特性的含义是什么？

## 1.4 智能合约

![../images/510363_1_En_1_Chapter/510363_1_En_1_Figq_HTML.gif](img/510363_1_En_1_Figq_HTML.gif) 定义 1-10

**智能合约**是一种自执行的合约，其中买方和卖方之间的协议条件直接由代码行表达。

如果交易条件本身可以由用户编程，则区块链是可编程的。例如，用户（不一定是程序员）可以编写一个脚本，以添加在发送资金之前必须满足的要求。它可能看起来像这样：1   if（用户拥有超过 10 个货币）2      then 批准交易 3      else 拒绝交易

智能合约作为在区块链上进行的计算实现。我们将在后面的章节中实现智能合约的基本功能。

## 1.5 比特币

比特币是世界上第一个区块链的实现。2008 年 11 月，中本聪（Satoshi Nakamoto）在一个密码学邮件列表上发表了一篇题为《比特币：一个点对点的电子现金系统》的论文。比特币的白皮书有九页，但它主要是对设计的理论解释，对新手来说可能有点压倒性。

比特币软件是开源代码，于 2009 年 1 月在 SourceForge 上发布。比特币的设计包括一个分散网络（点对点网络）、区块（挖矿）、区块链、交易和钱包，我们将在本书中详细讨论每个部分。

尽管有许多区块链模型，每个模型在实现细节上都有所不同，但我们在本书中将建立在比特币基础上的区块链看起来与比特币相似，只是有些部分被简化了。

## 1.6 示例工作流程

我们将列举一些重要的工作流程，这些工作流程是我们的系统将要使用的，除此之外还有其他的。

挖掘一个区块将创建一个新区块，使用 Hashcash 计算当前区块的哈希值。它还包含了先前的哈希值，这是链中上一个区块的链接。

对于个人 A 检查钱包余额，首先会过滤区块链中的所有区块（发送方=A 或接收方=A），然后将它们求和以计算余额。我们的区块链增长得越多，这个操作就会花费越长的时间。为此，我们将使用未花费交易输出（UTXO）模型。该模型是一个包含有关所有者和金额的交易列表。因此，每个交易都将消耗该列表中的元素。

*向区块链添加一个区块*包括将钱从 A 转移到 B。一个先决条件是 A 有足够的钱。我们使用钱包余额工作流来检查这一点。我们通过创建一个交易（发送方 = A，接收方 = B）并对其进行签名来进行。然后我们使用此交易挖掘一个区块，并使用奖励更新 UTXO。

## 1.7 总结

本章的重点是提供一个大致的系统实现的概念。在实施章节（第三章）中，我们将明确定义每个组件的定义，事情会变得更加清晰。

这是我们在本章中学到的内容的简要概述：

+   系统的核心组件是一个区块。

+   一个区块包含（除其他数据外）交易。

+   我们有一个按顺序排列的所有有效区块的分类账（区块链）。

+   参与分类账的每个对等方都有一个钱包。

+   分类账中的每条记录都由所有者签名，并可以由公众验证（数字签名）。

+   分类账位于分散的位置，即每个人都有其副本。

+   信任基于工作证明（挖矿）。
