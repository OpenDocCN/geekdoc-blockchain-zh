["```\n// C program to implement Playfair Cipher\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define SIZE 30\n\n// convert the string to lowercase\nvoid toLowerCase(char plain[], int ps)\n{\n    int i;\n    for (i = 0; i < ps; i++) {\n        if (plain[i] > 64 && plain[i] < 91)\n            plain[i] += 32;\n    }\n}\n\n// remove all spaces in the string\nint format(char* plain, int ps)\n{\nint i, count = 0; \n    for (i = 0; i < ps; i++)\n        if (plain[i] != ' ')\n            plain[count++] = plain[i];\n    plain[count] = '\\0';\n    return count;\n}\n\n// generate the 5x5 key square\nvoid generate(char key[], int ks, char keyT[5][5])\n{\n    int i, j, k, flag = 0, *dicty;\n\n    dicty = (int*)calloc(26, sizeof(int));\n    for (i = 0; i < ks; i++) {\n        if (key[i] != 'j')\n            dicty[key[i] - 97] = 2;\n    }\n\n    dicty['j' - 97] = 1;\n\n    i = 0;\n    j = 0;\n\n    for (k = 0; k < ks; k++) {\n        if (dicty[key[k] - 97] == 2) {\n            dicty[key[k] - 97] -= 1;\n            keyT[i][j] = key[k];\n            j++;\n            if (j == 5) {\n                i++;\n                j = 0;\n            }\n        }\n    }\n    for (k = 0; k < 26; k++) {\n        if (dicty[k] == 0) {\n            keyT[i][j] = (char)(k + 97);\n            j++;\n            if (j == 5) {\n                i++;\nj = 0; \n            }\n        }\n    }\n}\n\n// search for the characters of digraph\nin the key square and return their // position\nvoid search(char keyT[5][5], char a, char b, int arr[])\n{\n    int i, j;\n\n    if (a == 'j')\n        a = 'i';\n    else if (b == 'j')\n        b = 'i';\n\n    for (i = 0; i < 5; i++) {\n\n        for (j = 0; j < 5; j++) {\n\n            if (keyT[i][j] == a) {\n                arr[0] = i;\n                arr[1] = j;\n            }\n            else if (keyT[i][j] == b) {\n                arr[2] = i;\n                arr[3] = j;\n            }\n        }\n    }\n}\n// find the modulus with 5\nint mod5(int a) { return (a % 5); }\n// make the plaintext length even\nint make even(char str[], int ptrs)\n{\n    if (ptrs % 2 != 0) {\n        str[ptrs++] = 'z';\n        str[ptrs] = '\\0';\n    }\n    return ptrs;\n} \n// perform encryption\nvoid encrypt(char str[], char keyT[5][5], int ps)\n{\n    int i, a[4];\n\n    for (i = 0; i < ps; i += 2) {\n\n        search(keyT, str[i], str[i + 1], a);\n\n        if (a[0] == a[2]) {\n            str[i] = keyT[a[0]][mod5(a[1] + 1)];\n            str[i + 1] = keyT[a[0]][mod5(a[3] + 1)];\n        }\n        else if (a[1] == a[3]) {\n            str[i] = keyT[mod5(a[0] + 1)][a[1]];\n            str[i + 1] = keyT[mod5(a[2] + 1)][a[1]];\n        }\n        else  {\n            str[i] = keyT[a[0]][a[3]];\n            str[i + 1] = keyT[a[2]][a[1]];\n        }\n    }\n}\n\n//encrypt using Playfair Cipher\nvoid encryptByPlayfairCipher(char str[], char key[])\n{\n    char ps, ks, keyT[5][5];\n\n    // Key\n    ks = strlen(key);\n    ks = format(key, ks);\n    LowerCase(key, ks);\n\n    // Plaintext\n    ps = strlen(str);\n    LowerCase(str, ps);\n    ps = format(str, ps);\n\nps = make even(str, ps); \n\n    generate(key, ks, keyT);\n\n    encrypt(str, keyT, ps);\n}\nint main()\n{\n    char str[SIZE], key[SIZE];\n\n    // Key to be encrypted\n    strcpy(key, \"Monarchy\");\n    printf(\"Key text: %s\\n\", key);\n\n    // Plaintext to be encrypted\n    strcpy(str, \"ambidextrous\");\n    printf(\"Plaintext: %s\\n\", str);\n\n    // encrypt using Playfair Cipher\n    encryptByPlayfairCipher(str, key);\n\n    printf(\"Ciphertext: %s\\n\", str);\n\n    return 0;\n}\n\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define SIZE 30\n\n// convert all characters\nof string to lowercase\nvoid LowerCase(char plain[], int ps)\n{\n    int i;\n    for (i = 0; i < ps; i++) {\n        if (plain[i] > 64 && plain[i] < 91)\n            plain[i] += 32;\n    }\n}\n\n// remove all spaces in a string\n// remove punctuation\nint format(char* plain, int ps)\n{\n    int i, count = 0;\n    for (i = 0; i < ps; i++)\n        if (plain[i] != ' ')\n            plain[count++] = plain[i];\n    plain[count] = '\\0';\n    return count;\n}\n\n// generates the 5x5 key square\nvoid generate(char key[], int ks, char keyT[5][5])\n{\n    int i, j, k, flag = 0, *dicty;\n\n    dicty = (int*)calloc(26, sizeof(int));\n    for (i = 0; i < ks; i++) {\n        if (key[i] != 'j')\n            dicty[key[i] - 97] = 2;\n    }\n    dicty['j' - 97] = 1;\n    i = 0;\n    j = 0;\nfor (k = 0; k < ks; k++) { \n        if (dicty[key[k] - 97] == 2) {\n            dicty[key[k] - 97] -= 1;\n            keyT[i][j] = key[k];\n            j++;\n            if (j == 5) {\n                i++;\n                j = 0;\n            }\n        }\n    }\n    for (k = 0; k < 26; k++) {\n        if (dicty[k] == 0) {\n            keyT[i][j] = (char)(k + 97);\n            j++;\n            if (j == 5) {\n                i++;\n                j = 0;\n            }\n        }\n    }\n}\n\n// search for the characters of a digraph\n// in the key square and return their position\nvoid search(char keyT[5][5], char a, char b, int arr[])\n{\n    int i, j;\n    if (a == 'j')\n        a = 'i';\n    else if (b == 'j')\n        b = 'i';\n\n    for (i = 0; i < 5; i++) {\n        for (j = 0; j < 5; j++) {\n            if (keyT[i][j] == a) {\n                arr[0] = i;\n                arr[1] = j;\n            }\n            else if (keyT[i][j] == b) {\n                arr[2] = i;\n                arr[3] = j;\n} \n        }\n    }\n}\n\n// find the modulus with 5\nint mod5(int a)\n{\n    if (a < 0)\n        a += 5;\n    return (a % 5);\n}\nvoid decrypt(char str[], char keyT[5][5], int ps)\n{\n    int i, a[4];\n    for (i = 0; i < ps; i += 2) {\n        search(keyT, str[i], str[i + 1], a);\n        if (a[0] == a[2]) {\n            str[i] = keyT[a[0]][mod5(a[1] - 1)];\n            str[i + 1] = keyT[a[0]][mod5(a[3] - 1)];\n        }\n        else if (a[1] == a[3]) {\n            str[i] = keyT[mod5(a[0] - 1)][a[1]];\n            str[i + 1] = keyT[mod5(a[2] - 1)][a[1]];\n        }\n        else {\n            str[i] = keyT[a[0]][a[3]];\n            str[i + 1] = keyT[a[2]][a[1]];\n        }\n    }\n}\n\nvoid decryptByPlayfairCipher(char str[], char key[])\n{\n    char ps, ks, keyT[5][5];\n\n    // Key\n    ks = strlen(key);\n    ks = format(key, ks);\n    LowerCase(key, ks);\n\n// ciphertext \n    ps = strlen(str);\n    LowerCase(str, ps);\n    ps = format(str, ps);\n\n    generate(key, ks, keyT);\n\n    decrypt(str, keyT, ps);\n}\nint main()\n{\n    char str[SIZE], key[SIZE];\n    // Key to be encrypted\n    strcpy(key, \"Monarchy\");\n    printf(\"Key text: %s\\n\", key);\n\n    // Ciphertext to be decrypted\n    strcpy(str, \"rhitxsfpdvoz\");\n    printf(\"Plaintext: %s\\n\", str);\n\n    // encrypt using Playfair Cipher\n    decryptByPlayfairCipher(str, key);\n\n    printf(\"Deciphered text: %s\\n\", str);\n\n    return 0;\n}\n\n```", "```\n// C++ code to implement Hill Cipher\n#include <iostream>\nusing namespace std;\n\nvoid getMatrix(string key, int Matrix[][3])\n{\n    int k = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            Matrix[i][j] = (key[k]) % 65;\n            k++;\n        }\n    }\n}\n\n// encrypt the message\nvoid encrypt(int cipher[][1],\n            int Matrix[][3],\n            int message[][1])\n{\n    int x, i, j;\n    for (i = 0; i < 3; i++)\n    {\n        for (j = 0; j < 1; j++)\n        {\n            cipher[i][j] = 0;\n\n            for (x = 0; x < 3; x++)\n            {\n                cipher[i][j] +=\n                    Matrix[i][x] * message[x][j];\n            }\n            cipher[i][j] = cipher[i][j] % 26;\n        }\n    }\n}\n\n// implement Hill Cipher\nvoid HillCipher(string message, string key)\n{\n    // Get key matrix\n    int Matrix[3][3];\n    getKeyMatrix(key, Matrix);\n\n    int message[3][1];\n\n    // Generate vector for the message\n    for (int i = 0; i < 3; i++)\n        message[i][0] = (message[i]) % 65;\n\n    int cipher[3][1];\n\n    // generate\n    the encrypted vector\n    encrypt(cipher, Matrix, message);\n\n    string CipherText;\n\n    // generate the encrypted text from\n    // the encrypted vector\n    for (int i = 0; i < 3; i++)\n        CipherText += cipher[i][0] + 65;\n\n    cout << \"result:\" << CipherText;\n}\n\nint main()\n{\n    // Get the message to be encrypted\n    string message = \"ACT\";\n\n    // Get the key\n    string key = \"GYBNQKURP\";\n\n    HillCipher(message, key);\n\n    return 0;\n}\n\n```", "```\n// C program for RSA asymmetric cryptographic\n// algorithm.\n#include<stdio.h>\n#include<math.h>\nint gcd(int a, int h)\n{\n    int temp;\n    while (1)\n    {\n        temp = a%h;\n        if (temp == 0)\n        return h;\n        a = h;\n        h = temp;\n    }\n}\n\nint main()\n{\n    // random prime numbers\n    double p = 3;\n    double q = 7;\n\n    // first step for public key:\n    double n = p*q;\n\n    // next step for public key.\n    // e - > encrypt\n    double e = 2;\n    double phi = (p-1)*(q-1);\n    while (e < phi)\n    {\n        // e is co-prime to phi and\n        smaller than phi.\n        if (gcd(e, phi)==1)\n            break;\n        else\n            e++;\n    }\n    // Private key (d - > decrypt)\n    // choosing d such that it satisfies\n    // d*e = 1 + k * totient\n    int k = 2; // any constant value\n    double d = (1 + (k*phi))/e;\n\n    // Message to be encrypted\n    double msg = 20;\n\n    printf(\"data = %lf\", msg);\n\n    // Encryption c = (msg ^ e) % n\n    double c = pow(msg, e);\n    c = fmod(c, n);\n    printf(\"\\nEncrypted data = %lf\", c);\n    // Decryption m = (c ^ d) % n\n    double m = pow(c, d);\n    m = fmod(m, n);\n    printf(\"\\nOriginal Message = %lf\", m);\n\n    return 0;\n}\n\n```", "```\n#include <stdio.h>\n#include <gmp.h>\n\nint main {\nmpz_t x, y, result;\n\nmpz_init_set_str(x, \"7612058254738945\", 10);\nmpz_init_set_str(y, \"9263591128439081\", 10);\nmpz_init(result);\n\nmpz_mul(result, x, y);\ngmp_printf(\" %Zd\\n\"\n        \"*\\n\"\n        \" %Zd\\n\"\n        \"--------------------\\n\"\n        \"%Zd\\n\", x, y, result);\n/* free used memory */\nmpz_clear(x);\nmpz_clear(y);\nmpz_clear(result);\n\nreturn 0;\n}\n\n```", "```\n# find the gcd of two\n# integers using Euclidean algorithm\ndef gcd(p, q):\n\n    if q == 0:\n        return p\n\n    return gcd(q, p % q)\n\n# find the\nlcm of two integers\ndef lcm(p, q):\n    return p * q / gcd(p, q)\n\n# implementing extended\n# Euclidean algorithm\ndef ext gcd(e, phi):\n\n    if e == 0:\n        return (phi, 0, 1)\n    else:\n        g, y, x = ext gcd(phi % e, e)\n        return (g, x - (phi // e) * y, y)\n\n# compute the modular inverse\ndef modinv(e, phi):\n\n    g, x, y = ext gcd(e, phi)\n    return x % phi\n\n# Implement Chinese Remainder Theorem\ndef implement(dq, dp, p, q, c):\n\n    # Message part 1\n    m1 = pow(c, dp, p)\n\n    # Message part 2\n    m2 = pow(c, dq, q)\n\n    qinv = modinv(q, p)\nh = (qinv * (m1 - m2)) % p \n    m = m2 + h * q\n    return m\n\np = 9817\nq = 9907\ne = 65537\nc = 36076319\nd = modinv(e, lcm(p - 1, q - 1))\n\n\"\"\"\n\npow(a, b, c) calculates a raised to power b\nmodulus c much faster than pow(a, b) % c\nuse Chinese Remainder Theorem as it\nsplits the equation to calculate two\nvalues whose equations have smaller moduli and exponent\nvalue, thereby reducing computing time.\n\"\"\"\n\ndq = pow(d, 1, q - 1)\ndp = pow(d, 1, p - 1)\nprint implement(dq, dp, p, q, c)\n\n```", "```\n// Java program to calculate SHA-512 hash value\n\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Sha {\n    public static String encrypt(String input)\n{\n        try {\n            // getInstance() method is called with\nalgorithm SHA-512\n            MessageDigest md = MessageDigest.\ngetInstance(\"SHA-512\");\n\n            // digest() method is called\n            // to calculate message digest of the input\nstring\n            // returned as array of byte\n            byte[] messageDigest = md.digest(input.\ngetBytes());\n\n            // Convert byte array into signum\nrepresentation\n            BigInteger no = new BigInteger(1,\nmessageDigest);\n            // Convert message digest into hex value\n            String hashtext = no.toString(16);\n\n            // Add preceding 0s to make it 32 bit\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n\n            // return the HashText\n            return hashtext;\n        }\n\n        // For specifying wrong message digest\nalgorithms\ncatch (NoSuchAlgorithmException e) { \n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void main(String args[]) throws\nNoSuchAlgorithmException\n    {\n\n        System.out.println(\"HashCode Generated by\nSHA-512 for: \");\n\n        String s1 = \"Hello\";\n        System.out.println(\"\\n\" + s1 + \" : \" +\nencrypt(s1));\n\n        String s2 = \"hello world\";\n        System.out.println(\"\\n\" + s2 + \" : \" +\nencrypt(s2));\n    }\n}\n\n```"]