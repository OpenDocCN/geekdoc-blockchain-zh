- en: '[CHAPTER 10](toc.xhtml#c10)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第10章](toc.xhtml#c10)'
- en: '[Create and Validate Transactions](toc.xhtml#c10)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[创建和验证交易](toc.xhtml#c10)'
- en: In the previous chapter, you learned about Wallets, Private Keys, Public Keys,
    and Addresses and understood how to generate them. You learned to create a Hierarchical
    Deterministic wallet and understood how HD wallets simplify the generation of
    private keys, public keys, and addresses, and help us secure our wallets and simplify
    the management of our privacy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你学习了关于钱包、私钥、公钥和地址的知识，并理解了如何生成它们。你学会了创建一个分层确定性钱包，并理解了HD钱包如何简化私钥、公钥和地址的生成，帮助我们保护钱包并简化隐私管理。
- en: The most fundamental reason why Bitcoin exists is to transfer and store value.
    This means when you pay bitcoin to another person, bitcoin have to move from your
    wallet to the other person’s wallet. And if you don’t transfer bitcoin from your
    wallet to another person’s wallet, it has to sit in your wallet as long as you
    want. Additionally, when the other person receives bitcoin, they should be able
    to send a portion of it to yet another person or add additional bitcoin while
    sending.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币存在最根本的原因是为了传输和存储价值。这意味着当你向另一个人支付比特币时，比特币必须从你的钱包转移到另一个人的钱包。如果你不将比特币从你的钱包转移到另一个人的钱包，它就会一直呆在你的钱包里直到你愿意。另外，当另一个人收到比特币时，他们应该能够将其的一部分发送给另一个人，或者在发送时添加额外的比特币。
- en: We transfer bitcoin by creating transactions and publishing them to the network.
    Even though we create transactions to pay to the other person, the transaction
    is not just known to us; it is known to everyone on the network. It’s like making
    a payment and then shouting so that everyone knows that the transaction is done.
    So, everyone on the network is a witness to the transaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建交易并将它们发布到网络上来传输比特币。尽管我们创建交易以支付给另一个人，但交易不仅为我们所知；它为网络上的每个人所知。这就像付款后大声喊叫，以便每个人都知道交易已经完成。因此，网络上的每个人都是交易的见证人。
- en: In this chapter, our focus will be on transactions. We will parse a real transaction
    in a block and learn about its format and scripting language and verify the signature.
    We will then build our own transaction and publish it over the network. We will
    also look at common transaction types and ways to secure them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的重点将放在交易上。我们将解析一个区块中的真实交易，并学习其格式和脚本语言以及验证签名。然后我们将构建我们自己的交易并将其发布到网络上。我们还将查看常见的交易类型和保护交易的方法。
- en: '[Structure](toc.xhtml#s213a)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s213a)'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Scripting Bitcoin transactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写比特币交易脚本
- en: OPCODES
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OPCODES
- en: Signature verification
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名验证
- en: Hash type – SIGHASH_ALL
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希类型 – SIGHASH_ALL
- en: Hash type – SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希类型 – SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY
- en: Standard Bitcoin script – P2PK
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准比特币脚本 – P2PK
- en: Standard Bitcoin script – P2PKH
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准比特币脚本 – P2PKH
- en: '![](images/ent.jpg) Prepare signature preimage'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![](images/ent.jpg) 准备签名预图像'
- en: Standard Bitcoin script – P2MS
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准比特币脚本 – P2MS
- en: Standard Bitcoin script – P2SH
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准比特币脚本 – P2SH
- en: Building transactions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建交易
- en: Building P2PKH transaction
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建P2PKH交易
- en: Building P2SH transaction
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建P2SH交易
- en: '[Objectives](toc.xhtml#s214a)'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[目标](toc.xhtml#s214a)'
- en: The objective of this chapter is to help readers learn to verify and create
    a transaction. In this chapter, you will learn about the scripting language used
    by the blockchain to fund a transaction and secure the fund at the destination
    address. You will also learn how a transaction is verified by a node. You will
    then learn to create a transaction and publish it over the Bitcoin network.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助读者学习验证和创建交易。在本章中，你将学习区块链用于资助交易和保护目的地地址的脚本语言。你还将学习节点如何验证交易。然后你将学会创建交易并将其发布到比特币网络。
- en: You will learn how the Bitcoin script gets executed, and you will also learn
    about the most used scripts and understand them in detail, both in transaction
    verification and transaction creation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习比特币脚本是如何执行的，你还将学习最常用的脚本并详细了解它们，无论是在交易验证还是交易创建中。
- en: '[Scripting Bitcoin transactions](toc.xhtml#s215a)'
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[编写比特币交易脚本](toc.xhtml#s215a)'
- en: 'Bitcoin transactions have two sections: inputs and outputs. Input consists
    of unlocking script called `**scriptSig**`, and output consists of a locking script
    called `**scriptPubKey**`. Script `**scriptSig**` normally consists of signature
    required to unlock previously locked transaction and public-key or script to allow
    verification of the signature. Script `**scriptPubKey**` is based on the name
    of an earlier script called *P2PK* or *Pay-2-Pubkey*. Now, the *P2PK* script is
    not recommended and is rarely used. So, `**scriptPubKey**` is a misnomer now.
    Currently, *P2PKH, P2SH, P2SH-P2WPKH*, and *P2SH-P2WSH* are the most used scripts.
    Here, *W* denotes witness, which was introduced as part of s*egregated* w*itness*
    enhancement. We have a separate chapter to cover it in detail, so we will not
    cover s*egregated* w*itness* in this chapter.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Bitcoin 交易有两个部分：输入和输出。输入包括一个称为`**scriptSig**`的解锁脚本，输出包括一个称为`**scriptPubKey**`的锁定脚本。脚本`**scriptSig**`通常包括解锁先前锁定的交易所需的签名和公钥或脚本，以允许验证签名。脚本`**scriptPubKey**`基于一个早期脚本的名称，称为*P2PK*或*Pay-2-Pubkey*。现在，*P2PK*脚本不再推荐使用，且很少使用。因此，`**scriptPubKey**`现在是名副其实的。目前，最常用的脚本有*P2PKH,
    P2SH, P2SH-P2WPKH*和*P2SH-P2WSH*。在这里，*W*表示见证人，它是在s*egregated* w*itness*增强部分引入的。我们有一个单独的章节来详细介绍它，所以我们不会在本章中涵盖s*egregated*
    w*itness*。
- en: To verify the script portion of a transaction, `**scriptSig**` is executed first,
    and then `**scriptPubKey**` is executed in sequence. The script language is a
    stack-based reverse polish language. Language semantics is like reverse polish
    notation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证交易的脚本部分，首先执行`**scriptSig**`，然后按顺序执行`**scriptPubKey**`。脚本语言是一种基于栈的反波兰语言。语言语义类似于逆波兰记法。
- en: '[Reverse Polish notation](toc.xhtml#s216a)'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**逆波兰记法**[点击此处](toc.xhtml#s216a)'
- en: 'Reverse polish notation is also called *post fix notation*. The following is
    an example of reverse polish notation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 逆波兰记法也称为*后缀记法*。以下是一个逆波兰记法的示例：
- en: 7+ 9 in reverse polish notation is 7 9 +
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 7+9 的逆波兰记法是 7 9 +
- en: 'To solve this, 7 and 9 go into the stack, and + is the operator to perform
    the operation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，7 和 9 被放入栈中，+ 是执行操作的运算符：
- en: '![](images/Figure-10.1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.1.jpg)'
- en: '**Figure 10.1:** Reverse Polish notation operation execution'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.1:** 逆波兰记法操作执行'
- en: When we create a new transaction, we utilize UTXOs to fund the transaction.
    Inputs of the new transaction contain an unlocking script that is required to
    release funds locked by the `**scriptPubKey**` in the UTXOs. Once both scripts
    are executed, a Boolean value is left on the top of the stack, which denotes whether
    the script finally succeeded. These scripts are executed just like reverse polish
    notation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的交易时，我们利用 UTXO 来资助交易。新交易的输入包含一个解锁脚本，该脚本用于释放 UTXOs 中由`**scriptPubKey**`锁定的资金。一旦执行了这两个脚本，栈顶会留下一个布尔值，表示脚本最终是否成功。这些脚本的执行方式与逆波兰记法类似。
- en: '[OPCODES](toc.xhtml#s217a)'
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**操作码**[点击此处](toc.xhtml#s217a)'
- en: A script consists of data and operators. These operators have defined opcodes.
    An operator has defined functionality. Data is preceded by a `**pushdata**` operator,
    which denotes the number of bytes in the following data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个脚本由数据和操作符组成。这些操作符有定义的操作码。操作符有定义的功能。数据前面有一个`**pushdata**`操作符，表示以下数据的字节数。
- en: 'The following are some of the opcodes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些操作码：
- en: '| **Word** | **HEX** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '**单词** | **十六进制** |'
- en: '| OP_DUP | 0x76 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| OP_DUP | 0x76 |'
- en: '| OP_HASH160 | 0xa9 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| OP_HASH160 | 0xa9 |'
- en: '| OP_EQUALVERIFY | 0x88 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| OP_EQUALVERIFY | 0x88 |'
- en: '| OP_EQUAL | 0x87 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| OP_EQUAL | 0x87 |'
- en: '| OP_CHECKSIG | 0xac |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| OP_CHECKSIG | 0xac |'
- en: '| Pushdata bytelength | 0x01-0x4b |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 推送数据字节长度 | 0x01-0x4b |'
- en: '| OP_PUSHDATA1 | 0x4c |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| OP_PUSHDATA1 | 0x4c |'
- en: '| OP_PUSHDATA2 | 0x4d |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| OP_PUSHDATA2 | 0x4d |'
- en: '| OP_PUSHDATA4 | 0x4e |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| OP_PUSHDATA4 | 0x4e |'
- en: '**Table 10.1:** OPCODES'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10.1:** 操作码'
- en: 'The full list of opcodes can be found at following URL:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的操作码列表可以在以下网址找到：
- en: '**[https://en.bitcoin.it/wiki/Script](https://en.bitcoin.it/wiki/Script)**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**[https://en.bitcoin.it/wiki/Script](https://en.bitcoin.it/wiki/Script)**'
- en: 'The hex values from 0x01 to 0x4b denote the size of the data. OP_PUSHDATA1
    denotes the size of data in the next 1 byte, OP_PUSHADATA2 denotes the size of
    data in the next 2 bytes, and OP_PUSHDATA4 denotes the size of data in the next
    4 bytes. Here’s the illustration of the `**pushdata**` and the data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0x01 到 0x4b 的十六进制值表示数据的大小。OP_PUSHDATA1 表示下一个字节的数据显示数据大小，OP_PUSHADATA2 表示下一个字节的数据显示数据大小，OP_PUSHDATA4
    表示下一个字节的数据显示数据大小。以下是`**pushdata**`和数据的说明：
- en: '![](images/Figure-10.2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.2.jpg)'
- en: '**Figure 10.2:** Pushdata size encoding'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.2:** 推送数据大小编码'
- en: 'We use the preceding table to convert script hex-code to get the readable script:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`op_d = {‘76’: ‘OP_DUP’, ‘a9’: ‘OP_HASH160’, ‘88’: ‘OP_EQUALVERIFY’, ‘87’:
    ‘OP_EQUAL’, ‘ac’: ‘OP_CHECKSIG’, ‘ae’: ‘OP_CHECKMULTISIG’, ‘00’: ‘OP_0’, ‘51’:
    ‘OP_1’, ‘52’: ‘OP_2’, ‘53’: ‘OP_3’, ‘54’: ‘OP_4’, ‘55’: ‘OP_5’, ‘56’: ‘OP_6’,
    ‘57’: ‘OP_7’, ‘58’: ‘OP_8’, ‘59’: ‘OP_9’, ‘5a’: ‘OP_10’, ‘5b’: ‘OP_11’, ‘5c’:
    ‘OP_12’, ‘5d’: ‘OP_13’, ‘5e’: ‘OP_14’, ‘5f’: ‘OP_15’, ‘60’: ‘OP_16’, ‘6a’: ‘OP_RETURN’,
    ‘4c’: ‘OP_PUSHDATA1’, ‘4d’: ‘OP_PUSHDATA2’, ‘4e’: ‘OP_PUSHDATA4’}`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA1 = 0x4c`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA2 = 0x4d`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA4 = 0x4e`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`g_pushdata = range(0x01, 0x4c)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`def prepare_readable_script(script_b: bytes):`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`script_len = len(script_b)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl = []`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 0`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`while i < script_len:`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`if script_b[i] in g_pushdata:`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(script_b[i: i + 1].hex())`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(script_b[i+1: i+script_b[i]+1].hex())`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`i += 1 + script_b[i]`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`elif script_b[i] == OP_PUSHDATA1:`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(op_d[script_b[i:i+1].hex()])`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize_b = script_b[i + 1: i + 2]`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(datasize_b.hex())`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize = int.from_bytes(datasize_b, byteorder=’little’)`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(script_b[i + 2: i + 2 + datasize].hex())`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`i += 2 + datasize`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`elif script_b[i] == OP_PUSHDATA2:`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(op_d[script_b[i:i+1].hex()])`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize_b = script_b[i + 1: i + 3]`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(datasize_b.hex())`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize = int.from_bytes(datasize_b, byteorder=’little’)`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(script_b[i + 3: i + 3 + datasize].hex())`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`i += 3 + datasize`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`elif script_b[i] == OP_PUSHDATA4:`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(op_d[script_b[i:i+1].hex()])`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize_b = script_b[i + 1: i + 5]`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(datasize_b.hex())`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`datasize = int.from_bytes(datasize_b, byteorder=’little’)`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(script_b[i + 5: i + 5 + datasize].hex())`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`i += 5 + data_size`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`op_s = op_d[script_b[i:i+1].hex()]`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`script_sl.append(op_s)`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`i += 1`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`script_str = ‘ ‘.join(script_sl)`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`return script_str`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.1:** Hex code to get the readable script'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding program, the first byte of the script represents the script
    size in bytes. We have taken a few of the opcodes and mapped them with their hex
    codes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We convert hex code to readable script by calling the preceding method as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`data_s = ‘76a91461cf5af7bb84348df3fd695672e53c7d5b3f3db988ac’`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘pushdata: ‘, data_s)`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(data_s)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘Decoded Script: ‘, prepare_readable_script(script_b))`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘====================================================’)`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`data_s = ‘6a4c500029282c0002c5164b82ab2b42044dbe2b8573c969cc10d9e0bd03646ccf1e7497c4bf69678a7b6a99ce4f8dda595a2ed353f27c6195bdfd0528ff229f2619002759d5b9d236d1458d1ad7e7640b5948’`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘PUSHDATA1: ‘, data_s)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(data_s)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘Decoded Script: ‘, prepare_readable_script(script_b))`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘====================================================’)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`data_s = ‘47304402201f46c0a476592d44192773fb0ac385d5ab0fc286882016b220e055314989d70f0220151e45313207ef60d7e91b66f03bbaade27ad0fb0a78ca692ccdb4fa36202a66014d33014d0701434e54525052545903000800157934c4b76dd4598533af398d4600bc62c30e20001de8e1db9ab1622fb8b35eae514f6a2b848dec9000489ad6851b31a59f042593c28f49976ffe17abc6005d3d7d62a84e90b0cfcb455c4f73bc795115a5f2005eac6a674669c6c0de63177ae4b3f8f21579a5e90068430e5056f9b75beb0dbf415a8aa2c65305a89e00687fd8a1bcc5a7f48c540591a4e3521fe7a5d67300a393004b7d01b3ad81276898afb8203c1b631b8a40000085ecef53f53d0000000000000001808000000000000000300c0000000000000006030000000000000000c01000000000000000180e00000000000000030080000000000000006000000000000000000c00752103cff10054cf9cf2dbda64adb01ccfc46c3dee8fcf4a9ba7eb14015ebe97cc31f3ad0075740087’`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘PUSHDATA2: ‘, data_s)`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(data_s)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘Decoded Script: ‘, prepare_readable_script(script_b))`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.3.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.3:** Shows script parsed by the program'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[Signature verification](toc.xhtml#s218a)'
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a node gets a transaction, it needs to verify it against consensus rules,
    which includes verifying the signature and public key against the locking script,
    which is P2PKH or P2PSH, or any other type of script. You have learned Signature
    verification in *[Chapter 5, The Whitepaper](c05.xhtml)*, in a note named *Digital
    Signature.* You have learned that for signature verification, we require two inputs
    to the given signature: a public key and a message. The message, in this case,
    consists of version, input count, inputs, locktime, sighash type, output count,
    and outputs.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Here, sighash type indicates the structure of the message being signed by the
    new transaction.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the sighash types that can be used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| **SIGHASH Types** | **Hex code** | **Meaning** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_ALL | 0x01 | Signs all inputs and outputs |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_NONE | 0x02 | Signs all inputs and no outputs |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_SINGLE | 0x03 | Signs all inputs and single output |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_ALL&#124;SIGHASH_ANYONECANPAY | 0x81 | Signs one input and all outputs
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_NONE&#124;SIGHASH_ANYONECANPAY | 0x82 | Signs one input and no outputs
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| SIGHASH_SINGLE&#124;SIGHASH_ANYONECANPAY | 0x83 | Signs one input and one
    output |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '**Table 10.2:** Sighash types'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the description of each of the preceding sighash types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`**SIGHASH_ALL**`: Signing all outputs is needed to make sure someone does
    not change the output and steals the bitcoins. Consequently, every transaction
    needs to have at least one input signed with `**SIGHASH_ALL**`*.*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SIGHASH_NONE**`: This is mostly used with `**SIGHASH_ANYONECANPAY**`, but
    it is valid to use this sighash type without `**SIGHASH_ANYONECANPAY**` when all
    inputs are known.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SIGHASH_SINGLE**`: This is mostly used with `**SIGHASH_ANYONECANPAY*.***`
    Similar to `**SIGHASH_NONE**`, this sighash type can also be used without `**SIGHASH_ANYONECANPAY*.***`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SIGHASH_ALL|SIGHASH_ANYONECANPAY**`: This is useful if each one is contributing
    to specific purposes, like collectively paying for buying a gift from a gift shop.
    In this case, everyone knows where the funds are going and in what quantity, and
    everyone knows how much they need to contribute.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**SIGHASH_ALL|SIGHASH_ANYONECANPAY**`: 如果在特定的目的下每个人都在做贡献，比如一起从礼品店买礼物，这个就很有用。在这种情况下，每个人都清楚资金的流向和数量，也清楚他们需要贡献多少。'
- en: '`**SIGHASH_NONE|SIGHASH_ANYONECANPAY**`: This is useful when a coordinator
    is collecting funds for certain purposes. The collector knows where the funds
    need to go, so they will sign all inputs and outputs with their private key while
    creating a signature of one input. Others will not know where funds are to be
    used, so they will sign by `**SIGHASH_NONE|SIGHASH_ANYONECANPAY**`*.*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**SIGHASH_NONE|SIGHASH_ANYONECANPAY**`: 当一个协调者在为某些目的收集资金时这个很有用。收集者知道资金需要流向哪里，因此他们在创建一个输入的签名时会用他们的私钥签署所有输入和输出。其他人不知道资金将如何使用，因此他们会通过
    `**SIGHASH_NONE|SIGHASH_ANYONECANPAY**` 来签署*.*'
- en: '`**SIGHASH_SINGLE|SIGHASH_ANYONECANPAY**`: This is useful for merging independent
    transactions where each transaction has one input and one output. There needs
    to be one input that signs all outputs. The biggest issue here is that output
    value is normally fixed, so excess value needs to be paid as change. This can
    only be useful if the input and output match or if the input is less than output.
    We can call a transaction partial if the input is less than the output. In this
    case, each one makes a partial transaction, and the collector adds the remaining
    bitcoins in order to complete the transaction. As an example, this can be used
    if the payment is subsidized by another entity, who finally completes the transaction
    by signing all outputs.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**SIGHASH_SINGLE|SIGHASH_ANYONECANPAY**`: 这个在合并独立的交易时很有用，每个交易有一个输入和一个输出。需要有一个输入来签署所有的输出。这里最大的问题是输出值通常是固定的，所以多余的价值需要作为找零支付。这只可能在输入和输出相等或输入小于输出的情况下有用。如果输入小于输出，我们可以称这个交易为部分交易。在这种情况下，每个人都做一个部分交易，收集者添加剩余的比特币以完成交易。例如，如果支付由另一个实体资助，该实体最终通过签署所有输出来完成交易。'
- en: '[Hash type – SIGHASH_ALL](toc.xhtml#s219a)'
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[哈希类型 - SIGHASH_ALL](toc.xhtml#s219a)'
- en: 'The following illustration shows how signature in scriptSig is created for
    `**SIGHASH_ALL**`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了在 `**SIGHASH_ALL**` 情况下如何在 scriptSig 中创建签名：
- en: '![](images/Figure-10.4.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.4.jpg)'
- en: '**Figure 10.4:** Transaction creation for SIGHASH_ALL'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.4:** 创建 SIGHASH_ALL 类型的交易'
- en: The preceding figure shows how the signature is created by using the message
    and private key. In the case of `**SIGHASH_ALL**`, we create the message by taking
    all the elements of the new transaction. We then replace scriptSig and scriptSig
    length with the executing script, which, in the case of P2PKH, is the previous
    scriptPubKey and scriptPubKey length for the input index to be signed. For the
    other inputs, scriptSig length is replaced with zero as those inputs are not getting
    signed. For P2SH script, scriptSig and its length are replaced with redeem script
    and its length. At the end of the message, we add sighash type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图展示了如何使用消息和私钥创建签名。在 `**SIGHASH_ALL**` 的情况下，我们通过获取新交易的的所有元素来创建消息。然后我们用执行脚本替换
    scriptSig 和 scriptSig 长度，在 P2PKH 的情况下，是待签名的输入索引的 previous scriptPubKey 和 scriptPubKey
    长度。对于其他输入，scriptSig 长度用零替换，因为这些输入不需要签名。对于 P2SH 脚本，scriptSig 和其长度用赎回脚本和其长度替换。在消息的最后，我们添加
    sighash 类型。
- en: '[Hash type – SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY](toc.xhtml#s220a)'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[哈希类型 - SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY](toc.xhtml#s220a)'
- en: 'The following illustration shows the message structure to be signed for other
    sighash types:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了其他 SIGHASH 类型需要签名的消息结构：
- en: '![](images/Figure-10.5.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.5.jpg)'
- en: '**Figure 10.5:** Signature preimage for sighash types other than SIGHASH_ALL'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.5:** 除了 SIGHASH_ALL 之外的签名预像'
- en: In the case of `**SIGHASH_ANYONECANPAY**`, only the signed input is part of
    the message to be signed, and other inputs are not included. In the case of `**SIGHASH_NONE**`,
    none of the outputs are included, and in the case of `**SIGHASH_SINGLE**`, only
    one output is included. We can observe that the output index in the case, `**SIGHASH_SINGLE**`,
    corresponds to the input that is being signed. This means, if input 0 is signed,
    then output 0 is included and output 1 is excluded. If input 1 is signed, then
    output 1 is included and output 0 is excluded. If the excluded output is not the
    last output of the message, then we need to keep the excluded output as a placeholder
    by just having `0xFFFFFFFFFFFFFFFF` and `0x00` as is in the figure. In both `**SIGHASH_NONE**`
    and SIGHASH_SINGLE, the sequences of inputs that are not signed are replaced by
    `0x00000000`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`**SIGHASH_ANYONECANPAY**`的情况下，只有已签名的输入是待签名的消息的一部分，其他输入不包括在内。在`**SIGHASH_NONE**`的情况下，没有任何输出包括在内，在`**SIGHASH_SINGLE**`的情况下，只有一个输出包括在内。我们可以观察到，在`**SIGHASH_SINGLE**`情况下，输出索引对应于正在签名的输入。这意味着，如果签名输入0，则包括输出0，排除输出1。如果签名输入1，则包括输出1，排除输出0。如果排除的输出不是消息的最后一个输出，那么我们需要通过仅保留`0xFFFFFFFFFFFFFFFF`和`0x00`作为占位符来保留被排除的输出，正如图中所示。在`**SIGHASH_NONE**`和SIGHASH_SINGLE的情况下，未签名的输入序列被`0x00000000`替换。
- en: '[Standard Bitcoin script - P2PK](toc.xhtml#s221a)'
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[标准比特币脚本 - P2PK](toc.xhtml#s221a)'
- en: P2PK is not recommended for use. P2PK stands for ***Pay-2-Public-Key***.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: P2PK不推荐使用。P2PK代表***Pay-2-Public-Key***。
- en: 'In this script, `**scriptsig**` is:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`**scriptsig**`的内容是：
- en: '`<Signature>`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`<签名>`'
- en: 'and `**scriptpubkey**` is:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`**scriptpubkey**`的内容是：'
- en: '`<Public Key> OP_CHECKSIG`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`<公钥> OP_CHECKSIG`'
- en: 'It has simple execution: first, `**scriptSig**` gets executed, in which signature
    is pushed into stack, and then `**scriptPubKey**` gets executed, which pushes
    public-key to stack, and then `**OP_CHECKSIG**` checks the signature by popping
    out the signature and the public-key and pushes back the result to the stack.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它的执行过程简单：首先执行`**scriptSig**`，其中将签名推入栈，然后执行`**scriptPubKey**`，将公钥推入栈，然后执行`**OP_CHECKSIG**`，通过弹出签名和公钥来检查签名，并将结果推回栈。
- en: 'This script had a few drawbacks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有几个缺点：
- en: Compressed Public Keys are 32-bytes long, while the hash used by the P2PKH script
    is 20-byte long, so its hex is 40-character long, which is much easier to type.
    An address generated from 20-bytes using base58check encoding is 34-character
    long.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩公钥是32字节长，而P2PKH脚本中使用的哈希是20字节长，所以它的十六进制是40字符长，这要容易得多。使用base58check编码生成的20字节地址是34字符长。
- en: If quantum computers can utilize a quantum technique called Shor’s algorithm,
    it is expected that they will be able to derive private keys from public keys.
    For Bitcoin to remain secure in the future, we should not expose our public keys
    on the networks that are still holding bitcoins. By having a public key hash,
    we have multiple levels of security to secure our funds.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果量子计算机能够利用一种名为Shor算法量子技术，预计它们将能够从公钥中导出私钥。为了使比特币在未来保持安全，我们不应该在还持有比特币的网络中暴露我们的公钥。通过拥有公钥哈希，我们有多层安全性来保护我们的资金。
- en: Since this script is not recommended, there is no point in going deeper into
    understanding it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本不推荐使用，深入理解它没有意义。
- en: '[Standard Bitcoin script – P2PKH](toc.xhtml#s222a)'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[标准比特币脚本——P2PKH](toc.xhtml#s222a)'
- en: P2PKH is the most widely used Bitcoin script. P2PKH stands for ***Pay-2-Public-Key-Hash***.
    In the script, the sender locks the transaction output using the hash of the public
    key, and it requires the receiver to provide the public key when it needs to use
    the funds locked in transaction output. The hash is 20-byte long, which is smaller
    than the 32-byte long compressed public key. And it generates a 34-character long
    address, which includes a checksum. This makes it easier to type, and since it
    contains a checksum, it is not possible to accidentally type the wrong address.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: P2PKH是比特币脚本中最广泛使用的。P2PKH代表***Pay-2-Public-Key-Hash***。在脚本中，发送者使用公钥的哈希锁定交易输出，并要求接收者在需要使用锁定在交易输出中的资金时提供公钥。哈希是20字节长，小于32字节的压缩公钥。它生成了一个34字符长的地址，包括一个校验和。这使得它更容易输入，并且由于包含校验和，不可能意外地输入错误的地址。
- en: 'The `**scriptSig**` in P2PKH is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`**scriptSig**`在P2PKH中的内容是：'
- en: '`<Signature> <Public Key Hash>`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`<签名> <公钥哈希>`'
- en: 'and the `**scriptPubKey**` is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`**scriptPubKey**`的内容是：'
- en: '`OP_DUP OP_HASH160 <20-byte pubkey hash> OP_EQUALVERIFY OP_CHECKSIG`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`OP_DUP OP_HASH160 <20字节公钥哈希> OP_EQUALVERIFY OP_CHECKSIG`'
- en: Since `**<Signature>**` and `**<Public Key Hash>**` both are data, both go into
    the stack. Once `**scriptSig**` is executed, `**scriptPubKey**` is executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows the execution of P2PKH:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.6.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.6:** Execution of P2PKH'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Prepare signature preimage
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All messages include sighash type at the end. Once the message is signed, the
    sighash type is appended to the signature to help the verifying node reconstruct
    the message before verification.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to verify a real transaction script. We take following transaction
    ID:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`83eeaecaf531e5239ffc3ba7ff583c696f7dbe3610f0d672d41e0b9443632c82`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the transaction is in the Bitcoin blockchain, we get the raw transaction
    by calling `**getrawtransaction**` in Bitcoin Core CLI, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.7:** Shows the Bitcoin Core CLI command for getting transaction
    bytes'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following raw transaction:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.8.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.8:** Shows the hex data of the traansaction-ID'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We can use the transaction and parse it using the `**getTransactionInfo**` method
    written in *[Chapter 6, Blockchain, Transactions, and Mining](c06.xhtml),* under
    the topic *Transactions* and the subtopic *Other transaction* in *Program 6.15,*
    to get scriptSig.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`Transaction = {‘version’: ‘00000001’, ‘inp_cnt’: 2, ‘inputs’: [{‘prev_tx_hash’:
    ‘15b91bcf8b2b9ea46d0daab60aaa2e99b15a5fb37d9d4568d4c060e515e13130’, ‘prev_tx_out_index’:
    ‘00000001’, ‘bytes_scriptsig’: 106, ‘scriptsig’: ‘47304402205535a9ac25844514828bff3580120d5add488e09b7a6e62018fc265aabf95fe302200b66d4eb23fc348b31d58729b479ae73db9dfc467edf38f8dfd927c48cb46b5801210219fbee4b9cc12188598f244ff0ee352b124cbf9046180a1b25e020c0258f9d64’,
    ‘sequence’: ‘ffffffff’}, {‘prev_tx_hash’: ‘840ac7a55498c6746b9d7460a348f79e2f35db4a9696bef762d975e7e1deeff2’,
    ‘prev_tx_out_index’: ‘0000000c’, ‘bytes_scriptsig’: 106, ‘scriptsig’: ‘47304402203a28d10c786907fcb71c7bf69c507d58884ea9af2e7fa3b413d4e2867eca601502205fb253d82e4daa2672842ec031584ea7a215774422aa7de3cf8928c240e2faa60121030be5aa6d5de8c6dd89d6ac4d0e2a112caf5b12801349ab30fbdf2b205f0b94b8’,
    ‘sequence’: ‘ffffffff’}], ‘out_cnt’: 2, ‘outs’: [{‘satoshis’: 69302, ‘bytes_scriptpubkey’:
    25, ‘scriptpubkey’: ‘76a914f133f0339987cd84b6017517de2a93f009728d7e88ac’}, {‘satoshis’:
    12900349, ‘bytes_scriptpubkey’: 25, ‘scriptpubkey’: ‘76a91406c3bc40cde01312e2b24f8d2c23e68ea7d572f888ac’}],
    ‘locktime’: 0}`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program further parses `**scriptSig**` to get signature, `**sighash**`
    type, and public key:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA1 = 0x4c`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA2 = 0x4d`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_PUSHDATA4 = 0x4e`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHASH_ALL = 0x01`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHASH_NONE = 0x02`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHASH_SINGLE = 0x03`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHASH_ANYONECANPAY = 0x80`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`def getHashTypeInWords(hashtype: int):`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype_s = “”`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & SIGHASH_SINGLE == 0x03:`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype_s = “SIGHASH_SINGLE”`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`elif hashtype & SIGHASH_NONE == 0x02:`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype_s = “SIGHASH_NONE”`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`elif hashtype & SIGHASH_ALL == 0x01:`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype_s = “SIGHASH_ALL”`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & SIGHASH_ANYONECANPAY == 0x80:`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype_s = hashtype_s + “|” + “SIGHASH_ANYONECANPAY”`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`return hashtype_s`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`def decodePushdata(script_m: mmap):`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`length = int.from_bytes(script_m.read(1), byteorder=’little’)`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '`if length == OP_PUSHDATA1:`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`length = int.from_bytes(script_m.read(1), byteorder=’little’)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`elif length == OP_PUSHDATA2:`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`length = int.from_bytes(script_m.read(2), byteorder=’little’)`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`elif length == OP_PUSHDATA4:`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`length = int.from_bytes(script_m.read(4), byteorder=’little’)`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`return length`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`def parseScriptSig(script_m: mmap):`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig = {}`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘bytes_sig’] = decodePushdata(script_m)`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘sig’] = script_m.read(scriptsig[‘bytes_sig’] - 1).hex()`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘hash_type’] = int.from_bytes(script_m.read(1), byteorder=’little’)`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘hash_type_name’] = getHashTypeInWords(scriptsig[‘hash_type’])`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘bytes_pubkey’] = decodePushdata(script_m)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig[‘pubkey’] = script_m.read(scriptsig[‘bytes_pubkey’]).hex()`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptsig`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.2:** Scriptsig parser'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the preceding method as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(‘47304402203a28d10c786907fcb71c7bf69c507d58884ea9af2e7fa3b413d4e2867eca601502205fb253d82e4daa2672842ec031584ea7a215774422aa7de3cf8928c240e2faa60121030be5aa6d5de8c6dd89d6ac4d0e2a112caf5b12801349ab30fbdf2b205f0b94b8’)`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`script_m = mmap.mmap(-1, len(script_b) + 1)`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`script_m.write(script_b)`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`script_m.seek(0)`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig = parseScriptSig(script_m)`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`print(json.dumps(scriptsig, indent=4))`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following results:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.9.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.9:** Shows the JSON output by running the parseScriptSig program'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the preceding information to verify the transaction. We first implement
    script operations. Then, we use the list as a stack and use pop and append operations:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`st = []`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '`def opHash160():`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`v = st.pop()`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`h = hash160(v)`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '`st.append(h)`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`def opDup():`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '`v = st.pop()`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`st.append(v)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`st.append(v)`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '`def opEqualVerify():`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = st.pop()`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`v2 = st.pop()`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`if v1 == v2:`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`return True`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '`return False`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`g_pushdata = range(0x01, 0x4f)`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`def pushdata(d: bytes):`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '`st.append(d)`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '`def opCheckSig(script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = st.pop()`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`sig_b = st.pop()`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`v = sigcheck(sig_b, pubkey_b, script_b, inp_index, tx)`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`st.append(v)`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.3:** Bitcoin script operations for P2PKH'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The `**OP_CheckSig**` operation verifies transaction messages using a signature
    and a public key that is on the stack. To create the signature preimage, we take
    the transaction bytes and replace the input signature needed to be verified by
    executing the script. This is shown in *[figures 10.4](#fig10_4)* and *[10.5](#fig10_5)*.
    This is the reason we pass script bytes and input index as its arguments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the script operators using the following method, which reads script
    bytes till the whole script is executed:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`def execScript(script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`l = len(script_b)`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`script_m = bytes2Mmap(script_b)`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`while script_m.tell() < l:`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`v = script_m.read(1)`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`b = int.from_bytes(v, byteorder=’little’)`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`if b in g_pushdata:`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`script_m.seek(-1, 1)`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '`b = decodePushdata(script_m)`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`d = script_m.read(b)`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`pushdata(d)`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '`elif v == b’\x76’:`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`opDup()`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`elif v == b’\xa9’:`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`opHash160()`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`elif v == b’\x88’:`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`opEqualVerify()`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`elif v == b’\xac’:`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '`opCheckSig(script_b, inp_index, tx)`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.4:** P2PKH script execution'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The `**opCheckSig**` method calls the `**sigcheck**` method, which performs
    signature verification using the `**ecdsa**` package. To understand signature
    verification, we need to understand the format of signature used by Bitcoin transactions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the created message and the private key to verify the signature. The
    signature we get in the transaction is in the *DER encoding*. **DER** stands for
    **Distinguished Encoding Rules**. Here’s the structure of DER encoding:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.10.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.10:** DER encoding'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the description of the components of DER encoding:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '0x30 byte: Indicates compound structure'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data Size: Size of data following this byte'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x02: Indicates integer'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R value size: Size of R may include 0x00 prefix'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R: This may include 0x00 prefix'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S value size: Size of S may include 0x00 prefix'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S: This may include 0x00 prefix'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `**ecdsa**` package we are using requires a signature to be a concatenation
    of *R* and *S*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The following code returns concatenated *R* and *S:*
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`def getRandSFromSig(sig_b: bytes):`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '`sig_m = bytes2Mmap(sig_b)`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '`struct = sig_m.read(1)`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`size = sig_m.read(1)`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '`rheader = sig_m.read(1)`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`rsize_b = sig_m.read(1)`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`rsize = int.from_bytes(rsize_b, byteorder=’little’)`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`if rsize == 33:`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '`sig_m.read(1)`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`r = sig_m.read(32)`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`sheader = sig_m.read(1)`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '`ssize_b = sig_m.read(1)`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`ssize = int.from_bytes(ssize_b, byteorder=’little’)`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '`if ssize == 33:`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`sig_m.read(1)`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`s = sig_m.read(32)`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '`return r + s`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.5:** Get concatenated R and S bytes'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to build signature preimage to verify signatures using input index
    and current executing script. The following code does this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`def bytes2Mmap(b: bytes):`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '`m = mmap.mmap(-1, len(b) + 1)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '`m.write(b)`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`m.seek(0)`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '`return m`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '`# This method returns both value of variable integer and also the variable
    integer bytes`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`def setVarInt(n: int):`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`if n < 0xfd:`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '`n_h = ‘%02x’ % n`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '`elif n > 0xfd and n < 0xffff:`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '`n_h = ‘fd%04x’ % n`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`elif n > 0xffff and n < 0xFFFFFFFF:`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '`n_h = ‘fe%08x’ % n`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '`n_h = ‘ff%016x’ % n`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes.fromhex(n_h)`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '`def createMsgInputsForSig(tx: dict, script_b: bytes,`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_index: int,`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`sighash_type: int,`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_cnt: int):`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b = b’’`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in range(inp_cnt):`'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`tx_inp = tx[‘inputs’][i]`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b = bytes.fromhex(tx_inp[‘prev_tx_hash’])[::-1]`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += struct.pack(‘<L’, tx_inp[‘prev_tx_out_index’])`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '`if i == inp_index:`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += bytes.fromhex(‘%02x’ % len(script_b))`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += script_b`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += struct.pack(‘<L’, tx_inp[‘sequence’]) # sequence`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += bytes(1)`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_b += struct.pack(‘<L’, tx_inp[‘sequence’]) # sequence`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += inp_b`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`return msg_b`'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '`def createMsgOutsForSig(tx: dict, inp_index: int, sighash_type: int):`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b = b’’`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += setVarInt(tx[‘out_cnt’])`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`for o in range(tx[‘out_cnt’]):`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`tx_out = tx[‘outs’][o]`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += struct.pack(‘<Q’, tx_out[‘satoshis’])`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += setVarInt(tx_out[‘bytes_scriptpubkey’])`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += bytes.fromhex(tx_out[‘scriptpubkey’])`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`return msg_b`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '`def createMsgForSig(tx: dict, script_b: bytes, inp_index: int, sighash_type:
    int):`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b = bytes.fromhex(tx[‘version’])[::-1]`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_cnt = tx[‘inp_cnt’]`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += setVarInt(inp_cnt)`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += createMsgInputsForSig(tx, script_b, inp_index, sighash_type, inp_cnt)`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += createMsgOutsForSig(tx, inp_index, sighash_type)`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += struct.pack(‘<L’, tx[‘locktime’])`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b += struct.pack(‘<L’, sighash_type)`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`return `msg_b``'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`**Program 10.6:** Create signature preimage'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the message generated by calling the preceding method and using the
    public key to verify the signature. We have written the following method to verify
    the transaction signature at the given input index:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '`from cryptotools.ECDSA.secp256k1 import PublicKey`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '`def uncompressPubkey(pubkey_b: bytes):`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_P = PublicKey.decode(pubkey_b)`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = PublicKey.encode(pubkey_P, compressed=False)`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`return pubkey_b`'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '`def sigcheck(sig_b: bytes, pubkey_b: bytes, script_b: bytes, inp_index: int,
    tx: dict):`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '`sighash_type = sig_b[-1]`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_b = createMsgForSig(tx, script_b, inp_index, sighash_type)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '`msg_h = hashlib.sha256(msg_b).digest()`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`prefix = pubkey_b[0:1]`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`if prefix == b”\x02” or prefix == b”\x03”:`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '`fullpubkey_b = uncompressPubkey(pubkey_b)[1:]`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '`elif prefix == b”\x04”:`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`fullpubkey_b = pubkey_b[1:]`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '`rs_b = getRandSFromSig(sig_b)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`vk = ecdsa.VerifyingKey.from_string(fullpubkey_b, curve=ecdsa.SECP256k1)`'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`try:`'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '`if vk.verify(rs_b, msg_h, hashlib.sha256) == True:`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`print(“Signature is Valid”)`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\x01’`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '`print(“Signature is not Valid”)`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\x00’`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`except ecdsa.keys.BadSignatureError:`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '`print(“Signature is not Valid”)`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\x00’`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.7:** Signature verification method'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the preceding program to verify transaction signature related P2PKH
    address.The following the methods required to verify P2PKH script:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`def getScriptSig(tx: dict, inp_index: int):`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes.fromhex(tx[‘inputs’][inp_index][‘scriptsig’])`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`def getPrevScriptPubKey(tx: dict, inp_index: int):`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtx_rb = bytes.fromhex(tx[‘inputs’][inp_index][‘prev_tx_hash’])[::-1]`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtx_outindex = tx[‘inputs’][inp_index][‘prev_tx_out_index’]`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtx = findTransaction(prevtx_rb, txindex_db_g)`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`prevScriptPubkey = prevtx[‘outs’][prevtx_outindex][‘scriptpubkey’]`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`prevScriptPubkey_b = bytes.fromhex(prevScriptPubkey)`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '`return prevScriptPubkey_b`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`def verifyScript(tx: dict, inp_index: int):`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptsig_b = getScriptSig(tx, inp_index)`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '`execScript(scriptsig_b, inp_index, tx)`'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '`prev_scriptpubkey_b = getPrevScriptPubKey(tx, inp_index)`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
- en: '`status = st.pop()`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`status = st.pop()`'
- en: '`if status == b’\x01’:`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`if status == b’\x01’:`'
- en: '`print(‘1st Script succeeded’)`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script succeeded’)`'
- en: '`elif status == b’\x01’:`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif status == b’\x01’:`'
- en: '`print(‘1st Script Failed’)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script Failed’)`'
- en: '`else:`'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘1st Invalid state’)`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Invalid state’)`'
- en: '**Program 10.8:** Methods to verify P2PKH script'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序10.8：** 验证P2PKH脚本的方法'
- en: 'We call the preceding method as follows to verify a transaction scriptSig:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以下面这种方式来验证交易脚本Sig：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`txid_s = ‘2df97b379c9ce9e4a60529f555b9742c04f90b922c2fcff846ebae41206b93f9’`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_s = ‘2df97b379c9ce9e4a60529f555b9742c04f90b922c2fcff846ebae41206b93f9’`'
- en: '`inp_index = 1`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_index = 1`'
- en: '`txid_b = bytes.fromhex(txid_s)[::-1]`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = bytes.fromhex(txid_s)[::-1]`'
- en: '`tx = findTransaction(txid_b, txindex_db_g)`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = findTransaction(txid_b, txindex_db_g)`'
- en: '`verifyScript(tx, inp_index)`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, inp_index)`'
- en: '[Standard Bitcoin script – P2MS](toc.xhtml#s223a)'
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**标准比特币脚本 - P2MS**](toc.xhtml#s223a)'
- en: P2MS stands for ***Pay-2-Multisig***. This script allows the use of multiple
    signatures in order to access the locked bitcoin.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: P2MS代表***Pay-2-Multisig***。这个脚本允许使用多个签名以访问被锁定的比特币。
- en: 'The script looks as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本如下所示：
- en: '**ScriptPubKey:** `**OP_n <Public Key 1><Public Key 2>…<Public Key m>OP_m<Multisig>**`'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScriptPubKey:** `**OP_n <Public Key 1><Public Key 2>…<Public Key m>OP_m<Multisig>**`'
- en: '**ScriptSig:** `**OP_0 <Signature 1><Signature 2>… <Signature n>**`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScriptSig:** `**OP_0 <Signature 1><Signature 2>… <Signature n>**`'
- en: In a 2-of-3-multisig, two of the three signatures are required to claim the
    funds locked by `**scriptPubKey**`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个2-of-3-multisig中，需要两个签名来认领由`**scriptPubKey**`锁定的资金。
- en: 'This means when we create a transaction, we need to have multiple public keys
    in the script. These have the following disadvantages:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们创建一个交易时，我们需要在脚本中有多个公钥。这些有以下缺点：
- en: Transaction will consume many more bytes than the normal P2PKH script, so the
    sender will have to pay a higher transaction fee.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易将消耗比正常P2PKH脚本更多的字节，所以发送者将不得不支付更高的交易费。
- en: A sender will need to form a complex script by taking multiple public keys even
    though it is sending it to just one receiver. This is an overhead for the sender.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者即使要把比特币发送给一个接收者，也需要通过组合多个公钥来形成一个复杂的脚本。这对发送者来说是一种开销。
- en: Public keys may not remain secure if quantum computers are able to utilize Shor’s
    algorithm to break private key public key cryptography.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果量子计算机能够利用Shor算法来破解私钥和公钥加密，那么公钥可能不会保持安全。
- en: In 2012, P2SH was introduced as a softfork that solved the preceding disadvantages,
    so we are not going deeper into this script.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在2012年，P2SH作为一种软分叉被引入，解决了上述缺点，所以我们不会深入讨论这个脚本。
- en: '[Standard Bitcoin script – P2SH](toc.xhtml#s224a)'
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**标准比特币脚本 - P2SH**](toc.xhtml#s224a)'
- en: P2SH stands for ***Pay-2-Script-Hash***. As the name suggests, there is a script
    embedded in the hash, which must satisfy for payment to be made. This is mostly
    used to allow the use of multiple signatures in order to access bitcoin. It was
    introduced as a softfork in 2012.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: P2SH代表***Pay-2-Script-Hash***。正如这个名字 suggests，在这个散列中嵌入了一个脚本，只有当这个脚本满足时，才能进行支付。这主要用于允许使用多个签名以访问比特币。它于2012年作为软分叉引入。
- en: The P2SH script replaced the multisig script with a script hash, so the sender
    does not need to pay extra to the miner for including their transaction.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 由于P2SH脚本用脚本散列替换了多重签名脚本，所以发送者不需要向矿工支付额外的费用以包含他们的交易。
- en: 'For P2SH, the `**scriptSig**` is:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于P2SH，`**scriptSig**`是：
- en: '`<Signatures> <Redeem Scripts>`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Signatures> <Redeem Scripts>`'
- en: 'and the `**scriptPubKey**` is:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`**scriptPubKey**`是：'
- en: '`OP_HASH160 <20-byte Redeem Script hash> OP_EQUAL`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`OP_HASH160 <20-byte Redeem Script hash> OP_EQUAL`'
- en: 'The Redeem Script for the 2-of-3-multisig is as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 2-of-3多重签名赎回脚本如下：
- en: '`<2><Public Key 1><Public Key 2><Public Key 3><3><Multisig>`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`<2><Public Key 1><Public Key 2><Public Key 3><3><Multisig>`'
- en: In P2SH, two scripts need to get executed, i.e., the `**scriptPubKey**` and
    redeem script, along with the given list of signatures. This is a special script
    and executes a bit differently. In this case, a copy of the stack is maintained,
    and once `**scriptPubKey**` gets executed, the redeem script starts executing.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在P2SH中，需要执行两个脚本，即`**scriptPubKey**`和赎回脚本，以及给定的签名列表。这是一个特殊的脚本，执行方式略有不同。在这种情况下，维护一个栈的副本，一旦`**scriptPubKey**`执行完成，赎回脚本开始执行。
- en: As `**scriptPubKey**` in P2SH script contains a 20-byte hash of script, and
    we can hide complex scripts within the hash. The sender will not know what the
    rules are for claiming the funds; they will only have a normal-looking address
    to transfer his coins. This greatly simplifies and, at the same time, imposes
    complex rules for claiming the locked bitcoin. These complex rules work as a contract
    between parties. These contracts lead to the origin of the smart contract, which
    we will learn more about in the next chapter.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_m.'
- en: 'The following illustration explains the execution of P2SH:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushdata(d)`'
- en: '![](images/Figure-10.11.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '`elif v == b’\xa9’:`'
- en: '**Figure 10.11:** P2SH execution'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following illustration explains the execution of P2SH:'
- en: 'To write a program that could verify signature against P2SH transaction output,
    we need to be able to identify P2SH as it involves three consecutive executions
    of scripts. Here are the three execution scripts:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`v = script_m.read(1)`'
- en: OP_0 <signature 1> <signature 2> … <signature m> <Redeem Script>
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l = len(script_b)`'
- en: OP_HASH160 <Redeem Script Hash> OP_EQUAL
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是更新后的`**execScript**`方法，它处理额外的操作码：
- en: 'Redeem script: OP_m <Public Key 1> <Public Key 2> … <Public Key n> OP_n OP_MULTISIG'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def checkWrappedMultisig(st):`'
- en: For P2SH, the signature preimage remains the same, so we extend the program
    covered in the previous section on P2PKH to include redeem script handling and
    to also have handling for `**OP_CHECKMULTISIG**`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = decodePushdata(script_m)`'
- en: '`g_pushnumber = range(0x51, 0x61) # excludes 0x61`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`d = script_m.read(b)`'
- en: '`def opEqual():`'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xa9’:`'
- en: '`v1 = st.pop()`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`val = script_b[-2]`'
- en: '`v2 = st.pop()`'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`while script_m.tell() < l:`'
- en: '`if v1 == v2:`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`while script_m.tell() < l:`'
- en: '`st.append(b’\x01’)`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`for pubkey_b in pubkey_l:`'
- en: '`else:`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`v = script_m.read(1)`'
- en: '`st.append(b’\x00’)`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '`def opNum(b: int):`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(b’\x00’)`'
- en: '`num = b - 0x50`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following program identifies if we were executing P2SH script. This method
    is called after `**scriptSig**` is executed:'
- en: '`st.append(bytes([num]))`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_b = st[-1]`'
- en: '`def opCheckMultisig(script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`pubkey_cnt = int.from_bytes(st.pop(), byteorder=’little’)`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = decodePushdata(script_m)`'
- en: '`pubkey_l = [st.pop() for i in range(pubkey_cnt)][::-1]`'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_b = st[-1]`'
- en: '`sig_cnt = int.from_bytes(st.pop(), byteorder=’little’)`'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(b’\x00’)`'
- en: '`sig_l = [st.pop() for i in range(sig_cnt)][::-1]`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`sig_index = 0`'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif b < 0x4f:`'
- en: '`for pubkey_b in pubkey_l:`'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'To write a program that could verify signature against P2SH transaction output,
    we need to be able to identify P2SH as it involves three consecutive executions
    of scripts. Here are the three execution scripts:'
- en: '`v = sigcheck(sig_l[sig_index], pubkey_b, script_b, inp_index, tx)`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图解释了P2SH的执行：
- en: '`if v == b’\x01’:`'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_pushnumber = range(0x51, 0x61) # excludes 0x61`'
- en: '`sig_index += 1`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`if v == b’\x01’:`'
- en: '`if sig_index == sig_cnt:`'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`if sig_index == sig_cnt:`'
- en: '`break`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`# convert True/False to b’\x01’ or b’\x00’`'
- en: '`# convert True/False to b’\x01’ or b’\x00’`'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`num = b - 0x50`'
- en: '`b = bytes([int(sig_index == sig_cnt and v == b’\x01’)])`'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = int.from_bytes(v, byteorder=’little’)`'
- en: '`st.append(b)`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果b等于0x00：
- en: '**Program 10.9:** Bitcoin script operations for P2SH'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = int.from_bytes(v, byteorder=’little’)`'
- en: 'The following program identifies if we were executing P2SH script. This method
    is called after `**scriptSig**` is executed:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def checkWrappedMultisig(st):`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(b)`'
- en: '`script_b = st[-1]`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`opNum(b)`'
- en: '`val = script_b[-2]`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 将真/假转换为b''\x01''或b''\x00''`'
- en: '`if bytes([script_b[-1]]) == b’\xae’ and val in g_pushnumber:`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following is the updated `**execScript**` method that handles additional
    opcodes:'
- en: '`return True`'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名索引等于签名总数：
- en: '`else:`'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`num = b - 0x50`'
- en: '`return False`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**Program 10.10:** Identify P2SH script'
- en: '**Program 10.10:** Identify P2SH script'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`opNum(b)`'
- en: 'The following is the updated `**execScript**` method that handles additional
    opcodes:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`def execScript(script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif b < 0x4f:`'
- en: '`l = len(script_b)`'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`script_m = bytes2Mmap(script_b)`'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`def checkWrappedMultisig(st):`'
- en: '`while script_m.tell() < l:`'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '`v = script_m.read(1)`'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`d = script_m.read(b)`'
- en: '`b = int.from_bytes(v, byteorder=’little’)`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果v等于b’\x01’：
- en: '`if b == 0x00:`'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序用于确定我们是否正在执行P2SH脚本。此方法在执行`**scriptSig**`后调用：
- en: '`pass`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`sig_index += 1`'
- en: '`elif b < 0x4f:`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(b)`'
- en: '`script_m.seek(-1, 1)`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`l = len(script_b)`'
- en: '`b = decodePushdata(script_m)`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushdata(d)`'
- en: '`d = script_m.read(b)`'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 返回真。
- en: '`pushdata(d)`'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_pushnumber = range(0x51, 0x61) # 不包括0x61`'
- en: '`elif v == b’\x76’:`'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`val = script_b[-2]`'
- en: '`opDup()`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序10.10：** 识别P2SH脚本'
- en: '`elif v == b’\xa9’:`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个可以验证签名与P2SH交易输出的程序，我们需要能够识别P2SH，因为它涉及到三个连续的脚本执行。以下是三个执行脚本：
- en: '`opHash160()`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`sig_index += 1`'
- en: '`elif b in g_pushnumber:`'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`for pubkey_b in pubkey_l:`'
- en: '`opNum(b)`'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`if b == 0x00:`'
- en: '`elif v == b’\x87’:`'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\x87’:`'
- en: '`opEqual()`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`opEqual()`'
- en: '`elif v == b’\x88’:`'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\x88’:`'
- en: '`opEqualVerify()`'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`opEqualVerify()`'
- en: '`elif v == b’\xac’:`'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xac’:`'
- en: '`opCheckSig(script_b, inp_index, tx)`'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`opCheckSig(script_b, inp_index, tx)`'
- en: '`elif v == b’\xae’:`'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xae’:`'
- en: '`opCheckMultisig(script_b, inp_index, tx)`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`opCheckMultisig(script_b, inp_index, tx)`'
- en: '**Program 10.11:** P2SH script execution'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 10.11：P2SH 脚本执行**'
- en: 'The following method performs P2SH script verification:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法执行 P2SH 脚本验证：
- en: '`def verifyScript(tx: dict, inp_index: int):`'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`def verifyScript(tx: dict, inp_index: int):`'
- en: '`isP2SH = False`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`isP2SH = False`'
- en: '`scriptsig_b = getScriptSig(tx, inp_index)`'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptsig_b = getScriptSig(tx, inp_index)`'
- en: '`execScript(scriptsig_b, inp_index, tx)`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(scriptsig_b, inp_index, tx)`'
- en: '`prev_scriptpubkey_b = getPrevScriptPubKey(tx, inp_index)`'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = getPrevScriptPubKey(tx, inp_index)`'
- en: '`if checkWrappedMultisig(st) == True:`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedMultisig(st) == True:`'
- en: '`redeemscript_b = st[-1]`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeemscript_b = st[-1]`'
- en: '`isP2SH = True`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`isP2SH = True`'
- en: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
- en: '`status = st.pop()`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`status = st.pop()`'
- en: '`if status == b’\x01’:`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`if status == b’\x01’:`'
- en: '`print(‘1st Script succeeded’)`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script succeeded’)`'
- en: '`elif status == b’\x01’:`'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif status == b’\x01’:`'
- en: '`print(‘1st Script Failed’)`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script Failed’)`'
- en: '`else:`'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘1st Invalid state’)`'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Invalid state’)`'
- en: '`if isP2SH == True:`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isP2SH == True:`'
- en: '`execScript(redeemscript_b, inp_index, tx)`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(redeemscript_b, inp_index, tx)`'
- en: '`status = st.pop()`'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`status = st.pop()`'
- en: '`if status == b’\x01’:`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`if status == b’\x01’:`'
- en: '`print(‘2nd Script succeeded’)`'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Script succeeded’)`'
- en: '`elif status == b’\x01’:`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif status == b’\x01’:`'
- en: '`print(‘2nd Script Failed’)`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Script Failed’)`'
- en: '`else:`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘2nd Invalid state’)`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Invalid state’)`'
- en: '**Program 10.12:** P2SH verification method'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 10.12：P2SH 验证方法**'
- en: 'We call the preceding method as follows to verify a transaction scriptSig:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用前面所述方法来验证交易 scriptSig：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`txid_s = ‘8b3e54e345d0b3e9278a27f1ab2aa2566aba8cbe7cf44b9aa1836c9d0fcc2625’`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_s = ‘8b3e54e345d0b3e9278a27f1ab2aa2566aba8cbe7cf44b9aa1836c9d0fcc2625’`'
- en: '`inp_index = 0`'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_index = 0`'
- en: '`txid_b = bytes.fromhex(txid_s)[::-1]`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = bytes.fromhex(txid_s)[::-1]`'
- en: '`tx = findTransaction(txid_b, txindex_db_g)`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = findTransaction(txid_b, txindex_db_g)`'
- en: '`verifyScript(tx, inp_index)`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, inp_index)`'
- en: Since you have understood how transactions are verified, we will now create
    transactions and move the `**regtest**` bitcoin from one address to another.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经理解了交易是如何被验证的，我们现在将创建交易并将 `**regtest**` 比特币从一个地址转移到另一个地址。
- en: '[Building transactions](toc.xhtml#s225a)'
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**构建交易**'
- en: 'We are trying to create a transaction in this subtopic. To build a transaction,
    we need to fund the transaction from the previous transaction. Since we don’t
    want to use real bitcoin and want to easily mine a block, we are using a `**regtest**`
    environment. The transaction output we are using needs to be unspent. If the transaction
    is already confirmed, we can find the transaction in the *chainstate database*.
    If the funding transaction is not confirmed, it will be in the mempool. We are
    using the funding transaction from the chainstate database and not looking at
    mempool. We have already defined the method to retrieve UTXO from the chainstate
    database. The following method is used to get unspent output information:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在本子主题中尝试创建一个交易。为了构建交易，我们需要从之前的交易中资助交易。由于我们不想使用真实的比特币并且想要容易地挖出一个区块，我们使用了一个
    `**regtest**` 环境。我们使用的交易输出需要是未花费的。如果交易已经被确认，我们可以在 *链状态数据库* 中找到该交易。如果资助交易没有确认，它将位于
    mempool 中。我们使用来自链状态数据库的资助交易，而不是查看 mempool。我们已经定义了从链状态数据库检索 UTXO 的方法。以下方法用于获取未花费输出信息：
- en: '`getUnspentTransactions`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUnspentTransactions`'
- en: We can look at the method implementation in ***[Chapter 6, Blockchain, Transactions,
    and Mining](c06.xhtml)****,* **under** the s**ubtopic** ***UTXO***, ***Program
    6.****20*. We use this method to get `**scriptPubKey**` for P2PKH transactions.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在****[第 6 章，区块链，交易和挖矿](c06.xhtml)****的 s**ubtopic** ***UTXO***，***程序 6.****20*
    中查看方法实现。我们使用这个方法来获取 P2PKH 交易的 `**scriptPubKey**`。
- en: 'The following program returns the execution script that is required in the
    creation of P2SH transaction and in signing preimage for both P2SH and P2PKH.
    In the following program, the first argument is the transaction structure, which
    is a `***dict***` containing the information required to build the required transaction.
    The following method will be used later to get bytes from the hex string of script
    given in the transaction structure:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '`def getExecutionScript(txn_struct: dict, inp_index: int):`'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][inp_index]`'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '`script_type = inp[‘script_type’]`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '``if script_type[:4] == ‘P2SH’:`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(inp[‘redeem_script’])`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '`elif script_type == ‘P2PKH’:`'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = bytes.fromhex(inp[‘script_pubkey’])`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '`return script_b`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.13:** Get execution script for substituting Signature in Preimage'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: The bytes of script we obtained in the preceding method is an input to the `**createSignaturePreimage**`
    method*.*
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following methods, we will generate script in bytes from given address.
    We have already taken a look at the structure of P2PKH and P2SH in the preceding
    sections, where we discussed P2PKH and P2H scripts:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '`def getScriptPubkeyP2PKH(address: str):`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '`pkh_b = address2PubkeyHash(address)`'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '`pkhSize_b = encodePushdata(len(pkh_b))`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_DUP, OP_HASH160]) \`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '`+ pkhSize_b + pkh_b \`'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '`+ bytes([OP_EQUALVERIFY]) \`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '`+ bytes([OP_CHECKSIG])`'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptPubkey_b`'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '`def getScriptPubkeyP2SH(address: str):`'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '`sh_b = address2PubkeyHash(address)`'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '`shSize_b = encodePushdata(len(sh_b))`'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_HASH160]) \`'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '`+ shSize_b \`'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '`+ sh_b \`'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '`+ bytes([OP_EQUAL])`'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptPubkey_b`'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '`def getScriptPubkeyFromAddress(address: str):`'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '`pkh_b = address2PubkeyHash(address)`'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '`pkhSize_b = encodePushdata(len(pkh_b))`'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '`script_type = getScriptTypeFromAddress(address)`'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '`if script_type == ‘P2PKH’:`'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = getScriptPubkeyP2PKH(address)`'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '`elif script_type == ‘P2SH’:`'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = getScriptPubkeyP2SH(address)`'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptPubkey_b`'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.14:** Prepare Script Pubkey from Address'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method generates sequence in bytes for transaction inputs based
    on the `**locktime**` field:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '`def getSequence(txn_struct: dict):`'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '`if txn_struct[‘locktime’] > 0:`'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_b = bytes([0xfe, 0xff, 0xff, 0xff])`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_b = bytes([0xff, 0xff, 0xff, 0xff])`'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '`return sequence_b`'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.15:** Return sequence using given locktime'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the utility methods which are used in the succeeding methods:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '`def createVarInt(i: int):`'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '`if i < 0xfd:`'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes([i])`'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '`elif i < 0xffff:`'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\xfd’ + struct.pack(‘<H’, i)`'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '`elif i < 0xffffffff:`'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\xfe’ + struct.pack(‘<L’, i)`'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '`elif i < 0xffffffffffffffff:`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '`return b’\xff’ + struct.pack(‘<Q’, i)`'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '`def address2PubkeyHash(address: str):`'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '`pkh = base58checkDecode(address)`'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '`return pkh`'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '`def encodePushdata(length: int):`'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '`if length <= 0x4b:`'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes([length])`'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '`if length <= 0xff:`'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes([OP_PUSHDATA1, length])`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '`if length <= 0xffff:`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes([OP_PUSHDATA2]) + struct.pack(‘<H’, length)`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '`if length <= 0xffffffff:`'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '`return bytes([OP_PUSHDATA4]) + struct.pack(‘<L’, length)`'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '`def getScriptTypeFromAddress(address: str):`'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '`if address[0] in [‘m’, ‘n’] or address[0] == ‘1’:`'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '`return “P2PKH”`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '`elif address[0] == ‘2’ or address[0] == ‘3’:`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '`return “P2SH”`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '*[Figure 10.16:](#fig10_16)* Utility methods required for building transactions'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the opcodes used by the methods to create transaction:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_0 = 0x00`'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_DUP = 0x76`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_EQUAL = 0x87`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_EQUALVERIFY = 0x88`'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_HASH160 = 0xa9`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSIG = 0xac`'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKMULTISIG = 0xae`'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature preimage is the message that is signed using the private key
    of the sender. The following method generates signature preimage using the preceding
    methods:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignaturePreimage(txn_struct: dict,`'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b: bytes,`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_index: int):`'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b = b’’`'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘version’])`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘input_count’])`'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in range(txn_struct[‘input_count’]):`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][i]`'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += bytes.fromhex(inp[‘prevtxn’])[::-1]`'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, inp[‘prevtxnindex’])`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '`if i == inp_index:`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(script_b))`'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += script_b`'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += b’\x00’`'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += getSequence(txn_struct)`'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘out_count’])`'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '`for out in range(txn_struct[‘out_count’]):`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '`satoshis = txn_struct[‘outputs’][out][‘satoshis’]`'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<Q’, satoshis)`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '`address = txn_struct[‘outputs’][out][‘address’]`'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = getScriptPubkeyFromAddress(address)`'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(scriptPubkey_b))`'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += scriptPubkey_b`'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘locktime’])`'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype = txn_struct[‘inputs’][inp_index][‘hash_type’]`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, hashtype)`'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘preimage = ‘, preimage_b.hex())`'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '`return preimage_b`'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.17:** Prepare Signature Preimage'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: We generate a signature by signing the signature preimage using the private
    key. The signature is appended with `**hash_type**`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '`from ecdsa import SigningKey, SECP256k1`'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '`from ecdsa.util import sigencode_der_canonize`'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '`def signMessage(preimage_b: bytes,`'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey_wif: str,`'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '`hash_type: int):`'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '`hash_preimage = hash256(preimage_b)`'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey_s, network, compress = privkeyWif2Hex(privkey_wif)`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '`if privkey_s.__len__() % 2 == 1:`'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey_s = “0{}”.format(privkey_s)`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '`if compress == True:`'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘compress is true’)`'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey_b = bytes.fromhex(privkey_s)[:-1]`'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey_b = bytes.fromhex(privkey_s)`'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '`sk = SigningKey.from_string(privkey_b, curve=SECP256k1)`'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '`sig_b = sk.sign_digest(hash_preimage,`'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '`sigencode=sigencode_der_canonize) \`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '`+ bytes([hash_type])`'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '`return sig_b`'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.18:** Method for signing message'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we call the following method in the `**ecdsa**` package:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '`sk.sign_digest(hash_preimage,`'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '`sigencode=sigencode_der_canonize)`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: This method generates a signature using a hash of preimage and private key.
    We know that the generated signature consists of R and S. Since Bitcoin uses elliptic
    curve algorithm `**SECP256k1**`, which is symmetric on the X-axis, it is possible
    to get the same signature using –S. This means there are two valid signatures
    for the same private key and message. Since the signature is part of the transaction,
    it makes two transaction IDs to represent the same transaction, which is a security
    problem, also called **transaction malleability**. There are other ways in which
    transaction malleability can occur. To avoid this problem, we use smaller of the
    S and –S. This is the reason we pass the `**sigencode_der_canonize**` argument
    to the method, which only generates **low S**.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, `**ScriptSig**` has the following structure:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '**P2PKH:** `<Signature> <Public Key>`'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P2SH:** `OP_0 <Signature 1><Signature 2> … <Signature N> <Redeem Script>`'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create the scriptSig for each funding transaction output:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '`def getSignaturesAndExecScripts(txn_struct: dict):`'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l = []`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l = []`'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '`for inp_index in range(txn_struct[‘input_count’]):`'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][inp_index]`'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = getExecutionScript(txn_struct, inp_index)`'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b = createSignaturePreimage(txn_struct, script_b, inp_index)`'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][inp_index]`'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp = []`'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '`for privkey in inp[‘privkeys’]:`'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype = inp[‘hash_type’]`'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '`sign_b = signMessage(preimage_b, privkey, hashtype)`'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp.append(sign_b)`'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l.append(signgrp)`'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l.append(script_b)`'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn_struct, signgrp_l, script_l`'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.19:** Method for preparing a list of signatures and scripts'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the list of `**scriptSig**` and transaction structure to prepare the
    required transaction, as follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '`def getWithPushdata(data_b: bytes):`'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '`pushdata_b = encodePushdata(len(data_b))`'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '`return pushdata_b + data_b`'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '`def createScriptSigForMultiSig(signgrp: list, script_b: bytes):`'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = bytes([OP_0])`'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '`for sign_b in signgrp:`'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(sign_b)`'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(script_b)`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '`def createScriptSigForP2PKH(txn_input: dict, signgrp: list):`'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '`sign_b = signgrp[0] # it’s not a group.. just one signature`'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = getWithPushdata(sign_b)`'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '`privkey = txn_input[‘privkeys’][0]`'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = privkeyWif2pubkey(privkey)`'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(pubkey_b)`'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignedInput(txn_input: dict, signgrp, script_b: bytes):`'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtxn = txn_input[‘prevtxn’]`'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtx_rb = bytes.fromhex(prevtxn)[::-1]`'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtxnindex = txn_input[‘prevtxnindex’]`'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxnin_b = prevtx_rb + struct.pack(‘<L’, prevtxnindex)`'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '`if txn_input[‘script_type’] == ‘P2SH_Multisig’:`'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForMultiSig(signgrp, script_b)`'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2PKH’:`'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForP2PKH(txn_input, signgrp)`'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxnin_b += createVarInt(len(scriptSig_b)) + scriptSig_b`'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '`return sgntxnin_b`'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '`# In P2PKH script scriptSig is signature + pubkey`'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '`def scriptSigFromSignNPubkey(sign_b: bytes, pubkey_b: bytes):`'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = getWithPushdata(sign_b)`'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(pubkey_b)`'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignedTransaction(txn_struct: dict, signgrp_l: list, script_l: list):`'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b = b’’`'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<L’, txn_struct[‘version’])`'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(txn_struct[‘input_count’])`'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in range(txn_struct[‘input_count’]):`'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input = txn_struct[‘inputs’][i]`'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createSignedInput(txn_input, signgrp_l[i], script_l[i])`'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += getSequence(txn_struct)`'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(txn_struct[‘out_count’])`'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '`for out in range(txn_struct[‘out_count’]):`'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '`satoshis = txn_struct[‘outputs’][out][‘satoshis’]`'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<Q’, satoshis)`'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '`address = txn_struct[‘outputs’][out][‘address’]`'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = getScriptPubkeyFromAddress(address)`'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(len(scriptPubkey_b))`'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += scriptPubkey_b`'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<L’, txn_struct[‘locktime’])`'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '`return sgntxn_b`'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.20:** Create signed transaction'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create a transaction for both P2PKH and P2SH and publish it on the
    Bitcoin network. For this, we will require private keys, public keys, and addresses.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: We generate the keys and addresses using the method described in *[Chapter 9,
    Wallets and Addresses](c09.xhtml),* **under** the s**ubtopic** *Format and generation
    of private key, publickey, and address*.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following private key, public key, and addresses:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '| **Private Keys** | **Public Keys** | **Addresses** |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
- en: '| KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53 | 0281238fc6d981efce6aa1b3ccb8556a1b115a40f8ab3315c003f415ceedc3defe
    | msMV395AdBAk2SfdDhBLq4uJZRS7doCn5T |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
- en: '| L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ | 037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7
    | n1WvYkKU9i5RymcHeKFT4UworwqS6BKFSf |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
- en: '| KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG | 02fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d0
    | miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
- en: '| KyWeQEcM2YdirR2E7JwxSRjfgNuWyt4DR3v4sGtPvmeZqhTxWVrp | 02d50250aa629914e3146a
    5123a362a516c8aa95e5f0a6f3a078bd31fabe383abc | msV23rBcHAtQWSkWV9ph91DV65VduWi1Vt
    |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
- en: '| Ky5CYfpeMkfFku7K4FvzeEwRmTJhWqD2eFiMnjLT7uw2oUVMgyg6 | 0319b4b9ab4732e78dab0e48c2c54fd57dd35350a0269f8c041807c3b798aa1872
    | mnhWcUMqe9J1G4t3NMqNmLUqxfPTgwv7NK |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
- en: '| L1cnATDVZyvuo9m6tprCmbr14vm3JeCbkc4Z2397ZM7P96N3d8GA | 039d5dbb6e052631c46e046c6d11fb95d257eae5093117d2c265aeb784dba4acf6
    | mtRkMmpT6uhM9LXVPRk4ck9Gcaz9iuQgmZ |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
- en: '| KyP1xynRgwrCUThXATVy5kbKqteAxisDFY74zrHozSGhb75hJ3M6 | 02dfa818542ab4685284f7c222d541e218aed0712fc9e63ca2802b15bb418383c9
    | n2DfL6uEmPiwJBYjJRzyqUYDSTqxF8XSNS |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
- en: '**Table 10.3:** Few test addresses, public keys, and private keys'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the Bitcoin Core daemon for `**regtest**` as shown here:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '`bitcoind -regtest -printtoconsole –rpcuser=test –rpcpassword=test -txindex=1`'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[Building P2PKH transaction](toc.xhtml#s226a)'
  id: totrans-779
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[构建P2PKH交易](toc.xhtml#s226a)'
- en: We then connect the daemon and generate two blocks, sending bitcoin to a particular
    `**regtest**` address.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后连接守护进程并生成两个区块，将比特币发送到一个特定的`**regtest**`地址。
- en: To do this, run Bitcoin Core CLI with the `**regtest**` option, giving optional
    parameters `**rpcuser**` and `**rpcpassword**`. The `**rpcuser**` and `**rpcpassword**`
    options allow a client to make `**rpc**` connections. This is required for connecting
    using Python package but not for connecting using CLI.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请运行带有`**regtest**`选项的Bitcoin Core CLI，提供可选参数`**rpcuser**`和`**rpcpassword**`。`**rpcuser**`和`**rpcpassword**`选项允许客户端进行`**rpc**`连接。这对于使用Python包进行连接是必需的，但对于使用CLI进行连接则不是必需的。
- en: In the following CLI statement, we are generating two blocks, and each newly
    created block pays 50![](images/Bitcoin.jpg) to the given address. The payment
    transactions are coinbase transactions that are included in each generated block.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下CLI语句中，我们生成两个区块，每个新生成的区块向给定地址支付50![](images/Bitcoin.jpg)。支付交易是coinbase交易，包含在生成的每个区块中。
- en: '![](images/Figure-10.12.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.12.jpg)'
- en: '**Figure 10.12:** Shows the generated blocks that pay to the given address'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.12：** 显示了生成支付给给定地址的区块'
- en: 'We get the coinbase transactions from the block hashes:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从块散列中获取coinbase交易：
- en: '![](images/Figure-10.13.jpg)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.13.jpg)'
- en: '**Figure 10.13:** Shows the coinbase transactions of the generated blocks'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.13：** 显示生成的区块的coinbase交易'
- en: 'So, we have two transactions now holding 50 regtest bitcoins each:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在有两个持有每个50 regtest比特币的交易：
- en: '`5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f`'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '`5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f`'
- en: '`53793974d074e57305575d711fd0acd1d39f406264de234e686542ad2d0ddbfb`'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`53793974d074e57305575d711fd0acd1d39f406264de234e686542ad2d0ddbfb`'
- en: 'We also get `**scriptPubKey**` from the first transaction output as follows:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个交易输出中获取`**scriptPubKey**`，如下所示：
- en: '![](images/Figure-10.14.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.14.jpg)'
- en: '**Figure 10.14:** Shows the scriptPubKey obtained from the first output of
    funding transaction'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.14：** 显示了来自资助交易第一个输出的scriptPubKey。'
- en: Now, we have two blocks in the blockchain each with 50![](images/Bitcoin.jpg).
    There is a rule that a coinbase transaction cannot be spent for the next 100 blocks.
    This rule is useful if there is an attack on the network or if there is any critical
    bug and it becomes necessary to reorg the Bitcoin blockchain. This means we need
    to invalidate the previous version of the software, which has mined recent blocks,
    and deploy the new software, which fixes the issue. We may also need to invalidate
    some blocks that are already mined. The 100 blocks give nearly 16 hours to developers
    to fix the network. In the past, Bitcoin developers had to perform reorg twice
    once in 2010 and once in 2013\. This obviously affects the creditability of the
    network, and we don’t want it to happen again.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在区块链中有两个区块，每个区块都有50![](images/Bitcoin.jpg)。有一个规则， coinbase交易在接下来的100个区块内不能被花费。这个规则在网络遭受攻击或存在任何严重错误时很有用，需要重新组织比特币区块链。这意味着我们需要使软件的先前版本作废，部署修复问题的的新软件。我们可能还需要作废一些已经挖出的区块。这100个区块为开发者提供了大约16个小时来修复网络。过去，比特币开发者不得不进行两次重组，一次是2010年，一次是2013年。这显然影响了网络的可信度，我们不希望再次发生。
- en: 'We will just mine another 100 blocks, as follows, to be able to use the preceding
    transactions:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将挖掘另外100个区块，如下所述，以便能够使用之前的交易：
- en: '![](images/Figure-10.15.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.15.jpg)'
- en: '**Figure 10.15:** Shows the commpand executed to generate 100 blocks'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.15：** 显示生成100个区块的执行命令'
- en: 'We will use the locked bitcoins in two transactions and send them to two different
    addresses and leave 0.0001 regtest bitcoins as network fees. We first create a
    raw transaction without a signature. The following code defines the structure
    of the raw transaction:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个交易中的锁定比特币并将它们发送到两个不同的地址，并将0.0001 regtest比特币作为网络费用留下。我们首先创建一个没有签名的原始交易。以下代码定义了原始交易的结构：
- en: '`def createTransactionStruct():`'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createTransactionStruct():`'
- en: '`txn = {}`'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn = {}`'
- en: '`txn[‘version’] = 1`'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘version’] = 1`'
- en: '`txn[‘input_count’] = 2`'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘input_count’] = 2`'
- en: '`txn[‘inputs’] = []`'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘inputs’] = []`'
- en: '`input0 = {}`'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '`input0 = {}`'
- en: '`input0[‘prevtxn’] = \`'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`input0[‘prevtxn’] = \`'
- en: '`‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
- en: '`input0[‘prevtxnindex’] = 0`'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`input0[‘prevtxnindex’] = 0`'
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`input0[‘script_type’] = ‘P2PKH’`'
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '`input1 = {}`'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘prevtxn’] = ‘53793974d074e57305575d711fd0acd1d39f406264de234e686542ad2d0ddbfb’`'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘prevtxnindex’] = 0`'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘script_type’] = ‘P2PKH’`'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘hash_type’] = SIGHASH_ALL`'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input1)`'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 40*(10**8)`'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 599999*(10**4)`'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 110 # block height`'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.21:** Method creating transaction structure to be used as input
    for P2PKH transaction creation'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the methods to get signed transaction using the following code:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_struct = createTransactionStruct()`'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_struct, signgrp_l, script_l = getSignaturesAndExecScripts(txn_struct)`'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '`signed_txn_b = createSignedTransaction(txn_struct, signgrp_l, script_l)`'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '`print(signed_txn_b.hex())`'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the signed transaction:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.16.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.16:** Shows the signed transaction created by the program'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the Bitcoin Core daemon for `**regtest**` by using the *–*`**regtest**`
    option. We execute the client as follows:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.17.jpg)'
  id: totrans-846
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.17:** Shows the transaction failed to publish'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'We got an error message non-final because locktime is higher than the current
    block count:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.18.jpg)'
  id: totrans-849
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.18:** Shows the command to get latest block height'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: 'We create 8 more blocks and then publish the transaction again:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.19.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.19:** Shows the transaction is published once the locktime condition
    is fulfilled'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the transaction was successfully published, and we got the transaction
    ID:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '`efc4b90d71ff1e726924a5719fdbe9a548910aae20988c3dfa398575992100d6`'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the transaction that was published by executing the following command:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.20.jpg)'
  id: totrans-857
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.20:** Shows transaction hex data in mempool using Bitcoin Core
    CLI command'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this transaction into the block, we generate another block, as follows:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.21.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.21:** Shows the next block is mined'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can see that the published transaction is added to the new block:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.22.jpg)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.22:** Shows the transaction in mined in the next block'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: We can see that on generating a block, the new transaction we created is added
    to the newly generated block. Now, the transaction is confirmed, and its depth
    is 1.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: The next section will explain the creation and publishing of P2PKH transactions.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释P2PKH交易的创建和发布。
- en: '[Building P2SH transaction](toc.xhtml#s227a)'
  id: totrans-867
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**构建P2SH交易](toc.xhtml#s227a)'
- en: In this section, we will create a transaction and publish it. To do that, we
    need to generate a block that pays to a P2SH address. The P2SH address is generated
    by generating hash160 of redeem script.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个交易并发布它。为此，我们需要生成一个区块，该区块支付给P2SH地址。P2SH地址是通过生成赎回脚本的hash160值生成的。
- en: 'We use the following method to generate redeem script:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方法生成赎回脚本：
- en: '`OP_CHECKMULTISIG = 0xae`'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '`OP_CHECKMULTISIG = 0xae`'
- en: '`def createRedeemScript(pubkey_l: list, sigcount: int):`'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createRedeemScript(pubkey_l: list, sigcount: int):`'
- en: '`redeem_script_b = bytes([0x50 + sigcount])`'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeem_script_b = bytes([0x50 + sigcount])`'
- en: '`for pubkey in pubkey_l:`'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '`for pubkey in pubkey_l:`'
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = bytes.fromhex(pubkey)`'
- en: '`redeem_script_b += encodePushdata(len(pubkey_b)) + pubkey_b`'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeem_script_b += encodePushdata(len(pubkey_b)) + pubkey_b`'
- en: '`redeem_script_b += bytes([0x50 + len(pubkey_l), OP_CHECKMULTISIG])`'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeem_script_b += bytes([0x50 + len(pubkey_l), OP_CHECKMULTISIG])`'
- en: '`return redeem_script_b`'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '`return redeem_script_b`'
- en: '**Program 10.22:** Method to create redeem scripts for multisig'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序10.22：** 创建多签名赎回脚本的方法'
- en: We are creating redeem script, which requires two signatures using private keys
    related to the three public keys. So, we are going to use 2-of-3 `**multisig**`.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建赎回脚本，这需要使用与三个公钥相关的私钥的两个签名。所以，我们将使用2-of-3 `**多签名**`。
- en: 'We pass three public keys, and the required count of signature is 2 in the
    following code:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递三个公钥，以下代码中所需的签名数量是2：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`pubkey_l = [‘037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7’,
    ‘02fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d0’, ‘02d50250aa629914e3146a5123a362a516c8aa95e5f0a6f3a078bd31fabe383abc’]`'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_l = [‘037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7’,
    ‘02fcb1c7507db15576ab35cd7c9b1ea570'
- en: '`redeem_script_b = createRedeemScript(pubkey_l, 2)`'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeem_script_b = createRedeemScript(pubkey_l, 2)`'
- en: '`print(‘redeem script = %s’ % redeem_script_b.hex())`'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘赎回脚本 = %s’ % redeem_script_b.hex())`'
- en: '`sh = hash160(redeem_script_b)`'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`sh = hash160(redeem_script_b)`'
- en: '`address = sh2address(sh)`'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = sh2address(sh)`'
- en: '`print(‘P2SH address = %s’ % address)`'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH地址 = %s’ % 地址)`'
- en: 'On executing the preceding lines of code, we get the following result:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码行后，我们得到以下结果：
- en: '![](images/Figure-10.23.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.23.jpg)'
- en: '**Figure 10.23:** Shows the P2SH address generated using redeem script'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.23：** 显示使用赎回脚本生成的P2SH地址'
- en: 'We use the preceding address to generate a block and receive bitcoin, as follows:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的地址生成一个区块并接收比特币，如下所示：
- en: '![](images/Figure-10.24.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.24.jpg)'
- en: '**Figure 10.24:** Shows the generated block that pays to the P2SH address'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.24：** 显示支付给P2SH地址生成的区块'
- en: 'Next, we use the blockhash in the preceding Bitcoin Core CLI command to get
    the transaction-ID of the coinbase transaction:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用前一个Bitcoin Core CLI命令中的区块散列来获取coinbase交易的交易ID：
- en: '![](images/Figure-10.25.jpg)'
  id: totrans-895
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.25.jpg)'
- en: '**Figure 10.25:** Shows the coinbase transaction that will pay to the P2SH
    transaction'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.25：** 显示将支付给P2SH交易的coinbase交易'
- en: We need to get the structure of the generated transaction since we need to use
    the transaction output in a transaction.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取生成的交易的结构，因为我们需要使用交易输出在交易中。
- en: 'We get raw transaction by executing the following command:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行以下命令获取原始交易：
- en: '![](images/Figure-10.26.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.26.jpg)'
- en: '**Figure 10.26:** Shows the hex data of the coinbase transaction that pays
    to the P2SH address'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.26：** 显示支付给P2SH地址的coinbase交易的十六进制数据'
- en: 'By executing the following command, we get transaction structure from the raw
    transaction:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令，我们从原始交易中获取交易结构：
- en: '![](images/Figure-10.27.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.27.jpg)'
- en: '**Figure 10.27:** Shows the command to get content in the transaction hex data'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.27：** 显示获取交易十六进制数据内容的命令'
- en: 'The following is the structure of the raw transaction generated from the preceding
    command:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面命令生成的原始交易结构：
- en: '![](images/Figure-10.28.jpg)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-10.28.jpg)'
- en: '**Figure 10.28:** Shows the decoded transaction data'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.28：** 显示解码的交易数据'
- en: 'We create a transaction structure using the transaction IDs of generated transaction
    for P2SH transaction, as follows:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成的交易ID为P2SH交易创建交易结构，如下所示：
- en: '`def createTransactionStruct():`'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createTransactionStruct():`'
- en: '`txn = {}`'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn = {}`'
- en: '`txn[‘version’] = 1`'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘version’] = 1`'
- en: '`txn[‘input_count’] = 1`'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘input_count’] = 1`'
- en: '`txn[‘inputs’] = []`'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn[‘inputs’] = []`'
- en: '`input0 = {}`'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = \`'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '`‘de32b06aeb0103381df84d2cc5ea80a35b60bce0c6393bd9436cb395e3f47a5d’`'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2SH_Multisig’`'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = \`'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '`[‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’,`'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '`‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘redeem_script’] = ‘5221037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f72102fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d02102d50250aa629914e3146a5123a362a516c8aa95e5f0a6f3a078bd31fabe383abc53ae’`'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 10*(10**8)`'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 399999*(10**4)`'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0 # block height`'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_struct = createTransactionStruct()`'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_struct, signgrp_l, script_l = getSignaturesAndExecScripts(txn_struct)`'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '`signed_txn_b = createSignedTransaction(txn_struct, signgrp_l, script_l)`'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '`print(signed_txn_b.hex())`'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 10.23:** Method creating transaction structure to be used as input
    for P2SH transaction creation'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the following signed transaction:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.29.jpg)'
  id: totrans-945
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.29:** Shows the signed transaction moving bitcoin from P2SH address'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to mine 100 blocks before we can fund a transaction from coinbase transaction
    output, so we will again execute CLI command `**generatetoaddress**`. Before publishing
    a transaction, we can test whether a transaction is valid. We can do it by running
    the following Bitcoin CLI command:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.30.jpg)'
  id: totrans-948
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.30:** Shows if the transaction is valid and is acceptable to mempool'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the transaction is valid, and if sent, will be accepted by the
    mempool. If we were working on real bitcoin, this command could save us by verifying
    that everything is just fine.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can publish the transaction as follows:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-10.31.jpg)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.31:** Shows the transaction moving bitcoin from P2SH address is
    published'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: We got `**66ce54d909c9309d8bee5035b261c639ee8e274947b15a6ea2d540a12beea5d2**`
    as the transaction ID. So, we were able to successfully build and publish P2SH
    transaction.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to build and publish transaction using information
    provided in a transaction structure.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s228a)'
  id: totrans-957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the Bitcoin scripting language, its features,
    and its execution. You learned how the scripting language is used in transaction
    verification. You learned about the different types of Scripts used by Bitcoin
    and understood the why and how of Bitcoin scripting. Additionally, you learned
    to create a transaction and publish it to the Bitcoin network. The chapter involved
    quite a bit of coding.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了比特币脚本语言、其特点以及执行方式。你了解到脚本语言在交易验证中的使用。你了解了比特币使用的不同类型的脚本，并理解了比特币脚本的为什么和如何。此外，你还学会了创建交易并将其发布到比特币网络。这一章涉及了不少编码。
- en: In the next chapter, you will learn and create smart contracts and other useful
    transactions.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习并创建智能合约和其他有用的交易。
- en: '[Points to remember](toc.xhtml#s229a)'
  id: totrans-960
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[需记住的要点](toc.xhtml#s229a)'
- en: Bitcoin transactions are secured by locking scripts that contain a hash, and
    if we want to use the transaction to fund the newly created transaction, then
    we need to present the corresponding script or public key.
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币交易通过包含哈希的锁定脚本来保证安全，如果我们想要使用交易来资助新创建的交易，那么我们需要呈现相应的脚本或公钥。
- en: To create a new transaction, we also need to provide a signature by signing
    a message based on the format required by the script type and hash-type.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建一个新交易，我们还需要提供一个签名，通过基于脚本类型和哈希类型所需的格式签署一条消息。
- en: Bitcoin scripting language is based on R*everse Posix* n*otation*.
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币脚本语言基于R*everse Posix* n*otation*。
- en: When a node receives a newly created transaction, it needs to verify it against
    consensus rules and needs to verify that the `**scriptSig**` used to unlock funds
    locked by `**scriptPubKey**`.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个节点接收到一个新创建的交易时，它需要根据共识规则验证它，并需要验证用于解锁由`**scriptPubKey**`锁定的资金的`**scriptSig**`。
- en: For the P2PKH script, `**scriptSig**` gets executed first, and then the same
    stack is used to execute the `**scriptPubKey**` from the previous transaction
    output. The result is at the top of the stack.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于P2PKH脚本，`**scriptSig**`首先被执行，然后使用同一个栈执行前一个交易输出的`**scriptPubKey**`。结果位于栈顶。
- en: For the P2SH script in the first pass, `**scriptSig**` is executed, and then
    `**scriptPubKey**` is executed. In the third pass, the signatures are first pushed
    to the stack, and then redeem script is executed.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一遍执行P2SH脚本时，执行`**scriptSig**`，然后执行`**scriptPubKey**`。在第三遍执行时，首先将签名推入栈中，然后执行赎回脚本。
- en: The newly created transaction can be published to the Bitcoin network by using
    the Bitcoin Core command `**sendrawtransaction**`.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新创建的交易可以通过使用Bitcoin Core命令`**sendrawtransaction**`发布到比特币网络。
- en: If you don’t want to maintain a full node, you can still publish the newly created
    transaction using SPV software. Additionally, several online sites can push the
    new transactions.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想维护一个完整节点，你仍然可以使用SPV软件发布新创建的交易。此外，还有几个在线网站可以推送新交易。
- en: Before sending the transaction, we can decode it using the Bitcoin Core command
    `**decoderawtransaction**`, allowing us to manually verify the transaction we
    created.
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送交易之前，我们可以使用Bitcoin Core命令`**decoderawtransaction**`对其进行解码，允许我们手动验证我们创建的交易。
- en: We can also check that the created transaction is valid by using the Bitcoin
    Core command `**testmempoolaccept**`.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用Bitcoin Core命令`**testmempoolaccept**`检查创建的交易是否有效。
- en: P2PKH and P2SH scripts hide public keys till the locked funds are used in a
    transaction.
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2PKH和P2SH脚本在解锁资金的交易中隐藏公钥。
- en: Scripting language provides a large number of operations that can be used to
    write complex smart contracts, but P2SH hides those complexities from the sender.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本语言提供了大量可以用来编写复杂智能合约的操作，但P2SH将这些复杂性隐藏发送者。
- en: '[Questions](toc.xhtml#s230a)'
  id: totrans-973
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[问题](toc.xhtml#s230a)'
- en: 'Write programs to create transactions:'
  id: totrans-974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写创建交易的程序：
- en: Create a P2PKH transaction with three inputs and three outputs; all of them
    have sighash type as SIGHASH_ALL|SIGHASH_ANYONECANPAY.
  id: totrans-975
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有三个输入和三个输出的P2PKH交易；它们的sighash类型都是SIGHASH_ALL|SIGHASH_ANYONECANPAY。
- en: Create a P2PKH transaction with three inputs and three outputs. Two inputs have
    sighash type as SIGHASH_NONE|SIGHASH_ANYONECANPAY, and the third input has sighash
    type SIGHASH_ALL.
  id: totrans-976
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有三个输入和三个输出的P2PKH交易。两个输入的sighash类型为SIGHASH_NONE|SIGHASH_ANYONECANPAY，第三个输入的sighash类型为SIGHASH_ALL。
- en: Create a P2PKH transaction with three inputs and three outputs. Two inputs have
    sighash type as SIGHASH_SINGLE|SIGHASH_ANYONECANPAY, and the third input has sighash
    type SIGHASH_ALL
  id: totrans-977
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有三个输入和三个输出的P2PKH交易。两个输入的sighash类型为SIGHASH_SINGLE|SIGHASH_ANYONECANPAY，第三个输入的sighash类型为SIGHASH_ALL
- en: Write a generic program to convert the hex code of any Bitcoin transaction script
    to a readable script.
  id: totrans-978
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个通用程序，将任何比特币交易脚本的十六进制代码转换为可读脚本。
- en: Why should all transactions have at least one input signed with SIGHASH_ALL?
  id: totrans-979
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么所有交易至少应该有一个输入使用SIGHASH_ALL签名？
- en: Calculate the transaction fees for a transaction that unlocks two P2PKH outputs
    from the previous transactions and locks output to two P2PKH scripts if the transaction
    fee per byte is 10 satoshi per byte.
  id: totrans-980
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算解锁前交易中的两个P2PKH输出并锁定到两个P2PKH脚本的交易费用，如果每字节交易费用为10萨思奇。
- en: 'Choose the right sighash type:'
  id: totrans-981
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择正确的sighash类型：
- en: SIGHASH_NONE|SIGHASH_ANYONECANPAY
  id: totrans-982
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SIGHASH_NONE|SIGHASH_ANYONECANPAY
- en: SIGHASH_SINGLE|SIGHASH_ANYONECANPAY
  id: totrans-983
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SIGHASH_SINGLE|SIGHASH_ANYONECANPAY
- en: SIGHASH_ALL|SIGHASH_ANYONECANPAY
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SIGHASH_ALL|SIGHASH_ANYONECANPAY
- en: Renuka got a job in a different country. Her friends planned and jointly bought
    a watch from a shop that accepts bitcoin as payment.
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 雷努卡在另一个国家找到了工作。她的朋友们计划并一起从接受比特币支付的商店购买了一块手表。
- en: A social service organization is buying clothes and food for earthquake victims.
    It requires people to contribute to them by giving signed transaction inputs.
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个社会服务机构正在为地震灾区购买衣物和食物。它要求人们通过提供已签名的交易输入来向他们捐款。
- en: A school wants to send its bright student to participate in a national academic
    conference. The participation fees are high, and the school wants to help the
    parents by subsidizing the cost of participation.
  id: totrans-987
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一所学校希望将其优秀学生送往参加全国学术会议。参会费用高昂，学校希望通过资助参会成本来帮助家长。
- en: 'True/False:'
  id: totrans-988
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：
- en: P2SH script of 1-of-1 multisig is not valid.
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1-of-1多签的P2SH脚本无效。
- en: P2PKH does not allow the use of an uncompressed public key.
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: P2PKH不允许使用未压缩的公钥。
- en: When creating a signature, we get two values of S, of which we select the smaller
    value of S.
  id: totrans-991
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建签名时，我们得到两个S值，我们选择较小的S值。
- en: 'Fill in the blanks:'
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填空：
- en: An exchange platform works as an escrow between buyers and sellers of bitcoin.
    A seller locks their bitcoin such that if any two among buyer, seller, and escrow
    agrees that the seller has received money then the bitcoin is released to the
    buyer. The platform implements _____ of _____ multisig.
  id: totrans-993
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个交易所平台作为买家和卖家之间的托管人。卖家锁定他们的比特币，这样如果买方、卖方和托管人中任意两人同意卖家已收到钱，那么比特币就会被释放给买家。该平台实现_____的_____多签名。
- en: An address is related to P2PKH or P2SH script can be determined by looking at
    __________ of address which is _____ for mainnet P2PKH and _______ for mainnet
    P2SH script.
  id: totrans-994
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个地址与P2PKH或P2SH脚本有关，可以通过查看地址的__________来确定，这对于主网P2PKH是_____，对于主网P2SH脚本是_______。
- en: A P2SH script is verified after executing ___________ script in addition to
    scriptSig and scriptPubKey.``
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行___________脚本之后，才会验证P2SH脚本，除此之外还需要scriptSig和scriptPubKey。``
