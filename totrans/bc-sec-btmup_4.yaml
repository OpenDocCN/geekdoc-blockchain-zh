- en: CHAPTER 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin, the original blockchain protocol, was primarily designed to implement
    a decentralized system for tracking financial transactions. While Bitcoin has
    some scripting capabilities, these programs are not Turing-complete, meaning they
    cannot implement all of the functionality that a program running on another computer
    could. This lack of Turing-completeness limits their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contract platforms extend the blockchain protocol to allow Turing-complete
    programs to run on top of the blockchain, dramatically expanding what can be done
    on the blockchain. Blockchain extensions go a step further, leveraging smart contracts''
    capabilities to build protocols that address key limitations of blockchain technology
    by building new protocols on top of them or interconnecting different blockchain
    systems.  ## Smart Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are programs that run on top of a blockchain's distributed ledger.
    The goal of smart contract platforms is to create a “world computer” where each
    node in the blockchain network maintains an instance of a virtual machine and
    the state of this virtual machine is synchronized across the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract platforms achieve synchronization by controlling the instructions
    that are run on the distributed virtual machine and the execution environment.
    Instructions are coordinated using the blockchain's distributed ledger and consensus
    algorithms. Instructions are embedded in transactions, which are organized into
    blocks and added to the ledger. This ensures that, if the network is in consensus
    regarding the state of the blockchain, every node agrees on the order in which
    transactions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract platforms control the execution environment by running these
    instructions in a virtual machine. Smart contracts' virtual machines are designed
    to create identical, deterministic execution environments on every node in the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, if every node runs the same code in identical environments, they
    should all have the exact same results. This makes it possible to maintain both
    decentralization and synchronization within the “world computer.”
  prefs: []
  type: TYPE_NORMAL
- en: '### Smart Contract Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are software, and software has bugs. Even as immature as smart
    contract technology is, there are a variety of common vulnerabilities already
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections cover some of the most common smart contract vulnerabilities.
    However, since the smart contract and smart contract security landscapes are constantly
    evolving, this will never be a comprehensive list of all possible smart contract
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this discussion, vulnerabilities are divided into four major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General Programming Vulnerabilities:** These vulnerabilities can exist in
    any application. Smart contracts contain them simply because they are programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blockchain-Specific Vulnerabilities:** These vulnerabilities arise from the
    unique design of blockchain technology. They are platform-agnostic and apply across
    most or all blockchain implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-Specific Vulnerabilities:** These vulnerabilities are specific to
    a certain smart contract platform. Ethereum and EOSIO are two of the oldest and
    most used smart contract platforms, which have provided the most opportunity for
    vulnerabilities to be discovered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application-Specific Vulnerabilities:** Smart contracts can be designed for
    different purposes. Decentralized finance (DeFi) and non-fungible tokens (NFTs)
    are two of the most common and fastest-growing applications of smart contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#### *General Programming Vulnerabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: General programming vulnerabilities are vulnerabilities that can exist in any
    program. They arise from how software works and manages variables, memory, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: A buffer overflow vulnerability is an example of a general programming vulnerability.
    Programs allocate chunks of memory to hold data, and problems can arise if the
    data to be placed in the buffer is larger than the buffer itself. As long as programs
    manage memory in this way, buffer overflows are a potential risk in languages
    that lack protections against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete list of all the potential general programming vulnerabilities that
    could exist in smart contracts is beyond the scope of this discussion. Some of
    the main vulnerabilities that appear in smart contracts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal precision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signature vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-to-left control characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsafe serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Arithmetic Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic vulnerabilities such as integer overflow and underflow vulnerabilities
    can exist in most programming languages. Arithmetic vulnerabilities are made possible
    by how variables work.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Variables and Signedness*'
  prefs: []
  type: TYPE_NORMAL
- en: A variable is a fixed-size chunk of memory designed to hold a value. How the
    series of bits stored in this variable is interpreted depends on the variable
    type. For example, both an `int` and a `float` can be 4 or 8 bytes long, but the
    same series of bits are interpreted in very different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Within the numeric data types, there is also the concept of signed vs. unsigned
    variables. As their names suggest, signed variables have a sign and the ability
    to hold negative values, while unsigned ones do not. In a signed variable, the
    most significant bit holds the sign, while in unsigned variables, this bit is
    part of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer overflow and underflow vulnerabilities are enabled by variables'' fixed
    sizes and the ability to cast a value between signed and unsigned types. Values
    stored in a variable must remain within a set range, and unsafe casts between
    variables can cause the same series of bits to be interpreted in different ways.  ######
    *Integer Overflows*'
  prefs: []
  type: TYPE_NORMAL
- en: An integer overflow vulnerability occurs when too small of a variable is used
    to hold a value. For example, a 32-bit unsigned integer can hold values in the
    range 0 to 4,294,967,295, while 32-bit signed integers can hold values in the
    range –2,147,483,648 to 2,147,483,647\. If a value greater than this maximum value
    is placed in the variable, the value saved is the value of the 32 least significant
    bits of the original number.
  prefs: []
  type: TYPE_NORMAL
- en: Integer overflows can occur in one of two ways. One option is that the result
    of a computation exceeds the maximum value that can fit in a variable. [Figure
    5.1](#c05-fig-0001) illustrates this for an 8-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: '![An illustration of integer overflow.](images/c05f001.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 5.1**](#R_c05-fig-0001): Integer overflow'
  prefs: []
  type: TYPE_NORMAL
- en: The other possibility is that an unsafe typecast forces a value into a variable
    too small to hold it. For example, the value 3000000000 fits into an unsigned
    integer but not a signed one.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample is from a smart contract containing an integer overflow
    vulnerability named batchOverflow by PeckShield.[¹](#c05-note-0001)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code sample is designed to send the same amount of value to multiple recipients.
    The code calculates the total amount of value to be sent and validates that the
    sender has at least this much value in their account. Then, it individually transfers
    value to each of the intended recipients.
  prefs: []
  type: TYPE_NORMAL
- en: This code has a potential integer overflow value in the calculation of *`amount`*.
    If the product of *`cnt`* and *`_value`* is at least 2^(256), then the value of
    *`amount`* will overflow. For example, a *`cnt`* of 8 and a *`_value`* of 2^(253)
    will produce a product of 2^(256), which is more than can fit in *`amount`*, resulting
    in a value of 0 being stored in *`amount`*. An *`amount`* of 0 will pass the test
    `balances[msg.sender] >= amount`, allowing the transfers to go through.
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing the transfers in the loop, the code uses the variable *`_value`*,
    which indicates the amount to be sent to each recipient. As a result, each recipient
    will receive a transfer of 2^(253) tokens, while the sender''s account is debited
    0 tokens (the value of *`amount`*). These recipients could then later withdraw
    their balances from the contracts, extracting value that legitimately belongs
    to other users.  ###### *Integer Underflows*'
  prefs: []
  type: TYPE_NORMAL
- en: Integer underflows exist when a variable is asked to store a value lower than
    its minimum value. This too can occur as a result of a calculation or due to trying
    to use the wrong variable type to store a value.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned variables can only store positive numbers, so any value less than zero
    will underflow the variable. This could occur as a result of a mathematical operation
    or due to an unsafe cast from a signed variable, which can store negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample is an example of a withdraw function that contains
    an integer underflow vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code sample, the purpose of the `require` statement is to validate that
    an account contains the requested amount before allowing it to be withdrawn. In
    theory, subtracting the amount from the balance and testing that the result is
    nonnegative should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the variables used in the calculation (*`amount`* and *`balances`*)
    are both unsigned integers, which means that the result will be an unsigned integer
    as well. Since unsigned integers cannot store a negative number, the result of
    the calculation will always be greater than or equal to zero. As a result, the
    `require` statement will approve any withdrawal request, enabling a malicious
    user to steal value from the contract.  ###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic vulnerabilities generally result from using the wrong variable type
    for an operation or an unsafe conversion between variable types. These may be
    detected by automated tools or should be picked up by a code review.  ###### *Case
    Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In December 2021, the PIZZA DeFi project was exploited for $5 million in tokens.
    The attackers took advantage of an integer overflow vulnerability in the eCurve
    smart contract to create a massive amount of Tripool tokens.[²](#c05-note-0002)
    These tokens were then deposited into the PIZZA smart contract, which allowed
    the attacker to extract the other tokens deposited within the contract.  #####
    Decimal Precision'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts commonly contain mathematical operations, especially when they
    store and transfer value. One common vulnerable code pattern is division before
    multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: In Solidity—and any other programming language—numeric data types have limited
    precision. While this may not matter in most cases, division and multiplication
    with large numbers can cause small rounding errors to have significant effects.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample uses a divide-before-multiply code pattern when calculating
    the value of a token.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Solidity works with integer data types, which means the result of the division
    will be rounded before the multiplication is performed. This could result in a
    final answer that is different and smaller than if multiplication were performed
    before division. As a result, the token is undervalued, and the user receives
    less in trade than they should.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing multiplication and division in Solidity, use the multiply-before-divide
    code pattern. This helps to preserve the precision of the result but risks integer
    overflows.  ##### Digital Signature Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures provide the ability to authenticate a transaction and validate
    that it has not been modified in transit. Digital signatures are commonly used
    in smart contracts, especially in the DeFi space.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, digital signatures can go wrong in a few different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Missing Validation:** Digital signatures are useful only if they are validated.
    Missing signature validation can allow an attacker to submit fake requests on
    behalf of other users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptographic Errors:** Cryptographic algorithms can be fragile and must
    be properly implemented to be secure. One example of a cryptographic vulnerability
    is the reuse of random values across multiple signatures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malleable Signatures**: In some cases, the data covered by a digital signature
    may be interpreted in different ways, due to serialization or other factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The effects of digital signature errors depend on the vulnerability in question.
    They range from accepting a forged transaction to providing the attacker with
    complete control over the account used to generate the signature.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures should be implemented with trusted cryptographic libraries
    whenever possible. Also, code should ensure that signatures are validated before
    accepting transactions.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: In July 2021, the Anyswap protocol was the victim of a hack due to cryptographic
    errors in its implementation of the Elliptic Curve Digital Signature Algorithm
    (ECDSA).[³](#c05-note-0003) Multiple transactions used the same value of K, which
    is supposed to be a random, single-use value. As a result, part of the signature,
    R, was identical for both signatures, making this reuse trivial to detect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two signatures, an attacker was able to calculate the private key
    used in generating the signatures. This gave the attacker control over the blockchain
    account and the ability to steal an estimated $7,870,000 in tokens.  ##### External
    Dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: The use of library functions and other third-party dependencies is common both
    for traditional programming and smart contracts. Code reuse can help to expedite
    the development process and can result in improved code performance and security
    if high-quality libraries are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the use of external dependencies makes this third-party code part
    of an application''s attack surface. The following list includes two of the risks
    associated with external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability Exploitation:** Third-party code may contain vulnerabilities
    that leave it open to attack. A smart contract with external dependencies may
    inherit vulnerabilities from this third-party code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial-of-Service Attacks:** A smart contract may rely upon external smart
    contracts and functions to implement important functionality. If these external
    dependencies become unavailable due to self-destruction or other issues, then
    a smart contract may be rendered inoperable unless it can be updated to remove
    these dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts are designed to interact, and minimizing redundant code is especially
    important on the blockchain because it helps to minimize bloat on the blockchain's
    digital ledger. However, the use of external dependencies can create security
    risks for a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'External dependencies should be audited before use to identify any potential
    security issues that they could introduce into a smart contract. Additionally,
    smart contracts should be deployed in such a way that they can be changed as needed
    to remove or update vulnerable or deprecated dependencies.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: Parity wallet was a smart contract-based wallet. Users of the wallet could deploy
    their own instances of the contract, which relied on a central library contract
    for core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This library function contained an access control vulnerability that allowed
    an attacker to take ownership of the contract.[⁴](#c05-note-0004) The attacker
    then called the contract''s `self_destruct` function, which rendered it unusable.
    Since all Parity wallet contracts relied on this contract for core functionality,
    this caused the 513,774.16 ETH, plus other tokens stored in these wallets, to
    be lost forever since the functions needed to transfer these tokens out of the
    wallets no longer existed.  ##### Right-to-Left Control Character'
  prefs: []
  type: TYPE_NORMAL
- en: Right-to-left control characters are a feature in computers that allows them
    to support different languages. While English is written from left to right, other
    languages, like Arabic, are written from right to left. Non-printable control
    characters make it possible to switch between text directions, enabling support
    for both conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Since these control characters are non-printable and can appear anywhere in
    a line of text, they can be used by an unscrupulous smart contract developer to
    obfuscate the meaning of their code. Smart contracts are often open source, building
    trust by allowing anyone to review a contract's code.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample was developed by Skylight Cyber to demonstrate the
    malicious use of right-to-left control characters.[⁵](#c05-note-0005)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code sample is a game where a user places a bet and tries to guess a secret
    number. If they win, they receive a prize.
  prefs: []
  type: TYPE_NORMAL
- en: The `guess` function validates that the user has made a bet of 1 ETH and stores
    the current value of the pot in *`p`*. Then, the `checkAndTransferPrize` function
    is called, which checks if *`n`* equals the secret number and, if so, sends the
    prize to the winner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this contract, the malicious line of code is the call to the `checkAndTransferPrize`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command sends the prize amount, the guessed number, and the account address
    of the winner to the `checkAndTransferPrize` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, the comments in this line of code are not present due to good coding
    practices. Instead, the comments in the first line of code contain non-printable
    control characters that switch text direction from left-to-right to right-to-left
    and back again.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this code sample tests if the secret number is equal to the value
    stored in the contract, not the user's guess. Since *`secretNumber`* is less than
    or equal to 10, a contract with a value of at least 11 Ether will be unwinnable.
    The actual code passes *`n`* as the first argument to the `checkAndTransferPrize`
    function and *`p`* as the second.
  prefs: []
  type: TYPE_NORMAL
- en: However, the use of right-to-left and left-to-right characters make it appear
    that these arguments are reversed. As a result, a code review provides an inaccurate
    understanding of the contract's function, which could trick people into wasting
    money playing an unwinnable game.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: The use of right-to-left and left-to-right control characters for deception
    is only effective because these characters are non-printable. As long as the resulting
    source code looks right in a text editor, there is no reason to suspect this attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'While right-to-left and left-to-right control characters are unprintable, they
    still exist in the source code of the contract. Scanning for these characters
    can help to detect this attempted deception.  ##### Unsafe Serialization'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization enables data structures to be converted into a string of bits
    for transmission or storage. At the other end, the recipient unpacks this sequence
    of bits based on knowledge of the underlying structure. Smart contracts can implement
    serialization using functions like Ethereum's `abi.encodePacked`.
  prefs: []
  type: TYPE_NORMAL
- en: If a smart contract does not properly validate serialized data, attackers can
    exploit serialization with deliberately malformed data. One example of this is
    Smart Contract Weakness Classification (SWC) 133, which addresses hash collisions
    caused by data serialization with variable-length arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum's `abi.encodePacked` function can cause serialized data containing
    arrays to have multiple different interpretations. If packed data contains multiple,
    adjacent arrays, then values can be moved between these arrays without changing
    the final serialized value.
  prefs: []
  type: TYPE_NORMAL
- en: If the same serialized data can be deserialized in multiple different ways,
    then a digital signature authenticating one version can be used to authenticate
    any of them. An attacker can use this to bypass authentication mechanisms or to
    perform malicious transactions on another account's behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum's short address vulnerability is another example of an unsafe deserialization
    vulnerability. This vulnerability is illustrated in the following code sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ethereum serializes inputs to a function, which is unpacked by the called function.
    If one argument is too short, then it steals the missing byte(s) from the next
    argument. In the preceding code sample, an attacker can send a value of *`to`*
    that is deliberately one byte too short.
  prefs: []
  type: TYPE_NORMAL
- en: The `sendCoin` function does not check the length of *`to`* and *`amount`*,
    so the comparison of *`balances`* and *`amount`* uses the correct value of *`amount`*.
    However, the `Transfer` function specifies the length of the arguments, so Ethereum
    right-pads *`amount`* with zeros, multiplying it by 256\. As a result, the value
    transferred is far higher than the amount approved in `sendCoin`.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization vulnerabilities are usually caused by serialization of variable-length
    data or a failure to validate data during the serialization process. The use of
    fixed-size data structures and validation that serialized data properly unpacks
    can help to mitigate this vulnerability.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: In February 2022, the Superfluid protocol was the victim of a $13 million hack.
    The attacker took advantage of a serialization vulnerability in how the project
    tracked state within a transaction across different Superfluid agreements.
  prefs: []
  type: TYPE_NORMAL
- en: The *`ctx`* variable used for state tracking is intended to be initialized as
    an empty placeholder by the `callAgreement` function. The attacker included a
    malicious *`ctx`* in a call to `callAgreement`, which then added its placeholder
    to the serialized calldata sent to other agreements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the malicious *`ctx`* preceded the placeholder one, the target agreements
    accepted it and ignored the placeholder value. Also, since the calldata came from
    a trusted contract, the agreement did not validate it. The malicious *`ctx`* included
    a forged transfer of tokens from another account to the attacker, which the agreement
    processed.  #### *Blockchain-Specific Vulnerabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain systems work very differently than traditional software environments.
    Instead of running on a computer, smart contract code executes on top of the blockchain.
    The instructions to be executed are embedded in transactions, which are broadcast
    to the network and organized into blocks before finally being added to the digital
    ledger and executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unique design of the blockchain creates the potential for smart contract
    vulnerabilities. The following are examples of vulnerabilities that exist because
    smart contracts run on top of the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Denial of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontrunning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time stamp dependence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Access Control'
  prefs: []
  type: TYPE_NORMAL
- en: Most smart contract platforms are implemented as open, public blockchains. Anyone
    can create an account on the blockchain, create transactions, and interact with
    smart contracts hosted on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all functionality within a smart contract may be intended to be
    publicly accessible. As a result, smart contract platforms have the ability to
    restrict access to certain functions, variables, and so on to particular parties,
    such as the owner of a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: To restrict certain functionality to particular parties, a smart contract needs
    to define whom those parties are. Typically, this is done by specifying the address
    of certain blockchain accounts. While these addresses could be hardcoded into
    a smart contract, this is not best practice because these addresses may need to
    be updated when the contract is running.
  prefs: []
  type: TYPE_NORMAL
- en: Many smart contracts have an `initContract` or similar function that assigns
    ownership after the smart contract is deployed. The following code sample shows
    an example of an `initContract` function with an access control vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function is designed to assign ownership of a smart contract to the address
    that calls the function. Other functions in this contract would then be labeled
    as only accessible to the contract owner.
  prefs: []
  type: TYPE_NORMAL
- en: This function is designed to be called when the contract is first launched;
    however, it lacks any restrictions that prevent it from being called multiple
    times. Instead of assigning ownership of the contract to the first account that
    calls `initContract`, the function assigns ownership to the account that called
    it most recently. This could allow an attacker to access privileged functions
    within the contract, potentially stealing value from it or using its permissions
    to bypass other access controls.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: This function was vulnerable because it did not prevent multiple calls to it.
    The following code snippet fixes this issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When this contract is launched, *`firstCall`* would be set to true, allowing
    the deployer to claim ownership of the contract. However, after *`firstCall`*
    is set to false during the first call to the function, all future calls would
    fail because the `require` statement would resolve to false.
  prefs: []
  type: TYPE_NORMAL
- en: This example is the simplest way in which smart contract access control mechanisms
    could fail. Before launching a smart contract, all access control mechanisms should
    be reviewed for potential vulnerabilities or bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a function designed to only be called from other functions
    within a smart contract like `privateFunction` in the following code sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If a public function (like `forwarder`) within the contract makes it possible
    to call that function with user-controlled arguments, then the function is essentially
    public as well.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Poly Network hack is the biggest DeFi attack to date, with over $611 million
    in tokens stolen. The attacker exploited a chain of trust relationships between
    various functions within the smart contract move from a publicly accessible one
    to one with the ability to update the role of keeper within the smart contract.[⁶](#c05-note-0006)
    With the access provided by the keeper role, the attacker was able to drain the
    value stored within the Poly Network project.  ##### Bad Randomness'
  prefs: []
  type: TYPE_NORMAL
- en: Random number generation is a common requirement of smart contracts. For example,
    many games implemented as smart contracts exist that need to generate random numbers
    to identify winners.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, random number generation is difficult on the blockchain for a couple
    of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determinism:** For the “world computer” to work, every node in the network
    needs to be able to run the same code and get the same result. If each node independently
    generated pseudorandom numbers when running contract code, nodes would fall out
    of consensus regarding the state of the “world computer.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public Ledger:** All transactions are publicly visible on the blockchain''s
    digital ledger, including those creating and calling smart contracts. As a result,
    nothing is private on the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart contracts have used different methods of generating pseudorandom values,
    but many of these are insecure. Some of the most common approaches are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secret Values:** Smart contract code may be deployed with a secret value
    used to seed a pseudorandom number generator (PRNG). However, since transactions
    are public on the blockchain, anyone can read the secret value and predict the
    sequence of pseudorandom values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret Code:** Instead of using a secret seed and a known PRNG, a smart contract
    developer may create their own function for generating pseudorandom numbers. However,
    since smart contract code is deployed within a transaction and publicly visible,
    this has the same issues as secret values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blockchain Metadata:** Some smart contracts try to use unpredictable blockchain
    metadata, such as the time stamp or hash value of a block. However, some of these
    values are manipulable by a block producer, and all are also accessible to other
    smart contracts as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following code sample includes weak random number generation.[⁷](#c05-note-0007)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, the source of randomness is the hash of a particular block.
    While the value of *`blockNumber`* is not shown, no option provides a strong random
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current Block:** The hash of the current and any future blocks is unknown,
    so the value defaults to 0\. This means that a value of *`blockNumber`* pointing
    to the current block would always result in a win.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Over 256 Blocks Ago:** Solidity only stores the hashes of the previous 256
    blocks, and requests for older blocks produce a value of 0\. As a result, a *`blockNumber`*
    more than 256 blocks ago would be an automatic win.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recent Blocks:** For any of the last 256 blocks, another smart contract could
    access the block hash and test if it is a winner. If so, it could call the `play`
    function only when guaranteed to win.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: Any information within the blockchain ecosystem that is available to one smart
    contract is likely available to another. The only way to generate a secret random
    value is to do so from outside the blockchain ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts should use an external oracle to provide randomly generated
    values. Since every node in the network would see the same value from the oracle,
    this enables determinism without using values accessible to other, malicious smart
    contracts.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: The SmartBillions lottery was a betting game hosted on the Ethereum blockchain.
    Players could choose six lucky numbers and then call the `won` function to play.
    If their lucky numbers matched a random number when they called `won`, then they
    could earn increasing rewards.
  prefs: []
  type: TYPE_NORMAL
- en: 'SmartBillions''s random number was based on the hash of an earlier block, which
    is only accessible for the previous 256 blocks in Solidity. The attacker guessed
    lucky numbers of zero and called `won` 256 blocks after the target block, guaranteeing
    that their guess would be correct.[⁸](#c05-note-0008) They were able to win 400
    ETH from the game before the creators used a backdoor to drain the remaining 1,100
    ETH from the contract.  ##### Denial of Service'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain systems are designed to be distributed and decentralized. No node
    in the network is essential, which means that the blockchain system lacks permanent
    single points of failure. In theory, this should provide strong protection against
    denial-of-service (DoS) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, blockchain systems and the smart contracts that run on them are
    vulnerable to DoS attacks in various different ways, including the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DDoS against Transaction Creator:** For a transaction to execute a smart
    contract, it needs to be broadcast to the blockchain network by its creator. If
    a DDoS attack renders the creator of a transaction unable to publish it, then
    it will not be added to the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DDoS against Block Producer:** Transactions are only added to the ledger
    and executed as part of blocks. If a block producer cannot create a block, then
    transactions are delayed from being added to the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction Flooding DDoS:** Blockchains create blocks with a fixed maximum
    size at regular intervals, which means they have a maximum throughput. If a blockchain
    is flooded with spam transactions, then legitimate transactions may not be able
    to get through and be added to the digital ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse/Routing Attacks:** Transactions and blocks are distributed via the
    blockchain''s peer-to-peer network. If these messages are intercepted and dropped
    by an attacker, then they may be delayed or prevented from being added to the
    digital ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malicious Block Creators:** Block producers have full control over which
    transactions are included in the blocks they create. A block producer can choose
    not to include a transaction within a block, delaying it from being added to the
    digital ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a transaction has been distributed to nodes, it should be included in a
    block eventually unless all block producers collude to prevent this. However,
    some smart contracts are time-dependent, so delaying a transaction calling them
    could have a significant impact on the result.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: Many of these attacks target the underlying infrastructure that the blockchain
    relies upon. Traditional DDoS attacks or attacks on the connectivity of the blockchain
    network are IT security problems that can be addressed with traditional solutions.
    However, the decentralization of the blockchain network might make it difficult
    to have these solutions universally adopted, such as having all block producers
    deploy DDoS protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other DoS attacks exploit the design of the blockchain, such as transaction-flooding
    attacks and the potential for malicious block creators. Transaction flooding could
    be mitigated by block producers ignoring spam transactions, and in the absence
    of universal collusion by block producers, a legitimate transaction may be delayed
    but will eventually be included in a block.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sia is a decentralized, blockchain-based storage system. In June 2021, a multiday
    DDoS attack against the network targeted a quarter of Sia network hosts and storage
    providers.[⁹](#c05-note-0009) While the attack was unable to impact file storage
    operations, it did interrupt 30 percent of host connections.[^(10)](#c05-note-0010)  #####
    Frontrunning'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are not immediately added to the blockchain's digital ledger. After
    a transaction is created, it is broadcast to all blockchain nodes via the peer-to-peer
    network. Each node then stores the transactions to be included in a later block.
    Only when a transaction is included in a block is it executed and added to the
    digital ledger.
  prefs: []
  type: TYPE_NORMAL
- en: This design provides opportunities for an attacker to see a transaction and
    create one of their own based on it before the first transaction is processed.
    In fact, since transactions are typically added to blocks in order of their transaction
    fees, an attacker can create a transaction with a higher fee that is likely to
    be processed before the original one.
  prefs: []
  type: TYPE_NORMAL
- en: This ordering of transactions based on fees is referred to as miner extractable
    value (MEV), and the ability to exploit it is the basis for frontrunning bots.
    [Figure 5.2](#c05-fig-0002) illustrates how these bots can take advantage of frontrunning
    vulnerabilities for profit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic illustration of frontrunning attack on a decentralized exchange.](images/c05f002.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 5.2**](#R_c05-fig-0002): Frontrunning attack on a decentralized exchange'
  prefs: []
  type: TYPE_NORMAL
- en: 'A decentralized exchange (DEX) is a cryptocurrency exchange implemented as
    a smart contract. DEXs need to be able to calculate the exchange rate of various
    trading pairs. Often, they are implemented based on the laws of supply and demand:
    the more the DEX has of a particular asset, the lower its relative value.'
  prefs: []
  type: TYPE_NORMAL
- en: In the top half of the image, Alice performs a trade with the DEX. Since the
    exchange rate is currently 1 ETH for 10 TKNs, sending 1 ETH to the contract returns
    10 TKNs. Since the DEX's supply of ETH grows relative to its supply of TKN, the
    relative value of ETH decreases compared to TKN.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom half of the image illustrates a frontrunning attack on this trade.
    While Alice still sends in 1 ETH, Bob observes the transaction and frontruns it
    with his own transaction. As a result, Bob makes a trade at the original exchange
    rate of 1 ETH:10 TKN, while Alice's trade is made at the reduced exchange rate
    of 1 ETH:9 TKN.
  prefs: []
  type: TYPE_NORMAL
- en: After Alice's trade is complete, Bob makes another trade, exchanging his 10
    TKN for ETH. Since the two previous trades increased the value of TKN relative
    to ETH, Bob gets 1.25 ETH in return. As a result, he makes a net profit of 0.25
    ETH, minus the fees for his two transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This is one example of how frontrunning can be used to benefit an attacker.
    A frontrunner may also be able to win contests based on a first-come-first-served
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: Frontrunning attacks take advantage of the design of the blockchain, where block
    producers have full control over how transactions are organized into blocks. A
    block producer is expected to organize transactions based on associated fees but
    may also choose to prioritize certain transactions, enabling them to frontrun
    transactions without fees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts can be designed to minimize the risk or benefit of frontrunning.
    For example, a contract could randomly pick a winner from the first *`X`* submissions
    rather than operating on a first-come-first-served model. While an attacker could
    create many frontrunning transactions to defeat this system, it is more expensive,
    potentially making it unprofitable.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: The DODO DEX and Punk Protocol are DeFi projects that were targeted by attacks
    in 2021\. While these attacks did not involve frontunning, the attackers' transactions
    were frontrun by automated bots. By copying the attacker's transaction and paying
    a higher transaction fee, these bots exploited the vulnerable contracts before
    the attacker did, draining some of the targeted funds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the owners of the frontrunning bots were able to limit the impact
    of the attack. The Punk Protocol bot operator returned $5 million worth of tokens,[^(11)](#c05-note-0011)
    while the DODO DEX bot operator returned $1.88 million in tokens.[^(12)](#c05-note-0012)  #####
    Rollback Attacks'
  prefs: []
  type: TYPE_NORMAL
- en: Most smart contract platforms take an all-or-nothing approach to transactions
    by default. If any part of a transaction fails, then the entire transaction is
    rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker can take advantage of this when interacting with a smart contract
    like a blockchain-based game. A smart contract can call the game contract, and
    if it doesn't like the result, it could revert the transaction. This would mean
    that the attacker only plays if they will win anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rollback attacks have the greatest impact if a rolled-back transaction triggers
    another transaction that goes through. Whenever possible, smart contracts should
    only initiate new transactions after verifying that transactions triggering them
    executed successfully.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: In December 2018, Betdice, EOSMax, Tobet, and other EOS-based gambling apps
    were the victims of a rollback attack.[^(13)](#c05-note-0013) The attacker performed
    transactions from an address blacklisted by the block producer, which meant that
    it would never be accepted and included within a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, servers associated with the gambling apps saw and processed the transaction
    and determined that it would win the game. They then initiated transactions sending
    a reward to the player. As a result, the attacker''s initial betting transactions
    were not recorded on the blockchain, but the reveal transactions containing their
    reward were.  ##### Time Stamp Dependence'
  prefs: []
  type: TYPE_NORMAL
- en: Some smart contracts may be designed to take action at a certain point in time.
    For example, a contest may open at midnight January 1, so submissions before that
    time would be rejected while ones after would be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts rely on time stamps within the block header for the current
    time. However, this is not a reliable clock. Block header time stamps are under
    the control of the block producer and have a high degree of flexibility. For example,
    the Ethereum Virtual Machine (EVM) only requires that each block have a time stamp
    greater than that of the previous block. While nodes may reject blocks with time
    stamps too far into the future, there is no formal definition for a valid time
    stamp.
  prefs: []
  type: TYPE_NORMAL
- en: This creates the potential for a block creator to manipulate time stamps for
    their own benefit. For example, the following code snippet has time-stamp-dependent
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code implements a contest where the first player after time stamp 1521763200
    wins 1,500 ETH. A node creating a block shortly before this time could cheat by
    setting the block time stamp to 1521763201 and including a transaction in the
    block where they called the `play` function and claimed the reward. As long as
    their block is accepted by the network, they can win the contest before other
    users start playing.
  prefs: []
  type: TYPE_NORMAL
- en: '###### *Countermeasures*'
  prefs: []
  type: TYPE_NORMAL
- en: Time-stamp-dependence vulnerabilities exist because time stamps are under the
    control of the block producer. While some blockchains have constraints on acceptable
    time stamp values in block headers, these constraints are often flexible to account
    for unsynchronized clocks and the latency of blocks traveling over the peer-to-peer
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach to implementing time-dependent functions is the use of block
    heights rather than block time stamps. These values are not under the control
    of a block producer and provide a reasonable approximation of the current time.
    For example, while Bitcoin''s blocks aren''t created at exactly 10-minute intervals,
    they are close enough that a certain block height should be reached within a certain
    window.  ###### *Case Studies*'
  prefs: []
  type: TYPE_NORMAL
- en: GovernMental was a Ponzi scheme smart contract that ran on the Ethereum blockchain.
    The rules of the game were that, if no one performed a transaction to the contract
    within 12 hours, the previous player would be awarded the jackpot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This smart contract could be exploited by an attacker who produced a block
    close to the expiration of the 12-hour window.[^(14)](#c05-note-0014) By forging
    the time stamp in the block header, the malicious block producer could force the
    contract to pay out early, before the 12 hours were complete.  #### *Platform-Specific
    Vulnerabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract platforms are an extension of the original blockchain protocol.
    Bitcoin does not support smart contracts, and different smart contract platforms
    have implemented this functionality in different ways. Smart contract platforms
    may use existing programming languages and virtual machines or may have created
    their own.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, different smart contract platforms are prone to different vulnerabilities.
    Ethereum and EOSIO are two of the oldest and most used smart contract platforms,
    which means that they have had the most opportunity for these platform-specific
    vulnerabilities to be discovered.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum is the oldest smart contract platform, launching July 30, 2015\. The
    age and widespread adoption of this platform provided ample opportunity to identify
    potential vulnerabilities on the platform. The following list includes some examples
    of vulnerabilities specific to the Ethereum smart contract platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Denial of service: block gas limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Denial of service: unexpected reversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forced send of ether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing zero address checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reentrancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token standards compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unchecked return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsafe external call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '###### *Denial of Service: Block Gas Limit*'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses the concept of gas to fight spam and compensate nodes for their
    efforts. Gas is a fraction of an Ether, and each instruction in the EVM has an
    associated gas cost.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a transaction that runs a smart contract, an account will include
    some gas with it. If that gas runs out before the transactions completes, it is
    reverted.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum also has a block gas limit, which caps the amount of gas that can be
    used within a block. While this has its benefits, it also creates the potential
    for DoS attacks. If a smart contract function requires more gas than can be included
    in a block, then it cannot be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows an example of a function with a DoS vulnerability
    caused by block gas limits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function contains a loop whose number of iterations is determined by the
    user. The loop runs through some operations based on previous inputs and then
    assigns the value of *`_largestWinner`*, an argument to the function, to *`largestWinner`*,
    which determines the loop's termination condition. Inside the loop is heavy code
    that consumes a significant amount of gas.
  prefs: []
  type: TYPE_NORMAL
- en: This function will be rendered unusable as soon as the value of *`largestWinner`*
    grows large enough that execution of the loop meets or exceeds the block gas limit.
    This could happen intentionally as part of an attack or as part of legitimate
    usage since the value of *`largestWinner`* presumably grows as more users play
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Whoever triggers this Out of Gas exception will presumably win the game, as
    no new player would be able to run the `selectNextWinners` function to replace
    them. As a result, an attacker has incentive to choose a large value of *`largestWinner`*
    to render it unrunnable in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Block gas limit vulnerabilities generally exist in
    code that has unbounded loops or recursion. In the preceding example, the number
    of loop iterations was under the control of the smart contract''s users. As a
    result, the function could be placed in a state where it would be impossible to
    run within the block gas limit.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this issue, Ethereum smart contracts should avoid unbounded loops or
    recursion. It is also a good idea to modularize code wherever possible to minimize
    the amount of gas used by any function. If a sequence of actions can be broken
    up across multiple transactions, this reduces the probability of hitting the block
    gas limit.  ***Case Study***     The GovernMental contract mentioned in the Timestamp
    Dependence case study also included DoS vulnerabilities due to Ethereum's block
    gas limits. The process that allowed a player to claim the reward also included
    some cleanup code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This included two arrays that tracked the state of the contract. Once the array
    of participants grew past a certain point, attempting to clear it would exceed
    the block gas limit. As a result, it would be impossible for a player to win the
    game and claim the reward.[^(15)](#c05-note-0015)  ###### *Denial of Service:
    Unexpected Reversion*'
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, a smart contract account is nearly identical to a normal user account.
    The only difference is that a smart contract account has code associated with
    it that can be executed by another account.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, smart contracts have the ability to send, receive, and store value.
    This is essential to smart-contract-based games and DeFi smart contracts that
    allow users to deposit and withdraw value within a contract.
  prefs: []
  type: TYPE_NORMAL
- en: One vulnerability associated with value transfers in smart contracts is the
    potential for a transfer of value to be unexpectedly reverted. If a smart contract
    sends value to another smart contract, the recipient contract's fallback function
    will be run, allowing it to execute some code. That fallback function could be
    designed to revert any transactions to it.
  prefs: []
  type: TYPE_NORMAL
- en: If a smart contract assumes that all transfers will succeed, this can cause
    a DoS vulnerability within the contract. The following code sample contains an
    example of this vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code sample is from the King of the Ether smart contract,[^(16)](#c05-note-0016)
    which names a monarch and then allows other players to pay to claim the title.
    When this occurs, the previous monarch receives the payment made by their successor.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, the `require(currentLeader.send(highestBid))` command creates
    a DoS vulnerability due to the potential for reverted transactions. If the current
    monarch reverts any transfers to them, then this code will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The intention here was to ensure that the previous monarch always got their
    payment before they were unseated. However, this code allows a monarch who reverts
    payments to them to cause any attempt to unseat them to fail.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     This function was vulnerable to DoS attacks because
    it assumed that all transactions would succeed. Solidity includes a try-catch
    structure that can be used to handle reversion in external calls, enabling a contract
    to detect and respond to failed transfers.  ###### *Forced Send of Ether*'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, unexpected reversion within a fallback function can
    cause a DoS vulnerability within the calling contract. Forced send of Ether vulnerabilities
    look at the other side of this and what happens if a contract with a reverting
    fallback function is forced to receive Ether.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows an example of an Ethereum smart contract that
    attempts to revert all transfers of value.[^(17)](#c05-note-0017)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In Ethereum, fallback functions are labeled by the keyword `payable`. In this
    contract, all attempted payments are automatically reverted. The reason is that,
    in the `somethingBad` function, some undesirable event occurs if the contract
    ever holds a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This contract effectively protects itself against normal transfers of value,
    such as the use of send in the unexpected reversion example. However, there are
    a few ways in which an attacker can bypass this, sending Ether to the contract
    without triggering the fallback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefunding:** Smart contract accounts are like any other account on Ethereum,
    meaning they can receive transfers before smart contract code is deployed to them.
    If an attacker can predict the deployment address of a smart contract, then they
    can transfer Ether to it before the contract is deployed and the fallback function
    exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mining/Staking:** Participating in consensus can result in block rewards.
    An attacker can indicate that a smart contract account is the intended recipient
    of a block reward, which does not trigger the fallback function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-Destruct:** A self-destructing smart contract can specify another contract
    as the recipient of any Ether held at that address. Transfers triggered by self-destruct
    do not trigger the recipient''s fallback function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using one of these methods, an attacker can force Ether into the target smart
    contract. In this case, a future call to `somethingBad` would pass the `require`
    statement, allowing the bad functionality to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Forcing Ether into a smart contract is usually only
    a problem if the contract performs strict value comparisons. For example, the
    command `if (value == 5)` is problematic if an attacker forces 6 ETH into the
    contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using strict value comparisons, contracts should use greater than
    or equal to or less than or equal to. This way, any unexpected Ether does not
    break the contract's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For code where strict tracking is necessary, such as the previous toy example,
    value should be tracked internally rather than via *`this.balance`*. The following
    code sample shows an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, only value transfers that pass through the fallback function
    will affect the value of *`balance`*. As a result, forced sends of Ether will
    not trigger the `somethingBad` function.  ***Case Studies***     The Edgeware
    project allowed users to lock ETH in 3 to 12 months in exchange for a reward.
    When a user created a lockdrop, the main Lockdrop contract created a new contract
    that held their ETH and implemented the lock functionality. These contracts were
    vulnerable to forced send of Ether because they asserted at creation that the
    value of the contract was strictly equal to the amount of ETH sent in by the user.[^(18)](#c05-note-0018)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lockdrop contract used a deterministic algorithm to determine the address
    of the next contract. Since the address of the new contract was predictable, an
    attacker who prefunded the address with ETH could cause the creation of the lock
    contract to fail. Also, since the Lockdrop contract would keep trying to use the
    same address until it succeeded, locking the next address would cause it to fail
    forever.  ###### *Missing Zero Address Checks*'
  prefs: []
  type: TYPE_NORMAL
- en: The genesis, or zero, address (`0x0`) is used for burning tokens in Ethereum.
    Since the private key for this address is unknown and likely never to be discovered,
    tokens sent to this address cannot be recovered.
  prefs: []
  type: TYPE_NORMAL
- en: When working with addresses, it is important to ensure that an address is not
    the zero address. Transfers of tokens or ownership of a contract to the zero address
    cannot be reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts can also have errors if they assume that smart contract code
    exists at the `0x0` address. The following code sample shows vulnerable code implements
    a `safeTransferFrom` function for a token.[^(19)](#c05-note-0019)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `safeTransferFrom` function is called in the contract that
    created the deposited token. This should transfer that token from one address
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: If the address of *`token`* is the `0x0` address, then the `call` function will
    try to call the fallback function of the contract at `0x0`, which does not exist.
    Instead of reverting, this call will succeed, making it appear that a token transfer
    succeeded when it did not. As a result, the contract will accept and respond to
    a nonexistent transfer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     When working with transfers of tokens and calls to
    smart contracts, a contract should always check for the zero address. Additionally,
    smart contracts should verify that smart contract code exists at an address before
    attempting to call functions within it.  ***Case Studies***    The previous vulnerable
    code sample is from the Qubit project, which implements a bridge between the Ethereum
    and the BNB Chain platforms. This bridge was hacked in January 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker took advantage of a missing zero address check to trick the bridge
    into accepting a fake deposit of ETH, which triggered a Deposit event. This event
    was caught by the bridge''s smart contract, which caused qxETH tokens to be minted
    to the attacker''s account on BNB Chain, which the attacker converted into $80
    million in BNB.  ###### *Reentrancy*'
  prefs: []
  type: TYPE_NORMAL
- en: Reentrancy is likely the most famous Ethereum-specific vulnerability. It was
    the cause of the DAO hack, which was the most significant Ethereum hack to date.
  prefs: []
  type: TYPE_NORMAL
- en: Like unexpected reversion, reentrancy is made possible by the ability to execute
    code within a fallback function. The following code snippet contains a reentrancy
    vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This `withdraw` function checks to see if a withdrawal request is valid, transfers
    the value to the target address, and then updates its internal ledger accordingly.
    However, the command `msg.sender.call.value(_amount)()` executes before this state
    update and allows a target smart contract to execute some commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'A malicious smart contract can exploit this vulnerability by calling the `withdraw`
    function again from inside its fallback function. Assuming that the account has
    a balance of 5 ETH and is requesting a withdrawal of 4 ETH, this would produce
    the following sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious contract calls `withdraw` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require` statement validates that the transaction is valid (5 >= 4).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable `withdraw` function t sends 4 ETH to malicious contract, triggering
    fallback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious contract calls `withdraw` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require` statement validates that the transaction is valid (5 >= 4).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable `withdraw` function sends 4 ETH to malicious contract, triggering
    fallback function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback function returns.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable contract updates internal state (*`balances[msg.sender]`* = 1).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable `withdraw` function returns.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable `withdraw` function updates internal state (*`balances[msg.sender]`*
    = -3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable `withdraw` function returns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the vulnerable `withdraw` function only updates its internal state after
    performing the value transfer, an attacker can make multiple calls with the original
    value of *`balances[msg.sender]`*, allowing them to extract excess value from
    the contract. The number of reentries is largely limited by the amount of gas
    available at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Reentrancy vulnerabilities can be eliminated by following
    the check-effects-interaction code pattern. This involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check:** Check that a request is valid (i.e., the `require` statement from
    the example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effects:** Record the effects of the event (i.e., updating the value of *`balances[msg.sender]`*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction:** Perform the action (i.e., transferring the value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this code pattern, the reentrant call to the `withdraw` function would
    have failed at the `require` statement because *`balances[msg.sender]`* would
    equal 1, not 5.  ***Case Studies***     The DAO hack is the most famous Ethereum
    hack to date. The DAO was a contract designed to implement crowdfunding on the
    blockchain. Project proposals could be submitted to the contract and voted on
    by DAO token owners. If approved, they would receive funding, and successful projects
    would pay dividends to DAO token holders.
  prefs: []
  type: TYPE_NORMAL
- en: A reentrancy vulnerability in the DAO smart contract allowed the attacker to
    drain value from the contract by repeatedly requesting a withdrawal before the
    contract updated its internal state.[^(20)](#c05-note-0020) The attacker stole
    approximately 3.6 million ETH from the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the DAO hack was ultimately unsuccessful because the Ethereum network
    performed a hard fork that rewrote history to erase it from the ledger. This sparked
    the division of the Ethereum (ETH) and Ethereum Classic blockchains, which contain
    the nodes that did and did not follow this hard fork. This broke the rules of
    blockchain immutability but helped preserve the value of ETH.  ###### *Token Standards
    Compatibility*'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has a number of standards called Ethereum Improvement Proposals (EIPs).
    Among these is the EIP-20 standard that specifies a standard interface for tokens
    created on the Ethereum smart contract platform.[^(21)](#c05-note-0021)
  prefs: []
  type: TYPE_NORMAL
- en: EIP-20 specifies function prototypes for common token functions, including their
    arguments, return values, and required actions such as firing certain events.
    However, not all tokens follow the EIP-20 standard.
  prefs: []
  type: TYPE_NORMAL
- en: For example, EIP-20 specifies that `transfer` and `transferFrom` functions return
    a Boolean value indicating success or failure. However, the USDT stablecoin returns
    `void` in these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can cause incompatibility with smart contracts that strictly follow the
    EIP-20 standard like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The use of `require` here means that a compliant token will allow continued
    execution if transfer succeeds and causes reversion if the transaction fails.
    However, transactions that call this code with a noncompliant token like USDT
    will revert every time because `require(null)` will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Projects like OpenZeppelin have implemented `safeTransfer`
    and `safeTransferFrom` functions that properly handle both return value checks
    and noncompliant tokens. Using these implementations provides both security and
    support for noncompliant tokens.  ***Case Studies***    ForceDAO was a DeFi aggregator
    project that was hacked for $367,000 in tokens within hours of launch.[^(22)](#c05-note-0022)
    The project''s vaults were a fork of the xSUSHI contract, which was vulnerable
    to tokens that did not comply with the EIP-20 standard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An attacker deposited tokens into the contract that would return false rather
    than reverting upon a failed deposit. Since the contract did not check return
    values, it issued xFORCE tokens due to these failed deposits. The attacker could
    then redeem these xFORCE tokens for FORCE tokens stored in the contract''s vault.  ######
    *Unchecked Return Values*'
  prefs: []
  type: TYPE_NORMAL
- en: In Solidity, functions can indicate failure in a couple of different ways. If
    a low-level function reverts, then this can cause the transaction to be completely
    rolled back unless handled by a `try-catch` block. However, if a function indicates
    failure by returning false, then the calling function can continue execution at
    its next command.
  prefs: []
  type: TYPE_NORMAL
- en: This difference in how low-level functions handle errors can create smart contract
    vulnerabilities, like the one in the following code sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample implements a withdraw function with reentrancy protections.
    The crucial line of code here is the use of the `send` command to send value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solidity defines a few different mechanisms for sending Ether to another contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transfer`: Costs 2300 gas and indicates failure by throwing an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send`: Costs 2300 gas and indicates failure by returning false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call`: Sends an arbitrary amount of gas and indicates failure by returning
    false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `send` and `transfer` functions are nearly identical except in how they
    handle errors. In the previous code sample, if something goes wrong with the call
    to `send`, the transfer may fail without detection because the contract is not
    checking the return value. This could leave the contract in an invalid state because
    it has already recorded the transfer in its *`balances`* and *`etherLeft`* variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     The example vulnerability existed because a function
    failed to check for failure in a call to another function. This issue could be
    fixed by researching how a particular function handles errors before using it
    or assume the worst and implement error-checking functionality for all calls to
    external functions.  ***Case Studies***     An earlier version of the King of
    the Ether contract mentioned previously contained an unchecked return value vulnerability.[^(23)](#c05-note-0023)
    The contract did not include enough gas with a call to send to support transfers
    to a smart-contract-based wallet, which would execute a fallback function. As
    a result, an attempt to refund the previous monarch failed when that monarch used
    a smart-contract-based wallet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the contract did not check the return value of the call to send, the
    failure was ignored and the throne was transferred to the next claimant. However,
    when this was discovered, the contract operators extracted the value from the
    contract and sent it to the previous monarch.  ###### *Unsafe External Call*'
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, a smart contract account is no different from a user account, and
    smart contracts are designed to interact with one another. However, the ways in
    which a smart contract function calls other functions has a dramatic impact on
    its security.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample implements a call forwarder and is an example of unsafe
    calls to external functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Solidity's `delegatecall` function enables a smart contract's functions to be
    called while maintaining the context of the calling function. The code executed
    within the callee has access to the caller's data and value, and any calls made
    by the callee with have *`msg.sender`* set to the caller's address.
  prefs: []
  type: TYPE_NORMAL
- en: By using `delegatecall`, a smart contract is placing complete trust in the called
    function. The callee can modify or delete the caller's data, steal value from
    the caller, and bypass access controls by masquerading as the caller when calling
    other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Never use `delegatecall`. Anything that can be done
    using `delegatecall` can be done more safely another way.  ***Case Studies***
        Furucombo is a drag-and-drop interface for DeFi traders to build chains of
    trades. Furucombo allowed users to preapprove transfers for certain tokens, enabling
    the contract to extract these tokens from the user''s account without explicit
    approval.'
  prefs: []
  type: TYPE_NORMAL
- en: Furucombo's `batchExec` function allowed a `delegatecall` to the Aave proxy
    contract.[^(24)](#c05-note-0024) This allowed the attacker to call the Aave contract's
    fallback function, which performs a `delegatecall` to its implementation logic
    contract. The attacker exploited this chain of `delegatecall`s to have the implementation
    contract set to their own malicious contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this same chain of `delegatecall`s, the attacker can then call functions
    in their own contract using the state of the Furucombo contract. The attacker
    can then transfer preapproved tokens from users'' accounts to their own.  #####
    EOSIO'
  prefs: []
  type: TYPE_NORMAL
- en: 'EOSIO is another early example of smart contract technology that has been used
    to host various distributed applications (DApps). The following list includes
    some examples of vulnerabilities particular to the EOSIO platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Fake tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reentrancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unchecked transaction status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '###### *Fake Tokens*'
  prefs: []
  type: TYPE_NORMAL
- en: In many smart contract platforms, token names and symbols must be unique. An
    attempt to create a new token with the same symbol as an existing token will fail.
  prefs: []
  type: TYPE_NORMAL
- en: On EOSIO, different smart contracts can create tokens with the same symbols.
    This can lead to fake token vulnerabilities like that in the following code sample.[^(25)](#c05-note-0025)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `test::transfer` function in this code sample performs validation that a
    transfer is valid before accepting it. This includes validating that the token
    symbol is EOS, the native token of EOSIO.
  prefs: []
  type: TYPE_NORMAL
- en: However, in EOSIO, the combination of contract and symbol is unique, not just
    the token symbol itself. This function would accept a transfer of any token with
    a symbol of EOS, not just the official EOS token. This could allow an attacker
    to deposit a worthless token and extract tokens with actual value from the contract.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     In EOSIO, the combination of a token contract and
    symbol is unique, not just the token symbol. When validating a transfer, it is
    necessary to check that both of these match expected values.  ***Case Studies***    The
    BitDice project contained a fake token vulnerability that was exploited in October
    2019.[^(26)](#c05-note-0026) The code verified that a token symbol matched EOS
    but not that the token contract matched `eosio.token`. As a result, an attacker
    was able to send fake EOS tokens from the contract and then extract 4,000 real
    EOS tokens from it.  ###### *Notification Assumptions*'
  prefs: []
  type: TYPE_NORMAL
- en: In EOSIO, smart contracts can receive notifications about particular events
    and create listeners that execute code if they receive these notifications. The
    most common notification is when a user is involved in a transaction either as
    sender or receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample is vulnerable to exploitation due to incorrect assumptions
    about how notifications work in EOSIO.[^(27)](#c05-note-0027)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This transfer function is designed to act when it receives a transaction. It
    is triggered by a notification about a transfer and tests whether it was the one
    that initiated the transfer. If not, it assumes that it is the recipient of the
    transaction and responds accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this code is that any EOSIO account can be notified about a
    transaction using the `require_recipient` command. This function could be tricked
    by an attacker who performs a transfer between two other accounts and notifies
    this one via `require_recipient`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the contract will correctly determine that it was not the source
    of the transaction. However, it will then wrongly conclude that it was the recipient,
    which may result in it sending tokens to an attacker or taking other action in
    response to the deposit that it believes it received.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     With `require_recipient`, anyone can be notified
    of a transfer or other event. When responding to a notification about a transfer,
    it is necessary to verify that the contract was in fact the recipient of the transfer
    and not just that it is not the sender.  ***Case Studies***    The vulnerable
    code sample previously shown is from the EOSBet casino smart contract, which was
    exploited in October 2018.[^(28)](#c05-note-0028) The attackers sent transfers
    from account ilovedice123 to whoiswinner1 while notifying the EOSBet casino contract
    using `require_recipient`. Since EOSBet did not verify that it was the recipient
    of the transaction, it credited the transfer to the attacker''s account.  ######
    *Reentrancy*'
  prefs: []
  type: TYPE_NORMAL
- en: Reentrancy vulnerabilities exist in Ethereum because fallback functions allow
    third-party, potentially malicious code to be run between adjacent instructions
    of a calling function. EOSIO contracts are also vulnerable to reentrancy, but
    it works differently.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample demonstrates a reentrancy vulnerability.[^(29)](#c05-note-0029)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In EOSIO, reentrancy vulnerabilities originate from the notification system.
    As mentioned previously, EOSIO allows smart contracts to be notified of certain
    events via `require_recipient`, and these notified contracts can execute code
    when they receive these notifications.
  prefs: []
  type: TYPE_NORMAL
- en: This handler code may include *inline actions* such as the log action in the
    preceding sample. Logically, it would seem that this inline action would be executed
    immediately after the `on_transfer` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, EOSIO executes all notification handlers for an event before it will
    run any inline actions. This means that the log action in the preceding code may
    execute long after the `on_transfer` function with code from other functions in
    between.
  prefs: []
  type: TYPE_NORMAL
- en: This creates the potential for reentrancy attacks if a vulnerable contract splits
    operations between notification handlers and inline actions. For example, a contract
    might perform a transfer in the handler and then use an inline action to perform
    a state update or vice versa. An attacker that can split these two actions may
    be able to exploit the contract.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***     Reentrancy attacks in EOSIO take advantage of the
    fact that inline actions are not immediately executed after the notification handler
    that triggers them. Whenever possible, make actions and state updates atomic rather
    than splitting them over notification handlers and inline actions.  ***Case Studies***    In
    May 2021, the Vaults.sx yield aggregator smart contract was the victim of a reentrancy
    attack.[^(30)](#c05-note-0030) The attack included the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Attacker deposited tokens in exchange for SX tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker redeemed half of these SX tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When notified of the redemption transaction, the attacker created two inline
    actions. One triggered Vault.sx's update function, while the other redeemed the
    other half of its SX tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When notified of the redemption transaction, the vault.sx contract created an
    inline action to pay out rewards and updated its internal total supply value based
    on this update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker's inline actions executed, overwriting the balance update in step
    4, which had not yet executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The attacker received redeemed tokens. The second redemption included excess
    rewards because it was based on an incorrect value of the contract''s total supply.  ######
    *Unchecked Transaction Status*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In EOSIO, a transaction can have several different statuses,[^(31)](#c05-note-0031)
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`executed`: Transaction succeeded, and no error handling was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soft_fail`: Transaction failed but error handing succeeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hard_fail`: Transaction and error handling failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delayed`: Transaction delayed by user to execute in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expired`: Transaction expired, and CPU/NET was refunded to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most of these, the behavior of EOSIO is logical. Successful transactions
    are recorded on the chain, while unsuccessful or expired ones are not.
  prefs: []
  type: TYPE_NORMAL
- en: The exception here is delayed transactions. When a transaction is delayed, its
    contents are recorded on the blockchain. Later, when the delay timer expires,
    nodes can extract the contents of the transaction from a block to execute and
    validate it.
  prefs: []
  type: TYPE_NORMAL
- en: Delayed execution is not a problem if a transaction succeeds. However, a delayed
    transaction that results in a status of `hard_fail` is still recorded on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: This can create confusion for smart contracts that observe transactions but
    do not validate their status. A smart contract may see that a transaction to it
    exists on the blockchain and respond accordingly. However, this transaction may
    be delayed and designed to result in a `hard_fail`, meaning that it did not actually
    execute. As a result, the vulnerable contract has reacted to a transaction that
    never happened.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    A transaction''s *`status`* is one of the fields within
    a transaction receipt. Smart contracts should check this field and verify that
    it has a status of executed before accepting a transaction.  ***Case Studies***    Vegas
    Town contained an unchecked transaction status vulnerability that was exploited
    by fortherest12 in March 2019\. The attacker used delayed transactions to send
    transfers to the contract that would result in a status of `hard_fail` but still
    be recorded on the blockchain. The vulnerable contract failed to check the status
    of these transactions, causing it to accept failed transactions.  #### *Application-Specific
    Vulnerabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts can be used for various different purposes. Two of the main
    applications of smart contracts today are decentralized finance (DeFi) and non-fungible
    tokens (NFTs).
  prefs: []
  type: TYPE_NORMAL
- en: Both of these applications of smart contracts introduce features and functions
    that do not exist in all smart contracts. With them come potential vulnerabilities
    and security issues unique to these use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '##### DeFi Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin was designed to implement a decentralized financial system using the
    blockchain's digital ledger. However, Bitcoin is largely designed to track transfers
    of value on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'DeFi smart contracts are designed to implement other functions of financial
    institutions, such as borrowing, lending, and making exchanges between assets.
    These smart contracts are extremely valuable but can also contain various vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Access Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend Vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price Manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '###### *Access Control*'
  prefs: []
  type: TYPE_NORMAL
- en: Access control vulnerabilities can exist in any smart contract. However, the
    unique nature of the DeFi space creates new types of access control vulnerabilities,
    and the high value of DeFi contracts exacerbates their impacts.
  prefs: []
  type: TYPE_NORMAL
- en: In DeFi contracts, `mint` and `burn` functions must be appropriately protected.
    The following code sample shows an unprotected `mint` function.[^(32)](#c05-note-0032)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: DeFi smart contracts commonly have a native token. These tokens may be designed
    to indicate ownership of a share of the contract's liquidity (which could accrue
    interest) or issued when a user takes out a loan to allow them to reclaim their
    collateral.
  prefs: []
  type: TYPE_NORMAL
- en: A `mint` function like the one in the preceding code allows new tokens to be
    created. An unprotected one could allow an attacker to create new tokens and send
    them to their account. In the sample code, the `mint` function is labeled as `public`,
    meaning that anyone can call it to create new tokens.
  prefs: []
  type: TYPE_NORMAL
- en: If this occurs, the existing tokens lose some value, and the attacker can steal
    value from the protocol. For example, minting 100 tokens when 100 exist would
    cut the value of each token in half but allow the attacker to claim half of the
    value invested in a DeFi contract.
  prefs: []
  type: TYPE_NORMAL
- en: A `burn` function does the opposite, destroying some of a smart contract's native
    tokens. If an attacker can burn tokens held by a contract, then the remaining
    tokens gain additional value. If an attacker holds these tokens, they can extract
    more value from the protocol than they put in.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    Access control best practices for DeFi contracts are
    the same as for smart contracts in general. Functions should be labeled as `private`
    by default and only be made publicly accessible if necessary for the smart contract''s
    logic.  ***Case Studies***    The Zenon Network was the victim of a hack in November
    2021.[^(33)](#c05-note-0033) An unprotected `burn` function allowed anyone to
    destroy wZNN tokens held by the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker deposited tokens into the contract to earn wZNN, then burned over
    26,000 wZNN tokens. This caused the value of wZNN tokens to increase significantly
    because the value held by the contract mapped to fewer wZNN tokens. The attacker
    was then able to extract over $1 million in WBNB by redeeming their wZNN tokens.  ######
    *Centralized Control*'
  prefs: []
  type: TYPE_NORMAL
- en: Access control vulnerabilities exist when too many people have access to high-risk
    functions within a smart contract. However, implementing strong access control
    can also create security risks for a contract by centralizing control of that
    contract's protected functions.
  prefs: []
  type: TYPE_NORMAL
- en: Many DeFi contracts are deployed using a single signature wallet, which means
    that only one private key is necessary to sign transactions that access private
    functionality such as `mint`, `burn`, and `self_destruct` functions. This makes
    it easier for an attacker or a malicious insider to take over the contract and
    steal the value that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample is an example of a centralized control vulnerability.[^(34)](#c05-note-0034)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This `mint` function correctly limits access to minting functionality, making
    it more difficult for an attacker to mint unauthorized tokens. However, there
    are no restrictions on the owner's ability to mint new tokens, meaning the contract
    owner could mint new tokens at will, devaluing those held by other users. This
    functionality could be abused by the owners of the contract or exploited by an
    attacker who gains access to the account of the contract's owner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    Access management is important to DeFi security, but
    privileged access should be decentralized as much as possible. All DeFi contracts
    should be managed by multisignature wallets, which require access to multiple
    private keys to perform privileged functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, DeFi smart contracts should operate under a decentralized governance
    model that does not put full control in the hands of the project team. This can
    help to protect against *rug pull* attacks where project members drain value invested
    in a project and disappear.  ***Case Studies***    The bZx DeFi protocol lost
    over $55 million in tokens in a November 2021 hack.[^(35)](#c05-note-0035) The
    attackers exploited the fact that the smart contract was not using a multisignature
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A phishing email to a bZx developer installed malware that stole the private
    keys for both the developer''s personal accounts and the ones that managed the
    bZx contract. The attacker then used these keys to drain funds from the developer''s
    account, the bZx contract, and any bZx users who had preexisting approvals for
    tokens on bZx.  ###### *Frontend Vulnerabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Most DeFi protocols are not implemented solely as a smart contract. They also
    have a web frontend that provides a user-friendly interface for interacting with
    the smart contract. This distributed application (DApp) architecture works similarly
    to traditional web applications, except that backend systems are implemented as
    a smart contract on the blockchain rather than an application on a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frontend applications should be part of the threat model for DeFi smart contracts.
    Some frontend security risks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious Scripts:** Compromised frontend systems may have malicious JavaScript
    injected into a page. The JavaScript could attempt to steal private keys or create
    malicious transactions for users to unwittingly approve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Mismatch:** Mismatches in the interface between the web frontend
    and smart contract backend can create unintentional and undesired effects. For
    example, actions performed on the frontend may not be passed on to the smart contract
    backend and recorded on the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Account Takeover:** Users typically authenticate to web frontends with a
    username and password, and these sites may store and manage private keys. An attacker
    who steals a user''s password via phishing or other means could access their private
    key and take over their blockchain account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial-of-Service Attacks:** Web frontends are a single point of failure
    in a DeFi project. A DDoS attack against these sites could render a project inaccessible
    to legitimate users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only some of the security risks associated with a web frontend for
    a DeFi project. These sites combine the traditional security risks of web applications
    with those associated with smart contract security.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    DeFi projects'' web frontends are like any other website.
    They should be analyzed for potential vulnerabilities and business logic errors
    as part of the security audit process.  ***Case Studies***    Users of the BadgerDAO
    smart contract were hacked using a frontend exploit in December 2021.[^(36)](#c05-note-0036)
    The attacker inserted malicious JavaScript into the project''s web frontend that
    inserted approvals for sending tokens to the attacker''s address in transactions
    generated by users. Over 500 wallets made these unwanted approvals, which the
    attacker used to drain over $120 million in tokens from them.  ###### *Price Manipulation*'
  prefs: []
  type: TYPE_NORMAL
- en: Price manipulation vulnerabilities are some of the most common attacks in the
    DeFi space. They are made possible by on-chain calculations of tokens' values
    and the existence of *flashloans*.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when a borrower takes out a loan, they need to provide some collateral.
    This collateral is an asset with a value roughly equal to the amount of the loan.
    If the borrower defaults on the loan, the lender can seize this asset to recoup
    their losses.
  prefs: []
  type: TYPE_NORMAL
- en: Collateral is necessary in traditional finance because it allows lenders to
    manage their risk. In DeFi, flashloans can be made without collateral because
    a lender can make risk-free loans.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible because of how transactions work in the blockchain. In many
    blockchains, transactions are all or nothing. If part of a transaction fails,
    the entire transaction is rolled back as if it never happened.
  prefs: []
  type: TYPE_NORMAL
- en: Flashloans take advantage of this by requiring that a loan taken at the start
    of a transaction be paid back by the end of that transaction. If the borrower
    defaults and does not make this repayment, then the whole transaction is invalidated
    and the loan never happens. As a result, lenders can make huge, risk-free loans
    because these loans are always paid back by the end of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Some DeFi smart contracts calculate the exchange rates of various tokens based
    on supply and demand and the value of the contract. The following code sample
    includes a calculation of the value of a DeFi contract's native token.[^(37)](#c05-note-0037)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function calculates the share of a smart contract's liquidity that a user
    can claim by depositing some of the contract's native tokens. With flashloans,
    an attacker can manipulate this calculation by inflating the asset balance of
    the contract relative to its quantity of native tokens. This allows the attacker
    to drain value from the contract by redeeming its overvalued tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    Price manipulation exploits take advantage of on-chain
    calculations of a token''s value. Contracts can avoid slippage by using Chainlink
    or similar price oracles.  ***Case Studies***    In October 2021, Cream Finance
    was exploited for over $130 million in tokens.[^(38)](#c05-note-0038) The attack
    began with a flashloan and included a loop of depositing tokens into Cream and
    using the deposit as collateral for another borrow. One of the attacking contracts
    accrued approximately 1.5 billion in crYUSD and ~500 million in yUSDVault tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker deposited the yUSDVault tokens to extract yUSD and decrease the
    total supply of tokens in the vault to $8 million. A deposit of $8 million in
    yUSD then doubled the vault''s total supply and the perceived value of crYUSD
    tokens. The attacker was able to use its now roughly $3 billion in crYUSD tokens
    to pay off its flashloans and extract $130 million from the vault.  ##### NFT
    Vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tokens hosted on a smart contract platform can be divided into two main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fungible:** Tokens are completely interchangeable. For example, a dollar
    bill is fungible because one bill has the same value as another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-Fungible:** A particular token has a unique, inherent value. For example,
    one baseball card might be worth much more than another despite the fact that
    they are both ink on paper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In blockchain, non-fungible tokens (NFTs) can be used to perform blockchain-based
    tracking. For example, the most common application of NFTs today is to track ownership
    of digital art. However, NFTs can also be used for logistics, identity management,
    and other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'NFTs have a lot of potential, but they also have security issues. Some of the
    major security concerns of NFTs today are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Forged NFTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious NFTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Off-Chain Asset Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform Centralization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unconstrained Token Supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '###### *Forged NFTs*'
  prefs: []
  type: TYPE_NORMAL
- en: NFTs are designed to track ownership of an asset on the blockchain. This ownership
    can then be transferred by sending the NFT between wallets. However, NFTs are
    based on the assumption that the creator of the NFT actually owns the asset and
    has the right to create the NFT.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, most NFTs are supposed to track ownership of digital artwork. Forged
    NFTs are created without the knowledge and consent of the artist or current owner
    of the artwork, meaning that they have no inherent value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    Validating the authenticity of NFTs is difficult because
    it likely requires verification of the asset by its owner. However, performing
    background research on an NFT offering may help with determining if it seems legitimate
    or suspicious.  ***Case Study***    In March 2021, artist Derek Laufman learned
    that a verified profile impersonating him on the Rarible NFT marketplace was selling
    NFTs of his art without his knowledge.[^(39)](#c05-note-0039) Although Rarible
    took the account down after it was brought to their attention, at least one fan
    had already bought an NFT of his work.  ###### *Malicious NFTs*'
  prefs: []
  type: TYPE_NORMAL
- en: Most modern NFTs are designed to track ownership of digital art. To view the
    art, a user needs to follow the link embedded in the NFT, which makes them an
    ideal vehicle for phishing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious NFTs could be designed to use social engineering to trick users into
    handing over their credentials for an NFT platform like OpenSea or the private
    key of their blockchain account. If successful, the attacker could then use this
    access to steal tokens and NFTs from the user's account.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    Malicious NFTs are image files that contain malicious
    code. Scanning image files for such code before opening them can help to protect
    against this attack.  ***Case Study***    In October 2021, Check Point Research
    discovered vulnerabilities in OpenSea that would allow for malicious NFTs attacks.[^(40)](#c05-note-0040)
    Carefully crafted CVG files could be used to create pop-ups that would prompt
    the user to take actions that could reveal their credentials or private key. There
    is no indication that this vulnerability was exploited, and OpenSea remediated
    it on its platform.  ###### *Off-Chain Asset Storage*'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are designed to be immutable digital ledgers, meaning that bloat
    is a significant concern. Any data stored on the blockchain must be stored indefinitely
    by every node in the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, NFTs are not stored directly on the blockchain's digital ledger.
    Instead, an NFT contains a URL that points to the associated image or the hash
    of that image on Interplanetary Filesystem (IPFS), a decentralized storage system.
  prefs: []
  type: TYPE_NORMAL
- en: This design means that an NFT does not indicate ownership of a piece of digital
    art so much as a particular URL or IPFS hash. The image at a particular URL or
    IPFS hash may be taken down or (in the case of URLs) changed. If this is the case,
    then the NFT loses its value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    For owners of NFTs hosted on IPFS, the owner of a
    token could take over the role of the IPFS gateway that hosts a copy of their
    NFT. However, URL-based NFTs could be taken down or replaced with another file
    at any time.  ***Case Study***    Multiple NFT platforms have taken down forged
    NFTs that infringed on the rights of the real owners of the content. For example,
    Cent shut down sales of many NFTs in February 2022 due to “rampant fakes and plagiarism.”[^(41)](#c05-note-0041)  ######
    *Platform Centralization*'
  prefs: []
  type: TYPE_NORMAL
- en: While NFTs are stored on the blockchain, most users interact with them via a
    web frontend. This makes managing NFTs more convenient but also introduces new
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: These NFT platforms are centralized and introduce the same vulnerabilities as
    DeFi web frontends. Attackers could take down a website with a DDoS attack or
    embed malicious content in it to steal users' private keys or NFTs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    As in the DeFi space, frontend vulnerabilities should
    be addressed during a security audit. This includes testing for web application
    vulnerabilities in the web frontend and validating the business logic of the frontend,
    backend, and interfaces between them.  ***Case Study***    In January 2022, OpenSea
    users were the victims of a hack that exploited miscommunications between the
    platform''s web frontend and smart contract backend.[^(42)](#c05-note-0042) Users
    believed that they were delisting NFTs when they were transferred between wallets
    because they were no longer listed for sale on the web frontend. However, these
    transactions were not recorded in the smart contract backend. An attacker sent
    transactions directly to the smart contract to buy these tokens at earlier sale
    prices well under the market rate.  ###### *Unconstrained Token Supply*'
  prefs: []
  type: TYPE_NORMAL
- en: Many modern NFTs are instances of generative art, where an algorithm puts together
    sets of building blocks in various different ways. Many NFT collections derive
    at least some of their value from the fact that only a certain number of the NFTs
    exist in the collection. The scarcity of the asset drives up the value.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all NFT smart contracts enforce these limits. The following code
    sample is a function from the Bored Apes Yacht Club (BAYC) contract,[^(43)](#c05-note-0043)
    a popular NFT collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This `reserveApes` function allows the owner of the BAYC to mint 30 new NFTs
    whenever they choose. By updating the URI indicated by the function, they could
    also add 30 new images to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Like `mint` functions in DeFi, this runs the risk of devaluing existing NFTs.
    This would likely either cause these tokens to lose all value or allow the contract
    owner to create and sell valuable NFTs at will. This vulnerability could be triggered
    by the contract creator or an attacker exploiting an access control vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures***    NFT minting contracts should have built-in controls
    that limit the quantity of NFTs within a collection. If expansions are expected
    in the future, they should be governed by code that prevents unauthorized changes.  ###
    Threat Modeling for Smart Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vulnerabilities in smart contracts can be mapped to all categories of the STRIDE
    threat model, as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing:** Smart contract vulnerabilities can be used for spoofing in various
    ways. For example, Solidity''s delegatecall allows a malicious contract to masquerade
    as another contract, and signature vulnerabilities can allow forged transactions
    to be accepted or even reveal private keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering:** Reentrancy and `delegatecall` vulnerabilities allow an attacker
    to tamper with the internal state of vulnerable smart contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repudiation:** Rollback attacks allow an attacker to undo actions before
    their results are recorded on the digital ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information Disclosure:** Exposure of private keys due to signature errors
    could allow an attacker to decrypt encrypted messages intended for a user. Also,
    many bad randomness vulnerabilities are based on the public visibility of information
    that the contract wished to be private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of Service:** Many denial-of-service vulnerabilities exist in smart
    contracts, such as Ethereum''s block gas limits and unexpected reversion vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of Privileges:** Access control vulnerabilities give an attacker
    privileged access to protected functions within a smart contract.  ## Blockchain
    Extensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts build on the basic blockchain protocol and have dramatically
    expanded its functionality. With applications like DeFi, blockchain has expanded
    from a decentralized system for tracking financial transactions to a fully functional
    financial system.
  prefs: []
  type: TYPE_NORMAL
- en: However, the capabilities of smart contracts are limited by the infrastructure
    that they run on. For example, blockchains like Ethereum have relatively low transaction
    rates (15 per second). This limits the number of transactions that can be performed
    on this platform and the scalability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 2 protocols are built on top of Layer 1 blockchains (Ethereum, Bitcoin,
    etc.) and expand their functionality and scalability. Some common layer 2 protocols
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: State channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidechains and bridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### State Channels'
  prefs: []
  type: TYPE_NORMAL
- en: A state channel is a Layer 2 protocol that creates a direct payment channel
    between two blockchain accounts. State channels are set up and taken down by transactions
    recorded on the blockchain's digital ledger, but all intermediate transactions
    are performed off chain. Well-known examples of state channels include Bitcoin's
    Lightning Network and Ethereum's Raiden Network.
  prefs: []
  type: TYPE_NORMAL
- en: At any point in time, both parties in a state channel have a signed commitment
    from the other about the current allocation of funds in the channel. A channel
    is set up by creating these mutual commitments and sending the balance stored
    in the channel to an address that locks it until the channel is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Payments are performed by exchanging new versions of these commitments that
    reallocate the funds within a channel. The channel can be closed if one or both
    parties publish a mutually signed commitment as a transaction on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: If a user unilaterally closes the channel, the other participant has a set period
    of time in which to submit a more recent version of the commitment. If this occurs,
    then the defrauded party receives the full balance of the channel. If not, the
    timelocked funds are unlocked and distributed based upon the published commitment.
  prefs: []
  type: TYPE_NORMAL
- en: State channels allow payments between parties that lack a direct channel between
    them. This is accomplished by routing payments through a series of channels that
    link the two parties. These transactions are crafted so that the balance updates
    with intermediate parties are only approved once the recipient acknowledges receipt
    of the transaction. Additionally, intermediate channel providers may charge a
    fee for the use of their channels.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *State Channel Security Considerations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'State channels rely on many of the same security assumptions as other blockchain
    technologies, such as the security of digital signature algorithms. However, the
    use of state channels also introduces other potential security risks:'
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-service attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timelock exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Denial-of-Service Attacks'
  prefs: []
  type: TYPE_NORMAL
- en: State channels can only process payments if a route exists between the two parties
    that has sufficient liquidity. For example, Alice can't send 1 Bitcoin to Bob
    if the current balance of value in their channel only allocates 0.9 BTC to her.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers can take advantage of this fact to perform denial-of-service (DoS)
    attacks on a state channel network. If an attacker can perform a DoS attack against
    crucial nodes in a state channel network or unbalance state channels, they can
    prevent value from being transferred to/from a particular user.  ##### Timelock
    Exploits'
  prefs: []
  type: TYPE_NORMAL
- en: State channels can be closed unilaterally by one of the channel participants.
    However, a timelock exists on the closure, which can allow the other participant
    to generate a punishment transaction that allows them to claim the value in the
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this transaction must be submitted and processed within the timelock
    to take effect before funds are released. If this transaction is delayed due to
    an eclipse/routing attack, malicious miner, and so on, then the victim can lose
    funds.[^(44)](#c05-note-0044)  ### Sidechains'
  prefs: []
  type: TYPE_NORMAL
- en: Every blockchain protocol has its advantages and limitations. For example, Bitcoin
    has robust security due to a massive amount of hashpower supporting its Proof
    of Work consensus algorithm. However, Bitcoin has limited throughput and no support
    for smart contracts. Other blockchains may have greater scalability and smart
    contract support but lack the security and name recognition of Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Sidechains attempt to address these issues by creating relationships between
    different blockchains. These links allow users to send tokens to a locking address
    on one blockchain and have an equivalent number of tokens released on another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sidechains can be implemented in a few different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bridges:** Bridges enable links between independent blockchains. For example,
    Anyswap, Binance Bridge, and Wormhole are examples of major bridges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child Chains:** Child chains are blockchains that add scalability and features
    to a blockchain. They have their own methods of creating and validating blocks
    but use the parent blockchain to resolve disputes. Plasma creates child chains
    for the Ethereum blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#### *Sidechain Security Considerations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sidechains enable interoperability between different blockchains via a mediator.
    This design creates potential security concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: Centralized bridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent chain security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable bridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Centralized Bridges'
  prefs: []
  type: TYPE_NORMAL
- en: A bridge linking two sidechains creates a high degree of centralization. Its
    users rely solely on the bridge to transfer assets between the two chains.
  prefs: []
  type: TYPE_NORMAL
- en: This degree of centralization creates significant security risks. A denial-of-service
    attack against the bridge could render it inaccessible to users, or an attacker
    could exploit the bridge to steal tokens from users or manipulate their value.
  prefs: []
  type: TYPE_NORMAL
- en: In February 2022, the Meter.io bridge was the victim of an attack that exploited
    an incorrect assumption in how the bridge handled wrapped tokens.[^(45)](#c05-note-0045)
    By exploiting this vulnerability, the attackers were able to make fake deposits
    into the bridge and then withdraw real tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'This vulnerability decreased the value of BNB.bsc on the BNB Chain. This allowed
    attackers to buy this token at low rates and use it as collateral for loans from
    Hunter Finance, which used Chainlink''s prices for the asset.[^(46)](#c05-note-0046)
    Although some of these loans were repaid, the project lost $3.3 million.  #####
    Independent Chain Security'
  prefs: []
  type: TYPE_NORMAL
- en: Sidechains create links between blockchains, but each blockchain has its own
    security. For example, a peg between Bitcoin and another chain does not grant
    the sidechain Bitcoin's protection against 51% attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a sidechain is the victim of a 51% or other attack, this can affect the
    exchange rate of tokens between the two chains. This occurred in the Meter.io
    hack where BNB.bsc was devalued on BNB Chain.  ##### Interface Errors'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a bridge between sidechains will allow users to lock tokens on one
    blockchain, which will unlock tokens on the other. However, this exchange might
    not work as designed, especially if the bridge contract contains exploitable vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the case in the hack of Qubit''s QBridge in January 2022.[^(47)](#c05-note-0047)
    A vulnerability in the bridge''s smart contract on the Ethereum blockchain enabled
    an attacker to trick it with a fake deposit of WETH. The bridge accepted the fake
    deposit and released qXETh tokens for the attacker on BNB Chain.  ##### Vulnerable
    Bridges'
  prefs: []
  type: TYPE_NORMAL
- en: Some links between sidechains are implemented as smart contracts that monitor
    operations on one blockchain and respond to them accordingly. If these smart contracts
    contain exploitable vulnerabilities, an attacker may be able to exploit these
    vulnerabilities to steal tokens from a bridge contract or disrupt its operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hack of the Wormhole bridge in February 2022 was the second most expensive
    DeFi hack at the time, allowing the attacker to steal $326 million in wETH from
    the bridge. The attacker exploited a signature verification vulnerability, which
    involved tricking the contract into believing that a signature had been successfully
    verified when it had not.[^(48)](#c05-note-0048) This allowed the attacker to
    mint 120,000 ETH tokens, which they then “legitimately” withdrew from the bridge
    contract.  ### Threat Modeling for Blockchain Extensions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attacks against state channels and sidechains can be mapped to several STRIDE
    threat categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tampering:** Timelock exploits allow an attacker to delete part of the history
    of a state channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repudiation:** Timelock exploits in state channels can allow an attacker
    to undo transactions performed in these channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of Service:** Denial-of-service attacks on state channels or bridges
    can impact accessibility to legitimate users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of Privileges:** Vulnerabilities in bridge code could grant an
    attacker control over transfers between sidechains.  ## Conclusion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts and blockchain extensions dramatically extend the functionality
    of blockchain protocols but also create additional complexity and risk. Most attacks
    against blockchain systems occur at these levels as attackers take advantage of
    design flaws or implementation errors in the protocols and programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our exploration of vulnerabilities and security risks at the
    various levels of the blockchain ecosystem. The next chapter discusses best practices
    for securely designing, implementing, and auditing blockchain-based systems.  ##
    Notes'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  [1](#R_c05-note-0001).  `[https://peckshield.medium.com/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536](https://peckshield.medium.com/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536)`
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#R_c05-note-0002).  `[https://twitter.com/PizzaProFi/status/1468869822389768192](https://twitter.com/PizzaProFi/status/1468869822389768192)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3](#R_c05-note-0003).  `[https://medium.com/multichainorg/anyswap-multichain-router-v3-exploit-statement-6833f1b7e6fb](https://medium.com/multichainorg/anyswap-multichain-router-v3-exploit-statement-6833f1b7e6fb)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4](#R_c05-note-0004).  `[www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct](https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[5](#R_c05-note-0005).  `[https://skylightcyber.com/2019/05/12/ethereum-smart-contracts-exploitation-using-right-to-left-override-character](https://skylightcyber.com/2019/05/12/ethereum-smart-contracts-exploitation-using-right-to-left-override-character)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[6](#R_c05-note-0006).  `[https://slowmist.medium.com/the-root-cause-of-poly-network-being-hacked-ec2ee1b0c68f](https://slowmist.medium.com/the-root-cause-of-poly-network-being-hacked-ec2ee1b0c68f)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[7](#R_c05-note-0007).  `[https://dasp.co](https://dasp.co)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[8](#R_c05-note-0008).  `[www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked](https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9](#R_c05-note-0009).  `[https://sia.tech/ddos2021](https://sia.tech/ddos2021)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#R_c05-note-0010). `[https://hacked.slowmist.io/en/search](https://hacked.slowmist.io/en/search)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#R_c05-note-0011). `[https://medium.com/punkprotocol/punk-finance-fair-launch-incident-report-984d9e340eb](https://medium.com/punkprotocol/punk-finance-fair-launch-incident-report-984d9e340eb)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#R_c05-note-0012). `[https://dodoexhelp.zendesk.com/hc/en-us/articles/900004851126-Important-update-regarding-recent-events-on-DODO](https://dodoexhelp.zendesk.com/hc/en-us/articles/900004851126-Important-update-regarding-recent-events-on-DODO)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#R_c05-note-0013). `[https://slowmist.medium.com/roll-back-attack-about-blacklist-in-eos-adf53edd8d69](https://slowmist.medium.com/roll-back-attack-about-blacklist-in-eos-adf53edd8d69)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#R_c05-note-0014). `[https://eprint.iacr.org/2016/1007.pdf](https://eprint.iacr.org/2016/1007.pdf)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[15](#R_c05-note-0015). `[https://eprint.iacr.org/2016/1007.pdf](https://eprint.iacr.org/2016/1007.pdf)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16](#R_c05-note-0016). `[https://github.com/kieranelby/KingOfTheEtherThrone/blob/v1.0/contracts/KingOfTheEtherThrone.sol](https://github.com/kieranelby/KingOfTheEtherThrone/blob/v1.0/contracts/KingOfTheEtherThrone.sol)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17](#R_c05-note-0017). `[https://consensys.github.io/smart-contract-best-practices/attacks/force-feeding](https://consensys.github.io/smart-contract-best-practices/attacks/force-feeding)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18](#R_c05-note-0018). `[https://medium.com/@nmcl/gridlock-a-smart-contract-bug-73b8310608a9](https://medium.com/@nmcl/gridlock-a-smart-contract-bug-73b8310608a9)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[19](#R_c05-note-0019). `[https://blocksecteam.medium.com/when-safetransfer-becomes-unsafe-lesson-from-the-qbridge-security-incident-c32ecd3ce9da](https://blocksecteam.medium.com/when-safetransfer-becomes-unsafe-lesson-from-the-qbridge-security-incident-c32ecd3ce9da)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20](#R_c05-note-0020). `[https://medium.com/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee](https://medium.com/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[21](#R_c05-note-0021). `[https://eips.ethereum.org/EIPS/eip-20](https://eips.ethereum.org/EIPS/eip-20)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[22](#R_c05-note-0022). `[https://blog.forcedao.com/xforce-exploit-post-mortem-7fa9dcba2ac3](https://blog.forcedao.com/xforce-exploit-post-mortem-7fa9dcba2ac3)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23](#R_c05-note-0023). `[www.kingoftheether.com/postmortem.html](https://www.kingoftheether.com/postmortem.html)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24](#R_c05-note-0024). `[https://cmichel.io/replaying-ethereum-hacks-furucombo](https://cmichel.io/replaying-ethereum-hacks-furucombo)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25](#R_c05-note-0025). `[https://cmichel.io/eos-1-3-contract-development-toolkit-updates](https://cmichel.io/eos-1-3-contract-development-toolkit-updates)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26](#R_c05-note-0026). `[www.reddit.com/r/eos/comments/9fpcik/how_eosbet_attacked_by_aabbccddeefg](https://www.reddit.com/r/eos/comments/9fpcik/how_eosbet_attacked_by_aabbccddeefg)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27](#R_c05-note-0027). `[https://github.com/slowmist/eos-smart-contract-security-best-practices/blob/master/README_EN.md#transfer-error-prompt](https://github.com/slowmist/eos-smart-contract-security-best-practices/blob/master/README_EN.md#transfer-error-prompt)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[28](#R_c05-note-0028). `[https://blog.peckshield.com/2018/10/26/eos](https://blog.peckshield.com/2018/10/26/eos)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29](#R_c05-note-0029). `[https://cmichel.io/eos-vault-sx-hack](https://cmichel.io/eos-vault-sx-hack)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30](#R_c05-note-0030). `[https://cmichel.io/eos-vault-sx-hack](https://cmichel.io/eos-vault-sx-hack)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31](#R_c05-note-0031). `[https://developers.eos.io/welcome/v2.1/protocol-guides/transactions_protocol](https://developers.eos.io/welcome/v2.1/protocol-guides/transactions_protocol)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32](#R_c05-note-0032). `[https://twitter.com/RugDocIO/status/1451067795140005891](https://twitter.com/RugDocIO/status/1451067795140005891)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33](#R_c05-note-0033). `[https://twitter.com/peckshield/status/1462165620506742784](https://twitter.com/peckshield/status/1462165620506742784)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34](#R_c05-note-0034). `[https://letmeape.medium.com/how-to-spot-a-potential-rug-clear-signs-something-is-sketchy-169fb84c7084#59e7](https://letmeape.medium.com/how-to-spot-a-potential-rug-clear-signs-something-is-sketchy-169fb84c7084#59e7)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35](#R_c05-note-0035). `[https://bzx.network/blog/prelminary-post-mortem](https://bzx.network/blog/prelminary-post-mortem)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36](#R_c05-note-0036). `[https://rekt.news/badger-rekt](https://rekt.news/badger-rekt)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37](#R_c05-note-0037). `[https://peckshield.medium.com/the-spartan-incident-root-cause-analysis-a0324cb4b42a](https://peckshield.medium.com/the-spartan-incident-root-cause-analysis-a0324cb4b42a)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38](#R_c05-note-0038). `[https://rekt.news/cream-rekt-2](https://rekt.news/cream-rekt-2)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[39](#R_c05-note-0039). `[www.theverge.com/2021/3/20/22334527/nft-scams-artists-opensea-rarible-marble-cards-fraud-art](https://www.theverge.com/2021/3/20/22334527/nft-scams-artists-opensea-rarible-marble-cards-fraud-art)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40](#R_c05-note-0040). `[https://gizmodo.com/gullible-opensea-users-were-vulnerable-to-malicious-nft-1847850437](https://gizmodo.com/gullible-opensea-users-were-vulnerable-to-malicious-nft-1847850437)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[41](#R_c05-note-0041). `[www.reuters.com/business/finance/nft-marketplace-shuts-citing-rampant-fakes-plagiarism-problem-2022-02-11](https://www.reuters.com/business/finance/nft-marketplace-shuts-citing-rampant-fakes-plagiarism-problem-2022-02-11)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42](#R_c05-note-0042). `[https://decrypt.co/91076/opensea-exploit-sees-bored-ape-yacht-club-nft-sell-1700](https://decrypt.co/91076/opensea-exploit-sees-bored-ape-yacht-club-nft-sell-1700)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43](#R_c05-note-0043). `[https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code](https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44](#R_c05-note-0044). `[www.coindesk.com/tech/2020/10/27/4-bitcoin-lightning-network-vulnerabilities-that-havent-been-exploited-yet](https://www.coindesk.com/tech/2020/10/27/4-bitcoin-lightning-network-vulnerabilities-that-havent-been-exploited-yet)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45](#R_c05-note-0045). `[https://twitter.com/ishwinder/status/1490227406824685569](https://twitter.com/ishwinder/status/1490227406824685569)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46](#R_c05-note-0046). `[https://rekt.news/meter-rekt](https://rekt.news/meter-rekt)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[47](#R_c05-note-0047). `[https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0](https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[48](#R_c05-note-0048). `[https://twitter.com/samczsun/status/1489044939732406275](https://twitter.com/samczsun/status/1489044939732406275)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
