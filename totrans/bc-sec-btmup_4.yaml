- en: CHAPTER 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Advanced
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级
- en: Bitcoin, the original blockchain protocol, was primarily designed to implement
    a decentralized system for tracking financial transactions. While Bitcoin has
    some scripting capabilities, these programs are not Turing-complete, meaning they
    cannot implement all of the functionality that a program running on another computer
    could. This lack of Turing-completeness limits their capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Bitcoin，最初的区块链协议，主要是为了实现一个用于追踪金融交易的分布式系统。尽管比特币具备一些脚本功能，但这些程序并不具备图灵完备性，这意味着它们无法实现运行在另一台计算机上的程序的所有功能。这种图灵不完备性限制了它们的能力。
- en: 'Smart contract platforms extend the blockchain protocol to allow Turing-complete
    programs to run on top of the blockchain, dramatically expanding what can be done
    on the blockchain. Blockchain extensions go a step further, leveraging smart contracts''
    capabilities to build protocols that address key limitations of blockchain technology
    by building new protocols on top of them or interconnecting different blockchain
    systems.  ## Smart Contracts'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '智能合约平台扩展了区块链协议，允许图灵完备的程序在区块链之上运行，极大地扩展了区块链上可以完成的事情。区块链扩展更进一步，利用智能合约的能力构建协议，通过在智能合约之上构建新的协议或连接不同的区块链系统，解决区块链技术的关键局限性。  ##
    智能合约'
- en: Smart contracts are programs that run on top of a blockchain's distributed ledger.
    The goal of smart contract platforms is to create a “world computer” where each
    node in the blockchain network maintains an instance of a virtual machine and
    the state of this virtual machine is synchronized across the blockchain network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是在区块链分布式账本之上运行的程序。智能合约平台的目标是创建一个“世界计算机”，在该计算机中，区块链网络中的每个节点维护一个虚拟机实例，并且这个虚拟机的状态在整个区块链网络中同步。
- en: Smart contract platforms achieve synchronization by controlling the instructions
    that are run on the distributed virtual machine and the execution environment.
    Instructions are coordinated using the blockchain's distributed ledger and consensus
    algorithms. Instructions are embedded in transactions, which are organized into
    blocks and added to the ledger. This ensures that, if the network is in consensus
    regarding the state of the blockchain, every node agrees on the order in which
    transactions are executed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约平台通过控制在分布式虚拟机上运行的指令和执行环境来实现同步。指令通过区块链的分布式账本和共识算法进行协调。指令嵌入在交易中，交易组织成区块并添加到账本中。这确保了，如果网络就区块链的状态达成共识，每个节点都同意交易执行的顺序。
- en: Smart contract platforms control the execution environment by running these
    instructions in a virtual machine. Smart contracts' virtual machines are designed
    to create identical, deterministic execution environments on every node in the
    network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约平台通过在虚拟机中运行这些指令来控制执行环境。智能合约的虚拟机旨在为网络中的每个节点创建完全相同、确定性的执行环境。
- en: In theory, if every node runs the same code in identical environments, they
    should all have the exact same results. This makes it possible to maintain both
    decentralization and synchronization within the “world computer.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果每个节点在相同的环境中运行相同的代码，它们应该都会得到完全相同的结果。这使得在“世界计算机”内同时维护去中心化和同步成为可能。
- en: '### Smart Contract Vulnerabilities'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### 智能合约漏洞'
- en: Smart contracts are software, and software has bugs. Even as immature as smart
    contract technology is, there are a variety of common vulnerabilities already
    associated with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是软件，而软件有漏洞。即使智能合约技术尚不成熟，已经与它相关联的各种常见漏洞已经存在。
- en: The following sections cover some of the most common smart contract vulnerabilities.
    However, since the smart contract and smart contract security landscapes are constantly
    evolving, this will never be a comprehensive list of all possible smart contract
    vulnerabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节涵盖了智能合约中一些最常见的漏洞。然而，由于智能合约和智能合约安全领域在不断演变，这永远不会是一个全面的，包含所有可能的智能合约漏洞的列表。
- en: 'In this discussion, vulnerabilities are divided into four major categories:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，漏洞被分为四大类：
- en: '**General Programming Vulnerabilities:** These vulnerabilities can exist in
    any application. Smart contracts contain them simply because they are programs.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用编程漏洞：**这些漏洞可能存在于任何应用程序中。智能合约之所以存在这些漏洞，仅仅是因为它们是程序。'
- en: '**Blockchain-Specific Vulnerabilities:** These vulnerabilities arise from the
    unique design of blockchain technology. They are platform-agnostic and apply across
    most or all blockchain implementations.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链特定漏洞：**这些漏洞源于区块链技术的独特设计。它们与平台无关，并适用于大多数或所有区块链实现。'
- en: '**Platform-Specific Vulnerabilities:** These vulnerabilities are specific to
    a certain smart contract platform. Ethereum and EOSIO are two of the oldest and
    most used smart contract platforms, which have provided the most opportunity for
    vulnerabilities to be discovered.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台特定漏洞：**这些漏洞是特定于某个智能合约平台的。以太坊和EOSIO是最老和最常用的两个智能合约平台，它们提供了最多的漏洞被发现的机会。'
- en: '**Application-Specific Vulnerabilities:** Smart contracts can be designed for
    different purposes. Decentralized finance (DeFi) and non-fungible tokens (NFTs)
    are two of the most common and fastest-growing applications of smart contracts.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用特定漏洞：**智能合约可以被设计用于不同的目的。去中心化金融（DeFi）和非同质化代币（NFTs）是智能合约最常见和增长最快的两个应用。'
- en: '#### *General Programming Vulnerabilities*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *通用编程漏洞*'
- en: General programming vulnerabilities are vulnerabilities that can exist in any
    program. They arise from how software works and manages variables, memory, and
    so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通用编程漏洞是可能存在于任何程序中的漏洞。它们源于软件是如何工作和管理变量、内存等等的方式。
- en: A buffer overflow vulnerability is an example of a general programming vulnerability.
    Programs allocate chunks of memory to hold data, and problems can arise if the
    data to be placed in the buffer is larger than the buffer itself. As long as programs
    manage memory in this way, buffer overflows are a potential risk in languages
    that lack protections against them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出漏洞是通用编程漏洞的一个例子。程序为数据分配内存块，如果打算放入缓冲区的数据比缓冲区本身还要大，就会出现问题。只要程序以这种方式管理内存，在缺乏保护的语言中，缓冲区溢出就是一个潜在的风险。
- en: 'A complete list of all the potential general programming vulnerabilities that
    could exist in smart contracts is beyond the scope of this discussion. Some of
    the main vulnerabilities that appear in smart contracts are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本文讨论的范围之外，完整地列出所有可能在智能合约中存在的通用编程漏洞是不可能的。一些在智能合约中出现的主要漏洞如下：
- en: Arithmetic vulnerabilities
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术漏洞
- en: Decimal precision
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制精度
- en: Digital signature vulnerabilities
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名漏洞
- en: External dependencies
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖
- en: Right-to-left control characters
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从左到右的控制字符
- en: Unsafe serialization
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的序列化
- en: '##### Arithmetic Vulnerabilities'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 算术漏洞'
- en: Arithmetic vulnerabilities such as integer overflow and underflow vulnerabilities
    can exist in most programming languages. Arithmetic vulnerabilities are made possible
    by how variables work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 像整数溢出和下溢漏洞这样的算术漏洞存在于大多数编程语言中。算术漏洞是由变量的工作方式所允许的。
- en: '###### *Variables and Signedness*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *变量和符号位*'
- en: A variable is a fixed-size chunk of memory designed to hold a value. How the
    series of bits stored in this variable is interpreted depends on the variable
    type. For example, both an `int` and a `float` can be 4 or 8 bytes long, but the
    same series of bits are interpreted in very different ways.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是设计用来存储一个值的字节大小的内存块。这个变量中存储的一系列位是如何解释的，取决于变量的类型。例如，`int` 和 `float` 都可以是 4
    或 8 字节长，但同样的位序列被解释的方式非常不同。
- en: Within the numeric data types, there is also the concept of signed vs. unsigned
    variables. As their names suggest, signed variables have a sign and the ability
    to hold negative values, while unsigned ones do not. In a signed variable, the
    most significant bit holds the sign, while in unsigned variables, this bit is
    part of the value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值数据类型中，还存在有符号和无符号变量的概念。如他们的名字所暗示，有符号变量有符号并且能够存储负值，而无符号变量则没有。在有符号变量中，最高位存储符号，而在无符号变量中，这个位是值的一部分。
- en: 'Integer overflow and underflow vulnerabilities are enabled by variables'' fixed
    sizes and the ability to cast a value between signed and unsigned types. Values
    stored in a variable must remain within a set range, and unsafe casts between
    variables can cause the same series of bits to be interpreted in different ways.  ######
    *Integer Overflows*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '整数溢出和下溢漏洞是由变量的固定大小和将值在有符号和无符号类型之间转换的能力所启用的。存储在变量中的值必须保持在一定的范围内，变量之间的不安全转换可能导致同样的位序列被以不同的方式解释。  ######
    *整数溢出*'
- en: An integer overflow vulnerability occurs when too small of a variable is used
    to hold a value. For example, a 32-bit unsigned integer can hold values in the
    range 0 to 4,294,967,295, while 32-bit signed integers can hold values in the
    range –2,147,483,648 to 2,147,483,647\. If a value greater than this maximum value
    is placed in the variable, the value saved is the value of the 32 least significant
    bits of the original number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 整数溢出漏洞发生在使用过小的变量来保存一个值时。例如，32位无符号整数可以容纳0到4,294,967,295的值，而32位有符号整数可以容纳-2,147,483,648到2,147,483,647的值。如果将一个大于这个最大值的值放入变量中，保存的值就是原始数字的32个最低有效位。
- en: Integer overflows can occur in one of two ways. One option is that the result
    of a computation exceeds the maximum value that can fit in a variable. [Figure
    5.1](#c05-fig-0001) illustrates this for an 8-bit value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 整数溢出可以以两种方式之一发生。一种选项是计算结果超过了变量能容纳的最大值。 [图5.1](#c05-fig-0001) 为一个8位值说明了这一点。
- en: '![An illustration of integer overflow.](images/c05f001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![整数溢出的说明](images/c05f001.png)'
- en: '[**Figure 5.1**](#R_c05-fig-0001): Integer overflow'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图5.1**](#R_c05-fig-0001)：整数溢出'
- en: The other possibility is that an unsafe typecast forces a value into a variable
    too small to hold it. For example, the value 3000000000 fits into an unsigned
    integer but not a signed one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是，一个不安全的类型转换强制一个值进入一个太小而无法容纳它的变量中。例如，值3000000000适合无符号整数但不适合有符号整数。
- en: The following code sample is from a smart contract containing an integer overflow
    vulnerability named batchOverflow by PeckShield.[¹](#c05-note-0001)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例来自一个智能合约，其中包含一个由PeckShield命名的整数溢出漏洞batchOverflow。[¹](#c05-note-0001)
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code sample is designed to send the same amount of value to multiple recipients.
    The code calculates the total amount of value to be sent and validates that the
    sender has at least this much value in their account. Then, it individually transfers
    value to each of the intended recipients.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例旨在向多个接收者发送相同金额的价值。代码计算要发送的总价值量，并验证发送者账户中至少有这么多价值。然后，它分别向每个预期接收者转账价值。
- en: This code has a potential integer overflow value in the calculation of *`amount`*.
    If the product of *`cnt`* and *`_value`* is at least 2^(256), then the value of
    *`amount`* will overflow. For example, a *`cnt`* of 8 and a *`_value`* of 2^(253)
    will produce a product of 2^(256), which is more than can fit in *`amount`*, resulting
    in a value of 0 being stored in *`amount`*. An *`amount`* of 0 will pass the test
    `balances[msg.sender] >= amount`, allowing the transfers to go through.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在计算*`amount`*时存在一个潜在的整数溢出值。如果*`cnt`*和*`_value`*的乘积至少为2^(256)，那么*`amount`*的值就会溢出。例如，*`cnt`*为8，*`_value`*为2^(253)将会产生一个乘积为2^(256)，这超过了*`amount`*能容纳的值，导致*`amount`*存储的值为0。*`amount`*的值为0将通过了`balances[msg.sender]
    >= amount`的测试，允许转账完成。
- en: 'When performing the transfers in the loop, the code uses the variable *`_value`*,
    which indicates the amount to be sent to each recipient. As a result, each recipient
    will receive a transfer of 2^(253) tokens, while the sender''s account is debited
    0 tokens (the value of *`amount`*). These recipients could then later withdraw
    their balances from the contracts, extracting value that legitimately belongs
    to other users.  ###### *Integer Underflows*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中执行转账时，代码使用了变量*`_value`*，它表示要发送给每个接收者的金额。因此，每个接收者将收到2^(253)个代币的转账，而发送者的账户将记账0个代币(*`amount`*的值)。这些接收者随后可以从合约中提取他们的余额，提取属于其他用户的合法价值。######
    整数下溢
- en: Integer underflows exist when a variable is asked to store a value lower than
    its minimum value. This too can occur as a result of a calculation or due to trying
    to use the wrong variable type to store a value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被要求存储一个低于其最小值的值时，就会发生整数下溢。这也可以是由于计算结果或者由于使用错误的变量类型来存储一个值而发生的。
- en: Unsigned variables can only store positive numbers, so any value less than zero
    will underflow the variable. This could occur as a result of a mathematical operation
    or due to an unsafe cast from a signed variable, which can store negative numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号变量只能存储正数，所以任何小于零的值都会使变量下溢。这可能是由于数学操作或者由于从有符号变量（可以存储负数）的不安全转换而发生的。
- en: The following code sample is an example of a withdraw function that contains
    an integer underflow vulnerability.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例是一个包含整数下溢漏洞的提现函数。
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code sample, the purpose of the `require` statement is to validate that
    an account contains the requested amount before allowing it to be withdrawn. In
    theory, subtracting the amount from the balance and testing that the result is
    nonnegative should work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`require` 语句的目的是验证账户中是否包含请求的金额，然后再允许提款。理论上，从余额中减去金额并测试结果是否非负应该可以工作。
- en: 'However, the variables used in the calculation (*`amount`* and *`balances`*)
    are both unsigned integers, which means that the result will be an unsigned integer
    as well. Since unsigned integers cannot store a negative number, the result of
    the calculation will always be greater than or equal to zero. As a result, the
    `require` statement will approve any withdrawal request, enabling a malicious
    user to steal value from the contract.  ###### *Countermeasures*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用于计算的变量(*`amount`* 和 *`balances`*) 都是无符号整数，这意味着结果也将是一个无符号整数。由于无符号整数无法存储负数，计算的结果总是大于或等于零。因此，`require`
    语句将批准任何提款请求，允许恶意用户从合约中窃取价值。###### *对策*
- en: 'Arithmetic vulnerabilities generally result from using the wrong variable type
    for an operation or an unsafe conversion between variable types. These may be
    detected by automated tools or should be picked up by a code review.  ###### *Case
    Studies*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 算术漏洞通常是由于使用了不适合操作的变量类型或变量类型之间的不安全转换造成的。这些可以通过自动化工具检测到，或者应该在代码审查中找出。###### *案例研究*
- en: 'In December 2021, the PIZZA DeFi project was exploited for $5 million in tokens.
    The attackers took advantage of an integer overflow vulnerability in the eCurve
    smart contract to create a massive amount of Tripool tokens.[²](#c05-note-0002)
    These tokens were then deposited into the PIZZA smart contract, which allowed
    the attacker to extract the other tokens deposited within the contract.  #####
    Decimal Precision'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年12月，PIZZA DeFi 项目遭到攻击，损失了500万美元的代币。攻击者利用了 eCurve 智能合约中的整数溢出漏洞，创建了大量 Tripool
    代币。[²](#c05-note-0002) 然后这些代币被存入 PIZZA 智能合约中，这使得攻击者能够提取合约中存放的其他代币。##### 小数精度
- en: Smart contracts commonly contain mathematical operations, especially when they
    store and transfer value. One common vulnerable code pattern is division before
    multiplication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约通常包含数学运算，尤其是在存储和传输价值时。一个常见的脆弱代码模式是乘法之前的除法。
- en: In Solidity—and any other programming language—numeric data types have limited
    precision. While this may not matter in most cases, division and multiplication
    with large numbers can cause small rounding errors to have significant effects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中——以及任何其他编程语言中——数值数据类型都有有限的精度。虽然在大多数情况下这可能不重要，但大数字的除法和乘法可能会导致小的舍入错误产生重大影响。
- en: The following code sample uses a divide-before-multiply code pattern when calculating
    the value of a token.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例在计算代币价值时使用了除法在乘法之前的代码模式。
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Solidity works with integer data types, which means the result of the division
    will be rounded before the multiplication is performed. This could result in a
    final answer that is different and smaller than if multiplication were performed
    before division. As a result, the token is undervalued, and the user receives
    less in trade than they should.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 使用整数数据类型进行操作，这意味着在乘法执行之前，除法的结果将被四舍五入。这可能导致最终答案与除法在乘法之前执行时的答案不同且更小。结果，代币被低估，用户在交易中获得的比他们应该得到的要少。
- en: '###### *Countermeasures*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'When performing multiplication and division in Solidity, use the multiply-before-divide
    code pattern. This helps to preserve the precision of the result but risks integer
    overflows.  ##### Digital Signature Vulnerabilities'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中执行乘法和除法时，应使用乘法在除法之前的代码模式。这有助于保留结果的精度，但存在整数溢出的风险。##### 数字签名漏洞
- en: Digital signatures provide the ability to authenticate a transaction and validate
    that it has not been modified in transit. Digital signatures are commonly used
    in smart contracts, especially in the DeFi space.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名提供了验证交易并在传输过程中验证其未被修改的能力。数字签名通常用于智能合约中，尤其是在 DeFi 领域中。
- en: 'However, digital signatures can go wrong in a few different ways:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数字签名可能会以几种不同的方式出错：
- en: '**Missing Validation:** Digital signatures are useful only if they are validated.
    Missing signature validation can allow an attacker to submit fake requests on
    behalf of other users.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺少验证：** 数字签名只有在其被验证时才有效。缺少签名验证可能会允许攻击者代表其他用户提交伪造请求。'
- en: '**Cryptographic Errors:** Cryptographic algorithms can be fragile and must
    be properly implemented to be secure. One example of a cryptographic vulnerability
    is the reuse of random values across multiple signatures.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密错误：**加密算法可能很脆弱，必须正确实现才能保证安全。一个加密漏洞的例子是在多个签名之间重复使用随机值。'
- en: '**Malleable Signatures**: In some cases, the data covered by a digital signature
    may be interpreted in different ways, due to serialization or other factors.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可塑签名**：在某些情况下，由于序列化或其他因素，数字签名覆盖的数据可能会以不同的方式解释。'
- en: The effects of digital signature errors depend on the vulnerability in question.
    They range from accepting a forged transaction to providing the attacker with
    complete control over the account used to generate the signature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名错误的效果取决于具体漏洞。从接受伪造交易到向攻击者提供生成签名的账户完全控制权，其范围不一。
- en: '###### *Countermeasures*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'Digital signatures should be implemented with trusted cryptographic libraries
    whenever possible. Also, code should ensure that signatures are validated before
    accepting transactions.  ###### *Case Studies*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '应尽可能使用受信任的加密库实现数字签名。此外，代码应确保在接受交易之前验证签名。  ###### *案例研究*'
- en: In July 2021, the Anyswap protocol was the victim of a hack due to cryptographic
    errors in its implementation of the Elliptic Curve Digital Signature Algorithm
    (ECDSA).[³](#c05-note-0003) Multiple transactions used the same value of K, which
    is supposed to be a random, single-use value. As a result, part of the signature,
    R, was identical for both signatures, making this reuse trivial to detect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年7月，Anyswap协议因实现椭圆曲线数字签名算法（ECDSA）中的加密错误而遭到黑客攻击。[³](#c05-note-0003)多个交易使用了相同的K值，这个值应该是一个随机的一次性使用值。结果，两个签名的部分R是相同的，使得这种重复使用很容易被检测到。
- en: 'With these two signatures, an attacker was able to calculate the private key
    used in generating the signatures. This gave the attacker control over the blockchain
    account and the ability to steal an estimated $7,870,000 in tokens.  ##### External
    Dependencies'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '利用这两个签名，攻击者能够计算出生成签名的私钥。这使得攻击者能够控制区块链账户，并能够窃取大约787万美元的代币。  ##### 外部依赖'
- en: The use of library functions and other third-party dependencies is common both
    for traditional programming and smart contracts. Code reuse can help to expedite
    the development process and can result in improved code performance and security
    if high-quality libraries are used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程和智能合约中，使用库函数和其他第三方依赖是很常见的。代码重用可以加快开发过程，如果使用高质量的库，还可能提高代码性能和安全。
- en: 'However, the use of external dependencies makes this third-party code part
    of an application''s attack surface. The following list includes two of the risks
    associated with external dependencies:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，外部依赖的使用使得第三方代码成为应用程序攻击面的一部分。以下列表包括与外部依赖相关联的两个风险：
- en: '**Vulnerability Exploitation:** Third-party code may contain vulnerabilities
    that leave it open to attack. A smart contract with external dependencies may
    inherit vulnerabilities from this third-party code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**漏洞利用：**第三方代码可能包含漏洞，使其容易受到攻击。具有外部依赖的智能合约可能会从这种第三方代码中继承漏洞。'
- en: '**Denial-of-Service Attacks:** A smart contract may rely upon external smart
    contracts and functions to implement important functionality. If these external
    dependencies become unavailable due to self-destruction or other issues, then
    a smart contract may be rendered inoperable unless it can be updated to remove
    these dependencies.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务拒绝攻击：**智能合约可能依赖于外部智能合约和功能来实现重要的功能。如果这些外部依赖因自毁或其他问题而变得不可用，那么除非能够更新以去除这些依赖，否则智能合约可能变得无法操作。'
- en: Smart contracts are designed to interact, and minimizing redundant code is especially
    important on the blockchain because it helps to minimize bloat on the blockchain's
    digital ledger. However, the use of external dependencies can create security
    risks for a smart contract.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约旨在交互，并且在区块链上减少冗余代码尤为重要，因为这有助于减少区块链数字账本上的膨胀。然而，外部依赖的使用可能会为智能合约带来安全风险。
- en: '###### *Countermeasures*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'External dependencies should be audited before use to identify any potential
    security issues that they could introduce into a smart contract. Additionally,
    smart contracts should be deployed in such a way that they can be changed as needed
    to remove or update vulnerable or deprecated dependencies.  ###### *Case Studies*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用外部依赖之前，应该对其进行审计，以识别它们可能引入到智能合约中的任何潜在安全问题。此外，智能合约应该以一种方式部署，以便它们可以根据需要更改，以移除或更新脆弱或过时的依赖。######
    案例研究
- en: Parity wallet was a smart contract-based wallet. Users of the wallet could deploy
    their own instances of the contract, which relied on a central library contract
    for core functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Parity钱包是基于智能合约的钱包。钱包的用户可以部署他们自己的合约实例，这些实例依赖于一个中心库合约的核心功能。
- en: 'This library function contained an access control vulnerability that allowed
    an attacker to take ownership of the contract.[⁴](#c05-note-0004) The attacker
    then called the contract''s `self_destruct` function, which rendered it unusable.
    Since all Parity wallet contracts relied on this contract for core functionality,
    this caused the 513,774.16 ETH, plus other tokens stored in these wallets, to
    be lost forever since the functions needed to transfer these tokens out of the
    wallets no longer existed.  ##### Right-to-Left Control Character'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库函数包含一个访问控制漏洞，允许攻击者接管合约。[④](#c05-note-0004) 攻击者随后调用了合约的 `self_destruct` 函数，使其变得无法使用。由于所有Parity钱包合约都依赖于这个合约的核心功能，这导致513,774.16
    ETH以及存储在这些钱包中的其他代币永远丢失，因为不再存在将这些代币从钱包中转出的功能。##### 右至左控制字符
- en: Right-to-left control characters are a feature in computers that allows them
    to support different languages. While English is written from left to right, other
    languages, like Arabic, are written from right to left. Non-printable control
    characters make it possible to switch between text directions, enabling support
    for both conventions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 右至左控制字符是计算机上的一项功能，使它们能够支持不同的语言。虽然英语是从左至右书写的，但其他语言，如阿拉伯语，是从右至左书写的。非打印控制字符使得能够切换文本方向，从而支持这两种约定。
- en: Since these control characters are non-printable and can appear anywhere in
    a line of text, they can be used by an unscrupulous smart contract developer to
    obfuscate the meaning of their code. Smart contracts are often open source, building
    trust by allowing anyone to review a contract's code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些控制字符是不可打印的，并且可以出现在文本行的任何位置，因此它们可以被一个不择手段的智能合约开发者用来模糊其代码的含义。智能合约通常是开源的，通过允许任何人审查合约代码来建立信任。
- en: The following code sample was developed by Skylight Cyber to demonstrate the
    malicious use of right-to-left control characters.[⁵](#c05-note-0005)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例是由Skylight Cyber开发的，用以展示右至左控制字符的恶意使用。[⑤](#c05-note-0005)
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code sample is a game where a user places a bet and tries to guess a secret
    number. If they win, they receive a prize.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例是一个游戏，用户下注并尝试猜测一个秘密数字。如果他们赢了，他们将获得奖品。
- en: The `guess` function validates that the user has made a bet of 1 ETH and stores
    the current value of the pot in *`p`*. Then, the `checkAndTransferPrize` function
    is called, which checks if *`n`* equals the secret number and, if so, sends the
    prize to the winner.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`guess` 函数验证用户是否下注了1 ETH，并将彩池的当前值存储在 *`p`* 中。然后调用 `checkAndTransferPrize` 函数，该函数检查
    *`n`* 是否等于秘密数字，如果是，则将奖金发送给获胜者。'
- en: 'In this contract, the malicious line of code is the call to the `checkAndTransferPrize`
    function, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此合约中，恶意代码行是对 `checkAndTransferPrize` 函数的调用，如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command sends the prize amount, the guessed number, and the account address
    of the winner to the `checkAndTransferPrize` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将奖金金额、猜测的数字以及获胜者的账户地址发送到 `checkAndTransferPrize` 函数。
- en: However, the comments in this line of code are not present due to good coding
    practices. Instead, the comments in the first line of code contain non-printable
    control characters that switch text direction from left-to-right to right-to-left
    and back again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于良好的编码实践，此行代码中的注释并不存在。相反，代码第一行中的注释包含非打印的控制字符，这些字符使文本方向从左至右切换到右至左，再切换回来。
- en: In reality, this code sample tests if the secret number is equal to the value
    stored in the contract, not the user's guess. Since *`secretNumber`* is less than
    or equal to 10, a contract with a value of at least 11 Ether will be unwinnable.
    The actual code passes *`n`* as the first argument to the `checkAndTransferPrize`
    function and *`p`* as the second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个代码示例测试的是秘密数字是否等于合约中存储的值，而不是用户的猜测。由于*`secretNumber`* 小于或等于 10，所以拥有至少 11
    个以太币价值的合约将无法赢得。实际代码将 *`n`* 作为 `checkAndTransferPrize` 函数的第一个参数，将 *`p`* 作为第二个参数。
- en: However, the use of right-to-left and left-to-right characters make it appear
    that these arguments are reversed. As a result, a code review provides an inaccurate
    understanding of the contract's function, which could trick people into wasting
    money playing an unwinnable game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用从右至左和从左至右的字符使得这些参数看起来被颠倒了。结果，代码审查提供了对合约功能的错误理解，这可能会诱使人们浪费钱玩一个无法赢得的游戏。
- en: '###### *Countermeasures*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: The use of right-to-left and left-to-right control characters for deception
    is only effective because these characters are non-printable. As long as the resulting
    source code looks right in a text editor, there is no reason to suspect this attack.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 利用从右至左和从左至右的控制字符进行欺骗之所以有效，仅仅是因为这些字符是不可打印的。只要在文本编辑器中源代码看起来是正确的，就没有理由怀疑这种攻击。
- en: 'While right-to-left and left-to-right control characters are unprintable, they
    still exist in the source code of the contract. Scanning for these characters
    can help to detect this attempted deception.  ##### Unsafe Serialization'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管从右至左和从左至右的控制字符是不可打印的，但它们仍然存在于智能合约的源代码中。扫描这些字符可以帮助检测这种试图的欺骗。  ##### 不安全的序列化'
- en: Serialization enables data structures to be converted into a string of bits
    for transmission or storage. At the other end, the recipient unpacks this sequence
    of bits based on knowledge of the underlying structure. Smart contracts can implement
    serialization using functions like Ethereum's `abi.encodePacked`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化使得数据结构可以转换成用于传输或存储的二进制字符串。在另一端，接收者根据对底层结构的了解，解包这些二进制序列。智能合约可以使用如以太坊的 `abi.encodePacked`
    函数来实现序列化。
- en: If a smart contract does not properly validate serialized data, attackers can
    exploit serialization with deliberately malformed data. One example of this is
    Smart Contract Weakness Classification (SWC) 133, which addresses hash collisions
    caused by data serialization with variable-length arguments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果智能合约没有正确验证序列化数据，攻击者可以利用故意构造的序列化数据来利用序列化。的一个例子是智能合约弱点分类（SWC）133，它解决了由带有可变长度参数的数据序列化引起的哈希冲突。
- en: Ethereum's `abi.encodePacked` function can cause serialized data containing
    arrays to have multiple different interpretations. If packed data contains multiple,
    adjacent arrays, then values can be moved between these arrays without changing
    the final serialized value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的 `abi.encodePacked` 函数可能会导致包含数组的序列化数据有多种不同的解释。如果打包的数据包含多个相邻的数组，那么可以将值在这些数组之间移动，而不会改变最终的序列化值。
- en: If the same serialized data can be deserialized in multiple different ways,
    then a digital signature authenticating one version can be used to authenticate
    any of them. An attacker can use this to bypass authentication mechanisms or to
    perform malicious transactions on another account's behalf.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的序列化数据可以以多种不同的方式反序列化，那么对一个版本进行数字签名的认证可以用来认证它们中的任何一个。攻击者可以利用这一点来绕过认证机制，或者代表另一个账户执行恶意交易。
- en: Ethereum's short address vulnerability is another example of an unsafe deserialization
    vulnerability. This vulnerability is illustrated in the following code sample.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的短地址漏洞是另一个不安全反序列化的例子。这个漏洞在前面的代码示例中有所说明。
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ethereum serializes inputs to a function, which is unpacked by the called function.
    If one argument is too short, then it steals the missing byte(s) from the next
    argument. In the preceding code sample, an attacker can send a value of *`to`*
    that is deliberately one byte too short.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊序列化输入到函数中，被调用函数进行解包。如果一个参数太短，那么它会从下一个参数中窃取缺失的字节。在前面的代码示例中，攻击者可以发送一个故意短一个字节的
    *`to`* 值。
- en: The `sendCoin` function does not check the length of *`to`* and *`amount`*,
    so the comparison of *`balances`* and *`amount`* uses the correct value of *`amount`*.
    However, the `Transfer` function specifies the length of the arguments, so Ethereum
    right-pads *`amount`* with zeros, multiplying it by 256\. As a result, the value
    transferred is far higher than the amount approved in `sendCoin`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendCoin`函数没有检查*`to`*和*`amount`*的长度，所以*`balances`*和*`amount`*的比较使用了*`amount`*的正确值。然而，`Transfer`函数指定了参数的长度，因此以太坊将*`amount`*用零填充，将其乘以256。结果，转移的金额远远超过了在`sendCoin`中批准的金额。'
- en: '###### *Countermeasures*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: 'Serialization vulnerabilities are usually caused by serialization of variable-length
    data or a failure to validate data during the serialization process. The use of
    fixed-size data structures and validation that serialized data properly unpacks
    can help to mitigate this vulnerability.  ###### *Case Studies*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化漏洞通常是由变量长度数据的序列化或序列化过程中数据验证失败引起的。使用固定大小的数据结构并在序列化数据正确解包时进行验证可以帮助减轻此漏洞。#####
    *案例研究*
- en: In February 2022, the Superfluid protocol was the victim of a $13 million hack.
    The attacker took advantage of a serialization vulnerability in how the project
    tracked state within a transaction across different Superfluid agreements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年2月，超流体协议遭到了价值1300万美元的黑客攻击。攻击者利用了项目在跨不同的超流体协议中跟踪事务内状态的序列化漏洞。
- en: The *`ctx`* variable used for state tracking is intended to be initialized as
    an empty placeholder by the `callAgreement` function. The attacker included a
    malicious *`ctx`* in a call to `callAgreement`, which then added its placeholder
    to the serialized calldata sent to other agreements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用于状态跟踪的*`ctx`*变量旨在通过`callAgreement`函数初始化为一个空占位符。攻击者在对`callAgreement`的调用中包含了一个恶意的*`ctx`*，然后将其占位符添加到发送到其他协议的序列化calldata中。
- en: 'Since the malicious *`ctx`* preceded the placeholder one, the target agreements
    accepted it and ignored the placeholder value. Also, since the calldata came from
    a trusted contract, the agreement did not validate it. The malicious *`ctx`* included
    a forged transfer of tokens from another account to the attacker, which the agreement
    processed.  #### *Blockchain-Specific Vulnerabilities*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意的*`ctx`*在占位符之前，目标协议接受了它并忽略了占位符的值。此外，由于calldata来自一个可信的合约，协议没有验证它。恶意的*`ctx`*包含了一个从另一个账户到攻击者的伪造代币转账，该协议处理了它。####
    *区块链特定漏洞*
- en: Blockchain systems work very differently than traditional software environments.
    Instead of running on a computer, smart contract code executes on top of the blockchain.
    The instructions to be executed are embedded in transactions, which are broadcast
    to the network and organized into blocks before finally being added to the digital
    ledger and executed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链系统与传统的软件环境非常不同。智能合约代码不是在计算机上运行，而是运行在区块链之上。要执行的指令嵌入在交易中，这些交易广播到网络，组织成区块，最后添加到数字账本并执行。
- en: 'The unique design of the blockchain creates the potential for smart contract
    vulnerabilities. The following are examples of vulnerabilities that exist because
    smart contracts run on top of the blockchain:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的独特设计创造了智能合约漏洞的潜力。以下是因为智能合约在区块链之上运行而存在的漏洞示例：
- en: Access control
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Bad randomness
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏随机数
- en: Denial of service
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务否认
- en: Frontrunning
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前置交易
- en: Rollback attacks
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚攻击
- en: Time stamp dependence
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳依赖
- en: '##### Access Control'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 访问控制'
- en: Most smart contract platforms are implemented as open, public blockchains. Anyone
    can create an account on the blockchain, create transactions, and interact with
    smart contracts hosted on the blockchain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数智能合约平台都是以开放、公共区块链的形式实现的。任何人都可以在区块链上创建账户、创建交易，并与托管在区块链上的智能合约互动。
- en: However, not all functionality within a smart contract may be intended to be
    publicly accessible. As a result, smart contract platforms have the ability to
    restrict access to certain functions, variables, and so on to particular parties,
    such as the owner of a smart contract.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能合约中的所有功能可能都不打算公开访问。因此，智能合约平台有能力限制对特定功能的访问，例如智能合约的所有者。
- en: To restrict certain functionality to particular parties, a smart contract needs
    to define whom those parties are. Typically, this is done by specifying the address
    of certain blockchain accounts. While these addresses could be hardcoded into
    a smart contract, this is not best practice because these addresses may need to
    be updated when the contract is running.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将某些功能限制在特定的各方，智能合约需要定义这些各方是谁。通常，这是通过指定某些区块链账户的地址来完成的。尽管这些地址可以硬编码到智能合约中，但这并不是最佳实践，因为这些地址在合约运行时可能需要更新。
- en: Many smart contracts have an `initContract` or similar function that assigns
    ownership after the smart contract is deployed. The following code sample shows
    an example of an `initContract` function with an access control vulnerability.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 许多智能合约都有一个`initContract`或类似函数，在智能合约部署后分配所有权。以下代码样本展示了一个带有访问控制漏洞的`initContract`函数。
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function is designed to assign ownership of a smart contract to the address
    that calls the function. Other functions in this contract would then be labeled
    as only accessible to the contract owner.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数设计为将智能合约的所有权分配给调用函数的地址。此合约中的其他函数将被标记为仅可由合约所有者访问。
- en: This function is designed to be called when the contract is first launched;
    however, it lacks any restrictions that prevent it from being called multiple
    times. Instead of assigning ownership of the contract to the first account that
    calls `initContract`, the function assigns ownership to the account that called
    it most recently. This could allow an attacker to access privileged functions
    within the contract, potentially stealing value from it or using its permissions
    to bypass other access controls.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设计为在合约首次启动时调用；然而，它缺乏防止其被多次调用的任何限制。 instead of assigning ownership of the
    contract to the first account that calls `initContract`, the function assigns
    ownership to the account that called it most recently. This could allow an attacker
    to access privileged functions within the contract, potentially stealing value
    from it or using its permissions to bypass other access controls.
- en: '###### *Countermeasures*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: This function was vulnerable because it did not prevent multiple calls to it.
    The following code snippet fixes this issue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数存在漏洞，因为它没有阻止对其的多重调用。以下代码片段解决了这个问题。
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When this contract is launched, *`firstCall`* would be set to true, allowing
    the deployer to claim ownership of the contract. However, after *`firstCall`*
    is set to false during the first call to the function, all future calls would
    fail because the `require` statement would resolve to false.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个合约启动时，*`firstCall`*会被设置为true，允许部署者声称拥有该合约。然而，在函数的第一次调用后*`firstCall`*被设置为false，所有未来的调用都会失败，因为`require`语句会解析为false。
- en: This example is the simplest way in which smart contract access control mechanisms
    could fail. Before launching a smart contract, all access control mechanisms should
    be reviewed for potential vulnerabilities or bypasses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是智能合约访问控制机制可能失败的最简单方式。在部署智能合约之前，应审查所有访问控制机制，以识别潜在的漏洞或绕过方法。
- en: For example, consider a function designed to only be called from other functions
    within a smart contract like `privateFunction` in the following code sample.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个设计为仅能从智能合约中的其他函数调用的函数，如以下代码样本中的`privateFunction`。
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If a public function (like `forwarder`) within the contract makes it possible
    to call that function with user-controlled arguments, then the function is essentially
    public as well.  ###### *Case Studies*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '如果合约内的公共函数（如`forwarder`）允许使用用户控制的参数调用该函数，那么该函数本质上也是公开的。  ###### *案例研究*'
- en: 'The Poly Network hack is the biggest DeFi attack to date, with over $611 million
    in tokens stolen. The attacker exploited a chain of trust relationships between
    various functions within the smart contract move from a publicly accessible one
    to one with the ability to update the role of keeper within the smart contract.[⁶](#c05-note-0006)
    With the access provided by the keeper role, the attacker was able to drain the
    value stored within the Poly Network project.  ##### Bad Randomness'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '波场网络（Poly Network）的黑客攻击是迄今为止最大的去中心化金融（DeFi）攻击，窃取了超过6.11亿美元的代币。攻击者利用了智能合约内各个函数之间的信任关系链，从公开可访问的一个变为具有在智能合约内更新守护者角色能力的一对一关系。[⑥](#c05-note-0006)
    利用守护者角色提供的访问权限，攻击者能够提取波场网络项目内储存的值。  ##### 不良随机性'
- en: Random number generation is a common requirement of smart contracts. For example,
    many games implemented as smart contracts exist that need to generate random numbers
    to identify winners.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数是智能合约的常见需求。例如，许多作为智能合约实现的游戏需要生成随机数来确定获胜者。
- en: 'However, random number generation is difficult on the blockchain for a couple
    of reasons:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在区块链上生成随机数存在几个困难：
- en: '**Determinism:** For the “world computer” to work, every node in the network
    needs to be able to run the same code and get the same result. If each node independently
    generated pseudorandom numbers when running contract code, nodes would fall out
    of consensus regarding the state of the “world computer.”'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性：**为了让“世界计算机”工作，网络中的每个节点都需要能够运行相同的代码并获得相同的结果。如果每个节点独立地在执行合约代码时生成伪随机数，节点之间就会在“世界计算机”的状态上失去共识。'
- en: '**Public Ledger:** All transactions are publicly visible on the blockchain''s
    digital ledger, including those creating and calling smart contracts. As a result,
    nothing is private on the blockchain.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共账本：**所有交易都公开显示在区块链的数字账本上，包括创建和调用智能合约的交易。因此，区块链上没有隐私。'
- en: 'Smart contracts have used different methods of generating pseudorandom values,
    but many of these are insecure. Some of the most common approaches are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约已经使用了生成伪随机值的不同方法，但其中许多都是不安全的。一些最常见的方法如下：
- en: '**Secret Values:** Smart contract code may be deployed with a secret value
    used to seed a pseudorandom number generator (PRNG). However, since transactions
    are public on the blockchain, anyone can read the secret value and predict the
    sequence of pseudorandom values.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密值：**智能合约代码可能会部署一个秘密值，用于初始化伪随机数生成器（PRNG）。然而，由于区块链上的交易是公开的，任何人都可以读取这个秘密值并预测伪随机值序列。'
- en: '**Secret Code:** Instead of using a secret seed and a known PRNG, a smart contract
    developer may create their own function for generating pseudorandom numbers. However,
    since smart contract code is deployed within a transaction and publicly visible,
    this has the same issues as secret values.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密代码：**智能合约开发者不是使用一个秘密种子和一个已知的伪随机数生成器（PRNG），而是可能创建自己的生成伪随机数的函数。然而，由于智能合约代码是在一个交易中部署的，并且是公开可见的，所以这和秘密值有同样的问题。'
- en: '**Blockchain Metadata:** Some smart contracts try to use unpredictable blockchain
    metadata, such as the time stamp or hash value of a block. However, some of these
    values are manipulable by a block producer, and all are also accessible to other
    smart contracts as well.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链元数据：**一些智能合约试图使用不可预测的区块链元数据，例如区块的时间戳或哈希值。然而，这些值中有些可以被区块生产者操纵，而且所有这些值也都可被其他智能合约访问。'
- en: The following code sample includes weak random number generation.[⁷](#c05-note-0007)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例包含弱的随机数生成方法。[⁷](#c05-note-0007)
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this function, the source of randomness is the hash of a particular block.
    While the value of *`blockNumber`* is not shown, no option provides a strong random
    number:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，随机性的来源是特定区块的哈希值。虽然*`blockNumber`*的值没有显示，但没有一种选项能提供强随机数：
- en: '**Current Block:** The hash of the current and any future blocks is unknown,
    so the value defaults to 0\. This means that a value of *`blockNumber`* pointing
    to the current block would always result in a win.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前区块：**当前区块和未来任何区块的哈希值是未知的，所以默认值为0。这意味着指向当前区块的*`blockNumber`*的值总是会导致获胜。'
- en: '**Over 256 Blocks Ago:** Solidity only stores the hashes of the previous 256
    blocks, and requests for older blocks produce a value of 0\. As a result, a *`blockNumber`*
    more than 256 blocks ago would be an automatic win.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过256个区块之前：**Solidity只存储前256个区块的哈希值，并且对更早区块的请求会产生0的值。因此，一个*`blockNumber`*
    超过256个区块之前将自动获胜。'
- en: '**Recent Blocks:** For any of the last 256 blocks, another smart contract could
    access the block hash and test if it is a winner. If so, it could call the `play`
    function only when guaranteed to win.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近的区块：**对于过去任意256个区块中的任意一个，另一个智能合约都可以访问该区块的哈希值，并测试它是否为获胜者。如果是，它只能在确保获胜的情况下调用`play`函数。'
- en: '###### *Countermeasures*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: Any information within the blockchain ecosystem that is available to one smart
    contract is likely available to another. The only way to generate a secret random
    value is to do so from outside the blockchain ecosystem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 任何区块链生态系统中的信息，一旦被一个智能合约所获取，也很可能被另一个智能合约所获取。生成一个秘密随机值的唯一方法是从区块链生态系统外部进行生成。
- en: 'Smart contracts should use an external oracle to provide randomly generated
    values. Since every node in the network would see the same value from the oracle,
    this enables determinism without using values accessible to other, malicious smart
    contracts.  ###### *Case Studies*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约应使用外部预言机提供随机生成的值。由于网络中的每个节点都会从预言机看到相同的值，这使得在不使用其他恶意智能合约可访问的值的情况下实现确定性成为可能。######
    *案例研究*
- en: The SmartBillions lottery was a betting game hosted on the Ethereum blockchain.
    Players could choose six lucky numbers and then call the `won` function to play.
    If their lucky numbers matched a random number when they called `won`, then they
    could earn increasing rewards.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SmartBillions 彩票是一个在以太坊区块链上举办的博彩游戏。玩家可以选择六个幸运数字，然后调用 `won` 函数来参与游戏。如果他们在调用 `won`
    时他们的幸运数字与一个随机数字相匹配，那么他们可以获得递增的奖励。
- en: 'SmartBillions''s random number was based on the hash of an earlier block, which
    is only accessible for the previous 256 blocks in Solidity. The attacker guessed
    lucky numbers of zero and called `won` 256 blocks after the target block, guaranteeing
    that their guess would be correct.[⁸](#c05-note-0008) They were able to win 400
    ETH from the game before the creators used a backdoor to drain the remaining 1,100
    ETH from the contract.  ##### Denial of Service'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 'SmartBillions 的随机数字基于之前块的哈希，在 Solidity 中只能访问到之前的 256 个块。攻击者猜测幸运数字为零，并在目标区块后的
    256 个块调用 `won`，确保他们的猜测是正确的。[⁸](#c05-note-0008) 他们能够在游戏 creators 使用后门从合约中提取剩余的
    1,100 ETH 之前从游戏中赢得 400 ETH。  ##### 服务拒绝'
- en: Blockchain systems are designed to be distributed and decentralized. No node
    in the network is essential, which means that the blockchain system lacks permanent
    single points of failure. In theory, this should provide strong protection against
    denial-of-service (DoS) attacks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链系统被设计为分布式和去中心化的。网络中的任何节点都不是必需的，这意味着区块链系统缺乏永久性的单点故障。从理论上讲，这应该为抵御拒绝服务（DoS）攻击提供强有力的保护。
- en: 'In practice, blockchain systems and the smart contracts that run on them are
    vulnerable to DoS attacks in various different ways, including the following examples:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，区块链系统和运行在其上的智能合约容易遭受各种不同的拒绝服务（DoS）攻击，包括以下例子：
- en: '**DDoS against Transaction Creator:** For a transaction to execute a smart
    contract, it needs to be broadcast to the blockchain network by its creator. If
    a DDoS attack renders the creator of a transaction unable to publish it, then
    it will not be added to the ledger.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对交易创建者的 DDoS 攻击：** 为了执行智能合约，交易需要由其创建者广播到区块链网络。如果 DDoS 攻击使交易创建者无法发布它，那么它将不会被添加到账本中。'
- en: '**DDoS against Block Producer:** Transactions are only added to the ledger
    and executed as part of blocks. If a block producer cannot create a block, then
    transactions are delayed from being added to the ledger.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对区块创建者的 DDoS 攻击：** 交易仅作为区块的一部分添加到账本并执行。如果一个区块创建者无法创建一个区块，那么交易将被延迟添加到账本中。'
- en: '**Transaction Flooding DDoS:** Blockchains create blocks with a fixed maximum
    size at regular intervals, which means they have a maximum throughput. If a blockchain
    is flooded with spam transactions, then legitimate transactions may not be able
    to get through and be added to the digital ledger.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易洪水 DDoS：** 区块链以固定最大尺寸定期创建区块，这意味着它们有最大吞吐量。如果区块链被垃圾交易淹没，那么合法交易可能无法通过并添加到数字账本中。'
- en: '**Eclipse/Routing Attacks:** Transactions and blocks are distributed via the
    blockchain''s peer-to-peer network. If these messages are intercepted and dropped
    by an attacker, then they may be delayed or prevented from being added to the
    digital ledger.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日食/路由攻击：** 交易和区块通过区块链的对等网络进行分发。如果这些消息被攻击者拦截并删除，那么它们可能会被延迟或阻止被添加到数字账本中。'
- en: '**Malicious Block Creators:** Block producers have full control over which
    transactions are included in the blocks they create. A block producer can choose
    not to include a transaction within a block, delaying it from being added to the
    digital ledger.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意区块创建者：** 区块生产者完全控制着他们创建的区块中应包含哪些交易。区块生产者可以选择不在一个区块中包含一个交易，从而延迟它被添加到数字账本中。'
- en: Once a transaction has been distributed to nodes, it should be included in a
    block eventually unless all block producers collude to prevent this. However,
    some smart contracts are time-dependent, so delaying a transaction calling them
    could have a significant impact on the result.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易被分发到节点，它最终应该被包含在一个区块中，除非所有区块生产者勾结阻止这种情况。然而，一些智能合约是时间依赖的，所以延迟调用它们的交易可能会对结果产生重大影响。
- en: '###### *Countermeasures*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 应对措施'
- en: Many of these attacks target the underlying infrastructure that the blockchain
    relies upon. Traditional DDoS attacks or attacks on the connectivity of the blockchain
    network are IT security problems that can be addressed with traditional solutions.
    However, the decentralization of the blockchain network might make it difficult
    to have these solutions universally adopted, such as having all block producers
    deploy DDoS protection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些攻击针对的是区块链依赖的基础设施。传统的 DDoS 攻击或针对区块链网络连接性的攻击是可以通过传统解决方案解决的 IT 安全问题。然而，区块链网络的去中心化可能会使得这些解决方案的普遍采用变得困难，比如让所有区块生产者部署
    DDoS 保护。
- en: 'Other DoS attacks exploit the design of the blockchain, such as transaction-flooding
    attacks and the potential for malicious block creators. Transaction flooding could
    be mitigated by block producers ignoring spam transactions, and in the absence
    of universal collusion by block producers, a legitimate transaction may be delayed
    but will eventually be included in a block.  ###### *Case Studies*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的拒绝服务攻击利用了区块链的设计，比如交易洪水攻击和恶意区块创建者的潜在可能性。交易洪水可以通过区块生产者忽略垃圾交易来缓解，而在区块生产者没有普遍勾结的情况下，合法交易可能会被延迟但最终会被包含在一个区块中。######
    案例研究
- en: 'Sia is a decentralized, blockchain-based storage system. In June 2021, a multiday
    DDoS attack against the network targeted a quarter of Sia network hosts and storage
    providers.[⁹](#c05-note-0009) While the attack was unable to impact file storage
    operations, it did interrupt 30 percent of host connections.[^(10)](#c05-note-0010)  #####
    Frontrunning'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '西雅图（Sia）是一个去中心化、基于区块链的存储系统。2021 年 6 月，针对该网络的多日 DDoS 攻击针对了 Sia 网络主机和存储提供商的四分之一。[⁹](#c05-note-0009)
    尽管这次攻击无法影响文件存储操作，但它确实中断了 30% 的主机连接。[^(10)](#c05-note-0010)  ##### 前锋攻击'
- en: Transactions are not immediately added to the blockchain's digital ledger. After
    a transaction is created, it is broadcast to all blockchain nodes via the peer-to-peer
    network. Each node then stores the transactions to be included in a later block.
    Only when a transaction is included in a block is it executed and added to the
    digital ledger.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 交易不是立即添加到区块链的数字账本中。在创建交易后，它通过点对点网络广播给所有区块链节点。每个节点然后存储将要包含在稍后区块中的交易。只有当交易包含在一个区块中时，它才会被执行并添加到数字账本中。
- en: This design provides opportunities for an attacker to see a transaction and
    create one of their own based on it before the first transaction is processed.
    In fact, since transactions are typically added to blocks in order of their transaction
    fees, an attacker can create a transaction with a higher fee that is likely to
    be processed before the original one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计为攻击者提供了一个机会，可以看到一个交易并基于它创建自己的交易，在第一个交易被处理之前。实际上，由于交易通常是按照交易费用顺序添加到区块中的，攻击者可以创建一个费用更高的交易，这可能会在原交易之前被处理。
- en: This ordering of transactions based on fees is referred to as miner extractable
    value (MEV), and the ability to exploit it is the basis for frontrunning bots.
    [Figure 5.2](#c05-fig-0002) illustrates how these bots can take advantage of frontrunning
    vulnerabilities for profit.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基于费用对交易进行排序被称为矿工可提取价值（MEV），而利用它的能力是前锋机器人（frontrunning bots）的基础。图 5.2（[#c05-fig-0002](#c05-fig-0002)）展示了这些机器人如何利用前锋漏洞获利。
- en: '![Schematic illustration of frontrunning attack on a decentralized exchange.](images/c05f002.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![去中心化交易所前锋攻击的示意图](images/c05f002.png)'
- en: '[**Figure 5.2**](#R_c05-fig-0002): Frontrunning attack on a decentralized exchange'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#R_c05-fig-0002)：针对去中心化交易所的前锋攻击'
- en: 'A decentralized exchange (DEX) is a cryptocurrency exchange implemented as
    a smart contract. DEXs need to be able to calculate the exchange rate of various
    trading pairs. Often, they are implemented based on the laws of supply and demand:
    the more the DEX has of a particular asset, the lower its relative value.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化交易所（DEX）是作为智能合约实现的加密货币交易所。DEX 需要能够计算各种交易对的汇率。通常，它们是基于供求法则实现的：DEX 中某种资产越多，其相对价值就越低。
- en: In the top half of the image, Alice performs a trade with the DEX. Since the
    exchange rate is currently 1 ETH for 10 TKNs, sending 1 ETH to the contract returns
    10 TKNs. Since the DEX's supply of ETH grows relative to its supply of TKN, the
    relative value of ETH decreases compared to TKN.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片的上半部分，Alice与DEX进行交易。由于当前汇率为1 ETH兑换10 TKN，向合约发送1 ETH可返回10 TKN。由于DEX的ETH供应相对于TKN供应的增长，ETH相对于TKN的价值会降低。
- en: The bottom half of the image illustrates a frontrunning attack on this trade.
    While Alice still sends in 1 ETH, Bob observes the transaction and frontruns it
    with his own transaction. As a result, Bob makes a trade at the original exchange
    rate of 1 ETH:10 TKN, while Alice's trade is made at the reduced exchange rate
    of 1 ETH:9 TKN.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的下半部分说明了这笔交易的 前冲攻击。尽管Alice仍然发送了1 ETH，但Bob观察到交易并用自己的交易进行前冲。结果，Bob以原始汇率1 ETH:10
    TKN进行交易，而Alice的交易是在降低的汇率1 ETH:9 TKN进行的。
- en: After Alice's trade is complete, Bob makes another trade, exchanging his 10
    TKN for ETH. Since the two previous trades increased the value of TKN relative
    to ETH, Bob gets 1.25 ETH in return. As a result, he makes a net profit of 0.25
    ETH, minus the fees for his two transactions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Alice的交易完成后，Bob进行另一笔交易，用他的10 TKN换取ETH。由于前两笔交易增加了TKN相对于ETH的价值，Bob得到了1.25 ETH的回报。因此，他的净收益为0.25
    ETH，减去他两次交易的费用。
- en: This is one example of how frontrunning can be used to benefit an attacker.
    A frontrunner may also be able to win contests based on a first-come-first-served
    model.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前冲如何被用来造福攻击者的一个例子。前冲者也可能能够基于先到先得模型赢得比赛。
- en: '###### *Countermeasures*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '####应对措施'
- en: Frontrunning attacks take advantage of the design of the blockchain, where block
    producers have full control over how transactions are organized into blocks. A
    block producer is expected to organize transactions based on associated fees but
    may also choose to prioritize certain transactions, enabling them to frontrun
    transactions without fees.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前冲攻击利用了区块链的设计，其中区块生产者完全控制着如何将交易组织到区块中。区块生产者应基于相关费用组织交易，但也可能选择优先处理某些交易，使它们能够无需费用地进行前冲交易。
- en: 'Smart contracts can be designed to minimize the risk or benefit of frontrunning.
    For example, a contract could randomly pick a winner from the first *`X`* submissions
    rather than operating on a first-come-first-served model. While an attacker could
    create many frontrunning transactions to defeat this system, it is more expensive,
    potentially making it unprofitable.  ###### *Case Studies*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以被设计成最小化前冲的风险或收益。例如，合约可以随机从第一个*`X`*个提交中选择一个胜者，而不是采用先到先得的方式。尽管攻击者可以创建许多前冲交易来击败这个系统，但这样做更昂贵，可能使其无利可图。#####案例研究
- en: The DODO DEX and Punk Protocol are DeFi projects that were targeted by attacks
    in 2021\. While these attacks did not involve frontunning, the attackers' transactions
    were frontrun by automated bots. By copying the attacker's transaction and paying
    a higher transaction fee, these bots exploited the vulnerable contracts before
    the attacker did, draining some of the targeted funds.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: DODO DEX和Punk Protocol是2021年遭到攻击的DeFi项目。尽管这些攻击没有涉及前冲，但攻击者的交易被自动化机器人前冲了。通过复制攻击者的交易并支付更高的交易费，这些机器人利用了脆弱的合约，在攻击者之前提取了部分目标资金。
- en: 'In both cases, the owners of the frontrunning bots were able to limit the impact
    of the attack. The Punk Protocol bot operator returned $5 million worth of tokens,[^(11)](#c05-note-0011)
    while the DODO DEX bot operator returned $1.88 million in tokens.[^(12)](#c05-note-0012)  #####
    Rollback Attacks'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两起案例中，前冲机器人（frontrunning bots）的所有者都能够限制攻击的影响。Punk Protocol机器人的操作者返回了价值500万美元的代币,[^(11)](#c05-note-0011)而DODO
    DEX机器人的操作者返回了价值188万美元的代币。[^(12)](#c05-note-0012)#####回滚攻击
- en: Most smart contract platforms take an all-or-nothing approach to transactions
    by default. If any part of a transaction fails, then the entire transaction is
    rolled back.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数智能合约平台默认对交易采取全或无的方法。如果交易的任何部分失败，那么整个交易将被回滚。
- en: An attacker can take advantage of this when interacting with a smart contract
    like a blockchain-based game. A smart contract can call the game contract, and
    if it doesn't like the result, it could revert the transaction. This would mean
    that the attacker only plays if they will win anyway.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以在与基于区块链的游戏的智能合约互动时利用这一点。智能合约可以调用游戏合约，如果它不喜欢结果，可以撤销交易。这意味着攻击者只有在肯定会赢的情况下才会参与游戏。
- en: '###### *Countermeasures*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '####应对措施'
- en: 'Rollback attacks have the greatest impact if a rolled-back transaction triggers
    another transaction that goes through. Whenever possible, smart contracts should
    only initiate new transactions after verifying that transactions triggering them
    executed successfully.  ###### *Case Studies*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '回滚攻击如果触发了另一个Transaction，其影响将是非常大的。尽可能地，智能合约应该在验证触发它们的Transaction成功执行后才发起新的Transaction。  ######
    *案例研究*'
- en: In December 2018, Betdice, EOSMax, Tobet, and other EOS-based gambling apps
    were the victims of a rollback attack.[^(13)](#c05-note-0013) The attacker performed
    transactions from an address blacklisted by the block producer, which meant that
    it would never be accepted and included within a block.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年12月，Betdice、EOSMax、Tobet 等基于 EOS 的赌博应用遭受了回滚攻击。[^(13)](#c05-note-0013) 攻击者从区块生产者黑名单中的地址执行交易，这意味着它永远不会被接受并包含在区块中。
- en: 'However, servers associated with the gambling apps saw and processed the transaction
    and determined that it would win the game. They then initiated transactions sending
    a reward to the player. As a result, the attacker''s initial betting transactions
    were not recorded on the blockchain, but the reveal transactions containing their
    reward were.  ##### Time Stamp Dependence'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，与赌博应用相关的服务器看到了并处理了这笔交易，并确定它会赢得比赛。然后，它们发起交易，将奖励发送给玩家。因此，攻击者的初始投注交易没有记录在区块链上，但包含他们奖励的揭示交易却有记录。  #####
    时间戳依赖性'
- en: Some smart contracts may be designed to take action at a certain point in time.
    For example, a contest may open at midnight January 1, so submissions before that
    time would be rejected while ones after would be accepted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一些智能合约可能被设计为在特定时间点采取行动。例如，一个比赛可能在1月1日零点开始，所以在这个时间之前提交的将被拒绝，而之后的将被接受。
- en: Smart contracts rely on time stamps within the block header for the current
    time. However, this is not a reliable clock. Block header time stamps are under
    the control of the block producer and have a high degree of flexibility. For example,
    the Ethereum Virtual Machine (EVM) only requires that each block have a time stamp
    greater than that of the previous block. While nodes may reject blocks with time
    stamps too far into the future, there is no formal definition for a valid time
    stamp.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约依赖于区块头中的时间戳来获取当前时间。然而，这并不是一个可靠的时钟。区块头时间戳受区块生产者的控制，并具有很高的灵活性。例如，以太坊虚拟机（EVM）只要求每个区块的时间戳要大于前一个区块的。尽管节点可能会拒绝时间戳过于靠后的区块，但有效时间戳没有正式的定义。
- en: This creates the potential for a block creator to manipulate time stamps for
    their own benefit. For example, the following code snippet has time-stamp-dependent
    functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了区块创建者为了自身利益而操纵时间戳的潜在风险。例如，以下代码片段具有时间戳依赖性功能。
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code implements a contest where the first player after time stamp 1521763200
    wins 1,500 ETH. A node creating a block shortly before this time could cheat by
    setting the block time stamp to 1521763201 and including a transaction in the
    block where they called the `play` function and claimed the reward. As long as
    their block is accepted by the network, they can win the contest before other
    users start playing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现了一个比赛，时间戳1521763200之后的第一个玩家将赢得1,500 ETH。一个在这次之前不久创建区块的节点可以通过将区块时间戳设置为1521763201并在区块中包含一个调用`play`函数的交易来作弊，从而声称奖励。只要他们的区块被网络接受，他们就可以在其他用户开始玩游戏之前赢得比赛。
- en: '###### *Countermeasures*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *对策*'
- en: Time-stamp-dependence vulnerabilities exist because time stamps are under the
    control of the block producer. While some blockchains have constraints on acceptable
    time stamp values in block headers, these constraints are often flexible to account
    for unsynchronized clocks and the latency of blocks traveling over the peer-to-peer
    network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳依赖性漏洞存在是因为时间戳受区块生产者的控制。尽管一些区块链对区块头中可接受的时间戳值有所限制，但这些限制往往是灵活的，以考虑到不同步的时钟和区块在点对点网络中传播的延迟。
- en: 'A better approach to implementing time-dependent functions is the use of block
    heights rather than block time stamps. These values are not under the control
    of a block producer and provide a reasonable approximation of the current time.
    For example, while Bitcoin''s blocks aren''t created at exactly 10-minute intervals,
    they are close enough that a certain block height should be reached within a certain
    window.  ###### *Case Studies*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '实现时间依赖函数的更好方法是使用块高而不是块时间戳。这些值不受块生产者的控制，能够合理地近似当前时间。例如，尽管比特币的区块并非精确地在10分钟间隔内创建，但它们足够接近，以至于在一定时间内应该达到某个块高。  ######
    *案例研究*'
- en: GovernMental was a Ponzi scheme smart contract that ran on the Ethereum blockchain.
    The rules of the game were that, if no one performed a transaction to the contract
    within 12 hours, the previous player would be awarded the jackpot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: GovernMental 是一个在以太坊区块链上运行的庞氏骗局智能合约。游戏的规则是，如果在12小时内没有人对合约进行交易，前一个玩家将获得奖金。
- en: 'This smart contract could be exploited by an attacker who produced a block
    close to the expiration of the 12-hour window.[^(14)](#c05-note-0014) By forging
    the time stamp in the block header, the malicious block producer could force the
    contract to pay out early, before the 12 hours were complete.  #### *Platform-Specific
    Vulnerabilities*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '这个智能合约可能会被一个在12小时窗口到期前创建区块的攻击者利用。[^(14)](#c05-note-0014) 通过在区块头中伪造时间戳，恶意块生产者可以迫使合约提前支付，在12小时完成之前。  ####
    *平台特定漏洞*'
- en: Smart contract platforms are an extension of the original blockchain protocol.
    Bitcoin does not support smart contracts, and different smart contract platforms
    have implemented this functionality in different ways. Smart contract platforms
    may use existing programming languages and virtual machines or may have created
    their own.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约平台是原始区块链协议的扩展。比特币不支持智能合约，不同的智能合约平台以不同的方式实现了这一功能。智能合约平台可能使用现有的编程语言和虚拟机，也可能创建自己的。
- en: As a result, different smart contract platforms are prone to different vulnerabilities.
    Ethereum and EOSIO are two of the oldest and most used smart contract platforms,
    which means that they have had the most opportunity for these platform-specific
    vulnerabilities to be discovered.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不同的智能合约平台容易受到不同类型的漏洞攻击。以太坊和EOSIO是两个最古老且最常用的智能合约平台，这意味着它们有最多的机会发现这些平台特定漏洞。
- en: '##### Ethereum'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 以太坊'
- en: 'Ethereum is the oldest smart contract platform, launching July 30, 2015\. The
    age and widespread adoption of this platform provided ample opportunity to identify
    potential vulnerabilities on the platform. The following list includes some examples
    of vulnerabilities specific to the Ethereum smart contract platform:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是最早的智能合约平台，于2015年7月30日启动。这个平台的年龄和广泛采用为识别平台上的潜在漏洞提供了充足的机会。以下是一些特定于以太坊智能合约平台的漏洞示例：
- en: 'Denial of service: block gas limit'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务拒绝：块气体限制
- en: 'Denial of service: unexpected reversion'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务拒绝：意外反转
- en: Forced send of ether
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制发送以太币
- en: Missing zero address checks
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失零地址检查
- en: Reentrancy
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重入
- en: Token standards compatibility
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代币标准兼容性
- en: Unchecked return values
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未检查的返回值
- en: Unsafe external call
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的外部调用
- en: '###### *Denial of Service: Block Gas Limit*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *服务拒绝：块气体限制*'
- en: Ethereum uses the concept of gas to fight spam and compensate nodes for their
    efforts. Gas is a fraction of an Ether, and each instruction in the EVM has an
    associated gas cost.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用气体的概念来对抗垃圾邮件并补偿节点的努力。气体是以太币的一部分，EVM中的每个指令都有相应的气体成本。
- en: When creating a transaction that runs a smart contract, an account will include
    some gas with it. If that gas runs out before the transactions completes, it is
    reverted.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建运行智能合约的交易时，账户会包含一些气体。如果在那之前气体耗尽，交易将会被撤销。
- en: Ethereum also has a block gas limit, which caps the amount of gas that can be
    used within a block. While this has its benefits, it also creates the potential
    for DoS attacks. If a smart contract function requires more gas than can be included
    in a block, then it cannot be executed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊也有块气体限制，它限制了区块内可以使用的气体量。虽然这有其优点，但也创造了DoS攻击的潜在可能。如果一个智能合约功能需要的气体量超过了一个区块的容量，那么它就不能被执行。
- en: The following code snippet shows an example of a function with a DoS vulnerability
    caused by block gas limits.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个由于块气体限制而导致的DoS漏洞的函数示例。
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function contains a loop whose number of iterations is determined by the
    user. The loop runs through some operations based on previous inputs and then
    assigns the value of *`_largestWinner`*, an argument to the function, to *`largestWinner`*,
    which determines the loop's termination condition. Inside the loop is heavy code
    that consumes a significant amount of gas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包含一个由用户确定的循环次数的循环。循环基于之前的输入执行一些操作，然后将函数的参数*`_largestWinner`*的值分配给*`largestWinner`*，这决定了循环的终止条件。循环内部是消耗大量燃料的重代码。
- en: This function will be rendered unusable as soon as the value of *`largestWinner`*
    grows large enough that execution of the loop meets or exceeds the block gas limit.
    This could happen intentionally as part of an attack or as part of legitimate
    usage since the value of *`largestWinner`* presumably grows as more users play
    the game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*`largestWinner`*的值足够大，使得循环的执行遇到或超过区块燃料限制，这个函数将变得无法使用。这可能是攻击的一部分，也可能是合法使用的一部分，因为随着更多用户参与游戏，*`largestWinner`*的值会增长。
- en: Whoever triggers this Out of Gas exception will presumably win the game, as
    no new player would be able to run the `selectNextWinners` function to replace
    them. As a result, an attacker has incentive to choose a large value of *`largestWinner`*
    to render it unrunnable in the future.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 触发此Out of Gas异常的人预计将赢得游戏，因为没有任何新玩家能够运行`selectNextWinners`函数来取代他们。因此，攻击者有动机选择一个大的*`largestWinner`*值，使其在未来无法运行。
- en: '***Countermeasures***     Block gas limit vulnerabilities generally exist in
    code that has unbounded loops or recursion. In the preceding example, the number
    of loop iterations was under the control of the smart contract''s users. As a
    result, the function could be placed in a state where it would be impossible to
    run within the block gas limit.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策**：区块燃料限制漏洞通常存在于具有无限循环或递归的代码中。在前面的例子中，循环的迭代次数受到智能合约用户的控制。因此，函数可能会处于无法在区块燃料限制内运行的状态。'
- en: To avoid this issue, Ethereum smart contracts should avoid unbounded loops or
    recursion. It is also a good idea to modularize code wherever possible to minimize
    the amount of gas used by any function. If a sequence of actions can be broken
    up across multiple transactions, this reduces the probability of hitting the block
    gas limit.  ***Case Study***     The GovernMental contract mentioned in the Timestamp
    Dependence case study also included DoS vulnerabilities due to Ethereum's block
    gas limits. The process that allowed a player to claim the reward also included
    some cleanup code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免这个问题，以太坊智能合约应避免无限循环或递归。尽可能模块化代码也是一个好主意，以最小化任何函数使用的燃料。如果可以将一系列操作分解为多个交易，这将降低遇到区块燃料限制的概率。  ***案例研究***
        在时间戳依赖性案例研究中提到的GovernMental合约也由于以太坊的区块燃料限制而包含服务拒绝漏洞。允许玩家领取奖励的过程还包括一些清理代码。
- en: 'This included two arrays that tracked the state of the contract. Once the array
    of participants grew past a certain point, attempting to clear it would exceed
    the block gas limit. As a result, it would be impossible for a player to win the
    game and claim the reward.[^(15)](#c05-note-0015)  ###### *Denial of Service:
    Unexpected Reversion*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '这包括两个跟踪合约状态的数组。一旦参与者数组超过某个点，尝试清除它将超过区块燃料限制。因此，玩家将无法赢得游戏并领取奖励。[^(15)](#c05-note-0015)  ######
    *服务拒绝：意外的回滚*'
- en: In Ethereum, a smart contract account is nearly identical to a normal user account.
    The only difference is that a smart contract account has code associated with
    it that can be executed by another account.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，智能合约账户与普通用户账户几乎完全相同。唯一的区别是智能合约账户关联了可以被其他账户执行的代码。
- en: As a result, smart contracts have the ability to send, receive, and store value.
    This is essential to smart-contract-based games and DeFi smart contracts that
    allow users to deposit and withdraw value within a contract.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，智能合约具有发送、接收和存储价值的能力。这对于基于智能合约的游戏和允许用户在合约内存入和提取价值的DeFi智能合约至关重要。
- en: One vulnerability associated with value transfers in smart contracts is the
    potential for a transfer of value to be unexpectedly reverted. If a smart contract
    sends value to another smart contract, the recipient contract's fallback function
    will be run, allowing it to execute some code. That fallback function could be
    designed to revert any transactions to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与智能合约中的价值转账相关的一个漏洞是价值转账可能意外回滚。如果智能合约向另一个智能合约发送价值，接收合约的回退函数将被执行，允许它执行一些代码。这个回退函数可以被设计为回滚其所有的交易。
- en: If a smart contract assumes that all transfers will succeed, this can cause
    a DoS vulnerability within the contract. The following code sample contains an
    example of this vulnerability.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果智能合约假设所有转账都会成功，这可能会在合约内造成DoS（拒绝服务）漏洞。以下代码示例包含这种漏洞的一个例子。
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code sample is from the King of the Ether smart contract,[^(16)](#c05-note-0016)
    which names a monarch and then allows other players to pay to claim the title.
    When this occurs, the previous monarch receives the payment made by their successor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码来自于“以太坊之王”智能合约[^(16)](#c05-note-0016)，该合约命名一位君主，然后允许其他玩家支付以宣称头衔。当这种情况发生时，前任君主会收到继任者的付款。
- en: In this function, the `require(currentLeader.send(highestBid))` command creates
    a DoS vulnerability due to the potential for reverted transactions. If the current
    monarch reverts any transfers to them, then this code will fail.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`require(currentLeader.send(highestBid))`命令由于回滚交易的潜在可能性创建了一个DoS漏洞。如果当前君主撤销任何向他们转帐的交易，这段代码将会失败。
- en: The intention here was to ensure that the previous monarch always got their
    payment before they were unseated. However, this code allows a monarch who reverts
    payments to them to cause any attempt to unseat them to fail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的意图是确保前任君主在被废黜之前总能收到他们的付款。然而，这段代码允许一个回滚他们付款的君主使得任何试图废黜他们的尝试失败。
- en: '***Countermeasures***     This function was vulnerable to DoS attacks because
    it assumed that all transactions would succeed. Solidity includes a try-catch
    structure that can be used to handle reversion in external calls, enabling a contract
    to detect and respond to failed transfers.  ###### *Forced Send of Ether*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    这个函数因为假设所有交易都会成功而容易受到DoS攻击。Solidity包含了try-catch结构，可以用来在外部调用中处理回滚，使合约能够检测并响应失败的转账。######
    *强制发送以太币*'
- en: As mentioned previously, unexpected reversion within a fallback function can
    cause a DoS vulnerability within the calling contract. Forced send of Ether vulnerabilities
    look at the other side of this and what happens if a contract with a reverting
    fallback function is forced to receive Ether.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，回退函数内的意外回滚可能会在调用合约中造成DoS漏洞。强制发送以太币漏洞则从另一个角度看待这个问题，探讨如果一个具有回滚回退函数的合约被迫接收以太币会发生什么。
- en: The following code snippet shows an example of an Ethereum smart contract that
    attempts to revert all transfers of value.[^(17)](#c05-note-0017)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了一个试图回滚所有价值转账的以太坊智能合约的例子。[^(17)](#c05-note-0017)
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In Ethereum, fallback functions are labeled by the keyword `payable`. In this
    contract, all attempted payments are automatically reverted. The reason is that,
    in the `somethingBad` function, some undesirable event occurs if the contract
    ever holds a nonzero value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，回退函数通过关键字`payable`来标识。在这个合约中，所有尝试的付款都会自动回滚。原因是，在`somethingBad`函数中，如果合约持有非零价值时会发生一些不希望的事件。
- en: 'This contract effectively protects itself against normal transfers of value,
    such as the use of send in the unexpected reversion example. However, there are
    a few ways in which an attacker can bypass this, sending Ether to the contract
    without triggering the fallback function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个合约有效地保护自己免受正常价值转账的攻击，例如在意外回滚示例中使用`send`。然而，攻击者有几种方法可以绕过这一点，向合约发送以太币而不触发回退函数：
- en: '**Prefunding:** Smart contract accounts are like any other account on Ethereum,
    meaning they can receive transfers before smart contract code is deployed to them.
    If an attacker can predict the deployment address of a smart contract, then they
    can transfer Ether to it before the contract is deployed and the fallback function
    exists.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预部署资金：**智能合约账户与以太坊上的任何其他账户一样，意味着它们在智能合约代码部署之前就能接收转账。如果攻击者能够预测智能合约的部署地址，那么他们可以在合约部署之前和回退函数存在时向其转账以太币。'
- en: '**Mining/Staking:** Participating in consensus can result in block rewards.
    An attacker can indicate that a smart contract account is the intended recipient
    of a block reward, which does not trigger the fallback function.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挖矿/质押**：参与共识可能会获得区块奖励。攻击者可以指出智能合约账户是区块奖励的预期接收者，这不会触发回退函数。'
- en: '**Self-Destruct:** A self-destructing smart contract can specify another contract
    as the recipient of any Ether held at that address. Transfers triggered by self-destruct
    do not trigger the recipient''s fallback function.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自毁**：一个自毁的智能合约可以指定另一个合约作为该地址持有的以太币的接收者。由自毁触发的转账不会触发接收者的回退函数。'
- en: Using one of these methods, an attacker can force Ether into the target smart
    contract. In this case, a future call to `somethingBad` would pass the `require`
    statement, allowing the bad functionality to execute.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法之一，攻击者可以将以太币强制转入目标智能合约。在这种情况下，对`somethingBad`的后续调用会通过`require`语句，允许执行不良功能。
- en: '***Countermeasures***     Forcing Ether into a smart contract is usually only
    a problem if the contract performs strict value comparisons. For example, the
    command `if (value == 5)` is problematic if an attacker forces 6 ETH into the
    contract.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策**：如果智能合约执行严格的价值比较，将以太币强制转入智能合约通常只会成为一个问题。例如，命令`if (value == 5)`如果攻击者将6个以太币强制转入合约，那么就会成为问题。'
- en: Instead of using strict value comparisons, contracts should use greater than
    or equal to or less than or equal to. This way, any unexpected Ether does not
    break the contract's functionality.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: instead of using strict value comparisons, contracts should use greater than
    or equal to or less than or equal to. This way, any unexpected Ether does not
    break the contract's functionality.
- en: For code where strict tracking is necessary, such as the previous toy example,
    value should be tracked internally rather than via *`this.balance`*. The following
    code sample shows an example of this.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要严格跟踪的代码，例如之前的玩具示例，应该内部跟踪价值，而不是通过*`this.balance`*。以下代码示例展示了这种方法的示例。
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, only value transfers that pass through the fallback function
    will affect the value of *`balance`*. As a result, forced sends of Ether will
    not trigger the `somethingBad` function.  ***Case Studies***     The Edgeware
    project allowed users to lock ETH in 3 to 12 months in exchange for a reward.
    When a user created a lockdrop, the main Lockdrop contract created a new contract
    that held their ETH and implemented the lock functionality. These contracts were
    vulnerable to forced send of Ether because they asserted at creation that the
    value of the contract was strictly equal to the amount of ETH sent in by the user.[^(18)](#c05-note-0018)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有通过回退函数的转账会影响*`balance`*的值。因此，以太币的强制转账不会触发`somethingBad`函数。**案例研究**：Edgeware项目允许用户在3到12个月内锁定以太币以换取奖励。当用户创建一个锁仓时，主锁仓合约会创建一个新合约来持有他们的以太币并实现锁功能。这些合约由于在创建时断言合约的价值严格等于用户发送的以太币金额，因此容易受到以太币的强制转账攻击。[^(18)](#c05-note-0018)
- en: 'The Lockdrop contract used a deterministic algorithm to determine the address
    of the next contract. Since the address of the new contract was predictable, an
    attacker who prefunded the address with ETH could cause the creation of the lock
    contract to fail. Also, since the Lockdrop contract would keep trying to use the
    same address until it succeeded, locking the next address would cause it to fail
    forever.  ###### *Missing Zero Address Checks*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '锁仓合约使用确定性算法来确定下一个合约的地址。由于新合约的地址是可以预测的，因此如果攻击者预先用以太币资助这个地址，可能会导致锁仓合约的创建失败。另外，由于锁仓合约会一直尝试使用同一个地址直到成功，锁定下一个地址会导致它永远失败。  ######
    *缺失零地址检查*'
- en: The genesis, or zero, address (`0x0`) is used for burning tokens in Ethereum.
    Since the private key for this address is unknown and likely never to be discovered,
    tokens sent to this address cannot be recovered.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创世地址，或零地址（`0x0`），在以太坊中用于销毁代币。由于这个地址的私钥是未知的，且很可能永远无法被发现，发送到这个地址的代币无法恢复。
- en: When working with addresses, it is important to ensure that an address is not
    the zero address. Transfers of tokens or ownership of a contract to the zero address
    cannot be reversed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理地址时，确保一个地址不是零地址非常重要。将代币或合约的所有权转让给零地址无法撤销。
- en: Smart contracts can also have errors if they assume that smart contract code
    exists at the `0x0` address. The following code sample shows vulnerable code implements
    a `safeTransferFrom` function for a token.[^(19)](#c05-note-0019)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约如果假设在`0x0`地址处有智能合约代码，也可能出现错误。以下代码示例显示了脆弱代码实现了一个代币的`safeTransferFrom`函数。[^(19)](#c05-note-0019)
- en: '[PRE15]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code, the `safeTransferFrom` function is called in the contract that
    created the deposited token. This should transfer that token from one address
    to another.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`safeTransferFrom`函数在创建存款代币的合约中被调用。这应该将该代币从一个地址转移到另一个地址。
- en: If the address of *`token`* is the `0x0` address, then the `call` function will
    try to call the fallback function of the contract at `0x0`, which does not exist.
    Instead of reverting, this call will succeed, making it appear that a token transfer
    succeeded when it did not. As a result, the contract will accept and respond to
    a nonexistent transfer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`token`*的地址是`0x0`地址，那么`call`函数将尝试调用`0x0`处的合约回退函数，但该函数并不存在。代替回退，这次调用将成功，使得看起来代币转账成功，而实际上并没有。因此，合约将接受并响应一个不存在的转账。
- en: '***Countermeasures***     When working with transfers of tokens and calls to
    smart contracts, a contract should always check for the zero address. Additionally,
    smart contracts should verify that smart contract code exists at an address before
    attempting to call functions within it.  ***Case Studies***    The previous vulnerable
    code sample is from the Qubit project, which implements a bridge between the Ethereum
    and the BNB Chain platforms. This bridge was hacked in January 2022.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策**     在与代币的转账和智能合约的调用交互时，智能合约应始终检查零地址。此外，智能合约在尝试调用其内的函数之前，应验证地址处是否有智能合约代码。
    **案例研究**     之前的脆弱代码示例来自Qubit项目，该项目实现了一个连接以太坊和BNB链平台的桥。这座桥于2022年1月被黑客攻击。'
- en: 'The attacker took advantage of a missing zero address check to trick the bridge
    into accepting a fake deposit of ETH, which triggered a Deposit event. This event
    was caught by the bridge''s smart contract, which caused qxETH tokens to be minted
    to the attacker''s account on BNB Chain, which the attacker converted into $80
    million in BNB.  ###### *Reentrancy*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者利用了缺失的零地址检查，诱使桥接接受一笔假ETH存款，触发了存款事件。该事件被桥接的智能合约捕捉，导致在BNB链上为攻击者账户铸造了qxETH代币，攻击者将其兑换成了8000万BNB。######
    *重入*
- en: Reentrancy is likely the most famous Ethereum-specific vulnerability. It was
    the cause of the DAO hack, which was the most significant Ethereum hack to date.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 重入可能是最著名的以太坊特定漏洞。它是DAO攻击的原因，这是迄今为止最重大的以太坊攻击。
- en: Like unexpected reversion, reentrancy is made possible by the ability to execute
    code within a fallback function. The following code snippet contains a reentrancy
    vulnerability.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与意外回退一样，重入是由在回退函数内执行代码的能力实现的。以下代码片段包含一个重入漏洞。
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `withdraw` function checks to see if a withdrawal request is valid, transfers
    the value to the target address, and then updates its internal ledger accordingly.
    However, the command `msg.sender.call.value(_amount)()` executes before this state
    update and allows a target smart contract to execute some commands.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`withdraw`函数检查提现请求是否有效，将价值转移到的目标地址，并相应地更新其内部账本。然而，在状态更新之前，命令`msg.sender.call.value(_amount)()`执行，允许目标智能合约执行一些命令。
- en: 'A malicious smart contract can exploit this vulnerability by calling the `withdraw`
    function again from inside its fallback function. Assuming that the account has
    a balance of 5 ETH and is requesting a withdrawal of 4 ETH, this would produce
    the following sequence of events:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意智能合约可以通过在其回退函数内部再次调用`withdraw`函数来利用此漏洞。假设账户余额为5 ETH，并要求提现4 ETH，这将产生以下事件序列：
- en: Malicious contract calls `withdraw` function.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意合约调用`withdraw`函数。
- en: '`require` statement validates that the transaction is valid (5 >= 4).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`语句验证交易是否有效（5 >= 4）。'
- en: Vulnerable `withdraw` function t sends 4 ETH to malicious contract, triggering
    fallback function.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的`withdraw`函数t向恶意合约发送4 ETH，触发回退函数。
- en: Malicious contract calls `withdraw` function.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意合约调用`withdraw`函数。
- en: '`require` statement validates that the transaction is valid (5 >= 4).'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`语句验证交易是否有效（5 >= 4）。'
- en: Vulnerable `withdraw` function sends 4 ETH to malicious contract, triggering
    fallback function.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的`withdraw`函数向恶意合约发送4 ETH，触发回退函数。
- en: Fallback function returns.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退函数返回。
- en: Vulnerable contract updates internal state (*`balances[msg.sender]`* = 1).
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的合约更新内部状态(*`balances[msg.sender]`* = 1)。
- en: Vulnerable `withdraw` function returns.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的`withdraw`函数返回。
- en: Vulnerable `withdraw` function updates internal state (*`balances[msg.sender]`*
    = -3).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的`withdraw`函数更新内部状态(*`balances[msg.sender]`* = -3)。
- en: Vulnerable `withdraw` function returns.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的`withdraw`函数返回。
- en: Because the vulnerable `withdraw` function only updates its internal state after
    performing the value transfer, an attacker can make multiple calls with the original
    value of *`balances[msg.sender]`*, allowing them to extract excess value from
    the contract. The number of reentries is largely limited by the amount of gas
    available at each iteration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因为脆弱的`withdraw`函数仅在执行价值转移后更新其内部状态，所以攻击者可以使用*`balances[msg.sender]`* 的原始值进行多次调用，允许他们从合约中提取过量价值。重入次数主要受每次迭代可用的gas量限制。
- en: '***Countermeasures***     Reentrancy vulnerabilities can be eliminated by following
    the check-effects-interaction code pattern. This involves the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    通过遵循检查-效果-交互的代码模式，可以消除重入漏洞。这包括以下内容：'
- en: '**Check:** Check that a request is valid (i.e., the `require` statement from
    the example).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查：** 检查请求是否有效（例如，来自示例的`require`语句）。'
- en: '**Effects:** Record the effects of the event (i.e., updating the value of *`balances[msg.sender]`*).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效果：** 记录事件的影响（例如，更新*`balances[msg.sender]`* 的值）。'
- en: '**Interaction:** Perform the action (i.e., transferring the value).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互：** 执行行动（例如，转移价值）。'
- en: With this code pattern, the reentrant call to the `withdraw` function would
    have failed at the `require` statement because *`balances[msg.sender]`* would
    equal 1, not 5.  ***Case Studies***     The DAO hack is the most famous Ethereum
    hack to date. The DAO was a contract designed to implement crowdfunding on the
    blockchain. Project proposals could be submitted to the contract and voted on
    by DAO token owners. If approved, they would receive funding, and successful projects
    would pay dividends to DAO token holders.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种代码模式，对`withdraw`函数的重入调用将在`require`语句处失败，因为*`balances[msg.sender]`* 将等于1，而不是5。***案例研究***     DAO攻击是迄今为止最著名的以太坊攻击。DAO是一个旨在在区块链上实现众筹的合约。项目提案可以提交给合约，并由DAO代币所有者进行投票。如果获得批准，它们将获得资金，成功的项目将为DAO代币持有者支付股息。
- en: A reentrancy vulnerability in the DAO smart contract allowed the attacker to
    drain value from the contract by repeatedly requesting a withdrawal before the
    contract updated its internal state.[^(20)](#c05-note-0020) The attacker stole
    approximately 3.6 million ETH from the contract.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: DAO智能合约中的一个重入漏洞允许攻击者通过反复请求提款，在合约更新其内部状态之前耗尽合约的价值。[^(20)](#c05-note-0020) 攻击者从合约中窃取了大约3600万ETH。
- en: 'In the end, the DAO hack was ultimately unsuccessful because the Ethereum network
    performed a hard fork that rewrote history to erase it from the ledger. This sparked
    the division of the Ethereum (ETH) and Ethereum Classic blockchains, which contain
    the nodes that did and did not follow this hard fork. This broke the rules of
    blockchain immutability but helped preserve the value of ETH.  ###### *Token Standards
    Compatibility*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '最终，DAO攻击最终失败，因为以太坊网络执行了一个硬分叉，重写历史，将其从账本中抹去。这引发了以太坊(ETH)和以太坊经典区块链的分叉，包含遵循和不遵循这个硬分叉的节点。这打破了区块链不可变性的规则，但帮助保留了ETH的价值。  ######
    *代币标准兼容性*'
- en: Ethereum has a number of standards called Ethereum Improvement Proposals (EIPs).
    Among these is the EIP-20 standard that specifies a standard interface for tokens
    created on the Ethereum smart contract platform.[^(21)](#c05-note-0021)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊有一系列称为以太坊改进提案（EIPs）的标准。其中一个是EIP-20标准，它指定在以太坊智能合约平台上创建的代币的标准接口。[^(21)](#c05-note-0021)
- en: EIP-20 specifies function prototypes for common token functions, including their
    arguments, return values, and required actions such as firing certain events.
    However, not all tokens follow the EIP-20 standard.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: EIP-20规范指定了常见代币函数的函数原型，包括它们的参数、返回值以及必须执行的动作，如触发某些事件。然而，并非所有代币都遵循EIP-20标准。
- en: For example, EIP-20 specifies that `transfer` and `transferFrom` functions return
    a Boolean value indicating success or failure. However, the USDT stablecoin returns
    `void` in these functions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，EIP-20规范指定`transfer`和`transferFrom`函数返回一个布尔值，表示成功或失败。然而，USDT稳定币在这些函数中返回`void`。
- en: 'This can cause incompatibility with smart contracts that strictly follow the
    EIP-20 standard like the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会与严格遵循EIP-20标准的智能合约不兼容，如下面的命令所示：
- en: '[PRE17]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The use of `require` here means that a compliant token will allow continued
    execution if transfer succeeds and causes reversion if the transaction fails.
    However, transactions that call this code with a noncompliant token like USDT
    will revert every time because `require(null)` will throw an error.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`require`意味着一个符合标准的代币将在转移成功时允许继续执行，如果交易失败则导致回滚。然而，使用像USDT这样的不合规代币调用此代码的交易将每次都会回滚，因为`require(null)`将抛出错误。
- en: '***Countermeasures***     Projects like OpenZeppelin have implemented `safeTransfer`
    and `safeTransferFrom` functions that properly handle both return value checks
    and noncompliant tokens. Using these implementations provides both security and
    support for noncompliant tokens.  ***Case Studies***    ForceDAO was a DeFi aggregator
    project that was hacked for $367,000 in tokens within hours of launch.[^(22)](#c05-note-0022)
    The project''s vaults were a fork of the xSUSHI contract, which was vulnerable
    to tokens that did not comply with the EIP-20 standard.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    像OpenZeppelin这样的项目已经实现了`safeTransfer`和`safeTransferFrom`函数，这些函数能够正确处理返回值检查和不合规代币。使用这些实现既提供了安全性，也支持不合规代币。  ***案例研究***    ForceDAO是一个在上线几小时内被黑客攻击，损失了价值36.7万美元的代币的DeFi聚合器项目。[^(22)](#c05-note-0022)该项目的保险库是xSUSHI合约的分叉，该合约对不符合EIP-20标准的代币存在漏洞。'
- en: 'An attacker deposited tokens into the contract that would return false rather
    than reverting upon a failed deposit. Since the contract did not check return
    values, it issued xFORCE tokens due to these failed deposits. The attacker could
    then redeem these xFORCE tokens for FORCE tokens stored in the contract''s vault.  ######
    *Unchecked Return Values*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '攻击者向合约中存入了会在失败存款时返回false而不是回滚的代币。由于合约没有检查返回值，因此由于这些失败的存款而发行了xFORCE代币。然后攻击者可以将这些xFORCE代币兑换为存储在合约保险库中的FORCE代币。  ######
    *未检查返回值*'
- en: In Solidity, functions can indicate failure in a couple of different ways. If
    a low-level function reverts, then this can cause the transaction to be completely
    rolled back unless handled by a `try-catch` block. However, if a function indicates
    failure by returning false, then the calling function can continue execution at
    its next command.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，函数可以通过几种不同的方式指示失败。如果一个低级函数回滚，那么除非通过`try-catch`块处理，否则这笔交易会被完全撤销。然而，如果一个函数通过返回false来指示失败，那么调用函数可以在其下一个命令继续执行。
- en: This difference in how low-level functions handle errors can create smart contract
    vulnerabilities, like the one in the following code sample.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 低级函数处理错误的这种差异可能会创建智能合约漏洞，就像以下代码样本中的那个一样。
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code sample implements a withdraw function with reentrancy protections.
    The crucial line of code here is the use of the `send` command to send value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码样本实现了一个带有重入保护的提款函数。这里的关键代码行是使用`send`命令发送值。
- en: 'Solidity defines a few different mechanisms for sending Ether to another contract:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，定义了几种不同的机制将以太币发送到另一个合约：
- en: '`transfer`: Costs 2300 gas and indicates failure by throwing an error'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transfer`：消耗2300个气体，并通过抛出错误来指示失败'
- en: '`send`: Costs 2300 gas and indicates failure by returning false'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`：消耗2300个气体，并通过返回false来指示失败'
- en: '`call`: Sends an arbitrary amount of gas and indicates failure by returning
    false'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call`：发送任意数量的气体，并通过返回false来指示失败'
- en: The `send` and `transfer` functions are nearly identical except in how they
    handle errors. In the previous code sample, if something goes wrong with the call
    to `send`, the transfer may fail without detection because the contract is not
    checking the return value. This could leave the contract in an invalid state because
    it has already recorded the transfer in its *`balances`* and *`etherLeft`* variables.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`和`transfer`函数几乎相同，除了它们处理错误的方式不同。在之前的代码样本中，如果调用`send`时出错，由于合约没有检查返回值，转移可能会失败而没有被发现。这可能会使合约处于无效状态，因为它已经在*`balances`*和*`etherLeft`*变量中记录了转移。'
- en: '***Countermeasures***     The example vulnerability existed because a function
    failed to check for failure in a call to another function. This issue could be
    fixed by researching how a particular function handles errors before using it
    or assume the worst and implement error-checking functionality for all calls to
    external functions.  ***Case Studies***     An earlier version of the King of
    the Ether contract mentioned previously contained an unchecked return value vulnerability.[^(23)](#c05-note-0023)
    The contract did not include enough gas with a call to send to support transfers
    to a smart-contract-based wallet, which would execute a fallback function. As
    a result, an attempt to refund the previous monarch failed when that monarch used
    a smart-contract-based wallet.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策** 之前提到的国王合约的早期版本中存在一个未检查返回值的漏洞。[^(23)](#c05-note-0023) 该合约没有包含足够的gas来支持向支持智能合约钱包的转账调用，该钱包将执行回退函数。结果是，当之前的君主使用智能合约钱包时，尝试退还先前的君主失败了。'
- en: 'Since the contract did not check the return value of the call to send, the
    failure was ignored and the throne was transferred to the next claimant. However,
    when this was discovered, the contract operators extracted the value from the
    contract and sent it to the previous monarch.  ###### *Unsafe External Call*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于合约没有检查发送调用的返回值，所以忽略了失败，王位传给了下一个要求者。然而，当这个发现时，合约运营商从合约中提取了价值，并发送给了之前的君主。######
    *不安全的对外调用*
- en: In Ethereum, a smart contract account is no different from a user account, and
    smart contracts are designed to interact with one another. However, the ways in
    which a smart contract function calls other functions has a dramatic impact on
    its security.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上，智能合约账户与用户账户没有什么不同，智能合约被设计用来相互交互。然而，智能合约函数调用其他函数的方式对其安全性有重大影响。
- en: The following code sample implements a call forwarder and is an example of unsafe
    calls to external functions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例实现了一个调用转发器，是对外部函数进行不安全调用的例子。
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Solidity's `delegatecall` function enables a smart contract's functions to be
    called while maintaining the context of the calling function. The code executed
    within the callee has access to the caller's data and value, and any calls made
    by the callee with have *`msg.sender`* set to the caller's address.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity的`delegatecall`函数可以在保持调用函数上下文的情况下调用智能合约的功能。在被调用者中执行的代码可以访问调用者的数据和值，被调用者进行的任何调用都会将*`msg.sender`*设置为调用者的地址。
- en: By using `delegatecall`, a smart contract is placing complete trust in the called
    function. The callee can modify or delete the caller's data, steal value from
    the caller, and bypass access controls by masquerading as the caller when calling
    other functions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`delegatecall`，智能合约将完全信任被调用函数。被调用者可以修改或删除调用者的数据，窃取调用者的价值，并通过伪装成调用者调用其他函数来绕过访问控制。
- en: '***Countermeasures***     Never use `delegatecall`. Anything that can be done
    using `delegatecall` can be done more safely another way.  ***Case Studies***
        Furucombo is a drag-and-drop interface for DeFi traders to build chains of
    trades. Furucombo allowed users to preapprove transfers for certain tokens, enabling
    the contract to extract these tokens from the user''s account without explicit
    approval.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策** 永远不要使用`delegatecall`。任何可以通过`delegatecall`完成的事情都有更安全的其他方法。**案例研究** Furucombo是一个为DeFi交易者构建交易链的拖放界面。Furucombo允许用户预先批准某些代币的转账，使合约能够在不需要明确批准的情况下从用户账户中提取这些代币。'
- en: Furucombo's `batchExec` function allowed a `delegatecall` to the Aave proxy
    contract.[^(24)](#c05-note-0024) This allowed the attacker to call the Aave contract's
    fallback function, which performs a `delegatecall` to its implementation logic
    contract. The attacker exploited this chain of `delegatecall`s to have the implementation
    contract set to their own malicious contract.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Furucombo的`batchExec`函数允许对Aave代理合约进行`delegatecall`。[^(24)](#c05-note-0024) 这允许攻击者调用Aave合约的回退函数，该函数执行对其实施逻辑合约的`delegatecall`。攻击者利用这一系列的`delegatecall`将实施合约设置为自己的恶意合约。
- en: 'Using this same chain of `delegatecall`s, the attacker can then call functions
    in their own contract using the state of the Furucombo contract. The attacker
    can then transfer preapproved tokens from users'' accounts to their own.  #####
    EOSIO'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '使用相同的 `delegatecall` 链，攻击者可以调用 Furucombo 合约状态下的他们自己合约中的函数。然后攻击者可以将预先批准的代币从用户账户转移到自己的账户中。  #####
    EOSIO'
- en: 'EOSIO is another early example of smart contract technology that has been used
    to host various distributed applications (DApps). The following list includes
    some examples of vulnerabilities particular to the EOSIO platform:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: EOSIO 是另一种早期智能合约技术的例子，它被用来托管各种分布式应用（DApps）。以下列表包括一些特定于 EOSIO 平台的漏洞示例：
- en: Fake tokens
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假代币
- en: Notification assumptions
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知假设
- en: Reentrancy
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重入性
- en: Unchecked transaction status
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未检查交易状态
- en: '###### *Fake Tokens*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '###### *假代币*'
- en: In many smart contract platforms, token names and symbols must be unique. An
    attempt to create a new token with the same symbol as an existing token will fail.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多智能合约平台上，代币名称和符号必须是唯一的。尝试创建一个与现有代币具有相同符号的新代币将失败。
- en: On EOSIO, different smart contracts can create tokens with the same symbols.
    This can lead to fake token vulnerabilities like that in the following code sample.[^(25)](#c05-note-0025)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EOSIO 上，不同的智能合约可以创建具有相同符号的代币。这可能导致类似于以下代码示例中的假代币漏洞。[^(25)](#c05-note-0025)
- en: '[PRE20]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `test::transfer` function in this code sample performs validation that a
    transfer is valid before accepting it. This includes validating that the token
    symbol is EOS, the native token of EOSIO.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例中的 `test::transfer` 函数在接受转账之前执行验证，以确保转账是有效的。这包括验证代币符号是 EOS，即 EOSIO 的原生代币。
- en: However, in EOSIO, the combination of contract and symbol is unique, not just
    the token symbol itself. This function would accept a transfer of any token with
    a symbol of EOS, not just the official EOS token. This could allow an attacker
    to deposit a worthless token and extract tokens with actual value from the contract.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 EOSIO 中，合约和符号的组合是唯一的，不仅仅是代币符号本身。此函数将接受任何具有 EOS 符号的代币，而不仅仅是官方的 EOS 代币。这可能允许攻击者存入一个无价值的代币，并从合约中提取具有实际价值的代币。
- en: '***Countermeasures***     In EOSIO, the combination of a token contract and
    symbol is unique, not just the token symbol. When validating a transfer, it is
    necessary to check that both of these match expected values.  ***Case Studies***    The
    BitDice project contained a fake token vulnerability that was exploited in October
    2019.[^(26)](#c05-note-0026) The code verified that a token symbol matched EOS
    but not that the token contract matched `eosio.token`. As a result, an attacker
    was able to send fake EOS tokens from the contract and then extract 4,000 real
    EOS tokens from it.  ###### *Notification Assumptions*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    在 EOSIO 中，代币合约和符号的组合是唯一的，不仅仅是代币符号。在验证转账时，必须检查这两个是否符合预期值。   ***案例研究***    BitDice
    项目包含一个在 2019 年 10 月被利用的假代币漏洞。[^(26)](#c05-note-0026) 该代码验证了代币符号与 EOS 匹配，但没有验证代币合约是否与
    `eosio.token` 匹配。结果，攻击者能够从合约中发送假 EOS 代币，然后从中提取 4,000 枚真实 EOS 代币。  ###### *通知假设*'
- en: In EOSIO, smart contracts can receive notifications about particular events
    and create listeners that execute code if they receive these notifications. The
    most common notification is when a user is involved in a transaction either as
    sender or receiver.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EOSIO 中，智能合约可以接收到关于特定事件的通知，并创建监听器，如果收到这些通知，则执行代码。最常见的通知是当用户作为发送者或接收者参与交易时。
- en: The following code sample is vulnerable to exploitation due to incorrect assumptions
    about how notifications work in EOSIO.[^(27)](#c05-note-0027)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例由于对 EOSIO 中通知工作方式的错误假设而容易受到利用。[^(27)](#c05-note-0027)
- en: '[PRE21]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This transfer function is designed to act when it receives a transaction. It
    is triggered by a notification about a transfer and tests whether it was the one
    that initiated the transfer. If not, it assumes that it is the recipient of the
    transaction and responds accordingly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转账函数设计用于在接收到交易时执行操作。它通过关于转账的通知被触发，并测试它是否启动了转账。如果不是，它假定自己是交易的接收者并做出相应响应。
- en: The problem with this code is that any EOSIO account can be notified about a
    transaction using the `require_recipient` command. This function could be tricked
    by an attacker who performs a transfer between two other accounts and notifies
    this one via `require_recipient`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，任何 EOSIO 账户都可以使用 `require_recipient` 命令通知关于某笔交易的信息。攻击者可以通过在其他两个账户之间进行转账并使用
    `require_recipient` 通知这个账户来欺骗这个函数。
- en: In this case, the contract will correctly determine that it was not the source
    of the transaction. However, it will then wrongly conclude that it was the recipient,
    which may result in it sending tokens to an attacker or taking other action in
    response to the deposit that it believes it received.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在此案例中，合约将正确地确定它不是交易的来源。然而，它将错误地得出它是接收者的结论，这可能导致它向攻击者发送代币或对它认为收到的存款采取其他行动。
- en: '***Countermeasures***     With `require_recipient`, anyone can be notified
    of a transfer or other event. When responding to a notification about a transfer,
    it is necessary to verify that the contract was in fact the recipient of the transfer
    and not just that it is not the sender.  ***Case Studies***    The vulnerable
    code sample previously shown is from the EOSBet casino smart contract, which was
    exploited in October 2018.[^(28)](#c05-note-0028) The attackers sent transfers
    from account ilovedice123 to whoiswinner1 while notifying the EOSBet casino contract
    using `require_recipient`. Since EOSBet did not verify that it was the recipient
    of the transaction, it credited the transfer to the attacker''s account.  ######
    *Reentrancy*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    使用`require_recipient`，任何人都可以得知一笔转账或其他事件。在回应关于转账的通知时，有必要验证合约实际上是转账的接收者，而不仅仅是它不是发送者。  ***案例研究***    之前展示的易受攻击的代码样本来自EOSBet赌场智能合约，该合约于2018年10月被利用。[^(28)](#c05-note-0028)
    攻击者通过`require_recipient`通知EOSBet赌场合约，将转账从账户ilovedice123发送到whoiswinner1。由于EOSBet没有验证它确实是交易接收者，因此它将转账记入了攻击者的账户。  ######
    *重入*'
- en: Reentrancy vulnerabilities exist in Ethereum because fallback functions allow
    third-party, potentially malicious code to be run between adjacent instructions
    of a calling function. EOSIO contracts are also vulnerable to reentrancy, but
    it works differently.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ethereum中的回退函数允许第三方、潜在的恶意代码在调用函数的相邻指令之间运行，因此存在重入漏洞。EOSIO合约也容易受到重入攻击，但工作方式不同。
- en: The following code sample demonstrates a reentrancy vulnerability.[^(29)](#c05-note-0029)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码样本演示了一个重入漏洞。[^(29)](#c05-note-0029)
- en: '[PRE22]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In EOSIO, reentrancy vulnerabilities originate from the notification system.
    As mentioned previously, EOSIO allows smart contracts to be notified of certain
    events via `require_recipient`, and these notified contracts can execute code
    when they receive these notifications.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在EOSIO中，重入漏洞起源于通知系统。如前所述，EOSIO允许智能合约通过`require_recipient`通知某些事件，并在收到这些通知时执行代码。
- en: This handler code may include *inline actions* such as the log action in the
    preceding sample. Logically, it would seem that this inline action would be executed
    immediately after the `on_transfer` function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序代码可能包括如前一个示例中的日志操作的内联操作。从逻辑上讲，似乎这个内联操作将在`on_transfer`函数之后立即执行。
- en: However, EOSIO executes all notification handlers for an event before it will
    run any inline actions. This means that the log action in the preceding code may
    execute long after the `on_transfer` function with code from other functions in
    between.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，EOSIO在执行事件的任何通知处理程序之前会执行所有内联操作。这意味着前述代码中的日志操作可能在`on_transfer`函数之后很长一段时间执行，中间有其他函数的代码。
- en: This creates the potential for reentrancy attacks if a vulnerable contract splits
    operations between notification handlers and inline actions. For example, a contract
    might perform a transfer in the handler and then use an inline action to perform
    a state update or vice versa. An attacker that can split these two actions may
    be able to exploit the contract.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个易受攻击的合约将操作分隔在通知处理程序和内联操作之间，这将创建重入攻击的可能性。例如，一个合约可能会在处理程序中执行转账，然后使用内联操作执行状态更新，或反之。如果攻击者能够分割这两个操作，它可能能够利用该合约。
- en: '***Countermeasures***     Reentrancy attacks in EOSIO take advantage of the
    fact that inline actions are not immediately executed after the notification handler
    that triggers them. Whenever possible, make actions and state updates atomic rather
    than splitting them over notification handlers and inline actions.  ***Case Studies***    In
    May 2021, the Vaults.sx yield aggregator smart contract was the victim of a reentrancy
    attack.[^(30)](#c05-note-0030) The attack included the following steps:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    EOSIO中的重入攻击利用了内联操作在触发它们的 notification handler 执行后不会立即执行的事实。尽可能让动作和状态更新原子化，而不是将它们分隔在通知处理程序和内联操作之间。  ***案例研究***    2021年5月，Vaults.sx收益聚合器智能合约成为重入攻击的受害者。[^(30)](#c05-note-0030)
    攻击包括以下步骤：'
- en: Attacker deposited tokens in exchange for SX tokens.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者用SX代币兑换了代币。
- en: The attacker redeemed half of these SX tokens.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者兑换了这些SX代币的一半。
- en: When notified of the redemption transaction, the attacker created two inline
    actions. One triggered Vault.sx's update function, while the other redeemed the
    other half of its SX tokens.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当攻击者收到兑换交易通知时，他创建了两个内联操作。一个触发了Vault.sx的更新函数，而另一个兑换了其SX代币的一半。
- en: When notified of the redemption transaction, the vault.sx contract created an
    inline action to pay out rewards and updated its internal total supply value based
    on this update.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当攻击者收到兑换交易通知时，vault.sx合约创建了一个内联操作来支付奖励，并根据此更新更新了其内部的总量供应值。
- en: The attacker's inline actions executed, overwriting the balance update in step
    4, which had not yet executed.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者的内联操作执行了，覆盖了步骤4中尚未执行的余额更新。
- en: 'The attacker received redeemed tokens. The second redemption included excess
    rewards because it was based on an incorrect value of the contract''s total supply.  ######
    *Unchecked Transaction Status*'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者获得了已兑换的代币。第二次兑换包括了超额奖励，因为它基于合同总供应量的错误值。###### *未检查交易状态*
- en: 'In EOSIO, a transaction can have several different statuses,[^(31)](#c05-note-0031)
    including the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在EOSIO中，一个交易可以有几种不同的状态，[^(31)](#c05-note-0031)包括以下内容：
- en: '`executed`: Transaction succeeded, and no error handling was executed.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executed`：交易成功，没有执行错误处理。'
- en: '`soft_fail`: Transaction failed but error handing succeeded.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soft_fail`：交易失败但错误处理成功。'
- en: '`hard_fail`: Transaction and error handling failed.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hard_fail`：交易和错误处理失败。'
- en: '`delayed`: Transaction delayed by user to execute in the future.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delayed`：用户延迟交易以在将来执行。'
- en: '`expired`: Transaction expired, and CPU/NET was refunded to the user.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expired`：交易过期，CPU/NET退还给用户。'
- en: For most of these, the behavior of EOSIO is logical. Successful transactions
    are recorded on the chain, while unsuccessful or expired ones are not.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数这些情况，EOSIO的行为是逻辑的。成功的交易记录在链上，而不成功或过期的交易则没有。
- en: The exception here is delayed transactions. When a transaction is delayed, its
    contents are recorded on the blockchain. Later, when the delay timer expires,
    nodes can extract the contents of the transaction from a block to execute and
    validate it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个例外是延迟交易。当交易被延迟时，其内容被记录在区块链上。后来，当延迟计时器到期，节点可以从区块中提取交易的正文以执行和验证它。
- en: Delayed execution is not a problem if a transaction succeeds. However, a delayed
    transaction that results in a status of `hard_fail` is still recorded on the blockchain.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交易成功，延迟执行不是一个问题。然而，导致`hard_fail`状态的延迟交易仍然记录在区块链上。
- en: This can create confusion for smart contracts that observe transactions but
    do not validate their status. A smart contract may see that a transaction to it
    exists on the blockchain and respond accordingly. However, this transaction may
    be delayed and designed to result in a `hard_fail`, meaning that it did not actually
    execute. As a result, the vulnerable contract has reacted to a transaction that
    never happened.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会对观察交易但不对其状态进行验证的智能合约造成混淆。智能合约可能会看到区块链上存在对它的交易并做出相应响应。然而，这笔交易可能会被延迟，并设计成导致`hard_fail`，这意味着它实际上并没有执行。因此，脆弱的合约对一个从未发生的交易做出了反应。
- en: '***Countermeasures***    A transaction''s *`status`* is one of the fields within
    a transaction receipt. Smart contracts should check this field and verify that
    it has a status of executed before accepting a transaction.  ***Case Studies***    Vegas
    Town contained an unchecked transaction status vulnerability that was exploited
    by fortherest12 in March 2019\. The attacker used delayed transactions to send
    transfers to the contract that would result in a status of `hard_fail` but still
    be recorded on the blockchain. The vulnerable contract failed to check the status
    of these transactions, causing it to accept failed transactions.  #### *Application-Specific
    Vulnerabilities*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    交易*`status`*是交易收据中的字段之一。智能合约应检查此字段，并在接受交易之前验证其已执行。  ***案例研究***    Vegas
    Town包含一个未检查交易状态的漏洞，在2019年3月被forrest12利用。攻击者使用延迟交易向合约发送转账，这将导致状态为`hard_fail`但仍在区块链上记录。易受攻击的合约未能检查这些交易的状态，导致它接受失败的交易。  ####
    *应用特定漏洞*'
- en: Smart contracts can be used for various different purposes. Two of the main
    applications of smart contracts today are decentralized finance (DeFi) and non-fungible
    tokens (NFTs).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: smart contracts可以用于各种不同的目的。目前智能合约的两个主要应用是去中心化金融（DeFi）和非同质化代币（NFTs）。
- en: Both of these applications of smart contracts introduce features and functions
    that do not exist in all smart contracts. With them come potential vulnerabilities
    and security issues unique to these use cases.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个智能合约应用引入了智能合约中不存在的特性和功能。随着它们而来的是这些用例特有的潜在漏洞和安全问题。
- en: '##### DeFi Vulnerabilities'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '##### DeFi漏洞'
- en: Bitcoin was designed to implement a decentralized financial system using the
    blockchain's digital ledger. However, Bitcoin is largely designed to track transfers
    of value on the blockchain.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币被设计用来实现一个使用区块链数字账本的去中心化金融系统。然而，比特币主要被设计用来在区块链上跟踪价值的转移。
- en: 'DeFi smart contracts are designed to implement other functions of financial
    institutions, such as borrowing, lending, and making exchanges between assets.
    These smart contracts are extremely valuable but can also contain various vulnerabilities:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: DeFi智能合约被设计来实现金融机构的其他功能，如借贷、资产间交换等。这些智能合约非常有价值但也可能包含各种漏洞：
- en: Access Control
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Centralized Control
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中控制
- en: Frontend Vulnerabilities
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端漏洞
- en: Price Manipulation
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格操纵
- en: '###### *Access Control*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 访问控制'
- en: Access control vulnerabilities can exist in any smart contract. However, the
    unique nature of the DeFi space creates new types of access control vulnerabilities,
    and the high value of DeFi contracts exacerbates their impacts.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制漏洞可能存在于任何智能合约中。然而，DeFi领域的独特性质创造了新的访问控制漏洞，而DeFi合约的高价值加剧了它们的影响。
- en: In DeFi contracts, `mint` and `burn` functions must be appropriately protected.
    The following code sample shows an unprotected `mint` function.[^(32)](#c05-note-0032)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在DeFi合约中，`mint`和`burn`函数必须得到适当的保护。下面的代码示例展示了一个未受保护的`mint`函数。[^(32)](#c05-note-0032)
- en: '[PRE23]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: DeFi smart contracts commonly have a native token. These tokens may be designed
    to indicate ownership of a share of the contract's liquidity (which could accrue
    interest) or issued when a user takes out a loan to allow them to reclaim their
    collateral.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: DeFi智能合约通常具有原生代币。这些代币可能被设计用来表示合约流动性的股份（可能产生利息）或当用户提取贷款时发放，允许他们收回抵押品。
- en: A `mint` function like the one in the preceding code allows new tokens to be
    created. An unprotected one could allow an attacker to create new tokens and send
    them to their account. In the sample code, the `mint` function is labeled as `public`,
    meaning that anyone can call it to create new tokens.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面代码中的`mint`函数允许创建新的代币。未受保护的`mint`函数可能会让攻击者创建新的代币并发送到他们的账户。在示例代码中，`mint`函数被标记为`public`，意味着任何人可以调用它来创建新的代币。
- en: If this occurs, the existing tokens lose some value, and the attacker can steal
    value from the protocol. For example, minting 100 tokens when 100 exist would
    cut the value of each token in half but allow the attacker to claim half of the
    value invested in a DeFi contract.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，现有代币会失去一些价值，攻击者可以从协议中窃取价值。例如，当存在100个代币时铸造100个代币，每个代币的价值会减半，但允许攻击者声称DeFi合约中投入价值的一半。
- en: A `burn` function does the opposite, destroying some of a smart contract's native
    tokens. If an attacker can burn tokens held by a contract, then the remaining
    tokens gain additional value. If an attacker holds these tokens, they can extract
    more value from the protocol than they put in.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`burn`函数相反，销毁智能合约的一些原生代币。如果攻击者能够销毁合约持有的代币，那么剩余的代币将获得额外的价值。如果攻击者持有这些代币，他们可以从协议中提取的价值超过他们投入的价值。'
- en: '***Countermeasures***    Access control best practices for DeFi contracts are
    the same as for smart contracts in general. Functions should be labeled as `private`
    by default and only be made publicly accessible if necessary for the smart contract''s
    logic.  ***Case Studies***    The Zenon Network was the victim of a hack in November
    2021.[^(33)](#c05-note-0033) An unprotected `burn` function allowed anyone to
    destroy wZNN tokens held by the contract.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '****对策****     DeFi合约的访问控制最佳实践与一般智能合约相同。函数应该默认标记为`private`，并且只有在智能合约逻辑需要时才应公开可用。  ****案例研究****     Zenon
    Network在2021年11月遭受了黑客攻击。[^(33)](#c05-note-0033) 一个未受保护的`burn`函数允许任何人销毁合约持有的wZNN代币。'
- en: 'The attacker deposited tokens into the contract to earn wZNN, then burned over
    26,000 wZNN tokens. This caused the value of wZNN tokens to increase significantly
    because the value held by the contract mapped to fewer wZNN tokens. The attacker
    was then able to extract over $1 million in WBNB by redeeming their wZNN tokens.  ######
    *Centralized Control*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者向合约中存入代币以赚取wZNN，然后销毁了超过26,000个wZNN代币。这导致wZNN代币的价值大幅上升，因为合约中持有的价值映射到的wZNN代币更少了。然后攻击者通过赎回他们的wZNN代币提取了超过100万美元的WBNB。######
    *中心化控制*
- en: Access control vulnerabilities exist when too many people have access to high-risk
    functions within a smart contract. However, implementing strong access control
    can also create security risks for a contract by centralizing control of that
    contract's protected functions.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当太多的人可以访问智能合约中的高风险功能时，就存在访问控制漏洞。然而，实现强大的访问控制也可能通过集中控制合约的保护功能来为合约带来安全风险。
- en: Many DeFi contracts are deployed using a single signature wallet, which means
    that only one private key is necessary to sign transactions that access private
    functionality such as `mint`, `burn`, and `self_destruct` functions. This makes
    it easier for an attacker or a malicious insider to take over the contract and
    steal the value that it contains.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 许多DeFi合约是通过使用单个签名钱包部署的，这意味着只有一个人需要私钥来签署访问私有功能（如`mint`、`burn`和`self_destruct`功能）的交易。这使得攻击者或恶意内部人员更容易接管合约并窃取其包含的价值。
- en: The following code sample is an example of a centralized control vulnerability.[^(34)](#c05-note-0034)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例是中心化控制漏洞的一个例子。[^(34)](#c05-note-0034)
- en: '[PRE24]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `mint` function correctly limits access to minting functionality, making
    it more difficult for an attacker to mint unauthorized tokens. However, there
    are no restrictions on the owner's ability to mint new tokens, meaning the contract
    owner could mint new tokens at will, devaluing those held by other users. This
    functionality could be abused by the owners of the contract or exploited by an
    attacker who gains access to the account of the contract's owner.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mint`函数正确地限制了铸币功能的访问，使攻击者难以铸造未经授权的代币。然而，对合约所有者铸造新代币的能力没有限制，这意味着合约所有者可以随意铸造新代币，从而贬低其他用户持有的代币价值。这项功能可能会被合约所有者滥用，或者被获得合约所有者账户访问权的攻击者利用。
- en: '***Countermeasures***    Access management is important to DeFi security, but
    privileged access should be decentralized as much as possible. All DeFi contracts
    should be managed by multisignature wallets, which require access to multiple
    private keys to perform privileged functions.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    访问管理对DeFi安全很重要，但特权访问应尽可能去中心化。所有DeFi合约都应通过多签名钱包管理，执行特权功能需要访问多个私钥。'
- en: Ideally, DeFi smart contracts should operate under a decentralized governance
    model that does not put full control in the hands of the project team. This can
    help to protect against *rug pull* attacks where project members drain value invested
    in a project and disappear.  ***Case Studies***    The bZx DeFi protocol lost
    over $55 million in tokens in a November 2021 hack.[^(35)](#c05-note-0035) The
    attackers exploited the fact that the smart contract was not using a multisignature
    wallet.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，DeFi智能合约应该在不去中心化治理模型下运行，不对项目团队完全控制。这有助于保护项目成员抽取投资价值并消失的*地毯式拉扯*攻击。***案例研究***     bZx
    DeFi协议在2021年11月的一次黑客攻击中失去了超过5500万美元的代币。[^(35)](#c05-note-0035) 攻击者利用了智能合约没有使用多签名钱包的事实。
- en: 'A phishing email to a bZx developer installed malware that stole the private
    keys for both the developer''s personal accounts and the ones that managed the
    bZx contract. The attacker then used these keys to drain funds from the developer''s
    account, the bZx contract, and any bZx users who had preexisting approvals for
    tokens on bZx.  ###### *Frontend Vulnerabilities*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一名bZx开发者收到的钓鱼邮件安装了恶意软件，窃取了开发者个人账户以及管理bZx合约的私钥。攻击者随后使用这些密钥从开发者的账户、bZx合约以及任何在bZx上有预先批准代币权限的用户那里提取资金。######
    *前端漏洞*
- en: Most DeFi protocols are not implemented solely as a smart contract. They also
    have a web frontend that provides a user-friendly interface for interacting with
    the smart contract. This distributed application (DApp) architecture works similarly
    to traditional web applications, except that backend systems are implemented as
    a smart contract on the blockchain rather than an application on a web server.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数去中心化金融（DeFi）协议并非仅作为智能合约实施。它们还拥有一个网页前端，为与智能合约交互提供了一个用户友好的界面。这种分布式应用（DApp）架构与传统的网页应用类似，不同之处在于后端系统是作为区块链上的智能合约实现的，而不是部署在网页服务器上的应用程序。
- en: 'Frontend applications should be part of the threat model for DeFi smart contracts.
    Some frontend security risks are as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用应成为DeFi智能合约的威胁模型的一部分。一些前端安全风险如下：
- en: '**Malicious Scripts:** Compromised frontend systems may have malicious JavaScript
    injected into a page. The JavaScript could attempt to steal private keys or create
    malicious transactions for users to unwittingly approve.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意脚本：** 被入侵的前端系统可能会在页面中注入恶意JavaScript。该JavaScript可能会尝试窃取私钥或创建用户不知不觉批准的恶意交易。'
- en: '**Interface Mismatch:** Mismatches in the interface between the web frontend
    and smart contract backend can create unintentional and undesired effects. For
    example, actions performed on the frontend may not be passed on to the smart contract
    backend and recorded on the blockchain.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口不匹配：** 网页前端与智能合约后端之间的接口不匹配可能会产生非故意和不希望的效果。例如，前端执行的操作可能不会传递给智能合约后端或记录在区块链上。'
- en: '**Account Takeover:** Users typically authenticate to web frontends with a
    username and password, and these sites may store and manage private keys. An attacker
    who steals a user''s password via phishing or other means could access their private
    key and take over their blockchain account.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户接管：** 用户通常使用用户名和密码向网页前端进行身份验证，这些网站可能会存储和管理私钥。通过钓鱼或其他手段窃取用户密码的攻击者可能能够访问他们的私钥并接管他们的区块链账户。'
- en: '**Denial-of-Service Attacks:** Web frontends are a single point of failure
    in a DeFi project. A DDoS attack against these sites could render a project inaccessible
    to legitimate users.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务拒绝攻击：** 网页前端是DeFi项目中单点故障。针对这些网站的DDoS攻击可能会使项目对合法用户不可达。'
- en: These are only some of the security risks associated with a web frontend for
    a DeFi project. These sites combine the traditional security risks of web applications
    with those associated with smart contract security.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是与DeFi项目网页前端相关的部分安全风险。这些网站将网页应用的传统安全风险与智能合约安全风险相结合。
- en: '***Countermeasures***    DeFi projects'' web frontends are like any other website.
    They should be analyzed for potential vulnerabilities and business logic errors
    as part of the security audit process.  ***Case Studies***    Users of the BadgerDAO
    smart contract were hacked using a frontend exploit in December 2021.[^(36)](#c05-note-0036)
    The attacker inserted malicious JavaScript into the project''s web frontend that
    inserted approvals for sending tokens to the attacker''s address in transactions
    generated by users. Over 500 wallets made these unwanted approvals, which the
    attacker used to drain over $120 million in tokens from them.  ###### *Price Manipulation*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策：** DeFi项目的网页前端与其他任何网站一样。在安全审计过程中，应分析这些网站的潜在漏洞和业务逻辑错误。**案例研究：** 2021年12月，BadgerDAO智能合约的用户在使用前端的漏洞时遭到黑客攻击。[^(36)](#c05-note-0036)
    攻击者将恶意JavaScript插入项目的网页前端，在用户生成的交易中插入向攻击者地址发送代币的批准。有超过500个钱包作出了这些不受欢迎的批准，攻击者利用这些批准从它们那里提取了超过1.2亿美元的代币。######
    *价格操纵*'
- en: Price manipulation vulnerabilities are some of the most common attacks in the
    DeFi space. They are made possible by on-chain calculations of tokens' values
    and the existence of *flashloans*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 价格操纵漏洞是DeFi领域最常见的攻击之一。它们是由代币价值的链上计算和*闪电贷款*的存在所实现的。
- en: Typically, when a borrower takes out a loan, they need to provide some collateral.
    This collateral is an asset with a value roughly equal to the amount of the loan.
    If the borrower defaults on the loan, the lender can seize this asset to recoup
    their losses.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当借款人申请贷款时，他们需要提供一些抵押品。这笔抵押品价值大致等于贷款金额。如果借款人违约，贷款人可以接管这笔资产以弥补损失。
- en: Collateral is necessary in traditional finance because it allows lenders to
    manage their risk. In DeFi, flashloans can be made without collateral because
    a lender can make risk-free loans.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统金融中需要抵押品，因为它允许贷款人管理其风险。在DeFi中，可以无需抵押品发放闪电贷，因为贷款人可以发放无风险贷款。
- en: This is possible because of how transactions work in the blockchain. In many
    blockchains, transactions are all or nothing. If part of a transaction fails,
    the entire transaction is rolled back as if it never happened.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为区块链中交易的工作方式。在许多区块链中，交易要么全部完成，要么全部不做。如果交易的一部分失败，整个交易将被回滚，就像它从未发生过一样。
- en: Flashloans take advantage of this by requiring that a loan taken at the start
    of a transaction be paid back by the end of that transaction. If the borrower
    defaults and does not make this repayment, then the whole transaction is invalidated
    and the loan never happens. As a result, lenders can make huge, risk-free loans
    because these loans are always paid back by the end of a transaction.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 闪电贷利用这一点，要求在交易开始时所借款项必须在交易结束时还清。如果借款人违约并未偿还，那么整个交易将被无效化，贷款从未发生。因此，贷款人可以放心地发放巨额无风险贷款，因为这些贷款总是在交易结束时得到偿还。
- en: Some DeFi smart contracts calculate the exchange rates of various tokens based
    on supply and demand and the value of the contract. The following code sample
    includes a calculation of the value of a DeFi contract's native token.[^(37)](#c05-note-0037)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一些DeFi智能合约根据代币的供求关系和合同的价值计算各种代币的汇率。以下代码示例包括了一个DeFi合同原生代币价值的计算。[^(37)](#c05-note-0037)
- en: '[PRE25]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function calculates the share of a smart contract's liquidity that a user
    can claim by depositing some of the contract's native tokens. With flashloans,
    an attacker can manipulate this calculation by inflating the asset balance of
    the contract relative to its quantity of native tokens. This allows the attacker
    to drain value from the contract by redeeming its overvalued tokens.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算用户可以通过存入合同原生代币的一部分来声称智能合约流动性的份额。利用闪电贷，攻击者可以操纵这一计算，通过相对于原生代币数量膨胀合同的资产余额。这使得攻击者可以通过赎回高估的代币从合同中提取价值。
- en: '***Countermeasures***    Price manipulation exploits take advantage of on-chain
    calculations of a token''s value. Contracts can avoid slippage by using Chainlink
    or similar price oracles.  ***Case Studies***    In October 2021, Cream Finance
    was exploited for over $130 million in tokens.[^(38)](#c05-note-0038) The attack
    began with a flashloan and included a loop of depositing tokens into Cream and
    using the deposit as collateral for another borrow. One of the attacking contracts
    accrued approximately 1.5 billion in crYUSD and ~500 million in yUSDVault tokens.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***   价格操纵利用链上代币价值的计算。合同可以通过使用Chainlink或类似的价格预言机来避免滑点。   ***案例研究***   2021年10月，Cream
    Finance被利用，代币损失超过1.3亿美元。[^(38)](#c05-note-0038) 攻击始于一笔闪电贷，并包括将代币存入Cream并使用存款作为另一笔借款的抵押品的循环。其中一个攻击合同积累了大约15亿crYUSD和约5亿yUSDVault代币。'
- en: 'The attacker deposited the yUSDVault tokens to extract yUSD and decrease the
    total supply of tokens in the vault to $8 million. A deposit of $8 million in
    yUSD then doubled the vault''s total supply and the perceived value of crYUSD
    tokens. The attacker was able to use its now roughly $3 billion in crYUSD tokens
    to pay off its flashloans and extract $130 million from the vault.  ##### NFT
    Vulnerabilities'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者存入yUSDVault代币以提取yUSD，并减少保管库中代币的总供应量至800万美元。在yUSD中存入800万美元后，保管库的总供应量翻了一番，crYUSD代币的公认价值也翻了一番。攻击者能够使用其现在大约30亿美元的crYUSD代币来偿还闪电贷，并从保管库中提取1.3亿美元。#####
    NFT漏洞
- en: 'Tokens hosted on a smart contract platform can be divided into two main categories:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在智能合约平台上的代币可以分为两大类：
- en: '**Fungible:** Tokens are completely interchangeable. For example, a dollar
    bill is fungible because one bill has the same value as another.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同质化：** 代币完全可互换。例如，美元钞票是同质化的，因为一张钞票与另一张具有相同的价值。'
- en: '**Non-Fungible:** A particular token has a unique, inherent value. For example,
    one baseball card might be worth much more than another despite the fact that
    they are both ink on paper.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非同质化：** 某个特定的代币具有独一无二的内在价值。例如，一张棒球卡可能比另一张价值高得多，尽管它们都只是纸上的墨水。'
- en: In blockchain, non-fungible tokens (NFTs) can be used to perform blockchain-based
    tracking. For example, the most common application of NFTs today is to track ownership
    of digital art. However, NFTs can also be used for logistics, identity management,
    and other purposes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链上，非同质化代币（NFTs）可以用来执行基于区块链的追踪。例如，NFTs今天最常用的应用之一就是追踪数字艺术的所有权。然而，NFTs也可以用于物流、身份管理等其他目的。
- en: 'NFTs have a lot of potential, but they also have security issues. Some of the
    major security concerns of NFTs today are as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: NFTs具有很大潜力，但它们也存在安全问题。NFTs今天面临的一些主要安全担忧如下：
- en: Forged NFTs
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪造的NFTs
- en: Malicious NFTs
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意NFTs
- en: Off-Chain Asset Storage
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离链资产存储
- en: Platform Centralization
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台集中化
- en: Unconstrained Token Supply
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不受约束的代币供应
- en: '###### *Forged NFTs*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '###### **伪造的NFTs**'
- en: NFTs are designed to track ownership of an asset on the blockchain. This ownership
    can then be transferred by sending the NFT between wallets. However, NFTs are
    based on the assumption that the creator of the NFT actually owns the asset and
    has the right to create the NFT.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: NFTs被设计用来追踪区块链上的资产所有权。然后，可以通过将NFT在钱包之间发送来转移所有权。然而，NFT基于这样一个假设，即NFT的创建者实际上拥有该资产并有权创建NFT。
- en: Currently, most NFTs are supposed to track ownership of digital artwork. Forged
    NFTs are created without the knowledge and consent of the artist or current owner
    of the artwork, meaning that they have no inherent value.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数NFT都应该是用来追踪数字艺术作品的所有权。伪造的NFT是在艺术家或艺术作品当前所有者不知情和未经同意的情况下创建的，这意味着它们没有固有的价值。
- en: '***Countermeasures***    Validating the authenticity of NFTs is difficult because
    it likely requires verification of the asset by its owner. However, performing
    background research on an NFT offering may help with determining if it seems legitimate
    or suspicious.  ***Case Study***    In March 2021, artist Derek Laufman learned
    that a verified profile impersonating him on the Rarible NFT marketplace was selling
    NFTs of his art without his knowledge.[^(39)](#c05-note-0039) Although Rarible
    took the account down after it was brought to their attention, at least one fan
    had already bought an NFT of his work.  ###### *Malicious NFTs*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策**：验证NFT的真实性是困难的，因为这可能需要验证资产的所有者。然而，对NFT发行进行背景研究可能有助于确定它看起来是合法的还是可疑的。**案例研究**：2021年3月，艺术家Derek
    Laufman发现，在Rarible NFT市场的一个经过验证的账户冒充他，在未经他同意的情况下出售他的艺术作品。[^(39)](#c05-note-0039)尽管Rarible在注意到这一点后关闭了该账户，但至少有一个粉丝已经购买了他作品的一个NFT。######
    **恶意NFTs**'
- en: Most modern NFTs are designed to track ownership of digital art. To view the
    art, a user needs to follow the link embedded in the NFT, which makes them an
    ideal vehicle for phishing attacks.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代的NFT都是为了追踪数字艺术的所有权而设计的。要查看艺术品，用户需要点击嵌入在NFT中的链接，这使得它们成为网络钓鱼攻击的理想工具。
- en: Malicious NFTs could be designed to use social engineering to trick users into
    handing over their credentials for an NFT platform like OpenSea or the private
    key of their blockchain account. If successful, the attacker could then use this
    access to steal tokens and NFTs from the user's account.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意NFT可能会被设计用来利用社交工程，诱使用户向像OpenSea这样的NFT平台或其区块链账户的私钥交出他们的凭证。如果成功，攻击者然后可以利用这种访问权限从用户的账户中窃取代币和NFT。
- en: '***Countermeasures***    Malicious NFTs are image files that contain malicious
    code. Scanning image files for such code before opening them can help to protect
    against this attack.  ***Case Study***    In October 2021, Check Point Research
    discovered vulnerabilities in OpenSea that would allow for malicious NFTs attacks.[^(40)](#c05-note-0040)
    Carefully crafted CVG files could be used to create pop-ups that would prompt
    the user to take actions that could reveal their credentials or private key. There
    is no indication that this vulnerability was exploited, and OpenSea remediated
    it on its platform.  ###### *Off-Chain Asset Storage*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**对策**：恶意NFT是包含恶意代码的图片文件。在打开这些图片文件之前扫描其中的代码可以帮助防御这种攻击。**案例研究**：2021年10月，Check
    Point Research在OpenSea发现了漏洞，这些漏洞可能允许恶意NFT攻击。[^(40)](#c05-note-0040)精心制作的CVG文件可能被用来创建弹窗，提示用户采取可能暴露其凭证或私钥的行动。目前尚无迹象表明这一漏洞被利用，OpenSea在其平台上进行了修复。######
    **离链资产存储**'
- en: Blockchains are designed to be immutable digital ledgers, meaning that bloat
    is a significant concern. Any data stored on the blockchain must be stored indefinitely
    by every node in the blockchain network.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链被设计成不可变的数字账本，这意味着膨胀是一个重要问题。区块链网络上每个节点都必须无限期地存储在区块链上存储的所有数据。
- en: For this reason, NFTs are not stored directly on the blockchain's digital ledger.
    Instead, an NFT contains a URL that points to the associated image or the hash
    of that image on Interplanetary Filesystem (IPFS), a decentralized storage system.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NFT并没有直接存储在区块链的数字账本上。相反，NFT包含一个指向关联图片或该图片在星际文件系统（IPFS）上的哈希值的URL。
- en: This design means that an NFT does not indicate ownership of a piece of digital
    art so much as a particular URL or IPFS hash. The image at a particular URL or
    IPFS hash may be taken down or (in the case of URLs) changed. If this is the case,
    then the NFT loses its value.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计意味着，NFT并不表示数字艺术的所有权，而是一个特定的URL或IPFS哈希值。特定URL或IPFS哈希值上的图片可能会被移除或（在URL的情况下）被更改。如果是这样，那么NFT就会失去其价值。
- en: '***Countermeasures***    For owners of NFTs hosted on IPFS, the owner of a
    token could take over the role of the IPFS gateway that hosts a copy of their
    NFT. However, URL-based NFTs could be taken down or replaced with another file
    at any time.  ***Case Study***    Multiple NFT platforms have taken down forged
    NFTs that infringed on the rights of the real owners of the content. For example,
    Cent shut down sales of many NFTs in February 2022 due to “rampant fakes and plagiarism.”[^(41)](#c05-note-0041)  ######
    *Platform Centralization*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    对于存储在IPFS上的NFT的所有者，代币的所有者可能接管了托管他们NFT的IPFS网关的角色。然而，基于URL的NFT可能随时被移除或用另一个文件替换。  ***案例研究***    多个NFT平台已经下架了侵犯真实内容所有者权利的伪造NFT。例如，Cent在2022年2月因“猖獗的假货和剽窃”而下架了许多NFT。  ######
    *平台中心化*'
- en: While NFTs are stored on the blockchain, most users interact with them via a
    web frontend. This makes managing NFTs more convenient but also introduces new
    vulnerabilities.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NFT存储在区块链上，但大多数用户是通过网页前端与之互动的。这使得管理NFT更加方便，但也引入了新的漏洞。
- en: These NFT platforms are centralized and introduce the same vulnerabilities as
    DeFi web frontends. Attackers could take down a website with a DDoS attack or
    embed malicious content in it to steal users' private keys or NFTs.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这些NFT平台是中心化的，它们引入了与DeFi前端相同的漏洞。攻击者可以通过DDoS攻击接管一个网站，或者在其中嵌入恶意内容以窃取用户的私钥或NFT。
- en: '***Countermeasures***    As in the DeFi space, frontend vulnerabilities should
    be addressed during a security audit. This includes testing for web application
    vulnerabilities in the web frontend and validating the business logic of the frontend,
    backend, and interfaces between them.  ***Case Study***    In January 2022, OpenSea
    users were the victims of a hack that exploited miscommunications between the
    platform''s web frontend and smart contract backend.[^(42)](#c05-note-0042) Users
    believed that they were delisting NFTs when they were transferred between wallets
    because they were no longer listed for sale on the web frontend. However, these
    transactions were not recorded in the smart contract backend. An attacker sent
    transactions directly to the smart contract to buy these tokens at earlier sale
    prices well under the market rate.  ###### *Unconstrained Token Supply*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策***    正如在DeFi领域中一样，在前端进行安全审计时应解决前端漏洞问题。这包括测试web前端中的网络应用漏洞，以及验证前端、后端和它们之间的接口的业务逻辑。***案例研究***    2022年1月，OpenSea用户成为了一个利用平台web前端和智能合约后端之间通信失误的黑客攻击的受害者。[^(42)](#c05-note-0042)用户认为他们在钱包之间转移NFT时，因为不再在web前端列出来售，所以正在取消上市。然而，这些交易并没有记录在智能合约后端。攻击者直接向智能合约发送交易，以远低于市场价格的早期销售价格购买这些代币。  ######
    *无约束的代币供应*'
- en: Many modern NFTs are instances of generative art, where an algorithm puts together
    sets of building blocks in various different ways. Many NFT collections derive
    at least some of their value from the fact that only a certain number of the NFTs
    exist in the collection. The scarcity of the asset drives up the value.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代NFT是生成艺术实例，其中算法以各种不同方式组合一套构建模块。许多NFT系列至少部分价值来源于这样一个事实：即该系列中只有特定数量的NFT。这种资产的稀缺性推高了其价值。
- en: However, not all NFT smart contracts enforce these limits. The following code
    sample is a function from the Bored Apes Yacht Club (BAYC) contract,[^(43)](#c05-note-0043)
    a popular NFT collection.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有NFT智能合约都执行这些限制。以下代码样本是Bored Apes Yacht Club (BAYC)合约中的一个函数：[^(43)](#c05-note-0043)，这是一个流行的NFT系列。
- en: '[PRE26]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `reserveApes` function allows the owner of the BAYC to mint 30 new NFTs
    whenever they choose. By updating the URI indicated by the function, they could
    also add 30 new images to the collection.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`reserveApes`函数允许BAYC的所有者随时铸造30个新的NFT。通过更新函数指示的URI，他们还可以向收藏中添加30张新图片。
- en: Like `mint` functions in DeFi, this runs the risk of devaluing existing NFTs.
    This would likely either cause these tokens to lose all value or allow the contract
    owner to create and sell valuable NFTs at will. This vulnerability could be triggered
    by the contract creator or an attacker exploiting an access control vulnerability.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与DeFi中的`mint`函数一样，这存在贬值现有NFT的风险。这可能会导致这些代币失去所有价值，或允许合约所有者随意创建和销售有价值的NFT。这种漏洞可能由合约创建者或利用访问控制漏洞的攻击者触发。
- en: '***Countermeasures***    NFT minting contracts should have built-in controls
    that limit the quantity of NFTs within a collection. If expansions are expected
    in the future, they should be governed by code that prevents unauthorized changes.  ###
    Threat Modeling for Smart Contracts'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '***对策*** NFT铸造合约应具有内置控制，限制集合中的NFT数量。如果未来预期有扩展，它们应由代码管理，防止未经授权的更改。### 智能合约的威胁建模'
- en: 'Vulnerabilities in smart contracts can be mapped to all categories of the STRIDE
    threat model, as in the following examples:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约中的漏洞可以映射到STRIDE威胁模型的所有类别，如下例所示：
- en: '**Spoofing:** Smart contract vulnerabilities can be used for spoofing in various
    ways. For example, Solidity''s delegatecall allows a malicious contract to masquerade
    as another contract, and signature vulnerabilities can allow forged transactions
    to be accepted or even reveal private keys.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仿冒:**智能合约的漏洞可以以多种方式用于仿冒。例如，Solidity的delegatecall允许恶意合约伪装成另一个合约，签名漏洞可以允许伪造的交易被接受，甚至揭示私钥。'
- en: '**Tampering:** Reentrancy and `delegatecall` vulnerabilities allow an attacker
    to tamper with the internal state of vulnerable smart contracts.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改:**重入性和`delegatecall`漏洞允许攻击者篡改易受攻击的智能合约的内部状态。'
- en: '**Repudiation:** Rollback attacks allow an attacker to undo actions before
    their results are recorded on the digital ledger.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否认:**回滚攻击允许攻击者在数字账本记录结果之前撤销操作。'
- en: '**Information Disclosure:** Exposure of private keys due to signature errors
    could allow an attacker to decrypt encrypted messages intended for a user. Also,
    many bad randomness vulnerabilities are based on the public visibility of information
    that the contract wished to be private.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息泄露:**由于签名错误导致的私钥暴露可能允许攻击者解密旨在发送给用户的加密消息。此外，许多糟糕的随机性漏洞都是基于合约希望保持私有的信息的可公开可见性。'
- en: '**Denial of Service:** Many denial-of-service vulnerabilities exist in smart
    contracts, such as Ethereum''s block gas limits and unexpected reversion vulnerabilities.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务拒绝:** 智能合约中存在许多服务拒绝漏洞，例如以太坊的区块气体限制和意外回滚漏洞。'
- en: '**Elevation of Privileges:** Access control vulnerabilities give an attacker
    privileged access to protected functions within a smart contract.  ## Blockchain
    Extensions'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升:**访问控制漏洞赋予攻击者对智能合约中受保护功能的特权访问。## 区块链扩展'
- en: Smart contracts build on the basic blockchain protocol and have dramatically
    expanded its functionality. With applications like DeFi, blockchain has expanded
    from a decentralized system for tracking financial transactions to a fully functional
    financial system.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约建立在基本的区块链协议之上，极大地扩展了其功能。随着DeFi等应用的发展，区块链已经从跟踪金融交易的分布式系统扩展到一个完全功能的金融系统。
- en: However, the capabilities of smart contracts are limited by the infrastructure
    that they run on. For example, blockchains like Ethereum have relatively low transaction
    rates (15 per second). This limits the number of transactions that can be performed
    on this platform and the scalability of the system.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能合约的能力受到它们运行的基础设施的限制。例如，像以太坊这样的区块链具有相对较低的交易率（每秒15笔）。这限制了在此平台上可以执行的交易数量和系统的可扩展性。
- en: 'Layer 2 protocols are built on top of Layer 1 blockchains (Ethereum, Bitcoin,
    etc.) and expand their functionality and scalability. Some common layer 2 protocols
    are as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 层2协议建立在层1区块链（以太坊、比特币等）之上，扩展了其功能和可扩展性。一些常见的层2协议如下：
- en: State channels
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态通道
- en: Sidechains and bridges
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧链和桥梁
- en: '### State Channels'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '### 状态通道'
- en: A state channel is a Layer 2 protocol that creates a direct payment channel
    between two blockchain accounts. State channels are set up and taken down by transactions
    recorded on the blockchain's digital ledger, but all intermediate transactions
    are performed off chain. Well-known examples of state channels include Bitcoin's
    Lightning Network and Ethereum's Raiden Network.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道是创建两个区块链账户之间直接支付通道的第二层协议。状态通道是通过记录在区块链数字账本上的交易建立和拆除的，但所有中间交易都是在链下执行的。状态通道的知名例子包括比特币的闪电网络和以太坊的雷登网络。
- en: At any point in time, both parties in a state channel have a signed commitment
    from the other about the current allocation of funds in the channel. A channel
    is set up by creating these mutual commitments and sending the balance stored
    in the channel to an address that locks it until the channel is closed.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间点，状态通道中的双方都有一个关于通道中资金当前分配的对方签署的承诺。通道是通过创建这些共同承诺并将通道中存储的余额发送到一个地址来建立的，该地址在通道关闭前锁定它。
- en: Payments are performed by exchanging new versions of these commitments that
    reallocate the funds within a channel. The channel can be closed if one or both
    parties publish a mutually signed commitment as a transaction on the blockchain.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 支付是通过交换这些承诺的新版本来完成的，这些新版本在通道内重新分配资金。如果一方或双方发布一个彼此签署的承诺作为一个区块链上的交易，通道就可以关闭。
- en: If a user unilaterally closes the channel, the other participant has a set period
    of time in which to submit a more recent version of the commitment. If this occurs,
    then the defrauded party receives the full balance of the channel. If not, the
    timelocked funds are unlocked and distributed based upon the published commitment.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户单方面关闭通道，另一方有设定的一段时间来提交一个更近期的承诺版本。如果这样发生，那么受骗的一方将获得通道中的全部余额。如果没有，时间锁定的资金将被解锁并根据发布的承诺进行分配。
- en: State channels allow payments between parties that lack a direct channel between
    them. This is accomplished by routing payments through a series of channels that
    link the two parties. These transactions are crafted so that the balance updates
    with intermediate parties are only approved once the recipient acknowledges receipt
    of the transaction. Additionally, intermediate channel providers may charge a
    fee for the use of their channels.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道允许两个缺乏直接通道的当事人之间进行支付。这是通过将支付路由通过一系列连接这两个当事人的通道来完成的。这些交易设计得如此精巧，以至于中间当事人的余额更新只有在收款人确认收到交易后才会被批准。此外，中间通道提供商可能会对其通道的使用收取费用。
- en: '#### *State Channel Security Considerations*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *状态通道安全考虑*'
- en: 'State channels rely on many of the same security assumptions as other blockchain
    technologies, such as the security of digital signature algorithms. However, the
    use of state channels also introduces other potential security risks:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道依赖于许多与其他区块链技术相同的的安全假设，比如数字签名算法的安全性。然而，状态通道的使用也引入了其他潜在的安全风险：
- en: Denial-of-service attacks
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务拒绝攻击
- en: Timelock exploits
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间锁利用
- en: '##### Denial-of-Service Attacks'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 服务拒绝攻击'
- en: State channels can only process payments if a route exists between the two parties
    that has sufficient liquidity. For example, Alice can't send 1 Bitcoin to Bob
    if the current balance of value in their channel only allocates 0.9 BTC to her.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在两个当事人之间存在足够流动性的路由时，状态通道才能处理支付。例如，如果爱丽丝和他们通道中的当前余额只分配了0.9 BTC给她，那么她就不能向鲍勃发送1比特币。
- en: 'Attackers can take advantage of this fact to perform denial-of-service (DoS)
    attacks on a state channel network. If an attacker can perform a DoS attack against
    crucial nodes in a state channel network or unbalance state channels, they can
    prevent value from being transferred to/from a particular user.  ##### Timelock
    Exploits'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '攻击者可以利用这个事实对状态通道网络执行服务拒绝（DoS）攻击。如果攻击者能够对状态通道网络中的关键节点执行DoS攻击或失衡状态通道，他们就可以防止特定用户的价值被转移。  #####
    时间锁利用'
- en: State channels can be closed unilaterally by one of the channel participants.
    However, a timelock exists on the closure, which can allow the other participant
    to generate a punishment transaction that allows them to claim the value in the
    channel.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道可以被通道参与者之一单方面关闭。然而，关闭上有一个时间锁，这可以让另一方生成一个惩罚交易，让他们声称通道中的价值。
- en: 'However, this transaction must be submitted and processed within the timelock
    to take effect before funds are released. If this transaction is delayed due to
    an eclipse/routing attack, malicious miner, and so on, then the victim can lose
    funds.[^(44)](#c05-note-0044)  ### Sidechains'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这一交易必须在时间锁内提交和处理，以在释放资金前生效。如果由于日食/路由攻击、恶意矿工等原因导致这笔交易延迟，那么受害者可能会失去资金。[^(44)](#c05-note-0044)  ###
    侧链'
- en: Every blockchain protocol has its advantages and limitations. For example, Bitcoin
    has robust security due to a massive amount of hashpower supporting its Proof
    of Work consensus algorithm. However, Bitcoin has limited throughput and no support
    for smart contracts. Other blockchains may have greater scalability and smart
    contract support but lack the security and name recognition of Bitcoin.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块链协议都有其优势和局限性。例如，比特币由于其工作量证明共识算法支持大量哈希能力，因此具有强大的安全性。然而，比特币的吞吐量有限，不支持智能合约。其他区块链可能具有更大的可扩展性和智能合约支持，但缺乏比特币的安全性和知名度。
- en: Sidechains attempt to address these issues by creating relationships between
    different blockchains. These links allow users to send tokens to a locking address
    on one blockchain and have an equivalent number of tokens released on another.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链试图通过创建不同区块链之间的关系来解决这些问题。这些链接允许用户将代币发送到一个区块链上的锁定地址，并在另一个区块链上释放等量的代币。
- en: 'Sidechains can be implemented in a few different ways:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链可以通过几种不同的方式实现：
- en: '**Bridges:** Bridges enable links between independent blockchains. For example,
    Anyswap, Binance Bridge, and Wormhole are examples of major bridges.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥梁:**桥梁使独立的区块链之间建立链接。例如，Anyswap、Binance Bridge和Wormhole是主要的桥梁。'
- en: '**Child Chains:** Child chains are blockchains that add scalability and features
    to a blockchain. They have their own methods of creating and validating blocks
    but use the parent blockchain to resolve disputes. Plasma creates child chains
    for the Ethereum blockchain.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子链:**子链是增加区块链可扩展性和功能的区块链。它们有自己的创建和验证区块的方法，但使用父链来解决争端。Plasma为以太坊区块链创建子链。'
- en: '#### *Sidechain Security Considerations*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *侧链安全考虑*'
- en: 'Sidechains enable interoperability between different blockchains via a mediator.
    This design creates potential security concerns:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链通过中介实现不同区块链之间的互操作性。这种设计创造了潜在的安全问题：
- en: Centralized bridges
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心化桥梁
- en: Independent chain security
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立链安全
- en: Interface errors
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口错误
- en: Vulnerable bridges
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的桥梁
- en: '##### Centralized Bridges'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 中心化桥梁'
- en: A bridge linking two sidechains creates a high degree of centralization. Its
    users rely solely on the bridge to transfer assets between the two chains.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 连接两个侧链的桥梁创造了高度的集中度。其用户完全依赖桥梁在两条链之间转移资产。
- en: This degree of centralization creates significant security risks. A denial-of-service
    attack against the bridge could render it inaccessible to users, or an attacker
    could exploit the bridge to steal tokens from users or manipulate their value.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这种程度的中心化创造了重大的安全风险。针对桥的对服务攻击可能使桥对用户不可用，或者攻击者可能利用桥从用户那里窃取代币或操纵其价值。
- en: In February 2022, the Meter.io bridge was the victim of an attack that exploited
    an incorrect assumption in how the bridge handled wrapped tokens.[^(45)](#c05-note-0045)
    By exploiting this vulnerability, the attackers were able to make fake deposits
    into the bridge and then withdraw real tokens.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年2月，Meter.io桥遭到了攻击，该攻击利用了桥处理包装代币的假设错误。[^(45)](#c05-note-0045)通过利用这个漏洞，攻击者能够向桥中伪造存款，然后提取真实代币。
- en: 'This vulnerability decreased the value of BNB.bsc on the BNB Chain. This allowed
    attackers to buy this token at low rates and use it as collateral for loans from
    Hunter Finance, which used Chainlink''s prices for the asset.[^(46)](#c05-note-0046)
    Although some of these loans were repaid, the project lost $3.3 million.  #####
    Independent Chain Security'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这一漏洞导致BNB.bsc在BNB链上的价值下降。这使得攻击者可以以低价购买这种代币，并将其作为从Hunter Finance获得的贷款的抵押品，该贷款使用Chainlink的资产价格。[^(46)](#c05-note-0046)尽管其中一些贷款得到了偿还，但该项目损失了330万美元。#####
    独立链安全
- en: Sidechains create links between blockchains, but each blockchain has its own
    security. For example, a peg between Bitcoin and another chain does not grant
    the sidechain Bitcoin's protection against 51% attacks.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链创建了区块链之间的链接，但每个区块链都有自己的安全性。例如，比特币与另一条链之间的peg并不会授予侧链比特币对抗51%攻击的保护。
- en: 'If a sidechain is the victim of a 51% or other attack, this can affect the
    exchange rate of tokens between the two chains. This occurred in the Meter.io
    hack where BNB.bsc was devalued on BNB Chain.  ##### Interface Errors'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果侧链成为51%或其他攻击的受害者，这可能会影响两条链上代币的汇率。这发生在Meter.io黑客攻击中，其中BNB.bsc在BNB链上被贬值。#####
    接口错误
- en: In theory, a bridge between sidechains will allow users to lock tokens on one
    blockchain, which will unlock tokens on the other. However, this exchange might
    not work as designed, especially if the bridge contract contains exploitable vulnerabilities.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，侧链之间的桥梁将允许用户在一个区块链上锁定代币，从而在另一个区块链上解锁代币。然而，这种交换可能不会像设计的那样工作，特别是如果桥梁合约包含可利用的漏洞。
- en: 'This was the case in the hack of Qubit''s QBridge in January 2022.[^(47)](#c05-note-0047)
    A vulnerability in the bridge''s smart contract on the Ethereum blockchain enabled
    an attacker to trick it with a fake deposit of WETH. The bridge accepted the fake
    deposit and released qXETh tokens for the attacker on BNB Chain.  ##### Vulnerable
    Bridges'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是2022年1月Qubit的QBridge被黑的情况。[^(47)](#c05-note-0047) Ethereum区块链上桥梁的智能合约中的一个漏洞允许攻击者用假的WETH存款欺骗它。桥梁接受了假的存款，并在BNB链上为攻击者释放了qXETh代币。#####
    脆弱的桥梁
- en: Some links between sidechains are implemented as smart contracts that monitor
    operations on one blockchain and respond to them accordingly. If these smart contracts
    contain exploitable vulnerabilities, an attacker may be able to exploit these
    vulnerabilities to steal tokens from a bridge contract or disrupt its operations.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 一些侧链之间的链接作为智能合约实现，监控一个区块链上的操作并相应地响应。如果这些智能合约包含可利用的漏洞，攻击者可能能够利用这些漏洞从桥接合约中窃取代币或干扰其运行。
- en: 'The hack of the Wormhole bridge in February 2022 was the second most expensive
    DeFi hack at the time, allowing the attacker to steal $326 million in wETH from
    the bridge. The attacker exploited a signature verification vulnerability, which
    involved tricking the contract into believing that a signature had been successfully
    verified when it had not.[^(48)](#c05-note-0048) This allowed the attacker to
    mint 120,000 ETH tokens, which they then “legitimately” withdrew from the bridge
    contract.  ### Threat Modeling for Blockchain Extensions'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年2月Wormhole桥梁的黑客攻击是当时第二昂贵的DeFi黑客攻击，允许攻击者从桥梁中窃取3.26亿美元的wETH。攻击者利用了一个签名验证漏洞，涉及欺骗合约相信签名已经成功验证，而实际上并没有。[^(48)](#c05-note-0048)
    这使得攻击者能够铸造120,000 ETH代币，然后“合法地”从合约中提取。##### 区块链扩展的威胁建模
- en: 'Attacks against state channels and sidechains can be mapped to several STRIDE
    threat categories:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 针对状态通道和侧链的攻击可以映射到几个STRIDE威胁类别：
- en: '**Tampering:** Timelock exploits allow an attacker to delete part of the history
    of a state channel.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改:**时间锁利用允许攻击者删除状态通道历史的一部分。'
- en: '**Repudiation:** Timelock exploits in state channels can allow an attacker
    to undo transactions performed in these channels.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否认:**状态通道中的时间锁利用可以允许攻击者撤销在这些通道中执行的交易。'
- en: '**Denial of Service:** Denial-of-service attacks on state channels or bridges
    can impact accessibility to legitimate users.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务拒绝:**对状态通道或桥梁的服务拒绝攻击可能影响合法用户的访问。'
- en: '**Elevation of Privileges:** Vulnerabilities in bridge code could grant an
    attacker control over transfers between sidechains.  ## Conclusion'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升:**桥梁代码中的漏洞可能授予攻击者控制侧链之间转移的权限。## 结论'
- en: Smart contracts and blockchain extensions dramatically extend the functionality
    of blockchain protocols but also create additional complexity and risk. Most attacks
    against blockchain systems occur at these levels as attackers take advantage of
    design flaws or implementation errors in the protocols and programs.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约和区块链扩展极大地扩展了区块链协议的功能，但也创造了额外的复杂性和风险。大多数针对区块链系统的攻击发生在这些层面，因为攻击者利用协议和程序中的设计缺陷或实现错误。
- en: 'This concludes our exploration of vulnerabilities and security risks at the
    various levels of the blockchain ecosystem. The next chapter discusses best practices
    for securely designing, implementing, and auditing blockchain-based systems.  ##
    Notes'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对区块链生态系统各个层次的漏洞和安全风险的探讨。下一章讨论了安全设计、实现和审计基于区块链的系统的最佳实践。## 注释
- en: 1.  [1](#R_c05-note-0001).  `[https://peckshield.medium.com/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536](https://peckshield.medium.com/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536)`
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#R_c05-note-0002).  `[https://twitter.com/PizzaProFi/status/1468869822389768192](https://twitter.com/PizzaProFi/status/1468869822389768192)`'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3](#R_c05-note-0003).  `[https://medium.com/multichainorg/anyswap-multichain-router-v3-exploit-statement-6833f1b7e6fb](https://medium.com/multichainorg/anyswap-multichain-router-v3-exploit-statement-6833f1b7e6fb)`'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4](#R_c05-note-0004).  `[www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct](https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct)`'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[5](#R_c05-note-0005).  `[https://skylightcyber.com/2019/05/12/ethereum-smart-contracts-exploitation-using-right-to-left-override-character](https://skylightcyber.com/2019/05/12/ethereum-smart-contracts-exploitation-using-right-to-left-override-character)`'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[6](#R_c05-note-0006).  `[https://slowmist.medium.com/the-root-cause-of-poly-network-being-hacked-ec2ee1b0c68f](https://slowmist.medium.com/the-root-cause-of-poly-network-being-hacked-ec2ee1b0c68f)`'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[7](#R_c05-note-0007).  `[https://dasp.co](https://dasp.co)`'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[8](#R_c05-note-0008).  `[www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked](https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked)`'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9](#R_c05-note-0009).  `[https://sia.tech/ddos2021](https://sia.tech/ddos2021)`'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#R_c05-note-0010). `[https://hacked.slowmist.io/en/search](https://hacked.slowmist.io/en/search)`'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#R_c05-note-0011). `[https://medium.com/punkprotocol/punk-finance-fair-launch-incident-report-984d9e340eb](https://medium.com/punkprotocol/punk-finance-fair-launch-incident-report-984d9e340eb)`'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#R_c05-note-0012). `[https://dodoexhelp.zendesk.com/hc/en-us/articles/900004851126-Important-update-regarding-recent-events-on-DODO](https://dodoexhelp.zendesk.com/hc/en-us/articles/900004851126-Important-update-regarding-recent-events-on-DODO)`'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#R_c05-note-0013). `[https://slowmist.medium.com/roll-back-attack-about-blacklist-in-eos-adf53edd8d69](https://slowmist.medium.com/roll-back-attack-about-blacklist-in-eos-adf53edd8d69)`'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#R_c05-note-0014). `[https://eprint.iacr.org/2016/1007.pdf](https://eprint.iacr.org/2016/1007.pdf)`'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[15](#R_c05-note-0015). `[https://eprint.iacr.org/2016/1007.pdf](https://eprint.iacr.org/2016/1007.pdf)`'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16](#R_c05-note-0016). `[https://github.com/kieranelby/KingOfTheEtherThrone/blob/v1.0/contracts/KingOfTheEtherThrone.sol](https://github.com/kieranelby/KingOfTheEtherThrone/blob/v1.0/contracts/KingOfTheEtherThrone.sol)`'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17](#R_c05-note-0017). `[https://consensys.github.io/smart-contract-best-practices/attacks/force-feeding](https://consensys.github.io/smart-contract-best-practices/attacks/force-feeding)`'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18](#R_c05-note-0018). `[https://medium.com/@nmcl/gridlock-a-smart-contract-bug-73b8310608a9](https://medium.com/@nmcl/gridlock-a-smart-contract-bug-73b8310608a9)`'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[19](#R_c05-note-0019). `[https://blocksecteam.medium.com/when-safetransfer-becomes-unsafe-lesson-from-the-qbridge-security-incident-c32ecd3ce9da](https://blocksecteam.medium.com/when-safetransfer-becomes-unsafe-lesson-from-the-qbridge-security-incident-c32ecd3ce9da)`'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20](#R_c05-note-0020). `[https://medium.com/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee](https://medium.com/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee)`'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[21](#R_c05-note-0021). `[https://eips.ethereum.org/EIPS/eip-20](https://eips.ethereum.org/EIPS/eip-20)`'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[22](#R_c05-note-0022). `[https://blog.forcedao.com/xforce-exploit-post-mortem-7fa9dcba2ac3](https://blog.forcedao.com/xforce-exploit-post-mortem-7fa9dcba2ac3)`'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23](#R_c05-note-0023). `[www.kingoftheether.com/postmortem.html](https://www.kingoftheether.com/postmortem.html)`'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24](#R_c05-note-0024). `[https://cmichel.io/replaying-ethereum-hacks-furucombo](https://cmichel.io/replaying-ethereum-hacks-furucombo)`'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25](#R_c05-note-0025). `[https://cmichel.io/eos-1-3-contract-development-toolkit-updates](https://cmichel.io/eos-1-3-contract-development-toolkit-updates)`'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26](#R_c05-note-0026). `[www.reddit.com/r/eos/comments/9fpcik/how_eosbet_attacked_by_aabbccddeefg](https://www.reddit.com/r/eos/comments/9fpcik/how_eosbet_attacked_by_aabbccddeefg)`'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27](#R_c05-note-0027). `[https://github.com/slowmist/eos-smart-contract-security-best-practices/blob/master/README_EN.md#transfer-error-prompt](https://github.com/slowmist/eos-smart-contract-security-best-practices/blob/master/README_EN.md#transfer-error-prompt)`'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[28](#R_c05-note-0028). `[https://blog.peckshield.com/2018/10/26/eos](https://blog.peckshield.com/2018/10/26/eos)`'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29](#R_c05-note-0029). `[https://cmichel.io/eos-vault-sx-hack](https://cmichel.io/eos-vault-sx-hack)`'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30](#R_c05-note-0030). `[https://cmichel.io/eos-vault-sx-hack](https://cmichel.io/eos-vault-sx-hack)`'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31](#R_c05-note-0031). `[https://developers.eos.io/welcome/v2.1/protocol-guides/transactions_protocol](https://developers.eos.io/welcome/v2.1/protocol-guides/transactions_protocol)`'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32](#R_c05-note-0032). `[https://twitter.com/RugDocIO/status/1451067795140005891](https://twitter.com/RugDocIO/status/1451067795140005891)`'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33](#R_c05-note-0033). `[https://twitter.com/peckshield/status/1462165620506742784](https://twitter.com/peckshield/status/1462165620506742784)`'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34](#R_c05-note-0034). `[https://letmeape.medium.com/how-to-spot-a-potential-rug-clear-signs-something-is-sketchy-169fb84c7084#59e7](https://letmeape.medium.com/how-to-spot-a-potential-rug-clear-signs-something-is-sketchy-169fb84c7084#59e7)`'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35](#R_c05-note-0035). `[https://bzx.network/blog/prelminary-post-mortem](https://bzx.network/blog/prelminary-post-mortem)`'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36](#R_c05-note-0036). `[https://rekt.news/badger-rekt](https://rekt.news/badger-rekt)`'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37](#R_c05-note-0037). `[https://peckshield.medium.com/the-spartan-incident-root-cause-analysis-a0324cb4b42a](https://peckshield.medium.com/the-spartan-incident-root-cause-analysis-a0324cb4b42a)`'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38](#R_c05-note-0038). `[https://rekt.news/cream-rekt-2](https://rekt.news/cream-rekt-2)`'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[39](#R_c05-note-0039). `[www.theverge.com/2021/3/20/22334527/nft-scams-artists-opensea-rarible-marble-cards-fraud-art](https://www.theverge.com/2021/3/20/22334527/nft-scams-artists-opensea-rarible-marble-cards-fraud-art)`'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40](#R_c05-note-0040). `[https://gizmodo.com/gullible-opensea-users-were-vulnerable-to-malicious-nft-1847850437](https://gizmodo.com/gullible-opensea-users-were-vulnerable-to-malicious-nft-1847850437)`'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[41](#R_c05-note-0041). `[www.reuters.com/business/finance/nft-marketplace-shuts-citing-rampant-fakes-plagiarism-problem-2022-02-11](https://www.reuters.com/business/finance/nft-marketplace-shuts-citing-rampant-fakes-plagiarism-problem-2022-02-11)`'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42](#R_c05-note-0042). `[https://decrypt.co/91076/opensea-exploit-sees-bored-ape-yacht-club-nft-sell-1700](https://decrypt.co/91076/opensea-exploit-sees-bored-ape-yacht-club-nft-sell-1700)`'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43](#R_c05-note-0043). `[https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code](https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code)`'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44](#R_c05-note-0044). `[www.coindesk.com/tech/2020/10/27/4-bitcoin-lightning-network-vulnerabilities-that-havent-been-exploited-yet](https://www.coindesk.com/tech/2020/10/27/4-bitcoin-lightning-network-vulnerabilities-that-havent-been-exploited-yet)`'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45](#R_c05-note-0045). `[https://twitter.com/ishwinder/status/1490227406824685569](https://twitter.com/ishwinder/status/1490227406824685569)`'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46](#R_c05-note-0046). `[https://rekt.news/meter-rekt](https://rekt.news/meter-rekt)`'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[47](#R_c05-note-0047). `[https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0](https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0)`'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[48](#R_c05-note-0048). `[https://twitter.com/samczsun/status/1489044939732406275](https://twitter.com/samczsun/status/1489044939732406275)`'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
