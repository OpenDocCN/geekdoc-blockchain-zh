- en: Chapter 5\. Tokenize Everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advent of Bitcoin gave developers an opportunity to explore different types
    of cryptocurrencies. Yet it was Ethereum, a totally new technology, that gave
    coders the ability to easily create new cryptocurrencies on top of its blockchain,
    known as *tokens*. Today, there are tens of thousands of cryptocurrencies, mostly
    thanks to Ethereum. The Ethereum network sparked the proliferation of the concept
    of “tokenize everything” via initial coin offerings (ICOs), which allow a project
    to raise cryptocurrency funds and give investors tokens in exchange. This chapter
    looks at how that happened. We’ll begin by introducing a few notable examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastercoin
  prefs: []
  type: TYPE_NORMAL
- en: Developer J.R. Willett began working on the Mastercoin whitepaper in 2011\.
    His [aim](https://oreil.ly/tVC-J) was not “to bootstrap an entirely new blockchain,
    as every other cryptocurrency does,” but rather “to create an entirely new network
    of currencies, commodities, and securities on top of Bitcoin itself.” Willett
    eventually realized that community backing in the form of investment via bitcoin
    might help foster adoption. So, he held the first “token sale,” or ICO, in 2013\.
    This enabled Mastercoin to raise [3,700 BTC, or about $2.3 million](https://oreil.ly/UXrMe)
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous chapter, the beginnings of Ethereum trace back
    to November 2013, when Vitalik Buterin began emailing around a whitepaper proposing
    a new protocol based on elements of Bitcoin, Mastercoin, and other projects. This
    document was disseminated throughout the cryptocurrency community, and developers
    and backers began to accumulate. Buterin made a public announcement of the Ethereum
    project in February 2014.
  prefs: []
  type: TYPE_NORMAL
- en: A Swiss-based nonprofit foundation was created to initiate the ICO, and starting
    in July 2014, for 42 days Ethereum conducted a crowdsale. Approximately 60 million
    ether tokens were sold, raising some 31,000 BTC (around $18 million at the time).
    This became the template for many other ICOs in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Gnosis
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized prediction market platform, Gnosis shares some concepts and
    some personnel with the Augur project, an early Ethereum-based offering that had
    its ICO in 2015\. The Gnosis multisignature wallet is still one of the most widely
    used in the Ethereum ecosystem, especially for applications such as cold storage
    of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting aspect of the Gnosis project’s ICO was the Dutch-style
    auctioning system it employed. This novel concept enabled tokens to decline in
    value over the time of the ICO, encouraging investors to wait until the end to
    get the best pricing. Most ICOs are conducted the reverse way: cheaper tokens
    are offered the earlier an investor gets in. However, this proved successful as
    Gnosis was able to raise over [$300 million in 15 minutes](https://oreil.ly/_Cf97)
    while keeping 95% of the cryptocurrency attributed to the project and its founders.'
  prefs: []
  type: TYPE_NORMAL
- en: EOS
  prefs: []
  type: TYPE_NORMAL
- en: EOS.IO, brainchild of Daniel Larimer, is a blockchain protocol that aims to
    solve the scalability issues of blockchains by distributing computing resources
    equally among EOS cryptocurrency holders. The project raised [over $4 billion
    in a year](https://oreil.ly/79g90), one of the biggest raises ever, by using an
    uncapped token sale on Ethereum. The offering was for an ERC-20 token called EOS,
    which was converted into the native token once their native blockchain was ready.
  prefs: []
  type: TYPE_NORMAL
- en: Tokens on the Ethereum Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a token allows developers to create a cryptocurrency on the Ethereum
    network. This enables anyone to issue an asset on a blockchain using one of the
    most well-known cryptocurrency protocols. The [ERC-20 standard on Ethereum](https://eips.ethereum.org/EIPS/eip-20)
    is a reference implementation of blockchain assets on the network, paving the
    way for tokens to have properties that enable their use across many different
    exchanges, wallets, and other blockchain services. There *are* other blockchain
    platforms for issuing tokens. However, issuing an ERC-20 asset on Ethereum is
    one of the easiest and most secure ways to create a cryptocurrency today.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of technical projects like mobile dapps, distributed computing, or payment
    mechanisms, tokens have the potential to disrupt existing financial services where
    bottlenecks still exist. Blockchain and cryptocurrency have the ability to represent
    something of value in the real world, as long as they can be properly pegged back
    to a real-world asset.
  prefs: []
  type: TYPE_NORMAL
- en: In complex real estate transactions, for example, tokens on a blockchain could
    enable better record keeping for owners—the state of Ohio is looking at [using
    blockchain for this purpose](https://oreil.ly/GEupr). In the future, transfers
    of assets could be completed more quickly and easily using tokens. Other areas
    where tokens may prove useful to prove authenticity could include art, cars, and
    stocks and bonds.
  prefs: []
  type: TYPE_NORMAL
- en: Fungible and Nonfungible Tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all tokens are created equal. One of the most important differentiators
    when creating tokens is whether they are *fungible* or *nonfungible*. Fungible
    tokens all have the same value and are interchangeable with one another, whereas
    nonfungible tokens represent something that is unique.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of fungible assets are currencies like the US dollar. One dollar is
    one dollar, whether it exists in a physical form as coins or a bill or digitally
    in a bank account or other financial service. Most cryptocurrencies, like bitcoin,
    ether, and ERC-20 assets, are also fungible.
  prefs: []
  type: TYPE_NORMAL
- en: Items such as cars or houses are nonfungible—each is unique and not interchangeable
    with any other random car or house. [CryptoKitties](https://www.cryptokitties.co)—digital
    cats represented on Ethereum as ERC-721 tokens—are another example of a nonfungible
    asset (we discuss this example more later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are implications to creating tokens. Cryptocurrency markets are highly
    volatile. If a token is listed on an exchange and used only for speculation, its
    price could become highly unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract development is a nascent area of computer science. It is highly
    recommended that a third-party auditor (like [OpenZeppelin](https://openzeppelin.com/contracts),
    which contributed background for this chapter) take a look at your code before
    you bring a token into the wild. Other well-known companies providing such services
    include [Trail of Bits](https://www.trailofbits.com) and [Chainsecurity](https://chainsecurity.com).
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum offers many different token types that can be issued. Some popular
    ones include ERC-20, ERC-721, ERC-223, ERC-777, and ERC-1400\. The variety enables
    developers to create different types of functional cryptocurrencies on top of
    the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An exhaustive list of Ethereum token standards is available on [GitHub](https://oreil.ly/zBZ5x).
    Some of the tokens listed are currently functional, whereas others are merely
    proposed ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Ethereum’s nature, new types of cryptocurrencies on the Ethereum blockchain
    may provide real-world benefits. [ERC-846, which provides for shared ownership
    of a token](https://oreil.ly/TbdBg), is a good example of a real-world use case.
  prefs: []
  type: TYPE_NORMAL
- en: Is a Token Necessary?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One existential question developers should ask when developing blockchain-based
    solutions is: *Is a token necessary?* Many tokenization/ICO projects have been
    developed with a token for fundraising, but with no clear motivation other than
    to have a cryptocurrency. Although ICOs are a good method of using crypto for
    fundraising, regulatory pressure is pushing developers to create tokens that have
    a greater function within projects.'
  prefs: []
  type: TYPE_NORMAL
- en: A token may not be useful for a blockchain-based project if it is only for fundraising.
    In addition, any project looking for stable asset value will not find a token
    to be a suitable solution, although assets like stablecoins may be. Any processing
    function that has an asset that is unstable could prove to be problematic in the
    future. This is an issue already experienced on the blockchain in the form of
    transaction fees. A fee on the Bitcoin network, for example, can change based
    on how much network demand there is. The greater the demand, the less space is
    available in the blocks, which can create a fee market where the highest bidder
    “wins.” This supply and demand paradigm also exists in Ethereum for gas fees and
    token prices once they hit exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Airdrops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve said, the main way to distribute tokens is via an ICO or similar type
    of offering. Another alternative is doing an *airdrop*. Intended to leverage network
    effects of already existing blockchains, airdrops are free or low-cost disbursements
    of cryptocurrencies to a large subset of users. The idea is to rapidly give a
    project a user base from its inception, baking in adoption of an already existing
    project/cryptocurrency. The largest case so far has been the Stellar Foundation’s
    [$125 million airdrop](https://oreil.ly/ch3IJ) of its XLM token via the Blockchain.info
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Airdrops may seem like a solution to nascent cryptocurrency adoption, but they’re
    not without their drawbacks. In particular, there likely are tax implications
    for users to obtain a cryptocurrency-based asset at zero cost. When sold, there
    could be a taxable event, depending on jurisdiction. Providing a token at nearly
    no cost also might not bode well for future value, due to dilution of the underlying
    cryptocurrency being airdropped. There’s no such thing as a free lunch in economics,
    so there could be compensating or even extra costs to airdrops.
  prefs: []
  type: TYPE_NORMAL
- en: Different Token Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Different Ethereum tokens have different technical specifications, and they
    also use different nomenclature depending on how regulators around the world define
    them. It’s important for developers to understand the various terms being floated
    regarding how to define tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: Utility
  prefs: []
  type: TYPE_NORMAL
- en: '*Utility* in the context of tokens means that a blockchain-based cryptocurrency
    must have some use outside of financial speculation. There are several longstanding
    projects attempting to do this in the blockchain world. One of the best-known
    is [Filecoin](https://filecoin.io), where tokens grant users access to space on
    a decentralized cloud storage platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs: []
  type: TYPE_NORMAL
- en: A *security*, as defined by the SEC, is an investment contract. Designed to
    provide a promise of a return, investment contracts are regulated devices used
    around the world for fundraising. For this reason, the tokens proposed in many
    ICOs could be considered securities. They are thus regulated in the jurisdiction
    of issuance. An example of a project that offers security tokens is [bloXroute](https://bloxroute.com),
    a protocol that changes the way networking and routing work for blockchain. Owning
    a bloXroute token means entitlement to a share in the future payout that blockchains
    will be making to bloXroute to use its routing protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A *security token offering* (STO) is an attempt to create an ICO that fits into
    a regulatory framework. As ICOs mimic some of the qualities of an equity IPO,
    regulators around the world are increasingly trying to understand how to protect
    investors from fraud, excessive risk, and theft. The SEC, for example, has published
    [a framework](https://oreil.ly/rQOGS) for crypto-based security offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ethereum Requests for Comment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With improving capabilities of the EVM, empowering developers to write better
    smart contracts, the Ethereum community began creating standards, formalized as
    Ethereum Requests for Comment (ERCs). These standards are important, as they ensure
    that apps wanting to interact with Ethereum smart contracts will know which functions
    and inputs to call. All proposed ERCs start as an Ethereum Improvement Proposal
    (EIP), which then goes through a vetting process. This is similar to the Bitcoin
    Improvement Process, discussed in [Chapter 3](ch03.xhtml#forks_and_altchains).
  prefs: []
  type: TYPE_NORMAL
- en: ERC-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common ERC standard for Ethereum tokens is ERC-20\. Every smart contract
    that is compliant with the ERC-20 standard will implement the methods shown in
    [Table 5-1](#erc-twozero_methods).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. ERC-20 methods
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `totalSupply() public view returns (uint256 totalSupply)` | Get the total
    token supply. |'
  prefs: []
  type: TYPE_TB
- en: '| `balanceOf(address _owner) public view returns (uint256 balance)` | Get the
    account balance of another account with `address _owner`. |'
  prefs: []
  type: TYPE_TB
- en: '| `transfer(address _to, uint256 _value) public returns (bool success)` | Send
    `_value` amount of tokens from address `_from` to address `_to`. Tokens are sent
    from the address that called the transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `transferFrom(address _from, address _to, uint256 _value) public returns
    (bool success)` | Send `_value` amount of tokens from address `_from` to address
    `_to`. |'
  prefs: []
  type: TYPE_TB
- en: '| `transferFrom(address _from, address _to, uint256 _value) public returns
    (bool success)` | Send `_value` amount of tokens from address `_from` to address
    `_to`. |'
  prefs: []
  type: TYPE_TB
- en: '| `approve(address _spender, uint256 _value) public returns (bool success)`
    | Allow `_spender` to withdraw from your account, multiple times, up to `_value`
    amount. If this function is called again, it overwrites the current allowance
    with the new `_value`. |'
  prefs: []
  type: TYPE_TB
- en: '| `allowance(address _owner, address _spender) public view returns (uint256
    remaining)` | Return the amount which `_spender` is still allowed to withdraw
    from `_owner`. |'
  prefs: []
  type: TYPE_TB
- en: Every smart contract that is compliant with the ERC-20 standard will implement
    the two events shown in [Table 5-2](#events_supported_by_erc-twozero-complia).
    Developers can build applications that listen for these events to be triggered—for
    example, a cryptocurrency wallet checking to see if any of its Ethereum addresses
    have received tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Events supported by ERC-20-compliant smart contracts
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Transfer(address indexed _from, address indexed _to, uint256 _value)` |
    Event triggered when tokens are transferred. |'
  prefs: []
  type: TYPE_TB
- en: '| `Approval(address indexed _owner, address indexed _spender, uint256 _value)`
    | Event triggered whenever `approve(address _spender, uint256 _value)` is called.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following is an example of a basic ERC-20 smart contract, [*Mastering_Blockchain_Token.sol*](https://github.com/Mastering-Blockchain-Book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This token contract was published [on the Ropsten testnet](https://oreil.ly/X8y-v)
    and has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Token name*: Mastering Blockchain Book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Token symbol*: MBB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Token supply*: 100 MBB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Token decimal places*: 18'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create your own custom token, you can simply copy and paste the preceding
    code and change these four values in the `constructor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol of your token.
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of your token.
  prefs: []
  type: TYPE_NORMAL
- en: '`decimals`'
  prefs: []
  type: TYPE_NORMAL
- en: How many decimals your token can be divided into. The standard value for most
    tokens is 18.
  prefs: []
  type: TYPE_NORMAL
- en: '`totalSupply`'
  prefs: []
  type: TYPE_NORMAL
- en: How many tokens will be in existence. There is a lot of variation in supply
    among tokens; 1 billion is an easy round number that is common.
  prefs: []
  type: TYPE_NORMAL
- en: ERC-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ERC-721 is a standard for nonfungible tokens. As mentioned earlier, with fungible
    tokens (like ERC-20 tokens), each token has the exact same attributes. With nonfungible
    tokens, each token can have different attributes and therefore is unique, which
    allows for extreme digital scarcity.
  prefs: []
  type: TYPE_NORMAL
- en: Before blockchain, most virtual items could easily be copied. Connecting a virtual
    good or a real-world item to an ERC-721 token is a way to create a digitally scarce
    item that cannot be copied or tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most famous example of this in the blockchain world is [CryptoKitties](https://oreil.ly/EoBEo),
    virtual cats that are connected to ERC-721 tokens on the Ethereum blockchain.
    [Figure 5-1](#the_unique_attributes_of_the_cryptokitt) shows CryptoKitty #1270015.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mabc_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. The unique attributes of the CryptoKitty with the unique ID 1270015
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Instead of reading the attribute information about CryptoKitty #1270015 from
    a centralized database, the information is pulled from the [CryptoKitty ERC-721
    smart contract](https://oreil.ly/GFQBV). Go to function #32 and enter the CryptoKitty
    ID, which is `1270015`. From there it is possible to see the unique attributes
    for this CryptoKitty stored on the Ethereum blockchain, as shown in [Figure 5-2](#calling_the_read_function_getkitty_from).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mabc_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Calling the read function `getKitty` from the main CryptoKitties
    smart contract responds with data stored in Ethereum about the specific kitty
    ID 1270015
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: ERC-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This proposed standard is for the next generation of fungible (ERC-20) tokens.
    It includes some improvements to the ERC-20 standard, the most important of which
    is in the way tokens are transferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways that users can move ERC-20 tokens from one address to another:'
  prefs: []
  type: TYPE_NORMAL
- en: Push transaction
  prefs: []
  type: TYPE_NORMAL
- en: Calling the function `transfer(address _to, uint256 _value)` is a push transaction,
    where the sender initiates the transfer of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Pull transaction
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the functions `approve(address _spender, uint256 _value)`
    and `transferFrom(address _from, address _to, uint256 _value)` is a pull transaction,
    where the sender gives permission to the receiver and then the receiver pulls
    the tokens out of the sender’s account.
  prefs: []
  type: TYPE_NORMAL
- en: If a person sends tokens to a smart contract using a push transaction, then
    the smart contract will receive the tokens. However, the smart contract will not
    receive a trigger telling it that it has received the tokens and instructing it
    to run some code.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason for a pull transaction—the smart contract receiving the tokens
    initiates the transaction, and it can recognize when the tokens are received and
    execute additional code to react to this event. The most common use case for a
    smart contract receiving and sending tokens is decentralized exchanges, [IDEX](https://idex.market/eth/idex)
    being the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: Pull transactions work for smart contracts receiving tokens, but their use has
    led to many tokens accidentally being lost. A common problem is if a user mistakenly
    sends tokens to a smart contract using a push transaction rather than via the
    correct pull method; those tokens will be burned and lost forever, because the
    smart contract will not recognize that it has received the tokens and therefore
    won’t know to send them to another address at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERC-777 proposes to fix this problem by introducing the following improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authorizeOperator(address operator)` and `revokeOperator(address operator)`'
  prefs: []
  type: TYPE_NORMAL
- en: Allow token holders to authorize smart contracts to transfer tokens on their
    behalf and revoke that permission, respectively. The contracts that are authorized
    are known as *operators*. This is a variation of the pull transaction combination
    in ERC-20, but instead of authorizing the operator each time you want to transfer
    tokens, you only need to authorize the operator once. Then, for each additional
    transfer, the operator can transfer the tokens on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: '`tokensReceived` and `tokensToSend` hooks'
  prefs: []
  type: TYPE_NORMAL
- en: The contract receiving the tokens can include a function called `tokensReceived`.
    In that function, the receiving contract can identify which ERC-777 tokens the
    contract would like to accept and which it would like to reject (using `revert`).
    If an ERC-777 token is received but identified as to be rejected, the token transfer
    will not complete. It’s like receiving a letter in the mail and sending it back.
    Similarly, a contract that is requesting a token transfer can receive the `tokensToSend`
    hook, and when that hook is called has the option to revert the transaction. It’s
    less likely that this will happen, because this is the contract that initiated
    the transfer of tokens—it’s like going to the post office to send a letter, but
    then changing your mind as you are about to hand it over.
  prefs: []
  type: TYPE_NORMAL
- en: '`send(address to, uint256 amount, bytes data)`'
  prefs: []
  type: TYPE_NORMAL
- en: The push transaction includes a `data` field that not only allows the sender
    to send tokens to a contract, but also can contain specialized logic that triggers
    a function in the receiving contract. This is similar to how Ethereum transactions
    are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Although the ERC-777 standard is an improvement over ERC-20, it has not been
    adopted by the industry yet because there is a large switching cost for all stakeholders
    to move to the new standard. Many projects would have to create new token contracts,
    and then convince token holders to swap existing tokens for an equivalent amount
    using the new standard. Exchanges and some dapps would have to update their systems
    to support the new standard as well.
  prefs: []
  type: TYPE_NORMAL
- en: ERC-1155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This standard was designed to track virtual goods in games. For example, the
    default weapon in a shooting game might be a pistol, but it is possible to purchase
    the triple-barreled rocket-launching weapon that kills one hundred enemies in
    one shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal token standard for these in-game items would have a mixture of ERC-20
    and ERC-721 attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: ERC-20 (fungible) so that you can attach a price to the virtual good, and users
    can then purchase and trade the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC-721 (nonfungible) so that the virtual good can have unique properties—for
    example, how many rockets it can hold, or how powerful the weapon is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the ERC-777 token standard, this standard includes the concept of an *operator*,
    an address that has the authority to move your tokens on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another improvement in this standard is the ability to transfer multiple tokens
    in one transaction. When transferring ERC-721 tokens, you call the function `safeTransferFrom`
    and specify the token to be transferred by its `_tokenId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With ERC-1155 tokens, you can call the function `safeBatchTransferFrom` and
    specify an array of `_id`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The ability to do batch trades removes another layer of friction, for gamers
    and game publishers alike.
  prefs: []
  type: TYPE_NORMAL
- en: Enjin, the company that created this standard, is now providing a platform that
    makes it easy for game publishers to support virtual goods on the blockchain.
    One of the biggest challenges to gaining widespread adoption is that the Ethereum
    network is not yet fast enough to support hundreds of thousands of transactions
    a second, which is a common requirement in large-scale games.
  prefs: []
  type: TYPE_NORMAL
- en: At time of this writing, about 35 games have adopted this standard, and about
    100,000 people hold ERC-1155 virtual goods.
  prefs: []
  type: TYPE_NORMAL
- en: Multisignature Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending funds out of an *externally owned account* (EOA) wallet in Ethereum
    only requires one private key. This means if that key is compromised, there’s
    nothing stopping funds being stolen from the account—it’s a single point of failure.
    The purpose of a multisignature wallet is to lower the risk of unauthorized removal
    of funds by requiring multiple private keys to send the funds. This is a similar
    concept to a bank account that requires multiple signatures to authorize a payment.
    There isn’t an ERC standard for multisignature wallet contracts, although this
    type of contract is widely used in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every multisignature contract requires *M* of *N* signatures to authorize a
    transaction, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N* is the *number* of Ethereum addresses that can authorize a transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M* is the *minimum* number of signatures from among those *N* unique addresses
    required for a transaction to be authorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that *M* must be less than *N*. An example would be a 2-of-3 multisignature
    contract, which means there are three addresses that can authorize a transaction,
    and only two signatures are required to complete the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common practice for entities that do ICOs to collect all the funds they
    raise into multisignature wallets. These ICOs also make their multisignature wallet
    code transparent and publicly share which addresses can sign a transaction. This
    transparency increases trust from investors, because at any time investors can
    audit the funds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you audit the [multisignature wallet](https://oreil.ly/mkRsK) of a well-known
    company that raised $33 million in its ICO, you can see all the funds that have
    come in and been sent out. You can also audit the wallet’s *M* of *N*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the function `getOwners` shows which addresses can authorize transactions.
    These addresses are called *owners*. In this case, there are five of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[0x197a3d8fea67ee3b5a8436c5d9b4a794a196006b](https://oreil.ly/woTp1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[0x0063af5125737564407a4081f017c34d647dad4f](https://oreil.ly/s5BHD)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[0x00c947cdb9112086d203843be8132bc992737f69](https://oreil.ly/X3yob)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[0x003cb639f3c0120051abf4f927c2414d56ac766c](https://oreil.ly/7DgeO)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[0x00cb0d8171a9fa71e71fbf3f9cc17c6442755c29](https://oreil.ly/7ZSg3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the current value of the variable `required` shows how many signatures
    are required to execute a transaction. This wallet requires three signatures to
    execute a transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This wallet that is being audited here is thus a 3-of-5 multisignature wallet.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 5-3](#example_of_the_series_of_events_that_to), you
    can also audit which addresses signed all the transactions that this wallet has
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mabc_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Example of [the series of events](https://oreil.ly/bvK_8) that
    took place to set up and execute a multisignature transaction
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As this figure shows, the process for executing a multisignature transaction
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the owner addresses ([0x00c9…7f69](https://oreil.ly/qATRF)) that is
    authorized to perform a multisignature transaction calls the `submitTransaction`
    function to submit the transaction details. The `submitTransaction` call performs
    two events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It stores the details of the requested transaction.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It adds 0x00c9…7f69 to the list of addresses that confirm the transaction. This
    address therefore both initiates the transaction and confirms the transaction.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [`submitTransaction` call](https://oreil.ly/OyENJ) occurs in block #7331149.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A second owner ([0x0063…ad4f](https://oreil.ly/Ofyns)) calls the function `confirmTransaction`
    to give the second of the three required signatures. This [`confirmTransaction`
    call](https://oreil.ly/N63a8) occurs in block #7331154.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A third owner ([0x003c…766c](https://oreil.ly/nTVqu)) calls the function `confirmTransaction`
    to give the third signature. This call leads to two events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third owner confirms the transaction.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The contract recognizes that all required signatures have been given and then
    executes the transaction using the details that were submitted in step 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This [`confirmTransaction` call](https://oreil.ly/OXyFD) occurs in block #7458500.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Decentralized Exchange Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Ethereum, every cryptocurrency exchange had to be controlled and managed
    by a company—a centralized authority. Centralized exchanges still exist, with
    popular examples including Coinbase, Bitstamp, and Gemini. The purpose of an exchange
    is to act as a trusted platform where two parties can exchange cryptocurrencies
    securely. To accomplish this, an exchange must do the following for its customers:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a secure place to deposit/withdraw crypto, and hold the funds in escrow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an order book, so that two parties can agree on a price to trade the
    crypto at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swap the cryptocurrencies between the two parties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A smart contract has the capability to perform the following three actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Send/receive and hold ETH and ERC-20 tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record price requests from EOA accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two price requests match, change ownership of the corresponding cryptocurrencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good example of a *decentralized* exchange on Ethereum is [IDEX](https://idex.market/eth/idex).
    Even though the IDEX website looks similar to a centralized exchange, there are
    significant differences between the two types of exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code running a centralized exchange is deployed to a web hosting
    provider—for example, AWS or Azure. Frontend code running on a decentralized exchange
    is also deployed to a web hosting provider, but the backend code is written into
    a smart contract and deployed to the Ethereum network. The database is just the
    Ethereum or some other smart contract blockchain, as illustrated in [Figure 5-4](#infrastructure_differences_between_cent).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mabc_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Infrastructure differences between centralized and decentralized
    exchanges
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Advantages of a decentralized exchange include:'
  prefs: []
  type: TYPE_NORMAL
- en: Greater transparency
  prefs: []
  type: TYPE_NORMAL
- en: Because the backend code is in a smart contract, anyone can audit it before
    using the exchange. The code in a centralized exchange is private. This type of
    transparency increases trust in the decentralized exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced counterparty risk
  prefs: []
  type: TYPE_NORMAL
- en: When you deposit cryptocurrency in a centralized exchange, it maintains custody
    of your funds, and customers expect that at any point in time they can get those
    funds back. However, there have been many cases where exchanges have lost all
    of their customers’ funds. In a decentralized exchange, the smart contract maintains
    custody of the cryptocurrency, and if an audit of the smart contract shows that
    the contract is safe to use, then it’s impossible for the exchange to lose your
    funds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decentralized exchanges also have a few downsides, though. Notably, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Very slow
  prefs: []
  type: TYPE_NORMAL
- en: On a centralized exchange, users expect that if they execute a trade it will
    be completed instantly. On a decentralized exchange, in order for a trade to execute,
    a user must wait for their transaction to be included in a block, which often
    takes at least 10 seconds, or even a minute. By the time the user’s trade executes,
    the opportunity could be gone.
  prefs: []
  type: TYPE_NORMAL
- en: Expensive
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized exchanges require users to generate a new transaction every time
    they want to perform an action, including adding an order and cancelling an order.
    Exchange users frequently make multiple orders and changes to those orders in
    a short period of time. On a centralized exchange, these order changes are free,
    but on a decentralized exchange, you have to pay gas to the network for each action,
    which makes it much more expensive to use.
  prefs: []
  type: TYPE_NORMAL
- en: Difficult for nontechnical users
  prefs: []
  type: TYPE_NORMAL
- en: Since users must sign a transaction every time they complete an action, nontechnical
    users may find using a decentralized exchange is too complicated and requires
    too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: One other big difference between the two is that there is no need to ask anyone’s
    permission to add an ERC-20 token to a decentralized exchange. As soon as an ERC-20
    token is created, it can instantly be traded on a decentralized exchange. Depending
    on whom you speak to, this can be considered a pro or a con. We’ll talk more about
    decentralized exchanges and how they’re used in [Chapter 7](ch07.xhtml#decentralizing_finance_and_the_web).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can view all the [ERC standards](http://eips.ethereum.org/erc) online, and
    OpenZeppelin provides a great [library of ERC-compliant smart contracts](https://oreil.ly/LOwnY).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is by far the largest blockchain for tokenization today. In a short
    time frame, any developer can create their own blockchain-based asset. A lot of
    work has been done to give programmers a framework within Ethereum to operate
    in, with the different ERC standards providing a plethora of options. Ethereum-based
    tokenization has enabled the creation of a number of innovative new blockchain-based
    applications, and there surely will be many more as this technology continues
    to mature.
  prefs: []
  type: TYPE_NORMAL
