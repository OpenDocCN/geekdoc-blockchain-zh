©作者（们），在 Springer Nature 新加坡私人有限公司独家授权下 2021 年 Z. Zheng 等（编辑）区块链智能[`doi.org/10.1007/978-981-16-0127-9_4`](https://doi.org/10.1007/978-981-16-0127-9_4)

# 4. 智能驱动的智能合约优化

黄元^(1)，孔曲平^(1  )，贾南^(2  )，陈祥平^(3  )和郑子宾^(4, 5  )（1）数字生活国家工程研究中心，中山大学数据科学与计算机学院，广州，中国（2）河北地质大学管理与工程学院，石家庄，中国（3）中山大学舆论大数据分析与仿真广东省重点实验室，广州，中国（4）中山大学，广州，中国（5）数字生活国家工程研究中心，中山大学，广州，中国曲平孔 Email: kongqp@mail2.sysu.edu.cn 贾南 Email: jianan_0101@163.com 陈祥平（通讯作者）Email: chenxp8@mail.sysu.edu.cn 郑子宾 Email: zhzibin@mail.sysu.edu.cn

## 摘要

在本章中，我们概述了如何通过智能驱动的方法来优化智能合约。我们通过聚类分析实证研究了智能合约的重复性，并尝试从相似的合约中提取不同化的代码。不同化代码被定义为在两个相似的智能合约中的重复之外的源代码，通常说明软件特性是如何实现的或编程问题是如何解决的。然后，这些不同化代码可能被用来指导智能合约下一个版本的更新。最后，我们应用语法和语义相似性从超过 120,000 个智能合约中发现其相似的智能合约，并向目标智能合约推荐不同化代码。

## 4.1 概述

区块链作为公共账本，存储在区块链中的交易几乎不可能被篡改（Nakamoto 2009）。其目的是解决分布式环境中双方交易的信任问题，这可以大大提高交易效率并降低成本（Dinh et al. 2018；Zheng et al. 2018）。区块链技术允许使用密码学建立合同，并替代过去建立信任所必需的第三方（Zheng et al. 2017）。智能合约是一种计算机化的交易协议，执行合同的条款（Nick 2008）。随着区块链技术的日益普及，智能合约已应用于各个领域（Christidis and Devetsikiotis 2016；Juels et al. 2016；Norta 2015): 从金融、游戏到医疗保健。

实现智能合约的难度在于如何通过编程语言表达和编写法律合同。低质量的智能合约可能导致权利和义务的定义不明确，并变得脆弱。Loi 等人发现，现有的 19,366 个以太坊合约中有 8833 个是脆弱的（Luu et al. 2016）。智能合约作为区块链上的交易执行；网络的输入、输出和合约状态都是可见的。因此，具有安全漏洞的智能合约可能造成经济损失。包括自私挖矿攻击（Sapirshtein et al. 2017）和 DAO 攻击（Norta 2015）在内的著名攻击造成了数百万美元的损失。一些研究人员注意到了实现智能合约的困难，并建议在实现之前指定和建模智能合约（Frantz and Nowostawski 2016；He et al. 2018）。在本章中，我们发现以太坊上的大多数智能合约非常相似，因为它们有很多重复的源代码。同时，我们注意到在类似智能合约之间存在“个性化代码”，称为差异化代码。差异化代码被定义为两个类似智能合约中重复代码之外的源代码，通常说明软件功能是如何实现的或编程问题是如何解决的（Huang et al. 2017）。

因此，类似合同中的微分代码可以作为其他智能合约更新的候选实现。以下示例展示了智能合约*C* [1]在其初始版本中使用 throw，这可能会在异常抛出时导致额外的气体消耗。通过搜索其类似的智能合约，我们可以观察到智能合约*C* [2]使用了替代函数 revert( )而不是 throw，当异常抛出时可以将剩余的气体返回给用户。

因此，区分化的代码 revert( )（即合同*C* [2]中的红色字体）可以在发布新版本时用来支持合同*C* [1]的更新（图 4.1）。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig1_HTML.png](img/506524_1_En_4_Fig1_HTML.png)

图 4.1

智能合约更新支持的整体框架

在本章中，我们提出了一种使用区分化代码支持智能合约更新的方法。对于一个目标智能合约，我们首先应用代码语法和语义相似性来发现与超过 120,000 个智能合约相似的智能合约。然后，我们将目标智能合约的源代码与相似智能合约的源代码进行比较，以提取区分化代码。最后，我们推荐将区分化代码推荐给目标智能合约，这可能会用来支持目标智能合约的更新。案例研究显示我们推荐的区分化代码可以精确匹配 42 个智能合约在演进版本中的代码更改。鼓舞人心的实验结果表明，区分化代码可以有效地支持智能合约更新。

本章的其余部分如下组织。第 4.2 节描述了智能合约语法和语义相似性分析的主要方法。第 4.3 节介绍了整体框架，而第 4.4 节提供案例研究。第 4.5 节讨论了未来研究的有效性和相关工作。

## 4.2 智能合约相似性分析

### 4.2.1 语法相似性分析

实际上，检测相似智能合约是一个代码克隆检测问题（Jiang 等 2018; Yue 等 2018)。检测代码克隆有很多方法。其中一种代表方法是比较智能合约源代码的抽象语法树相似性，即基于树的方法（Baxter 等 1998)。这种方法首先计算子树相似性，然后计算整个树相似性。基于树的方法可以实现指数时间复杂度（Roy 等 2009)，这不适合用于我们场景。

检测代码克隆的第二种代表方法是基于代码片段的令牌序列，称为基于令牌的方法（Wettel 和 Marinescu 2005)。这种方法首先为每行代码生成令牌，然后通过找到两个代码片段的最长匹配令牌序列来计算语法相似性。基于令牌的方法达到时间复杂度 *O*(*n* × *m*)（Wettel 和 Marinescu 2005)，我们将其应用于本章计算代码语法相似性。

代码分词

为了获得智能合约的代码语法结构，我们首先应该识别出智能合约中每行代码的语法。在本章中，代码语法被细分为 90 种类型（例如，*MappingExpression*、*ModifierDeclaration*、*IfStatement*、*ForStatement*、*AssignmentExpression*、*ReturnStatement*）。我们的算法解析抽象语法树以获得每行代码的语法类型。值得注意的是，单行代码可能包含多种语法类型。例如，一个 if 代码行“if( _to == address( this) )”包含三种语法类型：*IfStatement*、*BinaryExpression*和*CallExpression*。

散列序列

对于两个智能合约的源代码，我们使用代币标记每一行代码，每种代币类型对应一个唯一的散列值（10 位数字）。如果代码行包含多种类型的代币，则该代码行的代币对应的散列值相加以生成新的唯一散列值。此后，每行代码都映射到一个散列值，因此智能合约的源代码对应一个散列序列。然后，我们使用两个智能合约的源代码散列序列来计算它们的语法相似度。

匹配算法

对于一对智能合约的两个散列序列，我们的目标是找到这两个散列序列中最长的匹配子序列，并使用最长的匹配子序列来衡量它们的语法相似度。我们采用 Wettel 和 Marinescu（2005）提出的方法寻找最长的匹配子序列，不同之处在于我们在此章节中使用抽象语法树解析代码元素以获得本章的代币化，而 Wettel 等人使用正则表达式来识别代码元素。

如算法 4.1 所示，匹配算法由四个步骤组成。首先，我们将序列 1 中的每个散列与序列 2 中的每个散列进行比较。结果存储在矩阵*M*中，矩阵中的每个单元格*M*[*i*,*j*]存储相关散列*i*与相关散列*j*之间比较的结果。*M*[*i*,*j*] = 1 意味着相关散列匹配（即，相同）。其次，我们从矩阵的左上角寻找匹配的单元格。从第一个匹配的单元格开始，我们将继续扩展到主对角线上第一个未匹配的单元格。连续匹配的单元格形成一个子序列。我们继续在矩阵中找到所有子序列。第三，我们检查矩阵中任意两个子序列之间的间隔。如果间隔小于某个阈值*η*，我们将这些子序列链接起来形成一个更长的子序列。以同样的方式重复检查间隔，直到遍历所有子序列，最后我们可以找到最长的子序列。第四，将最长子序列的长度除以散列序列 1 和散列序列 2 的最大长度，即为语法相似性。值得注意的是，由于矩阵是对称的，我们只需要使用矩阵的一半来找到最长的子序列。

算法 4.1 语法匹配算法![../images/506524_1_En_4_Chapter/506524_1_En_4_Figc_HTML.png](img/506524_1_En_4_Figc_HTML.png)

### 4.2.2 语义相似性分析

代码语法可以从程序逻辑的角度捕捉程序相似性，而代码语义可以直观地从源代码的词选择中捕捉程序相似性（Huang 等人 2018）。例如，如果代码行的标识符包含单词“withdraw”，那么该代码行可以实现提取功能。因此，为了评估两个智能合约的相似性，我们可以通过分析两个智能合约函数原型中包含的词选择来分析它们的语义相似性。

代码预处理

智能合约的源代码由一系列有意义的单词、标点符号和操作符号组成。我们可以将智能合约的源代码视为一篇文本文档。然而，文本文档与普通文档不同，它们不是句子，而是一组随机的单词和符号。因此，我们不能采用 Oliva 等人(2011)的方法，首先计算句子的语义相似性，然后计算两个文本文档的语义相似性。相反，我们使用词嵌入（Mikolov 等人 2013）将每个有意义的单词向量化，然后计算两个智能合约的语义相似性。

显然，智能合约源代码中的所有词并非都在语义相似性分析中起积极作用，一些原始词可能会削弱代码的语义。因此，应用了一系列预处理规则：（1）将驼峰命名法单词拆分为单个单词，例如：“*giveRightVote*”拆分为“*give*”、“*right*”和“*vote*”；（2）过滤源代码中的功能词，例如“*and*”、“*the*”和“*an*”；（3）过滤掉 Solidity 的关键字，例如“*mapping*”、“*public*”、“*function*”、“*if*”、“*modifier*”和“*for*”；（4）过滤掉不表示单词的字母序列，例如“*tttt*”、“*hhhk*”和“*kkkk*”。

词嵌入是一种无需监督的词表示，只需要大量未标记的文本即可学习（Mikolov 等 2013）。在本研究中，我们收集智能合约的源代码作为软件工程文本。为了减少整个语料库中的词汇量，首先，我们应用词干提取技术来分割文本。由于英语动词可能出现在不同的时态，如过去、未来和完成时态，我们将不同时态的动词转换为它们的原形。其次，我们过滤掉在整个语料库中出现次数少于三次的词。

代码向量化为了获得一个词的向量表示，我们使用了连续跳过模型来学习中心词（即 *w* [*i*]）的词嵌入（Mikolov 等 2013）。众所周知，所需的词嵌入是连续跳过模型的中间结果。连续跳过模型在预测 2*k*+1 个词的上下文窗口中的周围词方面是有效的（通常 *k*=2，窗口大小为 5）。跳过模型的目标函数旨在最大化以中心词为条件的周围上下文词的对数概率之和（Mikolov 等 2013):![$$\displaystyle \begin{aligned} \sum_{i=1}^n \sum_{-k \leq j \leq k, j \neq 0}\log p(w_{i+j}|w_i) \end{aligned} $$](img/506524_1_En_4_Chapter_TeX_Equ1.png)(4.1)其中 *w* [*i*] 

$$\log p(w_{i+j}|w_i)$$

](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq1.png)是条件概率，使用软最大化函数定义：![$$\displaystyle \begin{aligned} \log p(w_{i+j}|w_i) = \frac{{\mathrm{exp}}(v_{w_{i+j}}^{\prime T} v_{w_i})}{\sum_{w \in W} {\mathrm{exp}}}(v_{w}^{\prime T} v_{w_i}) \end{aligned} $$](img/506524_1_En_4_Chapter_TeX_Equ2.png)(4.2)其中 *v* [*w*] 

$$v_{w}^{\prime }$$

](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq2.png) 是神经网络模型中单词 *w* 的输入和输出向量，而 *W* 是所有单词的词汇表。直观地说，*p*(*w* [*i*+*j*]|*w* [*i*]) 估计了单词 *w* [*i*+*j*] 在中心词 *w* [*i*] 的上下文中出现的归一化概率。在这里，我们采用负采样方法（Mikolov 等人 2013）来计算这个概率。

在训练模型后，语料库中的每个单词都与向量表示关联并形成一个词典。为了获得智能合约的语义信息，我们首先收集它们的前处理标识符，然后从词典中确定每个标识符对应的向量表示。随后，我们在智能合约维度上按维度累加所有标识符的向量。然后，我们可以通过它们语义向量的向量夹角计算任意两个智能合约的语义相似性。

### 4.2.3 智能合约相似性计算

对于给定的一对智能合约 *C* [*n*] 和 *C* [*m*] 的源代码，我们的算法分析它们的代码语法以获得哈希序列，并提取关键词生成语义向量。之后，我们计算智能合约 *C* [*n*] 和 *C* [*m*] 的哈希序列之间的语法相似性。同时，我们计算 *C* [*n*] 和 *C* [*m*] 之间的语义相似性。在获得语法和语义相似性之后，我们使用式子 (4.3) 计算综合相似性。![$$\displaystyle \begin{aligned} CompSimi = \alpha \cdot SyntSimi + \beta \cdot SemanSimi, \end{aligned} $$](img/506524_1_En_4_Chapter_TeX_Equ3.png)(4.3)

其中，*CompSimi*, *SyntSimi*, 和 *SemanSimi* 分别对应于综合、语法和语义相似性；*α* 加 *β* 等于 1.0。

## 4.3 差异化代码推荐

基于相似性计算方法，我们的方法可以从合约库中为任何目标合约检索到许多类似的合约。然而，考虑到合约库中有超过 120,000 个智能合约，这种方法的检索效率非常低。因此，我们可以首先根据综合相似性对智能合约进行聚类，然后从更接近的簇中检索与目标合约类似的合约，这可以显著提高检索效率。接着，我们可以比较类似合约的源代码以获得代码差异，这些差异可以用作区分代码以支持智能合约的更新。

### 4.3.1 类似智能合约的聚类

为了聚类相似的智能合约，我们在本章中使用了 K-means 聚类（Hartigan 和 Wong 1979）。K-means 聚类背后的主要思想是，给定特定的参数*K*，它将*n*个实例划分为*K*个簇，每个实例属于最近的平均值的簇。

当初始化 K-means 聚类时，我们应该随机选择*K*个智能合约作为聚类中心；然后，根据综合相似性，当簇中心最接近智能合约时，每个智能合约将被分配到簇。后来，当新的智能合约添加到簇中时，它应该迭代地更新簇中心。最后，当簇中心保持不变时，我们停止迭代。

### 4.3.2 差异化代码提取

为了支持目标智能合约的更新，我们需要从其相似的智能合约中提取差异化代码。再次，我们应用语法匹配算法（即算法 4.1）来提取差异化代码。具体来说，对于目标智能合约*C* [*n*]和其相似的智能合约*C* [*m*]，我们可以在矩阵*M*[*i*,*j*]中找到最长的匹配子序列。一方面，我们可以根据最长的匹配子序列确定*C* [*n*]和*C* [*m*]的匹配代码语句。另一方面，通过从矩阵*M*[*i*,*j*]中移除最长匹配子序列中的匹配语句，我们也可以确定*C* [*n*]和*C* [*m*]的非匹配代码语句。

有两种不匹配的语句，即包含在智能合约*C* [*n*]中，但不包含在*C* [*m*]中的语句（情况 1）；或者包含在智能合约*C* [*m*]中，但不包含在*C* [*n*]中的语句（情况 2）。当我们试图使用差异化代码来支持智能合约*C* [*n*]的更新时，情况 2 中的不匹配语句可以用作差异化代码，推荐给智能合约*C* [*n*]以进行更新。同样地，情况 1 中的不匹配语句可以用作差异化代码，来支持智能合约*C* [*m*]的更新。

## 4.4 案例研究

### 4.4.1 数据集

我们从 Etherscan 下载了 32,537 个 solidity 文件，^(1)每个 solidity 文件平均包含 3.7 个智能合约（范围从 0 到 36）。总共有 120,389 个智能合约，存储在本地仓库中。这些智能合约是在 2018 年 3 月 24 日之前发布的。表 4.1 显示了数据集的统计特性。表 4.1

数据集的统计特性

| Solidity 文件 | 智能合约数量（最小） | 智能合约数量（最大） | 平均数 | 智能合约（总计） |
| --- | --- | --- | --- | --- |
| 32,537 | 0 | 36 | 3.7 | 120,389 |

### 4.4.2 研究问题

为了分析我们方法推荐差异化代码以支持智能合约更新的能力，我们希望在我们的评估中回答以下研究问题：

**RQ1**:

推荐的差异化代码能否引导开发者更新智能合约？

**RQ2**：

权重值的选择（即*α*和*β*）会影响我们方法的表现吗？

**RQ3**：

开发者在推荐的智慧合约中可以获得什么样的差异化代码？

在整个实验中，我们的方法在 Windows 7 上运行，配备有四核 3.3 GHz 英特尔酷睿 i5 处理器和 8GB 内存。整个实验中，间隙参数*η*=3。

### 4.4.3 评估标准

对于**RQ1**，我们想要评估推荐智能合约中的差异化代码是否可以帮助开发者更新智能合约。为了实现这一目标，我们首先收集数据集中的具有两个版本的智慧合约（早期发布的版本称为目标智能合约，后来发布的版本称为演变智能合约），然后应用提出的方法为目标智能合约推荐一些类似智慧合约（称为推荐智能合约）。最后，我们确定推荐智能合约和演变智能合约是否包含与目标智能合约相同的代码更改（即差异化代码）在与目标智能合约比较时。如果这是真的，它可以证明推荐的智慧合约可以用来指导目标智慧合约未来的更新，因为推荐智慧合约中的代码更改与目标智慧合约的演变版本中的代码更改一致。为了确定一个智慧合约是否有两个版本，我们要求这两个智慧合约应在同一个账户中（即由同一作者发布）。此外，我们还要求这两个智慧合约的相似度等于或大于 0.7。如果这两个条件都满足，智慧合约被视为具有两个版本。

对于**RQ2**，我们想要评估是否存在一个*α*和*β*之间的权衡，能使所提出的方法获得最佳结果。为了实现这一目标，我们提出了一种参数优化方法。具体来说，对于**RQ1**中的每个目标智能合约，我们参数优化方法的目标是通过逐渐调整*α*和*β*的值，提高推荐智能合约在推荐列表中的排名。因为只有当推荐的智能合约出现在推荐列表的前面，这意味着我们的算法运行良好，并能进一步有效地为开发者提供参考。

对于**RQ3**，我们试图定量分析推荐的智慧合约。我们希望了解开发者在推荐的智慧合约中可以获得什么样的代码差异，进而确定是否可以使用这些差异知识帮助开发者更新版本。为了实现这一目标，我们基于经验对推荐智慧合约中的差异代码进行分析分类。

### 4.4.4 结果分析

#### 4.4.4.1 **RQ1**

我们发现共有 42 个智能合约存在两个版本。由于篇幅限制，表 4.2 展示了部分智能合约的信息。表 4.2 中的*Name*列代表合约名称；*Address*列代表智能合约在区块链上的地址。*Address*由一个 40 位十六进制数组成，由于篇幅限制，我们在表 4.2 中只保留了其前 5 位。*Block Height*列代表当前智能合约所处的区块高度。*Simi*列代表目标智能合约与推荐智能合约（或目标智能合约与演变智能合约）之间的代码相似度；*Rank*列代表通过应用提出的方法，推荐智能合约在推荐列表中的相似度排名。表 4.2

RQ1 的结果

|  | 目标智能合约 | 推荐智能合约 | 演变智能合约 |
| --- | --- | --- | --- |
| No. | Name | Address | Block height | Name | Address | Block height | Simi | Rank | Name | Address | Block height | Simi |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | Owned | 0x2561b | 4,886,545 | Owned | 0x492a4 | 4,704,537 | 0.83 | 1 | Owned | 0x14b0d | 4,887,631 | 0.83 |
| 2 | ERC20 | 0x6c4fe | 4,928,600 | ABTokenBase | 0x007e7 | 4,547,466 | 0.89 | 2 | ERC20 | 0x01b84 | 5,168,599 | 0.89 |
| 3 | Token | 0x759a5 | 4,538,168 | Token | 0x273f5 | 4,494,277 | 0.8 | 3 | Token | 0x5d113 | 4,627,084 | 0.8 |
| 4 | ERC20 | 0x37bda | 4,551,394 | ABTokenBase | 0x007e7 | 4,547,466 | 0.73 | 3 | ERC20 | 0x1dfa4 | 4,685,008 | 0.73 |
| 5 | USDGOLD | 0x00755 | 4,879,124 | FireLottoToken | 0x04939 | 4,713,248 | 0.87 | 2 | ILoveYou | 0xaeda4 | 4,981,202 | 0.87 |
| 6 | FengShuiCoin | 0x0661f | 5,158,332 | PI | 0x69124 | 4,649,999 | 0.78 | 4 | FSRatCoin | 0x5ab63 | 5,158,430 | 0.78 |
| 7 | BRM | 0xd7732 | 5,231,383 | MOT | 0x263c6 | 4,753,082 | 0.82 | 1 | BRM | 0x61d16 | 5,239,862 | 0.82 |
| 8 | AbstractToken | 0xc25c2 | 4,967,169 | ERC20 | 0x003f7 | 4,508,340 | 0.89 | 1 | ERC20 | 0x15adb | 4,971,923 | 0.89 |
| 9 | ERC20Basic | 0x6c4fe | 4,928,600 | ERC20Basic | 0x0056A | 4,791,096 | 0.8 | 1 | ERC20Basic | 0x01b84 | 5,168,599 | 0.8 |
| 10 | VenusERC20 | 0xa723c | 4,837,227 | ELYTE | 0x05d37 | 4,506,864 | 0.84 | 7 | VenusToken | 0x1e4e3 | 4,846,201 | 0.84 |
| 11 | BIGCToken | 0xa6768 | 4,823,807 | TokenERC20 | 0x0445a | 4,526,508 | 0.81 | 2 | BIGCToken | 0x574fa | 4,824,268 | 0.81 |
| 12 | Token | 0x419ca | 4,209,736 | ERC20 | 0x01b6f | 4,135,914 | 0.75 | 3 | ERC20 | 0x661Eb | 4,163,888 | 0.75 |
| 13 | Token | 0xbca13 | 4,140,369 | ERC20Token | 0x03698 | 3,982,761 | 0.8 | 1 | Token | 0xc14b3 | 4,177,015 | 0.8 |
| 14 | Owned | 0xd32c2 | 4,424,760 | Managed | 0x259b0 | 4,343,542 | 0.94 | 1 | Managed | 0x9a9f1 | 4,430,409 | 0.94 |

对于一个目标智能合约，它可能与其推荐智能合约和演化智能合约具有相同的名称，如表 4.2 中的第一个目标智能合约（即 Owned）所示。值得注意的是，尽管目标智能合约和推荐智能合约具有相同的名称，但它们是由不同的账户创建的。因此，合约（Owned，地址为 0x492a4）可以用作目标智能合约（Owned，地址为 0x2561b）的推荐智能合约。在某些情况下，目标智能合约及其演化智能合约具有不同的名称，如第二个目标智能合约（即 Owned）所示。我们可以确定合约 Owned 是合约 Managed 的演化版本，因为它们由同一个账户创建，并且代码相似度更高（即 0.94）。此外，合约 Owned 和 Managed 的发布时间也可以证实这一点，因为区块高度越高，合约发布越晚。因此，合约 Owned 比合约 Managed 发布得更晚。类似地，我们要求推荐智能合约的发布时间应早于目标智能合约的发布时间。因为目标智能合约的开发者只能从之前发布的智能合约中获得参考。

在表 4.2 中，我们可以观察到一些具有重叠名称的目标智能合约，即第一个和最后一个目标智能合约，第三个和第五个智能合约，第四个和第十三个、第十四个智能合约。尽管这些智能合约具有相同的名称，但它们是由不同的账户创建的，并且具有不同的地址。更重要的是，它们的源代码不同。例如，我们比较第一个和最后一个智能合约的源代码，并发现这两个智能合约的代码相似度不到 40%。然后，当将提出的方法应用于检索它们的类似智能合约时，获得的推荐智能合约也是不同的。

我们得出结论，对于 RQ1，所提出的 42 个目标智能合约与其演化的智能合约相同，这一发现使得开发者可以采用建议的方法来检索类似的合约，以帮助他们在实际开发中更新智能合约。

#### 4.4.4.2 **RQ2**

在智能合约推荐中，我们利用代码语法和语义信息来衡量智能合约之间的代码相似度。我们根据公式(4.3)计算综合相似度。为了调整*α*和*β*的最佳值，我们逐渐将它们的值从 0.1 增加到 0.9（每次增加 0.1 的阈值）。并且我们应确保每次迭代的*α* + *β* = 1。我们的目标是找到一对*α*和*β*，使得推荐智能合约在推荐列表中的排名最佳。

图 4.2 展示了使用 proposed method 对 42 个推荐智能合约进行应用时详细信息以估算 *α* 和 *β* 的值。垂直轴显示应用 proposed method 时 42 个推荐智能合约的总排名，水平轴显示 *α* 和 *β* 的值对。例如，（0.1, 0.9）表示 *α* 等于 0.1，*β* 等于 0.9。我们可以观察到，随着 *α* 的逐渐增加，推荐智能合约的总排名得到提高。当 *α* 等于 0.9，*β* 等于 0.1 时，推荐智能合约的总排名在推荐列表中达到最佳结果。这一结果表明代码语法在计算合约相似性中起主导作用。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig2_HTML.png](img/506524_1_En_4_Fig2_HTML.png)

Fig. 4.2

权重值的效果

表 4.3 展示了使用不同指标衡量代码相似性的比较。当我们只用语义信息来计算代码相似性时，推荐智能合约可以获得总排名 172，平均 4.1；当我们单独应用语法信息时，推荐智能合约可以获得总排名 148，平均 3.5。当我们用权重值 0.9 和 0.1 结合这两个指标时，推荐智能合约在推荐列表中获得了最佳总排名 144，平均 3.4。表 4.3

不同指标的比较

| 指标 | 总排名 | 平均排名 |
| --- | --- | --- |
| 语义 | 172 | 4.1 |
| 语法 | 148 | 3.5 |
| 语法 + 语义 (*α* = 0.9, *β* = 0.1) | 144 | 3.4 |

我们得出 RQ2 的结论，用权重值 0.9 和 0.1 结合语法和语义信息可以使推荐智能合约获得最佳排名。因此，在本研究中我们使用 *α* = 0.9 和 *β* = 0.1 作为默认值。

#### 4.4.4.3 **RQ3**

我们对推荐智能合约进行了实证分析，并试图看看开发者可以在推荐智能合约中获得哪些不同的代码。表 4.4 展示了在 42 个推荐智能合约上对 10 种类型的不同代码，其中红色字体表示不同代码。值得注意的是，一个推荐智能合约可能涉及一个目标智能合约的多个不同代码。表 4.4

不同代码示例

![../images/506524_1_En_4_Chapter/506524_1_En_4_Figa_HTML.png](img/506524_1_En_4_Figa_HTML.png)![../images/506524_1_En_4_Chapter/506524_1_En_4_Figb_HTML.png](img/506524_1_En_4_Figb_HTML.png)

红色字体表示已分化的代码。

第一种不同的代码是事件（Events）。事件类似于面向对象编程语言（如 Java）中的日志操作，这是一个与 EVM 日志设施方便接口的常见编程实践。事件是实际重要的编程实践，用于收集 EVM 运行时信息，因为它们可以用于辅助事后分析（Zhu 等人 2015）。在某些情况下，开发人员忘记插入事件以记录 EVM 的关键运行时信息，这可能会显著增加故障诊断的难度。从这个意义上说，我们方法推荐的差异化代码为开发者添加事件提供了重要参考。

另一种不同的代码是自毁函数。自毁函数可以结束当前执行。更重要的是，自毁函数可以销毁当前合约并将资金转至指定账户。因此，当我们的方法向目标智能合约推荐自毁函数时，它不仅可以增强智能合约生命周期的可控性，还可以增加智能合约的灵活性。

第三种不同的代码是修改器（Modifier）。修改器可用于轻松更改函数的行为，并且它们可以自动在执行函数之前检查条件。例如，表 4.4 中的案例 3 显示，修改器要求 owner 等于 msg.sender，如果是，智能合约执行引用修改器的函数；如果不是，智能合约抛出异常。因此，针对目标智能合约推荐的修改器在此情况下对限制函数的访问权限发挥了重要作用。

另一种不同的代码是回滚函数优化。表 4.4 中的案例 4 显示，目标智能合约中使用了 throw，而推荐智能合约中使用了 revert( )。throw 可以回滚所有状态更改，但消耗剩余的燃料。相比之下，revert( )也可以回滚所有状态更改，但将剩余的燃料返回给调用者。从这个意义上说，revert( )对用户更友好，是一种优化的回滚函数。

第五种不同的代码是条件加强。表 4.4 中的案例 5 显示，当满足“allowTransfer == true”的额外条件时，if 语句可以执行。此操作加强了 if 语句的条件，还可以帮助避免程序漏洞。

接下来三种不同的代码（即从案例 6 到 8）可以归类为代码重构。例如，案例 6 将一些程序功能抽象为父合约 Iowned，然后 Owned 从 Iowned 继承。案例 7 更改了变量 totalSupply 的初始值。案例 6 向修改变量 _prevOwner 和 _newOwner 的关键词 indexed 添加，使变量可索引。

剩下的两个不同代码与变量声明和函数声明有关。在这两种情况下，一些变量和函数推荐给原始目标智能合约，这些变量和函数在智能合约中扮演不同角色，所以我们无法对它们进行更细粒度的分类。应注意自毁函数（案例 2）和修改器（案例 3）并未包含在函数声明（案例 10）中。

我们得出 RQ3 的结论，我们方法推荐的大部分不同代码对开发者更新他们的智能合约是有用的。这些不同代码从事件、自毁函数、修改器到回滚函数等都有。这些不同代码可以帮助更新后的智能合约增加可维护性（例如，事件）、灵活性（例如，自毁函数）、功能行为的可控性（例如，修改器）、用户友好性（例如，回滚函数）、代码结构的合理性（例如，案例 6 至 8）等。

### 4.4.5 集群分析

为了进一步理解我们支持智能合约更新的方法的有效性，我们实证研究了第 4.5 节中描述的智能合约集群。

考虑到仓库中有超过 120,000 个智能合约，我们设置 K-means 的集群数量为 6000，即*K*=6000。此外，我们要求当智能合约与集群的中心智能合约的相似度大于 0.6 时，允许将智能合约添加到集群中。这样做是为了确保同一集群中的智能合约具有更高的相似度。然而，这个约束可能导致一些不属于任何集群的智能合约。

图 4.3 显示了根据它们所属的智能合约数量的前 600 个集群。从集群中我们可以观察到，最大的集群包含了 2894 个相似的智能合约，最小的集群包含了两个相似的智能合约。有 15800 个智能合约不属于任何集群。这个结果意味着剩余的智能合约（即超过 104,000 个）可以从仓库中找到至少一个相似的智能合约。这是大多数智能合约在数据集中相似的证据，它们与相似的语法和语义共享许多代码。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig3_HTML.png](img/506524_1_En_4_Fig3_HTML.png)

Fig. 4.3

前 600 个智能合约集群

为了进一步理解为何存在如此多的相似智能合约，我们手动分析了同一簇中的智能合约。导致相似智能合约的最主要原因是实现了相同的“接口”。例如，为了实现“发行货币”，相应的智能合约应实现 ERC20 的“接口”。^(2) 因此，所有具有“发行货币”功能的智能合约都有相似的源代码。

相似智能合约的第二个原因是代码复用。由于以太坊上的许多智能合约都是开源的，开发者可以按需获取智能合约并根据现有智能合约的源代码进行定制。目前，智能合约只能在一些有限的领域使用，如金融、游戏和社会网络。同一领域的智能合约通常实现相似的功能。例如，与金融相关的智能合约具有常见的功能，如*转账*、*授权*和*批准*。然后，开发者可以大量复用现有智能合约进行定制开发，这使得许多智能合约在以太坊上保持较小的代码差异。

由于代码库中有大量相似的智能合约，在大多数情况下，我们的方法可以成功地找到与目标智能合约相似的智能合约，并从相似的智能合约中提取不同的代码，以支持目标智能合约的更新。

## 4.5 讨论

### 4.5.1 相关研究

智能合约被应用于各个领域，这已经被许多从不同角度研究智能合约的学者们探讨过，如并发编程（Dickerson 等人 2017; Yu 等人 2017）、安全（Atzei 等人 2017; Chen 等人 2017; Grossman 等人 2018; Kosba 等人 2016）和方案（Bartoletti 等人 2017; Chen 等人 2018）。与本研究最相关的工作是那些帮助程序员进行智能合约开发的工具。

为了促进智能合约的协同开发，He 等人(2018)提出了 SPESC，一种用于智能合约开发的规范语言。SPESC 允许用户以类似于现实世界合同的形式指定智能合约，在其中明确定义各方当事人的义务和权利以及加密货币的交易规则。此外，SPESC 可以根据合同条款和账户余额生成程序骨架（或程序接口）。他们初步研究结果表明，SPESC 可以很容易地被 IT 和非 IT 用户学习和理解。

Frantz 和 Nowostawski (2016) 提出了一种建模方法，支持将可读的合同表示半自动翻译成计算等价物。他们为建模智能合约改编了 ADICO（Ostrom 1995）。从基于 ADICO 的模型，他们还开发了一个代码生成器以导出部分源代码。ADICO 格式可以指定当事人的义务和权利。

Chen 等人 (2017) 对智能合约进行了一项调查，并揭示了耗气编程模式。他们确定了七个耗气模式，并将它们分为两类：与无用代码相关的模式，以及与循环相关的模式。他们提出了并开发了 GASPER 工具，以自动发现智能合约中的耗气模式，该工具可以帮助程序员在实际开发中定位三个典型模式。

Porru 等人 (2017) 识别了面向区块链的软件工程面临的许多挑战，重点是大型团队之间的协作、测试活动以及为智能合约创建而专门的工具。他们的工作为面向区块链的软件工程提出了新的研究方向。

与提到的研究不同，我们在首批提出面向智能合约开发的代码级差异化代码。差异化代码的作用是说明软件特性是如何实现的以及编程问题是如何解决的，因此，想要在下一个版本中更新他们的智能合约的程序员可以重用差异化代码。
