© 作者（们），在 APress Media, LLC 独家授权下，隶属于 Springer Nature 2023B.吴，B.吴青少年区块链[`doi.org/10.1007/978-1-4842-8808-5_2`](https://doi.org/10.1007/978-1-4842-8808-5_2)

# 2. 密码学：区块链安全的基石

布鲁恩·吴^(1   )和布里吉特·吴^(1)(1)新泽西州,美国,Livingston

区块链是基于一系列不同的密码学概念构建的。从保护钱包和确保交易的安全，到保护共识协议和为匿名账户加密私有数据，几乎所有的一切都需要密码学来确保正常运行。密码学是区块链安全的基石。

本章将深入探讨您需要了解的关于区块链中的密码学的所有内容，从基础开始。然后，您将被介绍到经典的对称密钥密码学、非对称密码学等等。随着您的进步，您将深入了解数字签名是如何工作的。

本章还将介绍如何利用散列函数来散列数据，在章节的最后，你将深入了解一下椭圆曲线密码学（ECC），这是区块链中使用的一种关键类型的加密密码。

在本章中，将讨论与密码学相关的以下主题：

+   密码学基础

+   对称密钥密码学

+   非对称密钥密码学

+   数字签名

+   散列算法

+   椭圆曲线密码学

+   派生以太坊地址

## 密码学基础

在第一章中，我们已经简要讨论了用于散列块数据的 SHA-256 散列密码学。

让我们用一个例子来说明如何向公众发送安全的消息。假设爱丽丝给鲍勃发送了一条个人消息。爱丽丝希望这条消息是私人的。只有鲍勃能理解这条消息，在传输过程中消息不能被更改。通过互联网发送的消息可能会被入侵者秘密拦截并记录（见图 2-1）。爱丽丝和鲍勃如何阻止这种情况发生？这就是密码学的作用所在。![](img/535492_1_En_2_Fig1_HTML.jpg)

爱丽丝通过互联网给鲍勃发送的消息被入侵者秘密拦截和记录的说明。

图 2-1

通过网络发送的消息

“密码学”这个词来自希腊词“kryptós”，意思是“隐藏或秘密”。

“密码学”意味着“秘密书写”，并允许有意愿的各方之间交换安全的消息。

消息通过加密算法转换成称为“密文”的秘密代码等价物，以防止未经授权的访问。然后，密文通过公共网络发送，在接收端进行解密，收件人可以查看其内容。

在前面的例子中，爱丽丝用一个密钥来加密她的消息，将其转换为密文，并通过互联网发送给鲍勃。她不必担心黑客获取她的私人消息。要阅读密文，黑客必须使用解密密钥。当鲍勃收到这个密文消息时，他可以使用一个密钥通过解密来恢复原始明文。![](img/535492_1_En_2_Fig2_HTML.png)

一个示意图展示了通过互联网，爱丽丝向鲍勃加密和解密消息的过程。带标签的过程是我的秘密文本，加密，密文，解密，和文本。

图 2-2

通过互联网加密和发送消息

密码学主要分为三类：对称密钥加密，非对称密钥加密和无密钥的原语，如哈希函数。

### 对称密钥加密

对称密钥加密是一种加密算法，它使用发送方和接收方之间的共享密钥来加密和解密数据。这个密钥被称为对称密钥。

在前面的例子中，爱丽丝和鲍勃共享同一个密钥。爱丽丝用这个密钥来加密消息，当鲍勃阅读消息时，这个密钥用于解密过程。这展示了对称加密是如何工作的。

对称加密通常比非对称加密更有效率。因此，它通常用于大量数据加密，个人数据加密和解密。

虽然有几种对称算法，但第一个美国标准是 DES。

对称密钥加密可以使用流密码或块密码来加密数据。在大多数情况下，使用流密码是加密数据的推荐方式。

#### 流密码

流密码以一次一个位或字节的方式加密明文消息，结果是一个字符入，一个字符出的密码。它对每个数据流中的二进制位应用随机字符流和异或操作。

异或是一种布尔逻辑操作，也被称为“排他或”或排他联合。当两个输入中的只有一个为真时，它产生真。如果两个输入都为真或都不是真，异或操作的输出为假。

异或逻辑的真值表如表 2-1 所示，其中 0 表示假，1 表示真。表 2-1

异或的真值表

| ** ** | 输入 | 输出 |
| --- | --- | --- |
| **---** | **---** | **---** |
| **A** | **B** | **A XOR B** |
| **0** | **0** | **0** |
| **0** | **1** | **1** |
| **1** | **0** | **1** |
| **1** | **1** | **0** |

所以，如果位 A 是 11000101，位 B 是 10100110，当对这些两个二进制位应用异或操作时，输出如下所示：

+   10101

+   异或 00110

+   输出 10011

密钥流字符可以是任何字母或数字的随机组合。假设我们有一个明文字节流 (p1, p2, p3, ..., pi)，密钥流生成器输出一个字节流 (k1, k2, k3, ..., ki)。要加密密文字节流，需要对每个明文和密钥应用异或操作以生成并加密密文字节流 (c1, c2, ..., ci)。这可以通过以下表达式来表示：

c1 = p1 XOR k1，...，ci = pi XOR ki

图 2-3 说明了流加密。P1 是 00110101，K1 是 11100011。通过异或操作，加密结果是 11010110。

+   00110101 (明文)

+   XOR 11100011 (密钥)

+   输出 11010110 (明文)

![](img/535492_1_En_2_Fig3_HTML.png)

图示流加密，分 3 步处理 P 1、P 2 到 P i 的数据流；K 1、K 2 到 K i 的密钥流；以及 C 1、C 2 到 C i 的 XOR 操作。P 1 是 00110101 加上 K 1 是 11100011 意味着 C 1 为 11010110。

图 2-3

流加密

为了解密明文字节，我们将密文和密钥应用异或操作。输出将得到原始明文字节。这个操作可以表示为 pi = ci XOR ki：

+   11010110 (密文)

+   XOR 11100011 (密钥)

+   输出 00110101 (明文)

#### 块加密

块加密与流加密的主要区别在于，块加密将固定大小的明文字节块作为单个单元，并将其作为密文字节块进行加密。通常，块大小与密钥大小相同。

假设我们有一个明文字节块 **p** 和密钥字节块 **k**。要加密密文字节块 **c**，我们需要用 **密钥 c = 加密 (p, k)** 加密明文，并通过 **密钥 p = 解密 (c, k)** 解密密文以恢复明文。

每个块的大小相等。假设输入大于块的数量，输入大小为 38 位，块大小为 6 位。经过 6 个块后，还剩下 2 位（38 - 6 * 6 = 2）。在这种情况下，我们通常添加填充（两个 0）并附在块的末尾。

图 2-4 显示了块加密的示例。明文被分成 n 个块 (p[n])，每个块使用相同的密钥来加密密文。加密过程将从第一个块开始，最后在最后一个块结束，最终所有块数据都将被加密。![](img/535492_1_En_2_Fig4_HTML.png)

3 个块的图。3 个块的标签分别是 P 1、P 2 和 P n，P1 指向密钥，密钥指向 C 1；P 2 指向密钥，密钥指向 C 2；P n 指向密钥，密钥指向 C n。过程从第一个块开始，最后一个块结束。

图 2-4

块加密

最常用的块加密类型包括高级加密标准（AES）、数据加密标准（DES）和三重 DES（3DES 或 TDEA）。

### 非对称密钥加密

对称加密相对简单且比非对称加密快，只需要一个密钥。它通常用于大数据加密/解密和银行交易的保密。在对数据进行加密之前，对称加密必须共享相同的密钥。在前面的例子中，当爱丽丝需要向许多人发送私人信息时，情况变得复杂。如果爱丽丝使用对称密钥（K）来加密所有这些信息并与鲍勃和其他人共享这个密钥，那么有人可能会在爱丽丝不知情的情况下秘密地将 K 的副本给其他人。在这种情况下，整个通信信道已经被 compromised，许多无意中的人可以读取和修改消息并将其发送给任何其他成员。为了避免这种安全风险，爱丽丝必须考虑为每个接收消息的人创建大量密钥，但爱丽丝将不得不记住所有这些密钥。爱丽丝需要通过可靠的信道给她朋友打电话或参与面对面的会议来分发这些密钥。因此，对称加密对于许多参与者可能很快就会变得不那么实用。这个问题在行业中关于使用加密手段已经存在了很长时间，但在 1976 年，迪菲和赫尔曼引入了公钥加密的概念，也称为非对称加密。^(1)

#### 公钥与私钥

惠特菲尔德·迪菲和马丁·赫尔曼描述了当两个通信方在不安全的信道上交换信息时，如何使用由公钥和私钥组成的密钥对来进行公钥加密。

私钥只有密钥的所有者知道，公钥被认为是公开信息，可供任何人使用。每个密钥都是为特定目的而设计的。

公钥用于加密信息，将其转换为密文。私钥用于解密用公钥加密过的信息。

##### 迪菲-赫尔曼算法是如何工作的

迪菲-赫尔曼算法基于一个数学原则，并使用以下公式：

模幂运算表示为 \(g^a \mod p\)

模运算是指除法运算的余数。例如，\(5 \mod 3 = 2\) 因为 2 会被剩下。模运算也可以表示为 \%.

在 \(p, g\) 为素数的情况下，\(g\) 是模 \(p\) 的原根。\(g\) 和 \(p\) 的数字是公开的，任何人都可以看到和使用。

在数学中，如果每个与 \(n\) 互质的整数在模 \(n\) 下与 \(g\) 的幂相等，那么 \(g\) 就是模 \(n\) 的原根。

例如，2 是模 5 的原根，所有与 5 互质的数是 1，2，3 和 4；而这些每个（模 5）都是它自己，意味着 \(2 \mod 5 = 2\)：

+   \(2⁰ = 1, 1 \mod 5 = 1, \) 所以 \(2⁰ \equiv 1\)

+   \(2¹ = 2, 2 \mod 5 = 2, \)所以 \(2¹ \equiv 2\)

+   \(2³ = 8, 8 \mod 5 = 3, \) 所以 \(2³ \equiv 3\)

+   \(2² = 4, 4 \mod 5 = 4, \) 所以 \(2² \equiv 4\)

现在，我们将看看 Diffie-Hellman 算法是如何工作的。让我们用一个简单的例子来理解密钥交换的算法。想象一下爱丽丝和鲍勃想要交换信息。现在，假设一个名叫伊芙的黑客正在试图拦截消息。

**步骤 1 –** 爱丽丝和鲍勃同意所有消息都需要使用模数 p = 13 和基数 g = 6 的公式 g^a (mod p) 来计算。爱丽丝和鲍勃都选择了一个只有他们自己知道的密钥数字。然而，公式以及数字 g 和 p 是公开给每个人的。![](img/535492_1_En_2_Fig5_HTML.png)

爱丽丝和鲍勃同意的公共值图示。模数 p 等于 13，基数 g 等于 6。

**图 2-5**

爱丽丝和鲍勃同意公共值

**步骤 2 –** 爱丽丝选择了一个秘密的随机数字（a = 5）作为她的私钥，鲍勃选择了他的私钥（b = 4）。![](img/535492_1_En_2_Fig6_HTML.png)

爱丽丝和鲍勃的秘密私钥图示。爱丽丝的随机私钥 a 等于 5，鲍勃的随机私钥 a 等于 4。

**图 2-6**

爱丽丝和鲍勃的密钥

**步骤 3 –** 爱丽丝和鲍勃然后将使用该公式，利用 p 和 g 参数以及他们的私有值来计算公共值。

爱丽丝将使用以下方程计算：![](img/535492_1_En_2_Fig7_HTML.png)

图表展示了爱丽丝和鲍勃的公共值计算。爱丽丝的公共值为 6 的 5 次方等于 7776，模 13 等于 2，鲍勃的公共值为 6 的 4 次方等于 1296，模 13 等于 9。

**图 2-7**

爱丽丝和鲍勃计算公共值

6⁵ (mod 13) = 7776 mod 13 = 2

鲍

6⁴ (mod 13) = 1296 mod 13 = 9

**步骤 4 –** 爱丽丝将她的计算结果（2）通过互联网发送给鲍勃。伊芙可以看到这个。鲍勃将他的计算结果（9）发送给爱丽丝，伊芙也可以看到这个。![](img/535492_1_En_2_Fig8_HTML.png)

图示展示了爱丽丝和鲍勃互相交换公共密钥的过程。交换的密钥是鲍勃的 9 和爱丽丝的 2。

**图 2-8**

爱丽丝和鲍勃将他们的结果互相发送

**步骤 5 –** 爱丽丝和鲍勃都收到了对方的公共消息，并通过公式 g^a (mod p) 计算出了共享密钥。

在这一步中，g 是一个从另一方发送的公共消息。

爱丽丝将使用以下方程计算：![](img/535492_1_En_2_Fig9_HTML.png)

图示展示了爱丽丝和鲍勃的秘密计算。爱丽丝的计算为 9 的 5 次方等于 59049，59049 mod 13 等于 3，鲍勃的计算为 2 的 4 次方等于 16，16 mod 13 等于 3。

**图 2-9**

爱丽丝和鲍勃得到相同的值

9⁵ (mod 13) = 59049 mod 13 = 3

鲍勃将使用以下方程计算：

2⁴ (mod 13) = 16 mod 13 = 3

爱丽丝和鲍勃都得到了相同的值。

伊娃是个黑客。她拦截了爱丽丝和鲍勃之间发送的消息。伊娃可以看到公开值（g^a (mod p)），看到 g 是什么，看到 p 是什么，看到爱丽丝和鲍勃的计算结果。然而，伊娃不知道爱丽丝和鲍勃选择的秘密数字，并且她无法轻易找到它们。![](img/535492_1_En_2_Fig10_HTML.png)

图表展示了黑客伊娃不知道的爱丽丝和鲍勃的秘密值。这些值是爱丽丝的 a 等于 5，鲍勃的 a 等于 4。爱丽丝和鲍勃同意 g 的 a 次幂模 p 等于 13，底数 g 等于 6。

图 2-10

黑客伊娃不知道爱丽丝和鲍勃的秘密值

从迪菲和赫尔曼的例子中，我们可以看出，爱丽丝和鲍勃都使用以下方程计算得到相同的结果：

*(g*^(*a*) *(mod p))*^(*b*) *mod p = (g*^(*b*) *(mod p))*^(*a*) *mod p*

共享密钥是 g^(ab)。通常，a、b 和 p 的值都很大。这是为了使结果安全。

在原始的迪菲和赫尔曼描述中，算法没有为通信方提供身份验证。这使得算法容易受到中间人攻击。

看看下面的例子：

伊娃拦截了爱丽丝和鲍勃之间的消息并阻断了他们之间的通信。

伊娃拦截了爱丽丝的公开值（g^a(mod p)）并发送给爱丽丝她自己的公开值（g^c(mod p)）。

伊娃拦截了鲍勃的公开值（g^b(mod p)）并发送给鲍勃他的公开值（g^d(mod p)）。

爱丽丝和鲍勃都无法检测到任何问题，每个方向都可能认为对方收到了他们的消息，但实际上，伊娃可以解密、阅读、修改和重新加密他们的所有消息。![](img/535492_1_En_2_Fig11_HTML.png)

图表展示了算法 g 的 a 次幂模 p 容易受到中间人攻击。解释是黑客伊娃拦截了爱丽丝和鲍勃的消息并阻断了他们之间的通信。

图 2-11

中间人攻击

迪菲和赫尔曼是第一个非对称加密协议，并为许多认证协议提供了基础，例如广泛使用的椭圆曲线迪菲-赫尔曼非对称算法和 RSA。加密、安全外壳（SSH）、安全套接字层（SSL）、电子邮件和 VPN 安全都是基于这些非对称算法的。

#### 数字签名是如何工作的

如果爱丽丝想通过互联网将一条已签名的消息发送给鲍勃，应遵循以下步骤：

1.  1.

    我们从发送方爱丽丝的消息开始。

1.  2.

    算法根据文档校验和生成消息的单向散列值。

1.  3.

    消息的散列值使用爱丽丝的私钥进行签名或加密。

1.  4.

    消息被发送给鲍勃。

1.  5.

    鲍勃收到消息。

1.  6.

    鲍勃使用爱丽丝的公开密钥对消息进行解密，并验证爱丽丝签署的消息认证。

1.  7.

    算法重新生成消息的散列值。

1.  8.

    这两个散列值进行比较。如果它们相同，我们可以确保自签名以来传输的文档没有被篡改。

数字签名的过程如图 2-12 所示。![](img/535492_1_En_2_Fig12_HTML.png)

图解展示了 Alice 和 Bob 的数字签名过程。标记的过程是原始文档、散列、签名/加密、私钥、公钥、解签名/解密、原始文档和散列。

图 2-12

数字签名过程

#### 数字签名

数字签名是一种非对称公钥加密技术，用于验证数字消息或文档所有者的真实性。

我们通常在公钥加密中使用公钥进行消息加密，私钥进行消息解密。然而，在数字签名的情况下，消息是用发送者的私钥加密的，换句话说，消息被签名了。

由于发送者的公钥是已知的，任何人都可以验证消息的数字签名。

数字签名包括以下特性：

+   认证（验证谁签署了文档的来源）

+   不可否认性（签署者和他们数字签名过的文档的身份应该是不可否认的）

+   完整性（证明文档自签名以来未被篡改的证据）

#### 散列算法

在第一章“区块链如何工作”部分，介绍了散列概念，并讨论了区块链如何使用 SHA-256 散列函数对交易数据进行散列。在前一节中，讨论了数字签名过程。该过程表明需要应用散列函数。

散列算法是一种数学函数，它将原始数据输入分为大小相等的较小数据块，然后执行散列函数生成两个固定大小的数据块的散列码。该算法从消息数据的第一块开始，使用一个种子值传入散列函数，输出第一个散列码。![](img/535492_1_En_2_Fig13_HTML.jpg)

插图展示了 2 个数据块生成散列函数的算法代码。它给出了散列值为 356A192B7913B04C54574D18C28D46E6395428AB。

图 2-13

用以生成散列码的两个固定大小的数据块 该过程类似于前节中讨论的块加密。散列过程将从第一块开始，结束于最后一块。这个过程可以根据算法要求重复多次。最终，所有块数据都将链接在一起并散列。![](img/535492_1_En_2_Fig14_HTML.jpg)

散列算法的流程图。标记的流程是数据种子、消息块和散列函数。该过程将持续到收到散列值。

图 2-14

散列算法

##### Keccak-256 算法

Keccak-256 算法是一个广泛应用于以太坊区块链的哈希函数。一些例子包括以太坊地址、一些智能合约函数以及被称为 Ethash 的以太坊共识引擎，它在产生区块和其他安全行动中扮演着重要角色。

Keccak-256 是 SHA-3 哈希函数家族的一员。函数输入可以是一个变长字符串或数字，生成的输出将始终是一个固定长度的 64 个字符（字母和数字）输出。输出可以转换为十六进制数字。与其他所有哈希函数一样，它是一个单向加密哈希函数。

Keccak-256 是基于吸墨构造的，是一个吸墨函数家族。Keccak-256 吸墨函数（Keccak[r,c]）需要两个参数：一个大小为 r（比特率和编码单个时间单位的数据显示量）和另一个大小为 c（容量）。

**填充**

填充函数将在输入数据（M）后添加足够的位，并且填充后的输入长度可以分为多个 r 位块。

**初始化**

填充后的输入被分成 r 位块，假设块的名称是 M0, M1, M2, 等等。

**吸收阶段**

r 位块与输入数据 M0 的小块进行异或操作。然后将结果传递给压缩函数 f。函数 f 的输出与下一个消息 M1 进行异或。重复此过程，直到处理完每个消息块 Mn。在每一步中，一小块输入数据（位长度为 r）被“吸收”到缓冲区中。

**压缩阶段**

同样的过程重复进行。缓冲区的 r 位块由下一个 r 位输出（Z0, Z1, Z2, 等等）组成。使用函数 f 提取 r 位数据作为下一个 r 位输出。重复此过程直到产生结果。

图 2-15 展示了 Keccak-256 哈希算法。![](img/535492_1_En_2_Fig15_HTML.png)

算法描述了通过两个吸收和压缩过程的 Keccak-256 哈希值。带标签的过程是消息、填充和输出。3658-89/+/

图 2-15

Keccak-256 哈希算法

##### 椭圆曲线密码学（ECC）

椭圆曲线密码学（ECC）是在 1985 年由 Victor Miller（IBM）和 Neil Koblitz（华盛顿大学）独立发现的，目前是最健壮且广泛使用的加密密码学类型之一。比特币和以太坊等区块链网络使用 ECC。

2005 年，美国国家安全局（NSA）公布了一套未发表的算法，称为 Suite B 协议，并发布了一篇题为“椭圆曲线密码学的案例”的论文，他们建议美国政府使用 ECC 来保护敏感和非机密的通信。^(2)

美国国家安全局（NSA）评论称，分析师应该“利用过去 30 年的公钥研究和分析，从第一代公钥算法转向椭圆曲线。”

套件 B 的协议包括椭圆曲线 Diffie-Hellman（ECDH）和椭圆曲线 Menezes-Qu-Vanstone（ECMQV）用于密钥交换，椭圆曲线数字签名算法（ECDSA）用于数字签名，高级加密标准（AES）用于对称加密，以及安全散列算法（SHA）。这些协议发布后，ECC 很快成为了保护现代工业通信的事实标准。

椭圆曲线基于椭圆曲线的代数性质，并提供了与其他非对称加密系统（如 RSA 或 DSA）等效的安全性，但密钥尺寸要小得多。例如，一个 256 位的 ECC 密钥与一个 3072 位的 RSA 密钥具有相同的强度。这也使得椭圆曲线显著 faster.

**椭圆曲线是什么？**

椭圆曲线是通过以下方程给出的：

y ² = x ³ + Ax + B

曲线，如所需，是非单点的，并且需要没有重复的根或自交。为了确保曲线是非单点的，条件可以通过以下方程表达：

4A³ + 27B² ≠ 0

当 A = -1 且 B = 1 时，椭圆曲线的例子可以在图 2-16 中看到：![](img/535492_1_En_2_Fig16_HTML.png)

曲线图描绘了方程 y 平方等于 x 立方减 x 加 1 的椭圆。曲线从点-3 开始，在-1.5 处弯曲，最终在大约 3 处结束。

图 2-16

椭圆曲线 y² = x³ - x + 1

y² = x³ - x + 1

在椭圆曲线中，有一个有用的性质可以在曲线上创建加法，使其成为一个阿贝尔群。取曲线上的两个点 P 和 Q，并通过它们画一条直线。这条直线将在曲线上 intersect at one more point (R)。取 P + Q 为 R，从 R，还可以画另一条直线，要么直线上升（如果 R 在 x 轴以下），要么直线下降（如果 R 在 x 轴以上）到曲线的另一侧，与点-R 相对（见图 2-17）。![](img/535492_1_En_2_Fig17_HTML.jpg)

曲线图描绘了椭圆的 2 点 R 和负 R 的加法。曲线通过轴 P、Q 和 R 的直线。结果通过负 R 得出 P 加 Q。

图 2-17

两点（R 和-R）的椭圆曲线加法

椭圆曲线的群法通过以下任意一个方程表达：

P + Q + R = 0，或者 P + Q = - R

点 P 和 Q 的和等于点- R。

在椭圆曲线 P = (x[1], y[1])和 Q = (x[2], y[2])两点相加时，可以使用以下公式计算第三个点：

P + Q = R = (x[3], y[3])其中

![](img/535492_1_En_2_Figa_HTML.jpg)

x 立方和 y 立方的方程。当 P 不等于 Q 和 P 等于 Q 时 lambda 的值

椭圆曲线 E 在 Z[p]上由以下方程定义，而 Z[p]是模 p 的场，意味着{0, 1, 2, …, n - 1}：

![](img/535492_1_En_2_Figb_HTML.jpg)

X = 3 时，y² = 36，36 除以 5 等于 1。

图 2-19

+   如果我们用 K 乘以 P，它将得到椭圆曲线上的点。

+   X = 2 → y² = 15 → 15 (mod 5) = 0

+   1.

+   ![](img/535492_1_En_2_Fig19_HTML.jpg)

+   K = n P

+   X = 3 → y² = 36 → 36 (mod 5) = 1

+   一个点表示方程 y 平方等于 3 加 2 x 加 3 的椭圆曲线，表示点 Q 和 P。两轴范围从 0 到

+   所以，如果给 E(Z[p])中的任何点 P 加上∞，我们总能得到 P 回来。这可以通过以下方程表示：

+   现在，重新排列模运算符 P = 263 留下以下方程：

算法描述了所选 E C 曲线名称所支持的椭圆，并生成密钥对。这个过程是由两个密钥 E C 私钥和 E C 公钥生成的。

图 2-18

然后，椭圆曲线具有以下七个点：

使用 EC 曲线（secp256k1）创建一个随机私钥并从此私钥导出公钥。

私钥是 64 个十六进制字符长（32 字节）。

X = 0 → y² = 3 → 没有解(mod 5)

在椭圆曲线中，如果 P 是(x, y) ∈ *E(Z*[*p*]*)，则(x, y) + (x, -y) = ∞（无穷远点）。

直到现在，我们已经学习了密码学。现在该是实践的时候了，我们将应用我们的知识来生成一个以太坊地址。我们将利用多个在线工具来进行这个练习。当然，如果你找到了更好的工具，你可以选择一个不同的工具，或者你可以编写代码来实现相同的结果：

使用费曼技巧，你只需花上`20 min`就能深入理解知识点，而且记忆深刻，*难以遗忘*。

椭圆曲线 y² = x³ + 2x + 3 (mod 263)

→ y = 0 因为 0² (mod 5) = 0

(1, 1), (1, 4), (2, 0), (3, 1), (3, 4), (4, 0), ∞。

在 Alice 和 Bob 的信息通信中，P 是曲线上双方同意的(x,y)点。Bob 的私钥用 n 表示，K 是他的公钥。我们将 P 和 n 相乘得到 K，如下所示：

→ y = 1, 4 因为 1² (mod 5) = 1，且 4² (mod 5) = 1

##### 对于所有∈E(Z[p])，P + ∞ = ∞ + P = P。

一个公式描述了模 p 方程 y²等于立方 3 加 A x 加 B，并且 A B E Z p, 4 立方 A 加 27 B 平方不等于 0。

1.  X = 4 → y² = 75 → 75 (mod 5) = 0

    通过应用这个公式，椭圆曲线 E 在 Z[p] - E(Z[p])上有一系列点(x, y)。在下面的例子中，椭圆曲线 y² = x³ + Ax + B = x ³ + 2x + 3 → y²(mod 5)，其中 A = 2, B = 3, P = 5。这可以通过以下方式看到：

    → y = 0 因为 0² (mod 5) = 0

    (x³ + 2x + 3) (mod 263)

导出以太坊地址

**理查德·费曼**的学习方法[链接](https://wiki.example.org/feynmans_learning_method)受到了诺贝尔物理学奖获得者的启发。

在模 263 下椭圆曲线 y² = x³ + 2x + 3 的标量乘法。该曲线有 270 个点，包括无穷远点。![](img/535492_1_En_2_Fig18_HTML.png)

椭圆曲线生成公钥和私钥

私钥：8c2b80899dd44981d7f8b38c1f5b13dbf1fbb98c360d9d1cfd63a3aed0d7b498

公钥：04502fa444861915b6a258c3daa2beaa41c9b912e6fd6cd526fa179c60362f602bd75e36cfe1513a1e460ca646476e54fab08aa42730068326ab0a8a2e57d2829b

1.  2.

    从以下公钥中派生地址：

    从公钥（128 个字符）开始，应用公钥的 Keccak-256 散列。它会生成一个 64 个字符长（32 字节）的字符串。让我们使用 Keccak-256 在线工具（[`​emn178.​github.​io/​online-tools/​keccak_​256.​html`](https://emn178.github.io/online-tools/keccak_256.xhtml)）来看散列结果（见图 2-20）。

![](img/535492_1_En_2_Fig20_HTML.png)

两个算法展示了地址和 Keccak-256 在线散列函数的派生。标签的键是输入类型、散列和自动更新。

图 2-20

公钥的 Keccak-256 散列示例

结果是 db97247835ec1f9d0bd8b6ed***6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3***

1.  3.

    获取以太坊地址

    取生成的散列的后 20 字节（40 字符）以获得带有前缀 0x 的以太坊地址。0x 让人们知道地址以十六进制格式。当加上前缀 0x 时，它变成了 42 个字符长。所以，在我们的例子中，以太坊地址是

    0x6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3

1.  4.

    验证以太坊地址

    我们使用其中一个在线以太坊地址验证工具（[www.rfctools.com/ethereum-address-validator/](http://www.rfctools.com/ethereum-address-validator/)）来验证我们新生成的以太坊地址。

![](img/535492_1_En_2_Fig21_HTML.png)

有效以太坊地址验证器的屏幕截图。标签的 R F C 工具是加密货币工具，包括 4 个步骤、图像工具、J S O N 工具和 H T M L 工具。

图 2-21

验证生成的以太坊地址

恭喜！我们刚刚使用密码学知识生成了一个有效的以太坊地址。在这个层面，你应该对区块链密码学的工作有一个很好的了解。

## 总结

密码学是确保区块链技术安全的必要机制。它用于确保区块链共识机制、保护区块链数据、保持用户账户安全等。本章的目的是通过快速概述其工作原理，更深入地了解密码学。

虽然这章只触及了密码技术表面，但它将帮助你丰富对称密钥密码学和不对称密钥密码学的知识。更重要的是，我们现在知道了数字签名的运作方式。我们介绍了散列算法，并详细讲解了椭圆曲线密码学的工作原理。最后，我们学会了如何生成以太坊地址。

我们将继续我们的旅程，在下一章学习比特币，货币的未来。
