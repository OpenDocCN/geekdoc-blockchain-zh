© 作者（作者）独家许可给施普林格自然瑞士 AG 2022A. Kumar 等人（编）量子与区块链用于现代计算系统：愿景与进展数据工程与通信技术讲义 133[`doi.org/10.1007/978-3-031-04613-1_5`](https://doi.org/10.1007/978-3-031-04613-1_5)

# 一种利用区块链和量子密钥分发在无服务器环境中扩展和提高安全性的概念框架

P. R. Mahalingam^(1  )(1)印度喀拉拉邦科钦库奇的 Muthoot 技术与科学学院 P. R. Mahalingam 电子邮件：prmahalingam@gmail.com

## 摘要

无服务器计算是当今世界上最受欢迎的部署策略之一。它指的是在部署过程中不预先定义执行环境，而是根据需求进行扩展的概念。随着云计算的改进，这一概念变得越来越重要，云计算依赖于这一概念。如今，云服务提供商能够将这一概念作为云服务本身提供，例如 GCP 云函数和 AWS Lambda。但随着服务上线，确保其安全性变得具有挑战性。无服务器计算最初被构想为一种无状态环境，但现在已经发展成半状态实体，使它们容易受到状态分析和劫持的影响。由于当前的加密系统以快速的速度被超越，并且量子计算预计在未来十年内破解几乎所有的加密算法，因此有必要以更加安全的方式对无服务器通信进行加密。提出了一种基于量子密钥分发和区块链的概念，以改善应用程序的扩展性和安全性。像以太坊这样的区块链平台是基于智能合约运行的，智能合约可以在节点上执行代码片段，并在共识之后将结果放置在区块链上。同样，可以将这一概念应用到无服务器计算中，因为智能合约代码库部署在节点本身上，并且由用户请求触发。用户定义的函数然后可以部署为智能合约。当需求量巨大时，可以启动更多的节点，这些节点包含智能合约的代码库，并且它们可以启动执行。为了增强安全性，端点之间的通信可以通过使用量子密钥分发来保护，甚至在节点之间，可以使用量子密钥分发背后的原理进行选择。执行完成后，结果被放置在区块链上，区块链本身充当执行日志，并携带结果。

## 1 引言

无服务器计算是在过去十年中变得重要的概念，随着云计算的日益普及。根据像 AWS 和 Azure 这样的流行云服务提供商，*无服务器计算*允许用户构建可以在互联网上运行的应用程序，而无需担心基础架构。术语*无服务器*并不完全指没有服务器的存在，而是指整个生态系统的透明性，使用户感觉不到有服务器存在于他们和执行环境之间。

云提供商提供的透明性是通过一套复杂的*自动扩展*程序框架实现的，该框架不断监控服务器的需求，并自动启动/停止新的服务器实例。透明性还使用户对安全的许多方面失去控制。虽然这对部署来说是有利的，但当用户不了解后台发生了什么时，就会存在风险。它为开发人员提供了简化的快速应用程序开发和部署的编程模型，摒弃了底层复杂性，部署更为经济（因为云提供商支持按需付费模式），提供更好的代码模板和协调。但同时，对控制 QoS、扩展性和容错性的平台设计决策的控制很少[1–3]。

本章介绍了区块链和量子计算等技术如何帮助确保无服务器计算平台的可扩展性和安全性。第二部分讨论了无服务器计算的架构以及它是如何从基本的客户端-服务器模型演变而来的。第三部分深入探讨了区块链背后的概念，它如何被广泛部署，以及在与无服务器计算集成时可以派上用场的智能合约等方面。第四部分概述了量子物理学及其在开发新的编程和执行范式中的作用。第五部分讨论了在无服务器平台中包含区块链的不同机会，而第六部分（#Sec11）则谈论了安全漏洞和管理。这些讨论在第七部分中得到了总结，提出了一个模型，将到目前为止讨论的所有优点结合起来，并探讨了如何构建这个模型。

## 2 无服务器计算

云计算在过去几年中获得了很大的重要性和流行度，特别是自从应用程序开始迁移到微服务架构[1]以来。传统的软件包具有高内聚性，所有功能都嵌入到同一个软件包的各个模块中。但是，通过微服务架构，开发人员能够将每个模块单独迁移到自己的软件包中，并独立部署它们。这得到了客户端-服务器计算的进展的支持，它使得服务能够将它们的计算负载转移到服务器上，而客户端仅限于提供基本处理和呈现输入和结果。

当我们考虑云计算的哲学时，通常有三个部署级别被广泛考虑。

IaaS

基础设施即服务（IaaS）是部署策略，其中提供了*裸骨*基础设施，仅包含存储、计算和网络基础设施。所有的安装、软件配置和管理都需要用户来完成。只有物理安全和基础设施维护属于服务提供商的责任范围。

PaaS

平台即服务在 IaaS 之上添加了软件层。基本软件可以提供现成的，也可以作为一个易于安装的包提供。开发人员可以利用提供的资源构建他们的应用程序。在这种情况下，物理安全和基础设施管理仍由服务提供商管理，但是从用户方面更新和保护软件仍由开发人员负责。

SaaS

软件即服务是指由服务提供商完全托管和管理的云应用服务。一个例子就是由谷歌完全管理的 Gmail。在这里，除了最终用户安全性之外，一切都由服务提供商管理。

无服务器计算可以被看作是一个融合了这些特点的平台。

### 2.1 走向无服务器

在无服务器计算和云计算变得流行之前，该领域由*分布式计算*控制。在这种范式中，所需的处理和存储能力分布在一组参与节点中，每个节点都包含一个完全自治的单元。当数据需要存储时，它会迁移到两个或更多节点上（这被称为*复制*），以确保在故障发生时可用性。进程也会适当地复制并且在其数据所在地附近执行。

无服务器计算是基于云计算的执行模型，在这种模型中，云服务提供商根据需求自动分配、管理、扩展和收回计算服务。简而言之，服务器管理由开发人员转移到云服务提供商。这在执行短时间脉冲而非持续负载的场景中非常有用。数据输入和输出由持久性存储管理。

从云提供商的角度来看，无服务器计算为控制开发堆栈，高效优化和管理云资源（使整个过程更加便宜），鼓励使用原生应用程序，并通过降低创建应用程序所需的工作量来吸引受众提供了机会。

这个概念与 SaaS 的概念非常相似，因为两者都共享自动管理和提供的理念。但它们之间的主要区别在于执行的工作负载。虽然 SaaS 适用于需要全天候可用的持续和一致的工作负载，但无服务器适用于持续时间短暂的密集工作负载。这通常是使用称为**函数即服务（FaaS）**的概念实现的，实际上，这是无服务器范例的子集。所有主要的云服务提供商都有他们自己的无服务器平台。热门服务列表见表 1，生产级平台的详细评估可在[4,5]中找到。Kubeless、OpenWhisk、Fission 和 OpenFaaS 等开源实现也可用于无服务器平台[6]。Table 1

热门云服务供应商的无服务器提供

| 服务 | 描述 |
| --- | --- |
| AWS Lambda | 该服务的命名灵感来自于 lambda 演算，lambda 演算推广了函数执行。Lambda 使用基于内核的虚拟机进行快速配置和低开销的微型 VM。代码可以直接使用原始源代码部署，也可以使用容器的构建版本部署。该平台支持 Node.js、Python、Go、Java 等。随着 Lambda 的宣布，无服务器的概念变得流行 [1] |
| Azure Functions | Azure 提供的托管服务，可用于构建 Web API（内置对 HTTP Web 钩子的支持）、响应数据库更改、处理 IoT 流、管理消息队列等，还支持外部管道的部署。还可以使用 *Azure Durable Functions* 来支持有状态行为，借助编排器函数和实体函数 |
| Google Cloud Run | 可以开发和部署容器化应用程序。支持 Java、Go、Python、Ruby 和 Node.js 等语言 |
| Google App Engine | 完全托管的平台和开发者环境，具有完全弹性的计算和存储管理 |
| Google Cloud Functions | GCP 提供的按使用量付费的 FaaS 实现，支持混合云和多云场景 |
| IBM Cloud Code Engine | 描述 |
| Red Hat OpenShift Serverless | 基于开源的 KNative 项目。该项目广泛使用 Kubernetes 控制器和定义来执行无服务器任务。重点放在 (i) 构建容器、(ii) 处理触发容器的事件，以及 (iii) 快速部署和自动扩展上 |

服务器端无架构的通用架构如图 1 所示。![](img/516210_1_En_5_Fig1_HTML.png)

图 1

服务器端无计算的通用架构 [1]

无服务器计算的优势如下 [7, 8]。

+   **更低的成本** — 大多数 CSP 都在按使用量付费的模式下运行无服务器[9]。必须注意的是，无服务器可以扩展到零实例，因此根本不需要任何费用[1]。将任务拆分为并行运行的微服务对于可以并行化的任务非常经济高效。

+   **简化的可伸缩性** — 由于自动缩放是作为平台的一部分提供的，因此可以避免扩展策略。

+   **简化的后端代码** — 可以最大化模块化，因为每个函数都应该执行一个固定的、最小的任务。无服务器函数通常执行一个接受数据（主要是 JSON 格式）作为输入的主函数，并生成类似格式的输出[1]。这还使开发人员能够专注于代码（使用他们选择的语言），而不是基础设施。CSP 更喜欢无服务器代码以 API 调用的形式触发。如果需要进行任何复杂的操作，则更倾向于使用级联调用[10]。

+   **更快的响应** — 部署几乎是瞬间完成的。如果代码可以打包成容器[11]，那么它可以在最短的延迟内重复部署。

但是无服务器也带来了一些权衡。

+   对于具有可预测、稳定或长时间运行进程特征的工作负载，无服务器不提供节省。传统上，无服务器代码最多执行 15 分钟，然后被其他分配所替换。

+   无服务器应用有时需要从头开始启动以服务新请求。对于低延迟应用可能是一个问题。

+   如果存在大量函数，则管理和监视环境可能会具有挑战性。根据[12]的评估，发现无服务器架构在必须从头开始启动进程时，倾向于过度配置资源以管理初始化开销。

+   如果代码使用供应商特定的库，可能需要供应商锁定。

+   无服务器部署在定义上是无状态的。因此，后续调用可能会被路由到不同的虚拟机，使任何持久性存储变得困难。任何此类存储都将导致 I/O 瓶颈，消除了 FaaS 提供的性能优势[13]。

+   没有专门的硬件支持无服务器计算[13]。由于云处理是短暂的，每次调用可能在不同位置的硬件上运行，使成本不可预测[14]。

+   设计函数时必须考虑硬件异构性。如果程序是针对特定架构进行精密调整的，则在任何其他架构上进行配置时可能会失败或性能不佳[14]。

实现无服务器架构的技术栈将需要考虑多个组件。无服务器指的是对用户不可见的 FaaS 和其他关联云服务和资源的配置、管理和计费。需要设计的主要组件包括：

+   **函数即服务（FaaS）：** 它代表无服务器中的核心计算（处理）引擎。它通常使用诸如 Java、Python、Go 等语言开发，并部署为程序本身，或作为容器。另一个选择是使用 WebAssembly[15]，它在执行期间非常高效，但在功能上有其限制，因为原生代码应该是 C 或 C++。

+   **无服务器数据库和存储：** 这涉及远离按需与基础架构和定价成比例扩展的 SQL 和 NoSQL 实例的部署。

+   **事件流和消息传递：** 需要支持基于事件驱动和流处理的工作负载（如 Apache Kafka）。

+   **API 网关：** 最好通过网关进行调用，可以根据需要配置安全性和负载平衡。

### 2.2 共享责任模型

云安全中的操作原则之一是共享责任模型。

共享责任模型规定，云服务提供商确保云的安全，而云中的安全是开发人员和用户的责任。

这意味着云服务提供商（CSPs）确保云基础设施的物理安全不受任何篡改，并提供足够的复制以保持存储数据的可用性。但是，提供商不会对由于应用程序中的不当安全实践而导致的任何数据丢失或数据泄漏负责（除了 SaaS，其中 CSPs 还负责服务）。共享责任还规定，用户完全负责保护其登录凭据的安全性。尽管现在许多提供商提供了额外的设施，如多因素身份验证，但用户必须保护其凭据。

这将我们带到了在无服务器应用程序中客户端和服务器之间进行安全通信的要求。如果通信没有得到适当的保护，将对任何窃听者或恶意实体敞开，从而导致意外数据丢失和泄露。对无服务器领域中安全性的更多讨论在第六部分中进行。

## 区块链

区块链是一种分布式分类账框架，通常被称为比特币的基础。它由存储在 *块* 上的一系列交易组成，这些块通过 *链* 的链接相互提交并记录到链中的交易都必须由分布式系统中大多数参与者通过一种称为*共识*的方法达成一致意见[16, 17]。

链接是使用哈希值创建的，每个块都存储着上一个块的哈希值。这使得链具有防篡改的特性，因为任何前面块的更改都会自动使所有后续哈希值失效。这种区块链的属性使其适用于维护数据日志。有四个主要特征使得区块链有用[18, 19]。

+   **去中心化** —— 借助分布式共识，消除了任何第三方调解者或验证者的需求。只有当区块链中的大多数节点都同意某个交易有效时，该交易才被认为是已提交的。这也使得伪造新条目变得困难。

+   **持久性** —— 一旦添加，很难从链中删除任何条目，因为它本质上是防篡改的。

+   **匿名性** —— 用户使用生成的地址与链进行交互，很难追溯到原始用户。这在加密货币中得到了利用。

+   **可审计性** —— 由于数据无法从链中擦除，因此任何交易都可以追溯到原始条目。在比特币中，这是通过*未花费的交易输出*条目来实现的。

区块链的另一个应用领域是在交易代码执行中，这是通过**智能合约**的概念实现的。它们是在交易被认为成功时执行的小段代码。

### 3.1 区块链架构

区块链的一般架构见图 2 和 3。![](img/516210_1_En_5_Fig2_HTML.png)

图 2

区块链的一般架构[18]

![](img/516210_1_En_5_Fig3_HTML.png)

图 3

区块的结构[18]

一个区块由*区块头*后跟*区块体*[18, 19]组成。交易是通过 Merkle 树管理的，Merkle 树根据元素的树状排列创建哈希值。Merkle 树的根代表其下所有元素的哈希值。这被添加到区块头中。区块头还包含版本、时间戳等记录信息，然后是上一个区块的哈希值。所有交易信息都在区块体中维护。

共识是任何区块链生态系统的核心。这是因为除非获得大多数参与节点的批准，否则无法向区块链添加交易。

这里考虑了两种流行的共识算法。

1.  1.

    **工作证明（PoW）**—在 PoW 中，网络的每个节点（称为*矿工*）都要计算区块头的哈希值，以获得发起交易的权限（称为*挖矿*）。头部中存在一个称为*随机数*的值，用于更改哈希值。为了发起交易，计算出的哈希值应该小于预定的阈值。如果一个节点达到了该阈值，状态将向所有节点广播，并且每个人都需要验证该区块。经过验证，节点将该区块添加到它们的链中。如果多个矿工同时生成有效的区块，链就会在那一点分叉，最终较短的分叉被丢弃。尽管这个过程非常有效，但在计算上是昂贵的。

1.  2.

    **股权证明（PoS）**—这是一种节能替代 PoW 的方法，在这种方法中，矿工根据其持有的货币数量证明权威。在这里，挖矿成本几乎为零。节点需要广播他们的账户余额，网络就会就添加下一个区块达成共识。

如果我们想要将区块链与传统数据库进行类比，我们需要考虑数据库的读写操作。 在区块链中，*写入*类似于在区块链中创建共识并添加新块。 *阅读*只涉及阅读和审核区块链中的条目 [20]。 考虑到有类似的操作，需要决定何时区块链变得重要。 这在[20]中用简单的示例详细解释，如图 4 所示。![](img/516210_1_En_5_Fig4_HTML.png)

图 4

何时使用区块链 [20]

超级账本和以太坊是区块链的两种流行实现 [21]。 超级账本遵循传统模式，在该模式中用户控制数据，并且整个处理过程基于信息在链上的传递方式。 以太坊从不同角度考虑了这个问题。 它是一个无需许可的平台，通过脚本平台实现智能合约的概念。 为此，它利用了*以太坊虚拟机（EVM）*，这使我们能够与无服务器计算的微型虚拟机进行类比。 这样多样化的实现使得区块链能够在诸如物联网、医疗保健、供应链、治理等多个领域找到应用。 在[19]中给出了功能描述，如图 5 所示。![](img/516210_1_En_5_Fig5_HTML.png)

图 5

区块链的功能架构 [19]

### 3.2 智能合约

智能合约为将可执行代码纳入区块链打开了一条途径。它们使得可以在传统的区块链框架中添加更高阶的功能和一定程度的复杂性成为可能。这在房地产管理和供应链管理等应用中非常有用，因为每一笔交易都需要从区块链的角度进行验证，同时也需要根据其中包含的数据进行验证。智能合约的概念可以像数据库触发器一样使用，以检查一旦准备好就要记录到链中的内容。它们还允许执行特定的计算，以便完成交易（类似于签署实体销售函，智能合约可以被视为数字签署销售函）。

智能合约是使用区块链网络上的已签名交易部署的函数（代码）和状态（数据）的封装[22]。该合约由区块链网络内的节点执行，并将执行结果记录在区块链上。在许多情况下，发布节点在发布新区块时执行合约。在某些实现中，节点仅验证发布节点的结果。

根据代码的复杂性，合约执行的时间有限制。任何违反此时间限制的行为都将导致合约执行的强制终止，并且交易将被丢弃。这可以防止恶意用户部署和执行可能导致拒绝服务攻击的智能合约。对于传统的区块链实现，执行智能合约将产生小额费用，这些费用将从他们的利益中扣除。但对于权限区块链网络，这可能并不需要，因为用户在预先已知，可以使用其他方法来防止恶意执行（比如移除访问权限）。

## 量子计算

根据李等人 [23] 的说法，量子计算结合了量子力学和计算机科学的能力。在传统计算单元中，计算的基本单位是*比特*，而量子计算机则以*量子位*（量子比特）进行计算。量子位可以被看作是一个两级原子。量子实体的优势在于它们可以处于基本状态的叠加态。这意味着所有这些由基本状态表示的数字可以同时被操纵，从而带来了巨大的并行性机会。这是一个巨大的范式转变，与传统的基于布尔代数、图灵机和λ演算的计算模型相比。

量子计算需要以下条件才能开始处理。

+   一个两级系统以确保与传统二进制逻辑的兼容性（表示为|0>和|1>）

+   初始状态为量子位（上面提到的其中一种水平）

+   一种测量量子位状态的方法

+   构建基本门操作（类似于布尔逻辑）

+   退相干时间，确保系统在与周围环境和内部的任何相互作用之后达到稳定状态。

量子模型的一个重要特征之一是纠缠。

纠缠表明，对一个粒子的测量会影响另一个粒子的测量。它在量子位之间创建了一种虚拟的同步机制 [24]。

考虑到纠缠，量子计算中的任何叠加态都可以表示如下。

### 4.1 量子密钥分发

有估计称量子计算机将能够仅通过暴力破解当前的加密算法[26]。像区块链中的安全系统依赖于单向代码（如哈希），这些代码在正向方向上很容易计算，但在反向工程上计算量很大。两种常见的方法是*整数因子分解问题*和*离散对数问题*。Shor 的因子分解算法[27]揭示了量子计算和纠缠如何在执行大规模并行任务时创建捷径。虽然算法的复杂度保持不变，但量子比特允许并行尝试多种组合，从而大大缩短了所需的时间。

量子计算本身就给出了解决方案。它利用了纠缠的属性，即一个粒子的测量会影响其配对粒子的测量。

换句话说，使用量子计算进行通信本质上是经过身份验证的，物理学的基本原理表明量子态无法被复制或测量而不受到改变。因此，任何窃听者都会立即留下痕迹，并被检测到。这是**量子密钥分发（QKD）**的基本原理。

这个概念的综合描述可在[28]中找到。QKD 使用量子态来建立密码学的随机密钥。在这里，数据通过光学通道发送，这是最适合编码量子信息的。以下是行动的序列，考虑到 Alice 和 Bob 之间的通信。

1.  1.

    Alice 将 2n 个量子比特发送给 Bob，每个量子比特都是随机选择的 |0>、|1>、|+>、|-> 状态之一。由于通信是光学的，这可以使用偏振器来完成。

1.  2.

    Bob 测量接收到的比特，随机选择测量基础为 |0>、|1> 和 |+>、|->。这可以通过极性滤波器来实现。

1.  3.

    Alice 和 Bob 公开告知对方他们用来准备或测量每个量子比特的基础。

1.  4.

    他们找出彼此在哪些场合使用了相同的基础。这平均发生了一半的时间。那些使用相同基础的场合被保留下来。

1.  5.

    理想情况下，他们现在共享这 n 个量子比特的相同随机字符串，然后将这些量子比特映射到经典比特（例如，|0> 和 |+> 映射到 0，|1> 和 |-> 映射到 1）。这个位串被称为 RQT（*原始量子传输*）。

1.  6.

    Alice 和 Bob 公布了从 RQT 中随机选择（并预先定义）的一组 n/2 位。如果所有这些位都匹配，未公开的 n/2 位将被接受作为密钥。否则，它将被丢弃，并重新启动新的传输。

尽管算法看起来很直接，但是这里使用了量子纠缠的基本原理。Alice 和 Bob 没有公开传输的数据。每个实例使用的基础只是公开的，只要原始的量子比特流不存在，对窃听者就没有效果。如果窃听者设法拦截了位流，量子比特的方向就会改变，而且那个比特就不会匹配 RQT 中的对应位。根据概率估计，如果窃听者一直监听整个传输，那么它就会改变所有比特的方向，并且只需用到 RQT 的 50% 就可以检测到（因为它是一个二进制系统）。这是上述过程的第 6 步中完成的。这种方法的优势在于绝大部分算法可以直接实现。但是在远距离传输领域依旧面临挑战，因为光通信不仅在强度方面需要可靠，也在极性方面需要可靠。QKD 过程在 *Quantum Flagship* 中有所说明，见图 6。![](img/516210_1_En_5_Fig6_HTML.png)

图 6

QKD 的工作原理（*提供者：量子旗舰*）

## 5 区块链在无服务器计算中的应用

Tien 等人[29]提出了区块链的数据中心视图。它将生态系统分解为四个层，每个层处理不同类型的数据项。这些层如下所示。

1.  1.

    **共识：** 处理证明将新数据添加到链中的权限的数据。作为其中的一部分，值如 nonce、质押等可能被转移和验证。

1.  2.

    **数据模型：** 指的是链上正在处理的实际数据。它可能包括交易数据、索引、块等。符合共识条件的人有权生成数据模型的实例，并在获得批准后将其写入区块。

1.  3.

    **执行引擎：** 表示对数据模型执行的处理。它可能是在虚拟机、容器等上运行的代码片段。

1.  4.

    **应用程序：** 指的是以智能合约形式嵌入的应用程序层代码，在执行引擎内执行。

自[29]中的分层架构图已在图 7 中进行了调整。![](img/516210_1_En_5_Fig7_HTML.png)

图 7

分层架构—区块链的数据中心视图[29]

考虑到[29]中讨论的分层堆栈，可以创建一个抽象模型，在其中可以建立区块链实现和无服务器平台之间的类比。这将使区块链更容易集成到无服务器框架中。这种可能性在表 2 中得到了探讨。表 2

将区块链整合到无服务器平台的可能性

| 区块链层 | 在无服务器平台中的使用 |
| --- | --- |
| 共识 | 当有大量请求需要处理时，无服务器平台可以通过添加更多虚拟机来自动扩展处理能力。因此，将会有许多节点同时等待新请求。负载均衡器可以使用共识方法来选择哪个节点应该接受请求。 |
| 数据模型 | 无服务器平台使用请求-响应执行模型。这涉及请求标头、请求主体、响应代码、响应标头和响应有效载荷。请求直接转发到选定的节点，该节点可以执行它，并返回结果。在发送结果之前，应验证请求和响应数据后将其记录到区块链中 |
| 执行引擎 | 这可以是微型虚拟机或容器，用于运行服务器代码。虽然选择了一个节点进行执行，但其他节点可能需要通过运行自己的代码并验证输出是否如广告中所述来验证输出。根据选择的语言，可以安装容器或虚拟机。以太坊平台已经支持用于运行其智能合约的 EVM |
| 应用程序 | 每当有新的请求到来时，都会将其记录为一个事务，并启动智能合约。智能合约将包含要执行的实际代码，并在验证后将输出写入链中 |

FBaaS [30]是提供区块链作为云服务的实现。它由以下几层组成。

1.  1.

    *基础设施层*建立在普通计算节点上（不是无服务器）。

1.  2.

    *组件层*处理在执行中常用的身份验证和授权操作。用于此目的的是*基于角色的访问控制*。

1.  3.

    *服务层*承载要执行的区块链代码。它负责对象存储、事务启动、挖矿、链管理和冲突解决（在一致性不一致的情况下）。它还通过根据需要部署容器来执行自动扩展。这个过程被称为*功能服务器*。

1.  4.

    *业务逻辑层*公开供参与者使用的服务。可以在现有层之上添加抽象以扩展功能。

ChainFaaS [31] 是一种利用区块链实现无服务器平台的实现。区块链在架构中的作用是维护执行日志，并跟踪财务交易（作为执行费用支付给服务提供者）。它以不同的方式实现了上述讨论的架构。

1.  1.

    *区块链网络* 负责记录日志并跟踪执行费用。

1.  2.

    *无服务器控制器* 是与外部的接口，并维护调度部分。

1.  3.

    *执行网络* 负责维护和部署容器和虚拟机以执行操作。

另一种使用区块链的微服务实现在 [32] 中进行了讨论。它对传统的基于 API 的无服务器实现和基于区块链的实现进行了比较。在 [32] 提出的架构中，微服务直接编写为智能合约，类似于 API 所做的。这些智能合约可以使用远程过程调用来访问外部实体。[32] 中的架构如图 8 所示。

图 8

API 对比区块链——实现微服务 [32]

上述三种实现可以根据表 2 中讨论的通用架构进行比较。比较结果如表 3 所示。

FBaaS、ChainFaaS 和微服务架构的比较

| 区块链层 | FBaaS [30] | ChainFaaS [31] | 微服务 [32] |
| --- | --- | --- | --- |
| 共识 | 服务层 | 区块链网络 | 区块链层 |
| 数据模型 | 服务层 | 区块链网络 | 区块链层 |
| 执行引擎 | 服务层 | 执行网络 | API 网关和区块链层 |
| 应用 | 业务逻辑层 | 无服务器控制器 | API 前端 |

## 6 无服务器计算中的量子密钥分发

### 6.1 无服务器域中的安全性

Eric 等人[14]列出了仅由无服务器计算引起的最重要的安全问题。虽然这种范式在认证和协议级违规方面都存在安全漏洞，但由于对资源供应的控制有限，会引发一些额外的危险。这些危险是由于应用程序模块化而引起的应用程序分解和负载平衡而导致的。需要考虑的重要安全挑战如下。

+   物理隔离可能必须确保，以防止任何攻击者获得对其他进程的共同访问。由于云进程是短暂的，攻击者有可能在它们执行中间时获得对未受保护进程的访问。

+   可能需要细粒度的安全管理，因为安全策略必须在执行代码的每个节点强制执行。

+   随着大型应用程序被分解为小函数，它们将必须保持彼此之间的通信，以确保连续性。作为其中的一部分，中间输出将必须在 API 调用之间传输。即使端到端受保护，这种转移也可能泄漏模式和敏感信息。

+   如果在函数内部访问任何外部服务（如外部数据库），则需要将访问权限暴露给函数的所有可能托管位置。否则，由于它们不在允许列表中，某些访问将被阻止[2]。

### 6.2 使用 QKD 作为安全机制

量子密钥分发的概念在 4.1 节中介绍。Scarani 等人[33]验证了一个实用的 QKD 算法 BB84 的证明，并评估了不同发射机和通道在其工作中的有效性。Shor 和 Preskill[34]考虑到重叠的量子态对其进行了评估，并发现该算法足够抵御大多数攻击。

Kiktenko 等人 [35] 展示了一个模型，其中区块链本身可以使用量子密钥分发（QKD）进行安全保护。它设计在一个两层结构之上。QKD 可以安全地生成对称密钥。因此，第一层将是一个网状网络，它在所有节点对之间运行 QKD，从而在它们之间生成无条件安全的密钥。第二层将是一个使用安全生成的私钥进行进一步传输的传统网络。它还改变了新区块被挖掘的框架。由于量子计算机具有巨大的固有并行性（因为叠加，它们同时处于多种状态），一个足够强大的量子计算机可以同时创建足够多的区块以压倒性地进行攻击并执行 51% 攻击。相反，[35] 中的建议强制要求为每个区块进行广播，并且必须获得个人批准。该协议对所有链的完整性进行周期性检查。他们能够使用光调制的量子比特成功地在小规模上进行演示。

在[36]中描述了一些能够在后量子生态系统中生存的加密模型。Rajan 等人[38]将其推进一步，并改变了纠缠本身的概念。他们提出将光子编码成*格林伯格-霍恩-泽林格（GHZ）状态*，这确保了在空间中不会发生超定态的同时共存，而是发生在时间上。这意味着，如果在时刻 t 时有一个量子位状态 ![$$\psi $$](img/516210_1_En_5_Chapter_TeX_IEq1.png)，那么在某个 t 时刻也有可能生成相同的状态 ![$$\psi $$](img/516210_1_En_5_Chapter_TeX_IEq3.png)。因此，密钥不必立即传递，而可以在以后的某个时间重新生成。但这会增加篡改的风险，因为在 t=0 时改变状态可能会影响到其纠缠时刻 t ![$$=$$](img/516210_1_En_5_Chapter_TeX_IEq5.png) k 的工作。

## 将量子密钥分发（QKD）和区块链集成到无服务器领域 

正如前面的部分所示，无服务器平台的关键是快速资源配置和代码执行。智能合约在以太坊上似乎很好地解决了这两个问题。此外，CSPs 的共享责任模型将安全责任放在了开发人员和用户自身的云端。这可以通过使用加密方法来解决。在这里，提出了一种方法，利用区块链和量子密钥分发来创建一个可扩展且安全的平台，以支持传统的无服务器平台。

### 7.1 服务器代码的部署

在[1]中为无服务器平台提供了一个明确定义的编程模型。下面讨论的是以下方面。

+   由于无服务器程序是短暂的，因此在执行之间保持状态将会很困难。后续执行甚至可能会被路由到不同的虚拟机。因此，它们从设计上就是无状态的。为了保持连续性，状态信息（包括安全信息）会作为参数随每次调用一起发送。另一个选择是在持久存储或数据库中（如 Amazon S3 桶或 Google Cloud SQL）维护状态，但这会比无状态实现慢。

+   维护适当的顺序是至关重要的，因此编程框架是必不可少的。当使用诸如 Python 或 Node.js 之类的语言时，路由框架将有助于连接到 web 挂钩，并避免可能干扰负载平衡能力的额外桥接代码。

+   定义为无服务器的函数可能需要根据各种事件（如在存储中添加新文件）自动触发，这在本质上是无状态的。

+   无服务器函数可能需要从内部调用其他公共 API，因为它可能作为*粘合代码*，以防止终端客户端调用一系列 API。在这种情况下，还应考虑安全性。这最终导致了聚合 API。

因此，作为基于需求的自动缩放的一部分启动的每个节点都将具有以下属性。

+   节点将加载一个包含区块链层和智能合约的微型 VM 或容器。

+   链不会驻留在短暂的节点内。相反，它会被卸载到 Amazon S3 桶或 Google Cloud SQL 等稳定存储中。

+   节点的工作完全是无状态的。节点不应因等待来自稳定存储的输入而导致执行延迟。

图 9 给出了该层的抽象示例。![](img/516210_1_En_5_Fig9_HTML.png)

图 9

无服务器智能合约部署

### 区块链和共识算法

根据 NIST [22] 的说法，*权限区块链*是一种必须经过某种授权机构授权的区块链。这使得限制访问变得更加容易。读写访问可以由一个中央管理访问控制的实体在多个级别进行管理。尽管区块链作为一个概念在去中心化上蓬勃发展，但在服务器执行的情况下，这种集中式的控制模式可能是有益的，特别是由于执行节点是暂时的，并且可以从任何位置启动。使用权限区块链将允许基于服务的访问控制。根据图 4 中给出的决策流程图，由于（i）需要持久化跨暂时执行的状态存储，（ii）存在多个写入者，（iii）信任的第三方可能并不总是可用，（iv）所有写入节点已知（它们由云提供商启动），（v）所有写入者不能直接信任（攻击者仍然可以操纵它们，因为它们暴露在互联网上，并且在共享责任模型下安全性不能得到保证），以及（vi）不需要公开可验证性，因此服务器无应用程序最好使用权限区块链。

为了避免昂贵的计算，采用了权益证明（PoS）共识模型。在这个模型中，拥有最高权益（货币）的参与者将获得插入下一个区块的权限。所有节点都验证权益金额以达成共识。但从长远来看，这可能变得不公平，因为最富有的节点总是获得权限。因此，我们的模型将使用基于密钥的半随机选择过程。在这个模型中，每个节点将生成一个随机数，然后对其进行哈希以生成一个 256 位的数字。这个哈希与密钥进行异或运算以获取*权益*。然后这个权益被广播给所有节点，并就谁有权添加下一个区块达成共识。

一旦修改的 PoS 就位，焦点转向密钥传输。密钥传输基于 QKD，使用偏振或调制的光子携带它们的量子状态。根据第 4.1 节的描述，它本质上是防篡改的。因此，我们实施以下多阶段过程。

1.  1.

    客户端启动与服务器的通信。为此，使用量子密钥传输创建客户端和服务端负载均衡器之间的对称加密通道。来自客户端的一个 1024 位的有效载荷被传输，这个有效载荷被负载均衡器（接收方）接收，并从量子比特映射到二进制，生成 RQT。这个 RQT 将是原始有效载荷大小的一半，得到 512 位。然后，这个 RQT 随机验证成功，公布 256 位，如果成功，另外 256 位形成最终的**密钥**。密钥偶尔可能会更新。

1.  2.

    当请求到达负载均衡器时，所有可用节点将被激活，并生成一个随机数（**nonce**），然后对其进行 256 位哈希处理。这个数字与从 QKD 生成的密钥（也是 256 位）进行异或运算，结果被广播为**股份**。

1.  3.

    一旦所有节点广播它们的股份，拥有最大股份的节点有资格向链中添加块。这个节点是**选择的**节点。

作为示例，我们考虑一个将系统缩小到 16 位密钥的情况。因此，原始通信需要 64 位长。这个过程在表 4 中进行了标记。在开始时考虑十六进制表示法。表 4

QKD 和共识的执行顺序：16 位密钥示例

| 操作 | 位 | 内容 |
| --- | --- | --- |
| 传输 | 64 | ![$$608918c0659e33dc_H$$](img/516210_1_En_5_Chapter_TeX_IEq6.png) |
| 接收 | 64 | ![$$608918c0659e33dc_H$$](img/516210_1_En_5_Chapter_TeX_IEq7.png) |
| 假设交替位根据基数有效 | 32 | ![$$4a284b5a_H$$](img/516210_1_En_5_Chapter_TeX_IEq8.png) = ![$$1001010001010000100101101011010_2$$](img/516210_1_En_5_Chapter_TeX_IEq9.png) |
| 选取交替位进行验证 | 16 | ![$$3633_H$$](img/516210_1_En_5_Chapter_TeX_IEq10.png) = ![$$011011000110011_2$$](img/516210_1_En_5_Chapter_TeX_IEq11.png) |
| 成功验证后的密钥 | 16 | ![$$809c_H$$](img/516210_1_En_5_Chapter_TeX_IEq12.png) = ![$$1000000010011100_2$$](img/516210_1_En_5_Chapter_TeX_IEq13.png) |
| 地址: 节点 1 | 64 | ![$$3de1016e288ba240_H$$](img/516210_1_En_5_Chapter_TeX_IEq14.png) |
| 地址: 节点 2 | 64 | ![$$e1681f706a664a1a_H$$](img/516210_1_En_5_Chapter_TeX_IEq15.png) |
| 哈希值(随机数): 节点 1 | 16 | ![$$f9f5_H$$](img/516210_1_En_5_Chapter_TeX_IEq16.png) = ![$$1111100111110101_2$$](img/516210_1_En_5_Chapter_TeX_IEq17.png) |
| 哈希值(随机数): 节点 2 | 16 | ![$$e686_H$$](img/516210_1_En_5_Chapter_TeX_IEq18.png) = ![$$1110011010000110_2$$](img/516210_1_En_5_Chapter_TeX_IEq19.png) |
| 密钥 XOR 随机数: 节点 1 | 16 | ![$$7969_H$$](img/516210_1_En_5_Chapter_TeX_IEq20.png) = ![$$0111100101101001_2$$](img/516210_1_En_5_Chapter_TeX_IEq21.png) |
| 密钥 XOR 随机数: 节点 2 | 16 | ![$$661a_H$$](img/516210_1_En_5_Chapter_TeX_IEq22.png) = ![$$0110011000011010_2$$](img/516210_1_En_5_Chapter_TeX_IEq23.png) |
| 胜利者 | 16 | 节点 1 (因为 ![$$7969_H$$](img/516210_1_En_5_Chapter_TeX_IEq24.png) > ![$$661a_H$$](img/516210_1_En_5_Chapter_TeX_IEq25.png)) |

### 7.3 智能合约执行

一旦选择了节点来执行合约，合约就会读取请求并运行加载的代码库。该代码库每个节点加载一次，并类似于 API 调用。步骤序列如下。

1.  1.

    该节点的代码库接受请求参数，并在需要时执行验证。

1.  2.

    函数被执行，并生成结果作为交易有效负载。

1.  3.

    负载在所有节点之间广播，并随机选择一个节点通过执行其本地副本来验证结果。如果两者匹配，则结果已准备好传播。如果不匹配，则第三个节点将执行，并采用多数答案。

1.  4.

    如果没有足够的节点来验证和验证交易，则默认接受原始输出。

1.  5.

    交易以 *{请求头、请求有效负载、密钥、随机数、执行时间戳、选定节点详情、验证节点详情、冲突详情、响应有效负载}* 的格式通过其自己的区块链 API 调用写入到稳定存储中。

以下是一个解释。给出了增加输入值的智能合约代码库的一部分示例。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figa_HTML.png)从 IP 119.208.23.5 收到请求，请求增加值“100”。如前所述，节点 1 准备执行合约。它被执行，并生成以下有效负载。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figb_HTML.png)这被发送到所有节点，节点 2 将验证其正确性。由于它是正确的输出，因此可以发送到稳定存储。以下交易被记录。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figc_HTML.png)

## 8 讨论

Gill 提出了一个参考模型[39]，其中结合了区块链、量子计算和无服务器技术，用于物联网领域。还在[40]中提出了无服务器领域的量子整合。第 7 节讨论的架构是针对一个通用用例而创建的，具有固有的分层结构，类似于[39]中的那样。原则上，它应该在动态负载下保持稳定。 Kaplunovich 等人[41]使用基于 AWS SQS 和 Lambda 的 Hyperledger Fabric 进行了研究，并发现即使支持无服务器计算的概念，云在涉及区块链层时很难扩展。这是因为在更新链时可能存在有限的并发性。为了尽可能地管理它，可以使用 Amazon QLDB（量子分类数据库），这是一种在区块链之外完全受控且可追溯的解决方案。所提出的架构也旨在通过以下方面最小化对区块链层的负载。

+   区块链仅被用作日志记录工具。在日常操作中不存在数据读取。

+   所有加密和解密都在负载均衡器级别进行管理。不需要数据访问。

+   共识完全基于权益证明，这完全依赖于传入密钥和 nonce。

Xiaoqi 等人[42]对区块链中不同安全弱点进行了详细分析。所提出的架构通过内在方式或设计方式缓解了一些已鉴定的弱点。表 5 描述了采取的措施和进一步的机会。表 5

在提出的解决方案中，安全问题及其管理

| 鉴定的问题 | 解决方案/机会 |
| --- | --- |
| 51%易受攻击性 | 因为没有使用 PoW，而 PoS 使用即时生成的关键和 nonce 生成的权益值，因此已处理好。 |
| 私钥安全 | 可以使用云原生密钥管理系统。主密钥可以基于 QKD 协商的密钥 |
| 犯罪活动 | 超出范围，因为应用领域仅限于基于计算。根据共享责任原则，云安全由用户负责 |
| 双重支付 | 由于无服务器平台中的双重支付问题只是创建相同响应有效负载的多个副本，因此可以安全地忽略 |
| 交易隐私泄露 | 不保存私人信息。日志只包含 IP 级别信息 |
| 犯罪智能合约 | 由于交易具有计算性质，犯罪智能合约可能会对存储在远程位置的机密数据生成不必要的访问。用户必须偶尔手动验证合约。由于使用了容器，直接启动恶意代码很困难。但合约应对注入攻击免疫 |
| 智能合约中的漏洞 | 异常情况应得到妥善处理。共享责任原则在这里适用 |
| 未优化的智能合约 | 开发者应负责创建优化的代码。云平台上的适当预算警报将标记资源可能过度利用的情况。由于无服务器执行是短暂的，并且持续时间最长为 15 分钟，编写不良代码将导致过早终止 |
| 低价操作 | 由于操作不涉及转移利益，因此定价不是问题 |

从两个分析中，我们可以推断，当在无服务器平台上部署时，所提出的架构应该能够在很大程度上保持可扩展性和安全性。

## 9 结论

随着云计算的出现，无服务器执行已成为应用开发人员的热门选择。它通过自动化提供和扩展过程，将基础设施的建立、配置和管理工作从开发人员手中解放出来，但由于过度自动化而遭受安全问题的困扰，这一问题正在借助区块链得到缓解。将区块链纳入其中，他们可能会在可扩展性上遭受潜在的减少，但通过控制每个请求时激活的节点，这一问题已得到很好的解决。此外，分层架构使其能够轻松适应不同类型的工作负载，保持了共享责任的概念完整性。
