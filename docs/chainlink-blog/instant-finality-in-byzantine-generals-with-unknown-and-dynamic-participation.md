# 未知和动态参与的拜占庭将军的瞬间终结

> 原文：<https://blog.chain.link/instant-finality-in-byzantine-generals-with-unknown-and-dynamic-participation/>

*作者:Dahlia Malkhi (Chainlink Labs)，Atsuki Momose (UIUC)，Ling Ren (UIUC)*

## 剧情简介

我们为拜占庭将军问题提出了一个非常简单的解决方案，在具有未知和动态参与的设置中具有 **确定性和无条件的安全保证** ，但是没有工作证明 的能量消耗或者最长链协议的长等待时间。这样，我们消除了 Nakamoto Consensus 的最大障碍，即概率终结性、高延迟和工作证明的能耗，同时保留了无许可模型的关键原则。

第一次见面时，上面的问题似乎令人生畏:当参与者来来去去，甚至没有一个已知的活跃参与者的数目时，他们怎么能达成一致呢？

去掉工作证明，Pass 和施 引入的 [【瞌睡】模式，借用了无权限设置的两个核心支柱。一个是连续性，要求 **在当前活跃的参与者之间同步** 消息传播，以便在面临流失时能够传递知识。第二个是在任何时刻，都有一个未知的 **和动态的** 集合的活跃的(并且同步连接的)团体，这些团体具有诚实的多数。在这两种假设下(下面将详细描述)，Sleepy Consensus 解决了拜占庭协议，但是继承了最长链协议的 **概率安全** 和高延迟。](https://eprint.iacr.org/2016/918.pdf)

在类似的未知和动态参与模型下(具有关于同步性的更实际的假设，即没有无限缓冲)，[Atsuki 和任](https://eprint.iacr.org/2022/404.pdf) 的最近结果通过展示具有 **确定性** **安全性** 保证和预期的恒定等待时间的拜占庭协议的解决方案而开辟了新天地。然而，只有当参与在足够长的时间内不再活跃时，活性才能得到保证。此外，即使在这样的时期，延迟中的常数因子也有些大。

通过要求更高的诚实参与门槛——三分之二而不是诚实的多数——我们展示了在未知和动态参与模式下拜占庭协议的一个非常简单的解决方案。它具有 **确定性和无条件安全性** 保证和一个 **(小)常数期望延迟** ，克服了上述缺点。此外，我们提到过它非常简单吗？正如下面 中的 所证明的，该算法看起来并不比具有静态和已知参与者集的经典设置中的异步协议更难或不同！

在这里，我们提出我们的解决一次性 **二元拜占庭协议** 的范例。在未来的帖子中，我们将(I)扩展到多值共识，(ii)扩展到共识决策链(即原子广播问题)，以及(iii)利用基于领导者的范式来提高平均案例回合复杂性。

## 未知且动态的参与模式

为了便于说明，我们将把时间看作是分成离散的“轮”。实际上，模型可以用来定义，我们的解决方案可以扩展到连续时间。

为了在协议中提供知识的连续性，无许可协议实际上做了一个强同步 假设:在每对诚实参与者(称为“节点”)之间存在一个已知的信道传播延迟上限 ，封装在我们的 round 模型中。

**同步通信。** 如果一个诚实节点 p 在回合 r 中发送消息，那么在回合 r+1 中活跃的每个诚实节点 q 接收该消息。

无许可共识协议通常假定积极参与者中的诚实多数。在这里，我们对诚实参与者的门槛要求更高。这大大简化了结构。

**诚实参与。** 在每一轮中，都有未知数量的活跃参与者，其中超过三分之二是诚实的。

参与假设值得进一步澄清。在一个动态的环境中，参与者在各轮之间不断变动，包括失误。我们必须假设，如果一个有故障的节点发生故障，它的消息不会在以后的循环中出现。与先前的工作相比，这是一个更弱的假设，先前的工作假设所有的错误方在整个执行过程中都是活跃的。

**未知而动态的参与模式概括地说** 。总结一下，我们有以下模型。在每个时刻的活动节点的集合是未知的，它们的计数是未知的，并且在每一轮，它们可能被完全替换，服从以下假设:

*   PKI:参与的节点取自一个有限的宇宙，每个节点可以用一个公钥来标识，它拥有这个公钥的私钥。
    *   注意，只有 VRF 和活性才需要 PKI 消息不需要由它们的发送者 签署
*   活跃节点:每轮 r 有一组未知的活跃 *节点* ，其(未知)计数 *n <sub>r</sub>* 满足*n<sub>r</sub>≥3f<sub>r</sub>+1*。
*   同步通信:在 r 轮中，诚实节点和主动节点接收 r-1 轮中诚实节点广播的所有消息。

## 拜占庭协议问题

这个问题已经描述过很多次了。简而言之，在二元协定变体中，一组参与者最初持有输入值∈ {0，1} (一位)，并就满足的输出值达成一致

*   **安全** :两个诚实方的输出相同
*   **有效性** :如果所有诚实方以相同的输入值开始，输出就是那个值
*   **活跃度** :最终所有诚实方输出一个值

## 未知动态参与模型中的二元协议

我们介绍一个一次性 二元协议的解决方案，它保证了安全性和预期的(小的)恒定的终止轮数。

我们首先深入探讨我们所研究的可转移性的关键机制。

**未知的动态仲裁属性(UDQ)。** 每个节点在第(r+1)轮中接收在第 r 轮期间发送的一组消息。我们观察到以下关键事实:

*   表示一个诚实节点在 R 轮(r+1)中收到的未知数量的消息，我们有 *R* ≤ *n <sub>r</sub>*
*   由于同步性，在 r 个消息中，至少有*个⅔ n <sub>个 r</sub> 个 r*个 T5】 ≥个⅔r个消息是从诚实的 round-r 节点接收的。
*   未知数*t<sub>r</sub>T4】≤*⅓**r**来自 r 的消息来自有故障的 round-r 节点。

假设每个协议消息携带单个值。以下保证成立:

*   **UDQ-unique:** 在一轮中，如果一个节点 p 接收到携带值 b 的超多数消息，另一个节点 q 接收到携带值 b’的超多数消息，则 b = b’。请注意，UDQ-unique 在静态设置中提供了与 quorum-intersection 类似的保证，但是没有能力 *传输* 一组签名消息作为接收超级多数的证书。    UDQ-unique 成立，因为如果诚实节点 p 在 round-(r+1)中接收到携带值 b 的绝大多数 round-r 消息， 然后大多数诚实的 round-r 消息携带 b .这成立是因为: *⅔r–t<sub>r</sub>=⅔(n<sub>r</sub>–f<sub>r</sub>+t<sub>r</sub>–t<sub>r</sub>=(n<sub>r</sub>–f<sub>r</sub>+⅙(n<sub>r</sub>–f*

*   **UDQ-valid:** 如果一个诚实节点在 round-(r+1)中接收到超过三分之一的携带 b 的 round-r 消息，那么某个诚实节点已经发送了一个携带 b 的消息。这与上面的推理类似: *⅓(r–t<sub>r</sub>)=⅓(n<sub>r</sub>–f<sub>r</sub>+t<sub>r</sub>)-t _ r = t _ r*

*   **UDQ-graded-agreement:**如果一个诚实节点 p 在 round-(r+1)中接收到包含值 b 的绝大多数 round-r 消息，那么在 round (r+1)中由另一个诚实节点接收到的 round-r 消息的三分之一以上包含 b。

给定 UDQ，很容易在两个广播步骤中构造一个单次二进制协议。它的工作原理如下。

协议从节点通告其输入的一轮开始，然后继续在 *收集-GA 轮* 和 *决策-GA 轮之间交替。* 在一轮中，主动节点侦听传入的消息(在前一轮中广播的)，对其进行处理，并广播一条消息。

#### 节点 p 的协议

初始化-回合 0:

*   一个节点向所有节点广播(0，收集，输入)

收藏-GA r+1:

*   *设 S-collect 为接收消息的集合(r，collect，*)*
*   *一个节点广播到所有节点:**【r+1，求婚，b)如果超过三分之二的 S-collect 都是(r，collect，b)**(r+1，求婚，“空”)否则*
*   *同时，一个节点向所有节点广播:**(r+1，VRF，c)其中 c* 为随机位

决定-GA r+2:

*   *设 S-propose 为接收消息的集合(r+1，propose，*)*
*   *A 节点 p 处理 S-propose 如下:**决定 b:如果超过三分之二的 S-propose 都是(r+1，propose，b)**采用 v**p**←b:如果超过一*
*   *一个节点 p 向所有节点广播:(r+2，收集，v**p**)*

在 collection-GA 轮次中，节点收集包含其他节点采用值的消息。在一个 collection-GA 轮结束时，如果一个节点对于某个值 b 接收到超过三分之二(collect，b)，那么它广播(propose，b)；否则，它会广播(提议，“空”)。同时，一个节点广播(VRF，c ),其中 VRF 是一个唯一的伪随机值，并且可使用该节点的公钥和整数来验证，c 是本地硬币投掷。注意，在执行的第一轮，节点发送带有自己输入的收集消息。

在 decision-GA 回合中，节点收集(propose，*)。每个接收超过三分之二(propose，b)消息的节点 **决定** b .每个接收超过三分之一(propose，b) **的节点采用** b 作为其当前值。其他节点采用消息(VRF，b’)中的随机值 b’，其(验证的)VRF 值在它们接收的所有 vrf 中是最高的。在一个决策-GA 循环的末尾，每个节点 p 广播(collect，v p )携带其采用的值。

### 正确性(草图)

**权利要求-1【独特-采用】。** 在 decision-GAs 中，最多只能强制采用一个值 b。为了被采用，一个值必须被前面集合的三分之一以上接收-GA 的消息。通过 UDQ-valid，它由一个诚实的发送者发送。然而，通过 UDQ-unique，集合 GA 中的诚实节点最多可以广播一个值 b。

权利要求 2【安全性】。 如果一个诚实的节点在一个 decision-GA 中决定 b，那么通过 UDQ-GA，每一个其他诚实的节点接收到超过前一个 collection-GA 的三分之一的消息携带(propose，b)。通过 Unique-adopt，只有 b 可能被强制采用。因此，每个诚实的一方在决策 GA 中采用 b。很容易看出，集合遗传算法和决策遗传算法的迭代以所有诚实节点采用 b 开始，以所有诚实节点决定 b 结束

索赔-3[终止]。 同样，如果所有诚实节点都以 b 开头，那么终止很容易。如果没有做出决定，通过 UDQ-adopt，最多可以强制采用一个值 b。按照概率，b 将是一个获胜的 VRF 值并被每个人采用。

## 未知动态参与的解

|  | **认证** | **安全保障** | **等待时间** | **门槛诚实** |
| **中本聪共识 2008** | 工作证明 | 概率性 | 高 | 多数 |
| **瞌睡共识 2016** | PKI | 概率性 | 高 | 多数下  永久失败 |
| **厚木&任 2022** | PKI | 确定性 | (稍大)常数 | 永久性故障下的多数 |
| **本作品 2022** | 安全认证通道和活性 PKI | 确定性和无条件性 | (小)常数 | 三分之二 |

Read more about this work in our recently published whitepaper: [https://eprint.iacr.org/2022/1448](https://eprint.iacr.org/2022/1448).

#### 致谢

与 Lorenzo Alvisi、Ittay Eyal、Jacob Leshno、Kartik Nayak 和 Youer Pu 就此话题展开的讨论让我们受益匪浅。

## 建议阅读

*   [【关，石，2016】共识的困倦模型](https://eprint.iacr.org/2016/918.pdf)
*   [【巴加利亚，坎南，谢，凡提，维斯瓦纳思，2019】棱镜:解构区块链逼近物理极限。T3】](https://arxiv.org/pdf/1810.08092.pdf)
*   [【Khan chandani，Wattenhofer，2021】未知参与者与失败的拜占庭协议](https://arxiv.org/abs/2102.10442)
*   [【Lewis-Pye，Roughgarden，2021】未经许可设置中的拜占庭将军](https://arxiv.org/abs/2101.07095)
*   [【Goyal，Li，Raizes，2021】瞌睡模型中的即时阻断确认](https://dl.acm.org/doi/abs/10.1007/978-3-662-64331-0_4)
*   [【Deb，Kannan，Tse，2021】PoSAT:证明工作的可用性和不可预测性，没有工作](https://dl.acm.org/doi/abs/10.1007/978-3-662-64331-0_6)
*   [【普，阿尔维斯，埃亚尔，2022】安全无权限共识](https://eprint.iacr.org/2022/796)
*   [【郭，任，2022】比特币的潜伏性——安全性分析简单明了](https://arxiv.org/pdf/2203.06357.pdf)
*   [【Atsuki，Ren，2022】瞌睡中的恒定潜伏共识](https://eprint.iacr.org/2022/404.pdf)