# 链环中的门限签名

> 原文：<https://blog.chain.link/threshold-signatures-in-chainlink/>

<small style="margin: 40px;">**摘要**:门限签名提供了一种简洁、廉价的方式来验证超大规模群体的共识，我们计划用它们来独立于以太坊的吞吐量来扩展 Chainlink 的安全性。在这篇文章中，我(1)回顾了门限签名是如何工作的，跟随 [Stinson &施特罗布尔 2001 年的论文](https://dl.acm.org/citation.cfm?id=678297)；(2)描述一种新的类似 Schnorr 的签名，其在可靠性方面[验证便宜](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-10a5b62d9dbf96402840ec82e11c3416R1)(仅 15k 气体，包括输入参数)；(3)介绍我开发的[门限签名构造](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-abacaa303fde0503396c86b9aac969a1R1)的实现，使用[类似 Schnorr 的签名](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-8cfbd9698bce280443de30b78698d492R1)。</small>

## 介绍

如果连陌生人都能被信任遵守承诺，这个世界会变成什么样？有多少协作和互助没有实现，因为太难相信我们对彼此的承诺了？在 [Chainlink Labs](https://chainlinklabs.com/) ，我们的目标是找出答案，因为我们的目标是帮助人们制定安全的智能合同，忠实地响应现实世界的结果。

像以太坊这样的区块链上的智能合约，一旦参与者的行为被证明，就可以可靠地奖励或惩罚<sup class="footnote-ref">[【1】](#fn1)</sup>当操作正确时，这是一种比合同法<sup class="footnote-ref">[【2】](#fn2)</sup>更便宜、更安全的执行形式。但是，为了对人们真正关心的现实世界的行为做出承诺，智能合同需要可靠的相关现实世界事件的报告。例如，今天你可以制定一个智能合同奖励解决方案来解决[某些数学问题](https://etherscan.io/address/0xdfab9f43f279bd8bd87026b84105c5d1543ae99e#code)<sup class="footnote-ref">[【3】](#fn3)</sup>，但是一个关于干旱等现实世界风险的保险合同需要信任有人告诉它干旱何时发生。

建立一个智能契约相对容易，当有人发布交易报告真实事件时，它会做出响应，但就其本身而言，这是一种不可靠的安排。随着越来越多的价值取决于该报告的结果，腐败 it 的动机变得巨大。因此，我们需要一种方法，让任何对手影响报告的成本更高，理想情况下是不可能的。

在某种意义上，这可以被视为比特币原始共识机制目标的概括，比特币包含了解决方案的核心:为了解决“双重花费”问题，比特币需要对哪些比特币交易是有效的进行可信的观察，而解决方案是一种分布式共识，通过赢得工作证明彩票所展示的“游戏中的皮肤”来衡量参与。

[Chainlink 的](https://chain.link/)当前处理现实世界事件的方法是由一组*的“先知”将他们的观察报告给一个智能合同，该合同估算一个总价值。这个群体越多样化，对手收买的破坏结果的观察者就越多，所以系统就变得越安全。问题是，让每个人单独向区块链汇报是相当昂贵的。历史上，在以太坊上，有 25 天这种幼稚的报告可能会花费超过 1.5 美元<sup class="footnote-ref">[【4】](#fn4)</sup>。因此，如果你想得到 2000 名参与者的确认，在那些日子里可能要花费 3000 多美元！一个承诺在一年内每天提供 2000 次验证的集团可能面临数十万美元的天然气成本，这只有在利润率极高的合同中才可行。即使按照今天的价格，这样的报告一年的总天然气成本也要数千美元。*

 *同时，如果你真的需要一个由 2000 名观察者组成的特定小组来确认一份报告，他们中的任何一个人都可能因为没有发送他们的确认而推迟对真实世界观察的确认。因此，为了确保报告通过，我们真的需要一个任意的子集来确认，比如说 2500 个中的 2000 个。这样，500 个报告可能会失败，但共识值仍会到达区块链。

如果这听起来很像多 sig 合同，它确实是，但在现有的多 sig 钱包中确认交易的气体成本随着参与者的数量线性增长。在这篇文章中，我将描述*门限签名*，这是一种加密方案，其中任意一组签名者可以构造*一个*签名，只要有足够数量的签名者。这极大地提高了效率，因为几乎所有的计算都可以由签名者在提交给以太坊之前完成，而且他们最终提交的内容非常简洁。。

我们目前最好的门限签名方案([在本帖](#cheaponchainverificationofschnorrsignatures)中描述)需要大约 15k 的气体来确认<sup class="footnote-ref">[【7】](#fn7)</sup>。这意味着，例如，我前面提到的“3，000 美元的数据点”将只花费大约 2 美元，节省了 1，500 倍(按照当前的天然气/ETH 价格，成本将略高于 1 美分，而使用当前的框架，验证 2，000 人的法定人数大约需要 17 美元。)

签名参与者之间的共识是独立于以太坊建立的(具有非常简洁的链上验证),这一事实也意味着 Chainlink 的安全性可以在以太坊的吞吐量没有提高的情况下扩展。这将允许合同依赖于*更大的*观察集，因为任何足够大的参与者子群都可以在观察值上达成一致，并在链外集体签名。限制因素将变成在共享私钥和签名的构造期间参与者之间的链外通信的成本(两者都随着参与者数量的平方而增长。)使用我们一直在开发的其他方法，甚至在未来的博客帖子中可能会讨论的其他方法，甚至有可能超越这一限制，扩大到有效的共识。

## 密码学预备知识:离散对数、彼得森承诺等等

数学家热爱强大的抽象<sup class="footnote-ref">[【8】](#fn8)</sup>，他们也热爱双关语。我们将要处理一些数学对象，它们都有不同的加法和乘法概念。这些算术概念都与被称为*组*、*环*和*字段*的常见抽象相关，但重要的是要记住，对每一个的算术运算都是不同的。这些抽象的美妙之处在于，你从常规算术中获得的直觉大多会继续存在。当有重大分歧时，我会尽力让你知道。重要的是，如果我说的是“$G+H$”这样的话，不一定要假设$G$和$H$一定是数字，只是因为我在加它们。“+”还有一种双关语。希望对象的类型将从上下文中明确。

我们要加密的数学对象是一条椭圆曲线。如果你不熟悉它们或它们在密码学中的应用，我推荐 Andrea Corbellini 的内容丰富的介绍。但我的目标是，你不需要知道所有这些就能理解。我们现在真正需要接受的是，在曲线点上有一个运算，看起来很像整数的常规加法，因为

*   我们可以将点彼此相加，得到另一个曲线点。这是第一个双关语:如果$G$和$H$是曲线点，我们用$G+H$表示它们的和。这看起来一点也不像数字加法<sup class="footnote-ref">[【9】](#fn9)</sup>，但以下事实意味着它具有类似的代数性质。
*   有一个零点，当你把它加到其他点上时，它没有任何影响。
*   每个点都有一个否定，当你把一个点和它的否定相加，就得到零点。
*   当你把一系列的点加在一起时，相加的顺序并不重要。
*   曲线上有一个点 G，它生成了整条曲线，如果你能计算$\{G，G+G=2G，G+2G=3G，G+3G=4G，…\}$等等，你最终会得到曲线上的每一个点。

在这里，当你做整数加法时，$G$扮演着与数字 1 相似的角色:正如你可以将任何正整数$m$表示为$m$个一的和，$1+\ldots+1$一样，原则上你可以将任何曲线点$H$表示为$G$的倍数，对于某个数字$m$来说，可以表示为$mG$的倍数。

在运行完曲线上的每一点后，序列$(G，2G，3G，\ldots)，$“绕回”到$G$。让我们称曲线上的点数为$q$<sup class="footnote-ref">[【11】](#fn11)</sup>(出于安全考虑，$ q $需要是一个不可理解的大质数。)所以我们有$(q+1)G = G $<sup class="footnote-ref">[【12】](#fn12)</sup>。出于这个原因，根据元素$𝔽_q=\{0、\ldots、q-1 \ }＄上的[“时钟算法”](https://en.wikipedia.org/wiki/Modular_arithmetic)来考虑＄g＄的倍数是很有用的。<sup class="footnote-ref">[【13】](#fn13)</sup>$𝔽_q$的算术是另一个数学双关语:在𝔽_q$，要计算元素$a，b \上的$a+b$或$ a \乘以 b$,首先我们把它们当作普通数字来运算，然后我们取欧几里得余数<sup class="footnote-ref">[【14】](#fn14)</sup>由此除以$q$。例如，假设$q$是(非常不安全的)数字 7。在$𝔽_7$，$ 6+6 = 12 = 1 \乘以 7+5$,所以我们说$6+6\equiv 5\mod 7$,就好像我们从一个有 7 个刻度的时钟的 6 点开始，向前移动 6 个刻度，然后看我们停在哪个刻度上。同样，$ 6 \乘以 6 = 36 = 5 \乘以 7+1$，所以我们说$ 6 \乘以 6\equiv 1\mod 7$。只要$q$是素数，$ a \在𝔽_q$的每个非零元素都有一个乘法逆$a^{-1}\in 𝔽_q$使得$ a \乘以 a^{-1}\equiv 1 \ mod q . $<sup class="footnote-ref">[【15】](#fn15)</sup>在$𝔽_7$，$6^{-1}$本身就是 6。因为每个非零元素都有一个逆元素，所以我们可以将$b\neq 0$的商$a/b$计算为$ a \乘以 b^{-1}$.

椭圆曲线上算术的一个密码学上的重要方面是有一个简明的表示法<sup class="footnote-ref">[【16】](#fn16)</sup>将$G$加到自身$m$倍所得的值，$mG=G+\ldots+G$， *$m$被认为无法从该表示法*<sup class="footnote-ref">[【17】](#fn17)</sup>中恢复。这是一个被广泛接受的椭圆曲线加密的基本假设，即如果我只给你$mG$这个值，你不太可能知道$m$是什么，除非或多或少地通过随机猜测。由于曲线上的点至少比宇宙中估计的原子数多 10 万倍，随机猜测被认为不太可能成功。<sup class="footnote-ref">[【18】](#fn18)</sup>从$mG$中猜出$m$的难度称为 [*离散对数硬度假设*](https://en.wikipedia.org/wiki/Discrete_logarithm) 。

离散对数难题的一个有趣的结果是，你可以用它来编码秘密算法。你要做的是在曲线$H$上选取另一个随机点，这样就没有人能算出它在$G$上的离散对数，<sup class="footnote-ref">[【22】](#fn22)</sup>然后你可以将一个值$\alpha$编码为$C=\alpha G+\beta H$，对于某个随机的$\beta$。点$C$是所谓的对值$\alpha$的 *Pedersen 承诺*，因为如果你已经发布了$C$，离散对数问题的难度使得很难回过头来算出其他值$\tilde{\alpha}，\tilde{\beta}$其中$ C = \ tilde { \ alpha } G+\ tilde { \ beta } H $。事实上，知道这样的$\tilde{\alpha}，\tilde{\beta}$将直接意味着您可以计算出$m$其中$mG=H$，解决离散对数问题:只需设置$ m = \ frac { \ alpha-\ tilde { \ alpha } } { \ beta-\ tilde { \ beta } } $。

$C$被称为*承诺*,因为我可以把它作为我们即将达成的某种协议的一部分给你，我稍后会透露$\alpha$和$\beta$，我们会根据$\alpha$或$\alpha G$采取一些行动。您通过检查$C=\alpha G+\beta H$来验证我在这一点上显示的任何$\alpha$，并且您确信这是我用$C$承诺的$\alpha$，因为我很难找到$ C = \ tilde { \ alpha } $和$\tilde{\beta}$的替代项。同时，我可以确信，在我揭示之前，你无法确定$\alpha$或$\alpha G$。

你可以用彼得森承诺做秘密的算术，只要把这些点加起来:如果$c^\prime=\alpha^\prime g+\beta^\prime h $，那么$c+c^\prime=(\alpha+\alpha^\prime)g+(\beta+\beta^\prime)h$就是彼得森对$\alpha+\alpha^\prime$的承诺<sup class="footnote-ref">[【23】](#fn23)</sup>。

## Shamir 秘密共享

现在，我将带您了解我们需要的门限签名的构造。这主要是遵循 Stinson 和施特罗布尔的论文，[可证明安全的分布式 Schnorr 签名和隐式证书的$(t，n)$门限方案](https://dl.acm.org/citation.cfm?id=678297)。

对于基础构造，Shamir 秘密共享，我们不需要椭圆曲线，我们只需要在$𝔽_q$.上操作

Shamir 秘密共享的初始阶段不是协作的，尽管我们将在后面看到门限签名在协作协议中使用它。有一个可信的经销商，他创建(并且知道)一个秘密，并且向$n$个其他实体提供关于它的足够信息，使得他们中的任何$t$个实体都可以重构它。

Shamir 秘密共享的关键思想是系数在$𝔽_q$的＄( t-1)＄-次多项式的空间形成一个＄t ＄-维向量空间。因此，经销商将其秘密表示为多项式$f(x)=a_0+a_1x+\ldots+a_{t-1}x^{t-1}$的常数项，系数＄\ { a _ I \ }\子集𝔽_q$中的每一个都是从$𝔽_q$.中统一且独立地选择的我们实际上要共享$f$的所有系数，但是只有$a_0$被用作共享秘密。<sup class="footnote-ref">[【24】](#fn24)</sup>

然后，庄家将指数$1，\ldots，n$以某种任意但固定的顺序分配给接收者。最后，它向第 I $个参与者发送值$(i，f(i))$。因为$f$是$t$维向量空间中的一个点，所以这些求值中的$t$足以重建$f$了。另一方面(如果你不了解向量空间，就忽略这句话)，$t-1$或更少的点只能将$f$约束到$𝔽_q$上多项式的非平凡向量子空间，因此它们不能揭示任何特定系数的信息(除非该系数为 0，这是极不可能的。)这有点像如果你在三维空间中取两个平面的交点，你会得到一整条线，但是如果你取三个平面的交点，你会得到一个点。

假设参与者$i_1，\ldots i_t$彼此分享他们的值$(i_j，f(i_j))$彼此分享。然后他们可以构造多项式<sup class="footnote-ref">[【25】](#fn25)</sup>

\[\begin{equation}g(x)=\sum_{j=1}^tf(i_j)\prod_{k\in\{1,\ldots,t\}\setminus\{j\}}\frac{x-i_k}{i_j-i_k}\label{lagrange}\end{equation}\]

这里,$\sum$符号表示“将这些值相加，从$j=1$直到$j=t$为止”，而$\prod$符号表示“将这些值相乘，从$k=1$直到$k=t$为止，但不包括$k=j$在内。”如果我想用 python 生成器的理解来表达这一点，我可能会这样做

```
sum(f(i[j])*np.prod([(x-i[k])/(i[j]-i[k]) 
                     for k in range(1, t+1) if k != j])
    for j in range(1, t+1)) 
```

其中`np.prod`是`numpy` [`prod`函数](https://docs.scipy.org/doc/numpy-1.14.5/reference/generated/numpy.prod.html)，它计算其第一个参数<sup class="footnote-ref">[【26】](#fn26)</sup>中元素的乘积。

在任何$i_j$给定的情况下计算$g$,分离出$j$ term，

$ \ begin { align * }
g(I _ j)&f(I _ j)\ prod _ { k \ neq I _ j } \ frac { I _ j-k } { I _ k }+\ sum _ { k \ neq I _ j } f(k)\ prod _ { l \ neq k } \ frac { I _ j-l } { k } \ \ t1]t5 = f(I _ l)

其中，对于第一个等式，我从总和中取出了第$ j $ term，对于第二个等式，我使用了$ \ frac { I _ j-k } { I _ j-k } = 1 $ for $ k \ neq j $这一事实，并从每个剩余的乘积中取出了第$j$th 因子。

由于$f$和$g$在$t$点上一致，所以它们是同一个多项式。这个技巧，从$d+1$点的值构造一个$d$次多项式，被称为*拉格朗日插值*。

至少需要$t$参与者才能收回$f$的资金。用更少的，你只能推断$f$位于$(t-1)$-次多项式的向量空间的某个非平凡仿射子空间(其基数至少为$q$，因为它在$𝔽_q$上至少是一维的)。

## 可验证秘密共享

密码学不仅仅是数学。同样重要的是，从对立的角度思考像 Shamir 秘密共享这样的协议的参与者可能会为了个人利益而行为不端。这导致了一轮又一轮的挑战和回应，以确定谁应该对合作出错负责。此外，每条消息都需要由发件人签名，以便在需要时可以作为他们行为不端的证据。<sup class="footnote-ref">[【27】](#fn27)</sup>

在上面的方案中，信任经销商向每个参与者提供一致的值$f(i)$。如果经销商没有使用一致的$(t-1)$-次多项式来构造值$f(i)$，则参与者的不同$ t $-大小的子集可以为秘密构造不同的值。

*可验证的*秘密共享使用彼得森承诺来限制分发者可以向参与者发送什么。庄家像以前一样构造$f(x)=a_0+a_1x+\ldots+a_{t-1}x^{t-1}$，但也构造第二个随机多项式$h(x)=b_0+b_1x+\ldots+b_{t-1}x^{t-1}$，并用它来形成系数为$f$的公共彼得森承诺，曲线指向$C_c=a_cG+b_cH$。

从庄家到参与者的消息现在是$(i，f(i)，h(i))$。这允许每个接收者验证这些值来自＄\ { c _ c \ }＄提交的多项式，因为必须是这样的情况，$\sum_{c=0}^{t-1}c_ci^c=\left(\sum_{c=0}^{t-1}a_ci^c\right)g+\left(\sum_{c=0}^{t-1}b_ci^c\right)h=f(i)g+h(i)h$是他们可以计算的曲线点，知道＄f(I)＄和＄h(I)＄。

如果一个接收者，比如说第 i$th，不能验证来自经销商的信息，它就广播一个投诉，公布经销商提供的值，并由经销商签名。然后，所有其他参与者可以使用投诉来验证经销商发送了$\sum_{c=0}^{t-1}c_ci^c\neq f(I)g+h(I)h＄的值。如果发生这种情况，整个交易取消！类似地，如果任何参与者广播无效投诉(带有错误的经销商签名或有效的经销商值)，他们将被标记为不可信。<sup class="footnote-ref">[【28】](#fn28)</sup>

一旦每个人都满足于从庄家那里得到正确的值，他们中的任何$t$都可以使用与等式$(\ref{lagrange})$中相同的拉格朗日插值技巧来构造庄家的秘密多项式。

## 彼得森/拉宾分布式密钥生成

分布式密钥生成的目标是在𝔽_q$中创建一个私有值$m，没有人知道这个值，但是任何$t$参与者都可以使用它来进行公钥加密，其中$m$作为私有密钥，$mG$作为公共密钥。

下面的方案要求$t\leq n/2$即一半以上的参与者是诚实的。这有点不可思议，因为它用一个没人知道的多项式*模拟了*可验证的秘密共享。

第一步是$n$个同时可验证的秘密多项式秘密共享，$h_i(x)=b_{i,0}+b_{i,1}x+\ldots+b_{i,t-1}x^{t-1}$ $f_i(x)=a_{i,0}+a_{i,1}x+\ldots+a_{i,t-1}x^{t-1}$，第$ i $个参与者作为$(f_i，h_i)$的分发者给所有其他参与者。他们都必须对参与者的排序达成一致，并使用该排序来共享交易，以便第 I $个参与者从任何其他第$ j $个参与者处获得$f_j(i)$而不是其他某个$f_j(k)$个参与者。粗略地说，他们共享的未知多项式是$f_i$的和。

如果对参与者的交易有任何有效的投诉，或者如果参与者对某人提出无效的投诉，他们将被从协作中移除。在此结束时，参与者$i$从参与者$j$得到$(f_j(i)，h_j(i))$用于所有$j\neq i$。用$Q$(代表“合格”)表示通过共享程序而没有受到合法投诉的参与者集合。<sup class="footnote-ref">[【29】](#fn29)</sup>

一旦所有这些份额完成，任何$t$参与者*都可以*重建任何其他参与者的秘密，但是**一个$(t，n)$-门限方案的隐含假设是，最多$t-1$参与者是不诚实的**，所以任何不诚实的联盟都太小而不能这样做。

此时，参与者有足够的信息*模拟*共享所有合格参与者的秘密多项式之和，＄f(x)= \sum_{i\in Q } f _ I(x)= ＄＄\ sum _ c(q}a_{i,c})x^c$的\ sum _ { I \ in q，＄h(x)= \ sum _ { I \ in q } h _ I(x)= \ sum _ c(\ sum _ { I \ in q}b_{i,c})x^c$，尽管他们实际上都不知道＄f＄。由于 Q$中的参与者$ i \具有来自 Q$中的每个参与者$ j \的$(f_j(i)，h_j(i))$，他们可以计算$f(i)=\sum_{j\in Q}f_j(i)$和$ h(I)= \ sum _ { j \ in Q } h(I)$<sup class="footnote-ref">[【30】](#fn30)</sup>，并验证相关联的彼得森承诺，因此就好像某个名义经销商正在与他们共享该秘密。我们将使用这些值来处理分布式秘密$m=\sum_ia_{i，0}$。

现在，每个参与者$i$通过发布$A_{i，k}=a_{i，k}G$(回想一下$(a_{i，k})_k$是$i$的秘密多项式的系数，$f_i，$A_{i，k}$在某种意义上已经作为$C_{i，k}=a_{i，k}G+b_{i，k}H$的第一项被共享。)然后，每个其他参与者可以验证$f_i(j)g=\sum_{k=0}^{t-1}j^ka_{i,k}$.

如果$j$报告来自$i$的$A_{i，k}$s 的一个无效的、有符号的集合，则其他参与者(其中必须至少有$t-1$才能使协议工作)求助于使用拉格朗日插值技巧来恢复$i$的秘密多项式。因为他们能够做到这一点，恶意联盟不能选择中止协议或通过选择发布或保留对其联盟之一的有效投诉来以任何方式控制输出。这就是我们最初必须使用 Pedersen 承诺$C_{i，k}$而不是直接的“公钥”值$A_{i，k}$来验证份额的原因:假设不可能从$C_{i，k}$推断出$A_{i，k}$并且我们想要确保每个人都致力于参与秘密的最终构造，或者通过适当地共享，或者通过由其他诚实方根据他们在可验证的秘密共享阶段期间验证的揭示来强制重构他们的秘密。

上述恢复步骤需要 n/2 美元。只要是这种情况，总是有足够的来自诚实参与者的份额来重构来自扣留正确的$A_{i，k}$s 的不诚实参与者的份额。

最后，现在大家都知道 Q$中任意$ i \的常系数的“公钥”，即$A_{i，0}=a_{i，0}G$了。关联的“私钥”就是那个系数，$a_{i，0}$。然后，分发的秘密就是每个人的常数系数之和，$z=\sum_{i\in Q}a_{i，0}$，相关的公钥(我们将在门限签名方案中使用)是每个人的公钥之和，$\sum_{i\in Q}A_{i，0}=\sum_{i\in Q}a_{i，0}G=(\sum_{i\in Q}a_{i，0})G=zG$。

值得注意的是，如果协议因为$i$的公布的$A_{i，k}$值无效而被迫重构$i$的秘密，那么从该点开始，只有$t-1$其他参与者需要与分发的秘密$z$一起工作。但是要记住的重要一点是，这个门限方案隐含的假设是，最多$t-1$个参与者是不诚实的。如果$i$的公共$A_{i，k}$值是错误的，则证明$i$是不诚实的，因此基于该假设，最多可以有$t-2$个其他不诚实方。

## 阈值签名

我们可以进行门限签名，因为我们有办法从参与者级别的密钥部分＄\ {(z _ I，z _ iG)\ } _ { I \ in Q }＄中构造＄( t，n)＄分布的秘密＄z＄和相关的公钥＄zG＄。首先，参与者构造这样一个公钥/私钥对，他们将用它来签署消息$(z，zG)$。然后，对于他们想要签名的每条消息$M$来说，他们将再次运行分布式密钥生成过程，以在 Q^\prime}k_i$构建 nonce $ k = \ sum _ { i \(其中$k_i$是$i$的新秘密的一部分),并在 Q^\prime}K_i$构建相关联的公钥$ k = \ sum _ { I },其中$K_i=k_iG$。每个参与者$i$使用 [Schnorr 签名方案](https://en.wikipedia.org/wiki/Schnorr_signature#Signing)用他们的$z$部分对消息签名:

$$e=H(K‖M)，s_i=k_i-z_ie，$$

其中$H$是一个合适的散列函数，算法在$𝔽_q$.最后，他们把他们的签名加起来，在 q^\prime}s_i=\sum_{i\in q^\prime}k_i-z_ie=k-ze$.得到＄s = \ sum _ { I }对$(s，e)$是使用公钥/私钥对$(z，zG)$和随机数$k$在 M 上的签名。任何人都可以通过检查$H(sG+e(zG)‖M)=e$来验证签名是否与公钥$zG$匹配，这对于正确的签名是成立的，因为$sG+e(zG)=(s+ez)G=kG=K$。

Schnorr-signature 公式$s=k-ze$的线性度在这里起着关键作用。以太坊的签名方案来自比特币，比特币使用 [ECDSA 签名](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)，而不是 Schnorr，虽然在 ECDSA 中签名涉及到一个有点类似的公式，$ s =(h(m)+k _ xz)/k $<sup class="footnote-ref">[【31】](#fn31)</sup>在$𝔽_q$，$k$中的非线性意味着不能像我们在 Schnorr 中那样只是将参与者的个人签名相加。

## Schnorr 签名的廉价链上验证

在链上验证 Schnorr 签名并不*昂贵。有一个[公共实现](https://github.com/HarryR/solcrypto/blob/master/contracts/Schnorr.sol)，通过使用以太坊[预编译的配对曲线 AltBN-128](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md) 契约，需要大约 85k gas。尽管如此，在 Chainlink 和 Ethereum 变得非常流行的乐观情况下，我们将希望尽可能地降低成本，以便允许更多的数据在链上报告。*

通过对 Schnorr 签名公式进行小的[调整，我们能够将在线验证的成本降低到](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-10a5b62d9dbf96402840ec82e11c3416R45)[仅仅 15k gas](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-014cdfd88099806d82f1b40815091865R89)<sup class="footnote-ref">[【32】](#fn32)</sup>，使用 Vitalik Buterin 的 [ecrecover trick](https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384) 来滥用以太坊的认证基础设施来验证椭圆曲线算法。以太坊有一个预编译的契约，可通过 solidity 经由`ecrecover`函数访问，对于 3,000 gas，它将返回签名消息的公钥的以太坊地址<sup class="footnote-ref">[【33】](#fn33)</sup>。当你计算`ecrecover(z, v, r, s)`时，你实际上是在<sup class="footnote-ref">[【34】](#fn34)</sup>中为$P$求解

$$(s^{-1}zG+s^{-1}rP)=R,$$

其中$R$是由$x$纵坐标$r$和来自$v$的$y$纵坐标的奇偶性指定的点，并且所有标量算术都以$𝔽_q$.为单位因此

$$P=(r^{-1}s)R+(-r^{-1}z)G.$$

另一方面，为了验证 Schnorr 签名，我们计算＄K = sG+eP ＄,其中＄P＄是公钥，然后检查＄e = H(K‖M)＄。如果我们改为在签名和验证过程中使用$ e = H(\ mathrm { address }(K)÷M)$的话，我们可以直接使用`ecrecover`来检查$\mathrm{address}(K)$是否为`ecrecover(` $-P_xs$，$P_v$，$P_x$，$ P _ xe $`)`$ = \ mathrm { address }(sG+eP)$其中$P_x$是公钥的$x$纵坐标，$P_v$是 2 正如[在这里](http://www.neven.org/papers/schnorr.pdf)所说的，我们甚至可以将＄e＄截断为 128 位，以保持 secp 256 k1<sup class="footnote-ref">[【35】](#fn35)</sup>提供的 128 位安全性。由于验证的是曲线点的散列而不是曲线点本身，所以有必要对那篇论文中的证明进行一些调整，我可能会在未来的博客文章中讨论这些调整。

## 履行

优秀的密码学库 [kyber](https://github.com/dedis/kyber/) (这是学术 [**EPFL 德迪斯集团**](https://dedis.epfl.ch/) 的一个项目，据我所知**与 kyber 网络<sup class="footnote-ref">[【36】](#fn36)</sup>没有**联系)已经实现了我上面描述的门限签名方案。我们已经编写了[一个与 kyber `Group`抽象兼容的](https://github.com/dedis/kyber/pull/385/files) [btcd 的 secp256k1 算法](https://github.com/btcsuite/btcd/tree/3dcf298fed2d5fd65918dc560b3942b2aa0629e8/btcec)的包装器，一个对 kyber 的门限签名构造的[修改，以及](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-abacaa303fde0503396c86b9aac969a1R1)[一个在上述签名方案中实现验证](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-10a5b62d9dbf96402840ec82e11c3416R1)的智能契约，以及[一个对两个系统的端到端测试](https://github.com/smartcontractkit/chainlink/pull/1272/files#diff-014cdfd88099806d82f1b40815091865R93)。一旦我们审计了这个实现，我们计划在 oracles 之间建立一个对等网络，通过这个网络，oracles 可以协商和构造证明真实世界数据的阈值签名。

我们预计这将是智能合约与现实世界连接的完整性的一个重大进步，因为它能够对参与的甲骨文之间本质上任意的链外交互进行廉价的链上验证。如果你对这类事情感兴趣，[我们正在招聘](/cdn-cgi/l/email-protection#d3b0b2a1b6b6a1a093b0bbb2babdfdbfbabdb8)。

## 承认

感谢 Chris Blake、Steve Ellis、Ari Juels、Dimitri Roche 和 Holly White 对本文的反馈和建议，并感谢 Sergey Nazarov 首先建议我写这篇文章。

* * *



1.  是的，我们所能做的就是提供财务奖励，从组织的角度来看，这是一个非常限制性的激励结构。然而，许多简单的合作可以从容易实施的财务奖励中受益。另一方面，如果您知道一个区块链，它能够在深厚的个人关系、有意义的成就和温暖、模糊的感觉方面实现奖励，请让我们知道，以便我们可以将 Chainlink 与它集成。😊 [↩︎](#fnref1)
2.  虽然法规和其他法律保护对于降低我们合作所需的信任度至关重要，但对于许多潜在的合作来说，它们太昂贵、太慢、太不确定，无法降低被利用的风险。 [↩︎](#fnref2)
3.  那份特殊的合同[包含了一个错误](https://www.reddit.com/r/ethereum/comments/7vi6h6/i_created_a_smart_contract_for_fermats_last/dtsppev/)并且涉及到一个[认为已经解决的问题](https://en.wikipedia.org/wiki/Wiles%27s_proof_of_Fermat%27s_Last_Theorem)，但是总体来说这是一个好主意！ [↩︎](#fnref3)
4.  Etherscan 的历史日平均 [ETH/USD 价格](https://etherscan.io/chart/etherprice?output=csv)和[天然气价格](https://etherscan.io/chart/gasprice?output=csv)。通过取每天两个值的乘积进行估算。交易的 43k gas 假设基于每个参与者的单独交易(21k 基本 gas 成本)、一个`uint256`输入(2k gas)和他们输入的存储(20k gas)。)对此可能有一些优化，但我还没有仔细考虑，因为这不是这篇文章的主要内容:通过将多个确认聚合到一个交易中，你可能会将每个参与者的成本降低到大约 9k gas(每个报告有`uint256`，每个签名有两个`uint256`，每个签名需要 3k 来验证签名)，但这仍然很昂贵！ [↩︎](#fnref4)
5.  这在统计上是不合理的，但会低估最高隐含美元天然气价格。 [↩︎](#fnref5)
6.  也有可能进行门限 ECDSA 签名，T2 Keep 网络正在为以太坊实现这一功能。门限 ECDSA 签名非常有趣，因为您可以使用它们来直接签署以太坊交易，以太坊的机器会像在任何其他交易中一样为您验证签名。因此，当协议中的每个人都按预期行为时，这是一个很大的气体节省。解决 ECDSA 签名公式中的非线性问题涉及大量具有非常大的数字(安全 RSA 模数的平方)的复杂同态加密，这将使得在秘密共享过程中对不正确行为的链上责任更加昂贵，并且更难以在以太坊契约中表达。在 Chainlink，我们已经决定使用 Schnorr 签名，因为它们简单，而且因为它们的线性结构允许我们在后续的开发计划中有更大的灵活性，这一点我可能会在以后的博客文章中谈到。 [↩︎](#fnref6)
7.  它还基于常规的以太坊 secp256k1 椭圆曲线算法，这使我们大大降低了被危及该方案的密码突破所震惊的风险。基于配对的 BLS 签名很有吸引力，但是以太坊的配对操作的加密安全性可能低于 [110 位](https://eprint.iacr.org/2016/1102.pdf#page=20)(“因此，对具有 256 位素数 p 的 BN 曲线的安全级别的保守估计是 110 位。”) [↩︎](#fnref7)
8.  一个极端的例子: *[格罗滕迪克的思维模式](http://www.ams.org/notices/200410/fea-grothendieck-part2.pdf)的一个显著特点是，它似乎很少依赖例子。这在所谓的“格罗滕迪克质数”的传说中可见一斑。在一次数学对话中，有人向格罗滕迪克建议，他们应该考虑一个特定的质数。“你是说一个实际的数字？”格罗滕迪克问道。另一个人回答，是的，一个实际的质数。格罗滕迪克建议，“好吧，拿 57。”* *但是格罗滕迪克一定知道 57 不是质数吧？布朗大学的大卫·芒福德说，绝对不是。“他不具体思考。”* [↩︎](#fnref8)
9.  它确实与曲线上有理函数领域的乘法有一些相似之处，但是，如果你从正确的角度来看。 [↩︎](#fnref9)
10.  这个点$G$被称为*发生器*。不是每条曲线都有生成器，但以太坊用的那个有。在没有生成器的曲线上，通常仍然可以通过将运算限制到集合$\{G，G+G=2G，G+2G=3G，G+3G=4G，…\}$来进行加密，尽管这是曲线的一个严格子集。 [↩︎](#fnref10)
11.  secp256k1 的$q$，[的实际值，比如说](https://en.bitcoin.it/wiki/Secp256k1)，是$2^{256}-432420386565659656852420866394968145599$.各种密码椭圆曲线组的大小如第二个表[所示。在 secp256k1 的情况下，$q$比$2^{256}$小一点是有用的，因为在网络传输过程中，这几乎不会浪费 32 字节表示中的任何空间。它还可以很容易地从$\{0，\ldots q-1\}$中均匀地采样一个随机数，只需采样 32 个随机字节，如果它表示一个大于$q$的数(如果您正确地抽取均匀随机样本，大约每$2^{128}$样本就会发生一次),则丢弃结果以再次尝试。)](https://safecurves.cr.yp.to/base.html) [↩︎](#fnref11)
12.  使用[双加算法](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Double-and-add)计算$mG$实际上是可行的，即使$m$大得不可思议。粗略地说，你计算$2g=g+g,4g=2g+2g,8g=4g+4g,\ldots,2^{255}g=(2^{254}g)+(2^{254}g)$.然后，您使用$m=\sum_{p=0}^{255}b_p2^p$的二进制表示法，用\{0，1 \ }＄中的＄b _ p \来计算$mg=\left(\sum_{p=0}^{255}b_p2^p\right)g=\sum_{p=0}^{255}b_p(2^pg)$.要[正确地编码这个](https://eprint.iacr.org/2011/338.pdf)有点棘手，因为如果你以最有效的方式来做，运行算法所花费的时间可能会泄露关于$m$的信息，而$m$应该是保密的。无论$b_p$是 0 还是 1，确保每一步都发生完全相同的计算操作(当然，尽管有适当的输入)是很重要的。 [↩︎](#fnref12)
13.  如果你碰巧读过安德里亚·科贝里尼关于椭圆曲线的精彩介绍，值得注意的是，$𝔽_q$与他在那里使用的$𝔽_p$是不同的结构。$𝔽_p$是定义椭圆曲线的坐标系的*基域*，<sup class="footnote-ref">[【21】](#fn21)</sup>，而$𝔽_q$表示曲线上的加法结构，$𝔽_q$的加法对应于点加法，𝔽_q$的点$P$乘以$ m \对应于将点加到自身$m$倍，而𝔽_q$的$ 1 \表示生成器$G$。$𝔽_q$和$𝔽_p$都使用“时钟算法”，但他们时钟上的滴答声数量不同。($𝔽_p$有$2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1。$) [↩︎](#fnref13)
14.  也就是说，我们使用[欧几里德除法](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf#page=3)找到$(d，r)$使得$ a+b = q \乘以 d + r$，其中$0\le r < q$。这对于计算$𝔽_q$中的否定$-a$非常重要，因为它返回给我们一个元素$\{0，\ldots，q-1\}$，即$q-a$。 [↩︎](#fnref14)
15.  这可以通过在$q$和$a$上运行[扩展欧几里德算法](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)来计算，步骤大约为$\log_2 q$步。倒数将是$a$的最终贝佐特系数，因为$\gcd(q，a)=1$，因为$q$是质数，$a < q$。 [↩︎](#fnref15)
16.  具体来说，椭圆曲线上的每一点都是$(x,y)\in(𝔽_p)^2$形式，$y^2\equiv x^3+1\mod 为 p$。你可以很容易地用 257 位来表示这样一个点:x$纵坐标和 y$纵坐标的奇偶性，它可以计算到$\sqrt{x^3+7}\mod p$的符号变化。 [↩︎](#fnref16)
17.  例如，secp256k1 生成器$G$的$(x，y)$坐标是`(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798, 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)`，而$2^{128}\times G$的坐标是`(0x8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da, 0x662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82)`。两组坐标都适合 64 个字节，尽管对于地球上每个人的每个原子来说，第二组坐标相当于第一组坐标的十倍，并且在这些坐标中没有任何明显的(或者，我们希望是模糊的)东西会让你推断出$2^{128}$是乘数。 [↩︎](#fnref17)
18.  不过，使用[小步、大步算法](https://en.wikipedia.org/wiki/Baby-step_giant-step)<sup class="footnote-ref">[【19】](#fn19)</sup>，你可以做得比单纯的随机猜测好得多，这将你必须做出的猜测次数减少到大约曲线点数的平方根，代价是大约相同的存储量。据任何人所知，这仍然是完全不可行的，尽管$2^{128}$的原子数量比太阳的原子数量少大约三万亿分之一，所以如果你把太阳变成一台大型专用计算机，也许你可以破解当代的椭圆曲线密码系统。<sup class="footnote-ref">[【20】](#fn20)</sup>我认为比较猜测值和存储值是困难的。
    量子计算也有可能让我们用非常有限的计算资源解决离散对数问题。我认为在可预见的未来，这实际上比太阳计算机更不可能，但我不是物理学家。 [↩︎](#fnref18)
19.  注意，他们在那一页上使用了乘法符号，对于我们在这里表示为加法的运算。 [↩︎](#fnref19)
20.  在我看来，这是对关键资源的轻率使用，尽管似乎有一些相当严肃的人对这个想法感到兴奋。用木星制造一台计算机可能会引发较小的环境抗议，但那样的话，你的每猜测/单位存储空间就会减少大约 1000 个原子。 [↩︎](#fnref20)
21.  即，例如，secp256k1 的仿射表示是$\{(x，y)\ in(𝔽_p)^2 | y^2=x^3+7\}$[↩︎](#fnref21)
22.  也就是说，从一般理论中我们都知道有*一些* $m$使得$H=mG$，但是没有人能明确指出$m$是什么 [↩︎](#fnref22)
23.  有关秘密彼得森算法的详细介绍，请参见 Grin 加密货币的[初级读本，该加密货币使用它们来隐藏其交易账本](https://github.com/mimblewimble/grin/blob/master/doc/intro.md)中的所有余额。不过，我们并不需要所有的机器。 [↩︎](#fnref23)
24.  如果你试图使用更多的系数来获得更多的共享熵，你会遇到较小的联盟能够推断它们之间的线性关系的问题。此外，重要的是，所有系数都是以加密方式安全随机选择的，包括$a_0$。如果您想要共享实际信息，您使用$a_0$对其进行加密，并单独发送加密。 [↩︎](#fnref24)
25.  下面等式最右边的数字只是一个参考标签，所以我可以在后面的文章中很容易地调用它。 [↩︎](#fnref25)
26.  我遇到过不少人，他们完全能够理解这个协议，但是不知道我在这里使用的数学符号。这个解释是给他们的。 [↩︎](#fnref26)
27.  像以太坊使用的常规签名就足够了；我们不是在这里构建门限签名的循环结构！ [↩︎](#fnref27)
28.  这与斯丁森&施特罗布尔论文中描述的 VSS 协议略有不同，后者不依赖于参与者的个人签名。在那里，当参与者$i$广播投诉时，经销商有机会清楚地广播正确的$(f(i)，h(i))$值。与此同时，如果有超过$t$的投诉，就意味着交易取消。这是由于$(t，n)$阈值方案中的隐含假设，即最多$t-1$个参与者是不诚实的，这意味着，如果有$t$个投诉者，则至少有一个诚实的投诉，并且经销商首先发送了错误的值，即使他们随后发布了正确的值来响应该投诉。要求投诉包含经销商的签名避免了所有这些令人毛骨悚然的逻辑，因为如果它是由经销商签名的，你就有压倒性的高概率知道它来自他们。 [↩︎](#fnref28)
29.  佩德森[最初提出了一个没有佩德森承诺](https://link.springer.com/content/pdf/10.1007/3-540-46416-6_47.pdf)的秘密共享方案，但是[包括拉宾](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.2737)在内的一个小组指出，这个方案允许一个小的攻击联盟影响最终公钥的分发，通过选择哪个成员将由于其他成员的有效投诉而被移除。为了解决这个问题，拉宾*等人*提出了多项式系数的初始彼得森承诺。 [↩︎](#fnref29)
30.  请注意，这些是$𝔽_q$中的和，所以您通过常规算术来计算它们，然后取欧几里得余数$\mod q$。 [↩︎](#fnref30)
31.  这里$K_x$代表仿射坐标中$K=zG$的 x 坐标，而$H$是一些标准散列函数，具有通常假定的属性，如抗原像和抗碰撞。 [↩︎](#fnref31)
32.  该测试中的值是 37，000，因为基本交易成本是 21，000 汽油。在我手里，实际价值出来是 15300 左右的气。同样值得注意的是，如果公钥已经在链上，您可以节省大约 2,000 gas，这将使成本下降到大约 13000，或者更少，如果您有可以用`nonceAddress`打包的数据。 [↩︎](#fnref32)
33.  给定一个公钥$P=(x，y)\in\mathrm{secp256k1}$，其以太坊地址是$\mathrm{keccack256}(x‖y)$的低 160 位，其中$x$和$y$表示为大端二进制字符串。 [↩︎](#fnref33)
34.  这是在标准 [ECDSA 验证](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm)中检查的等式(参见该链接的步骤 5)。) [↩︎](#fnref34)
35.  感谢 Ari Juels 指出这篇论文。 [↩︎](#fnref35)
36.  强调是因为*每个人*似乎一开始都会产生这种联想。我也是。 [↩︎](#fnref36)

*