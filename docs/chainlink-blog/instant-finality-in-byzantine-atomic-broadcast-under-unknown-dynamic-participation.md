# 未知/动态参与下拜占庭原子广播的即时终结

> 原文：<https://blog.chain.link/instant-finality-in-byzantine-atomic-broadcast-under-unknown-dynamic-participation/>

*作者:Dahlia Malkhi (Chainlink Labs)，Atsuki Momose (UIUC)，Ling Ren (UIUC)*

## 剧情简介

在之前的[](https://blog.chain.link/instant-finality-in-byzantine-generals-with-unknown-and-dynamic-participation/)帖子中，我们提出了一个简单的解决方案，用于一次性的 **，** **二进制的** 拜占庭协议，其未知/动态参与者可以在任何时候被替换，条件是三分之二的活动参与者是诚实的，这保证了确定性和无条件的终结性，并且具有(小的)恒定的预期延迟。

在这篇文章中，我们将这种方法扩展到一系列值的多值一致性，即解决**拜占庭原子广播(BAB)** 问题。我们的协议继承了前一篇文章，与现有解决方案相比具有以下优点:1) *【小三轮延迟】*【2)确定性和无条件的安全性，3)不需要最终的稳定参与，4) *允许故障节点的波动参与。T13T15】*

**概述模型。** 活跃参与者的集合——也称为节点——是未知的，它们的计数是未知的，并且在每一轮中，它们可能被完全替换，服从以下假设:

*   *PKI。* 参与节点取自一个有限的宇宙，每个节点可以通过一个公钥来标识，它拥有该公钥的私钥。
    *   注意，只有 VRF 和活性才需要 PKI 消息做 **不做** 需要由发件人签名
*   *活跃节点。* 每个回合 r 都有一个未知的活跃集合 *节点* ，其(未知)计数*n**<sub>r</sub>**n<sub>r</sub>*≥*3f<sub>r</sub>*
*   *同步通信。* 在 r 轮中，诚实的主动节点接收 r-1 轮中诚实节点广播的所有消息。

我们还注意到，来自故障节点的任何消息都不能被延迟到下一轮。

**原子广播。** 该协议允许节点对值的增长序列(由节点输入)达成一致，使得:

*   *安全。* 两个诚实的节点不在序列的同一位置上决定一个值。
*   *活跃度。* 诚实节点的输入值是最终决定的。

## 我们的协议

**连锁。** 我们使用常见的块链接技术。每个块包含一些值(例如，新事务)以及前一个块的散列。第一个块包括一个称为“起源”块的特殊预定义块的散列。如果以 B 结尾的序列是以 B 结尾的序列的前缀，我们说块 B' *扩展了块 B。如果两个块彼此不扩展，我们说它们是 *冲突的* 。*

**分级协议(GA)。** 我们上一篇帖子中的 BA 协议有两个非常相似的通信步骤。每一步都实现了一个叫做分级协议(GA)的抽象。我们首先给出这个 GA 构建块，然后用它来构建我们的原子广播协议。

在未知和动态参与的情况下，这一轮(GA)开始时的活动节点集合可能不同于 GA 结束时的活动节点集合(下一轮的活动节点)。GA 开始处的每个活动节点具有输入块 B。GA 结束处的每个(新的)活动节点确定块 B 和等级位 g 对的集合{ (B，g) }作为 GA 的输出。我们再次强调，我们使用了块链接，所以块 B 唯一地标识了从 genesis 开始到 B 结束的整个块序列

**我们的 GA 协议T3】**

GA开始时，每个活动节点 p 发送(vote，B)为其输入 B.

(从 GA 开始的活动节点集现在可以被替换，即，不同的节点集现在可以接收和计数投票。)

GA结束时，每一个活跃节点都有票数统计。如果 B '扩展了 B，那么对 B '的投票也算作对 B 的投票。来自同一投票者的对冲突块的投票被忽略。

*   输出(b，1)如果收到的票数超过⅔投票给 B.
*   输出(b，0)如果收到的票数超过⅓投票给 B.

**遗传算法的特性。** 通过前面帖子中的 UDQ 属性，我们有以下保证。

*   *等级一致。* 如果一个诚实节点输出(B，1)，那么所有诚实节点输出(B，*)。
*   *正直。* 如果一个诚实节点输出(B，*)，那么至少有一个诚实节点输入扩展 B 的 B’
*   *有效期。* 设 B 为诚实节点输入的最高共同祖先。然后，所有诚实节点输出(B，1)
*   *唯一性。* 如果一个诚实节点输出(B，1)而另一个诚实节点输出(B '，1)，那么 B and B '彼此不冲突。
*   *有界发散。* 每个节点最多输出(等级为 0)两个冲突块。

我们的原子广播协议。 我们现在给出我们的原子广播协议。变量 **C** ， **L** 初始化为 genesis。( **C** :候选， **L** :锁定)

每个视图有两轮。在第一个视图 v = 1 开始之前有一个额外的初始回合。

*初始回合 0:* 发送(求婚，B，VRF)其中 B 是扩展创世纪的块。

*第一轮*

如果 v > 1:

决定任何块 B，使得视图 v-1 的 GA2 输出(B，1)

设置 **L** 到最高的块，这样视图 v-1 的 GA2 输出( **L** ，*)

将来自前一轮的扩展 **L** 的“建议”消息中具有最高 VRF 的块输入到 GA1。

如果没有这样的块，输入 **L** 到 GA1。

*第二回合第五回合*

设置 B 为最高块，使 GA1 输出(B，1)。

将 **C** 设置为最高位块，使 GA1 输出( **C** ，*)。(如果有两个这样的 **C** ，随便挑一个。)

输入 B 到 GA2。

发送(提出，B '，VRF)其中 B '延伸 **C** 。

## 校样草图

**安全。** 假设一个诚实的主动节点在视图 v 的第一轮中决定一个块 B，即它从视图 v-1 中开始的 GA2 输出(B，1)。由于分级一致性，在视图 v 的第一轮中活动的任何诚实节点 p 必须输出(B，*)。还观察到视图 v-1 GA2 不可能输出任何冲突块。这是因为没有诚实节点可以向视图 v-1 的 GA2 输入任何冲突块(由于 GA1 的唯一性)，并且 GA2 在没有一些诚实节点的输入的情况下不能输出任何冲突块(由于完整性)。因此，p 必须将 L 设置为视图 v 的第 1 轮中扩展 B 的块。视图 v 中的 GAs 和 v 之后的所有视图中的 inductively 都只输出扩展 B 的块(由于有效性)。因此没有诚实的节点决定任何冲突的块。

**热闹。** 让我们称视图 v-1 中发送最高 VRF 的节点为视图 v 的领导者，很明显，如果所有诚实的活跃节点向视图 v 的 GA1 输入一个诚实领导者的建议，则必须决定建议的块。诚实的节点 p 不向 GA1 输入领导者的提议的唯一原因是它与它的锁 L 冲突。节点 p 必须具有来自 GA2 的输出(L，* ), GA2 在先前的视图 v-1 中开始。然后，在视图 v-1 的 GA1 中输出(L，1)之后，某个诚实节点 q 必须具有到 GA2 的输入 L(或扩展 L 的块)。因此，视图 v 的领导者在视图 v-1 的 GA1 中输出(L，0)(由于分级一致性)。由于有界发散，领导者从视图 v-1 的 GA1 输出至多一个其他冲突块。因此，至少以概率，领导者提出扩展 L 的块，并且所有诚实节点接受领导者的提议。

## 讨论

在本文开头列出的四个基本优势中， 我们强调了现有解决方案的两个重要实际优势。

**3 轮潜伏期。** 我们的协议的一个重要的实际优势是实际延迟:只有 3 轮。相比之下，之前最先进的 [【桃濑-任 2022】](https://eprint.iacr.org/2022/404)花费 16 发。这种改善归因于两个因素。首先，我们通过牺牲从到⅓.的容错性，将遗传算法的延迟从 3 轮提高到 1 轮其次，也是更重要的，我们通过将 GA 调用的数量从 5 个减少到 2 个，改进了原子广播协议。

**故障节点的波动。** 如前所述，我们的协议不仅允许诚实节点，也允许错误节点在执行过程中加入/离开。这是一个重要的实际优势，因为所有没有工作证明(或可验证延迟功能)的现有解决方案都假设故障节点一直在线(如 [【德布-坎南-谢，2021】](https://arxiv.org/pdf/2010.08154.pdf)所示)。这种对对手的限制很难自圆其说。假设开始时只有 10 个节点处于活动状态，但 10 年后，一百万个节点处于活动状态。那么，现有的解决方案将不得不假设对手最多控制一百万个活动节点中的 10 个。我们的协议仍然容许⅓百万个故障活动节点。

在我们最近发布的白皮书中阅读关于这项工作的更多信息。

*关于区块链、智能合约和神谕的最新研究，[订阅 Chainlink 时事通讯](https://pages.chain.link/subscribe?utm_medium=referral&utm_source=chainlink-blog&utm_content=cta)，[关注官方 Chainlink Twitter。](https://twitter.com/chainlink)*