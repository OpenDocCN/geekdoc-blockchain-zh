# 未知和波动参与的拜占庭将军中的少数民族腐败弹性

> 原文：<https://blog.chain.link/minority-corruption-resilience-in-byzantine-generals-with-unknown-and-fluctuating-participation/>

*作者:Dahlia Malkhi、Atsuki Momose 和 Ling Ren*

## 摘要

最近，[](https://eprint.iacr.org/2022/404.pdf)表现出一种拜占庭式的共识解决方案下的动态和未知的参与假设 **少数腐败** 。但是，它不完全支持波动。具体来说，只有当参与是“稳定的”时，协议才取得进展。我们的 [之前的帖子](https://blog.chain.link/instant-finality-in-byzantine-atomic-broadcast-under-unknown-dynamic-participation/) 去掉了这个假设，但是我们之前的解决方案只容忍⅓腐败。这篇文章展示了如何去除这种假设并获得最佳的损坏阈值。

由于我们已经知道了如何在给定一个分级协议(GA)的解决方案的情况下解决完全一致的问题，所以我们在这篇文章中主要关注 GA。我们通过对 [【桃色人】](https://eprint.iacr.org/2022/404.pdf) 中的 GA 解决方案的简单修改来解决带有少数损坏的 GA。

## 回顾:问题模型

我们在一个被称为 [Pass 和施【2016】](https://eprint.iacr.org/2016/918.pdf)的“沉睡”模型的设置中解决了一个称为少数腐败的分级协议(GA)的抽象问题，该模型具有未知和波动的参与。

为了便于说明，我们将把时间看作是分成离散的“轮”。实际上，模型可以用来定义，我们的解决方案可以扩展到连续时间。

活跃参与者的集合(也称为节点)是未知的，它们的计数是未知的，并且在每一轮中，它们可能被完全替换，服从以下假设:

*   **PKI。** 参与节点取自一个有限的论域，每个节点可以用一个公钥来标识，它拥有该公钥的私钥。
*   **故障节点。** 敌手可以腐化多达 *f* 节点，致使他们遭受拜占庭式的失败。
*   **活动节点。** 每个回合 r 都有一个未知的活跃集合 *节点* ，其(未知)计数，*n**<sub>r</sub>*满足*n*<sub>r</sub>≥*2f+1*
*   **同步通信。** 在 r 轮中，诚实主动节点接收 r-1 轮中诚实节点广播的所有消息。

**分级协议(GA)。** 在分级协议问题中，一组活动节点最初持有输入值∈ {0，1}(一位) <sup>1</sup> 。在 GA 结束时，一组活动节点输出(b，g ),使得以下属性成立:

*   **分级一致性。** 如果一个诚实节点输出(b，1)，那么所有诚实节点输出(b，*)。
*   **正直。** 如果一个诚实节点输出(b，*)，那么至少有一个诚实节点输入 b. 
*   有效期。 如果所有诚实节点输入 b，那么所有诚实节点输出(b，1)。
*   **独特性。** 如果一个诚实节点输出(b，1)，那么没有其他诚实节点输出(b '，1)其中 b' ≠ b.

在未知和动态参与的情况下，GA 开始时的活动节点集合可能不同于 GA 结束时的活动节点集合。

注意，Momose-Ren 中的 GA 定义不要求输出(具有任一等级)是唯一的或具有有界散度。我们需要 uniques 来简化在拜占庭一致性解决方案中嵌入 GA。

<sup>1</sup>*T3】扩展到非二进制 GA 并不难；为了说明的简洁，省略了它。*

## 分级协议解决方案

在整个协议中，在第 r+1 轮开始时的唤醒节点回显它从第 r 轮接收的所有消息。

我们的 GA 分三轮构建:

**第一轮。在第 1 轮开始时，清醒节点在消息“ **输入** ，b”中广播其输入 b。**

**回合-2。** `At the start of round 2, an awake node broadcasts “**tally**, b, y” where y is the # of “input, b” messages by unique senders it has received at the end of round 1.`

**第三轮。** **在第 3 轮开始时，一个清醒的节点广播“**”、b“如果在第 2 轮结束时它收到的# of“输入，b”是超过一半的唯一输入发送者。****

 ****在第 3 轮结束时，清醒节点观察到以下 参数:

*   E =“输入，*”消息的唯一发件人的数量。
*   `For all b, M(b) = the **median** of values y in “tally, b, y” by unique senders.`
*   V =“vote，*”消息的唯一发件人数量。  

A 节点产生以下 **输出，** 为所有 b:

*   如果“投票，b”的#大于 V/2，那么 **输出(b，0)。**
*   若 M(b) > E/2，且未输出(b '，0)用 b' ≠ b，则 **输出(b，1)。**

### 直觉

我们的解决方案基于 Momose-Ren 的时移法定人数技术，但使用了一种新技术(突出显示的部分)来消除稳定参与的要求。

更具体地说，莫莫塞人的时移法定人数的工作方式如下。第 2 轮中的一个节点记住了“输入，b”(我们的是 y)的#号，然后在第 3 轮(我们的是 E)结束时将它与“输入，*”的发送者的#号进行比较。由于所有“输入，*”消息都被转发，如果 y > E/2 成立(到输出(b，1))，那么在第 3 轮开始时的一个清醒节点必须观察多数“输入，b”并投票给 b，使得每个人都输出(b，0)。

关键在于，一个节点只需要知道**的某个诚实节点已经在第 2 轮中计数了 y“输入，b”就可以保证转发 y“输入，b”消息，它不需要 **记住** 自己在第 2 轮中的计数 y。为了得到真实的 y 值，我们使用第二轮报告的 y 值的中位数。这样，即使在恶意节点报告过高/过低 y 的情况下，我们也可以获得诚实节点 y 的可靠估计，并且时移法定人数参数仍然成立。**

 **### 正确性(草图)

**分级一致性:如果一个诚实节点输出(b，1)，那么所有诚实节点在第 3 轮输出(b，0)结束时醒来。**

假设一个诚实的节点 p 输出(b，1)。我们表示如下:

*   E[p]，M[p](b)——p 在第三轮结束时的 E，M(b)值。

我们有 M[p](b) > E[p] / 2。

T[p]中存在一个诚实发送者 T，其“tally b，y[t](b)”具有 y[t](b) ≥ M[p](b)。这是因为 M[p](b)是所有回显计数 v 的中间值，每个发送者最多有一个计数，并且我们有诚实的多数。

在第二轮中选择一个诚实的节点 v 清醒。节点 v 在第 2 轮中至少接收到 y[t](b)“输入，b”条消息。这是因为 t 是诚实的，并且它发送的所有内容都被 v 接收到。相反，假设 v 没有“投票 b”。那么 v 具有来自至少 2*y[t](b)个发送者的“输入，*”个条目。因为 v 回应所有这些输入，所以它们在第 3 轮结束时被 p 接收。我们有 E[p] ≥ 2*y[t](b) ≥ 2*M[p](b)，与 y[t](b) ≥ M[p](b) > E[p] / 2 矛盾。

因此，对于第 2 轮中的所有清醒节点 v，v 投票给 b。因此，在第 3 轮结束时，每个清醒节点必须接收针对 b 的多数投票，并输出(b，0)。

**有效性:如果所有诚实节点具有相同的输入 b，则所有诚实节点在第 3 轮输出(b，1)结束时醒来。**

由于所有诚实节点都发送“输入，b”，所以每个诚实节点 t 的计数 y[t](b)大于“输入，*”的发送者的一半。

取一个诚实节点 p，使用与上面相同的符号，在 T[p]中存在一个诚实发送者 T，其计数 y[t](b)不大于 M[p](b)。我们有 M[p](b) ≥ y[t](b) > E[p] / 2，因此有 p 个输出(b，1)。

**完整性:如果一个诚实节点输出(b，*)，那么至少一个诚实节点在第一轮醒来时输入 b**

在第 3 轮结束时，节点 p 的输出(b，*)需要在诚实投票或诚实计数中观察来自多于 E[p] / 2 个发送者的“输入，b”消息。因为 p 必须从所有诚实的发送者接收输入，所以至少有一个“输入，b”的发送者是诚实的。******