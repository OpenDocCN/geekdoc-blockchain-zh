© Springer Nature Switzerland AG 2020A. M. Langer 下一代软件架构的分析与设计[`doi.org/10.1007/978-3-030-36899-9_4`](https://doi.org/10.1007/978-3-030-36899-9_4)

# 4. 分布式客户端/服务器和数据

Arthur M. Langer^(1  )(1)哥伦比亚大学技术管理中心，美国纽约州纽约市 Arthur M. LangerEmail: al261@columbia.edu

## 4.1 客户端/服务器和面向对象分析

客户端/服务器在系统实现中提供了另一层次的复杂性。客户端/服务器的概念基于分布式处理，其中程序和数据放置在最有效的位置。客户端/服务器系统通常安装在局域网（LAN）或广域网（WAN）上。局域网可以定义为多台计算机连接在一起共享处理和数据。广域网是连接的局域网。在本书中，我们将把对客户端/服务器的讨论限制在应用程序开发概念转移到云和移动环境上。

在你能够为移动性设计有效的客户端/服务器应用程序之前，组织应该致力于对象范式。基于面向对象的实现，客户端/服务器基本上需要多一步：确定对象或类的哪些部分应该移动到仅在客户端活动、仅在服务器活动或跨广阔移动网络的两者都应该活动。许多现有的客户端/服务器应用程序需要扩展以在更分布式的设计中运行，而且这种设计不是分层的。

## 4.2 客户端/服务器应用程序的定义

我们已经说过客户端/服务器是分布式处理的一种形式。客户端/服务器应用程序有三个组件：客户端、服务器和网络。暂且不谈网络的影响，让我们先了解一下客户端和服务器的作用。尽管客户端/服务器应用程序往往被视为永久客户端或永久服务器程序，但我们将看到在对象范式中这不是真的。

“服务器”是为请求者提供信息的东西。有许多客户端/服务器配置具有永久硬件服务器。这些硬件服务器通常包含数据库和应用程序，为请求的网络计算机（以及其他局域网）提供服务。这种配置称为“后端”处理。另一方面，我们有从服务器请求信息的网络计算机。我们称这些计算机为“客户端”，并将这种类型的处理归类为“前端”。当我们将这些定义扩展到仅应用程序时，我们看一下对象或类的行为，并将其归类为客户端（请求服务）、服务器（提供服务）或两者（提供和请求服务）。

理解对象如何成为永久服务器或客户端是相当简单的。例如，汽车对象在汽车传输类型类中被归类为服务器。如果这是汽车的唯一用途，那么它将被称为“专用”服务器对象。同样，交通工具类中的汽车对象被归类为客户端对象。反过来，如果它是类中对象的唯一用途，则将其定义为“永久”客户端。但是；由于它存在于多个类中并且是多态的，汽车对象实际上既是客户端又是服务器，具体取决于对象的位置和行为。因此，当我们谈论对象的客户端/服务器行为时，我们必须首先了解它所在的“实例”以及它所在的类。

客户端/服务器的困难在于为了在网络上实现性能而进一步分离属性和服务。这意味着汽车对象的服务器服务和属性组件可能需要与客户端的组件分开，并永久放置在物理服务器机器上。

客户端的服务和属性将被存储在不同的物理客户端机器上。为了使这一点更加清晰，可以根据处理分类进一步对对象进行功能分解。因此，分析员必须参与网络设计，并了解处理将如何在网络上分布。客户端/服务器分析应该采用快速应用程序开发（RAD）^(1)，因为在系统需求阶段需要分析和设计。一旦分析员了解了网络的布局，那么必须进一步分解以产生混合对象。这些混合对象分解为专用服务器和对象功能，如下所示（图 4.1）。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig1_HTML.png](img/480347_1_En_4_Fig1_HTML.png)

图 4.1

将客户端/服务器对象分解为专用客户端和服务器对象

移动到客户端/服务器更容易，如果 OO 已经完成。在过程的早期将分析团队纳入网络设计中要困难得多。分析员在客户端/服务器中的角色将随着这些环境中对象的分布不断增长和成熟而继续扩展。

## 4.3 数据库简介

第三章集中讨论了与流程相关的应用规范。使用 DFD、PDF、ERD 等，我展示了数据元素在 DD 中的定义方式。然而，完成 DD 并构建复杂的关系数据库还有进一步的步骤。本章重点介绍了如何为电子商务 Web 应用程序设计数据库。完成 DD 和创建数据库概要图，称为实体关系图，为开发人员提供了系统的数据架构组件。我们称创建这种架构的过程为逻辑数据建模。逻辑数据建模的过程不仅定义了架构，还为实际数据库提供了构建，通常称为物理数据库。物理数据库与其逻辑对应物不同，因为它受到将用于实现系统的数据库产品的规则和格式的约束。这意味着，如果使用 Oracle 来实现逻辑模式，数据库必须符合 Oracle 所需的具体专有格式。因此，逻辑模型为规划物理实施提供了第一步。首先，我将审查构建适当概要的过程。即使选择了打包软件产品，也有可能需要使用像 Oracle 这样的数据库产品。因此，下面的许多分析和设计对于确定最适合包装的软件非常重要。

## 4.4 逻辑数据建模

逻辑数据建模（LDM）是一种方法，它审查特定的数据实体并确定需要与之关联的数据元素。有许多程序，一些是基于数学的，用于确定分析员需要如何以及需要做什么。因此，LDM 只关注存储的数据，并意图设计可以定义为系统“引擎”的内容。通常这个“引擎”被称为“后端”。引擎的设计必须独立于流程，并且必须基于数据定义理论的规则。下面列出了构建数据库蓝图的八个建议步骤。该蓝图通常称为模式，定义为数据库的逻辑视图。

1.  1.

    确定数据实体

1.  2.

    选择主键和备用键

1.  3.

    确定关键业务规则

1.  4.

    将规范化应用到第三范式

1.  5.

    合并用户视图

1.  6.

    与现有数据模型集成（例如，遗留接口）

1.  7.

    确定域和触发操作

1.  8.

    根据需要进行反规范化。

在提供具体示例之前，有必要定义本章中使用的数据库术语。以下是关键概念和定义：

+   实体：可以收集数据的感兴趣的对象。Larson 和 Larson (2000)定义实体为“对真实世界中的人、事件或概念的表示”。例如，在电子商务应用中，客户、产品和供应商可能是实体。本章将提供从 DFD 中确定实体的方法。一个实体可以与许多与之相关的数据元素关联，称为属性。

+   属性：当数据元素与实体相关联时，通常称为属性。这些属性或实体的单元格属于实体或“依赖于”实体。

+   关键字：关键字是唯一标识行的实体属性。行被定义为数据库中的特定记录。因此，关键字是具有唯一值的属性，其他行或记录不能具有。典型的关键字属性包括“社会安全号码”，“订单号”等。

+   业务规则：这是业务定义为真实的规则。业务规则指导数据库中的键和其他流程的行为。

+   规范化：在数据库中消除数据冗余并确保数据完整性的过程。

+   用户视图：从用户的角度定义数据。这意味着数据元素的使用方式，其业务规则，以及它是否是关键性的，很大程度上取决于用户的定义。分析人员理解数据定义不是普遍的是很重要的。

+   领域：这与数据元素或实体属性中的值或发生次数限制相关。领域的一个示例是州，州具有 50 个可接受值的领域（即 NY，NJ，CA 等）。

+   触发器：这些是作为数据库级别事件的结果而激活或触发的存储过程或程序。换句话说，一个事件（插入、删除、更新）可能需要改变其他元素或记录。通过在数据库产品（如 Oracle）中存储的程序自动执行和更新数据来实现此更改。

+   基数：这个概念定义了两个实体之间的关系。此关系是基于一个实体与另一个实体具有的发生次数或关联数目而构建的。例如，一个客户记录可能有许多订单记录。在这个例子中，客户和订单都是不同的实体。

+   传统系统：这些是正在运行的现有应用程序。传统应用有时指的是较老且不太复杂的应用程序，需要与更新的系统进行接口或完全替换（见第十章 10）。

+   实体关系图：使用基数格式的所有实体及其关系的图表。实体关系图提供了数据的蓝图，或者说是数据引擎的图表。

## 4.5 逻辑数据建模流程

LDM（逻辑数据模型）的第一步是选择将用于启动规范化过程的实体。如果 DFD（数据流程图）按照第三章概述的程序完成，那么代表数据文件的所有数据存储器都会被转换为数据实体。这种方法的主要优势是在处理数据之前对过程进行建模。如果没有使用 DFD 或某些类似的流程工具，分析师必须依靠他们可以从旧系统获取的信息，例如现有的数据文件、屏幕和报告。以下示例描述了如何将 DFD 中的数据存储器转换为实体。名为“订单”的数据存储器中包含的数据被表示为一个包含许多数据元素的实际表单（图 4.2）。因此，这个示例代表了一个被转换为称为数据存储器的 LE 的物理形式，然后再次转换为一个实体（图 4.3）。

图 4.2

样品客户订单表格

![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig3_HTML.png](img/480347_1_En_4_Fig3_HTML.png)

图 4.3

订单数据存储器转换为实体

## 4.6 关键属性

在 LDM 中的下一步是选择主键和备用键。主键被定义为用于标识实体中记录或事件的属性。主键像任何键属性一样包含唯一值。通常一个实体中有多个包含唯一值的属性。我们称可以作为主键的属性为候选键属性。这意味着该属性可以担任主键的角色。如果只有一个候选键，则没有问题：该候选键就成为主键。如果存在多个候选键属性，则必须选择一个作为主键，其他的将被称为备用键属性或次要键属性。这些备用键属性仅在物理数据库中提供好处。这意味着它们可以用作数据库中记录的标识，作为主键未知时的替代方法。接下来举个例子。假设一个员工实体有两个候选键：社会安全号和员工 ID。员工 ID 被选为主键，因此社会安全号成为备用键。在逻辑实体中，社会安全号被视为任何其他非键属性；然而，在物理数据库中，它可以被用于（或索引）查找记录。这可能发生在员工打电话询问人力资源部关于累计休假时间时。人力资源部工作人员会要求员工提供其员工 ID。如果员工不知道自己的员工 ID，人力资源部工作人员可以要求他们提供其社会安全号，并使用该信息作为替代方法来定位该个人的信息。需要注意的是，基于主键的搜索速度会大大加快，因为主键搜索使用一种称为直接访问的方法，而不是索引方法，后者明显较慢。这引出了一个问题：当存在多个候选键属性时，应选择哪个属性作为主键？答案是最常用于查找记录的属性。这意味着员工 ID 被选择为主键属性，因为用户确定它是最常用于查找员工信息的字段。因此，电子商务分析师必须确保他们在面试过程中问用户这个问题。图 4.4 提供了一个员工实体的图形描述，显示员工 ID 为主键属性，社会安全号为非键属性。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig4_HTML.png](img/480347_1_En_4_Fig4_HTML.png)

图 4.4

主键和备用键属性

-   还有一种称为外键的键属性。外键提供了一种链接表格并在它们之间创建关系的方法。由于外键是在规范化过程中创建的，我将推迟在本章中关于规范化的部分讨论它们。

## -   4.7 规范化

-   虽然 LDM 的下一步是确定关键业务规则，但先解释规范化的过程会更容易些。也就是说，在实践中，规范化发生在定义关键业务规则之后，但在教育目的下介绍该主题时不会发生。因此，在规范化之后将讨论关键业务规则。

-   毫无疑问，规范化是 LDM 中最重要的方面。如上所述，规范化被定义为在实体中消除冗余并确保数据完整性。正是后者在理解规范化在电子商务数据库系统设计中的价值时至关重要。对 LDM 过程的理解在很大程度上取决于如何实现规范化过程。

-   规范化是按照一定的“范式”构建的。虽然有五种已发布的范式，但范式 4 和 5 难以实现，大多数专业人士都会避开它们。因此，本书省略了范式 4 和 5。规范化的三个范式列在下面。请注意，范式被表示为“NF”。

+   -   第一范式（1st NF）：没有重复的非键属性或非键属性组。

+   -   第二范式（2nd NF）：在连接键属性的一部分上没有部分依赖。

+   -   第三范式（3rd NF）：非键属性之间没有依赖关系。

-   每个范式都依赖于前面的范式，也就是说，完成规范化的过程取决于满足前面的范式。规范化可以通过提供详细的示例来最好地解释。使用图 4.1 中提供的订单表格，我们可以开始规范化的过程。图 4.5 显示了订单表的逻辑等价实体格式。在此示例中，主键是订单号（由“PK”标记表示），这要求每个订单都与唯一的订单号相关联。还应注意，由五个属性组成的重复组显示在单独的框中。这个属性的重复组对应于订单表上的一个区域，通常称为订单行项目。这意味着与订单相关的每个项目都显示在其自己的组中，即项目标识、名称、单价、数量和金额。图 4.1 中的客户订单显示与订单号 12345 相关联的两个项目。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig5_HTML.png](img/480347_1_En_4_Fig5_HTML.png)

-   图 4.5

-   订单实体及其相关属性

确定规范化遵从性的过程是评估是否满足了每个正规形式或 NF。这可以通过逐个测试每个 NF 来完成。因此，第一个要问的问题是：我们是否处于第一范式？答案是否定的，因为存在重复属性：Item-ID、Item-Name、Quantity、Unit-Price 和 Amount，或者如上所述一个“订单行项目”。在显示此框时，示例暴露了可以与客户订单相关联的项目重复组。观察这种现象的另一种方式是看到在订单内，实际上确实存在另一个实体，该实体具有自己的关键识别。由于存在一组重复的属性，因此存在第一范式失败。每当一个 NF 失败或违反时，都会导致创建另一个实体。每当第一范式失败时，新实体将始终以连接的“组”属性作为其主键。这种连接，或者将多个属性连接成一个特定值，由原始实体（订单）的主键与重复元素组的新键属性相连接。新键必须是控制其他属性组的属性。在本例中，控制属性是 Item-ID。确定新的“键属性”后，将其与订单实体的原始键属性连接起来。其余的非键属性将从原始实体中移除，成为新实体的非键属性。这个新实体显示在图 4.6 中。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig6_HTML.png](img/480347_1_En_4_Fig6_HTML.png)

图 4.6

第一范式的订单

新实体称为订单项，其主键反映了来自实体订单的原始键 Order-Number 与代表重复组的控制属性 Item-ID 的连接。所有其他重复属性现在都已转移到了新实体。新实体订单项允许系统根据需要存储多个订单行项目。未经此修改的原始实体将限制项目的出现次数。例如，如果分析/设计人员默认为五组订单行项目，则数据库将始终具有五个属性的五次发生。如果大多数订单实际上都少于五个项目，则会浪费大量空间。更重要的是订单有超过五个项目的情况。在这种情况下，用户需要将订单拆分为两个物理订单，以便捕获额外的项目。实现第一范式的实体的这两个问题是显著的优点。因此，保持订单实体不变实际上会创建一种完整性问题。

完成了对实体“订单（Orders）”的更改，以及新实体“订单项（Order Item）”的完成后，系统被称为处于第一范式数据库。需要注意的是，实体“订单项”的新主键是两个属性的组合。虽然这两个属性保持独立作为数据的单独字段，但在作为关键属性的角色时，它们被用作一个组合值。例如，根据图 4.1 中订单表中的数据，实体“订单项”将有两条记录。第一条记录将具有主键为 1234531，这是订单编号（12345）与商品编号（31）的连接。第二条记录将是 1234527，这是相同的订单编号，但与第二个商品编号（27）连接。从 SQL 功能的角度来看，虽然关键属性将每个属性连接成一个地址，但它可以作为单独的字段进行搜索。因此，用户只需搜索包含订单编号为“12345”的订单项即可搜索与订单 12345 关联的所有商品。这展示了关系模型的灵活性。一旦达到第一范式，就必须进行下一个测试，即测试是否符合第二范式。

第二范式测试仅适用于具有连接键的实体。因此，任何处于第一范式且没有连接主键的实体必须已经处于第二范式。在我们的示例中，“订单（Orders）”实体已经处于第二范式，因为它处于第一范式且没有连接主键。然而，“订单项（Order Items）”实体属于另一类。订单项具有连接的主键属性，必须测试是否符合第二范式。第二范式要求分析人员确保实体中的每个非键属性完全依赖于主键的所有组成部分，或所有的连接属性。当我们应用测试时，我们发现属性“商品名称（Item-Name）”仅依赖于关键属性“商品编号（Item-ID）”。也就是说，订单编号对商品名称没有影响或控制。这种情况被视为第二范式失败。必须再次创建一个新实体。新实体的主键是导致失败的属性的连接键的一部分。换句话说，商品编号是新实体的主键，因为“商品名称”完全依赖于属性“商品编号”。现在值得进一步解释属性依赖的概念。一个属性对另一个属性的依赖意味着控制属性的值可以更改依赖属性的值。另一种解释这一点的方法是说，必须是一个键的控制属性控制记录。也就是说，如果商品编号发生变化，则我们正在查看不同的商品名称，因为我们正在查看不同的商品记录。

为了完成新实体 Items 的创建，必须对原始实体 Order Items 中的每个非关键属性进行第二范式违规测试。请注意，作为此测试的结果，“Quantity”和“Amount”留在 Order Items 实体中，因为它们依赖于 Order-Number 和 Item-ID。也就是说，与任何给定的 Order Items 出现相关联的数量不仅依赖于物品本身，还依赖于与其相关联的特定订单。我们称之为完全依赖于连接的主键属性。因此，非关键属性的移动是基于对每个非关键属性与连接的主键的测试。此测试的结果确定了图 4.7 中显示的三个实体！../images/480347_1_En_4_Chapter/480347_1_En_4_Fig7_HTML.png

图 4.7

订单在第二范式中

实施第二范式的结果表明，如果没有它，无法在没有订单的情况下向数据库中添加新的 Item（或 Item-ID）。这显然会造成重大问题。确实，必须在创建具有新订单的 Item 之前添加新 Item。因此，新实体表示创建一个单独的 Item 主文件，如图 4.7 所示。

图 4.7 表示第二范式的订单。我们必须再次应用下一个测试-第三范式以完成规范化。第三范式测试两个非关键属性之间的关系，以确保它们之间没有依赖关系。确实，如果存在这种依赖关系，这意味着其中一个非关键属性实际上是一个关键属性。如果发生这种情况，控制非关键属性将成为新实体的主键。针对示例实体的测试反映出 Customer-Name 和 Customer-Address^(2) 依赖于 Customer-ID。因此，实体 Orders 不符合第三范式，必须创建一个新实体。新实体的主键是控制其他非关键属性的非关键属性；在这种情况下是 Customer-ID。新实体称为 Customers，并将所有依赖于 Customer-ID 的非关键属性移动到该实体中，如图 4.8 所示！../images/480347_1_En_4_Chapter/480347_1_En_4_Fig8_HTML.png

图 4.8

订单在初步的第三范式中

第三范式失败的独特之处在于新的关键属性仍然作为原始实体（在本例中为：订单）中的非关键属性。非关键属性 Customer-ID 的副本被称为外键，并且被创建以允许订单实体和新的客户实体建立关系。两个实体之间的关系只有在它们之间至少有一个公共的键属性时才能存在。理解这个概念对于归一化的目的至关重要。观察图 4.8，可以看到实体订单和订单项目之间存在关系，因为这两个实体都有一个共同的键属性：Order-ID。在创建物品实体时也是如此，这是由于第二范式失败而产生的。这里的关系是订单项目实体和物品实体之间的，这两个实体都包含共同的关键属性 Item-ID。这些关系都是在归一化过程中从原始实体传播关键属性而产生的。通过传播，我们指的是将指针或关键属性的副本放置在新实体中。传播是使用外键实现的，并且是该过程的自然结果。注意，“PK”后面跟着一个“FK”，表示键属性是原始键属性的传播结果。在第三范式中不是这种情况。如果从订单实体中删除 Customer-ID，则订单和客户之间的关系将不存在，因为两个实体之间没有共同的键属性。因此，在第三范式中，需要强制建立关系，因为自然的传播并未发生。这通过从非键属性到主键副本（在本例中为 Customer-ID）创建一个指针来实现。指针的概念很重要。外键结构通常在物理数据库中使用索引内部实现。索引或间接地址是通过确保仅存储一个属性值的副本来维护数据库完整性的一种方式。如果存储了两份 Customer-ID 副本，则更改其中一份可能会在订单和客户之间创建完整性问题。解决方案是使订单中的 Customer-ID 间接“指向”客户实体中的 Customer-ID 键属性。这确保了不能向订单实体添加不存在于客户主实体中的 Customer-ID。

现在的问题是实体是否处于第三范式。经过进一步审查，我们发现答案是否定的！虽然这并不直观，但有三个非键属性依赖于其他非键属性。这首先发生在订单项实体中。非键属性“Amount”依赖于非键属性“Quantity”。Amount 表示订单中每个商品的总计。它不仅依赖于“Quantity”，还依赖于“Unit-Price”。这在计算属性中经常发生。此类属性称为派生元素，并且从数据库中删除。实际上，如果我们存储 Quantity 和 Unit-Price，“Amount”可以单独计算，而不是作为单独的属性存储。存储计算还会导致完整性问题。例如，如果数量或单价更改会发生什么？数据库必须重新计算更改并更新 Amount 属性。虽然这是可以完成的，并且将在本章后面讨论，但在数据库中维护起来可能会出现问题，并导致生产电子商务系统的性能问题。订单实体还包含两个派生属性：Subtotal 和 Total-Due。同样，这两个属性都被移除了。问题在于是否应将派生属性的移除视为第三范式的失败。Date (2000) 将这些失败视为第三范式之外的情况，但在我看来，它们代表了对其他非键属性的间接依赖，并应作为第三范式测试的一部分包括在内。无论如何，我们都同意在 LDM 过程中应删除派生元素。第三范式 LDM 被修改以反映删除这三个属性，如图 4.9 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig9_HTML.png](img/480347_1_En_4_Fig9_HTML.png)

图 4.9

第三范式第二阶段的订单

一旦达到第三范式，分析员应创建实体关系图（ERD），其中将显示实体之间的关系或连接。实体之间的关系通过关联建立。关联使用所谓的 Crow's Foot 方法定义关系的基数，如图 4.10 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig10_HTML.png](img/480347_1_En_4_Fig10_HTML.png)

图 4.10

使用 Crow's Feet 格式的 ERD 实体

Crow's Foot 方法只是众多格式之一。该方法包含三个关键符号：

![../images/480347_1_En_4_Chapter/480347_1_En_4_Figa_HTML.png](img/480347_1_En_4_Figa_HTML.png)

表示许多出现的基数

![../images/480347_1_En_4_Chapter/480347_1_En_4_Figb_HTML.png](img/480347_1_En_4_Figb_HTML.png)

表示零次出现

![../images/480347_1_En_4_Chapter/480347_1_En_4_Figc_HTML.png](img/480347_1_En_4_Figc_HTML.png)

表示一个发生。

因此，图 4.10 中的 ERD 描述了所有实体之间的关系如下：

1.  1.

    一个且仅一个（由双线表示）订单记录可以拥有一到多个订单项目记录。它还显示了订单项目实体中的任何订单必须存在于订单实体中。

1.  2.

    一个且仅一个物品记录可以拥有零个到多个订单项目记录。这种关系与订单和订单项目之间建立的关系的区别在于，物品可能与订单项目没有关系，由 Crow's Foot 中的零表示。当存在一个尚未接收任何订单的新物品时，这种情况通常会发生。

1.  3.

    Order Items 实体具有一个主键，该主键是来自订单实体的 Order-ID 和来自物品实体的 Item-ID 两个主键的连接。这种关系被称为“联合”关系，因为该实体是作为一个关系问题的结果而创建的。这种关系问题的存在是因为订单实体与物品实体之间存在“多对多”的关系。因此，创建联合实体 Order Items 的第一范式失败实际上是“多对多”情况的结果。多对多关系违反了规范化，因为它会导致 SQL 编码中的重大问题。因此，每当两个实体之间存在多对多关系时，都会创建一个联合实体，其主键将是每个实体的两个主键的连接。因此，联合实体将多对多关系转换为两个一对多关系，以便 SQL 在搜索过程中能够正常工作。联合实体通常用钻石框表示。

1.  4.

    一个且仅一个客户可以拥有零个到多个订单，还显示了可能存在从未下过订单的客户。例如，如果业务是信用卡，消费者可以获得信用卡，即使他们没有进行购买。请注意，通过非关键外键属性将 Customer-ID 与订单相关联。

## 4.8 规范化的限制

尽管已经达到了第三范式，但是模型存在一个主要问题。问题涉及到 Items 实体中的 Unit-Price 属性。如果任何 Item 的 Unit-Price 发生变化，那么历史订单项目购买的计算将不正确。请记住，“Amount”属性已被消除，因为它是一个派生元素。这可能表明规范化工作不正常！但事实并非如此。首先，我们需要评估将“Amount”放回 ERD 是否会解决问题。如果 Unit-Price 发生变化，那么 Amount 在计算之前需要重新计算。虽然这可能看起来合理，但实际上并没有提供解决问题的方法，只是绕过了问题。实际的问题与“Amount”属性关系不大，但与一个缺失的属性有更多关系。缺失的属性是 Order-Item-Unit-Price，它将代表订单时的价格。Order-Item-Unit-Price 取决于订单和项目，因此会成为订单项目实体的非键属性（即，它完全依赖于整个串联主键）。Unit-Price 和 Order-Item-Unit-Price 之间的唯一关系是在订单输入系统时。在这种情况下，应用程序将 Unit-Price 属性的值或金额移动到 Order-Item-Unit-Price 属性中。此后，这两个属性之间没有关系。因为这是在规范化过程中发现的新数据元素，所以必须将其输入到数据字典中。因此，规范化的一个限制是它不能规范化它没有的内容；它只能规范化被呈现给公式的属性。但是，规范化的限制也是一个优势：该过程可以帮助分析人员意识到缺少一个数据元素。因此，规范化是分析人员可以使用的“基于数据”的工具，以达到逻辑等价。图 4.11 显示了添加了 Order-Item-Unit-Price 的最终 ERD。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig11_HTML.png](img/480347_1_En_4_Fig11_HTML.png)

图 4.11

最终的 ERD 包含了 Order-Item-Unit-Price。

## 4.9 超类型/子类型模型

在 LDM 中出现了一个麻烦的数据库问题，当实体内有记录可以具有不同特性或具有许多“类型”属性时。 “类型”意味着特定记录中的一部分属性可能会根据该实体内的行的特性或标识而变化。定义类型的另一种方式是将其描述为给定记录中的一组属性，这些属性根据其表示的记录类型而不同于同一实体的其他记录。这种类型被称为记录的“子类型”。因此，子类型是记录中偏离标准或“超类型”部分的部分。 “超类型”部分在实体的所有记录中始终相同。换句话说，“超类型”代表实体中属性的全局部分。下图 4.12 中的图示了超类型/子类型关系。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig12_HTML.png](img/480347_1_En_4_Fig12_HTML.png)

图 4.12

超类型/子类型关系

子类型和普通类型标识符（使用外键）之间的区别在于至少存在一个非键属性仅存在于该子类型记录中。创建超类型/子类型关系的主要原因是在只有某些子类型记录中存在多个这些唯一属性的排列。限制一条记录格式内的这些属性的排列可能会有问题。首先，它可能会浪费存储空间，特别是如果每个子类型具有大量唯一属性的情况下。其次，它可能会导致数据查询的重大性能问题。使用图 4.12，我们可以看到存储这些数据的两种方式。第一种（图 4.13）是一种基本表示，其中所有排列都存在于一个名为“教育者”的实体中。行的“类型”通过使用指向验证实体“教育者类型”的外键指针来标识。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig13_HTML.png](img/480347_1_En_4_Fig13_HTML.png)

图 4.13

使用外键标识符的教育者 ERD

虽然此数据表示仅使用一个实体，但会浪费存储空间，因为实体的所有属性从未被任何一个“类型”的记录所需。此外，用户必须知道哪些属性需要为特定类型的记录输入。这种逻辑数据建模方法违反了归一化的概念，并且将实体中元素的值的完整性委托给应用程序的控制（存储过程）或用户的记忆。这两种选择都不是特别可靠或已被证明是数据完整性的可靠方法。

另一方面，图 4.14 提供了使用超类型/子类型模型的不同解决方案。

图 4.14

教育工作者实体超类型/子类型模型

该模型为每种类型的教育工作者构建了一个单独的实体，通过关系模型中的特殊符号，称为超类型/子类型关系进行连接。关系是互斥的，这意味着超类型实体教育工作者在任何给定的超类型发生中只能有三个子类型中的一个。因此，一个超类型的记录与一个子类型的关系必须是一对一的。超类型/子类型模型创建了一个单独的子类型实体，以仅携带其子类型特有的特定属性。

这种实体结构有两个主要好处。首先，该结构节省存储空间，因为它只存储每个实体所需的属性。其次，子类型信息可以直接访问，而无需访问其相关的超类型。这是可能的，因为每个子类型实体包含与其父类相同的主键。这种能力很重要，因为用户可以从任何子类型自动获取唯一信息，而无需首先通过超类型实体进行搜索。当每个子类型中的记录数量差异显著时，这一点尤为重要。例如，假设数据库中有 600 万名教育工作者。因此，教育工作者数据库将包含 600 万行。假设其中 500 万名教育工作者是高中教师，因此，高中子类型实体有 500 万条记录。八十万名教育工作者是教授，其余 20 万名教育工作者是院长；因此，教授数据库和院长数据库分别有 80 万和 20 万条记录。使用超类型/子类型模型应用程序可以访问每个子类型，而无需搜索数据库中的每条记录。此外，由于对一个子类型的访问不会影响其他子类型，因此性能得到了极大的改善。

需要注意的是，超类型/子类型模型并不局限于相互排斥，也就是说，它可以支持多个子类型排列组合。例如，假设教育工作者可以同时是高中教师、大学教授和院长，或者三种类型的任意组合。然后，示例模型将被修改为显示单独的一对一关系，而不是图 4.14 中显示的“T”关系。替代模型在图 4.15 中表示。

图 4.15

没有相互排斥的超类型/子类型模型

超类型/子类型可以级联，即它们可以在每个子类型内继续迭代或分解。这在图 4.16 中表示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig16_HTML.png](img/480347_1_En_4_Fig16_HTML.png)

图 4.16

级联子类型

在上述示例中，请注意相同的主键继续连接实体之间的“一对一”关系。此外，图 4.16 还展示了超类型/子类型模型中的另一种可能性。这种可能性反映了子类型可以存在而不包含任何非键属性。这在子类型实体 Adjunct Prof 的示例中发生。这个“空”实体仅用于标识子类型的存在，而没有与之关联的专用非键属性。因此，Adjunct Prof 实体仅用于允许另外两个子类型（Tenured Prof 和 Contract Prof）存储它们的唯一属性。此示例展示了如何构建超类型/子类型模型，以及它们通常为标识目的而创建的子类型。

级联子类型可以混合方法，即一些级联级别可能不是相互排他的，而其他级联级别可以是相互排他的，如图 4.17 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig17_HTML.png](img/480347_1_En_4_Fig17_HTML.png)

图 4.17

具有交替排他性的级联子类型

在数据库开发人员中存在一个有争议的问题。这个争议与是否需要创建一个特殊属性来标识哪个实体包含任何给定超类型的子类型条目有关。换句话说，数据库如何知道哪个子类型包含继续信息？当超类型/子类型中存在互斥关系时，这个困境尤其相关。最终的问题是超类型/子类型模型是否需要包含一个标识符属性，用于知道哪个子类型持有继续记录，或者这个问题是否由物理数据库产品解决？弗莱明和冯·哈勒在《数据库设计手册》中解决了这个问题，他们建议“属性至少在一定程度上是冗余的，因为它的含义已经通过类别或子类型关系传达出来”（第 162 页）。然而，冗余问题在物理数据库产品之间可能有所不同。因此，我建议逻辑模型包含一个子类型标识符，用于互斥的超类型/子类型关系，如图 4.18 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig18_HTML.png](img/480347_1_En_4_Fig18_HTML.png)

图 4.18

具有子类型标识符元素的超类型/子类型

请注意，上述示例将子类型标识符 Professor Types 作为第三范式中的验证实体。

超类型/子类型还必须按照规范化规则进行规范化。例如，子类型 Educator Types 包含不符合第三范式的元素。子实体高中教师的属性 Grade_Level 和 Subject 可以使用查找表进行验证。部门、学校和 PhD_Subject 也可以进行验证。生成的第三范式 ERD 如下所示，见图 4.19。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig19_HTML.png](img/480347_1_En_4_Fig19_HTML.png)

图 4.19

第三范式中的超类型/子类型

## 4.10 关键业务规则

关键业务规则是在插入或删除行时管理实体之间行为的规则。这些业务规则在数据库级别使用存储过程和触发器进行编程（参见步骤 7：确定域和触发操作）。这些过程通常被标记为约束。约束强制执行分析人员定义的关键业务规则，并且是所谓的引用完整性的基础，即基于表之间关系的完整性。插入和删除的过程侧重于父实体和子实体之间的关系。子实体始终是具有 Crow’s Foot 指向的实体。根据图 4.10 中的 ERD，父子实体关系如下：

+   订单实体是订单项实体（子实体）的父实体。

+   客户实体是订单实体（子实体）的父实体。

+   Items 实体是 Order Items 实体（子实体）的父实体。

当讨论插入行时，始终从子实体的角度进行。也就是说，管理插入子记录的关键业务规则涉及尝试插入没有相应父记录的子记录时应执行的操作。有六个选择：

1.  1.

    不允许：这意味着约束是不允许事务。例如，在图 4.11 中，用户不能为不存在于订单实体（父实体）中的订单号插入订单项（子实体）。基本上，引用的完整性将被维护，直到订单实体中首先插入订单号。

1.  2.

    添加父项：这意味着如果父项键不存在，它将同时被添加。使用图 4.11，这意味着在插入子项之前，用户将被提示将订单号添加到订单实体中。不允许和添加父项之间的区别在于用户可以在插入子交易时输入父信息。使用此规则仍然强制执行引用完整性。

1.  3.

    默认值：使用默认值允许将“虚拟”行插入到父行中。使用默认值的示例是当收集机构从未知人士那里收到付款时。父实体是“账户”，子实体是“付款”。账户实体将具有一个名为“未分配”的关键值，该值在收集到未知付款时使用。在这种情况下，拥有虚拟记录是合适的，因为子交易实际上是未知的，但同时需要记录在数据库中。这也很有用，因为用户可以快速获取“未分配”付款列表，并且它维护了参照完整性。

1.  4.

    算法：算法是一个“智能”的默认值。使用与（3）相同的示例，假设用户想要按州跟踪未分配的付款。例如，如果在纽约收到了未分配的付款，则父项（账户实体）将插入一个带有值“未分配-纽约”的记录。因此，每个州都有自己的默认值。还有基于复杂算法的默认键，以确保对父键属性值的选择有所了解。同样，此选择确保参照完整性，因为记录会被插入到父实体和子实体中。

1.  5.

    空值：指定空值意味着父项不存在。大多数数据库产品（如 Oracle）允许这样的选择，虽然它在产品内部保持，但它违反了参照完整性，因为父项是未知的。

1.  6.

    不关心：这基本上表示用户愿意接受数据库中不存在参照完整性。用户会告诉您，他们从不希望平衡子记录与父记录。尽管会发生这种情况，但应该避免，因为它会创建一个没有完整性的系统。

在讨论行的删除时，始终从父实体的角度出发。也就是说，关于删除具有对应子记录的父记录时应该执行的关键业务规则。同样有六个替代方案：

1.  1.

    不允许：这意味着约束是不允许删除父记录。换句话说，如果存在子记录，则用户无法删除父记录。例如，在图 4.11 中，如果用户无法删除订单（父项），如果在订单项目实体（子项）中有相应的记录，则此操作将要求用户先删除所有订单项目或子记录，然后才能删除父订单。  

1.  2.

    删除所有：这也称为级联，因为系统会自动删除与父实体相关联的所有子关联。使用与（1）相同的示例，订单项目中的子记录将自动删除。虽然此选项确保引用完整性，但它可能会删除其他重要记录。

1.  3.

    默认值：使用默认值与插入相同，即允许将“虚拟”行插入父级。这意味着原始父级被删除，并且子记录被重定向到父实体中的某个默认值行。当有许多旧的父记录（例如旧的零件编号）杂乱了父数据库时，这有时是有用的。如果保留子记录仍然很重要，则可以将它们重定向到默认父行，例如“旧零件编号”。

1.  4.

    算法：算法的使用与插入时相同。与上述情况（3）一样，默认值可能基于产品类型或其过时年份。

1.  5.

    空值：与插入时相同，分配空值意味着父项不存在。这会导致子记录变成“孤立”。引用完整性丢失。

1.  6.

    无关紧要：与插入时相同。数据库允许删除父记录，而无需检查其他实体中是否有相应的子记录。这也会导致引用完整性丢失并创建“孤立”记录。

总的来说，关键业务规则涉及主键在插入和删除操作期间的行为。在每个操作（插入和删除）中有六个备选选项。其中四个选项维护引用完整性，即数据项之间关系的可靠性。数据完整性是数据发生变化时的问题，在电子商务系统中，这种变化是频繁的。因此，电子商务分析师必须确保一旦确定了主键，非常重要的是要对用户的引用完整性需求进行访谈。分析师不应该孤立地做出这些决定，需要适当向用户展示引用完整性的优势，以便他们能够做出明智和充分的决策。

对关键业务规则的讨论是基于使用规范化讨论中提取的示例。正如本章前面讨论的那样，规范化的应用发生在确定关键业务规则之后，特别是因为它可能影响 ERD 的设计以及存储过程的编程。这将在本章的“确定域和触发操作”部分进一步讨论。

## 4.11 合并用户视图

规范化的应用侧重于将实体分解或分解以包括数据的正确放置。每个 NF 故障都会导致创建一个新实体；但是，某些情况下可能需要合并某些实体。本节标为“组合用户视图”，因为数据的含义很大程度上取决于用户如何定义数据元素。不幸的是，有些情况下，数据元素被称为不同的事物，并且由不同部门的不同用户以不同方式定义。这个例子中的“不同”一词对示例至关重要。在我们认为有两个实体的情况下，实际上我们可能只有一个。因此，组合用户视图的过程通常会导致将两个或更多实体合并，而不是像规范化所做的那样对其进行分解。理解这个概念的最佳方法是回顾早期对逻辑等价物的讨论。对逻辑等价物的此解释将侧重于数据而不是过程。假设有两个由两个不同部门创建的实体。第一个部门为名为“客户”的实体定义了元素，如图 4.20 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig20_HTML.png](img/480347_1_En_4_Fig20_HTML.png)

图 4.20

客户实体

第二个部门定义了一个名为“客户”的实体，如图 4.21 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig21_HTML.png](img/480347_1_En_4_Fig21_HTML.png)

图 4.21

客户实体

在对数据元素定义进行更详细的分析和审查后，显而易见两个部门正在看同一个对象。无论实体被命名为客户还是客户，这些实体都必须合并。将两个或更多实体合并的过程并不像听起来那么简单。在这两个示例中，存在相同但具有不同名称的数据元素，并且每个实体中还有独特的数据元素。每个部门都不知道对方对相同数据的看法，并通过应用逻辑等价性得到以下单一实体，如图 4.22 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig22_HTML.png](img/480347_1_En_4_Fig22_HTML.png)

图 4.22

组合的客户和客户实体

上述示例使用的名称使分析人员更容易知道它们是相同的数据元素。然而，在现实中，情况可能并非如此，特别是在处理遗留系统时。在遗留系统中，元素的名称和定义在部门和应用程序之间可能存在显著差异。此外，数据定义也可能存在显著差异。假设 Client 被定义为 VARCHAR2(35)，而 Customer 被定义为 VARCHAR2(20)。解决方案是采用较大的定义。在其他情况下，一个元素可以被定义为字母数字，而另一个元素则为数字。在这些情况下，决策变得更加复杂，需要进行用户对话。无论是哪种情况，重要的是数据元素确实被合并，并且用户同意这种合并。在用户达成一致意见困难的情况下，分析人员可以利用数据字典功能中的别名。别名被定义为数据元素的替代名称。多个别名可以指向同一个数据字典条目。因此，屏幕可以显示作为另一个元素别名的名称。当需要使用不同的名称时，这种替代方案可以解决许多问题。

在合并用户视图时，另一个重要问题是性能。虽然分析人员在逻辑数据模型设计期间不应过分关注性能问题，但也不应忽视。简单地说，实体越少，性能越快；因此，在 ERD 中设计的实体数量越少越好。

## 4.12 与现有数据模型集成

本节的目的是讨论与如何与现有数据库应用程序集成相关的特定分析和设计问题。与其他数据库系统的连接是困难的。事实上，许多公司通过逐步将每个业务领域转移到新的重新开发的操作中来应对这种情况。在这种情况下，每个阶段性区域都需要一个“遗留链接”，它允许“旧”应用程序与新的逐步引入的软件一起工作。

将实体与现有数据库链接可能会迫使电子商务分析人员重新考虑如何在保持与其他企业数据的物理链接的同时保持完整性。在电子商务系统中，由于数据的某些部分在企业内外使用，这种情况是确定的。以下示例展示了这个问题的发生方式：

分析员正在设计一个利用公司订单主数据库的网站。该网站需要这些信息，以便允许客户查看有关其过去订单的信息，以便他们可以将其与电子商务系统提供的产品数据库匹配。此功能提供给客户以便他们了解如何利用物品制作产品。不幸的是，主订单项数据库仅保存了过去一年的订单，然后将其存储脱机。订单部门没有创建历史跟踪系统的愿望。图中的 ERD 显示了与公司订单项数据库文件的关系。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig23_HTML.png](img/480347_1_En_4_Fig23_HTML.png)

图 4.23

显示 Web 数据库与遗留员工主数据库之间关联的 ERD

注意，订单项产品实体与订单项主实体之间存在一对零或一的关系。这意味着订单项产品实体中可能存在一个订单项，而订单项实体中不存在。这不仅违反了规范化，还带来了严重的完整性问题。例如，如果客户想要显示关于他们的产品和每个组件项的信息，所有在订单项实体中不存在的项目都将显示为空白，因为在订单项文件中没有相应的名称信息。显然，这是数据库设计中的一个缺陷，需要纠正。解决方法是建立一个子系统数据库，以捕获所有的订单项而不会清除它们。这将需要一个访问订单项数据库并将其与文件的 Web 版本合并的系统。合并转换将比较两个文件，并更新或添加新的订单项，而不删除旧的订单项。也就是说，每天都会搜索主订单项以拾取要添加到 Web 版本的新订单项。尽管这是一个额外的步骤，但它保持了完整性、规范化，最重要的是，要求不修改原始订单项数据库。这种解决方案的缺点是 Web 版本可能没有最新的订单项信息。这将取决于记录何时移动到 Web 数据库。这可以通过具有复制功能来解决，其中 Web 订单项将与主版本同时创建。ERD 将如图所示重建。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig24_HTML.png](img/480347_1_En_4_Fig24_HTML.png)

图 4.24

反映订单项实体的遗留链接的 ERD

在上图中，显示了订单项主信息及其与 Web 订单项实体的关系，仅供信息目的。主订单项更多地成为应用需求，而不是 ERD 的永久部分。为了使这个系统“操作化”，分析员首先必须从清除的文件中重建历史数据，或者简单地提供某个日期的历史数据。

## 4.13 确定域和触发操作

关系型数据库模型的发展已经建立了在数据库级别存储某些应用逻辑的流程。我们已经将关键业务规则定义为创建主键属性级别约束的载体。然而，根据非主键属性的行为，可能会出现其他约束和程序。最终，业务规则是在数据库语言中编码的应用逻辑，例如 Oracle 的 PL_SQL。这些非主键属性规则可以强制执行诸如：如果输入了 CITY，则必须输入 STATE。这种类型的逻辑规则过去是在应用程序级别强制执行的。不幸的是，使用应用逻辑来执行业务规则是低效的，因为它要求将代码复制到每个应用程序中。这个过程还限制了控制，因为关系模型允许用户直接“查询”数据库。因此，数据库级别的业务规则只需编写一次，它们可以管理所有类型的应用程序，包括程序和查询。

正如前面所述，业务规则是通过存储过程在数据库级别实现的。大多数数据库制造商都提供存储过程，尽管它们相似，但它们不是使用相同的编码方案实现的。因此，将存储过程从一个数据库移动到另一个数据库并不是微不足道的。具有可移植存储过程的重要性及其与在 Internet、Intranet 和分布式网络上分区数据库的关系变得更加复杂。重要的是要注意，分布式网络系统是在客户/服务器计算的支持下构建的，并且可能需要在许多不同的数据库供应商系统之间进行通信。如果要在数据库级别实现业务规则，则此类代码的兼容性和可传输性将成为一个挑战。我们还看到客户/服务器将越来越多地被视为分布式的，尽管归一化仍然很重要，但区块链的扩展将需要存在多个存储数据。

业务规则的实现分为三类：键（Keys）、域（Domains）和触发器（Triggers）。键业务规则已作为规范化过程的一部分进行讨论。域代表与属性值范围相关的约束。如果一个属性（键或非键）的值范围从一到九，我们称该范围是属性的域值。出于上述相同的原因，这是非常重要的信息，需要在数据库级别通过存储过程进行包含和强制执行。第三个、也是最强大的业务规则是触发器。

触发器被定义为当激活时会“触发”一个或一组其他存储过程执行的存储过程。触发器作用于其他实体，尽管在许多数据库产品中，触发器正在成为在数据库级别而不是在应用程序级别提供重要功能的强大编程工具。触发器类似于批处理类型的文件，当调用时执行一个“脚本”或一组逻辑语句，如下所示：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figd_HTML.png](img/480347_1_En_4_Figd_HTML.png)

此触发器已在一家联系管理电子商务系统中实施。该触发器旨在允许将企业信息标记为仅由特定执行人员保密。这意味着公司的指定执行人员可以输入私人信息。触发器的第二个组件被设计为自动确保执行人员的联系人被存储为私人或机密。这两个存储过程展示了应用程序逻辑如何通过 Oracle 触发器执行。重要的是要记住，这些业务规则是由数据库强制执行的，无论信息如何被访问。

然而，触发器可能会引起问题。因为触发器可以在数据库文件之间引发活动，设计人员必须小心，以免损害性能。例如，假设编写了一个影响 15 个不同数据库文件的触发器。如果触发器在处理其他关键应用程序时被激活，它可能导致处理速度显著降低，从而影响关键生产系统。

业务规则的主题非常广泛，但必须针对实际使用的数据库产品进行具体说明。由于分析人员可能不知道最终将使用哪个数据库，因此应该使用第三章提出的规范格式来开发存储过程的规范。在电子商务系统中，这一点变得更加重要，因为整个系统可以使用不同的数据库。

## 4.14 反规范化

第三范式数据库通常在性能方面会遇到困难。具体来说，大量的查找表，这些表实际上是第三范式的失败，会创建太多的索引链接。因此，虽然我们已经达到了所需的完整性，但性能成为了一个不可避免的困境。实际上，完整性越高，性能就越低。有许多应对规范化数据库不足的方法。其中一种方法是开发数据仓库和数据库的其他离线副本。有许多不好的去正规化方法。事实上，任何一种去正规化都会损害完整性。但是有两种类型的去正规化可以在不显著损害数据完整性的情况下实施。

第一种去正规化的类型是重新审视第三范式失败，看看所有的验证是否都是必要的。第三范式的失败通常会创建表，以确保输入值与主列表进行验证。例如，在图 4.10 中，作为第三范式失败的结果创建的 Customers 实体为与订单相关的所有客户提供了验证。这意味着用户不能分配任何客户，而只能分配那些在 Customer 实体中的客户。选择客户的屏幕很可能会使用“下拉”菜单，其中会显示所有有效的客户供订单选择。然而，并非所有查找表都是关键的。例如，邮政编码可能需要验证，也可能不需要验证。邮政编码是否需要验证取决于用户对邮政编码的使用。如果它们只用于记录客户的地址，则可能没有必要或值得验证邮政编码。如果，另一方面，它们用于某些类型的地理分析或邮寄，则验证是必要的。这个过程——审查验证表的使用和需要的过程——应该在面试过程中进行。如果忽略了这一步，那么非关键属性中将包含太多不必要的验证查找实体的可能性很高，这会影响性能。

第二种去正规化的类型是添加“派生”属性。虽然这不是首选方法，但可以在不牺牲完整性的情况下实现。这可以通过创建触发器来完成，触发器会在依赖属性被更改时自动启动存储过程来重新计算派生值。例如，如果金额是基于数量 * 单价计算的，则必须开发两个触发器（一个用于数量，一个用于单价），它们会在数量或单价更改时重新计算金额。虽然这解决了完整性问题，但分析人员必须意识到在高峰处理时间触发器启动时可能会发生性能冲突。因此，必须在触发器和允许其发生的时间之间取得平衡。

正如前面所述，由于物联网和区块链，反规范化将更频繁地发生，其中部分数据将需要分布。我主张始终从规范化的角度开始设计，然后根据网络设计允许基于网络性能和接口设备特性的重复。

### 4.14.1 摘要

本章提供了电子商务系统数据组件的逻辑等价物。使用 LDM 完成数据分解的过程，其中包括八个主要步骤，需要按顺序应用以对数据进行功能分解。数据流图（DFD）是过程分析中的强大工具，因为它们为 LDM 方法提供直接输入。具体而言，数据流向数据字典提供数据定义，这对完成 LDM 是必要的。此外，DFD 中的数据存储表示主要实体，这是 LDM 的第一步。LDM 的输出是一个 ERD，它表示数据库的原理图或蓝图。ERD 显示实体之间的关系以及这些关系的基数。

LDM 还规定了开发存储过程的方法，这些存储过程是在数据库级别开发的程序。这些过程允许强制执行“引用完整性”，而无需开发在数据之外运行的应用程序。存储过程可用于强制执行关键业务规则、域规则和触发器。触发器是批处理程序，在发生特定条件时在数据库级别自动执行，通常在某种方式下已更改属性时。

LDM 的过程还允许在逻辑设计级别进行反规范化。这是为了分析员能够在物理数据库完成之前避免重大已知性能问题。反规范化应在用户界面时间发生，因为许多问题将取决于用户的需求和物联网和区块链的扩展。另一个重要问题是减少正在被哈希算法替换以保护安全性的自然键。

## 4.15 问题和练习

1.  1.

    逻辑数据建模试图实现什么？

1.  2.

    定义规范化。什么是三个范式？

1.  3.

    规范化不能做什么？

1.  4.

    “衍生”数据元素一词是什么意思？

1.  5.

    描述结合用户视图的概念。在许多组织中这样做有什么政治影响？

1.  6.

    什么是传统链接？描述它们如何用于强制执行数据完整性。

1.  7.

    命名并定义三种业务规则类型。

1.  8.

    为什么存储过程在某种程度上违反了数据和过程需要分开的规则？

1.  9.

    数据库触发器的缺点是什么？

1.  10.

    “反规范化”是什么意思？这是分析员的责任吗？

## 4.16 迷你项目#1

数据流图中的医生主文件包含以下数据元素：![../images/480347_1_En_4_Chapter/480347_1_En_4_Fige_HTML.png](img/480347_1_En_4_Fige_HTML.png)假设：

1.  a.

    一个医生可以与许多医院相关联，但必须至少与一个相关联。

1.  b.

    医生可以有多种专长，也可以没有专长。

分配：归一化为第三范式。

## 4.17 迷你项目 #2

以下是从东南大学计算机科学专业获取的注册表单：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figf_HTML.png](img/480347_1_En_4_Figf_HTML.png)学生们从以下课程列表中选择他们的课程：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figg_HTML.png](img/480347_1_En_4_Figg_HTML.png)

分配：使用上述形式，创建一个归一化的 ERD。确保你处于第三范式。

**提示**：最终你应该至少有四个实体，可能是五个。
