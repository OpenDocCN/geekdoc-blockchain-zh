© Santiago Palladino 2019S. Palladino[Ethereum for Web Developers](https://doi.org/10.1007/978-1-4842-5278-9_3)

# 3. 智能合约速成课

Santiago Palladino^(1 )(1)阿根廷布宜诺斯艾利斯自治城智能合约是以太坊的关键组成部分。它们保存在网络上执行的逻辑，跟踪自己的状态，并且还可以与其他智能合约进行交互。然而，它们有一些限制，例如每笔交易的计算受限以及昂贵的存储成本。它们也无法启动新的交易 - 它们依赖外部账户来触发。并且由于它们在以太坊网络上运行，因此无法直接与网络外的任何东西进行交互。在本章中，我们将

+   定义以太坊智能合约，与外部拥有账户相对应

+   确定交易的组成部分，如数据、燃气限制和价格

+   学习如何用 Solidity 编写合约

+   了解 Solidity 的修饰符、数据类型和事件

+   回顾 Solidity 中继承的工作原理

+   展示广泛使用的 ERC20 和 ERC721 令牌标准

## 什么是智能合约？

智能合约的概念由 Nick Szabo 在 1990 年代提出，^(1) 指的是在公共网络中能够捕捉现实合同概念并通过代码执行的自执行代码。

> *智能合约背后的基本思想是，许多种类的合同条款（如抵押、债券、财产权界定等）可以嵌入我们处理的硬件和软件中，以使违约成本昂贵（如果需要，有时甚至是令人望而却步的）对于违约者来说。*
> 
> —Nick Szabo

在以太坊网络中，智能合约被表示为代码，部署在一个地址上，拥有自己的状态。该代码在每次发送到它的交易上执行，并且可以执行任意计算，读写自己的存储，并可能调用网络中的其他合约。智能合约也可以持有和转移 ETH，就像任何其他以太坊地址一样。

### 注意

由于智能合约由可以执行任何计算的代码驱动，它们实际上并不限于金融合同条款。例如，它们可以用来表达不同种类的协议或共识，甚至是治理机制。

在软件中，对智能合约的一个很好的类比是 *actor*。在 actor 模型中，系统由称为 actor 的独立单元组成，它们接收消息并根据消息执行代码，修改自己的内部状态，并可能与系统中的其他 actor 进行交互。从功能的角度来看，智能合约也可以被视为 *reducer functions*：给定一个交易和合约的状态，智能合约返回一个更新后的状态。

### 外部账户与智能合约

当一个智能合约被部署到以太坊网络上时，它被创建在一个新的 *地址* 上。该地址充当智能合约的标识符：每当用户（或另一个合约）想要与其交互时，他们向该特定地址发送一个 *交易*。

*Externally owned accounts*（通常简称为 EOAs），另一方面，是由现实生活中的用户或网络外的任何代理拥有的账户。它们也由地址表示，其格式与标识智能合约的地址完全相同。因此，在以太坊中，对用户或智能合约的引用是相等的：它们只是地址。这允许将 ETH 发送到一个接收者，而不需要区分它是由智能合约支持的地址还是由最终用户管理的地址。

然而，智能合约和外部拥有账户之间有几个值得一提的区别：

+   首先，智能合约账户有*代码*，每次交易都会执行这些代码。向外部拥有账户发送交易不会在网络上触发任何执行。

+   智能合约账户无法发起交易。智能合约只能对传入消息作出反应，并在此过程中可能调用其他合约，但它们不能自行启动新的交易。需要按时执行操作（类似于定时作业）或在事件发生时（例如在特定地址之间移动余额）执行操作的合约需要外部拥有账户调用以触发操作。

+   只有外部拥有账户有对应的*私钥*。私钥用于签署发送到网络的新交易，作为身份验证的一种方式。智能合约不能发起新交易，因此它们没有必要签署任何操作。

### 注意

最后一点差异的含义是，只有外部拥有账户才能*签署*任意消息。私钥不仅可用于签署以太坊交易，还可用于任何信息的纯文本消息。例如，用户可以签署一条声明其身份的消息（如“我是 Github 上的 spalladino”），任何人（包括合约）都可以恢复对应于该签名的以太坊地址。这允许他们验证该账户的所有者是谁写了那条消息。^(2) 智能合约没有私钥的事实意味着它无法签署消息。

### 代码和状态

智能合约有两个主要属性：其代码和其状态。合约的状态由其以太币余额（因为所有以太坊地址都有相关联的余额）和其存储（其中变量的值被持久化）组成。

智能合约中的代码通常很短，因为其执行“时间”有着紧密的上界，由以太坊网络定义。每次收到合同的交易时，都会运行代码，并且可以访问合同的本地存储和交易的上下文。

### 注意

智能合约的代码是不可变的。这意味着一旦部署，智能合约就不能更改。虽然这与现实生活中的合同制造软件的原始概念一致，但它在开发方面提出了一些挑战。这使得迭代式开发特别困难，合同在推送到生产网络之前还必须是无缺陷的。这就是为什么智能合约中的安全性是如此关键的问题：智能合约不仅位于任何攻击者都可以自由交互的公共网络中，而且如果发现漏洞，原始开发人员也无法修补它。如果这种限制的前景看起来令人生畏，不要担心，因为有解决方法^(3)可用于升级智能合约，即使它们的代码是不可变的。

所有以太坊代码都不是在本地运行的，而是由以太坊节点在以太坊虚拟机（EVM）上执行。EVM 执行一个基于堆栈的低级汇编，该汇编使用 32 字节的字（word）操作，通常称为*EVM 汇编*。此汇编具有传统算术和逻辑操作的操作码，基本控制流操作，以及一些以太坊特定操作，如访问存储和内存，或查询和管理 ETH 余额。还有一些用于计算哈希或使用椭圆曲线签名的原语^(4)。值得一提的是，EVM 不支持浮点算术，所有操作都是在用作固定小数点的 256 位整数上进行的，以最小化数值错误的风险。

### 注意

在撰写本文时，基于 WebAssembly 的第二个后端，名为 eWASM，正在开发中，作为执行以太坊代码的替代环境。由于它基于现有的 WebAssembly 技术，将可以利用已经可用的工具链和优化，而不必重新实现它们。预期以太坊节点将接受并执行以任一格式编写的智能合约代码。

EVM 的执行模型旨在追求简单而非性能。所有交易都是按顺序执行的（即一个接一个地），而且始终在单个执行线程中进行。这使得对智能合约进行推理变得更加容易：当一个合约在响应交易时执行一段代码时，你可以确信它不会接收到可能影响当前线程的同时交易。

然而，由于合约可以调用其他合约，EVM 确实允许*重入调用*。例如，如果合约 A 调用合约 B，那么在同一笔交易中，没有任何阻止 B 回调 A 的机制。重入性调用可能很难推理，并且一直以来都是生态系统中一些主要黑客攻击的源头。2016 年著名的 DAO 攻击促使链分叉成为以太坊和以太经典，当时决定将被黑客攻击的用户资金归还给他们是可能的，这是由于一个重入性 bug：

> *在审查以太坊代码时，需要特别小心确保任何转移价值的函数都发生在任何状态更新之后，否则这些状态值将必然容易受到重入攻击的影响。*
> 
> —Phil Daian，《对 DAO 攻击的分析》^(5)

### 注意

与大多数平台一样，你很少会发现自己直接在汇编中编写智能合约，除非你在处理某些特别隐蔽的功能。有几种专为智能合约构建的高级语言，可以编译成 EVM 代码。其中最流行的是 Solidity，我们将在接下来的章节中进行详细介绍。

智能合约中的状态由其存储和余额组成。后者是两者中最直接的：以太坊中的所有地址类型，无论是外部拥有的帐户还是智能合约，都有与 ETH 关联的余额。以太坊提供了查询这些余额的原语（无论是从智能合约内部还是从网络外部），以及轻松转移它的原语。

至于智能合约中的存储空间，它非常大：它是一个具有 2²⁵⁶ 个 32 字节槽的可寻址空间。然而，在 EVM 中写入存储是非常昂贵的，因此应该始终谨慎使用。

由于存储使用是昂贵的，EVM 还提供了另一个可寻址的 256 位瞬态空间，称为*内存*，它相当于其他环境中的内存堆，并且保证在事务之间被清除。

### 燃气使用

在以太坊网络中执行代码需要*燃气*。智能合约运行的每个操作都会消耗预定义数量的燃气，复杂的操作消耗的燃气比简单的操作更多。总的来说，燃气只是执行成本的一种度量，旨在防止以太坊上过度复杂的计算。由于每个节点都需要执行网络上的每个事务以验证它，因此关键是尽量保持简单。这也是为什么在区块链上创建新数据的操作，例如写入存储或创建新合约，是燃气成本最高的操作之一。

如何获取气体？这个过程在每笔交易中自动处理。每当用户发送新交易时，他们会指定一个*气价*，这是 ETH 和气体之间的转换率。交易运行后，计算使用的总气量，然后使用这个气价将其转换为 ETH，并从发送者的余额中扣除。请注意，对气价没有任何要求，它几乎可以任意高或低。然而，具有非常高气价的交易将非常昂贵；另一方面，具有非常低气价的交易对矿工不具吸引力，并且很可能永远不会包含在区块链中。

### 注意

有一些服务，比如 ETH gas station，^(6)，提供以太坊网络的实时气价成本统计数据。这为您提供了关于发送交易所需的平均气价的信息。

除了气价之外，交易发送者必须指定在执行过程中要使用的最大气量。如果交易达到已使用的所有允许气量的点，它将停止运行并报告燃尽错误。这使用户可以控制他们愿意在交易上花费多少。相反，这也允许网络在实际运行代码之前检查用户是否有足够的 ETH 来支付执行，方法是检查发送者的余额是否至少是最大气量乘以指定气价。

请注意，以太坊节点可用于查询运行交易所需的气量估算，假设运行的上下文不会改变。这允许动态计算应该附加到交易中的气量，而不需要为系统发出的每个调用硬编码它。

然而，由于使用的燃气量取决于执行的操作，而执行的操作又取决于交易运行的上下文，因此节点执行的估算可能并不总是代表性的。例如，对于智能合约的以下伪代码：如果余额 > 1ETH:    运行昂贵的操作否则:    返回 true

如果在合约余额低于 1 ETH 时运行估算，则燃气估算将较低，用户可能会使用该值将交易发送到网络。然而，在交易实际被矿工接受之前，另一个交易可能会在原始交易之前执行，增加合约的余额超过 1 ETH。这将导致原始交易实际上需要更高数量的燃气，并最终以燃气耗尽错误失败。在与网络进行交互的编码时，您应该注意这些情况，始终在估算数量之上增加合理的燃气津贴，并根据需要重试带有更新估算的交易。

### 交易

总结一下，为了与智能合约进行交互，外部账户必须签署并广播一个发送到合约地址的交易。然后网络执行智能合约的代码，使用交易中的所有数据（以及合约的状态）作为上下文。

交易是具有以下属性的消息：

+   发送者地址，始终为外部拥有的账户

+   目标地址

+   要转移的 ETH 金额，可以为零

+   一个二进制数据字段，用于打包智能合约执行的参数

+   一个一次性使用的数字

+   最大燃气津贴

+   用于在燃气和 ETH 之间进行转换的燃气价格

交易也可以发送到另一个外部拥有的账户。在这些情况下，数据通常为空，因为目的只是在账户之间转移 ETH。然而，它们也会消耗燃气，尽管与发送到智能合约的交易相比数量很少。

### 注意

在最低级别上，交易实际上不包括发送者地址作为属性。它是从交易的签名中检索的。

在交易中我们尚未审查的唯一字段是*nonce*。这是一个递增的整数值，确保从一个账户发送的所有交易按顺序处理：nonce 不能跳过一个值，并且始终等于从地址发送的已执行加上待处理的交易数量。它也是网络的重播保护的一部分。通常，您不需要显式处理 nonce。

交易的生命周期有些复杂，因为交易需要被矿工挑选并确认才能被视为最终（见图 3-1）。![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig1_HTML.png](img/476252_1_En_3_Fig1_HTML.png)

图 3-1

以太坊交易的生命周期

交易生命周期中的第一步是将其发送到以太坊节点。这可以是用户拥有的私有节点，也可以是没有关联账户的公共节点。在前者中，签名通常由节点处理，该节点保存用户的私钥；在后者中，交易由客户端软件签名，然后发送到节点。无论哪种情况，节点都会通过尝试在本地执行它来检查交易是否有效，如果有效，则将其广播到网络。

广播的交易被称为*待处理*，因为它们尚未包含在区块中，但正在等待被称为*mempool*的地方。直到交易被矿工处理并添加到区块链中的时间通常取决于网络拥塞情况和交易本身的 gas 价格 - 正如我们之前提到的，更高的 gas 价格会导致更有吸引力的交易被更快地挖掘。

### 注意

未确认交易在被挖掘之前可以*替换*。在交易被广播之后，并且在被矿工拾取之前，你可以发送另一笔具有相同 nonce 和更高 gas 价格的交易。看到两个待处理交易后，矿工会更倾向于新的那个，这将使原始交易无效，因为它具有过时的 nonce。替换交易用于纠正错误或增加同一交易的 gas 价格以加快其确认速度，但这并不是一种被广泛使用的技术。我们将在第五章中对此进行审查。

最终，交易被*挖掘*并包含在一个区块中。然而，由于以太坊中的共识算法的工作方式，仍然有可能发生链的*重组*，并且包含此交易的区块被另一个区块替换。这只有在最近挖掘的区块中才有可能发生。随着每个新挖掘的区块叠加，一个区块被从链中移出的可能性变得越来越小。一打确认（即，新挖掘的区块）对于大多数情况已经足够，但根据您的用例，您可能希望等待更多确认。

单个账户可以有多个待处理交易，因为协议不要求等待交易被挖掘或确认后再发送下一个交易。nonce 确保所有待处理交易将按正确顺序由矿工处理。

在以太坊中的交易并不总是成功的。交易可能由于执行过程中耗尽 gas 或者由于智能合约代码中的预置条件检查失败等各种原因而失败。智能合约可以对调用它们的参数进行检查，如果未通过所有预置条件，则可能导致交易失败。交易是原子性的，这意味着它们在状态变化方面要么全部成功，要么全部失败。换句话说，失败的交易不会将任何更改持久化到区块链上，除了从发送者余额中扣除 gas 执行费用。因此，当您发送的交易失败时，您可以放心地知道您的合约在链上的状态没有以任何方式被更改。

### 注意

失败的交易要么是被 ABORT，要么是被 REVERT。两者之间的区别在于前者将消耗交易的最大配额之前的所有 gas，而后者只消耗直到交易失败的点为止的 gas。当预置条件检查失败时，智能合约通常会触发一个 REVERT，以免浪费用户的 gas。

在执行过程中，一个交易可能会*记录*任意信息。这些日志不能从另一个智能合约中访问，只能从以太坊网络外部，比如从前端界面中看到。记录的数据可以被结构化甚至*索引*，允许客户端搜索特定事件。当我们处理 Solidity 的*事件*时，我们将更深入地研究日志。

### 调用

虽然交易是在以太坊区块链上执行更改的唯一方法，但它们不是与智能合约互动的唯一方式。任何链下客户端都可以通过向智能合约发出静态*调用*来查询它。

Calls（调用）与交易不同，因为它们不需要签名，也不会被广播到以太坊网络，因此不能对区块链状态进行任何更改，也不会消耗任何 Gas。调用始终由接收到它们的节点解析，并且仅用于从智能合约查询数据。

一个调用执行智能合约代码，就像交易一样，唯一的区别是调用期间执行的任何更改都不会被持久化，并且调用的返回值会发送回发送者（与交易不同，发送者无法获得返回值）。如果交易可以被认为是改变智能合约状态的 setter，那么调用将是 getter。

调用甚至可以在旧区块上发出。由于区块链中的所有数据都是持久的，每个区块的链状态都被保留，^(7)因此可以在旧区块的上下文中对智能合约进行调用。虽然这个特性并不经常使用，但可以用于重构合约的历史，尽管 *日志* 是首选方法。

## Solidity

Solidity 是一种面向对象的静态类型语言，其花括号语法灵感来自于 Javascript，并支持多重继承。它是最流行的智能合约开发语言。在撰写本文时，最新的次要版本是 0.5，在本书中我们将使用该版本。

Solidity 代码的基本单位是合约，它类似于一个类，但编译成生成新智能合约的代码。Solidity 合约可以有状态变量，这些变量存储在合约的存储中，并可以定义在调用或交易时执行的函数。该语言还支持修饰符、事件、库、复杂数据类型等概念，我们将在本节中探讨这些概念。

我们只会对 Solidity 进行概述，涵盖了理解和对智能合约系统进行小改动所需的功能。强烈建议您阅读 Solidity 文档^(8)，以更深入地了解该语言，同时在部署合约之前审查安全最佳实践也是一个好主意。^(9)

### 重新编辑

在深入研究 Solidity 本身之前，我们将介绍 Remix，^(10) 这是一个用于快速原型设计 Solidity 代码的工具（图 3-2）。Remix 是一个完整的基于浏览器的 Solidity 开发 IDE。它包含一个 Solidity 代码编辑器、一个编译器和一个 EVM 运行时。EVM 运行时允许您在模拟环境中本地部署和测试智能合约。Remix 也可以连接到任何以太坊节点，允许您管理任何网络上的智能合约，无论是本地开发网络还是主以太坊网络（也称为 *主网*）。![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig2_HTML.jpg](img/476252_1_En_3_Fig2_HTML.jpg)

图 3-2

在 remix.ethereum.org 上 remix IDE 的屏幕截图

Remix 具有几个功能，用于开发、分析、部署、与智能合约交互和调试。我们将重点关注最基本的功能，但也可以随意使用该工具进行尝试。

要开始，请点击 IDE 左上角的加号，添加一个新文件，并创建一个新的 MyContract.sol 文件。在屏幕右侧的 *编译选项卡* 中，请确保您正在使用编译器版本 0.5.0，并选择 *自动编译* 您的合约。我们将使用此选项测试我们的第一个 Solidity 合约。

### 注意

Solidity 编译器使用 C++ 编写，不仅编译为本机代码，还使用 Emscripten 编译为 JavaScript。这使您可以直接在浏览器中编译 Solidity 智能合约。

### 您的第一个 Solidity 合约

我们将从一个非常简单的 Solidity 合约开始（见 3-1）。这个合约将保存一个单一的整数值 myNumber，并提供一个构造函数来设置它的初始值，一个公共函数来增加它的值，以及一个公共 getter 来检索它。pragma solidity ⁰.5.0;contract MyContract {    uint256 private myNumber;    constructor(uint256 initialValue) public {        myNumber = initialValue;    }    function increase(uint256 x) public {        require(x > 0);        myNumber = myNumber + x;    }    function getValue() public view returns (uint256) {        return myNumber;    }}[3-1]

简单的 Solidity 合约，实现一个计数器

让我们来逐步理解这个合约。首先要注意的是 pragma 指令，用于设置与代码相对应的所需 Solidity 编译器版本。不符合所需版本的编译器将拒绝编译文件。特别是 ⁰.5.0 表示以 0.5 开头的任何版本。^(11)

下面是一个合约块，定义了一个要部署的智能合约。合约可以定义多个状态变量，比如例子中的 myNumber，它将保存到 EVM 的存储中。

### 注意

存储在以太虚拟机（EVM）中始终初始化为零。这意味着 Solidity 中的所有状态变量默认都是零。为了防止任何价值数十亿美元的错误，Solidity 没有空值。^(12)

一个合约可以定义多个函数，这些函数将在其上下文中执行，并可以访问其存储。函数必须始终定义其参数类型及其返回类型（如果有）。此外，函数可以具有不同的可见性，取决于它们是否只能在合约内部调用或从外部调用，并且可以限制为不修改合约的存储，例如在示例中的 getValue。可以选择定义构造函数，并在部署合约时运行。

### 注意

Solidity 支持函数重载；这意味着在同一合同中有两个名称相同但参数不同的函数。尽管对于某些场景很有用，但一些客户端库，特别是 JavaScript 中的库，并不总是对其有很好的支持。此外，可以说，重载函数会使代码更难理解，而其他智能合同语言甚至明确决定不支持函数重载。

另一个在这份示例合同中有趣的关键词是 `require`。它允许您检查条件，并在条件不成立时抛出错误（EVM 回滚）。通常用于检查函数的前置条件。

请记住，您的合同对区块链上的所有人都是公开的。这意味着任何攻击者都可以向任何公共函数发送带有任何所需参数的交易。这极大地促使您添加尽可能多的 `require` 语句，以始终验证函数的输入。

在深入研究 Solidity 代码之前，让我们在 Remix 中尝试我们的第一个合同。将 MyContract 的代码复制到 Remix 中新创建的 MyContract.sol 文件选项卡中，并等待其自动编译。然后在 IDE 右侧打开 *Run* 选项卡（见图 3-3）。这将允许您配置要部署合同的环境：选择 *JavaScript VM* 在浏览器中模拟区块链运行代码，并选择提供的 *任何账户*。![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig3_HTML.jpg](img/476252_1_En_3_Fig3_HTML.jpg)

图 3-3

通过 Remix 部署合同

要部署您的合约，请从合约下拉菜单中选择 MyContract，输入要用于我们定义的构造函数的初始值，并接受交易。这将将合约部署到您的浏览器环境中，几乎会立即执行。请记住，在真实的区块链中工作时，部署实际上将需要几秒钟的时间。

您将注意到在中底部面板出现了一个新的日志条目（图 3-4）。其中包含有关执行的交易的详细信息。花些时间仔细阅读并理解列出的所有信息，并参考本章的“交易”部分。![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig4_HTML.jpg](img/476252_1_En_3_Fig4_HTML.jpg)

图 3-4

Remix 控制台中显示的交易详细信息

此外，在集成开发环境（IDE）右侧侧边栏底部，您现在将看到一个名为 MyContract 的实例列在*已部署的合约*部分下，包括其部署的地址。展开它将使您可以访问合约的公共函数：increase 和 getValue。尝试调用它们两个，并使用不同的值来调用 increase，以便玩弄合约并查看生成的交易。

请记住，我们之前在交易和对合约的调用之间进行的区分：前者向整个网络广播一个交易，该交易可能会更改合约的状态或地址的余额，而后者仅查询单个节点以检索值。由于 getValue 被标记为不修改合约的方法（通过 view 关键字），当您执行它时，Remix 会自动对合约发出调用，而不是交易。另一方面，由于 increase 确实改变了合约的状态，所以每次调用它时都会生成一个新的交易。

现在我们将更深入地了解 Solidity。随意将代码示例复制到 Remix 中，部署它们，并与之交互。请记住，如果更改合约的代码，则需要部署其新实例才能与新版本交互，因为已部署的合约无法更改。此外，如果您想详细探讨特定主题，请参阅 Solidity 文档。

### 函数的内部结构

Solidity 中的函数定义具有以下结构：

+   函数名

+   一组类型化的参数

+   可见性修饰符

+   一个支付能力修饰符

+   一组自定义修饰符

+   一组返回值

函数可能如下所示。请注意，函数可以返回多个值，表示为元组。function myFunction(uint256 param1, bool param2)  public payable onlyOwner  returns (uint256, bool);

#### 可见性修饰符

与大多数面向对象的语言一样，Solidity 中的函数可以指定不同的可见性或访问修饰符，以控制函数是否可以从合约外部调用。Solidity 提供了以下四个访问级别：

+   外部

+   公共

+   内部

+   私有

**私有**函数只能在同一合约内部调用。在内部，它们实现为跳转到合约代码的另一部分。这意味着对私有函数的调用不会创建新的作用域，也不会产生相关的调用数据、值、gas 等。相反，它在调用者的相同作用域内执行，这使得调用本身在 gas 使用方面很廉价。**内部**函数的工作方式完全相同，只是它们允许派生合约调用它们（在其他语言中相当于受保护的）。

另一方面，**外部**函数只能从外部帐户或另一个合约中调用。外部函数用于定义合约的暴露接口，并且通常是大多数输入参数检查所在的地方。当一个合约调用另一个合约时，它会进行一个 EVM 调用，这会创建一个新的作用域，具有自己的调用数据、转移值、gas 等等。这比跳转到内部或私有函数更昂贵，但是 EVM 要求如此。请注意，可能会在定义它的同一合约中调用外部函数，但这也需要一个 EVM 调用。

如果你有一个外部函数，你还需要从你的合约内部调用它，你会将它标记为**公共**函数。公共函数是外部和内部之间的混合：它们支持从合约内外部都被调用。编译器足够智能，如果从同一合约内调用该函数，它会使用一个内部廉价的跳转，但是如果从另一个合约调用公共函数，则会创建一个新的 EVM 调用。

请注意，状态变量也有自己的一套可见性修饰符，即 public、internal 和 private，尽管它们的语义略有不同。私有状态变量只能从同一合约内部访问，而内部状态变量不仅可以从同一合约内部访问，还可以从任何派生合约中访问（与函数的情况相同）。然而，当将 public 修饰符应用于状态变量时，它的行为类似于 internal 修饰符，并为具有与状态变量相同名称的隐式 getter 函数定义一个内部修饰符（见列表 3-2）。

使用获取器函数与公共状态变量修改器的示例。在获取器方面，这两个合约是等价的。但有一个注意事项：隐式获取器不能被派生合约覆盖。

#### 支付性修改器

一个函数可以选择性地被定义为可支付的（见列表 3-3）。这告诉 Solidity 当调用该函数时可以接受 ETH。如果尝试向未定义为可支付的函数发送 ETH，编译器将抛出错误。这可以防止意外向未准备处理的合约发送余额，可能将 ETH 锁定在其中。可支付合约 {  function canPay() public payable {  }  function cannotPay() public { }}支付方 {  function pay(Payable p, uint256 eth) public {    // 这种语法用于发送 eth    // 与函数调用一起    p.canPay.value(eth)();    // 这无法编译    p.cannotPay.value(eth)();  }}列表 3-3

Solidity 中的可支付 vs. 非可支付函数

Solidity 还添加了运行时检查，以确保没有余额发送到不可支付的函数。例如，如果尝试从外部帐户向合约的不可支付函数发送 ETH，您将收到一个 revert 错误。

#### 自定义修改器

Solidity 允许您定义自己的函数修改器。这些是在函数之前和之后可以执行的代码块，甚至可以调用其他合约函数、管理存储或根据当前消息做出反应。

通过名为 msg 的上下文变量可以获取有关当前调用的信息，其中包括接收的 ETH 值、调用方地址、提供的 gas、gas 价格等。

修饰符的典型用例是访问控制（见[3-4](https://example.org/PC6)）。 通过在修饰符中定义谁可以调用函数，您可以通过修饰符在多个函数之间轻松重用该逻辑。 合同`OwnerDepositable` {  address public owner;  constructor(address _owner) public {    owner = _owner;  }  modifier onlyOwner {    require(msg.sender == owner);    _;  }  modifier minDeposit(uint256 value) {    require(msg.value > 0);    _;  }  function ownerDeposits()    onlyOwner minDeposit(1 ether) payable public {    // 这里我们知道发送者是所有者，    // 并且已经转移了至少 1 ETH   }}[3-4]

使用自定义修饰符进行访问控制

修饰符使用`modifier`关键字定义，并通过下划线将调用委托给原始函数。 然后，在函数定义中通过名称列出它们应用于一个函数。 修饰符甚至可以接受参数，当应用于函数时必须提供这些参数。

#### 回退函数

合同可以定义一个没有名称的函数。 这个函数被称为*回退函数*，如果合同收到一个与任何其他函数不匹配的调用，则会调用它。

尽管它们可以在合同中用作通用函数，但回退函数的主要用例是处理纯粹的以太币转账（见[3-5](https://example.org/PC7)）。 当您向合同地址转账资金时，通常不在交易数据中包含任何内容。 回退函数允许合同对该转账做出响应，或者对转账本身进行检查。合同`NotCheap` {  function() external payable {    require(msg.value >= 1 ether);  }}[3-5]

使用回退函数防止合同接受低于 1 ETH 的转账

请注意，当使用 Solidity 代码从转移资金时，transfer 方法仅会分配很小的 gas 补贴。这是出于安全原因，以防止在转移资金时发生重入攻击。这意味着回退函数应只执行非常简单的检查或操作，否则在接收 ETH 时可能会耗尽 gas，从而导致转账交易失败。甚至对存储的写入都比普通转账中可用的 gas 补贴更昂贵。

### 警告

回退函数还需要表明合约是否能够接收以太币。如果合约没有定义可付款的回退函数，那么不能向其发送纯以太币转账。这可以防止意外向无法处理资金的合约发送资金，从而锁定资金。

### 值数据类型

Solidity 支持传统的基本数据类型，例如 bool 或 uint，以及一些更复杂的数据类型，例如数组、映射或结构。我们将从最简单的数据类型开始：值类型（见列表 3-6）。pragma solidity ⁰.5.0;contract MyContract {  bool private myFlag;  uint256 private myUnsignedNumber;  int256 private mySignedNumber;  address private myAddress;}列表 3-6

合约中值数据类型的概述

#### 布尔值和相等性

布尔字面值由关键字 true 和 false 表示。通常的逻辑操作可用，使用相同的符号，并具有与 javascript 相同的短路语义：

+   否定 !x

+   且 x && y

+   或 x || y

另一方面，相等比较运算符==和!=实际上的行为与 javascript 的===和!==相同。当比较时，Solidity 不会强制转换类型，并且在尝试比较两种不同类型的对象时会抛出编译器错误。这对于所有数据类型都适用，不仅仅是布尔值。

#### 整数和算术

整数类型可以是有符号的，也可以是无符号的，可以定义不同大小的类型，从 8 到 256 位，步长为 8。通常的算术、移位和按位操作都可用，以及比较运算符：

+   uint8、uint16、uint24、...、uint256 是无符号整数类型。

+   int8、int16、int24、...、int256 是有符号整数类型。

由于整数类型通常用于在智能合约中表示*值*，无符号整数比有符号整数更常见。此外，由于不支持固定或浮点值（完全），因此通常使用带有固定小数位数的整数表示所有值。这对于以太坊余额特别真实，它们始终用*wei*来表示，这是以太坊的最小可分割单位：1e18 wei 等于 1 ETH。Solidity 甚至提供了后缀来使用这些单位：文字量 1 ether 实际上是整数值 1e18。还有用于处理时间值的后缀，如分钟、小时、天和周。在这些情况下，基本单位是秒，因此 3 分钟被编译为整数值 180。

警告：Solidity 中的所有整数算术操作都是不受检查的；这意味着可能会发生悄悄溢出。这在处理与值相关的无符号数时尤为危险。例如，意外地将表示某人余额的变量减少到零以下实际上会将该值变为几乎为 2^(²⁵⁵)。因此，强烈建议始终使用 SafeMath^(13)（清单 3-7），这是 OpenZeppelin 框架提供的一个库，它为每个算术操作添加了溢出检查（有关导入和库的更多信息，请参见后文）。import "openzeppelin-solidity/contracts/math/SafeMath.sol";contract MyContract {  using SafeMath for uint256;  uint256 private myNumber;  function unsafeDecrease(uint256 x) {    // 如果 x > myNumber，则 myNumber 将悄悄地回绕    myNumber = myNumber - x;  }  function safeDecrease(uint256 x) {    // 如果 x > myNumber，则会抛出错误    myNumber = myNumber.sub(x);  }}清单 3-7

算术运算的 SafeMath 用法示例

我们将在本章后面介绍如何使用导入和库。现在，请记住，在 Solidity 中直接使用算术运算符，而不经过 SafeMath，是一种潜在的安全风险。

#### 固定大小字节

Solidity 还提供了多达 32 字节的固定大小字节字符串，形式为 bytes1、bytes2、...、bytes32 数据类型。由于它们都适合于 EVM 字，它们也都被视为值类型，并且行为类似于整数类型，只是它们不提供任何算术函数。它们支持比较、位和移位运算符，以及一个索引访问运算符，用于从数组中检索单个字节。bytes32 data;uint8 index;byte firstByte = data[0];

这些类型通常用于存储哈希或标识符，其中数值本身并不重要。例如，预编译的哈希函数如 sha256 或 ripemd160 分别返回 bytes32 和 bytes20。

#### 地址、合同和转账

地址数据类型表示任何以太坊地址。虽然任何至少有 160 位的整数或字节类型都可以用来存储地址，但 Solidity 特别提供了这种类型来处理它们。地址还具有用于检查 ETH 余额以及转移资金的特定属性。

Solidity 将地址区分为两种不同类型：address 和 address payable。它们的基础表示相同，不同之处在于只有后者提供了用于向其发送 ETH 的 transfer 方法。这使得您可以依靠类型系统来决定哪些地址应该被允许从您的合同中接收资金。不可付款地址只提供余额属性来查询其 ETH 余额。

下面这份相当无聊的合同（见列表 3-8）跟踪了创建合同的所有者，并提供了一个将资金转发给他们的单一功能。合同 MyContract {  address payable private owner;  address private lastContributor;  constructor(address payable _owner) public {    owner = _owner;  }  function forward() public payable {    uint256 ethReceived = msg.value;    require(ethReceived > 0);    lastContributor = msg.sender;    owner.transfer(ethReceived);  }}列表 3-8

使用地址数据类型的示例合同

请注意，所有者地址需要存储为地址支付类型；否则，当尝试编译 owner.transfer(ethReceived) 时，编译器会抛出错误。另一方面，lastContributor 可以是普通地址，因为它永远不会从合同中接收 ETH。

### 注意

Solidity 还提供了另一个用于发送 ETH 的函数，即 send。两者之间的区别在于 send 返回一个布尔值，指示 ETH 转账是否成功，并且 transfer 在失败时抛出 REVERT。为了避免由于忘记检查 send 返回值而引起的错误，建议始终使用 transfer。

在 Solidity 中定义的任何合约也可以用作类型（见列表 3-9）。合约实例具有合约中定义的所有公共函数。合约提供者 {  function answer() public pure returns (uint256) {    return 42;  }}合约调用者 {  function fetchAnswer(Provider provider) public {    uint256 answer = provider.answer();    // 对答案进行操作  }}列表 3-9

从 Solidity 调用合约的公共函数

在内部，合约实例存储为其地址，因此合约可以转换为地址类型并从地址类型进行转换。当尝试检查合约的余额或向其转移资金时，这很有用，因为只有地址类型提供了余额和转移方法。function sendFunds(MyContract recipient) {  recipient.transfer(1 eth); // 编译错误  address(recipient).transfer(1 eth); // ok!}合约类型也可以用于部署合约的新实例（见列表 3-10）。您可以利用这一点创建类似工厂的合约，用于设置和创建其他合约。合约 Box {  uint256 public value;  constructor (uint256 _value) public {    value = _value;  }}合约工厂 {  function create(uint256 _value) public returns (Box) {    return new Box(_value);  }}列表 3-10

从 Solidity 创建合约

与许多其他语言一样，Solidity 也提供了一个代表当前合约的关键字 this。this 的类型是合约本身。function forward(address payable beneficiary) public {  uint256 myBalance = address(this).balance;  beneficiary.transfer(myBalance);}

### 引用类型

Solidity 中的*引用类型*包括数组、字符串、映射和结构体。与值类型不同，赋值或将引用类型作为参数传递时，通常会传递指向可以在另一个函数中别名或修改的对象的句柄。我们将研究这是如何与最常见的引用类型——数组一起工作的。

#### 数组、字节和字符串

Solidity 支持固定大小和动态数组。数组类型是参数化的，这意味着它们被定义为基本类型的数组。这使您可以定义动态整数数组，如 uint256[]，或固定大小地址数组，如 address[4]。您甚至可以使用数组的数组，但请记住，在 Solidity 中，符号的表示与其他语言相比是相反的：bool[][4] 是一个包含四个动态数组的固定大小数组。此外，您不能在外部函数调用中返回数组的数组。

数组有一个 length 方法来查询它们的大小，并提供一个索引运算符来访问或修改数组中的位置。动态数组还具有 push 和 pop 方法来添加或删除元素。在 Solidity 中，通常使用 for 循环来迭代数组（参见 3-11）。

对于向数组追加元素并迭代它们的示例代码，请注意该示例可能存在算术溢出，因为它没有使用 SafeMath 来计算数组元素的总和。

### 警告

对无界数组使用 for 循环是有风险的，因为它可能消耗任意数量的 gas，潜在地超过一个区块的限制，使函数无法调用。始终避免循环遍历可能无限增长的数组，或者至少提供按可控大小批次迭代它的方法。

请记住数组是引用类型而不是值类型。引用类型包含，正如其名称所示，指向对象的引用而不是实际值。这意味着，根据上下文，将数组变量分配给另一个变量不会创建副本，而是将对相同数组的引用传递给另一个。

数组是复制还是传递引用取决于*数据位置*。数据位置可能是一个令人困惑的概念，因为它在其他语言中没有直接等价物，并且是来自 EVM 的抽象泄漏。Solidity 选择将这种区别暴露出来，并迫使程序员意识到这个重要的实现细节，而不是试图隐藏它并导致潜在的令人惊讶的结果。

正如我们之前提到的，每个合约都可以访问一个内部存储，用于持久化数据。由于这个空间使用起来非常昂贵，EVM 提供了一个用于临时操作的内存堆。这正是 Solidity 定义的两个主要数据位置：存储和内存。第三个位置是 calldata，它指的是事务中提供数据的空间。在实际应用中，calldata 的工作方式与内存完全相同，唯一的区别是它是不可变的。

对于每个引用类型的局部变量或函数参数，都需要指定数据位置。唯一不需要数据位置的情况是声明合约状态变量时，因为这些变量始终保留在存储中。请注意，在为函数参数指定位置时，您需要遵循以下规则：

+   外部函数只能接受 calldata 引用类型。

+   公共函数只能接受内存引用类型。

+   内部或私有函数只能接受内存或存储引用类型。

赋值语义取决于引用类型的位置（见 3-12 列表）。从一个内存引用到另一个的赋值只会传递对同一对象的引用，当从存储引用赋值到另一个引用时也是一样。然而，当从内存引用赋值到存储引用时，Solidity 将**复制**整个内存数组到存储中。合约数据位置 {  uint256[] public storageArray;  function test(uint256[] memory memoryArray) public {  // 我们把 memoryArray 命名为 localMemory  uint256[] memory localMemory = memoryArray;  localMemory[0] = 42;  require(localMemory[0] == memoryArray[0]);  // 我们把 memoryArray 复制到 storageArray  storageArray = memoryArray;  require(storageArray[0] == 42);  // 我们把 storageArray 命名为 localStorage  uint256[] storage localStorage = storageArray;  localStorage[0] = 21;  require(localStorage[0] == storageArray[0]);  // 对 storageArray 的更改不会影响原始 memoryArray  require(storageArray[0] != memoryArray[0]);  }}列表 3-12

演示内存和存储位置修饰符在 Solidity 中的工作方式

数组的一个特殊情况是 bytes ，它的行为与 byte[]（即 byte 的动态数组）完全相同。然而，这种类型经过优化并严密打包在内存或存储中，因此应始终优先使用它而不是 byte[]。

另一个特殊情况是字符串。字符串是不可变的 UTF-8 编码的字节数组，不允许按索引访问。字符串字面量使用双引号定义。请记住，Solidity 几乎没有字符串操作函数，因此字符串大多以不可变的标识符或描述存储。字符串 myString = "foo";

与值类型不同，当数组状态变量被定义为 public 时，Solidity 生成的隐式获取器接受索引参数，以确定要检索数组中的哪个项目。这仅适用于常规动态数组：字节和字符串在单个调用中返回。

作为例子，给定以下带有公共动态数组、字符串和字节的合同，以下获取器（图 3-5）可用：合同 PublicArrays {    uint256[] public numbers = [20,30,40];    string public text = "foo";    bytes public data = hex"20";}![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig5_HTML.jpg](img/476252_1_En_3_Fig5_HTML.jpg)

图 3-5

使用需要索引的获取器访问公共动态数组 vs. 获取字符串或字节变量

#### 映射

映射，在其他语言中也称为哈希表或字典，是 Solidity 中的关联引用类型。

像数组一样，它们是参数化的，因为它们包含来自其他类型的元素。映射从键到值，它们接受任何值类型（加上字节或字符串）作为键，并可以处理任何类型的值（包括其他映射）。然而，与数组不同，映射的唯一有效位置是存储，而不是内存或调用数据。

### 注意

在幕后，映射是依赖于合同的存储空间足够大以确保两个不同键不会发生碰撞的哈希表，因此它们保证了对值的访问始终是常量时间的。

自动创建的映射的公共 getter 方法（见列表 3-13）与数组的类似，只是它们不接受索引，而是接受一个键（见图 3-6）。对于嵌套映射，嵌套映射的 getter 方法将需要为每个嵌套级别的每个键提供一个参数，并且只返回最内层的值。contract PublicMappings {  mapping(uint256 => string)    public num2str;  mapping(uint256 => mapping(uint256 => string))    public num2num2str;  constructor() public {    num2str[10] = "foo";    num2num2str[10][20] = "bar";  }}列表 3-13

自动创建的两个映射的样本合约，带有自动生成的 getter 方法：一个简单的映射和一个嵌套的映射。

![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig6_HTML.jpg](img/476252_1_En_3_Fig6_HTML.jpg)

图 3-6

从嵌套映射获取值需要为每个嵌套级别的每个键提供一个值。

Solidity 中关于映射的一个重要注意事项是，与其他语言不同，没有办法迭代映射中存在的键或值。这与映射的实现方式有关。如果你确实需要跟踪插入映射的键，你将需要保留一个单独的数组来存储它们。

#### 结构体

Solidity 中的最后一种引用类型是结构体（见列表 3-14）。与 C 语言类似，结构体充当其他类型字段的命名集合。contract HasStruct {  struct MyStruct {    uint256 number;    string text;  }  mapping(uint256 => MyStruct) structs;  constructor() public {    structs[10] = MyStruct(20, "foo");  }  function getStruct(    uint256 key  ) public view returns (uint256, string memory) {    MyStruct storage s = structs[key];    return (s.number, s.text);  }}列表 3-14

在 Solidity 合约中使用结构体的示例用法。

结构体是可变的，可以存储在映射或数组中，它们可以包含其他结构体或引用类型作为自己的字段。请记住，与任何其他 Solidity 类型一样，结构体被初始化为零，因此空结构体是每个字段都为零的结构体。

### 发出事件

Solidity 提供了一种对事务日志进行抽象的机制，称为 *事件*。Solidity 事件由名称标识，并可以具有多个参数来提供附加数据（见 3-15）。由于它们被实现为日志，因此 Solidity 事件只能被发出，而不能从智能合约中观察到。我们将在后面学习如何从客户端监视或查询事件。contract EmitsEvents {  mapping(string => uint256) private counters;  event CounterIncreased    (string indexed key, uint256 newValue);  function increase(string memory key) public {    counters[key] += 1;    emit CounterIncreased(key, counters[key]);  }}Listing 3-15

每次调用 increase 函数时都会发出事件的智能合约

使用 event 关键字声明事件，并使用 emit 触发。请注意，在事件声明中，可以将其某些参数标记为索引。这些允许观察或查询具有该参数的特定值的事件。是否将参数标记为索引取决于您的使用情况。

### 注意

由于 EVM 的限制，索引变量长度参数不是使用其实际值存储的，而是使用该值的哈希。这意味着，在此示例中，您将能够在所有 CounterIncreased 事件中搜索特定键，但您将无法从给定事件中检索实际键。

事件不仅用于监视合同的变化，还可以作为交易中返回值的替代。由于客户端无法从在交易中调用的方法中检索返回值，因此通常会发出带有需要获取的值的事件。然后，客户端检索附加到交易收据的事件，并从中提取值。

### 导入、继承和库

Solidity 文件可以导入其他文件（见列表 3-16）。导入语句类似于 javascript 的 require，在当前文件中从另一个文件中获取声明。在 Solidity 中，由于唯一的顶级对象是合同（加上库和接口，我们一会儿会看到），导入允许您引用在另一个文件中定义的合同。// Callee.sol 合约 Callee {  function f() external;}// MyContract.solimport "./Callee.sol";合约 MyContract {  function call(Callee c) public {    c.f();  }}列表 3-16

使用导入语句加载另一个文件中定义的合同的示例用法

在上面的示例中，MyContract 通过导入定义它的文件来获取 Callee 的定义。注意，Callee 没有定义函数 f 的实现，因此实际上它是一个抽象合约。由于这足以让 MyContract 知道如何调用 Callee 的实例，因此这些文件可以成功编译。此外，由于我们仅使用 Callee 作为接口定义，因此我们可以使用 interface 关键字重新定义合约：// Callee.sol 接口 Callee {  function f() external;}

### 注意

当从依赖项中导入代码时，通常作为 npm 包，导入语句指的是包名。具体的语法因使用的构建工具而异，但通常遵循以下模式 `import "package-name/contracts/Contract.sol"`。

一个文件不仅可以被导入以引用另一个合约，还可以从中扩展。Solidity 支持多重继承。这使得继承成为扩展功能或从另一个合约中引入功能的默认机制，使用基础合约就像它们是混合物一样（见列表 3-17）。

派生合约可以访问基础合约的内部和公共方法，以及所有结构体、修饰符和事件定义。它们还可以覆盖基础合约中的方法。contract Timelocked {  uint256 internal locktime;  modifier whenNotLocked() {    require(now > locktime);    _;  }}contract Ownable {  address internal owner;  modifier onlyOwner() {    require(msg.sender == owner);    _;  }}contract MyContract is Timelocked, Ownable {  constructor(uint256 _locktime) public {    locktime = _locktime;    owner = msg.sender;  }  function f() whenNotLocked onlyOwner public {    // 只有在所有者调用时可达    // 并且合同未锁定  }}列表 3-17

典型的基础合约模式提供行为或方面，类似于合同中包含的混合物。这些基础合约定义了它们自己的状态，并提供了修饰符或内部函数，供派生合约利用。

最后但同样重要的是，Solidity 允许定义*库*，这些库是辅助函数的模块，可以选择性地应用于特定数据类型（见列表 3-18）。根据它们的函数是内部定义还是不是，库实际上会内联到包含它们的合同中或者单独部署并链接。一个好的库示例是前面提到的 SafeMath，它定义了带有溢出检查的简单算术运算。// openzeppelin-solidity SafeMath.sol 代码片段库 SafeMath {  function add(uint256 a, uint256 b)    internal pure returns (uint256) {      uint256 c = a + b;      require(c >= a);      return c;  }}// MyContract.solimport "openzeppelin-solidity/contracts/math/SafeMath.sol";contract MyContract {    uint256 value;    function increase(uint256 x) public {        value = SafeMath.add(value, x);    }}列表 3-18

在合同中使用 SafeMath 的示例用法

由于库经常定义某种数据类型（例如 SafeMath 中的 uint256），因此 Solidity 提供了一种方便的 using 语句（见列表 3-19），该语句将库的所有方法添加到指定类型的所有变量中。当与结构体结合使用时，这尤其强大，因为它允许我们定义具有自己一套函数的自定义数据类型。contract MyContract {    using SafeMath for uint256;    uint256 value;    function increase(uint256 x) public {        value = value.add(x);    }}列表 3-19

以 using 语句重写的先前示例，该语句将库中的所有方法添加到合同范围内的类型中

## 知名智能合约

结束智能合约这一章节时，我们将回顾两个最著名的合约标准，即 ERC20 和 ERC721。它们分别对应可互换和不可互换的代币。但是，在深入研究它们之前，我们将首先介绍一个超越 Solidity 语言的概念：ABI。

### 应用程序二进制接口

合约的应用程序二进制接口（ABI）是由合约公开的一组方法。可以将其视为其公共 API，可以从外部帐户或另一个合约调用。

ABI 背后的关键概念是它与编程语言无关。它规定了如何对函数调用、参数和返回值进行编码的规范。这使得用 Solidity 编写的合约能够与用其他高级语言（如 Vyper）编写的合约无缝交互。

ABI 具有与 Solidity 非常接近的一组数据类型，包括地址、整数（有符号和无符号）、布尔值、字符串、数组等。主要的例外是合约类型，它们作为普通地址处理，以及结构体，它们编码为具有所有字段的元组。

### EIP 和 ERC

作为去中心化协议，所有对以太坊的改进通常都以提案（或 EIP，以太坊改进提案）的形式开始，由社区讨论。这些提案从核心协议本身的变更到为了兼容性而定义的应用级标准，涵盖广泛。

Ethereum Request for Comments（或 ERC，遵循 Internet Engineering Task Force 使用的 RFC 命名约定）通常简称为后者。它们至关重要，因为它们定义了要使用的合约的通用 ABI 和语义。它们作为更大应用的构建块，并通过设定社区共同接口来促进可重用性。

两种最流行的智能合约标准，即可互换和非可互换代币，分别定义为 ERC – ERC20 和 ERC721。

### ERC20 代币

ERC20 标准定义的代币，^(14)可能是以太坊应用程序中最常见的构建块。在其核心，ERC20 合约为每个代币持有者地址记录余额，并提供查询和管理这些余额的方法（清单 3-20）。

一个代币可以作为任何项目的去中心化货币。因此，任何团队都可以轻松在以太坊网络上推出自己的加密货币，而无需设置自己的区块链。

然而，代币除了货币之外还有更多用途。代币的用途由其所使用的协议赋予：它可以用于表示对特定项目的担保，或者在去中心化组织中的投票权。如今许多项目都依赖于一个（或有时是多个）ERC20 代币。

ERC20 标准的完整接口

要理解 ERC20 代币的第一步是窥视其状态。可替换代币由用户到余额的映射支持，这由 balanceOf getter 公开。  function balanceOf(address who)    external view returns (uint256); 通过调用 transfer 来修改余额。用户可以选择将其一定数量的代币转移到另一个地址 - 可以是合约或外部账户。每当调用此方法时，都会发出 Transfer 事件以记录该操作。  function transfer(address to, uint256 value)    external returns (bool); 除了余额转移的基本行为外，还有 *津贴* 的概念。用户可以批准任何地址代表他们管理一定数量的代币。可以通过 allow getter 查询代币津贴的状态。  function allowance(address owner, address spender)    external view returns (uint256); 要为地址设置津贴，合约提供了 approve 方法，在调用时需要发出 Approval 事件。请注意，用户可以为任意高的代币数量设置批准 - 无论他们是否拥有它们。  function approve(address spender, uint256 value)    external returns (bool); 当 spender 账户转移所有者的代币时，将消耗津贴。如果地址 A 已经允许地址 B 代表其花费最多 20 个代币，那么在 B 转移了 A 的 5 个代币后，剩余的津贴将是 15。代表另一个用户转移代币是通过 transferFrom 方法完成的，这将影响余额和津贴。  function transferFrom(    address from, address to, uint256 value  ) external returns (bool);

此外，标准还包括三个可选的获取器：name、symbol 和 decimals。这些通常由钱包或其他客户端软件使用，根据其地址显示有关代币的信息。

该标准未指定如何最初分配代币或代币的总供应量如何随时间演变。 某些代币在创建时具有固定的供应量，并分配给单个地址，该地址手动分配它们。 其他代币可以随时间铸造并根据某些规则分配。

### 提示

您可以从 OpenZeppelin 合约包中获取 ERC20 标准的规范和经过审计的实现，^(15) 因此您不需要自行实现。

### ERC721 非同质化代币

ERC721 标准（列表 3-21）定义了数字收藏品的规范，也称为非同质化代币（通常缩写为 NFT）。 NFT 与传统的 ERC20 代币不同，每个代币都是可识别且与其他代币不同的。 因此，用户不再拥有一定数量的代币，而是拥有一组特定的唯一可识别代币，每个代币都有其自身的元数据。 类比而言，如果 ERC20 代币可用于表示货币，那么 ERC721 代币可用于表示可收集的卡片。

ERC721 的接口受到 ERC20 的重大启发，区别在于所有操作都针对可识别的代币而不是余额。ERC721 还在 ERC20 的基础上引入了一些补充，现在我们将进行审查。

ERC721 标准的接口

查询地址持有的代币数量以及查询特定代币是否属于地址的第一个方法非常简单。

在整个标准中，代币由不透明的 uint256 值标识。虽然一些实现使用递增数字作为 ID，但这并不是必需的。

请注意，标准并没有提供任何列出现有代币或属于用户的代币的方式。为了解决这个问题，有一个可选的扩展（见列表 3-22）提供了方法来枚举所有现有的代币，以及特定用户的代币。  函数 `totalSupply()`    public view returns (uint256);  函数 `tokenOfOwnerByIndex`    (address owner, uint256 index)    public view returns (uint256 tokenId);  函数 `tokenByIndex(uint256 index)`    public view returns (uint256);列表 3-22

ERC721Enumerable 可选扩展

为了避免返回一个包含所有已创建代币或属于用户的所有代币的任意大数组，此 Enumerable 扩展提供了一种方法来知道代币的总数（或属于用户的代币的数量）并通过索引迭代它们。

类似于 ERC20，ERC721 也有授权（allowances）的概念，尽管管理方式略有不同。ERC721 允许所有者为其每个代币单独指定一个或多个支出者，并同时为代表他们管理所有代币的一个或多个地址。后者有时被称为*操作者*。这两个概念——对特定代币或所有代币的批准——通过以下方法查询和设置，并通过 Approval 和 ApprovalForAll 事件反映。  function approve(address to, uint256 tokenId)    public;  function getApproved(uint256 tokenId)    public view returns (address operator);  function setApprovalForAll    (address operator, bool _approved)    public;  function isApprovedForAll    (address owner, address operator)    public view returns (bool);ERC721 不包括转账方法。相反，所有代币转账都必须通过 transferFrom 处理，该方法要求支出者不仅指定要转移的代币和目的地，还要指定当前所有者。如果当前所有者与 from 参数不匹配，则拒绝转移。  function transferFrom    (address from, address to, uint256 tokenId)    public;此标准包括另外两种管理转账的方法：  function safeTransferFrom    (address from, address to, uint256 tokenId)    public;  function safeTransferFrom    (address from, address to, uint256 tokenId, bytes data)    public;安全转账方法检查代币的接收方是否实际上可以管理它们，通过调用接收方中指定的 onERC721Received 方法来实现（图 3-7）。如果接收方未实现此方法，则转账将中止。这可以防止将代币意外丢失，因为将其发送到无法管理它们的合约中，从而永久锁定它们，这是 ERC20 中的一个常见问题。因此，建议始终优先使用这种方法，而不是普通的 transferFrom。![../images/476252_1_En_3_Chapter/476252_1_En_3_Fig7_HTML.png](img/476252_1_En_3_Fig7_HTML.png)

图 3-7

ERC721 安全转移的执行流程

这种方法的另一种重载包括额外的数据参数。这些数据会在 onERC721Received 调用时转发，并且接收者可以使用它来决定是否接受要转移的令牌。

ERC721 的另一个部分是实现 ERC165 的要求（见列表 3-23）。ERC165 提供了一种标准的查询方式，用于查询合约是否实现了一个接口。这允许用户或其他合约在尝试调用它之前实际上检查任何给定地址是否响应某个方法。在 ERC721 的上下文中，这意味着您实际上可以*询问*一个地址是否是 ERC721 合约。然而，请记住，实际实现是否正确或恶意是一个完全不同的话题。  function supportsInterface(bytes4 interfaceId)    external view returns (bool);列表 3-23

ERC165 的接口。interfaceId 是每个标准的已知标识符集，通常由公共函数签名的哈希组成

ERC721 的最后一个组件是用于元数据的可选扩展（见列表 3-24）。该扩展不仅包括了在 ERC20 中也存在的名称和符号获取器（请注意，在此情况下，小数点在这个上下文中没有意义，因为非同质化代币是不可分割的），而且还包括了一种获取任何给定令牌的元数据信息的方法。  function name() external view returns (string);  function symbol() external view returns (string);  function tokenURI(uint256 tokenId)    public view returns (string);列表 3-24

ERC721 的元数据可选扩展

尽管 tokenURI 的格式未定义，而是留给实现者选择，^(16) 但它提供了一种标准的方式来获取有关特定令牌实例的信息，例如描述其的图像或一小段文本。Token URI 通常指向包含令牌清单的链下^(17) 资源。

## 摘要

在本章节中，我们介绍了智能合约是什么，以及它由代码和状态组成，区别于外部拥有的账户。我们回顾了交易是什么，它的生命周期以及它与智能合约的交互方式，潜在地修改它的状态——与静态调用相反，用于查询而不更改合约。我们还介绍了一些概念，如燃气使用和价格，这对于向网络发出交易的客户特别重要。

我们还学习了 Solidity 作为一种用于编写智能合约的高级编程语言。Solidity 的基本单位是合约，它由状态变量和函数组成，这些函数可以用修饰符修饰，并且可能会发出事件。Solidity 合约可以从多个其他合约继承，或者包含库，作为模块化代码的手段。这个介绍远远没有涵盖所有 Solidity 概念，也忽略了在开发生产级别智能合约代码时至关重要的几个安全见解，但足以让您理解智能合约并能够编写小型系统。

最后，我们回顾了智能合约中两个最广泛使用的构建模块——在 ERC20 和 ERC721 中定义的代币。分别涵盖可互换的代币和数字收藏品，并且大多数应用程序都在其中之一（或两者）上运行。

总的来说，本章的主要目标不是让您成为智能合约开发的专家，而是理解在开发由这些合约支持的 Web 应用程序时会有用的关键概念。
