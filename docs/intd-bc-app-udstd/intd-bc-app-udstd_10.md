© 作者（们），在 Springer Nature 的 APress Media，LLC 独家许可下 2022J. T. George 引入区块链应用[`doi.org/10.1007/978-1-4842-7480-4_10`](https://doi.org/10.1007/978-1-4842-7480-4_10)

# 10. 实时系统中的调度

Joseph Thachil George^(1  )（1）意大利罗马任务状态确定了进程中任务的里程碑。默认状态如下：

+   作业已被接收，正在等待在系统中被接受。

+   任务已被分配的用户（或系统）接受。其他用户和系统无法修改或完成工作，因为它被锁定了。

+   任务已完成。

+   用户已分配到作业。（仅限手动任务。）

+   任务尝试在激活系统中生成工作订单，但未成功。（仅限激活任务。）

这些条件必须满足且不能更改。为支持您的业务流程，您可以定义额外的状态（用户定义的状态）。如果任务无法按时完成，您可以将任务的状态设置为挂起。

在没有其他操作的情况下，处理器执行一系列指令，直到它们完成。任务是一系列实例（作业）的序列。![../images/520777_1_En_10_Chapter/520777_1_En_10_Fig1_HTML.jpg](img/520777_1_En_10_Fig1_HTML.jpg)

图 10-1

状态偶数

准备好的作业保存在一个称为等待列表（QUEUE）的队列中。调度算法是选择在 CPU 上运行任务的方法。

## 10.1 调度概念

进程由调度算法组成：

+   **抢占式：** 工作可以被暂停一小段时间，以完成更重要的任务。

+   **非抢占式：** 任务不能被中断。调度是将任务按照一定顺序分配给处理器的列表。处理器的进程是已分配给它们的任务集合。

![../images/520777_1_En_10_Chapter/520777_1_En_10_Fig2_HTML.jpg](img/520777_1_En_10_Fig2_HTML.jpg)

图 10-2

状态转换和就绪队列

在具有严重实时限制的应用中，进程可能需要被交换或分页到辅助存储器中。

当操作系统同时运行多个程序时，称为*多任务*。重要的是要区分“作为指令容器”的程序和“正在进行中”的程序之间的区别。正在运行的程序称为进程（或任务）。

因此，虽然*程序*是描述要执行的操作的静态实体，但*进程*是表示执行这些操作的动态实体。操作系统采用的执行多个进程“并行”（并发进程）的机制称为*时间共享* 。

它包括将 CPU 分配给称为时间片的时间片段，该时间片段为每个进程设置。当时间片段到期时，进程的执行被暂停，并且 CPU 被分配给另一个进程。这种技术称为*抢占式多任务* 。

多任务系统中最重要的问题是分配各种进程所需的资源。事实上，可能发生多个进程同时请求无法共享的特定单一资源的情况（例如打印机）。在这种情况下，进程请求者立即被挂起，并且请求进程被放置在等待队列中。只有当资源被释放且队列中没有其他进程先于它时，才能获取该资源并恢复执行。

另一个问题涉及对外设的访问。因为设备 I/O 操作与处理器速度相比非常慢，进程对 I/O 操作的请求会导致进程挂起，直到操作完成（明显涉及的硬件机制是中断）。

一个进程可以处于以下三种状态之一：

+   运行。进程具有 CPU 并正在运行（就绪）。

+   进程因时间到期而暂停。

+   阻塞（阻塞，等待，暂停）。进程无法前进，因为它需要一个尚未可用的资源，或者因为它正在等待 I/O。

管理就绪作业是通过一组具有定义优先级的队列实现的。每个进程被分配一个优先级，以便当进程进入就绪状态时，它将被放置在具有相应优先级的队列中。

运行的进程是队列中的第一个。如果队列中没有等待的作业，则执行队列中的第一个作业，依此类推。

## 10.2 约束类型

过渡限制防止数据由于先前状态而进入不可能状态。例如，一个人不应该能够从“已婚”转变为“单身，从未结婚过”。在“已婚”之后，“离婚”，“丧偶”或“死亡”是唯一允许的状态。![../images/520777_1_En_10_Chapter/520777_1_En_10_Fig3_HTML.jpg](img/520777_1_En_10_Fig3_HTML.jpg)

图 10-3

任务处理器

过渡约束是指每个合法过渡的特征，从模型的一个状态到其后继状态在信息安全的形式模型中。它可以被看作是状态标准的补充，它适用于整体状态但不影响它们之间的过渡。

一旦其目标地址已被写入二级存储，并且它不在等待特定任务，该进程就是可执行的并且可切换的。如果一个进程正在等待任务，则它会被置于休眠状态，并且其整个地址空间被写入二级存储。

关于约束的注意事项如下：

+   类型包括抖动、触发、完整性和截止日期。

+   它们可以是显式的（包含在系统活动规范中）或隐式的（不包含在系统活动规范中）。

+   他们对资源的执行限制施加了逻辑顺序。

+   它们确保对互斥资源的访问是同步的。

![../images/520777_1_En_10_Chapter/520777_1_En_10_Fig4_HTML.jpg](img/520777_1_En_10_Fig4_HTML.jpg)

图 10-4

实时任务

![../images/520777_1_En_10_Chapter/520777_1_En_10_Fig5_HTML.jpg](img/520777_1_En_10_Fig5_HTML.jpg)

图 10-5

任务激活

### 10.2.1 独立任务调度约束

此类别假设任务没有任何依赖关系（例如互斥）。

*速率单调算法*是一种基于静态优先级的动态算法，具有抢占功能，具有以下假设：

1.  1.

    属于具有硬实时约束的特定任务集合的所有任务的请求都是周期性的。

1.  2.

    所有任务都是独立的（没有互斥或依赖关系）。

1.  3.

    每个任务的到期时间（Ti）对应其周期的持续时间（pi）。

1.  4.

    你事先知道每个任务的最大计算时间。

1.  5.

    上下文切换时间被忽略。

1.  6.

    *n*个任务的利用率因子之和在顶部受到限制：

![$$ \mu =\sum \frac{c_i}{p_i}\le n\;\left({2}^{\frac{1}{n}}-1\right) $$](img/520777_1_En_10_Chapter_TeX_Equa.png)

Where:

c[i] = 第 i 个任务的计算时间

p[i] = 第 i 个任务的周期持续时间

该算法静态地分配优先级，并基于任务周期的持续时间。周期较短的任务优先级较高，周期较长的任务优先级较低。因此，在执行阶段，每次都会选择周期最短的任务。

使用*最早截止期限优先算法*，选择最早过期的算法。使用*最小松弛度算法*，根据截止期限和任务所需计算时间之间的差异来计算任务优先级。这个值越低，任务的优先级就越高！$$ {laxity}_i={d}_i-{c}_i $$

### 10.2.2 调度相关任务

在这个更接近现实且因此更有趣的类别中，我们假设任务具有依赖关系（例如互斥）。

*核化监视器算法*，由 Mok [2] 提出，为非可中断时间*q*分配处理器，并假设关键部分可在时间限制内执行。最早的策略用于首先安排截止期限。

该协议中进行的调度分析需要对任务中出现的所有关键部分的执行时间上界进行使用。实际上，该数量必须根据最长可执行的关键部分进行校准。由于这些上界可能太悲观，使用协议核化监视器可能导致处理器利用率低。

*优先级天花板协议*用于安排周期性的任务集，这些任务集具有对由信号灯保护的一个或多个公共资源的独占访问权限。

这个协议是由 Sha、Rajkmar 和 Lehocky 于 1990 年创建的，旨在解决*优先级反转*问题。这种情况发生在高优先级作业必须等待更高优先级作业执行时，通常是因为正在运行的任务使用了其他资源。

如果有三个任务（T1、T2 和 T3）的优先级 p1> p2> p3，所有三个任务都使用资源 R 和用于调度单调速率类型的算法。

假设 T1 和 T3 需要访问与互斥量 S 相关联的资源。

如果 T3 在 T1 开始之前开始处理并锁定（S），那么 T1 将被锁定一段未定义的时间，也就是说，直到 T3 不解锁（S），释放资源 S 为止。事实上，没有资源 S，T1 无法继续执行。在这种情况下，尽管优先级顺序为 p1 > p3，但 T1 被牺牲以支持 T3。

如果在 T3 解锁（S）之前，T2 开始，则 T3 将被挂起，以允许 T2 在优先级 p2 > p3 下进行处理。在这种情况下，T1 将不得不等待 T2 停止处理。事实上，T1 在 T3 上被阻塞，而 T3 又在 T2 上被阻塞，尽管优先级顺序为 p1 > p2。

所提出的算法基于以下几点：

+   一个任务只有在其优先级高于当前锁定资源的任务时才允许进入临界区。

+   当它使用完临界区后，它会释放它，并赋予它以前的优先级。

## 10.3 复习问题与答案

请尝试这些复习问题，作为对知识的测试。

### 10.3.1 复习问题

1.  1.

    “任务是一系列事件。” 这个说法正确还是错误？

1.  2.什么是调度？

    1.  a.

        预防性：当一个当前任务可以被暂停以完成一个更重要的任务时。

    1.  b.

        预防性：当一个正在运行的任务可以被暂停以完成一个更关键的任务时。

    1.  c.

        抢占性：当当前执行的进程可以被暂时用来执行另一个任务时。

    1.  d.

        预防性：当正在进行的任务可以暂停一小段时间以完成一个不太关键的任务时。

1.  3.以下哪种任务描述是正确的？

    1.  a.

        根据操作系统的不同，一个任务可以是一个进程或一个线程。

    1.  b.

        作业必须是一个程序或一个线程，这取决于操作系统。

    1.  c.

        一个任务可能是一个进程或一个线程，这取决于版本。

    1.  d.

        前面的都不是。

1.  4.关于事件的以下说法哪些是正确的？

    1.  a.

        如果当前任务不能暂停直到完成，则为非抢占式。日程安排是处理器被分配的任务列表。

    1.  b.

        非抢占式并不是指正在进行的作业是否可以暂停直到完成。日程安排是处理器被分配的任务列表。

    1.  c.

        非抢占式是指当前任务不能被中止直到完成。时间表是分配给特定事件的一组责任。

    1.  d.

        所有这些都是真的。

1.  5.

    “任务是在没有其他活动的情况下由处理器持续执行的一组指令。” 这个陈述正确吗？

### 10.3.2 答案

1.  1.

    答案：错误，任务是一系列事件。

1.  2.

    答案：B，预防调度是指运行中的任务可以被短暂暂停以完成更重要的任务。

1.  3.

    答案：C，任务可能是一个进程或一个线程，这取决于版本。

1.  4.

    答案：A，如果当前任务不能暂停直到完成，则为非抢占式。日程安排是处理器被分配的任务列表。

1.  5.

    答案：错误，任务是一组指令，处理器在没有其他操作的情况下执行，直到完成为止。

## 10.4 总结

本章解释了实时系统中调度的工作原理。调度同质过程时，多个具有相同请求和时间限制的进程必须通过调度策略有效地提供服务。例如，在必须支持显示一定数量的视频的视频服务器中，所有视频都具有相同的帧速率、视频分辨率、数据传输频率等特征，就会出现这种情况。

在这种情况下，一个简单但有效的调度策略是**循环调度**。事实上，所有的进程都同样重要；它们有相同的工作量，当它们完成处理当前帧时就会崩溃。调度算法可以通过添加定时机制来优化，以确保每个进程以正确的频率运行。简单的先例模型在实践中很少出现。一个更现实的模型提供了多个进程竞争 CPU 使用的情况，每个进程都有自己的工作量和截止日期。

下一章重点介绍建模，并讨论模型驱动工程如何在分布式系统中发挥作用。对于分布式系统的实际实现，模型引导的工程是一个重要的概念。
