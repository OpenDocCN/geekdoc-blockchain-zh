© 作者，独家许可给 APress Media, LLC，Springer Nature 的一部分 2022J. T. George《引入区块链应用》[`doi.org/10.1007/978-1-4842-7480-4_4`](https://doi.org/10.1007/978-1-4842-7480-4_4)

# 4. 以太坊

约瑟夫·塔奇尔·乔治^(1  )(1)意大利罗马

比特币的区块链模型已被证明是加密货币的一种有效范式，这导致了对区块链在各个应用领域的兴趣和研究的增加。

Vitalik Buterin 很早就意识到了区块链模型的潜力。他认为它远不仅仅是一个加密货币的平台。

对比特币的热情在他 17 岁时促使他与 Mihai Alisie 共同创办了*比特币杂志*，这是一个涵盖与比特币相关主题的网站和印刷杂志。Vitalik 很快意识到区块链技术的潜力远不止于此。

2013 年，他宣称比特币需要一种用于开发和创建*去中心化应用*的脚本语言。

未能说服社区，他开始开发一个基于区块链技术的新型分布式信息平台。因此，以太坊在 2015 年 7 月 30 日诞生，并推出了一个叫做*智能合约*的全新特性。

一个新一代的区块链应运而生，至今仍然是最突出的一种—区块链 2.0。

考虑图 4-1 中显示的图像，其中比较了比特币和以太坊。左边是比特币，堆栈的顶部是通过该顶部执行货币转移操作的钱包应用程序。右边是以太坊，它将区块链转变为计算系统框架或架构，并在去中心化领域打开了全新的机会。请注意，以太坊支持智能合约和机器虚拟机 EVM，在此上面运行。智能合约又使去中心化应用程序能够实现更多的价值转移。通过这种方式，向区块链添加了一层逻辑和计算。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig1_HTML.jpg](img/520777_1_En_4_Fig1_HTML.jpg)

图 4-1

比特币 vs. 以太坊技术堆栈

以太坊用户不仅可以通过交易转移数字货币，还可以开发智能合约，使他们能够在特定条件下执行交易。就所有目的而言，他们可以在价值转移方式上设置条件。可以理解的是，“可编程货币”的概念吸引了全世界的用户、开发人员和公司。

此外，开发人员可以在以太坊区块链的分布式网络中实现和创建应用程序，即 DAPPs（去中心化应用程序）。

有了以太坊，区块链成为一个去中心化的 IT 平台，除了转移数字货币之外，还可以分发新的应用程序并与网络中的其他用户交互。

任何人都可以编写一个新的应用程序，在区块链网络上运行，而不是在集中式服务器上运行。这不仅需要克服中央机构的任何形式的审查，而且还免疫于变化，并允许所有用户在与其交互之前检查代码。

对于以太坊而言，区块链并不仅限于金融领域；它们也可以包括选举系统、域名注册、众筹平台和知识产权等，仅举几例。

简而言之，以太坊是一个革命性且有远见的项目，除了被认为是最佳在线投资之一外，还为以太坊网络的年轻创始人带来了世界声誉。该发明于 2014 年荣获著名的世界技术奖。

本章详细介绍了定义以太坊区块链的组件和技术。

## 4.1 区块链作为状态转换系统

*以太坊区块链*是一种开源的公共区块链。以太坊实现的模型可以概括为三个定义：

+   **密码学安全性：** 账本中的信息安全由复杂的数学算法和难以破解的密码学保证。换句话说，欺骗系统几乎是不可能的。

+   **事务单例机：** 按照构造范式，负责系统中生成的所有交易的机器有一个唯一的规范实例。有一个全局真理，每个人都相信。

+   **共享状态：** 存储在此机器中的状态是共享的，并且所有人都可以访问。

因此，以太坊区块链的范式是一个具有密码学安全性的共享状态事务单例机。以太坊区块链本质上是一个基于交易的状态机。

状态机是一个由状态和转换组成的图形。

+   状态描述了对象生命周期中的一段时间，并由顶点或*节点*表示。

+   转换连接两个状态，并用有向弧表示。

退出状态定义了对象对事件发生的响应。事件是时间和空间中放置的现象的再现。

因此，状态机是一种自动机，根据一系列输入数据，改变其内部状态。（见图 4-2。)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig2_HTML.jpg](img/520777_1_En_4_Fig2_HTML.jpg)

图 4-2

有限状态机的示例

由此，您可以推断：

+   区块链的状态是账本中存在的交易的集合。

+   区块链中的事件，比如创建交易。

+   区块链中的交易函数，接受一个状态和新交易，并生成一个新状态。

因此，设 S 为状态，TX 为交易，APPLY 为状态转换函数。可以正式定义如下：

*APPLY (S; TX) -> S0 or ERROR*

请注意，以太坊的状态机从创世状态开始，类似于网络上进行交易之前的空列表。

要导致从一种状态到另一种状态的转变，交易必须是有效的。当各种交易被执行时，这种起源状态会从时间到时间地转换为后续状态。（见图 4-3.)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig3_HTML.png](img/520777_1_En_4_Fig3_HTML.png)

图 4-3

基于交易的状态转换

在任何交汇点，最终状态代表以太坊的整体状态。

以太坊的整体状态包含交易。这些交易被分组到区块中。每个区块包含若干笔交易，并且与前一个区块链接。见图 4-4。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig4_HTML.png](img/520777_1_En_4_Fig4_HTML.png)

图 4-4

交易流程

从技术角度看，总账可以被视为一个状态转换系统，其中有一个包含全部总账交易的状态，以及一个接受状态和交易并返回新状态的转换函数。

在传统的银行系统中，状态是资产负债表，交易是将 X 从账户 A 转移到账户 B 的请求，并且状态转换函数会减少账户 A 中 X 的值，并增加账户 B 中 X 的值。

如果 A 的账户在开始时少于 X，则状态转换函数会出错。让 TX = 从 Luca 发送 70 到 Sara。

*APPLY ((Luca: e50; Sara: e50); TX) = ERROR*

或者，*让 TX = 从 Luca 发送 e20 到 Sara*

*APPLY ((Luke: e50; Sara: e50); TX) = Luke: e30; Sara: e70*

## 4.2 以太坊账户

在以太坊中，状态是由称为 *账户* 的对象构成的，它们起着核心作用。有两种类型的账户：

+   外部拥有账户（EOA）

+   合约账户

一般来说，外部拥有账户（EOAs）是用户账户，由私钥控制，并且没有与之相关联的代码。但是合约账户由其合约代码控制，并具有相关的代码。（见图 4-5。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig5_HTML.jpg](img/520777_1_En_4_Fig5_HTML.jpg)

图 4-5

以太坊账户

### 4.2.1 账户状态

此账户状态由四个元素组成，无论账户类型如何都会存在：（见图 4-6。）

+   **一次性数字（Nonce）：** 如果该账户由第三方拥有，则此数字表示从该账户地址发送了多少笔交易。如果是合约账户，则 Nonce 是该账户创建的合约数量。

+   **余额：** 这是该地址拥有的 Wei 数。一以太币等于 10¹⁸。

+   **内存根（MemoryRoot）：** 是 Merkle 树帕特里夏的根节点的 256 位哈希（参见第二章）。该树编码了该账户的存储账户的哈希，并默认为空。对于合约账户，这是智能合约存储。

+   **CodeHash：**这是 EVM（以太坊虚拟机）账户的哈希代码。对于合约账户，这是哈希并存储为 codeHash 的代码。对于外部拥有的账户，codeHash 是空字符串的哈希。

![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig6_HTML.jpg](img/520777_1_En_4_Fig6_HTML.jpg)

图 4-6

以太坊中的账户状态

### 4.2.2 外部拥有的账户（EOAs）

外部拥有的账户 ：

+   有以太坊余额。

+   可以发送交易（它们要么转账要么激活合约代码）。

+   由私钥控制。

+   没有关联代码。

请注意，每个账户由一对密钥定义——私钥和公钥。与比特币一样，以太坊也使用 ECDSA（椭圆曲线数字签名算法）。以太坊还使用由标准 secp256k1 规定的曲线。

你应该已经知道私钥和相应的公钥是如何工作的。但是，以太坊与比特币不同之处在于生成一个*以太坊* *地址* *.*

这些（与比特币一样）是由公钥派生的。但是，对此应用了哈希函数 Keccak 256。从此函数的结果中，你得到了*公钥哈希* *.* 从这里你再往右取 20 字节，就会得到以 0x 前缀开头的以太坊地址。

+   账户是根据其地址进行索引的。

+   创建外部拥有账户不需要费用。

+   EOA 使用交易（或消息，如你将看到的）与以太坊区块链网络进行交互。

+   他们可以发送交易，将数字货币转移到其他外部财产账户。

+   他们可以将交易发送到合约账户以调用智能合约。

### 4.2.3 合约账户

合约账户 代表智能合约，这意味着：

+   它有一个地址。

+   它有以太坊余额。

+   它有关联代码。

+   它由关联代码控制。

+   代码的执行是由来自其他账户（EOA 或合约账户）收到的事务或消息（调用）触发/调用的。

+   一旦执行，它执行任意复杂性的操作（图灵完备）并操纵其自己的持久存档；它可以拥有自己的永久状态并调用其他合约。

合约地址是通过对发送者账户和它们的 nonce 的 SHA-3 哈希，也称为 Keccak-256，以及取此结果的最右 20 字节而生成的。合约账户在创建和使用（执行）方面都有成本，因为它们使用了计算资源和网络存储。

### 4.2.4 外部所有权和合约账户之间的区别

首先，很重要的是澄清，在以太坊网络中参与需要一个外部所有权账户。此外，通过以太坊网络发送的任何类型的消息都会产生成本，因为它使用了计算和存档资源。

这意味着外部所有权账户可以向其他外部账户或其他创建合约的账户发送或传递消息。（见图 4-7。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig7_HTML.jpg](img/520777_1_En_4_Fig7_HTML.jpg)

图 4-7

来自 EOA 的交易

这意味着两个外部所有权账户之间的消息仅仅是价值的转移。

然而，来自于合约账户外部的消息会激活合约账户代码，使其能够执行各种操作（例如转移代币，写入内部存储器，铸造新代币，运行一些计算，创建全新合约等）。

换句话说，通过来自合约账户外部的所有权账户的消息调用智能合约。（见图 4-8。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig8_HTML.jpg](img/520777_1_En_4_Fig8_HTML.jpg)

图 4-8

合约账户交易示例

与外部拥有的帐户不同，合同帐户将无法启动新的交易。 相反，合同的帐户只能对接收到的不同交易（来自外部拥有权帐户或另一个合同帐户）生成交易。 您将在“交易和消息”部分了解有关合同调用的更多信息。

因此，以太坊区块链上发生的任何操作都是由外部受监管帐户激活的交易激活的。

### 4.2.5 存储密钥：加密 keystore

每个私钥/地址对都编码在一个密钥文件中，密钥文件是 JSON 文本文件。 此外，密钥文件的关键组件，帐户的私钥，始终使用在帐户创建期间输入的密码加密。

密钥文件位于创建或导入帐户的以太坊节点的数据目录中的 keystore 子目录中。

Keystore 使用椭圆曲线 secp256k1，该曲线在有效加密标准中定义，由 libsecp256k 库实现，并在 github.com/ethereum/go-ethereum/accounts 找到。 帐户以 Web3 密钥存储格式存储在磁盘上。

创建以太坊帐户的加密 keystore 后，您可以将此帐户管理器用于所有周期要求帐户生命。 这包括基本功能：

+   创建新帐户

+   现有帐户的消除

+   更新访问凭据

+   现有帐户的导出

+   导入到另一个设备

尽管 keystore 定义了用于存储帐户的加密级别，但没有全局主密码可以授予所有人访问权限。

相反，每个帐户都是单独管理的，并且以其单独加密格式存储在磁盘上，确保分离更加清洁，并使用更严格的凭据。

这种个性化意味着任何需要访问账户的操作都必须提供特定账户所需的身份验证凭据，形式为密码：

+   创建新账户时，调用方必须提供用于加密账户的密码。此密码将需要用于任何后续访问。

+   删除现有账户时，调用方必须提供密码以验证账户所有权。

+   更新现有账户时，调用方必须提供当前密码和新密码。完成操作后，账户将无法再通过先前的密码访问。

+   导出现有账户时，调用方必须提供当前密码以解密账户，以及密码以重新编码它，然后将密钥文件返回给用户。这是必要的，以允许在不共享凭据的情况下在计算机和应用程序之间移动账户。

+   导入新账户时，调用方必须提供要导入的密钥文件的加密密码和用于存储账户的新密码。这是必要的，以允许存储具有不同凭据的账户，这些凭据与用于移动它们的凭据不同。

因此，对于密码遗失没有恢复机制。加密密钥库的密码学属性确保无法以任何方式强制获取账户凭据。对于账户管理，有各种钱包应用程序可用于高效管理它们。

## 4.3 世界状态

以太坊区块链的世界状态是以太坊地址（160 位标识符）和账户状态之间的映射。

这种映射通过一种名为修改的默克尔帕特里夏树的数据结构来维护。让我们看看它是什么。

### 4.3.1 Trie

Trie，也称为*数字树*或*前缀树*，是一种有序树数据结构，用于存储动态集合或数组关联数组，其中键通常为字符串。

一般来说，节点在树中的位置定义了它所关联的键。节点不保存自己的键的副本，而是依赖于树中节点的位置。（参见图 4-9。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig9_HTML.jpg](img/520777_1_En_4_Fig9_HTML.jpg)

图 4-9

Trie 示例

树的根与空字符串相关联，节点的所有后代共享与该节点相关联的前缀。并非所有节点都必然表示一个重要的键，通常这些键可以在叶子节点以及可能的一些内部节点中找到。

### 4.3.2 Radix 树

注意，Radix 树，也称为紧凑前缀树或基数字典树，是一种表示 Trie 的数据结构，在这种树中，与 Trie 不同的是，每个叶节点都是唯一的子节点，并与父节点连接在一起。（参见图 4-10。）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig10_HTML.jpg](img/520777_1_En_4_Fig10_HTML.jpg)

图 4-10

Radix 树示例

这里的结果是每个内部节点的子节点数最多为值 r，r 是基数变量的正整数赋值给基数树。该值是 2x 的幂，其中 x 大于或等于 1。

这使得基数树对于键是长字符串的集合以及具有长前缀的键的共享集合更加高效。因此，如果基数等于 2，你会得到一个二进制 Radix 树。

让 k 为键的长度。Radix 树允许在 O(k) 的时间内进行搜索、插入和删除。这似乎不是一个优势，但它们可以执行这些操作，比平衡树需要更少的比较，并且需要比平衡树少得多的节点。

通常，基数树对于构建可表示为字符串的键的关联数组很有用。它们在 IP 路由中具有特定的应用，其中容纳大范围的值并且例外较少的能力特别适用于 IP 地址的分层组织。

### 4.3.3 Patricia Trie

请注意，Patricia trie 是基数树的一种类型，其中基数等于 2（见图 4-11）。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig11_HTML.jpg](img/520777_1_En_4_Fig11_HTML.jpg)

图 4-11

树的基数，基数 = 2

换句话说，它是一种二进制基数树（基数=2），其中每个节点都有两个子节点。因此，在树的每个交叉点处，对于每个节点（不是叶子节点），您都面临一个二进制选择（两个分支）。这意味着键的每个位都会被单独比较，并且每个节点都是一个双向分支（即左和右）。

Patricia trie 是二进制基数树（基数=2）的特殊变体，其中节点仅存储区分两个子树的第一个位的位置，而不是明确存储每个键的每个位。

在交叉点处，算法检查搜索键的索引位，并选择适当的右子树或左子树。Patricia trie 的显着特点之一是，它只为每个存储的键插入一个节点，使得 Patricia 比标准二叉 trie 紧凑得多。我们提供了一个 Patricia trie 的示例，以便更好地理解。假设您在 Patricia Trie 中放入了三个键：smiled，smiles 和 smile。

这三个键的二进制表示如图所示 4-12。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig12_HTML.jpg](img/520777_1_En_4_Fig12_HTML.jpg)

图 4-12

Patricia trie 示例

我们注意到 smile 是 smiled 和 smiles 的前缀。

分析二进制表示，我们可以看到左起第一个不同的比特位是 0（在第二行中用红色突出显示）。因此，smiled 将是 smile 的左子节点。同样，smiles 将是 smiled 的右子节点，因为它们共享相同的前缀，直到比特位的值为 1（在第三行中用红色突出显示）。输入三个密钥后得到的 Patricia trie 如图 4-13 所示。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig13_HTML.jpg](img/520777_1_En_4_Fig13_HTML.jpg)

图 4-13

Patricia trie 的示例

由于实际密钥不再显式存储，您需要对记录索引上的密钥进行全面比较以确认匹配。关于此，Patricia 与使用哈希表进行索引具有特定相似性。

### 4.3.4 以太坊修改后的 Merkle Patricia Trie

本节解释了以太坊如何更改 Merkle Patricia trie。

在修改后的 Merkle Patricia 树中，树的密钥由以十六进制表示（16 个字符）的以太坊地址（20 字节，160 位地址）表示。帐户状态中的值对应于该以太坊地址。

在加密安全的 Merkle 树的情况下，每个节点都由其哈希引用，并且树的根作为整个树的密码印记。换句话说，每个节点的确定性密码哈希被精确地用作指向节点本身的指针。

这为数据提供了一种形式的密码身份验证。如果某个 trie 的根哈希是公开已知的，则任何人都可以提供证据，证明该 trie 在特定路径上具有给定值，只要节点一直向上走。攻击者不可能提供一对（路径，值）的证据表明它们不存在，因为根哈希基于所有底层哈希，所以任何更改都会更改根哈希。这就是树的 *Merkle* 部分。

此外，在修改后的默克尔帕特里夏树中有三种不同类型的节点：

+   **扩展节点：** 包含多个节点的共同键的一部分（编码路径），并包含对后续节点（键）的引用，或下一个节点的哈希。因此，这两个字段（编码路径、键）构成了一个节点。

+   **分支节点：** 包含指向具有相同键前缀的不同节点的指针。分支节点有 17 个字段，每个字段对应十六进制字母表的一个字符（16 个字符），以及一个值字段，用于在路径完全穿过时包含最终目标值，即如果存在一对（键：以太坊地址，值：账户状态），其中键（以太坊地址）在分支节点终止。该节点由 17 个字段组成（v0 ... v15，值）。

+   **叶节点：** 包含一个值和键的剩余部分（称为键尾）。叶节点的键（因此您的以太坊地址）是其所有父节点的前缀和叶节点的键尾的连接。

扩展节点只有一个子节点。因此，子节点只能是分支节点。实际上，如果它指向一个叶子节点，它们将合并为单个叶子节点。如果它指向一个扩展节点，这些将合并为单个扩展节点。在图 4-14 中，您可以看到各种节点类型的结构。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig14_HTML.jpg](img/520777_1_En_4_Fig14_HTML.jpg)

图 4-14

以太坊修改后的默克尔帕特里夏树

简单起见，值字段承载的是账户余额。但实际上，它承载的是应用于账户状态（包含四个字段）的 RLP 函数（序列化函数）的结果。而用于节点的哈希函数是 SHA 3。

正如你所见，扩展节点和叶节点都由两个字段组成，一个字段专门用于地址的路径，另一个字段专门用于值。对于扩展节点，该值是它指向的节点的哈希。对于叶节点，它是正在序列化的账户。

但以太坊如何区分这两种节点呢？

它添加了一个前缀。这是图中称为前缀的字段。假设一个单独的十六进制字符等于 1 个 nibbe 单位。因此，一个 nibbe 等于 4 位。因此，这些前缀被用于：

+   0 是一个扩展节点，其字段中引用的路径上有偶数个字节。

+   1 是一个扩展节点，其字段中引用的路径上有奇数个字节。

+   2 是一个叶节点，其字段中引用的路径上有偶数个字节。

+   3 是一个叶节点，其字段中引用的路径上有奇数个字节。

区分扩展节点和叶节点之间的重要性是什么？

因为如果它是一个扩展节点，那么该值是一个分支节点的指针（即，它的哈希）。而如果它是一个叶节点，那么该值就与通过 RLP 函数序列化的账户状态相同。

在以太坊中的所有 Merkle Trie 都是以太坊 Merkle Patricia Trie。通过一个平坦的键/值 DB 来维护这种结构。

### 4.3.5 存储根

一个哈希 256 位根节点或 Merkle Patricia 树的基节点将账户存储的内容编码为 trie 中从 Keccak 哈希到 256 位 RLP 编码的整数值的映射。因此，在合约账户的情况下，这是智能合约的存储。图 4-15 说明了这个概念。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig15_HTML.png](img/520777_1_En_4_Fig15_HTML.png)

图 4-15

存储根是用于存储账户的 Merkle Patricia Trie 的根或基础。

### 4.3.6 为什么使用 Merkle 树？

将所有这些信息高效地存储在默克尔树中的能力在以太坊中非常有用，特别是对于我们所谓的*轻节点*而言。区块链由一组节点处理。通常有两种类型的节点：全节点和轻节点。

一个完整节点通过存档整个链，从起始块到最后一个块，并执行其中包含的所有操作来同步区块链。矿工通常保留完整节点用于挖矿过程。

也可以下载一个没有挖矿的完整节点。无论如何，每个完整节点都包含整个区块链。但只要一个节点不需要执行每个交易或查询历史数据，就不真正需要存储整个区块链。

这就是轻量级节点概念的应用之处。与其下载和存储整个链并执行所有轻节点的交易，它们只下载头部链，从起始块到当前块，而不执行任何交易或检索任何状态。由于轻节点可以访问区块头，其中包含三棵默克尔帕特里夏树的哈希，因此它们仍然可以轻松生成和接收到交易、事件、余额等的可验证响应。

## 以太坊虚拟机

以太坊虚拟机，通常简称为 EVM，是允许在以太坊平台上执行复杂代码（智能合约）的计算中心。因此，它是一台虚拟机，即能够通过虚拟化过程在所有方面模拟物理机器的软件，通过该过程，将物理资源（CPU、RAM、硬盘等）分配给在虚拟机上运行的应用程序（包括其操作系统）。它扮演着类似于 Java 虚拟机（JVM）为 Java 所扮演的角色，也就是说，一个安全的环境，与主机计算机上运行的其他进程或文件隔离和保护。

EVM 的崩溃或故障不会在主机计算机的文件系统和操作系统进程中引起副作用。EVM 还充当网络节点的保证人，“提供”它们自己的物理基础设施用于存储和处理潜在有害的智能合约。以太坊区块链的开放和无需许可的特性（就像比特币一样）实际上允许任何人都可以成为其一部分，并部署潜在有害的智能合约。

## 4.5 什么是 Gas？

以太坊中的一个非常重要的概念是手续费。请考虑每个节点都会作为验证和验证协议的一部分运行 EVM。每个交易和每个智能合约都会在网络上的每个节点上执行。

显然这并不是为了优化计算的效率。这种并行处理是多余的并行。目标是提供一种更有效的达成共识的方法，而不需要信任第三方。智能合约和*交易*的执行通过节点冗余复制，因此非常昂贵。

这激励人们不要将区块链用于计算，这些计算可以在平台之外完成。以太坊网络上的任何交易引发的计算都是有成本的。

请注意 *gas* 是以太坊区块链上的执行手续费，发送交易的人必须为每项任务支付该费用。

Gas 的命名是因为此税项类似于加密燃料，推动着智能合约和*交易*的运动。Gas 和以太被有意区分开来，因为 gas 单位对齐于具有自然成本的计算单位，而以太的价格通常因市场力量而波动。Gas 是用于计算所需费用的单位。

气体价格是我们准备在每单位气体上花费的以太数量，并以 gwei 计算。请注意，Wei 是以太的最小单位，其中 10¹⁸ Wei 表示一以太。一个 gwei 是 1,000,000,000 Wei。在每次计算/交易时，发件人设置一个 gasLimit，这意味着气体成本或价格（*gasprice*）。在这种情况下，气体限制指的是我们愿意在特定计算或交易上花费的全部气体量。气体成本指的是我们愿意支付的 Gwei 量。气体成本和气体限制的乘积代表发件人愿意为执行计算或交易支付的以太数量。

这里我们将考虑一个具有气体成本限制的发件人的示例。假设发件人将气体限制设为 50,000，并设置气体价格为 20 gwei。这意味着发件人准备花费高达 50000 x 20 gwei = 1,000,000,000,000,000 Wei = 0.001 以太来执行该计算或交易。（见图 4-16。)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig16_HTML.jpg](img/520777_1_En_4_Fig16_HTML.jpg)

图 4-16

交易手续费支付示例

如果用户在其余额账户中有大量以太来支付此费用，那么交易或计算就可以执行。在交易或计算的最后阶段，发件人将获得未使用的气体数量的退款。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig17_HTML.jpg](img/520777_1_En_4_Fig17_HTML.jpg)

图 4-17

计算结束后未使用气体的退款示例

如果发送者不提供执行交易所需的燃气，交易将耗尽并被视为无效。在这种情况下，交易的处理将停止，并且任何已经回滚以返回到计算前以太坊状态的路径更改都将被还原。此外，将记录一个失败的交易以显示尝试了哪些操作以及失败的位置。由于汽车已经在耗尽燃气之前进行了计算，因此不会向发送者退款。（见图 4-18.）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig18_HTML.jpg](img/520777_1_En_4_Fig18_HTML.jpg)

图 4-18

由于燃气不足而导致交易失败的示例

请注意，发送者为燃气所支付的全部费用都将发送到矿工的地址。由于矿工正在耗费资源来运行计算并识别计算，他们会收到作为燃气税的金额。（见图 4-19.）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig19_HTML.jpg](img/520777_1_En_4_Fig19_HTML.jpg)

图 4-19

矿工接收佣金的示例

因此，很明显，燃气价格越高，矿工从计算中获得的分数就越高。这样一来，矿工可以自由选择哪些计算要验证，哪些要避免。为了引导发送者选择他们认为合适的燃气价格，矿工可以选择宣传一个更便宜的费用，以此来执行交易。矿工会包含手续费最高的交易，因此，用户愿意为燃气支付的越多，他们的交易就越快被包含在一个区块中。你可以在这张表上看到每个操作所需的燃气。

### 4.5.1 储存用的燃气

气体不仅用于支付计算步骤，而且用于支付内存使用。存档的费率具有一些微妙的方面。例如，由于主要内存会增加所有节点上以太坊状态数据库的大小，因此有一个保持存档数据量小的激励。

由于这个原因，如果一笔交易在取消存储空间中的条目时有一个阶段，那么该交易的执行佣金将被取消，并且将退还款项以释放存储空间。此外，存储成本非常高。当我们开发智能合约时，有三种访问内存的方式：

+   栈：访问易失性栈。

+   内存：访问易失性存储或内存。

+   存储：访问非易失性存储。最昂贵的是非易失性存储。

图 4-20 显示了每个内存操作所需的气体表。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig20_HTML.jpg](img/520777_1_En_4_Fig20_HTML.jpg)

图 4-20

每个内存操作的气体成本列表

总之，不断在以太坊上存储数据的成本极高。使用以太坊保留数据是没有意义的。应仅存储当前操作所需的数据；将存档委托给另一个解决方案。

然而，一个很好的方法是仅在以太坊中存档默克尔树的根或基本哈希，作为对外部服务数据篡改的证明。

重要的是以气体消耗或计算来理解智能合约，以控制操作价格。

有几个 API 可以估算交易成本以及智能合约的成本。但这超出了本书的目标。最终，所有操作，无论是计算还是存档，都有一个以 gas 单位解释的价格。当用户提交交易时，他们提供每个 gas 单位的 ETH 价格以及他们愿意花费的 gas 单位数量。代码在 gas 方面越低，执行代码所需材料就越高效。

### 4.5.2 Gas 的目的

以太坊运行的一个重要方面是，网络执行的每个操作都是由每个完整节点共同执行的。但是您已经看到以太坊虚拟机上的计算步骤可能更加昂贵。

因此，以太坊智能合约用于基本活动，例如执行简单的业务策略，或验证数字签名和其他加密对象，而不是用于更复杂的用途，例如文件存档、电子邮件机器学习和一般可能对网络造成压力的操作。

征收关税可以防止用户过度收费。请注意，以太坊是一种完整的图灵语言，简而言之，它能够模拟任何算法。这也允许您创建循环，使得以太坊对避免无限执行的程序敏感。

在没有关税的情况下，攻击者可以有效地试图通过在操作中运行无限循环来分散网络而没有任何后果。

## 4.6 交易和消息

我们将以太坊区块链定义为基于交易的机器状态。因此，交易是可以改变以太坊区块链状态的事件。可以为不同目的创建交易：

+   EO 之间的数字货币转账

+   在以太坊区块链上分发智能合约

+   在分布式智能合约上执行函数

交易只能由 EOs 创建和传输。

### 4.6.1 交易结构

以太坊交易是一个字节数组。该矩阵被划分为字段，如图 4-21 所示。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig21_HTML.jpg](img/520777_1_En_4_Fig21_HTML.jpg)

图 4-21

交易结构

交易是通过修改后的默克尔逻辑帕特里夏树来维护的，该树在专门讨论世界状态的部分中被广泛讨论过。

在这个逻辑中，键由交易 ID 表示，值恰好是交易。

### 4.6.2 交易数字签名流程

我们使用了签署交易所采取的步骤，遵循了 Vitalik Buterin 在以太坊遭受硬分叉后提出的 EIP（以太坊改进提案）方案，以防止可能的重放攻击。使用旧方案也有效；然而，创始人建议使用新方案以防止重放攻击。可以在这里看到：![../images/520777_1_En_4_Chapter/520777_1_En_4_Figa_HTML.jpg](img/520777_1_En_4_Figa_HTML.jpg)

这是以太坊创始人提出的，附有所有链 ID 列表。

一旦创建了交易，它将通过函数 RLP 进行序列化。

*L*[*1*] *(T) = RLP (T (T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p; chainID; (); ()))*

*Dove p = T*[*i*] *se T*[*t*] *= 0, altrimenti p = T*[*d.*]

一旦序列化，将应用称为 SHA-3 的加密哈希函数，也称为 Keccak-256：

*h*[*1*] *(T) = KEC (L (T))*

一旦完成此操作，您可以应用签名

*ECDSASIGN (h (T); privKey) = (T*[*w;*] *T*[*r*]*; T*[*s*]*)*

其中：

+   T[w] 是一个恢复标识符，它加倍加上 35 或 36

+   T[r] 是数字签名的随机部分

+   T[s] 是数字签名的标志

因此，T[r] 和 T[s] 构成了 ECDSA 数字签名的输出（randomPart; sign），而 T[w] 则根据 EIP155 计算，并具有双重目的：

+   防止重放攻击

+   允许您检索有关公钥的快速恢复信息

实际上，在交易中并不存在发送者地址。一旦完成此操作，T[w]、T[r] 和 T[s] 字段将被添加到交易中，得到 *T(T*[*n*]*; T*[*p*]*; T*[*g;*] *T*[*t*]*; T*[*v*]*; p; T*[*w*]*; T*[*r*]*; T*[*s*]*)*

然后对其应用 RLP 序列化函数：

*L*[*2*] *(T)= RLP(T(T*[*n*]*; T*[*p*]*; T*[*g*]*; T*[*t*]*; T*[*v*]*; p; T*[*w*]*; T*[*r*]*; T*[*s*]*))*

然后再次应用于 SHA-3 哈希函数：

*h*[*2*] *(KEC (L*[*s*] *(T))*

最终您得到的是交易 ID。

### 4.6.3 从数字签名中恢复公钥

对于数字签名，以太坊与比特币一样，使用了 ECDSA 算法和标准的 secp256k1。

我们在此处理 EIP-155 提案中的数字签名方案。在本示例中，我们将参考以太坊主网链。但是，对于使用此方案的每个链，该过程都是相同的，只需将 chainId 更改为相应的值。

正如您所见，交易中不存在发送者地址的字段。

实际上获得了这些信息。这就是为什么您有变量 v 提供有关奇偶性和曲线点有限性的信息，其中 randomPart 是 x 值。计算 v 的公式是

*v = chainId 2 + ((y mod 2) + 35)*

+   chainID 是所用链的 ID。对于以太坊主网，该变量的值为 1。

+   y 是曲线点的 y 坐标，其中 randomPart 是曲线的 x 值。它是 ECDSA 签名的一部分。

分析计算 v 的提议公式，您会发现有趣的部分是 y mod 2。它起到恢复标识符的作用？

它被用于加速检索签名者的公钥的过程。实际上，如果信息正确，这个操作有两个可能的结果：

+   0: -> y 坐标是一个偶数值。

+   1: -> y 坐标是一个奇数值。

结果，我们发现 ((y mod 2) + 35) 可以有两个可能的值：

+   35: -> y 坐标是一个偶数值。

+   36: -> y 坐标是一个奇数值。

给定 X 坐标的固定值并截取相对于 Y 坐标的信息，可能会有几对可能的点 (x; y)，它们的 x 相同。

要验证签名，我们需要检索公钥，在其中执行一个循环，在每次迭代中，比较其中一个可能的配对是否与签名匹配。

可能的配对匹配签名。因此，让我们看一下发送者的公钥。我们简要解释 ECDSA 算法如何计算数字签名的随机部分。

给定曲线 secp256k1。设 G 是由标准 secp256k1 定义的生成点。设 n 是曲线上点 G 的阶。那么，我们需要理解一个随机数是如何在 [1, n-1] 的区间内生成的。我们称这个随机数值为 randomNumber。我们可以像这样找到 randomPart。

*随机数 G = (x1; y1)*

因此，

*随机部分 = x1 mod n*

设 h 是椭圆曲线的余因子，则 2 (h + 1) 给出了关于我们在 X 坐标的 randomPart 上有多少个可能点的信息。对于 secp256k1，余因子等于 1。因此，我们有四个可能的点：

+   两个，因为每个 X 坐标有两个可能的 Y 坐标，一个正数和一个负数。

+   两个，因为 R.x = randomPart + j n，其中 j 2 0; 1; 2; ... h（在我们的情况下 h = 1）;

但是，R.x 可以唯一地从 randomPart 中恢复，因为只有一个整数：

*R.x = randomPart + j * n*

对于 j 0; 1; 2; .....; h，表示一个有效的 x 坐标，即 G 的倍数。

出于这个原因，[SEC2]加密标准建议椭圆曲线的余因子为 h = 1 或 h = 2。对于[SEC2]推荐的这些曲线，有效 x 坐标的数量通常是一个，因此这个控制为空。

在最坏的情况下，只需要 log2 h + 1 位就能从 randomPart 中找到 R.x。

因此，鉴于点 R 的 X 坐标的固定 randomPart 信息，并截断与 Y 坐标有关的信息，可能会有两个可能的对(x; y)具有相同的有效 X 坐标。也就是说，一个是具有正 Y 坐标的(x; y)，另一个是具有负坐标的(x; -y)。

要验证签名，然后，您将不得不运行一个循环，在每次迭代期间，您确定其中一个可能的对是否与签名匹配。然而，由于 Y 坐标的奇偶性信息，我们可以一举获得点 R 的 yr 值，从而导出与签名对应的公钥。事实上，由于 v 给出了关于坐标 Y 奇偶性的信息，其中 randomPart 是有关坐标 X 的信息，我们可以计算 R = (xr; yr)。

让 h(msg)是交易的哈希。这样，我们就得到了相应的公钥 Q：

1.  1.对于 j 从 0 到 h 的范围（对于 secp256k1，h = 1）：

    1.  a)

        Pony x[r] = random Part + in

    1.  b)

        从 y[r,]的奇偶性信息派生出点 R。R = (x[r]; y[r])

    1.  c)

        计算公钥候选![../images/520777_1_En_4_Chapter/520777_1_En_4_Figb_HTML.gif](img/520777_1_En_4_Figb_HTML.gif)

    1.  d)用数字签名验证公钥：

        1.  i.

            *u1 = h(msg) * sign-1 mod n*

        1.  ii.

            *u2 = randomPart * sing-1 mod n*

        1.  iii.

            计算：

            *R = (xr, yr) = u1G + u2Q*

        1.  iv.

            设置 c = xr mod n。因此，如果 c == randomPart 为真，则签名已验证。返回 True（有效）。

否则，如果循环后未返回值 True，则信息中存在残疾。这样，公钥是从标准 secp256k1 的 ECDSA 签名中导出的，并验证签名。

### 4.6.4 三种交易类型

本节介绍了三种交易类型：

+   *EOA（外部拥有账户）之间的资金转移*：当 EOA 向另一个 EOA 转账时使用此交易。该交易的日期字段为空白。（见图 4-22。）

![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig22_HTML.jpg](img/520777_1_En_4_Fig22_HTML.jpg)

图 4-22

EOs 之间的资金转移

+   *在以太坊网络上存储智能合约*：在以太坊中，分发合同是通过交易进行的。该交易的目的地址字段为空白。但是，在数据字段中，有智能合约代码的字节码，以及必要时的一些参数。如果成功，发送者将收到一个包含合同地址的收据，他们将需要使用该智能合约（见图 4-23）。

![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig23_HTML.jpg](img/520777_1_En_4_Fig23_HTML.jpg)

图 4-23

在以太坊网络上部署智能合约的分发智能合约的运行函数

合同部署后，EOA 可以执行在此合同中定义的函数。同样，这是通过提交以太坊交易来实现的。在这种情况下，交易的目的地址是智能合约地址。而在数据字段中，有要回调的函数的选择器加上要输入到函数中的数据。（见图 4-24）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig24_HTML.jpg](img/520777_1_En_4_Fig24_HTML.jpg)

图 4-24

在智能合约上调用函数

显然，能够执行操作的人对智能合约的权限是在智能合约代码中定义的，其中包含操作的逻辑。

### 4.6.5 消息

消息是一种由 EVM 代码从一个智能合约发送到另一个智能合约的虚拟交易。请注意，在以太坊中，交易和消息是不同的。以太坊语言中的*交易*特指来自执行 EVM 代码的不同来源的数字签名数据，以在区块链中注册。消息只能由 EVM 代码发送，永远不会在数据中表示。因此，它们表达了智能合约向不同的智能合约发送消息的能力。

这些是虚拟对象，从未序列化，并且仅存在于以太坊运行环境中。它们也可以被看作是智能合约之间的函数调用。

基本上，你需要理解，消息就像一个交易，只不过它是由合约开发而不是外部参与者开发的。在生成消息后，当一个合约正在执行时，代码执行主要的 CALL 或 DELEGATE THE CALL 代码，从而生成消息。

因此，合约可以与其他智能合约建立关系，如外部参与者。它们也被称为内部计算或交易，当一个合约将交易内部发送到不同的合约时，代码被执行并与接收合约账户相关联。（见图 4-25。）

一般来说，消息来自智能合约，执行触发了从外部账户发出的交易。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig25_HTML.jpg](img/520777_1_En_4_Fig25_HTML.jpg)

图 4-25

交易和消息（内部交易）

gasLimit 由外部拥有账户设置，因此足够高，可以执行整个操作，其中包括由于操作本身而发生的任何不足执行的消息，如合同之间的消息。

对于整个交易链，一条消息的特定执行结束后，那条消息的执行可以恢复到其初始状态，以及由其执行后激活的所有消息。

## 4.7 以太坊状态转换函数

![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig26_HTML.png](img/520777_1_En_4_Fig26_HTML.png)

图 4-26

由新交易调用的状态更改和状态转换函数

本节讨论交易的验证以及状态转换函数。该函数允许您在交易有效且您已安排完成其执行所需的所有资源时，转移到新状态。请参见图 4-26。

让我们来看看以太坊状态转换函数的步骤：

应用（S; TX）-> S0 或 ERROR 的定义如下：

1.  1.

    检查交易的结构和语法，验证签名的有效性，并确定交易的 nonce 是否与发送者的 nonce 匹配。如果失败，返回错误。

1.  2.

    然后，您可以将交易成本计算为 GASLIMIT GASPRICE，并确定签名者的地址。如果发送者的账户足够，则减去刚刚计算的值并增加 nonce；否则，返回错误。

1.  3.

    初始化变量 GAS = GAS LIMIT。对于每个消耗的字节，它会减少一定数量的 gas 以支付每个消耗的资源字节。

1.  4.

    将交易的数字货币从发送者的账户转移到接收者的账户。请注意，如果接收者的账户不存在，它将创建它。然后，如果受益者的账户是智能合约，运行合约代码直到操作完成，或者至少直到执行耗尽燃气。

1.  5.

    如果交易失败，因为发送者没有钱，或者代码的执行已经耗尽了燃气，则恢复完整的状态更改，支付税金，并将税金添加到矿工的账户中。

1.  6.

    否则，如果成功，它会为未使用的燃气退还发送者的佣金，并将已消耗的佣金发送给包含交易的块的矿工。

消息的工作方式与交易相同，就恢复管理而言：如果正在运行的消息耗尽了燃气，并且所有其他由此触发的执行都得到了恢复，那就没问题。在其他情况下，它会产生错误或 STOP/RETURN 语句。

如前所述，智能合约开发人员可以访问三种类型的存储器：

+   后进先出（LIFO）堆栈（易失性），可以推送或馈送数据（范围从 0 到 1024）。

+   （易失性）存储器是一个无限扩展的字节数组。

+   以太坊的（非易失性）存储。

代码还可以获取消息的值和传入的数据。它可以阻止头数据，并且还可以将数据的字节数组作为输出返回。

EVM 的功能状态可以由数据集定义。在这种情况下，块状态是包含所有账户、预算和存储的全局状态。

请确保在每次运行的开始时，当前指令都会被识别，这是通过程序计数器指向的字节来完成的。每个操作都有其与数据集交互的定义。

## 4.8 以太坊区块链中的交易流程

本节讨论以太坊区块链中的交易生命周期。让我们以通过分布在以太坊网络上的去中心化应用程序投票的交易为例——它对任何类型的交易都有效。假设你想通过一个分布在以太坊网络上的去中心化应用程序来投票。图 4-27 显示了该应用程序的图形界面，你通过浏览器访问了它，并安装了一个插件来管理以太坊账户。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig27_HTML.jpg](img/520777_1_En_4_Fig27_HTML.jpg)

图 4-27

调用智能合约函数的交易

该应用程序向我们提供了一份选举列表，我们选择了自己有权投票的选举。

我们点击的投票功能是由 JavaScript 处理的事件，通过名为 Web3.js 的以太坊通信库。它连接到以太坊网络的一个节点，创建了一个智能投票合约的代理实例，并调用其 castVote() 函数，传递选定的候选人。函数调用是一个交易，因为它改变了投票应用程序的状态（通过其 castVote() 函数）并需要立即生成的数字签名。参见图 4-28。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig28_HTML.png](img/520777_1_En_4_Fig28_HTML.png)

图 4-28

区块链 dapps

投票交易由提交它的本地以太坊节点进行验证。验证涉及检查各种事项：

+   结构和语法定义良好。

+   数字签名与发送方地址和交易内容一致。

+   交易的 nonce 值必须有效。记住，账户的 nonce 是该账户分类账或账单发送的计算或交易次数。为了有效，交易的 nonce 应与发送方用户账户的 nonce 相匹配。

+   发件人有足够的以太币来处理交易。

+   发送的数据不会导致 castVote()函数失败。

所以，如果验证成功，当前节点将交易广播给所有相邻的对等节点。如果验证失败，交易不会传输，只会消失。然后，交易通过各个完整节点在网络上传输，这些节点依次经过之前的验证过程。

然后，通过网络传播的交易到达矿工节点。每个矿工节点根据收到的交易有自己的交易池添加到总账中。（参见图 4-29.）![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig29_HTML.jpg](img/520777_1_En_4_Fig29_HTML.jpg)

图 4-29

内存池

然后矿工节点选择要包含在候选块中的交易。

因此，让我们考虑 n 是交易的数量，并让 APPLI (S; TX)是之前定义的状态转换函数。

让 S [0]是上一个区块结束时的状态。

*对于 i = 0; 1; ... n–1，S (i+1) = APP (S (i); TX (i))*

如果没有应用过渡函数返回错误，则它们是有效的，并且可以添加到块中，否则将丢弃无效的部分。

然后，矿工将奖励加入到 S [n]中并定义块的最终状态。然后，矿工将构建块，解决共识算法，并将其传播到网络以添加到区块链中。一旦在块的验证期间执行了投票交易，智能合约将发布 VoteConfirmation()事件。

这将从选民的 Web 用户界面接收到，您已注册以侦听该事件。

Vote Confirmation() 事件将由接口的 JavaScript Web 用户处理，并在屏幕上显示消息，以使用户知道投票成功。

图 4-30 展示了交易的生命周期，从发起到确认事件。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig30_HTML.jpg](img/520777_1_En_4_Fig30_HTML.jpg)

图 4-30

交易池系统

## 4.9 交易状态

交易通过一系列状态直至未在添加到账本的区块中确认。 (参见图 4-31.)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig31_HTML.jpg](img/520777_1_En_4_Fig31_HTML.jpg)

图 4-31

交易状态

让我们逐个分析这些状态：

+   **未知:** 网络未查看或处理的交易。

+   **待处理:** 处于待处理状态且等待矿工选择和详细说明的交易。它在所谓的交易池中。

+   **在区块中:** 当矿工正确选择交易并在一个区块中提取时，交易转移到区块状态。一旦在区块中，如果区块被分叉，交易可以回滚到待处理状态。

+   **已替换:** 当发生以下事件之一时，交易可以从待处理状态转移到已替换状态：

    +   具有 nonce 自身的同一发件人的另一笔交易进入区块状态。

    +   同一发件人的具有相同 nonce 的更高燃气价格的另一笔交易进入待处理状态。

因此，让我们看看交易的状态*转换*。

+   **汇总:** 从未知状态转移到待处理状态的转换。它涉及进入某人的交易池的交易。因此，它们正在等待被选中以训练候选区块。

+   **已挖掘：** 已挖掘的交易由矿工处理，创建一个块。一旦他检查了交易，他就会将其状态输入块中。由于以太坊网络的点对点性质，从某个节点的角度来看，交易可以直接从未知状态转移到块内状态，而无需经过待处理状态。

+   **已替换：** 从挂起状态转移到替换状态的交易被视为已替换。当发生以下情况时：

    +   与相同发送者的另一笔具有相同 nonce 的交易进入块内状态。

    +   发件人状态中具有相同 nonce 但具有更高 gas 价格的另一笔交易进入待处理状态。

+   **分叉：** 当一个块交易是网络倒置的块的一部分时发生。该块内的所有交易将从块内状态转移到待处理状态*。*

+   **已确认：** 块状态中的交易在每次提取并添加到链中的新块时都被确认。

## 4.10 块结构

以太坊区块链的一个块被分成以下几部分：

+   块头

+   ommer 块头列表

+   块数据

ommer 块头的格式与报告的格式相同。 (见图 4-32.)![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig32_HTML.jpg](img/520777_1_En_4_Fig32_HTML.jpg)

图 4-32

块结构

带有 B[U] 的 ommer 块头列表，而交易列表则表示为 B[T]。因此，形式上，我们将块 B 称为：

*B = (B*[*H*]*; B*[*T*] *; B*[*U*]*)*

请记住，以太坊中的每棵树都是修改的 Merkle Patricia trie，这在 World State 部分有详细介绍。

乍看起来，这种方法可能非常低效，因为每个区块都必须捕获整个状态，但实际上每个区块后只需改变少部分。由于所有状态信息都是最终区块的一部分，因此无需记录区块链的完整历史。

一般来说，两个相邻区块之间的树大部分是相同的，因此只需记录一次信息并通过哈希指针引用两次。另外值得一提的是智能合约的代码执行过程是通过通过状态计算或转换函数执行的事务生成的。

鉴于区块验证算法，如果将计算或交易添加到名为 X 的区块中，则该交易生成的代码的执行将由网络的所有节点执行，验证并添加 X 区块。

图 4-33 总结了这些以太坊区块。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig33_HTML.jpg](img/520777_1_En_4_Fig33_HTML.jpg)

图 4-33

以太坊中的区块结构

### 4.10.1 交易收据

每个交易在执行和验证时都会改变区块链的状态。因此，每个有效的交易都有一个结果。交易收据记录了每笔交易的结果。每次计算或交易收据都是由四个元素组成的元组：

+   Ru：累积气体

+   Rl：通过交易执行开发的寄存器集合

+   Rb：由这些寄存器中的信息组成的布隆过滤器

+   Rz：交易后的状态

因此，交易收据的定义如下：

*R = (R*[*u*]*; R*[*b*]*; R*[*l*]*; R*[*z*]*)*

### 4.10.2 哥伦布区块

以太坊的区块处理时间比比特币低得多。一方面，这允许更快地处理交易，另一方面，几个矿工同时解决更多的区块。这些并行区块被称为*附属区块*。

附属区块不进入主链。然而，将这些区块整合到已获得主区块链位置的主区块中的目标是帮助奖励这些区块的矿工。

为了使矿工能够获得对一个附属区块的奖励，它必须是有效的。因此，附属区块的目的是奖励表现良好的矿工，并奖励孤立区块。

这有双重效应：

1.  1.**促进网络的去中心化。** 事实上，甚至奖励因为孤立区块而挖掘的矿工也是如此：

    +   更大的网络延迟，导致数据传播延迟

    +   较少的计算能力导致更大的难度来提取一个区块

        +   降低集中化程度，并避免拥有更大计算能力的矿工池声称大部分奖励而不留给个别矿工。

1.  2.

    **通过增加主链上的工作量来增加链的安全性。** 这样就减少了浪费的工作量。

赢得主链上位置的区块通常是具有最大工作量证明份额的区块。而附属区块通常比这个测试份额少。每个区块最多可以有两个附属区块。

## 4.11 以太坊简化的 GHOST

*GHOST* 协议背后的目标是为那些具有非常快的区块处理速度的区块链提出一种解决方案。事实上，具有非常快确认时间的链受到“减少”安全性的影响，因为矿工挖掘的区块在网络中传播得更慢。

基本上，解决方案是将潜在的区块包含在主区块链的计算中。

此外，产生快速块的区块链强烈面临着向矿池中心化的风险，该矿池在网络上具有高比例的哈希能力，从而控制挖矿过程。

为了避免这种情况，以太坊采用了“简化版” GHOST 协议，能够克服处理块速度快的区块链所困扰的两个问题。

以太坊采用的解决方案是为潜在块提供降低的奖励。不仅如此，他们还为包含潜在块的子块提供奖励。

以太坊的简化版 GHOST 协议定义如下：

+   块必须指定一个先前的块，并且 0.1 或 2 个嵌套块。

+   包含在块中的嵌套块应具有以下属性：

    +   它必须是 B 的 k 代父代的直接子代，其中 k 介于两个和七个之间。

    +   因此，它不应该是 B 的前体。

    +   它应该是一个有效的块。

    +   嵌套块应该不同于上一块中包含的所有嵌套块以及同一块中包含的所有其他嵌套块。

嵌套块可以包含在最多七代中的两个原因有：

+   没有世代限制的 GHOST 将在计算哪些嵌套块对于某个块有效时带来复杂性。

+   而且，作为以太坊中实现的无限 GHOST，将消除矿工挖掘主链的动机，而不是攻击者的动机。

## 4.12 以太坊共识

让我们看看，即使在这里，也是形成共识的一种新兴方式，并且以太坊将其共识基础放在了工作量证明（POW）上。

以太坊使用的 POW 算法是 Ethash，它基于 Keccak-256 位密码散列函数。

正如您已经看到的，当一个交易被创建并签名后，在被传输到网络之前，它会通过本地以太坊节点进行本地验证。

此验证包括以下检查：

+   交易的结构和语法是完全形成的。

+   数字签名与发送方地址和交易内容一致。

+   交易的一次性值必须有效。要有效，交易的一次性值必须与发送方账户的一次性值匹配。

+   发送方有足够的以太币来支付交易的气体。

+   发送的数据一致且格式良好，因此不会导致任何调用操作失败。

如果这些验证步骤中的任何一步失败，则交易将失败并传输到网络中。相反，如果成功，则通过相邻节点传播到整个网络。每个接收交易的节点依次执行交易有效性验证。

再次，如果成功，这将通过网络传递，否则将被忽略。通过这种方式，您可以避免用无效交易堵塞网络，因此这些交易不会导致任何状态更改。

当这些到达矿工时，他们会验证它们并将它们添加到交易池中。实际上，矿工像比特币一样在本地保留交易池，等待添加到候选块中的交易。

矿工根据各种标准选择要添加到块中的交易，但主要基于交易提供的费用。矿工每个块有一个气体限制，不能突破。

然后他们选择一个数字 n 的交易添加到块中，并且他们对每个这些状态应用过渡函数 APPLY(S; TX) -> S 或 ERROR，因此矿工最终可以构建具有新状态 S0 的块，填写字段，并解决我们在比特币章节中谈到的 Nakamoto 共识中的 PoW 难题。一旦谜题解决，矿工就可以将块传递给网络。将接收块的每个节点都将验证后者。以太坊中的基本块验证算法的工作方式如下：

+   检查先前引用的块是否仍然存在且有效。

+   查看区块的时间戳是否大于前一个并且比未来 15 分钟的参考区块的时间戳。

+   验证区块号、难度、交易发起方、衍生交易和 gas 限额是否有效。

+   验证区块上的 POW 是否仍然有效。

+   S [0] 可以是上一个区块结束时的状态，TX 可以是该区块的计算或事务列表，有 n 步。

*对于 i = 0 ... n - 1，设置 S (i+1) = APPLY (S (i); TX (i)).*

然后检查应用程序是否出错，或者到目前为止在区块中消耗的总 gas 是否超出了 GASLIMIT；这也会导致错误。

+   假设 S FINALS (n)，但添加了支付给矿工的区块奖励。

+   需要验证 Merkle 树 S_FINAL 的原始状态是否与区块头中给出的原始最终步骤或状态相同。在这种情况下，区块是有效的；反之，则无效。

### 4.12.1 工作量证明算法（PWA）

PWA 正式定义如下：

*(n; m) = PoW (H; H*[*n*]*; d)*

其中

+   (n; m)

    +   M 是一个 mixHash

    +   n 是 nonce

+   H 是区块头，不包含 nonce 和 mixHash。

+   Hn 是一个由密码学伪随机数定义的 nonce，与 H 和 d 不独立。

+   d 是 DAG，是一个计算 mix-hash 需要的大量数据。简而言之，矿工通过 DAG 反复生成这样的 mixHash，直到输出的 nonce 值低于期望值为止。

nonce 与区块的难度之间的关系在此正式定义：![../images/520777_1_En_4_Chapter/520777_1_En_4_Figc_HTML.png](img/520777_1_En_4_Figc_HTML.png)

## 4.13 以太坊 2.0

你已经看到，与比特币一样，以太坊是一种新兴的共识。以太坊用于提取区块的算法是 *工作量证明* 算法。

但是，很快，以太坊将从 1.0 升级到 2.0 版本。 这个更新不会立即发生，而是会通过各个阶段逐渐进行。

这个更新最重要的一个注释是创新了用于提取区块的算法。 实际上，随着升级到以太坊 2.0，将过渡到权益证明算法。工作量证明是一种用于提取区块的算法，其带来的计算负担不小。 为了赢得一个区块，您需要来自昂贵而专业的硬件的必要计算能力。

这导致能源消耗非常高，对污染产生后果。因此，总的来说，与 PoW 相关的问题有：

+   这是一个非常低效的过程，因为它需要大量的计算资源和能源。

+   能够负担得起更强大硬件来进行 PoW 的人和组织更有可能使用它，这意味着存在将挖矿过程集中在组织中的风险。

图 4-34 显示了以太坊网络内挖矿能力分布的统计例子。![../images/520777_1_En_4_Chapter/520777_1_En_4_Fig34_HTML.png](img/520777_1_En_4_Fig34_HTML.png)

图 4-34

以太坊的哈希率分布

因此，从图像中可以清楚地看出，以太坊总挖矿能力的 51%以上掌握在三个组织手中。为了解决这些问题，以太坊考虑了 PoS 作为解决方案。

## 4.14 总结

在本章中，你学习了关于以太坊及其结构（状态和交易功能）的知识。它解释了以太坊是如何被创造出来的，以使开发人员能够构建和发布智能合约和分布式应用，这些应用可以在没有停机问题、欺诈或第三方干预的情况下使用。下一章将重点介绍基于权益证明算法的共识，研究越来越深入。更多的区块链正在考虑转向这种算法共识，首先是以太坊。本章结束时，将涵盖以太坊的 Casper，这是以太坊开发者正在实施的权益证明。
