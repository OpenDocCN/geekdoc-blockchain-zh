# 如何在草原上创造刀

> 原文：<https://web.archive.org/web/https://dappradar.com/blog/how-to-create-a-dao-on-velas>

## Velas 为构建分散、高效、透明的 DAO 提供了理想的基础设施

团队可以享受在 Velas 上创建 Dao 的各种好处。其中包括拥有一个完全自主和透明的组织，利用基于以太坊的智能合约，以接近零的成本享受闪电般的交易速度，等等。

**概要:**

*   组织的未来将以 DAO 的形式出现，Velas 为此提供了一个高效的基础设施。
*   利用 Velas ( [VLX](https://web.archive.org/web/20221022164655/https://dappradar.com/hub/token/eth/VLX?from=0x8c543aed163909142695f2d2acd0d55791a9edb9) )区块链，开发人员可以用多种语言构建 Dao，并且支持跨链交互。
*   值得注意的是，在构建 DAO 时，团队需要全面考虑 DAO 结构、记号组学、社区建立等。
*   Dao 已经选择加入 Velas 区块链，以受益于其低成本、高效率和 Velas 1 亿美元的资助计划。
*   本文将向开发人员一步步展示如何在 Velas 上创建 DAO。

## 介绍

虽然[以太坊](https://web.archive.org/web/20221022164655/https://dappradar.com/rankings/protocol/ethereum)仍在努力转向节能的利益相关模型，但各种区块链已经出现，以解决以太坊的扩展问题。在所有的替代品中，Velas 是最受认可的。

根据 DappRadar Token Explorer 的数据，Velas ( [VLX](https://web.archive.org/web/20221022164655/https://dappradar.com/hub/token/eth/VLX?from=0x8c543aed163909142695f2d2acd0d55791a9edb9) ) token 在过去七天内反弹了 9.76%，在撰写本文时的交易价格为 0.046。

Velas 是一款区块链，继承了 Solana 的技术优势，并提供了高性能的 EVM 兼容解决方案。因此，它可以以更高的速度和更低的成本平稳地执行基于以太坊堆栈构建的智能合约和 dapps。令人印象深刻的是，Velas 可以以接近零的成本每秒处理 50，000 多个事务(TPS)。

此外，Velas 致力于提供一个终极基础设施，以其突破性的技术为分散自治组织(Dao)提供支持。那么，为什么道在区块链世界越来越受欢迎呢？

首先，让我们弄清楚这个问题:[什么是刀](/web/20221022164655/https://dappradar.com/blog/what-is-a-dao-how-does-it-work/)？

简而言之，一个道是一个虚拟的社区领导的实体，没有任何中央领导，决策是通过对区块链的投票作出的。由于这可以带来更民主、透明和公平的组织治理，DAO 正在进入商业管理的主流，尤其受到密码社区的青睐。

这篇文章将展示如何在 Velas 上开始你的刀。在进入这些步骤之前，开发人员需要有一个 Velas 钱包和自己的 VLX，因为 dapps 通过发送带有一个或多个指令的交易来与 Velas 区块链进行交互。

[点击此链接](/web/20221022164655/https://dappradar.com/blog/faq-token-swap-on-dappradar/)了解如何使用 DappRadar 令牌交换来获取 VLX。

## Velas 上的 Dao 是按比例建造的

与将规则写在纸上的传统组织不同，DAO 的规则和规定是开源编程的，并由智能合同运行。利用 Velas 区块链，开发人员可以用多种语言构建由智能合约支持的 Dao。此外，Velas 上的 Dao 是按比例构建的，因为 Velas 区块链支持跨链交互。

让我们通过这些步骤在 Velas 上创建你的刀。

### 决定刀的类型

一个组织的构建需要深思熟虑，一个道的创造也是如此。创造一把刀背后的原因和动机值得深思。这些考虑将有助于确定 DAO 的最佳结构。你想用你的刀达到什么目的？道的短期和长期愿景是什么？你的项目需要一个分散的、非等级的所有权结构吗？这些只是一些需要思考的示例问题。

组织也可以发挥他们的想象力来提出他们自己的 DAO 选择，但一般来说，他们涵盖以下类型:

*   协议 DAOs
*   格兰特·道斯
*   社会道德
*   收藏家道斯
*   创业道
*   媒体 Dao
*   社交媒体 DAOs
*   娱乐道

### 设计记号组学

DAOs 的目标是取代公司，以自下而上的方式组织各种商业和非商业活动。为了使这些活动顺利进行，自然需要经济激励。因此，战略性地考虑 DAOs 中令牌的分布和效用对于社区的发展至关重要。

DAO 标记可用于:

*   奖励和激励
*   道的治理和表决道的方向
*   为您的社区释放其他利益和机会

代币组学的其他关键方面包括代币的初始供应和分配。它们是道的商业计划的一部分；因此，这些事项是投资者在做出投资决定时必须考虑的。

### 建立并参与你的社区

对于第一次构建 DAO 的团队来说，没有必要太担心，因为市场上有第三方工具可以帮助他们快速启动。

然而，使一个道成功的最关键的部分是其社区中的人。如果一个道有一个积极投入的社区，它更有可能在激烈的竞争中生存下来，甚至茁壮成长。

值得一提的是，建立一个社区并不局限于在 Discord、Telegram 或 Twitter 等社交媒体上露面。一个充满活力的社区依赖于拥有相同愿景并共同贡献的建设者、创造者和 Web3 爱好者。

## 一步一步的在草原上创造刀的指南

在本文的这一章中，我们将向您展示如何在 Velas testnet 上部署一个实际的 DAO 智能契约。

### 先决条件

在本教程中，我们将使用 [Hardhat](https://web.archive.org/web/20221022164655/https://hardhat.org/) 进行开发。然而，我们不会在这里讨论安全帽和坚固性的基础知识。所以如果你对这些技术不熟悉，请先装备好扎实和安全帽的基础。

### 设置

对于安装，请在您的机器上创建一个新的 Hardhat 项目，并删除所有文件(。sol)放在默认创建的合同文件夹中。

### 如何创建治理令牌

像 MakerDAO 这样基于令牌的成员模型是目前 DAO 组织的主要形式。因此，我们将指导您创建自己的治理令牌。由于 Velas 与 EVM 兼容，我们创建的令牌将是一个 ERC20 令牌。

这里我们不关心如何向用户分发令牌，因为这不是一个真正的项目。如果想找出令牌分发的策略，建议研究一下 MakerDAO 这样不同的项目，比较一下。

要创建治理令牌，首先，您需要在 contracts 文件夹中创建一个名为 *GovernanceToken.sol* 的文件，并将以下代码添加到该文件中。

```
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract GovernanceERC20 is ERC20 {
    constructor(uint256 initialSupply) ERC20("Governance Token", "GT") {
        _mint(msg.sender, initialSupply);
    }
}
```

### 如何编写 DAO 智能合约

由于智能契约是创建全功能 DAO 的关键部分，我们将一步一步地完成这个过程，并根据需要分别对每个部分进行编码。首先，让我们创建一个准系统合同，并将其添加到一个名为 *DAO.sol.* 的文件中。

```
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {

}
```

#### 创建构造函数

现在，我们将使这个 DAO 契约与任何 ERC20 令牌兼容。

通过使用 IERC20 接口，我们可以与任何 ERC20 令牌进行交互。为此，我们必须从 *Openzeppelin 库*导入 IERC20 接口，然后声明一个使用 IERC20 接口的变量 *governancetoken* 。

现在，我们需要创建智能合约的构造函数。在这种情况下，我们将使用一个名为 *_governancetoken* 的参数，这是我们的治理令牌的地址。在构造函数内部，我们将使用 IERC20 给 *governancetoken* 变量赋值，并将其传递给 *address _governancetoken* 。

```
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {
    IERC20 public governancetoken;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }
}
```

#### 定义建议结构

每当成员创建提案时，他们都必须使用预定义的格式。我们将通过使用 struct 数据类型来定义每个建议的格式来实现这一点。现在，让我们创建一个名为 *Proposal* 的结构，如下所示。

```
 struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        Status status;
    }
```

正如您在上面看到的，每个属性都有一个与之关联的数据类型。您将知道这些数据类型中的大多数，但是我们已经添加了一个名为 *Status* 的自定义数据类型。关于数据类型“状态”的更多细节将在下面的章节中解释。

#### 跟踪建议

创建提案后，我们必须将其保存在仓库中。为此，我们使用建议映射，将 index(在本例中为 uint256)作为键，将*建议*作为值。将映射添加到我们的智能契约中，并将其命名为 public proposals，使其对公众可见。

```
mapping(uint256 => Proposal) public proposals;
```

#### 其他全局变量和枚举

为了让智能契约完全发挥作用，我们还需要向它添加一些其他的全局变量和枚举。

首先，我们将添加*状态*枚举。我们前面提到的这种数据类型定义了一个提议的状态。枚举帮助我们将变量的值限制为预定义的值。通常，我们希望将建议结构中状态变量的值限制为以下值。

*   被认可的
*   拒绝
*   InProgress
*   期满

让我们逐一检查一下。因此，如果持有 51%治理令牌的成员批准该提议，则状态将为*批准*，同样的条件也适用于*拒绝*状态。

如果赞成或反对都不超过投票总数的 51%，提案的状态将更改为*过期*。当然，当提案处于投票阶段时，其状态将显示为*正在进行*。

我们还将为单个成员的投票类型创建一个枚举。这将限制成员的投票选项为*赞成*或*反对*。

```
enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}
```

此时此刻，我们还需要两个变量。一个是在我们将提案添加到提案映射时为每个提案提供一个索引，另一个是存储投票周期的值。我们将保持所有提案的固定投票期，即 7 天。

```
uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;
```

由于我们已经完成了本教程的一半，我们的智能契约应该类似于下面这样。

```
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {

    enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}

    struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        uint256 votingPeriod;
        Status status;
    }

    mapping(uint256 => Proposal) public proposals;

    IERC20 public governancetoken;

    uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }
}
```

#### 限制访问成员

因为在一个 DAO 中通常有许多类型的成员，所以不是所有的成员在一个 DAO 中都被同等对待。所以我们想限制一些 DAO 成员对某些功能的访问。为此，我们将使用一个修饰符。这个修饰符叫做 *isMember* 。在我们的例子中，我们仅使用它来允许治理令牌持有者访问该函数。

```
 modifier isMember {
        uint256 balance = governancetoken.balanceOf(msg.sender);
        require(balance > 0, "Not a member of quorum");
        _;
    }
```

#### 用于创建建议的功能

所有准备工作完成后，让我们编写智能合同的核心功能，即建议书创建。那么如何编写一个允许成员(在本例中，是持有治理令牌的人)创建提议的函数呢？

```
 function createProposal(string memory _name) public isMember returns(Proposal memory) {

        proposals[indx] = Proposal(
            msg.sender,
            _name,
            0,
            0,
            block.timestamp,
            VOTING_PERIOD,
            Status.InProgress
        );

        indx++;

        return proposals[indx-1];
    }
```

创建提议时，提议者只需在调用函数的同时提交提议的名称。为此，我们有一个名为 *_name* 的参数，类型为 string。

此功能的访问权限仅限于治理成员。所以让我们用 *isMember* 修饰符来确定 *public* 的可见性。在内部，我们使用 *indx* 作为一个键来存储一个带有提议映射的提议。最后，我们将 *indx* 增加 1，并返回创建的提议。

在创建一个建议时，我们必须使用所有值作为参数的建议结构。设置新建议值的方法如下。

*   *提议者*:保存调用函数的人的地址
*   *name* :设置为字符串，作为函数参数传递
*   *voteForApprove* :设置为 0
*   *voteForDeny* :设置为 0
*   *开始时间*:当前块时间戳
*   *状态*:设置为状态。正在进行中

#### 跟踪投票的成员

创建提案后，投票将开始。现在最重要的是确保不让议员投两次票。我们将使用嵌套映射，其中第一个映射将建议索引( *indx* )作为键，布尔值作为值，外部映射将该地址作为键，前一个映射作为值。

这样，我们将跟踪每个成员的地址，以及他们是否对某个特定的提案投了票。

```
 mapping(address => mapping(uint256 => bool)) public voted;
```

#### 投票功能

现在到了激动人心的部分，编写一个允许成员投票的函数。投票函数将接受两个参数。第一个是提案的索引( *_proposal* )，第二个是投票选项( *Option* struct)。

如前所述，这个函数仍然只能由带有 *isMember* 修饰符的成员访问。因为我们将更改智能合约的状态，所以它需要对公众可见。

#### 投票功能是如何工作的？

首先，我们需要检索存储在提议映射中的提议，供用户投票。我们可以使用映射名称后跟带键的方括号来访问任何提议。

这里我们将使用*提议[_ 提议]* 。将建议存储在名为*建议、*的变量中，变量的类型为*建议*，后跟关键字*存储*。关键字存储允许我们访问存储的数据，数据会根据我们所做的更改而更新。

#### 为投票添加更多条件

我们创建投票函数的工作不止于此，因为我们需要添加一些条件来限制投票。比如投票期已经结束，或者用户已经投票了怎么办？

在这些情况下，我们将对它们都使用 *require* 函数。在第一个条件中，我们想要检查投票是否已经结束。为此，我们可以使用下面的语句。

*proposal . start time+VOTING _ PERIOD>= block .时间戳*

如果条件被满足，它将抛出一个错误，说“*已经投票了！*”。

在第二个条件中，我们希望检查用户是否已经投票。为此，我们可以检查用户投票地址的标志是否为假。使用下面的陈述可以帮助我们实现这一点。

*已投票的[邮件发送者][_ 提案] ==假*

如果该标志为真，它将显示一个错误消息“已经投票了！”。

每当用户投票时，他们的治理令牌的余额将被视为该用户所投的票数。因此，我们将相应地更新投票。要获得用户拥有的令牌数，我们可以使用*治理令牌*的方法的*balance。*

如果用户投票批准，则将余额添加到 *votesForApprove。*相反，如果用户投票否定，那么给 *votesForDeny* 加余额。最后，将该地址的*投票*标志设置为*真*。

```
 function vote(uint256 _proposal, Option _vote) public isMember {
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD >= block.timestamp, "Voting Ended");
        require(voted[msg.sender][_proposal] == false, "Already Voted!");

        uint256 balance = governancetoken.balanceOf(msg.sender);

        if (_vote == Option.Approve) {
            proposal.votesForApprove = proposal.votesForApprove + balance;
        } else {
            proposal.votesForDeny = proposal.votesForDeny + balance;
        }

        voted[msg.sender][_proposal] = true;
    }
```

#### 更新建议的状态

现在我们已经创建了投票函数，下一步是编写一个函数，在提案结束时更新提案的状态。“其他全局变量和枚举”部分解释了任何提案的不同法规的含义。

现在让我们继续讨论如何做出决策和更新提案的状态。对于 *updateStatus* 函数，我们将提案的索引作为函数参数。该流程还从从建议映射中检索建议开始。然后我们需要检查提案是否还在投票期内。如果没有，我们可以进入下一步。

为了检查提议的结果，我们需要做一些计算，但是怎么做呢？首先，我们必须获得治理令牌供应量的一半( *halfOfSupply* )。为此，我们需要使用 *governancetoken* 的 *totalSupply* 函数获得总供应量，然后除以 2。

如果 *votesForApprove* 大于 *halfOfSupply，*则将状态设置为待批准(*状态)。已批准*。如果 *votesForDeny* 大于 *halfOfSupply* ，则将状态设置为拒绝(*状态)。被拒绝*)。条件都不满足怎么办？然后我们可以将状态设置为过期( *Status.expired* )。

```
 function updateStatus(uint256 _proposal) public returns(Status){
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD <= block.timestamp, "Voting In Progress");
        uint256 halfOfSupply = governancetoken.totalSupply() / 2;

        if (proposal.votesForApprove > halfOfSupply) {
            proposal.status = Status.Approved;
        } else if (proposal.votesForDeny > halfOfSupply) {
            proposal.status = Status.Denied;
        } else {
            proposal.status = Status.Expired;
        }

        return proposal.status;
    }
```

#### 整个智能合同的预览

现在，最困难的部分已经过去了。让我们看看我们取得了什么成就。DAO 智能协定应该如下所示。

```
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {

    enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}

    struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        Status status;
    }

    mapping(uint256 => Proposal) public proposals;

    mapping(address => mapping(uint256 => bool)) public voted;

    IERC20 public governancetoken;

    uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }

    function createProposal(string memory _name) public isMember returns(Proposal memory) {

        proposals[indx] = Proposal(
            msg.sender,
            _name,
            0,
            0,
            block.timestamp,
            Status.InProgress
        );

        indx++;

        return proposals[indx-1];
    }

    function vote(uint256 _proposal, Option _vote) public isMember {
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD >= block.timestamp, "Voting Ended");
        require(voted[msg.sender][_proposal] == false, "Already Voted!");

        uint256 balance = governancetoken.balanceOf(msg.sender);

        if (_vote == Option.Approve) {
            proposal.votesForApprove = proposal.votesForApprove + balance;
        } else {
            proposal.votesForDeny = proposal.votesForDeny + balance;
        }

        voted[msg.sender][_proposal] = true;
    }

    function updateStatus(uint256 _proposal) public returns(Status){
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD <= block.timestamp, "Voting In Progress");
        uint256 halfOfSupply = governancetoken.totalSupply() / 2;

        if (proposal.votesForApprove > halfOfSupply) {
            proposal.status = Status.Approved;
        } else if (proposal.votesForDeny > halfOfSupply) {
            proposal.status = Status.Denied;
        } else {
            proposal.status = Status.Expired;
        }

        return proposal.status;
    }

    modifier isMember {
        uint256 balance = governancetoken.balanceOf(msg.sender);
        require(balance > 0, "Not a member of quorum");
        _;
    }
}
```

### 在 Velas Testnet 上部署合同

恭喜你！你离经营自己的道就一步之遥了。您准备好在 Velas 上部署您的智能合约了吗？

为了部署契约，我们必须编写一个部署契约的脚本。在*脚本*文件夹中创建一个 *deploy.js* 文件，并将以下代码粘贴到该文件中。

```
const hre = require("hardhat");

async function main () {
  // We get the contract to deploy
  const GovernanceToken = await hre.ethers.getContractFactory('GovernanceERC20');
  console.log("Deploying Governance Token...");
  const governanceToken = await GovernanceToken.deploy(1000);
  await governanceToken.deployed();
  console.log('Governance Token deployed to:', governanceToken.address);

  const DAO = await hre.ethers.getContractFactory('DAO');
  console.log('Deploying DAO...');
  const dao = await DAO.deploy(governanceToken.address);
  await dao.deployed();
  console.log('DAO deployed to:', dao.address);
}

main()
  .then(() => process.exit(0))
  .catch(error => {
    console.error(error);
    process.exit(1);
});
```

在部署合同之前，我们必须更改 *hardhat.config.js* 文件中的 *module.exports* 。

```
module.exports = {
  solidity: "0.8.4",
  networks: {
    velastestnet: {
      url: `https://evmexplorer.testnet.velas.com/rpc`,
      accounts: [process.env.PRIVATE_KEY]
    }
  }
};
```

这将 Velas testnet 的详细信息添加到我们的 hardhat 配置中。此外，在部署契约之前，您必须将钱包的私钥添加到*中。env* 文件。此外，确保你的钱包里有一些 testnet Velas 令牌。你可以在这里从[那里获得 testnet 代币。](https://web.archive.org/web/20221022164655/https://t.me/velas_faucet_bot)

现在一切都设置好了，在终端中运行下面的命令。

```
npx hardhat run scripts/deploy.js --network velastestnet
```

检查输出。

```
Deploying Governance Token...
Governance Token deployed to: 0x158C94E88d3AC6967e7690eAeac3FB6c8BF68502
Deploying DAO...
DAO deployed to: 0x190b8BF3f887D4F00AcF57e95AE478270Cc7fdC5
```

如果您的输出与上面看到的类似，那么您已经成功地部署了契约！

最后但同样重要的是，与创建 DAO 智能合约相关的所有信息都在[这个 repo](https://web.archive.org/web/20221022164655/https://github.com/nikbhintade/velas-dao) 中。如果你想检查代码或查看智能合同的测试，[查看这个页面](https://web.archive.org/web/20221022164655/https://github.com/nikbhintade/velas-dao)。

## 最后的话

创业团队选择了 Velas 区块链作为构建 Dao 的基础设施。例如，VeleroDAO，基于 MakerDAO 协议的 DeFi 平台，已经加入了 Velas 区块链。

基于 Velas 的构建意味着 VeleroDAO 可以享受闪电般的交易速度和成本效益，而不会影响与以太坊的互操作性。最重要的是，VereloDAO 也是创业团队如何受益于 [Velas grant 计划的一个很好的例子。](https://web.archive.org/web/20221022164655/https://velasgrants.typeform.com/GrantsProgram)

该计划提供 1 亿美元的奖励，以支持开发者和创作者将他们的想法付诸行动。它不仅促进了草原生态系统的发展，也加速了区块链生态系统的多样化。[现在就加入快速发展的 Velas 生态系统](https://web.archive.org/web/20221022164655/https://velasgrants.typeform.com/GrantsProgram)。

关于 Velas 的更多信息

[网站](https://web.archive.org/web/20221022164655/https://velas.com/?utm_source=dappradar&utm_medium=about_velas)

[白皮书](https://web.archive.org/web/20221022164655/https://velas.com/pdf/whitepaper.pdf)

[资助项目](https://web.archive.org/web/20221022164655/https://docs.velas.com/grants/?utm_source=dappradar&utm_medium=about_velas)

[脸书](https://web.archive.org/web/20221022164655/https://www.facebook.com/velasblockchain)

[LinkedIn](https://web.archive.org/web/20221022164655/https://www.linkedin.com/company/velas-ag)

[推特](https://web.archive.org/web/20221022164655/https://twitter.com/VelasBlockchain)

[电报通知](https://web.archive.org/web/20221022164655/https://t.me/VelasOfficial)

[电报社区](https://web.archive.org/web/20221022164655/https://t.me/velascommunity)

[Instagram](https://web.archive.org/web/20221022164655/http://instagram.com/velas.blockchain)

[不和](https://web.archive.org/web/20221022164655/https://discord.gg/CTcKpPc)

[YouTube](https://web.archive.org/web/20221022164655/https://youtube.com/c/VelasOfficial)

[中等](https://web.archive.org/web/20221022164655/https://velasblockchain.medium.com/)

**免责声明** —这是一篇赞助文章。DappRadar 不认可本页面上的任何内容或产品。DappRadar 旨在提供准确的信息，但读者应该在采取行动之前总是自己做研究。DappRadar 的文章不能被认为是投资建议。