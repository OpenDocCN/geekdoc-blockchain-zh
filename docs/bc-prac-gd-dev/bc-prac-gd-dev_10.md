## 10 示例应用：区块链与投注

在本章中，我们将通过从头创建一个体育投注分布式应用（dapp）来查看区块链技术的实际应用。我们将：

•   设置完整的开发环境

•   详细编写并解释用于实现投注应用功能的以太坊 Solidity 代码

我们的 dapp 将模仿 PeerBet，一个开源的对等体育投注平台。如果你想查看我们即将实施代码的工作版本，PeerBet 的主代码仓库可以在 [`github.com/k26dr/peerbet`](https://github.com/k26dr/peerbet) 找到，而且一个工作实现可以在 peerbet.co 找到。为书中使用的简化版本设置了一个分支，可以在 [`github.com/k26dr/peerbet/tree/for-book`](https://github.com/k26dr/peerbet/tree/for-book) 找到。

### 什么是 Dapp？

Dapp 是指部署在如以太坊这样的区块链上的分布式应用或智能合约。与标准的 web 应用不同，分布式应用没有用来存储数据或执行计算的中心服务器。相反，所有的计算和数据存储都由区块链网络上的交易处理。这些交易由区块链对等网络中的每一个节点执行，数据也由网络中的每一个节点存储。因此，与中心化系统相比，dapp 更难以被审查和下架，这使它们成为中心服务器可能因法律或攻击者而被妥协的使用场景的理想选择。

并非所有区块链都能托管 dapps。例如，比特币区块链就不是为了处理托管真正 dapp 所需的通用目的计算而设计的。事实上，大多数区块链都无法处理 dapps。这是因为大多数区块链都是为了特定用例而设计的，比如比特币用于金融交易。

为了支持 dapps，区块链必须能够用图灵完备的编程语言编码交易。存在一个数学上严密的图灵完备性的正式定义，但对于我们的目的，将图灵完备语言定义为支持循环和条件语句的语言就足够了。JavaScript 和 Python 都是图灵完备语言的例子，而 SQL 和 XML 则不是。比特币使用一种自定义的脚本语言来清除交易，但故意设计为没有循环和条件语句，以避免与区块链上的图灵完备性相关的复杂性。脚本语言的功能越强，其“攻击面”也就越大——也就是说，它更容易受到安全漏洞和黑客攻击。

目前有两个主要的具有图灵完备交易语言的区块链：Hyperledger 和 Ethereum。Hyperledger 是一个需要权限的私有区块链（有关公共和私有区块链之间的区别，请参见第八章 Chapter 8，"Private Blockchain Use Cases"）。

市值最大的图灵完备公共区块链是以太坊，我们将使用它来托管我们的 dapp。以太坊使用一种极简主义的智能合约编程语言 Solidity 来开发合约。Solidity 编译器将 Solidity 代码转换为以太坊虚拟机（EVM）字节码。EVM 字节码实际上是在区块链上存储和执行的，但我们将全部开发工作都集中在 Solidity 上。EVM 还支持其他语言，如 Serpent 和 LLL（低级 Lisp-like 语言），但 Solidity 是最受欢迎的。

### 区块链上的彩票、投注与赌博简介

体育博彩应用已经在互联网上以各种形式存在。在欧洲和亚洲，像 Bet365 和 Bovada 这样的合法博彩公司提供在线体育投注，赔率由博彩公司设定。那么，区块链在投注方面的优势是什么？

大多数区块链应用是寻找问题的解决方案。今天，区块链是一种昂贵、低效且缓慢的计算和存储方式。随着技术的成熟，这种情况将发生变化。云服务器和存储提供的计算和存储能力比区块链要高出许多倍，成本却只是其一小部分。然而，区块链提供了一些特定的优势和特性。如果一个应用不能充分利用这些优势或受到这些优势的阻碍，那么应该使用传统的服务器技术来实现。

在决定在区块链上开发您的应用之前，请浏览以下列表，确保您的应用适合这项技术。

优点：

匿名、加密安全的身份验证

快速、无摩擦、匿名、低费用支付

不可审查的网络，100%的正常运行时间

公开可验证且保证的代码交易执行

不可变的数据存储

缺点：

有限的、昂贵的存储

有限的、昂贵的计算

缓慢的网络

有限的交易速率

合约代码部署不能超过区块的 gas 限制（约 1000 行）

其他可能适合或不适合的特性：

交易费用由用户支付，而不是合约所有者。

所有数据都是公开的。

一个清晰的应用例子，这类应用不适合区块链的是社交媒体应用。以下是典型社交媒体应用的一组需求和特性：

扩展到数百万用户

扩展到每秒数千个请求

大型代码库

大数据存储，用于生成广告洞察

用户期望服务是免费的

用户想要控制他们的数据

如果您逐一查看这些要求，它们中的每一个都与上面列出的区块链开发原则之一相矛盾。

现在让我们来看看投注应用程序。投注应用程序需要具备以下一些功能：

频繁处理付款

处理多种货币的跨国投注

避免某些国家的反赌博法律

•   保持投注两边资金平衡

•   可以选择匿名投注

•   提供可验证和一致的投注执行

提供有竞争力的赔率和费用

这些要求更适合区块链解决方案。在线投注最大的痛点之一是将资金通过电线和银行转账转移。用户必须等待三到五个工作日才能从银行账户存入或提取资金，并且必须信任投注网站掌握他们的银行信息。反过来，这些网站必须保护这些信息，采取适当的网络安全措施保护其网站免受黑客攻击，并遵守其在运营的各个国家实施的一系列金融法规。此外，在不同国家进行交易需要支持多种不同的货币和银行，所有这些都增加了运营的复杂性。

此外，许多投注者喜欢保持自己的匿名性，并依赖网站保护他们的身份信息。不幸的是，黑客经常设法获取这些数据，并可能使用它来勒索那些不想让他们的赌博债务公开的客户。

使用区块链解决方案允许投注者匿名投注，轻松跨境转账以支持国际投注网站，并保证他们的投注将及时支付。

那么让我们开始编写我们的点对点区块链投注 dapp 吧！

### 设置开发环境

在开始之前，我们将需要下载必要的工具。本节将涵盖 Windows、OS X 和基于 Debian 的 Linux 系统的安装过程。

为了设置一个合适的开发环境，我们将需要在我们的计算机上安装以下工具：

•   Mist 浏览器

•   Go Ethereum 命令行客户端（geth）

NodeJS + NPM

•   Google Chrome 浏览器

•   MetaMask Chrome 扩展

•   Solidity 编译器

Geth 与 Mist 浏览器捆绑在一起，两者都可以通过下载最新版本并遵循[`github.com/ethereum/mist/releases`](https://github.com/ethereum/mist/releases)上的安装说明进行安装。

NodeJS 和 NPM 可以通过遵循 NodeJS 官方网站上的说明进行安装，[`nodejs.org/en/download/`](https://nodejs.org/en/download/)。如果您正在运行 OS X 或 Linux，您还可以使用包管理器进行安装。

![Images](img/p0236-01.jpg)

MetaMask 目前只支持 Chrome 浏览器，因此你需要下载 Google Chrome 浏览器([`www.google.com/chrome/`](https://www.google.com/chrome/)).

安装 Chrome 之后，打开它并导航到 MetaMask 主页，[`metamask.io/`](https://metamask.io/)，以下载 Chrome 扩展/插件。

Solidity 编译器作为 NPM 包分发。要全局安装它：

`npm install -g solc`

### 同步 Ethereum 节点

在我们开始开发之前，我们需要在电脑上运行一个完整的、同步的 Ethereum 节点。与轻客户端不同，完整节点包含当前 Ethereum 状态树（区块链数据库）的完整副本，这样我们就可以对其运行交易。为此，请运行以下命令：

`geth`

Geth 将自动连接到主 Ethereum 网络（mainnet），找到对等端，并开始将区块链副本下载到我们的本地节点。同步过程可能需要数小时，通常最好让它整夜运行，并在早上检查，届时应该完成。节点同步完成后，我们可以开始开发我们的 dapp。

### 创建和配置私有开发链

为我们的投注 dapp 创建一个文件夹。我们所有的项目代码都将放在这个文件夹中。

为了能够在本地测试我们的代码，我们需要在电脑上运行一个私有区块链。这将允许我们部署、与之一致互动并迭代我们的合约，而不会污染主 Ethereum 网络，也无需不断支付交易费用。

正确设置私有测试网的命令有点冗长，所以我们创建一个文件来保存命令。打开一个名为 geth.sh 的文件，将其中的以下代码插入其中。此代码行旨在 Linux 机器上运行。OS X 用户应该将 ~/.ethereum 更改为 /Library/Ethereum，Windows 用户应该将其更改为 `%APPDATA%/Ethereum`。

![Images](img/p0237-01.jpg)

•   **`--dev`**   这个便捷选项可以启动一个新的私有链，为该链创建一个创世区块，并设置一系列调试标志。

•   **`--datadir`**   这允许我们指定一个自定义目录来存储链数据。默认目录用于主网，因此我们指定一个替代路径来存储我们的私有链。

•   **`--ipcpath`**   默认情况下，geth 将其进程间通信（IPC）文件存储在由 `--datadir` 指定的目录中。然而，Mist 浏览器只能与位于 `~/.ethereum/geth.ipc` 的 IPC 文件进行通信，因此我们必须指定这个作为我们的 IPC 路径。

•   **`--networkid`**   网络 ID 标志用于标识对等端哪个网络（主网、Ropsten 测试网、Morden 测试网等）我们的链是同步的。由于我们正在运行一个私有网络，我们指定一个随机的未使用网络 ID，以便对等端不会连接到我们。

•   **`--rpc`**  这个标志开启了 RPC（远程过程调用）模式，允许轻客户端和其他节点通过 JSON RPC API 访问我们的节点。这个标志是必需的，以便 web3.js 和我们前端可以访问我们的节点。

•   **`--rpcapi`**  默认情况下，RPC 模式启用了 web3、net 和 eth 模块。为了能够访问我们节点的账户和私钥来签署交易，我们将启用个人模块。

•   **`--rpccorsdomain`** 使用 JSON RPC API 的 Web 浏览器受到标准浏览器同源策略的限制。为了允许浏览器访问我们的 API，我们将 CORS 域名设置为尽可能宽泛的`“*”`（允许所有访问）。

•   **`--mine`**  挖矿我们自己的网络，以便处理交易和创建区块。通常，矿工会处理这个过程，但我们将不得不亲自为我们的私有链执行此操作。默认的`--dev`选项设置了一个网络挖矿难度，可以由单个 CPU 合理地挖矿。

•   **`console`**  这将会打开 geth 控制台，允许我们使用 JavaScript 命令直接与我们的节点和私有链交互。

一旦脚本创建并保存为 geth.sh，我们就可以直接执行文件来运行我们的私有链。确保文件可执行，然后运行它：

![Images](img/p0238-01.jpg)

你现在应该看到一系列日志输出，表明私有链正在运行并被挖矿。

### 创建一个可终止合约

在我们开始开发完整的合约之前，我们将开发一个小型测试合约，以确保我们的开发链正在运行，并且可以部署和调试合约。

所有我们的合约都将用 Solidity 编写，这是一种编译成以太坊虚拟机（EVM）字节码的智能合约语言。这个项目我们将只有一个.sol 文件，名为 bet.sol。

为了防止区块链膨胀并允许从区块链中删除旧的合约，大多数合约包括一个`kill`函数，允许合约所有者从区块链中删除合约。

一个简单的可终止合约的代码如下所示：

![Images](img/p0238-02.jpg)

让我们逐行回顾这个合约：

`contract Bet {`

合约关键字创建了一个随后的名称而去的合约。合约名称将在后面的步骤中需要，我们也将回过头来参考它。

`address owner;`

这创建了一个名为`owner`的类型为`address`的变量，并在合约存储中为其分配空间。

每个合约都有分配给它的存储和内存空间。存储变量存储在区块链上，更改会在网络中传播。内存变量是在函数执行期间创建的临时变量，在函数结束时销毁。它们不会存储在区块链上。我们将在本章后面看到内存变量的例子。

在全局作用域外声明的所有变量都是作为存储变量声明的。

`address`是 Solidity 特有的数据类型。它是一个 20 字节的字段，专门用于持有以太坊钱包和合约地址。

`function Bet() {`

在 Bet 合约中，`Bet`函数是一个特殊类型的函数，称为构造函数（同样，在 Bid 合约中，构造函数的名称将是`Bid`）。构造函数在合约部署到区块链上时立即执行，通常包含合约的设置逻辑和变量初始化。

`owner = msg.sender;`

Solidity 定义了一系列内置的便利函数和值。其中之一是`msg.sender`，这是一个包含发起当前函数调用的钱包或合约地址值的`address`变量。由于构造函数在合约部署时执行，`msg.sender`是合约的部署者。

`function kill() {`

这定义了一个公共函数（我们稍后讨论私有函数） named `kill`，可以不带任何参数调用。

`if (msg.sender != owner) throw;`

按照惯例，只有合约的所有者才被允许销毁它。如果其他任何人尝试销毁合约，这行代码将抛出一个错误。`throw`命令消耗传递给函数的所有燃料，以防止滥用。

有时你可能希望优雅地退出一个函数，而不强迫用户失去他们提供的所有燃料。这将在后面讨论。

`selfdestruct(owner);`

`selfdestruct`函数是内置于 Solidity 中的。从合约内部调用它将删除合约以及合约存储中的任何数据，然后将存储在合约地址中的任何以太币发送到提供的地址。在这种情况下，合约地址中不应该有任何以太币，但如果有人意外地将以太币发送到合约地址，我们可以将这笔钱发送给合约所有者。

### 编译合约

以太坊区块链只能存储和执行 EVM 字节码，因此为了部署或执行我们的 Solidity 代码，我们首先必须使用 Solidity 编译器将其转换为 EVM 字节码。要编译，运行：

`solc --bin --abi --optimize -o bin peerbet.sol`

我们调用的选项如下：

• `--bin`：在输出中包含一个字节码文件。这将是我们部署到区块链上的字节码。

• `--abi`：输出一个描述合约 ABI 接口的 JSON 文件。web3.js 使用它来简化与我们的已部署合约的交互。

• `--optimize`：运行优化以最小化合约的数据占用。这很重要，因为部署合约需要与字节码输出大小成比例的燃料。随着我们的合约越来越大，未优化的输出可能超过块燃料限制，使我们的合约无法部署。

• `-o`：为我们的字节码和 ABI 文件指定输出目录（bin/）。

`peerbet.sol`：我们希望编译的合约文件。

我们合约文件中存在的任何错误都会阻止编译并在输出中显示。修复你看到的任何错误并重新编译。如果从上一节正确复制了所有内容，你的代码应该可以编译。

编译器应该把两个文件输出到`bin`目录中：

![Images](img/p0240-01.jpg)

### 部署合约

既然我们已经编写了一个简单的可终止测试合约，让我们将其部署到我们的私有链上并尝试与它交互。在以太坊链上部署合约可能是一个复杂的操作，所以我们将会写一个小脚本来自动处理。脚本将需要 web3.js 库，所以让我们先安装这个然后再开始。

![Images](img/p0240-02.jpg)

这是我们基本部署脚本的样式。我们的脚本假设字节码和 ABI 已经编译到 bin/目录中。

![Images](img/p0240-03.jpg)

![Images](img/p0241-01.jpg)

这里有很多内容需要我们一步步来解析。

![Images](img/p0241-02.jpg)

这个开头的块需要必要的库。fs 和 child_process 库是 Node 内置的。

![Images](img/p0241-03.jpg)

web3.js 库需要一个暴露以太坊 JSON RPC API 的提供者。至此，我们应该有一个私有链在我们的命令行上同步并运行。此块连接到该节点，如果节点没有运行，将会失败。

![Images](img/p0241-04.jpg)

所有以太坊交易，包括合约部署，都必须源自一个钱包地址。此块访问我们的账户地址，然后解锁账户，以便用于部署交易。当我们创建私有链时，我们确保 RPC API 选项包含`personal`模块。如果没有这样做，我们将无法从我们的脚本中访问此节点上的账户。

`unlockAccount`函数的第二个参数是密码。由于你可能希望将此代码存储在 GitHub 或其他公共托管服务上，脚本设计为通过命令行参数接收密码。绝不要在任何情况下在源文件中包含你的密码。虽然这个密码在私有链上不能被恶意使用，但后来我们将在主网上使用相同的代码。具有暴露`personal` rpc 模块的节点暴露与此节点关联的所有公钥。阻止黑客使用你的私钥签署交易并窃取你所有的以太币的唯一东西就是你的密码，所以要相应地保护它！

`exec(`solc --bin --abi --optimize -o bin peerbet.sol`);`

通常我们希望同时编译和部署脚本，为此我们可以将编译步骤作为一个子进程包含在内。这一行是多余的。如果你愿意，可以分开编译和部署。

![Images](img/p0242-01.jpg)

web3 的合约对象可以方便地进行部署和合约交互。为了设置这个对象，我们读取 ABI 并将其传递给合约构造函数。

`var compiled = ’0x’ + fs.readFileSync(“bin/PeerBet.bin”);`

读取合约的十六进制（记住，十六进制只是二进制的另一种表示形式）字节码。web3.js 的一个特点是它要求所有的十六进制字符串都要以`’0x’`前缀，所以我们已经这样做了。

![Images](img/p0242-02.jpg)

合约对象上的`.new`函数用于部署合约。第一个参数是交易（`tx`）选项，第二个参数是一个回调函数。

`from`字段中指定的钱包地址必须是解锁的钱包，并且你必须有权访问该钱包的私钥。尝试使用私钥未存储在本地节点的公钥将失败。

合约创建交易的数据显示了合约的字节码。

我们目前设置了一个非常高的燃料限制，但实际消耗的燃料应该要低得多（< 5e5）。任何未使用的燃料都将退还，而燃料不足的交易将抛出 OutOfGasError，所以宁可设置得高一些也不要低。燃料限制通常以 100,000（1e5）为单位增加。当前每个区块的燃料限制设置为 47e5 燃料/区块，所以请确保您的燃料限制低于这个数字，否则您的交易将会失败。

Ethereum 中的默认燃料价格是 20e9。燃料价格通常以吉瓦韦（1e9 Wei，1e-9 以太币）为单位衡量。在私有网络中，这个数字没有意义。在主网上，这是真钱，所以你必须关注这个数字。交易可以用低至 1 Gwei 的燃料价格完成，但完成时间会变慢。矿工会优先处理他们区块中燃料价格最高的交易。

![Images](img/p0243-01.jpg)

这是部署函数的回调部分。当矿工尝试挖掘交易时执行此回调，它使用标准的 Node（错误，数据）参数格式。如果出现错误，我们记录它。如果没有错误，合约地址应该被设置，并且第二个`if`语句应该执行。为了用户的利益，我们将记录合约已被挖掘，然后将合约地址写入文件，以便我们稍后可以将其加载到 web3 中。

如果您上面的一切都理解了，现在就是部署合约的时候了。将文件保存为 deploy.js，然后在您的命令行中运行：

`node deploy.js [password]`

确保用您的钱包密钥密码替换`[password]`。合约部署可能需要长达一分钟的时间。部署完成后，日志输出将表明合约已被矿工处理。

恭喜您！您已将合约部署到私有开发网络。现在让我们编写一个与合约交互的脚本。

### 合约调试与交互

就像我们设置部署脚本一样，现在我们要设置一个调试脚本。为了拥有一个实时的调试环境，我们将使用 NPM 包 locus。让我们安装 locus：

`npm install locus --save`

安装完成后，我们就可以开始编写我们的脚本。以下是完整的脚本：

![Images](img/p0243-02.jpg)

![Images](img/p0244-01.jpg)

这个脚本中只有两个新的块，所以我们来分解一下。

![Images](img/p0244-02.jpg)

`web3`现有的合约构造函数需要一个 ABI 和合约地址。此块从文件系统加载这些内容，并创建合约对象。

`eval(require(’locus’))`

这创建了一个类似于 node 控制台但包含我们所有加载变量的活跃调试环境。

执行脚本来查看调试环境：

`node debug.js [password]`

你应该看到一个类似于这样的调试提示：

![Images](img/p0244-03.jpg)

Solidity 会自动为公共存储变量创建 getter 函数。在调试提示符中输入`contract.owner()`，它应该返回合约的地址。

我们现在可以直接与合约交互。让我们尝试使用我们之前定义的`kill`函数。

`tx = contract.kill({ from: walletAddress, gas: 40e5 })`

你可能会遇到一个错误，提示`Error: authentication needed: password or unlock`。这是因为你的钱包密钥上的密码已经过期。使用以下方法解锁你的账户。

![Images](img/p0244-05.jpg)

所有交易都遵循相同的格式。首先列出函数的参数，然后是一个`tx`选项对象。`kill`函数不接收任何参数，所以这里只有一个`tx`选项对象。

当使用 web3 合约对象时，`from`是唯一必需的`tx`选项。`data`是由库创建的（自己创建会比较复杂），`gasPrice`默认为 20e9，`gas`默认为 0.9e5。默认的`gas`值通常太低，无法执行合约交易，所以通常需要明确指定。

当一个合约交易被发送时，它会立即返回一个交易 ID，但交易实际上要在被挖掘后才会执行。在调试器中输入`tx`以查看交易 ID。要查看交易是否已经被挖掘，使用：

`web3.eth.getTransactionReceipt(tx)`

如果函数返回`null`，这意味着它还没有被挖掘。如果已经被挖掘，你将在控制台看到一个交易收据对象。

仅仅因为你看到一个收据，并不意味着函数已经正确执行。抛出错误或耗尽燃料的交易仍然会显示收据。你需要验证所请求的状态变化是否已经完成。

在这种情况下，Solidity 的`selfdestruct`函数通过将所有合约数据设置为 0 来删除所有合约数据。在调试器中检查`contract.owner`的值。如果你得到`0x`，合约已经成功销毁。

既然我们已经成功部署并销毁了一个简单的合约，是时候构建一个完整的投注合约了。

### 定义数据结构

在我们开始编写合同时，我们需要先定义必要的数据结构。图 10-1 展示了一个我们所希望的数据关系的大致流程图。

![图像](img/fig10-1.jpg)

**图 10-1   合同功能流程**

Solidity 使用结构体来组织相关数据片段。Solidity 结构体与 C 语言的结构体类似，包含一个名称和一系列成员定义。

我们现在使用 Solidity 结构体定义我们的数据结构，以便我们可以在应用程序中使用它们。

![图像](img/p0246-01.jpg)

我们的游戏结构体存储了关于游戏的一些信息、书籍映射（以防我们以后想添加更多书籍）和一个游戏结果。锁定期相当于游戏开始时间。在锁定期之后投注将被拒绝。

游戏状态是一个 Solidity 枚举，其功能与 C 枚举非常相似。我们将在本节的后面深入讨论枚举，并列出我们应用程序的枚举定义。

![图像](img/p0246-02.jpg)

游戏结果结构存储了每个球队的得分和一个时间戳。

![图像](img/p0246-03.jpg)

投注簿结构是基于正宗的拉斯维加斯投注簿设计的，包含高估、低估和投注。完整的 PeerBet 应用程序包含让分、金钱线和超过/低于投注簿，但我们的示例应用程序将只构建一个超过/低于投注簿。

超过和高估数组实际上将是有序的栈，以允许高效的投注配对。与 C 结构体不同，Solidity 结构体不能是递归的，因此它们不能用于定义递归数据结构，如链表或栈。取而代之的是，Solidity 允许动态长度的数组，因此我们必须使用那些数组。

由于投注和投注需要我们跟踪多个信息片段，我们将为它们定义结构体。

![图像](img/p0246-04.jpg)

![图像](img/p0247-01.jpg)

由于投注未配对，它们只包含一个地址字段。配对的投注有两方，投注簿结构中的每个字段都包含一个地址字段。

这些是我们将在应用程序中使用的所有结构体。除了结构体外，我们还希望定义几个枚举（`enum`）以使我们的代码更容易阅读。Solidity 中的枚举与 C 语言中的枚举类似，因为它们从不必要，总是可以用整数值替换，但它们对于可读性很有帮助。

### 枚举类型

我们在应用程序中将要使用的枚举如下：

![图像](img/p0247-02.jpg)

游戏在接受投注时为开放状态，锁定期过后为锁定状态，得分时为计分状态，支付投注时为已验证状态。

当结果未确定时，投注为开放状态；当结果已确定且参与者余额已更新时，投注为已支付状态。

### 存储变量

在 Solidity 合约中，存储变量必须在全局范围内显式定义。存储变量在以太坊状态树中使用空间，并且创建起来可能很昂贵，因此最小化合约存储变量的总大小很重要。

以下是我们要创建的存储变量：

![Images](img/p0247-03.jpg)

`owner`在我们之前编写的简单可终止合约中已经介绍过。

`games`是一个动态长度的 Game 结构体数组。它将负责大部分的存储空间，是我们主要的存储变量。自定义结构体不能公开，因此 games 将保持私有。作为提醒，Solidity 会自动为公共变量创建 getter ABI 函数，但不会为私有变量创建。

`balances`是一个存储用户余额的公共映射。用户可以随时从合约中提取他们余额的价值。Solidity 中的映射可能很棘手，因为没有方法可以在不将它们存储在另一个数组中确定映射的键。所以，给定一个地址，我们可以确定该地址的余额，但给定合约中持有的以太币数量，我们无法确定地址之间余额的分配。

### 事件

Solidity 事件用于将交易活动记录到区块链上。与状态树中新条目的创建相比，事件日志的创建要便宜得多，因此它是存储只读数据的好方法。日志不能从合约内部访问（只能访问变量），但可以被 web3.js 等外部客户端库读取。

Ethereum 交易是异步的，通常在它们被广播到网络后 15-30 秒内不会挖矿。因此，交易不能返回值。交易创建输出的唯一方式是修改状态或添加事件日志。客户端库通常解析日志以确定交易的输出。

Solidity 事件是日志的架构。日志会自动按合约地址和事件类型索引，以便高效查询。此外，Solidity 事件允许你定义三个自定义索引字段。只有索引字段在解析日志时才能查询。目前，不能解析字符串索引的值，因此避免创建字符串索引的最佳实践。

以下是我们在合约中要使用的日志：

![Images](img/p0248-01.jpg)

每个可能在我们合约中发生的主要状态修改都有一个相关的事件。它们一起为合约在区块链上采取的行动提供了一个历史记录。

### 函数

在我们深入代码之前，让我们创建一个我们将在应用程序中定义的函数列表。函数和变量一样，可以是公共的或私有的。公共函数可以被其他合约和客户端库（如 web3.js）访问，并作为 ABI 的一部分列出。私有函数只能被同一合约中的其他函数访问。

此外，还有常量函数，它们读取区块链但不会修改区块链。公共常量函数立即返回其结果，不将交易发送到网络，并且在调用时不会消耗任何燃料。

下面是我们将要定义的公共非常量 ABI 函数：

![Images](img/p0249-01.jpg)

可支付函数是指可以在`tx`选项对象中接受非零`value`的函数。

下面是我们将要定义的公共常量函数：

![Images](img/p0249-02.jpg)

常量函数返回一个必须用上述语法指定的类型的值。

此外，我们将为我们的内部使用定义一些私有函数：

![Images](img/p0249-03.jpg)

**注意**   默认情况下，函数定义中的变量被认为是内存变量。为了指定变量是指向状态树中现有存储变量的指针，它必须像上面这样明确地声明为`Bid[] storage stack`和`Game storage`。

让我们逐一解释每个函数并解释代码：

#### 创建游戏

![Images](img/p0249-04.jpg)

![Images](img/p0250-01.jpg)

函数定义指定函数返回一个 int，尽管我们提到非常量公共函数不返回值，因为它们在区块被挖掘之前不会执行。我们仍然包含一个返回值的原因是为了调试目的。调用公共函数有三种方式。

![Images](img/p0250-02.jpg)

当我们调用一个非常量函数时，它返回的值就像一个常量函数一样。它运行矿工在交易中会运行的确切步骤，但不会更新状态树或广播交易，所以它非常适合调试。抛出错误的调用返回返回类型的零/null 值。所以对于一个 int 返回类型，错误将返回 0。根据约定，我们将在所有函数中返回-1，以表示函数执行没有错误，并使用正整数来表示错误代码。

创建游戏需要我们传入游戏参数（`home,` `away,` `category,` `locktime`）。锁时间是自 UNIX 纪元以来的秒数。

我们首先从全局计数器创建一个 id，然后增加全局计数器，以确保我们的 id 保持唯一。接着，我们将游戏数组的长度扩展 1，以容纳我们的新游戏，获取对新创建游戏的引用，并在新游戏对象上填写适当的属性。

一旦游戏被创建，我们将发出一个 GameCreated 事件，记录我们刚刚执行的状态修改，并返回-1，表示没有错误。

#### 出价

![Images](img/p0250-03.jpg)

![Images](img/p0251-01.jpg)

要出价，客户端必须提供他们希望出价的游戏的 game_id，他们要下注的赌注方向（超过或低于），以及他们想要下注的线程限制。超过的出价将在或低于限制时匹配，低于的出价将在或高于线时匹配。

该函数是`payable`的，因此客户端可以发送一个`value`随交易一起发送。对于这个函数，这个`value`将被解释为出价金额。发送到可支付的 Solidity 函数的值可以在内置的`msg.value`变量中找到。

这个函数比`createGame`函数要复杂，所以让我们逐步解释它：

![Images](img/p0251-02.jpg)

这部分从存储中获取所需的游戏，并在内存中创建一个临时的出价。`msg.sender`包含签署并发送交易的钱包/合约的地址，而`msg.value`是一个`uint`变量，包含以 wei（1e-18 以太币）为单位发送到函数的以太币值。

结构体变量默认初始化为存储指针，但结构体构造器总是返回内存指针。不指定`Bid` `memory`，变量赋值将抛出编译器错误，指出值和变量的类型不匹配。

`getGameById`是我们将用来获取特定游戏指针的助手函数。以下是`getGameById`函数的代码：

![Images](img/p0251-03.jpg)

![Images](img/p0252-01.jpg)

我们已经将该函数定义为私有和常量。它之所以是常量，是因为它不会修改状态。它也必须定义为私有，因为公共函数不允许返回自定义结构体。返回类型必须指定为`Game storage`，因为函数定义默认为内存作为变量位置，而我们希望指向的游戏包含在状态树中的存储中。

该函数遍历游戏数组，查找匹配的游戏 ID。它维护一个标志，如果数组中存在匹配的游戏，则设置为真。如果游戏存在，它返回游戏存储指针。

如果游戏不存在，它会抛出错误。`throw`关键字结束当前函数和当前交易的执行。当前交易期间所做的任何更改都将被回滚，并且所有提供给交易的 gas 都将被消耗并给予矿工。

![Images](img/p0252-02.jpg)

游戏状态必须是开放状态才能接受投注。此外，当游戏已经过了锁定时间时，它的状态仍然可以设置为开放。在这种情况下，我们锁定游戏并取消所有开放的出价。这两个验证都返回错误代码。

`now`是一个内置变量，设置为当前区块的 UNIX 时间戳值。这不会与交易发送的时间相同。

`cancelOpenBids`是一个私有助手函数，用于取消并退款市场上的未匹配出价。以下是该函数的代码：

![Images](img/p0252-03.jpg)

![Images](img/p0253-01.jpg)

参数对这个函数来说必须是存储指针。如果它是内存指针，我们将在本地内存中删除项目，而不是在状态树中。

我们首先通过循环遍历`over bids`并退还出价，通过将出价金额添加到出价者的余额来实现。我们不需要担心初始化键。

在 Solidity 映射中的键被转换为一个 32 字节的地址，该地址指向以太坊状态树中的一个位置，其底层数据结构为 Patricia 字典树。这个 32 字节的地址是通过计算一系列值的 keccak256 散列生成的，包括合约地址、变量地址和映射键。如果 32 字节的地址在 Patricia 字典树中不存在，则假设其值为对应类型的空值。由于`balances`的类型为`mapping(address => uint)`，可以假设所有地址最初都被设置为`uint`类型的空值，即 0。

一旦开放出价被退还，`overBids`数组就会被删除。`delete`关键字通过将其从状态树中移除，将变量设置为其空值。动态数组的空值是一个长度为 0 的数组，所以`overBids`现在是一个长度为 0 的数组。

然后对`underBids`数组执行相同的操作。

`Bid memory remainingBid = matchExistingBids(bid, game_id);`

一旦出价被验证，处理它的第一步是与现有出价匹配。

以下是`matchExistingBids`帮助函数的代码：

![图片](img/p0253-02.jpg)

![图片](img/p0254-01.jpg)

这是一个很长的函数，它遍历出价的另一方的栈，匹配并删除尽可能多的出价，并记录它放置的每一注。然后返回一个剩余未匹配金额的出价，以便稍后添加到正确的栈中。

让我们也分解这个函数：

![图片](img/p0254-02.jpg)

我们首先获取游戏存储的指针，并确定我们将要匹配哪个栈。上出价将匹配下栈，下出价将匹配上栈。

![图片](img/p0254-03.jpg)

我们将假设数组已经按栈的顺序排列好，最优的待处理出价（对于上栈是最高出价，对于下栈是最低出价）位于栈底。参见图 10-2 栈的排列。我们从栈底开始循环，通过设置迭代变量`i`。我们想要继续循环直到迭代器越界，在这种情况下，迭代器将为负数。为了实现这一点，我们必须使用`int`而不是`uint`，因为`uint`在变为负数时表现出未定义行为，并且永远不会表示小于零的值。然而，数组索引访问需要`uint`，因此在我们进入循环并验证迭代器不为负数后，我们创建了一个`uint`版本的迭代器`j`。

![图片](img/fig10-2.jpg)

**图 10-2   出价栈结构**

![图片](img/p0254-04.jpg)

接下来，我们通过检查出价是否已经匹配来验证堆叠出价。匹配的出价将有一个金额为 0。在大多数语言中，我们会通过从堆叠中删除它们来摆脱匹配的出价。不幸的是，我们的堆叠是数组而不是链表，因为 Solidity 不允许递归数据结构，所以删除一个项目需要重写很多内容，并且将是一个昂贵的操作。为了最小化燃料成本，我们将保留堆叠中的匹配出价，并在插入新出价时尽可能地覆盖它们。

![Images](img/p0255-01.jpg)

堆叠的退出条件如下：

对于超额出价，如果出价行小于堆叠迭代器指向的不足行，则退出循环。因为不足的堆叠是按行递增的，一旦遇到一个太高无法匹配的不足行，所有高于它的行也将太高无法匹配。

对于不足出价，正好相反。如果出价行大于堆叠迭代器指向的超额行，则退出循环。所有高于它的行也将太低无法匹配。

![Images](img/p0255-02.jpg)

如果确定退出条件不满足，我们有一个有效的可以匹配的出价。出价金额将是堆叠出价金额和出价金额中的较低者。出价金额从堆叠出价和当前出价中减去。如果当前出价金额低于堆叠出价，减去后出价金额将为 0，循环条件在下次迭代中将无法满足。如果堆叠出价较低，剩余出价将大于 0，循环将继续。

![Images](img/p0255-03.jpg)

![Images](img/p0256-01.jpg)

一旦下注，就必须将其加入堆叠并记录在适当的事件中。为了使用户更容易解析日志，BetPlaced 事件为每个用户调用两次。

![Images](img/p0256-02.jpg)

递减迭代变量，并继续循环。循环完成后，返回剩余的出价，以便将其添加到相应的出价堆叠中。

一旦出价匹配完成，我们返回到原始的出价函数并将出价加入堆叠。

![Images](img/p0256-03.jpg)

如果剩余的出价金额为 0，则此代码块不会执行。如果不止如此，出价将加入堆叠。超额和不足的出价以不同的方式加入。第三个参数表示堆叠将按顺序排序：超额时最高行在底部，不足时最低行在底部。一旦放置出价，我们就会发出一个事件，将动作记录在链上。

让我们看看`addBidToStack`助手函数是如何工作的：

![Images](img/p0256-04.jpg)

![Images](img/p0257-01.jpg)

这可能是整个合约中最复杂的函数，因为它需要我们维护一个可以双向排序的堆栈，向该堆栈添加项目，并在可能的情况下替换已经匹配的出价，而不是尽可能地延长堆栈长度。

我们之前提到，通过延长堆栈长度或从堆栈中删除项目来添加出价是非常昂贵的操作。必须为状态树中的项目分配或销毁空间，然后必须重新编写插入/删除索引下方的堆栈中的每个项目，因此每次调整大小时必须修改大量状态。通常，使用链表会使这些操作变得不那么昂贵，但 Solidity 不允许递归数据结构，因此这个选项对我们来说不可用。

为了避免执行昂贵的删除操作，我们在出价匹配时将剩余金额为 0 的出价留在了堆栈中。现在我们将执行优化的第二部分，通过尽可能地重写金额为 0 的出价而不是延长数组来完成。让我们一步步来看：

![Images](img/p0257-02.jpg)

我们需要指定要插入的出价、应插入的堆栈以及堆栈是按正常顺序还是逆序排序。对于我们来说，正常顺序是指最低出价在底部，逆序顺序是指最高出价在底部。

![Images](img/p0258-01.jpg)

这是一个简单的情况。如果堆栈中没有项目，那么就没有必要进行排序或重写过程，只需将项目添加到堆栈中并返回。

![Images](img/p0258-02.jpg)

在将项目插入排序堆栈之前，我们需要确定插入应该发生的索引。对于逆序堆栈，我们从底部开始，向上遍历堆栈，同时出价线小于堆栈线。对于正常堆栈，我们从底部开始，向上遍历堆栈，同时出价线大于堆栈线。

![Images](img/p0258-03.jpg)

通常，我们会将插入索引下方的所有项目向下移动，为新的排序堆栈中的项目腾出空间，但因为创建额外存储是一个昂贵的操作，我们将尝试找到一个空出价（`bid.amount` == 0）并覆盖它。

首先检查插入索引上方的槽位是否为空出价。如果是，则不需要移动任何内容，我们可以用新出价覆盖那个出价，并退出函数。接下来，我们从插入索引开始向下遍历堆栈，尝试找到第一个空出价。当我们找到时，我们退出循环。如果没有空出价，我们在到达堆栈末尾时将退出循环。

![Images](img/p0258-04.jpg)

![Images](img/p0259-01.jpg)

如果插入索引下方的堆栈中没有空出价，我们需要将堆栈长度扩展 1。从插入索引正上方开始，一直到 shift 索引，我们将所有出价向下一格移动。这将覆盖 shift 索引处的出价，并在插入索引处打开一个格子，然后我们插入当前的出价。

#### 评分比赛和支付

一旦比赛开始并且投注关闭，比赛结果可以通过使用`setGameResult`函数来设置，该比赛由比赛创建者来设置：

![Images](img/p0259-02.jpg)

这个函数为指定比赛设置主队和客队的比分。这个函数的第一部分执行一系列验证。比赛必须已经过了锁定时间且还没有被评分。如果这些验证失败中的任何一项，将返回一个错误代码。

所有在记分牌上的开放出价都被取消。`cancelOpenBids`辅助函数在出价部分已经解释。主队和客队的比分在存储中更新，比赛状态更新，支付出注，并记录事件，表示比赛已被评分。

`payBets`辅助函数看起来像这样：

![Images](img/p0259-03.jpg)

![Images](img/p0260-01.jpg)

这个函数首先使用比赛结果计算总得分。然后它遍历每个投注。如果投注已经被支付，它跳过这个投注并移动到下一个。这不应该发生，但为了防止未来版本的代码对同一比赛调用此函数两次，已经包含。如果计算得分的总和大于投注线，则将两倍的投注金额添加到过度投注的地址。如果计算得分的总和小于投注线，则将两倍的投注金额添加到投注不足的地址。如果得分的总数和投注线相同，则将投注的双方退款投注金额。一旦投注被支付，投注状态被标记为已支付。

#### 提现

一旦投注被解决并且用户余额已经被更新，获胜用户将想要提取他们的钱。`withdraw`函数允许他们这样做。

![Images](img/p0260-02.jpg)

提现时，我们从`balances`映射中检索用户余额并存储在一个临时变量中。然后我们将用户的余额清零并将以太币发送到他们的钱包。如果发送失败，我们将退款到他们的余额并返回一个错误代码。如果发送成功，我们记录事件。

这个函数中逻辑的顺序*非常*重要。臭名昭著的 DAO 攻击是由于这个提现实现中的一个未知的虫子引起的。零用户余额然后如果发送失败再退款似乎有点效率低下。这样做的原因是调用`withdraw`函数的实体可能是一个合约。合约可以定义一个回退函数，当找不到匹配的 ABI 函数时作为默认动作执行。如果攻击者的合约定义了一个可支付的回退函数，该函数对我们的合约执行另一个提现，并且余额没有被清零，它可以反复执行提现直到我们的合约余额被耗尽。这就是 DAO 攻击者能够从 DAO 合约中提取所有资金的方式。

#### 阅读游戏

我们需要一种方法让前端从区块链上读取活跃游戏。这样做是一个两步过程，因为我们不能在公共 ABI 函数中直接返回一个自定义结构体。相反，我们要做的是从合约中获取一个活跃游戏 ID 列表，然后解析游戏详情日志。

以下是过程的第一步的合约 ABI 函数。第二步将在前端部分介绍。

![Images](img/p0261-01.jpg)

该函数创建一个初始化为游戏数组长度的空内存数组。我们使用内存数组而不是存储数组，因为这是一个常量函数，意味着它不能修改存储。我们遍历游戏并把每个 ID 添加到内存数组中，然后返回该数组。

#### 阅读出价

每个放置的出价都会改变订单簿，因此我们需要一种获取订单簿当前快照的方法。不幸的是，日志在这里对我们并没有太大用处，因为放置的出价可以被匹配并删除，所以记录的出价可能已经不存在了。为了获取当前书籍视图，我们必须从合约中直接返回出价。不幸的是，如前所述，我们不能直接在 ABI 中返回自定义结构体。所以，我们打算运行一个临时修改，返回一个包含信息的字节数组，然后在前端将字节数组解析回出价数组。

这里是将出价编码成字节数组的合约函数。

![Images](img/p0261-02.jpg)

![Images](img/p0262-01.jpg)

让我们分解这段代码，因为它有些地方变得复杂。

![Images](img/p0262-02.jpg)

该函数是常量，以表示它不会修改存储。首先，我们获取一个指向游戏的存储指针。然后我们计算书籍中出价的总数，并使用该数目在内存中分配一个字节数组。`bytes`是动态大小字节数组的数据类型。还有一个迭代变量`k`也被初始化了。这个迭代变量将指向正在写入的字节数组中的当前索引。每次向字节数组写入一个字节，我们都会增加迭代器。

![Images](img/p0262-03.jpg)

遍历所有出价，确定当前出价是在过账还是未过账的栈中。

![图片](img/p0262-04.jpg)

![图片](img/p0263-01.jpg)

将每个出价属性转换为其字节表示形式。bytesxx 数据类型为所有值定义到 32（bytes2，bytes3 等）以及单个`byte`。接下来，遍历每个字节表示形式并将它们添加到主字节数组中，逐字节。

一旦所有出价都已编码并连接，我们返回字节数组。稍后我们将介绍如何在客户端解析字节数组为 JavaScript 对象。现在定义一个数据字典来描述出字节结构按字节索引（参见表 10-1）。

**表 10-1** 出字节结构

![图片](img/tab10-1.jpg)

### 摘要

在本章中，我们已经介绍了基于以太坊构建的全功能投注应用的开发生命周期。主要关注的是使用 Solidity 进行编码。下一章，我们将部署合约并开发一个简单的前端来运行应用。
