© 克里斯·丹南 2017 克里斯·丹南《介绍以太坊和 Solidity》10.1007/978-1-4842-2535-6_4

# 4. Solidity 编程

克里斯·丹南^(1 )(1)美国纽约布鲁克林 Solidity 是一种新的编程语言，用于编写称为智能合约的程序，可以由以太坊虚拟机（EVM）运行。这种新语言是来自网络、汇编语言和 Web 开发的传统的大杂烩。想象一下，你在另一个国家的海滩上。你一时冲动来到这里，并且在机场匆匆走过货币兑换柜台，想着在访问期间可以使用信用卡或借记卡——不需要现金。在你匆忙中，你忘记带太阳镜了。一个在海滩上走动的小贩有一副恰好是你的款式的太阳镜。事实上，它们比你记得在机场免税区经过的那几副还要好。不幸的是，他没有信用卡读卡器——只有他的安卓手机——而你也没有当地货币。他给了你一张小卡片，上面写着一个电子邮件地址和一个电话号码，以防你以后想买眼镜。稍微想想这种情况，你就会明白基于协议的数字货币的威力。为什么你可以给这个人发短信或电子邮件，甚至给他打电话，但你不能用同样的方式给他发钱？

## 入门指南

前一章描述了 EVM 如何转换状态，在本章中，您将了解到 EVM 可以处理什么样的指令，以及它在进行状态转换时。总的来说，计算环境是一个无限循环，重复执行系统程序计数器中当前的操作。（在程序计数器中跳过队列是 JUMP 操作码名称的由来。）程序计数器逐个迭代，直到达到特定程序的结尾。只有当遇到（抛出）错误，或者遇到指示机器停止或返回结果或值的指令时，机器才会退出执行循环。这些操作可以访问三种类型的空间来存储数据：

+   栈，一个容器，可以添加或移除值（推入或弹出）。栈值在方法内定义。

+   动态内存，也称为堆，是一个可以无限扩展的字节数组。当程序结束时，它会重置。

+   一个键/值存储用于账户余额，以及在合约地址的情况下，Solidity 代码。

Solidity 合约也可以访问关于传入消息的某些属性，例如传入消息的价值、发送者和数据，以及区块头中的数据。

## 全球银行业变得（几乎）真实

世界各地的银行都拥有计算机系统，尽管已经升级并且大部分是现代化的，但它们仍是互联网甚至万维网出现之前的机器的后代。因此，它们的架构被设计成是孤立的。没有单一的全球银行网络，而是一堆相互连接的国家系统和私人银行软件堆栈，每个都有自己的怪癖。

### 额外大型基础设施

一个系统，比如以太坊，有着遍布全球的节点，由私人个体运营，他们以以太币形式的挖矿费用为自己的活动获得报酬。这是第六章的主题。该系统高度去中心化。因此，加密货币协议有能力将金融交易提升到我们现在享受的与电信一样的便利水平。那么，去中心化的对等节点系统如何“运行”“程序”呢？

### 全球货币？

正如你所看到的，普遍加密货币的理念似乎是建立在这样一个假设上：地球上的每个人最终都会在他们的手机上下载一个加密货币钱包。然而，这样的白日梦并非以太坊的路线图。相反，以太坊核心开发者选择了让第三方轻松创建辅助货币，或自定义代币，这些代币将被品牌化并用于特殊目的（类似于今天的信用卡奖励积分）。这些第三方（无论是现有的公司、初创公司、市政当局、大学还是非政府组织）可以依靠公共链或大型许可链来推动许多不同类型的代币，就像全球银行系统能够处理许多不同货币一样。大多数人第一次接触以太币的可能性不大是出于加密货币实验的目的。更有可能的是，他们最终会持有数字代币或积分作为品牌忠诚计划、大学计划或雇主赞助计划的一部分。体育场馆、主题公园、城市夏令营、购物中心、大型办公园区——任何地方都有一个社区在交换货币，辅助货币可能是合理的。

## 辅助货币

一个国家为什么需要不止一种货币？在建立美国现今的中央银行——美联储的几十年之前，许多地方货币在流通。这些纸币通常代表着某处的金库，因此具有地方性；如果兑现机构在数千英里之外，那么金的凭证就毫无价值。在广泛的、系统性的私人货币系统普及之前（美国历史上被称为野猫银行时代），许多印刷厂主要通过印刷带有各种防伪特征的货币来与竞争对手的印刷厂竞争。本杰明·富兰克林就是这样一个印刷商，他通过印刷辅助货币而致富。事实上，他以超越寻常的防伪措施而闻名。根据史密森尼学会的说法，他一次印刷了一张宾夕法尼亚地方货币，其中州名拼写错误，希望能够破坏那些认为那些钞票一定是假的伪钞者。富兰克林的许多殖民时期的钞票上都印有“伪造即死”的字样。辅助货币这一术语指的是一种在国家法定货币旁辅助运转的交换媒介，满足了国家货币无法满足的需求。这些货币通常有四个目的：

+   促进小社区内的地方经济发展

+   在社区中建立社会资本

+   培育更可持续的生活方式

+   满足主流货币无法满足的需求

Solidity 编程允许任何人创建一个辅助货币，只需一个简单的代币合约。这些代币可以具备任何场景需要的参数，当你在第五章部署代币合约时，就会看到。

### Solidity 的承诺

Solidity 是一种高级的面向合约的语言，与 JavaScript 和 C 语言相似。它允许你开发合约并编译为 EVM 字节码。目前，它是以太坊的旗舰语言。虽然它是为 EVM 编写的最流行的语言库，但它并不是第一个，也可能不是最后一个。以太坊协议中有四种语言处于同一抽象级别，但社区逐渐收敛于 Solidity，这使得 Serpent（类似于 Python）、Lisp-Like Language (LLL) 和已被弃用的 Mutan 落后于它。学习 Solidity 使您能在任何基于以太坊的系统中传递价值令牌。由于以太坊和 Solidity 本身是免费且开源技术，聪明的头脑很可能会修改并重新发布它，或者私下部署它。事实上，已经有几个团体做到了这一点；您将在第十一章中了解这些第三方及其方法。您可以在 [`solidity.readthedocs.io/en/develop/index.html`](http://solidity.readthedocs.io/en/develop/index.html) 找到官方的 Solidity 文档。但其他网站也提供了有用的 Solidity 文档。为了方便起见，所有最受欢迎的 Solidity 文档都链接在 [`solidity.eth.guide`](http://solidity.eth.guide) 子域名下。

### 浏览器编译器

测试 Solidity 最常见的方式是使用基于浏览器的编译器。可以在 [`ethereum.github.io/browser-solidity`](http://ethereum.github.io/browser-solidity) 找到它。为了快速查阅，你也可以在 [`compiler.eth.guide`](http://compiler.eth.guide) 找到它。如果你已经读到这里，你可能已经对如何学习 Solidity 感到好奇了。虽然如果你已经掌握其他编程语言，开始在 Solidity 中编程会更容易，但如果你是非程序员，也不要因此感到泄气。

## 学习 EVM 编程

有时候，学习一个新习惯比改掉一个旧习惯更容易。分布式应用程序编程中的许多惯例可能会让今天的 Web 和本地应用程序程序员感到奇怪或古怪。此外，他们可能已经在其他语言或主题领域投入了职业或个人兴趣。因此，如果你刚刚开始，不要觉得整个世界都领先于你。在以太坊的世界里，现在依然是早期阶段。在我们继续的过程中，会定义关键编程术语，并且你将从上下文中学到很多。尝试查看一本面向初学者的 JavaScript 书籍（[`​www.​apress.​com/​us/​book/​9781484217863`](http://www.apress.com/us/book/9781484217863)），深入了解本章核心概念。新手编程人员可以在没有预先假设的情况下接触以太坊。更好的是，他们会发现一个系统，他们（诚然，需要一些时间）可以从头到尾理解。并非所有的黑客，甚至软件工程师，都了解其应用托管提供程序下面层的网络的复杂性。在传统的 Web 应用程序中，你有许多带有数据库的个体服务器，它们通过网络进行通信和共享数据。这些数据可能会被其他服务器上的应用程序操纵。甚至可能还有更多的服务器混合在一起来平衡需求的激增。一个服务器是一台按照特定的角色行事的计算机，作为通过 Web 提供给人们的某种服务的一部分。一些服务器在所谓的数据库中保存数据（考虑信息的电子表格，比如客户姓名和地址）。一些服务器运行其他计算机可以通过网络访问的应用程序。在以太坊中，网络就是数据库，这个网络可以运行所有人都可以使用的应用程序。所以你最终会对这三个方面有相当多的了解。当你知道底层发生了什么时，观察区块链浏览器报告新的交易是一种奇迹。虽然学习以太坊可能看起来是很多工作，但要理解今天的 Web 的广度和深度将需要更多的工作。以下小节提出了你应该开始尝试使用 Solidity 的其他原因。

### 简单部署

在以太坊中，你不一定需要费心部署和扩展一个普通的 Web 应用程序。所有需要的智能合约都可以整洁地打包在几个文件中，然后发送到以太虚拟机（EVM），嗖地一声——你的程序就立即对安装了以太坊钱包或命令行节点的地球上的任何人可用了。今天，开发者可能想要构建“混合”以太坊 dapp，这些 dapp 可以通过普通的 Web 浏览器访问，这种情况下添加以太支付只是增加了更多工作量。但到了网络完全成熟的 2-3 年后，使用以太坊协议托管应用程序的所有组件将变得更加容易。请注意：在业务术语中，价值时间（TTV）是指从客户提出请求到客户获得请求物品的时间。这个物品可以是有形的或无形的。但是低 TTV 意味着很容易想出一个产品或服务并迅速交付给想要使用它的人。在以太坊中，开发和部署不可更改、始终可用、无法审查的应用程序，以实时价值在任意距离上移动，是快速且廉价的（尽管还不容易）。一切都是免费的，除了由你的程序生成的燃气成本，以及你自己的时间（和计算机）。对于软件工程师、服务提供商、系统管理员和产品经理来说，在以太坊生态系统中工作的长期影响意味着更少脆弱的系统、更快的产品迭代，以及大大减少为支持新应用程序或服务开发基础设施的时间。简而言之，这可能会大幅减少企业软件供应商和内部团队的 TTV。

### 在 Solidity 中编写业务逻辑的理由

由于其新颖的特性，以太坊在 2017 年及以后的命运并不完全取决于当今以太坊客户端的主流普及或采用。相反，它依赖于受开发者、品牌、企业、组织、政府和其他有能力为其社区创建以太坊代币的人的欢迎程度，甚至是他们自己的品牌钱包。他们可能出于快速、安全地推出超低开销的新产品和服务的利益而这么做。这也适用于大型营销活动，今天必须比以往更快地部署，以跟上互联网迷因文化的速度。加密网络中支付的无摩擦性使得为客户建立无缝的销售和营销体验比以往任何时候都更容易，其中包含支付功能。补充货币也是用于奖励计划、会员俱乐部和大型零售区的非常有价值的工具。以品牌硬币形式持有资金的客户往往更经常在该品牌上消费，就像今天的常旅客忠于给予他们最大回报的航空里程和信用卡积分计划一样。今天，忠诚计划可能会有些模糊甚至有点欺诈。但基于区块链的忠诚代币的透明性将使其与任何其他形式的加密货币一样优秀——这意味着它可能会在交易所上交易或被其他方接受作为支付。

### 代码，部署，放松

许多以太坊启用的应用程序可以通过 Mist 钱包或另一个在幕后运行节点的以太坊原生应用程序使用。对于客户端应用程序的开发人员来说，添加对新的基于以太坊的代币的兼容性是微不足道的，这意味着以太坊钱包和代币之间将存在高度重叠和互操作性，就像今天有许多 IMAP 和 POP 兼容的电子邮件客户端一样。今天也可以通过一点工作创建一个可以通过常规旧 Web 访问的以太坊程序。然而，使用新的第三方框架将使部署变得越来越容易，其中一些示例在第八章中提供。但是，这并不意味着传统的 Web 应用程序会消失。许多个人和组织在传统 Web 应用程序中投入了巨大的资源。也就是说，以太坊网络使得在大规模上推出和运行应用程序变得更加容易和便宜，正如你将看到的，这诱使越来越多的团队考虑去中心化他们的应用程序。

## 设计原理

Solidity 编程语言的语法类似于 JavaScript，但它专门设计用于编译成以太坊虚拟机的字节码。正如在第三章中所指出的，EVM 运行的代码是完全确定性的；相同的算法在相同的输入下总是产生相同的结果。你可以通过数学证明这一点，正如你将在本章后面看到的。Solidity 是静态类型的，支持继承、库和复杂的用户定义类型等特性。有意识地使用类型可以帮助程序员了解他们的程序将如何执行。Solidity 中的类型列表在本章末尾给出。注意数据类型正是它们听起来的样子。程序员可以选择告诉机器期望的数据类型：例如，它将是一个数字还是一串字母？松散类型的语言不要求程序员具体说明；而强类型的语言则需要。有趣的是，在 Solidity 中你可以内联编写汇编代码。如果你喜欢使用 EVM 列在第三章中的操作码之一执行特定操作，你可以在你的 Solidity 合约中内联执行。只需写上 `assembly {...}`，在其中放置你的代码，以取代 Solidity 语句。

### 在 Solidity 中编写循环

循环是编程中控制流的基础，即对“如果-那么”的编码化和对“在做这个的同时做那个”的并发的规范化。在大多数编程语言中，循环都以类似的语法启动。在循环方面，Solidity 遵循与 JavaScript 和 C 相同的语法规则。迭代器循环是一种使程序员能够遍历容器或列表的对象。有时，迭代器用于指示计算机执行相同操作一定次数，或在代码中的一些元素上执行操作。通用循环在 JavaScript、C 和 Solidity 中具有相同的语法。它指示计算机从 0 计数到 10：`for (i = 0; i < 10; i++) {...}`。如果你仔细查看了前一章中的操作码列表，你可能会注意到 EVM 允许两种方式的循环。你可以在 Solidity 中编写循环，也可以使用 JUMP 和 JUMPI 指令创建循环。这会在程序计数器中向前跳跃指定的步数。请记住，程序计数器会跟踪在 EVM 上执行给定程序时计算步骤的数量和顺序。这只是 Solidity 和 EVM 操作码可以结合使用以创建一个大部分具有表达力和可读性，但运行成本又较低的合约的一种方式。需要指出的是，由于天然气价格的计算方式，某些功能可能更容易强制执行或更便宜地执行，如果使用操作码编写的话，这尤其有用，特别是如果你正在编写自己的语言库。如果你以前从未认真看过代码，并且这个循环概念很难理解，那么现在不要着急；接下来的章节会提供更多的背景信息。

### 表达力与安全性

在计算机科学中，形容词“表达性”（expressive）用来指代容易让人类程序员编写和理解的代码。表达性语言是人类思维模式和机器执行模式之间的桥梁。要使一种语言具有表达性，它的各种构造必须直观易读，并且其样板代码（如关键词、特殊变量和操作码）必须使用人类可读的单词，以帮助程序员记住它们所代表的含义。表达性语言在运行之前必须被编译成更适合机器的形式，这需要计算机的工作。毕竟，表达性语言往往更难推理（更难预测行为），而更受限制、更低级别、更不抽象的语言则使得推理更容易。最后的前沿是可以轻松进行形式验证的智能合约，同时也可以用表达性高级语言（如 Solidity）编写。这个问题需要自动化解决，事实上，自动化形式验证现在已经在望——这是计算机科学家必定会为之兴奋的事实，以及以太坊开发人员将无意中受益于此。

## 形式证明的重要性

如果你学习 Solidity 编程，你可能会遇到其他开发者的好奇，他们会直截了当地问：你如何防止某人写入无限循环并锁住机器？这绝非一个小众的争论，这是与当今世界软件工程角色相关的最重要问题：人类能否制造一个自由、开放可访问的虚拟计算机，其他人无法破坏？如果答案是肯定的，那么它就是对“共有资源悲剧”理论的鲜明反驳。

### 共享全球资源的历史影响

在经济学中，公地悲剧是一个共享资源无法长久存在的概念。最终，以自身利益为出发点的用户会耗尽资源，因为对他们来说这没有任何成本。这种情景，即某人可以在外部化成本的同时充实自己或挥霍浪费资源，被称为道德风险。举个例子：2016 年底，纽约市政府在曼哈顿下城的街道上安装了计算终端。这些终端为路过的行人提供免费的 Wi-Fi。然而，这些终端也配备了一个小触摸屏，可以提供即时的上网服务。就在这些共享资源刚刚投入使用之后，人们便纷纷拉椅子坐下，观看 YouTube 或色情内容，徘徊数小时。⁴项目管理人员不得不迅速限制屏幕上的互联网访问，现在这些终端主要用作 Wi-Fi 热点。因此，像以太坊虚拟机这样的极为廉价的公共计算机观念简直是太棒了。任何人，任何计算机，任何地方都可以访问它，并将来可以长期运行程序。它没有任何所有者，也没有人能篡改它。它甚至可以为你存储资金。

### 攻击者如何摧毁社区

去中心化经济代表着对全球各种私人既得利益的一种新兴威胁，尤其是在发展中国家，那里的有权势的人更希望世界继续存在着“公地悲剧”（因此，仍然任由最新的专制者或疯狂的暴民摆布）。以太坊网络的安全性是第七章的主题。但以太坊的防御措施无处不在，甚至包括编程语言本身，因此在这里提及是必要的。在本讨论中，你可以将网络视为通过计算机互相连接的人群社区。攻击者是指那些憎恶这个群体，并试图以任何代价使他们感到痛苦的人。

### 用 Solidity 编写的假想攻击

假设一个攻击者想要用 Solidity 编写的超内存密集型智能合约锁定 EVM。 攻击者愿意支付气体成本，无论多么大。（这是一个真实的场景，你将在第七章中看到。）请记住，为了本例，合约也可以用为 EVM 创建的任何语言编写，比如 Serpent，甚至是更低级别的 EVM 代码，不仅限于 Solidity。根据 Rice 定理，一些计算机程序的行为特性在数学上是不可判定的，这意味着不可能编写另一个计算机程序，可以明确预测你展示给它的 Solidity 代码是否会终止。⁵因此，在这种情况下，没有办法编写任何有效的“守门员”程序，来击落攻击者可能编写的理论上耗费大量内存的智能合约。请注意，智能合约与分布式应用程序（dapp）不同，尽管两者都是分布式且类似应用程序。dapp 是一个使用以太坊智能合约作为后端的 GUI 应用程序，而不是传统数据库和 Web 应用程序托管提供商。dapp 可通过 Mist 浏览器或通过 Web 访问。EVM 以各种方式处理这一现实，包括每个区块的计算步骤的硬性限制、其确定性语言和气体成本。然而，如果存在财务激励，攻击者总是会探索灰色地带，而在 10 亿美元的市值下，破解 EVM 并窃取以太币的激励是相当大的。虽然灰色地带不能一下子消失，但可以通过一系列的协议分叉来处理。至于意外破坏性程序，这取决于以太社区开发出有利于简单易证明的合同发展为样板标准的模式和实践。第五章介绍了其中一些最佳实践。

## 自动证明能否解救困境？

尽管不可能创建一个可以排除不良程序的门卫，但通过使用可机器检验的证明——一种数学上证明其他程序的自动化程序，生产可证明正确的程序变得越来越可行。由于智能合约涉及资金流动，它们成为自动化数学证明的极好实验对象。这一计算机科学和数学研究领域的目标是以系统化的方式确保源代码满足某些形式化规范。这是独立审计员进来并数学验证程序实际上是否正在执行其预期功能的一种方法。自动化证明过程对企业是一个福音，但对于学习 Solidity 的普通程序员来说并没有太大帮助。证明仅仅向你展示你的意图是否实际上在程序中发生了。如果你的程序不能证明出来，自动化系统就没有办法告诉你如何更好地编写它。尽管如此，探讨这个话题的目的是为了表明以太坊网络确实有一天可能会承载大量自动化资金流动的机器人，推动着数万亿美元的安全流动；并且开发这些机器人可能并不像今天一样缓慢、风险高、晦涩难懂。

### 实践中的确定性

结合前面章节的概念，你可以看到，在某些方面，图灵完备性的整个概念可能是一个理想化的概念，在设计现实世界中的公共系统时具有有限的用处。因此，可以说，在实践中，以太坊虚拟机并不真正是图灵完备的，因为在 Solidity 合约中的执行的有限性可能很快就能使理论上预测以太坊虚拟机将运行的任何程序的行为成为可能。比特币也没有摆脱这些问题。存在于表达性语言和机器语言之间的灰色地带也存在于比特币的脚本语言中，该语言在运行时也编译成机器代码。

### 翻译中迷失

有趣的是，证明的问题与先前在本章中讨论的表达性概念有很大关系。人类只能在高级别的抽象语言上执行数学证明，即人类可读的编程语言，如 Solidity。在汇编代码或机器码上执行这样的证明，即使是最专注的数学思维，也几乎不可能。编译过程——将人类可读代码传输为较低级别的机器码——牺牲了大量（人类可解释的）关于如何推理程序的信息。它还牺牲了对自动定理证明器有用的信息。因此，始终会引入一些模糊性到这个过程中。今天，即使是用 Solidity 编写的经数学证明的智能合约在编译后仍然是可证的，你也无法完全确定。

## 测试，测试，测试

防止模糊代码让您损失资金的方法是进行大量测试。以太坊网络配备了一个称为 Ropsten 的测试网络，使用虚拟以太币，这些以太币不花钱，并且可以在类似沙箱的环境中快速地从水龙头中提取。实际上，Ropsten 与主链没有任何区别。它只是一个被指定用于测试的不同链。就像泰坦尼克号和它的姐妹船不同名字一样，它们是相同的，正如其他任何由某人启动的链一样。这些链没有什么特别或神圣的地方；你将在第八章中创建与它们完全相同的链。

### 命令行可选！

Ethereum 的大部分重要功能都可以在 Mist 钱包中完成：发送和接收以太币、跟踪代币以及部署合约。对于打算学习编写 DApp 的开发者来说，使用 Geth（或其他命令行客户端）是一个不错的选择。第六章更详细地介绍了 Geth。在本节中，我们将简要地查看一个真实的智能合约，以探索一个简单示例，展示智能合约的使用方式。如果你不会阅读或编写代码，不要担心。在这个例子之后会有一个关于语法和结构的教程，帮助你理解代码在做什么。在下一章中，我们将部署一个标准的以太坊代币，而无需编写任何代码。你将在第五章学习如何部署这样的合约。你会高兴地发现，使用 Solidity 部署一个简单的合约只有三个要求：

1.  1.诸如 macOS 上的 TextEdit、Ubuntu 上的 Gedit 或 Windows 上的 Notepad 之类的文本编辑器。请确保切换到纯文本模式，以删除所有字体、下划线、粗体、超链接和斜体。（永远不要使用富文本编写代码！）

1.  2.在第二章中介绍的 Mist 钱包。

1.  3.位于 [`ethereum.github.io/browser-solidity/`](https://ethereum.github.io/browser-solidity/) 的浏览器 Solidity 编译器，或者通过以下短链接获取：

http://compiler.eth.guide 正如我们将在第五章中演示的那样，“上传”合约所需的全部工作就是将你的 Solidity 代码从文本编辑应用程序复制粘贴到 Solidity 浏览器编译器中。从那里，你将代码编译成字节码，然后将该字节码复制粘贴到 Mist 中。这真的非常简单，但让我们暂时不要被细节问题困扰。相反，我们将检查下面的示例智能合约的行为，以便你开始领会自动发送和接收资金的合约的潜力。以下示例最初由肯塔基州软件工程师和以太坊爱好者 Cyrus Adkisson（GitHub 上的 fivedogit）撰写。它已经为本书做了调整。你将命名此合约为 PiggyBank，使用 CapsCase（而不是 camelCase），符合 Solidity 命名约定。你可以在[`solidity.readthedocs.io/en/develop/style-guide.html`](http://solidity.readthedocs.io/en/develop/style-guide.html)找到这些命名约定以及其他 Solidity 风格指南。现在，让我们看看 PiggyBank.sol：contract PiggyBank {       address creator;       uint deposits;// 将此函数声明为 public 使其对其他用户和智能合约可访问。       function PiggyBank() public       {           creator = msg.sender;           deposits = 0;       }// 检查是否存入了任何以太。存入时，存款数会增加，并返回总计数       function deposit() payable returns (uint)       {           if(msg.value > 0)                deposits = deposits + 1;           return getNumberOfDeposits();       }       function getNumberOfDeposits() constant returns (uint)       {           return deposits;       }// 当实例化此合约的外部账户再次调用它时，它会终止并将余额发送回。       function kill()       {           if (msg.sender == creator)               selfdestruct(creator);       }}你可以在[`solidity.eth.guide`](http://solidity.eth.guide)找到适用于各种技能水平和能力的程序员的更多 Solidity 脚本示例。

## 格式化 Solidity 文件

前述合约示例缺少一个重要细节。每个 Solidity 文件都应该（但不是必须）有一个版本声明，即指示该合约是使用哪个 Solidity 版本编写的语句。随着时间的推移，这应该可以防止较旧的合约被未来版本的编译器拒绝。此文件的版本声明为 0.4.7，因此您应该将以下内容添加到文件头部：`pragma solidity ⁰.4.7;`。有关 Solidity 文件结构的更多信息，请参阅 [`solidity.readthedocs.io/en/develop/layout-of-source-files.html`](http://solidity.readthedocs.io/en/develop/layout-of-source-files.html) 。

## 阅读代码的提示

这里有七个事实，这将使这个合约对初学者更易读：

+   计算机从上到下、从左到右读取代码，就像英语讲者一样。通常，将一行放在另一行之前意味着计算机将首先看到该指令。

+   通常，程序接受一个输入并返回某种输出。可计算函数（计算机可以执行的数学函数）被定义为可以编写为算法的函数。

+   算法接受数据，对其进行操作，并返回某种输出。程序是具有其他算法嵌套在其中的算法。

+   算法就像一台机器：您可以多次重复使用它。因此，编写算法指令——编程——会让您觉得很像写填空游戏，稍后计算机将使用用户（或以太坊中的合约）提供的信息（通过交易或消息调用）自动填写信息。有时，这些信息只是一个数字（例如，5 以太）。

+   运算符是英文单词之间的符号，例如等号、加号和减号。这些通常按照您的预期工作，但也有一些例外。您可以在表 4-1 中查看 Solidity 运算符。

    | 优先级 | 描述 | 运算符 |
    | --- | --- | --- |
    | 1 | 后缀递增和递减 | ++, -- |
    | 函数调用 | <func>(<args...>) |
    | 数组下标 | <array>[<index>] |
    | 成员访问 | <object>.<member> |
    | 括号 | (<statement>) |
    | 2 | 前缀递增和递减 | ++, -- |
    | 一元加和减 | +, - |
    | 一元操作 | delete |
    | 逻辑非 | ! |
    | 位非 | ∼ |
    | 3 | 指数运算 | ** |
    | 4 | 乘法、除法和取模 | *, /, % |
    | 5 | 加法和减法 | +, - |
    | 6 | 位移操作符 | <<, >> |
    | 7 | 位与 | & |
    | 8 | 位异或 | ^ |
    | 9 | 位或 | &#124; |
    | 10 | 不等运算符 | <, >, <=, >= |
    | 11 | 相等运算符，不相等运算符 | ==, != |
    | 12 | 逻辑与 | && |
    | 13 | 逻辑或 | &#124;&#124; |
    | 14 | 三元运算符 | <conditional> ? <if-true> : <if-false> |
    | 15 | 赋值运算符 | =, &#124;=, ^=, &=, <<=, >>=, +=, -=, *=, /=, %= |
    | 16 | 逗号操作符 | , |

+   类型是计算机编程中的名词。因此，当你看到一个类型时，你知道在 Mad Lib 的那个空间中允许什么。在 Solidity 中的一个常见类型是地址。

计算机最初的用途是快速进行数学计算。几十年来，使用计算机的人主要是物理学家，他们想要解决一些难题，比如：什么时间和日期最适合发射阿波罗 11 号，以便它到达月球的距离最短？EVM 更接近于这种最初的计算机，但它更适合思考复杂的会计和财务对账，就像你可能通过在 Microsoft Excel 中编写电子表格来学习一样。记住，数据库本身就是电子表格，计算机程序操作这些数据库。因此，当你声明某些内容时，你在告诉计算机把它放入电子表格中——具体地说，是放入堆栈中。计算机将自行确定需要准备多少内存来存储任何临时的、或者所谓的动态计算的值——用于计算诸如 if-then 这样的情况的关键逻辑语句。（重要的是要定义堆栈和堆，以便看到内存占用过多的危险在哪里：即要求计算机使用超出其可用的动态内存。）

## Solidity 中的语句和表达式

正如你将看到的，Solidity 中到处都是函数。然而，它们以不同的方式使用。一些函数产生一个值，比如一个数字，或者对一个真/假问题的回答。这个值究竟是什么由 Solidity 的类型决定，之前提到过；真/假值称为布尔值。

### 什么是表达式？

产生值的函数被称为表达式函数。因为表达式评估为某种类型的值，所以在编程中它们可以用来代替值。其他函数是声明式的，并导致在计算机内存中创建专用空间，每次运行此例程时将使用该空间。这些声明式函数很重要，因为它们对编写语句至关重要。

### 什么是语句？

粗略而言，语句告诉计算机执行动作。计算机使用表达式来弄清楚如何以及何时执行此操作。因此，计算机程序由语句组成，语句通常由表达式（或其他语句）组成。

### 函数，公共和私有

在 JavaScript 和 Solidity 中，您可以使用分号来链接语句，并告诉计算机代码中即将出现另一个语句：function first(); function second()在 Solidity 中，您还可以声明您是否希望某些函数在该程序外部可用。这些指定如下：

+   public：外部和内部可见（为存储/状态变量创建一个访问器函数）

+   私有：仅在当前合约中可见（默认）

注意：在 Solidity 代码中编写的函数默认不是公共的。您必须在创建它们时将它们声明为公共，否则它们将无法在其外部合约中使用。虽然这只是对代码识字的简介，但应该足以让您开始解码我们稍后将讨论的某些智能合约在做什么。

## 值类型

在编写 Solidity 代码时，您可以告诉计算机在每个算法指令中期望什么类型的值。本节描述了 EVM 可以解释的值类型。

### 布尔值

在代码中称为布尔值，布尔值是评估为 true 或 false 的 true/false 表达式。

### 有符号整数和无符号整数

在代码中称为 int 和 uint，它们是数字。如果具有符号，则可以为负数，或者带有减号，表示它们是有符号的。因此，无符号整数是正数。

### 地址

地址类型保存一个 20 字节的值，这是以太坊地址的大小（40 个十六进制字符，或 160 位）。地址类型也有成员类型。

### 地址的成员

这两个成员允许您查询账户的余额，或者向账户转账以太。在智能合约中使用转账时要小心。最好使用允许收款人提取资金的模式，而不是由合约发起转账。

+   余额

+   转账

### 与地址相关的关键字

关键字是 Solidity 语言的一部分。它们是一种方法，可以说，用于以预定的方式使用语言。您可以在代码中使用这些关键字来完成智能合约中需要的常见任务。这些包括以下内容：

+   <address>.balance (uint256): 返回 wei 中[地址](http://solidity.readthedocs.io/en/develop/types.html)的余额

+   <address>.send(uint256 amount) 返回 (bool): 将指定数量的 wei 发送到[地址](http://solidity.readthedocs.io/en/develop/types.html)，失败时返回 false

+   this(当前合约的类型)：显式转换为地址

+   selfdestruct(address recipient): 销毁当前合约，将其资金发送到给定的[地址](http://solidity.readthedocs.io/en/develop/types.html)

注意：可以使用关键字 this.balance 查询当前合约的余额。

### 不常见的值类型

如果您已经是高级或中级程序员，则还有其他几种值类型可能会有用：

+   动态大小的字节数组

+   固定点数

+   有理数和整数字面量

+   字符串字面量

+   十六进制字面量

+   枚举

### 复杂（引用）类型

一般来说，Solidity 中的类型在以太坊虚拟机的存储中被分配了 256 位的内存；即 2,048 个字符。比这更长的类型可能会产生更大的燃料成本来移动。您需要仔细选择在以太坊虚拟机的堆栈中分配永久存储的类型。以下是超过 256 位的复杂类型：

+   数组

+   数组字面量 / 内联数组

+   结构体

+   映射

数组、结构体和其他复杂类型具有数据位置，Solidity 程序员可以使用该位置来操作它们是动态存储在内存中还是永久存储。这可以帮助您管理费用。

## 全局特殊变量、单位和函数

全局特殊变量可以被以太坊虚拟机上的任何 Solidity 智能合约调用；它们是内置于语言中的。它们中的大多数返回有关以太坊链的信息。时间单位和以太币也是全局可用的。字面数字可以带有 wei、finney、szabo 或 ether 后缀，并且可以在以太的子单位之间自动转换。没有后缀的以太币数字被视为 Wei。时间相关的后缀可以用于字面数字后，以在时间单位之间进行转换。这里，秒是基本单位，并且单位被视为一般单位。由于闰年的存在，请注意在使用这些后缀计算时间时要小心，因为不是所有年份都有 365 天，也不是所有天都有 24 小时。1 == 1 秒 1 分钟 == 60 秒 1 小时 == 60 分钟 1 天 == 24 小时 1 周 = 7 天 1 年 = 365 天

### 区块和交易属性

请注意，这些全局变量仅在 Solidity 智能合约中可用。这些不应与您在 Geth 中可以进行的 JavaScript Dapp API 调用混淆，您将在第六章中了解有关此内容。

+   block.blockhash(uint 区块编号) 返回 (字节 32): 给定区块的哈希，仅适用于最近的 256 个区块

+   block.coinbase (地址): 当前区块的矿工地址

+   block.difficulty (整数): 当前区块难度

+   block.gaslimit（uint）：当前区块的燃气限制

+   block.number（uint）：当前区块编号

+   block.timestamp（uint）：当前区块时间戳

+   msg.data（bytes）：完整的调用数据

+   msg.gas（uint）：剩余的燃气

+   msg.sender（address）：消息的发送者（当前调用）

+   msg.sig（bytes4）：调用数据的前 4 个字节（函数标识符）

+   msg.value（uint）：随消息发送的 wei 数量

+   now（uint）：当前区块时间戳（别名为 block.timestamp）

+   tx.gasprice（uint）：交易的燃气价格

+   tx.origin（address）：交易的发送者（完整的调用链）请注意，所有 msg 的成员的值（即 msg.sender 和 msg.value）在每次外部函数调用时都可能更改，即使它们是库函数。如果您希望对 msg.sender 的使用进行访问限制的库函数的实现，那么您将需要手动提供 msg.sender 的值作为参数。

### 操作符速查表

表格 4-1 展示了你可以在 Solidity 表达式中使用的操作符。

### 全局函数

一般来说，在 Solidity 中，特殊函数主要用于提供关于区块链的信息，但有些也可以执行数学和密码学函数。它们如下：

+   keccak256(...)返回（bytes32）：计算（紧密打包的）参数的以太坊-SHA-3（Keccak-256）哈希

+   sha3(...)返回（bytes32）：keccak256（）的别名

+   sha256(...)返回（bytes32）：计算（紧密打包的）参数的 SHA-256 哈希。“紧密打包”意味着参数是在不添加填充的情况下连接的。要查看如何向参数添加填充，请参阅以下 URL：[`solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions`](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions) 。

+   ripemd160(...)返回（bytes20）：计算（紧密打包的）参数的 RIPEMD-160 哈希

+   ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)：从椭圆曲线签名中恢复与公钥关联的地址，在错误时返回 0

+   addmod(uint x, uint y, uint k) returns (uint)：计算（x + y）% k，其中加法精确计算且不会在 2**256 处截断

+   mulmod(uint x, uint y, uint k) returns (uint)：计算（x * y）% k，其中乘法精确计算且不会在 2**256 处截断

+   this（当前合同的类型）：当前合同，可明确转换为其地址。还值得一提的是，在编写 Solidity 合同时可能有用的与合同相关的变量：

+   super：继承层次结构中较高一级的合同。有关继承的更多信息，请参见下文中的链接。

+   selfdestruct(address recipient)：销毁当前合同，将其资金发送到给定地址

+   assert(bool condition)：如果条件不满足，则抛出异常。

+   revert()：中止执行并恢复状态更改

### 异常和继承

某些情况会自动引发异常。要查看所有情况，请访问[`exceptions.eth.guide`](http://exceptions.eth.guide)。Solidity 语言还支持多重继承。即使合同从多个其他合同继承，区块链上也只创建一个合同，基础合同中的代码始终会复制到最终合同中。有关一般继承系统的详细信息，请参阅[`solidity.readthedocs.io/en/develop/contracts.html#inheritance`](http://solidity.readthedocs.io/en/develop/contracts.html#inheritance)。

## 概述

在本章中，你迈出了理解为 EVM 编写的程序影响的第一步。您还对这些程序如何在不牺牲网络安全的情况下实现一定程度的图灵完备性进行了批判性审视。我们只是简要涉及了使这些程序对企业信息技术如此令人兴奋的形式化数学。但幸运的是，您已经看到足够的动力，深入研究以太坊白皮书和黄皮书，并亲自了解 EVM 如何达到可证实的共识。在第五章中，您将在 EVM 上部署您的第一个令牌合约。您还将了解货币工具的社会和文化历史，以及这对您对以太坊潜力的理解意味着什么。脚注 1 史密森尼教育，“革命性货币”，[`www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html`](http://www.smithsonianeducation.org/educators/lesson_plans/revolutionary_money/introduction.html)，2016 年。2 维基百科，“伪造货币”，[`en.wikipedia.org/wiki/Counterfeit_money`](https://en.wikipedia.org/wiki/Counterfeit_money)，2016 年。3Investopedia，“互补货币”，[www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp](http://www.investopedia.com/articles/economics/11/introduction-complementary-currencies.asp)，2016 年。4《纽约时报》，“纽约的免费 Wi-Fi 亭将停用互联网浏览器”，[www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0](http://www.nytimes.com/2016/09/15/nyregion/internet-browsers-to-be-disabled-on-new-yorks-free-wi-fi-kiosks.html?_r=0)，2016 年。5 维基百科，“赖斯定理”，[`en.wikipedia.org/wiki/Rice%27s_theorem`](https://en.wikipedia.org/wiki/Rice%27s_theorem)，2016 年。
