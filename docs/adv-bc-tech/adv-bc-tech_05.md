© 作者（们），在 Springer Nature Switzerland AG 2022 年独家许可 Y. Maleh 等人（编辑）用于智能物联网技术的区块链技术的进展物联网技术，通信和计算[`doi.org/10.1007/978-3-030-93646-4_5`](https://doi.org/10.1007/978-3-030-93646-4_5)

# 隐私保护 *k*-均值聚类在基于区块链的加密 IoMT 数据上

Rakib Ul Haque^(1, 2  ), A. S. M. Touhidul Hasan^(3, 4  ), Tasnia Nishat^(5  ) 和 Md Akhtaruzzaman Adnan^(6  )(1)中国科学院大学计算机科学与技术学院，中国北京(2)达卡自动化研究与工程学院，孟加拉国达卡(3)亚太大学计算机科学与工程系，孟加拉国达卡(4)达卡自动化研究与工程学院，孟加拉国达卡(5)Daraz 孟加拉有限公司，孟加拉国达卡(6)亚太大学计算机科学与工程系，孟加拉国达卡 Rakib Ul Haque 电子邮件：rakibulhaqueraj@mails.ucas.ac.cnA. S. M. Touhidul Hasan （通讯作者）电子邮件：touhid@uap-bd.eduTasnia Nishat 电子邮件：nishat.tasnia@daraz.com.bdMd Akhtaruzzaman Adnan 电子邮件：adnan.cse@uap-bd.edu 关键词隐私真实性区块链物联网全同态加密系统

## 1 引言

在现代医疗保健领域，一种迅速崛起的技术是物联网医疗（IoMT）[1]，它基于不断从健康监测设备收集的大量数据。软件应用程序和医疗设备结合起来提供健康服务和构建医疗保健系统[2]。可以创建一系列独立设备用于远程患者监测[3]。将互联网连接的健康设备与患者信息和基于传感器的工具（如可穿戴设备）相结合，最终建立了 IoMT 的生态系统[4]。IoMT 可以生成、存储、调查或传输医疗数据或图像到医疗服务提供商的网络，并将数据保留到内部数据库或云存储库[5]。这种在医疗设备和传感器之间的连接是医疗工作流程管理的流线化，并导致医疗保健的整体改善。IoMT 设备在诊断方面表现出更高的准确性，确保错误更少，但成本更低。如今，多样化的机器学习（ML）[6, 7]算法被用来训练这些大量数据，以构建预测模型。

训练各种 ML 模型所需的数据集通常来自诸如医疗服务提供商或医院等实体。为了使 ML 模型分类器能够以更高的准确性产生预测结果，除了数据量之外，数据样本的独特性至关重要[8]。这可以通过使用统一来自各种实体收集的不同样本集的过程来有效实现。但是，许多实体通常不同意提供其用于训练的数据集，因为存在许多隐私问题。最常见的问题涉及所有权、数据完整性和数据隐私[9]。在训练阶段，来自 IoMT 设备的医疗数据由其他关联方处理，或者可能被篡改，导致敏感和私人数据的隐私丢失。在数据共享期间，未经授权的数据修改，即通过改变或篡改进行的潜在侵入者，可能降低数据完整性，导致 ML 模型分类错误。许多关联方在复制或重用共享数据集时可能会丢失数据提供者的所有权权限。

过去处理数据隐私问题的方法是使用加密和差分隐私（DP）[10]。而加密方法繁重且耗时，差分隐私不保证数据效用。为了确保数据效用，这项工作聚焦于加密方法[11]。最近关于密码学 ML 方法的研究在空间和时间上都很昂贵。在 ML 方法中，*k*-均值是最简单和最轻量级的无监督算法之一，但过去的*k*-均值工作并未解决所有隐私问题。这些方法缺乏数据真实性。

为了解决这些问题，本研究提出了安全*k*-均值。采用部分同态加密方法 Paillier 与区块链技术。每个数据所有者的 IoMT 数据都使用 Paillier 进行加密，然后记录在分布式分类账上。开发了安全的构建模块，以处理具有加密数据的分类任务，即安全多项式运算（SPO）（加法/减法）和安全比较（SC）。无需信任的第三方。安全*k*-均值可以使用*k*-均值分类器，在准确性损失不明显的情况下比其他密码学方法更快。

本文的其余部分安排如下。第 2 和第三部分分别描述了相关工作和预备知识。系统概述和模型构建概述在第 4 和第五部分中概述。第六部分表示实验和结果评估。最后，在第七部分中对本文进行了总结。

## 2 相关工作

许多研究关注使用各种方法解决隐私问题，例如，加密[12]、差分隐私[13]以及以保护隐私的方式发布数据[14–17]，其中加密和差分隐私耗时并且提供的数据效用较低。相反，ML 训练并未考虑在保护隐私的数据发布中。此外，这些方法在数据共享时无法保留数据所有者和数据分析师的信息。最近保护数据所有者在训练 ML 技术时的隐私解决方案包括安全支持向量机（SVM）[18]、安全*k*-最近邻居（*k*-nn）[19, 20]和安全线性回归（LR）[21]。所有这些方法都将区块链整合到 ML 训练中，以加密 IoMT 数据，并保留与数据所有者和数据分析师的任何交易相关的信息。这些方法达到了与标准 SVM、*k*-nn 和 LR 最接近的正确性。然而，安全 SVM、安全*k*-nn 和安全 LR 需要进行多次比较和计算，从而导致分析健康数据的空间和时间复杂性增加。

先前对安全的*k*-means 的研究主要集中在任何特定领域[22]，一些并不考虑区块链[23]，而仅有少数研究使用区块链[24–28]。它们都不够通用，因为它们基于特定设置，并且未能解决与数据完整性、真实性和隐私相关的所有隐私问题。在这项研究中，将部分同态（Paillier）的加密系统与区块链技术结合起来，以解决使用 IoMT 所有者数据的*k*-means 分类器时所涉及的上述问题。Paillier 被用来加密各个数据所有者的 IoMT 数据。使用不可变的分布式账本来记录所有交易。仅当与各个数据所有者相关联后，数据分析人员才能使用安全的*k*-means 来获取加密数据。没有参与者可以从区块链中推断其他参与者的原始数据，因为仅保存了交易的哈希值。SPO 和 SC 被用作*k*-means 中加密数据的多项式计算的安全协议。这些也被视为安全构建模块，不需要可信的第三方。所提出的方法在最小损失精度的情况下实现了更高的效率。

## 3 初步工作

在本节中，将呈现所有背景技术和数学方程式。数据集*D*有*m*条记录，其中*x* [*i*]和*y* [*i*]是第*i*个属性，在分类后它们被赋予标签*l* [*i*]。距离*d*表示两点之间的间隔，而*k*-means 的模型参数为![$$\sum _{i=1}^{k}$$](img/513458_1_En_5_Chapter_TeX_IEq1.png) ![$$(c_{x_{i}}, c_{y_{i}})$$](img/513458_1_En_5_Chapter_TeX_IEq2.png)。符号*P*代表数据所有者，*A*分别代表数据分析师。在 Paillier 下的加密消息表示为[[*m*]]。

### 同态加密系统

三种方法共同开发了密码系统：密钥生成（*KeyGen*）、数据加密（*Enc*）、数据解密（*Dec*）。（*PK*；*SK*）是一对密钥，称为（公钥；私钥），用于公钥密码系统。这些密钥对用于加密和解密。如果一个密码系统的特征可以在不知道解密密钥的情况下将计算映射到相应的明文，则该密码系统可以是同态的。在提出的模型中，基于 Paillier 进行多项式运算（安全数学加法和减法）。*p*，*q*和*N*是*n*位素数，其中，*N*  =  *p* *q*。公钥和私钥分别用*N*和（*N*，*ϕ*(*N*)）表示。^(1) Paillier 的加密函数为*c* := [[(1 + *N*)^(*m*) *r* ^(*N*) *mod* *N* ²]]，解密函数为*m* ∈ *Z*[*N*]和![

$$m:=[[\frac {[c^{\phi (N)}\;mod\; N^{2}-1]}{N}\; \times \; \phi (N)^{-1} \; mod \; N]]$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq6.png)。Paillier 在[11]中进行了详细讨论。

### 区块链

区块链是一系列不断扩展的交易列表，称为区块，利用密码学连接和保护[29]。为了避免单点故障，区块链采用点对点（P2P）架构。共识机制确保了对区块和交易的强大而明确的控制。它还确保了区块链分布式节点之间的一致性和完整性，即，可审计性、完整性和去中心化。

+   公共区块链（比特币和以太坊）。

+   联盟区块链（超级账本，瑞波）。

+   私有区块链。区块链作为智能合约的托管和执行平台。

### *k*-均值算法

*k*-均值[30]是一种无监督的机器学习算法，主要用于分类任务。为了识别质心![$$(c_{x_{j}},c_{y{{ }_j}})$$](img/513458_1_En_5_Chapter_TeX_IEq7.png)距离*d*的计算是必要的。识别距离的常用方法是欧几里得*d*[*e*]（方程（1））、曼哈顿*d*[*m*]（方程（2））等。在这项研究中，我们将使用曼哈顿*d*[*m*]。设(*x*[1]，*y*[1])，(*x*[2]，*y*[2])，…，(*x*[*n*]，*y*[*n*])  ∈ *D*。![$$\displaystyle \begin{aligned} d_{e} = \sqrt{(c_{x_{j}}-x_{i})^{2}+(c_{y_{j}}-y_{i})^{2}} \end{aligned} $$](img/513458_1_En_5_Chapter_TeX_Equ1.png)(1)![$$\displaystyle \begin{aligned} d_{m} = |(c_{x_{j}}-x_{i})|+|(c_{y_{j}}-y_{i})| \end{aligned} $$](img/513458_1_En_5_Chapter_TeX_Equ2.png)(2)

## 4 系统概述

本节讨论与系统、威胁和安全定义相关的模型。

### 系统模型

所提出的模型的目标是确保*A*和*P*之间的隐私和保护数据共享。*A*从每个*P*那里获得加密的 IoMT 数据。所有共享的数据都记录在区块链的分布式账本中，通过形成交易以保持真实性。*A*通过从区块链的公共账本获取记录的数据来组装其 Ml 模型（*k*-means）。*A*利用保护性构建模块（SC 和 SPO）建立了一种受保护的方法。在使用安全 ML 模型时，重要的是*A*和*P*之间有适度的互动以分享中间结果。在共享中间数据进行比较时，*P*会添加微小偏差*δ*。这降低了模型逆推攻击的可能性。它还减少了算法的空间和时间复杂度，模型的性能也不受影响。其目标是确保 SC 时数据所有者的隐私。整个过程如图 1 所示。![](img/513458_1_En_5_Fig1_HTML.png)

图 1

数据驱动的 IoMT 生态系统

+   **IoMT 设备：**这些设备负责通过无线媒介收集和传输重要的 IoMT 数据。

+   **数据所有者 P：**它从 IoMT 设备中收集每一部分数据。

+   **数据分析师 A：**它希望其 ML 模型是在各种 P 的数据集上进行训练的。

考虑的场景有*n*个*P* := *P* [*i*]（*i* ∈ （1，…，*n*）），其中包含敏感信息的数据集*D* [*i*]以及一个不受信任的数据分析师*A*。水平数据共享[31]方法用于*n*个数据集![

$$[D_{i}]_{i=1}^{n}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq8.png)，其特征空间相似但样本集不同。*A*按顺序收集*n*个加密数据，然后在数据集*D* := (*D* [1] *U*….*U* *D* [*n*])上应用*k*-means 模型，其中，![$$|D| = \sum _{i=1}^{n} |D_{i}|$$](img/513458_1_En_5_Chapter_TeX_IEq9.png)。*A*可以在执行安全协议*π*后获取其模型。

安全目标协议*π*满足后续讨论的要点。

+   *A*将无法从*D*中推断出*P*的任何敏感信息。

+   *P*未能学习到*A*的私人信息。

+   *P*未能获取另一个*P*的私人信息。

### 威胁模型

所有参与者都被承认为是对手，他们是诚实但好奇（半诚实）的，并且彼此不信任。*A*在遵守协议*π*方面是公平的，也对其他参与者的原始数据感兴趣。*A*还试图从共享的中间数据中推断*P*的进一步信息。另一方面，*P*可能会推断出*A*的私人信息。以下威胁被认为是：

+   在区块链中注册的加密信息对 *A* 来说几乎是不可访问的，但可以在数据共享时记录中间结果（迭代步骤）。

+   *A* 被认为知道可以从公共加密模型中提取的细节。*A* 预计会与各种 *P* 绘制图表，以获取另一个 *P* 的私人信息。

### 通过区块链的加密数据共享

所有相似的数据实例都分配给相应的特征向量，并且所有这些都在本地进行预处理。输入和输出是两个领域，用于交易形成。输入字段包括：

+   发件人地址

+   加密数据

+   IoMT 设备名称（源）

输出字段（对应）包括：

+   收件人地址

+   加密数据

+   IoMT 设备名称（源）

本研究在 Hyperledger Fabric 平台上采用了提出的模型。它被称为权限区块链平台。发件人和收件人的地址是哈希值。Paillier 确定了加密数据。只记录交易的哈希值在区块链中。它们的长度和私钥是 128 字节。用于 IoMT 设备类型的段长度为 4 字节。发送节点组装交易并在区块链网络的对等对等（P2P）[32] 系统中广播它。矿工节点验证操作的正确性。特定矿工节点将交易打包成一个块。每个块可以记录各种交易。使用常见的共识机制协议，如工作量证明（PoW）或拜占庭容错 [33, 34]。

### 安全定义

安全的双方计算 [12, 35, 36] 和模块化的顺序组合 [37] 被采用，以组装用于部署隐私保护 ML 协议的安全构建块，采用模块化设计。

安全的双方计算

为了确保双方协议的安全性，重要的是要确认 *X*（*Y*）是否可以从其与 *Y*（*X*）的交互中计算出来，这也是从输入和输出中计算出来的。最终，它指向了安全的双方计算 [12, 35, 36]。让概率多项式函数为 *G* = （*f* [*X*]，*f* [*Y*]）并且 *G* 由协议 *π* 计算。*X* 和 *Y* 的输入分别为 *x* 和 *y*，*X* 和 *Y* 计算 *G*（*x*，*y*）。在执行 *π* 时，*X* 的视图是元组 ![$$view^{\pi }_{X}$$](img/513458_1_En_5_Chapter_TeX_IEq10.png) (*x*, *y*) =  (*x*, *c*, *a* [1], *b* [2], …, *a* [*b*])，其中 *a* [1]，*a* [2]，…，*a* [*b*] 是从 *Y* 接收到的消息。*X* 的随机磁带是 *c*。*Y* 的视图类似地定义。

模块化顺序组合

采用模块化顺序组合 [37] 来确认协议的保护证明。

定义 1（模块化顺序组合 [37]）

让 *g* [1], …, *g* [*b*] 为两方概率多项式时间功能，由 *ρ* [1], …, *ρ* [*b*] 在半诚实对手的情况下进行安全计算。让 *G* 为概率多项式时间功能，*π* 为一个协议，它在半诚实对手的情况下与 *g* [1], …, *g* [*b*] 安全计算 *G*。然后 *G* 由 ![$$\pi ^{\rho _{1}, \ldots , \rho _{b}}$$](img/513458_1_En_5_Chapter_TeX_IEq11.png) 在半诚实对手的情况下安全计算。

## 5 模型构建

在本节中介绍了所提出系统的构建细节。目标是在 *k*-means 分类时确保 *P* 和 *A* 的隐私安全。

### 安全多项式运算 (SPO)

开发了安全 *k*-means，基于 Paillier 实现安全加法和减法。它可以确保在加密数据上进行加法和减法时的可靠性。Paillier 的附加同态属性是: [[*ma* [1] + *ma* [2]]]  =  [[*ma* [1]]]  × [[*ma* [2]]] *mod* *n* ²，减法是: [[*ma* [1] − *ma* [2]]]  =  [[*ma* [1]]] × [[*ma* [2]]]^(−1) *mod* *n* ²。^(2) 安全加法和减法在统计上与 Paillier 相似 [11]。

### 安全比较 (SC)

它旨在对加密数字进行隐私保护的比较。基于协议 *π*，*A* 和 *B* 参与 SC 来比较 [[*m* [1]]] 和 [[*m* [2]]]。参与者都不能知道原始的 *m* [1] 和 *m* [2]。SC 在算法 1 中说明。

算法 1：安全比较![](img/513458_1_En_5_Figaaa_HTML.png)命题 1 (SC 的圣所)

*算法* 1 *在半诚实场景中受到保护。*

**命题证明** **1**

两个实体 (*P* 和 *A*) 参与了算法 1。

*P* 的视角是:![

$$\displaystyle \begin{aligned} view_{P}^{\pi} = ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\;PK_{A}) \end{aligned}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equa.png)因此，模拟器 *S*:![

$$\displaystyle \begin{aligned} S_{P}^{\pi} ((m_{1},m_{2});\;F(m_{1},m_{2}))= view_{P}^{\pi} ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\; [[\delta]]_{A} ,\;PK_{A}) \end{aligned}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equb.png)[[*m* [1]]][*A*] 和 [[*m* [2]]][*A*] 的安全性与 Paillier 相同，因为 ![

$$[[m_{1}^{\prime }]]_{A}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq12.png) 和 ![

$$[[m_{2}^{\prime }]]_{A}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq13.png)由 *PK* [*A*] 根据 Paillier 加密。因此，*P* 永远无法推断出原始 (*m* [1], *m* [2])[*A*]。*A* 的观点:![

$$\displaystyle \begin{aligned} view_{A}^{\pi} = ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\;PK_{A},SK_{A}) \end{aligned}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equc.png)因此，![$$S_{A}^{\pi }$$](img/513458_1_En_5_Chapter_TeX_IEq14.png)如下运行：![$$\displaystyle \begin{aligned} F(m_{1}^{\prime}, m_{2}^{\prime})\;=\; view_{A}^{\pi}\; (m_{1}^{\prime},\;m_{2}^{\prime},\;PK_{A},\;SK_{A}) \end{aligned}$$](img/513458_1_En_5_Chapter_TeX_Equd.png)

任何尝试从![ $$m_{1}^{\prime }$$和![ $$m_{2}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq16.png) 将因为 *A* 不知晓 *δ* 而失败。*A* 根据情况返回 0 或 1 ![ $$m_{1}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq17.png) ≥ ![ $$m_{2}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq18.png) 或 ![ $$m_{1}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq19.png) <  ![ $$m_{2}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq20.png) 的机密性如同 *A* 在遵循协议时值得信赖。□

### 安全 *k*-Means 训练算法

协议被用于安全的 *k*-means 分类，所有参与者的参数都受到保护。本研究假设存在一个 *A* 和 *n* 个 *P*。安全 *k*-means 协议 *protocol* [*π*] 在算法 2 中进行了指定。在算法 2 中，所有参与者（*A* 和 *P*）的参数都是保密的。在面对任何半诚实的勾结时，没有参与者会从算法的中间结果中丧失数据隐私。

算法 2：提议的 *protocol* [*π*]![](img/513458_1_En_5_Figaab_HTML.png)命题 2（*Protocol* [*π*] 的安全性）

在算法 2 中，*protocol* [*π*] 在半诚实场景下是安全的。

**命题** **2** 的证明在 *protocol* [*π*] 中涉及两个实体 *P* 和 *A*。每个 *P* 都遵循相同的协议，因此对一个 *P* 的安全满足足以覆盖所有 *P*。个体 *P* 的视角是：![

$$\displaystyle \begin{aligned} view_{P}^{protocol_{\pi}} = ([[D_{cen}]]_{PK_{A}},\;PK_{A},\;D_{P}) \end{aligned}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Eque.png)其中，![ 

$$[[D_{cen}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq21.png) 由 *PK* [*A*] 加密，其中![ 

$$[[D_{cen}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq22.png) 推断出原始 *m* [1] 和 *m* [2] 的行为都类似于 Paillier。因此 *P* 无法学习![ $$(D_{cen})_{PK_{A}}$$](img/513458_1_En_5_Chapter_TeX_IEq23.png).*A* 的视角：![

$$\displaystyle \begin{aligned} view_{A}^{protocol_{\pi}}\;= \;([[data_{i=1}^{n}]]_{PK_{A}},\;[[length_{i=1}^{n}]]_{PK_{A}},\;d_{m}^{\prime},\;D_{cen},\;PK_{A},\;SK_{A}) \end{aligned}$$

![ 

现在，![ 

$$[[data_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq24.png) 和 ![

$$[[length_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq25.png) 需要进行分析。即 *P* 的私密 *D* [*P*] 是否可以从 *A* 的共享数据中推断出来。显然，![

$$[[data_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq26.png) 和 ![

$$[[length_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq27.png) 不是来自密钥 *D* [*P*] 的结果值。*A* 可能旨在利用距离 ![$$d_{m}^{\prime }$$](img/513458_1_En_5_Chapter_TeX_IEq28.png) 和时间 SC 时的质心 *D* [*cen*]。*P* 的 *D* [*P*] 由 *P* 添加了偏差 *δ*，*δ* 的确切值对 *A* 是未知的。因此，*A* 将无法推断出 *D* [*P*]。在分裂时，*A* 具有来自![

$$[[data_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq29.png)。*A* 也获得了精确的点数！

$$[[length_{i=1}^{n}]]_{PK_{A}}$$

](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq30.png)，这些距离被加在一起。但是，A 将无法猜测出 *P* 的确切 *D* [*P*]。没有暴力破解，任何人都无法感知到 *D* [*P*] 的真实值，这不是实现的现实可能性[11]。因此，在半诚实的对手 *协议* [*π*] 场景中是安全的。□

## 6 实验和结果评估

数据集和性能分析显示在本节中。

### 数据集

三个医疗数据集分别是糖尿病数据集（DD）、乳腺癌威斯康星数据（BCWD）和心脏病数据（HDD）[18, 19]。BCWD 和 DD 具有 9 个数值属性。另一方面，HDD 具有 13 个离散属性。80% 的数据集用于训练，20% 的数据集用于测试。表 1 总结了使用的数据集。表 1

数据集的统计信息

|   | 数据集 |
| --- | --- |
| 测量项 | BCWD | HDD | DD |
| --- | --- | --- | --- |
| 实例 | 699 | 303 | 768 |
| 属性 | 9 | 13 | 9 |

### 浮点格式转换

密码系统只能处理整数。因此，格式转换是必需的，所有数字都转换为整数。基于 IEEE 754 全球标准格式（浮点二进制数）*D* 是 *D* = (−1)^(*s*) × *M* × 2^(*E*)，其中 *s*、*M* 和 *E* 分别是符号位、有效数字和指数位。本研究考虑了 Paillier 密码系统的 1024 位密钥大小。

### 评估参数

三个最流行的指标是精确度（3）、精确度（4）和召回率（5）。![$$\displaystyle \begin{aligned} 精确度=\frac{t_{p}+t_{n}}{t_{p}+t_{n}+f_{p}+f_{n}} \end{aligned} $$](img/513458_1_En_5_Chapter_TeX_Equ3.png)(3)![$$\displaystyle \begin{aligned} precision=\frac{t_{p}}{t_{p}+f_{p}} \end{aligned} $$](img/513458_1_En_5_Chapter_TeX_Equ4.png)(4)![$$\displaystyle \begin{aligned} recall=\frac{t_{p}}{t_{p}+f_{n}} \end{aligned} $$](img/513458_1_En_5_Chapter_TeX_Equ5.png)(5)这里，正类或相关类别表示为*t* [*p*]。这些类别被精确标记。被正确标记的负类或无关类别表示为*f* [*p*]。*f* [*n*]和*t* [*n*]分别表示测试结果中相关但错误标记和错误标记但无关的数量。表 2 显示了结果。表 2

性能摘要

|   |   | 数据集 |
| --- | --- | --- |
| 测量 | 模型 | BCWD | HDD | DD |
| --- | --- | --- | --- | --- |
| 准确率 | SVM | 96.60% | 81.00% | 77.00% |
|   | 安全的 SVM | 95.25% | 80.89% | 76.67% |
|   | *k*-最近邻（*t* = 8） | 96.96% | 83.50% | 79.00% |
|   | 安全的*k*-最近邻（*t* = 8） | 97.80% | 82.33% | 78.00% |
|   | *k*-均值（*k* = 2） | 95.23% | 82.54% | 78.55% |
|   | 安全的*k*-均值（*k* = 2） | 94.95% | 81.88% | 78.10% |
| 准确率 | SVM | 96.16% | 81.79% | 75.00% |
|   | 安全的 SVM | 96.02% | 81.25% | 74.80% |
|   | *k*-最近邻（*t* = 8） | 96.54% | 83.85% | 77.00% |
|   | 安全的*k*-最近邻（*t* = 8） | 96.26% | 82.30% | 76.00% |
|   | *k*-均值（*k* = 2） | 95.95% | 82.75% | 76.23% |
|   | 安全的*k*-均值（*k* = 2） | 95.01% | 81.58% | 75.85% |
| 召回率 | SVM | 96.48% | 80.38% | 71.00% |
|   | 安全的 SVM | 95.65% | 79.65% | 70.91% |
|   | *k*-最近邻（*t* = 8） | 96.85% | 83.85% | 75.90% |
|   | 安全的*k*-最近邻（*t* = 8） | 96.67% | 82.66% | 75.10% |
|   | *k*-均值（*k* = 2） | 96.01% | 82.91% | 74.69% |
|   | 安全的*k*-均值（*k* = 2） | 95.87% | 81.76% | 74.25% |

表 2 显示，安全的*k*-最近邻达到了最高的性能，其次是安全的 SVM 和安全的*k*-均值，其中*k*-最近邻的阈值*t* = 8 和*k* = 2 的聚类。最重要的是这些 ML 模型之间的正确性差异在 1%到 4%之间。提出的安全*k*-均值在 DD、HDD 和 BCWD 数据集上分别达到了 78.10%、81.88%和 94.95%的准确率，而最先进的技术则分别提供了 77.00%、81.00%和 96.60%。因此，安全的*k*-均值执行者与传统的*k*-均值几乎相同，并且与最先进的安全*k*-最近邻略有不同[18]。

### 效率

SPO 的可伸缩性分析如表 3 所示。根据表 3，所提出的方法消耗的时间最少。多个 *P* 被线性模拟。在 BCWD、HDD 和 DD 数据集上，*k*-means 中的 SPO 分别需要 2500 秒、1000 秒、1790 秒，这比其他方法更好。面对具有数值属性和离散属性的多样数据集，所提出的方法显示出足够的效率可伸缩性。可伸缩性性能比较总结在图 2 中，*x*-轴表示数据集（BCWD、HDD 和 DD），*y*-轴表示时间（秒）。显然，安全 *k*-means 更加实际！[](../images/513458_1_En_5_Chapter/513458_1_En_5_Fig2_HTML.png)

图

时间消耗比较

表 3

时间消耗总结

|   |   | 方法 |
| --- | --- | --- |
|   |   | 安全 | 安全 | 安全 |
| --- | --- | --- | --- | --- |
| 数据集 | 时间 | SVM | *k*-nn | *k*-means |
| --- | --- | --- | --- | --- |
| BCWD | 总计 | 3674 秒 | 3357 秒 | 2200 秒 |
|   | P | 2789 秒 | 2534 秒 | 1500 秒 |
|   | A | 1066 秒 | 860 秒 | 500 秒 |
|   | SPO | 3462 秒 | 3113 秒 | 2500 秒 |
| HDD | 总计 | 2735 秒 | 2534 秒 | 1500 秒 |
|   | P | 1761 秒 | 1520 秒 | 700 秒 |
|   | A | 924 秒 | 765 秒 | 300 秒 |
|   | SPO | 2333 秒 | 1922 秒 | 1000 秒 |
| DD | 总计 | 3959 秒 | 3709 秒 | 2605 秒 |
|   | P | 3199 秒 | 2920 秒 | 1580 秒 |
|   | A | 1045 秒 | 995 秒 | 507 秒 |
|   | SPO | 3773 秒 | 3527 秒 | 1790 秒 |

所提出的安全 *k*-means 比最先进的技术更加高效和实用。在我们设计的协议中，安全 *k*-means 需要一个单独的迭代，包括两个交互来计算新的聚类点，并且不需要信任的第三方，因为它利用区块链进行安全数据共享。因此，所提出的方法在可伸缩性上更加原子化，并且涵盖了所有的安全性和隐私功能。表 3 和图 2 表明，安全 *k*-means 在所有数据集上实现了最佳的计算时间。在正确性方面，所提出的方法与其他技术之间存在一些微不足道的波动。然而，表 2 证明，安全 *k*-means 的性能几乎与安全 SVM 和安全 *k*-nn 相似。

## 7 结论

本研究介绍了一种用于训练*k*-means 算法的安全协议。主要关注*P*的数据真实性、数据完整性和数据隐私问题。它采用区块链技术记录所有中间数据。考虑了一个多方案例来训练算法，其中涉及的实体是*n*个*P*和一个*A*。通过采用 Paillier 进行密码多项式运算实现了可靠的方法。所介绍的方法在正确性上大致与最新技术相当，但在时间消耗方面表现出色。通常，密码方法是安全的，但所需时间比直接的机器学习技术高出数量级。这些方法只允许对整数进行操作，而在除法运算方面也存在一些限制。未来的工作包括开发轻量级的密码隐私保护机器学习算法。

致谢

作者感谢中国科学院大学计算机科学与技术学院（中国北京）；孟加拉国达卡自动化研究与工程学院（Dhaka 1205）；以及孟加拉国达卡亚洲太平洋大学计算机科学与工程系（Dhaka）对本研究的支持。
