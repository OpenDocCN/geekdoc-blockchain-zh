© 作者（们），在 Springer Nature Switzerland AG 独家授权 2022 年 X. Yi 等。区块链基础与应用 Springer 应用科学与技术简报[`doi.org/10.1007/978-3-031-09670-9_1`](https://doi.org/10.1007/978-3-031-09670-9_1)

# 1. 密码学基本元素

许**毅**^(1  )，杨**学超**^(1  )，安德烈**基拉耶夫**^(1  )，林**耀坚**^(2  ) 和 **塔里**^(1  )（1）澳大利亚墨尔本 RMIT 大学计算机技术学院（2）新加坡南洋理工大学计算机科学与工程学院**许**毅**（通讯作者）电子邮件：**xun.yi@rmit.edu.au**杨**学超**电子邮件：**xuechao.yang@rmit.edu.au**基拉耶夫**安德烈**电子邮件：**andrei.kelarev@gmail.com**林**耀坚**电子邮件：**kwokyan.lam@ntu.edu.sg**塔里**扎希**电子邮件：**zahir.tari@rmit.edu.au

## 1.1 秘密密钥加密系统

### 1.1.1 秘密密钥加密系统模型

秘密密钥加密系统是一种加密系统，使用秘密密钥对明文进行加密和对密文进行解密。密钥可能相同，也可能有两个不同的密钥和一个简单的转换方法。在实践中，密钥代表两个或更多方之间的共享秘密，可用于维护私人信息链接。

秘密密钥加密系统的第一个系统信息理论研究可以在香农的经典论文“通信理论的保密系统”[7]中找到。它给出了一个秘密密钥加密模型，如图 1.1 所示。

在明文 *P* 传输之前，发送方和接收方需要交换一个共享密钥 *K*，或者从可信密钥源接收它。发送方使用该密钥加密明文 *P*，产生密文 *C*，交付给接收方，可能会被敌方窃听者拦截。接收方然后使用密钥 *K* 以便重建明文 *P*。

### 1.1.2 高级加密标准

数据加密标准（DES）是一种在 20 世纪 70 年代初由 IBM 开发的秘密密钥加密系统，用于加密电子数据，其基础是 Horst Feistel 的早期设计[6]。该算法在机构邀请提出用于保护敏感、非机密电子政府数据的候选算法后，提交给了国家标准局（NBS）。在 1976 年与国家安全局（NSA）咨询后，NBS 最终选择了一个略有修改的版本，该版本于 1977 年作为美国的官方联邦信息处理标准（FIPS）发布。

DES 及其变种已经被广泛使用超过 40 年。DES 算法的主要问题是它的密钥相对较短，只有![$$2^{56}$$](img/516136_1_En_1_Chapter_TeX_IEq1.png)种可能的密钥。尽管这个数字相当大，但足够的计算资源使得对 DES 的暴力攻击变得可行。所谓的 DES 挑战，就是大量连接到互联网的计算机 exhaustively 搜索密钥空间，这证明了这是一个剧烈的弱点。1997 年的第一次 DES 挑战用了 4.5 个月完成，1998 年的第二次用了 39 天，1999 年的第三次也是最后一次 DES 挑战在不到一天内（22.5 小时）完成。![](img/516136_1_En_1_Fig1_HTML.png)

图反映了密钥加密模型，它包括发送方、加密、解密、接收方、明文和密文。

Fig. 1.1

密钥加密模型

1997 年，美国国家标准与技术研究院（NIST）启动了一场公开竞赛，以选择一个替代 DES 的算法。该算法需要支持 128、192 和 256 位的密钥大小，并且不得受任何专利的限制。选拔过程包括几个回合，在这些回合中，候选算法得到了评估。到了 1998 年 8 月第一轮结束时，有 15 个算法被接受为候选人。在接下来 1999 年 8 月的第二轮中，候选算法被减少到了五个最终候选算法（MARS，Blowfish，RC6，Rijndael，Serpent）。最终，在 2000 年 4 月，Rijndael 算法被选为胜者。2000 年 10 月 2 日，NIST 正式宣布 Rijndael 已被选为高级加密标准（AES） [2]。

AES 算法对 128 位数据块进行操作，支持三种不同密钥大小：128、192 和 256。这三个 AES 算法的版本也分别称为 AES-128、AES-192 和 AES-256，对应于 128、192 和 256 位的密钥， respectively. AES 加密过程包括多个加密轮次（Nr），这取决于密钥的大小。标准要求 AES-128 需要 10 轮加密，AES-192 需要 12 轮，AES-256 需要 14 轮。

在加密过程中，每一轮都由一组四个基本操作组成。解密过程应用这些操作的逆序。图 1.2 展示了 AES-128 加密和解密的基本结构。![](img/516136_1_En_1_Fig2_HTML.png)

图表示高级加密标准的基本结构的加密和解密。

Fig. 1.2

AES-128 的加密和解密

AES 操作的是一个 ![$$4\times 4$$](img/516136_1_En_1_Chapter_TeX_IEq2.png) 列优先的矩阵字节，称为状态，如图 1.3 所示，其中元素 ![$$S_{r,c}$$](img/516136_1_En_1_Chapter_TeX_IEq3.png) 是一个 8 位的值，对应于状态的行 *r* 和列 *c*。AES 的大多数计算都是在特殊的有限域中进行的。![](img/516136_1_En_1_Fig3_HTML.png)

一个表由 4 列和 4 行组成。第一列从 S 脚标 0,0 开始，以 S 脚标 3,0 结束。其他三列遵循类似的模式。

图 1.3

AES 的状态

接下来，我们提供一个高级描述，描述 AES 算法的主要操作。

+   **KeyExpansion**。轮密钥是通过 AES 密钥计划从密钥派生的。AES 需要为每个轮次加一额外的一个 128 位的轮密钥块。

+   **InitialRound**。

    **AddRoundKey**。状态的每个字节与轮密钥的一个块使用位异或操作结合。

+   **Rounds**。

    **SubBytes** 是一个非线性替换步骤，其中每个字节根据查找表用另一个字节替换。

    **ShiftRows** 是一个置换步骤，其中状态的最后三行按一定步数循环移动。

    **MixColumns** 是对状态的列进行的混合操作，每个列中结合四个字节。AES 加密和 AES 解密的混合列操作分别如图 1.4 所示。

    **AddRoundKey**。

+   **Final Round**（不包含混合列）。

    **SubBytes**。

    **ShiftRows**。

    **AddRoundKey**。

![](img/516136_1_En_1_Fig4_HTML.png)

图反映了高级加密标准加密和解密的混合列。混合列是对状态的列进行的混合操作，每个列中结合四个字节。

图 1.4

AES 加密和解密的混合列

美国国家安全局（NSA）审查了所有 AES 决赛选手，包括 Rijndael，并表示它们都足够安全，可用于美国政府的非机密数据。2003 年 6 月，美国政府宣布 AES 可以用来保护机密信息：“AES 算法（即 128 位、192 位和 256 位）的所有密钥长度的设计和强度都足以保护机密信息至秘密级别。绝密信息将需要使用 192 位或 256 位密钥长度。旨在保护国家安全系统及/或信息的产品中 AES 的实现必须在其获取和使用之前由 NSA 审查并认证。”直到 2009 年，针对完整 AES 的唯一成功的公开攻击是对某些特定实现的双通道攻击。

## 1.2 公钥密码系统

公钥密码系统包括公钥加密算法和数字签名算法。

### 1.2.1 公钥加密模型

在秘密密钥加密系统中，两个方会依赖于一个他们通过安全方式相互交换的密钥。例如，面对面会议或通过可信信使交换都可以使用。这个双方绝对保密保持的密钥，然后可以用来交换加密信息。这种密钥分发方法有几个显著的实践难题。公钥加密解决了这些缺点，使得用户可以在不需要事先商定共享密钥的情况下，通过公共通道安全地通信。

公钥加密模型，如图 1.5 所示，是由 Whitfield Diffie 和 Martin Hellman 于 1976 年提出的[3]，他们受到了 Ralph Merkle 关于公钥分发的作品的启发，提出了一种公钥协商方法。![](img/516136_1_En_1_Fig5_HTML.png)

图示代表了公钥加密模型。公钥用于加密明文，私钥用于解密密文。

图 1.5

公钥加密模型

公钥加密，也称为非对称密钥加密，是一类需要两个不同密钥的算法，其中一个保密（或私有的），另一个是公开的。尽管这两个密钥不同，但它们形成一个密钥对，并且在数学上是相关的。公钥用于加密明文，私钥用于解密密文。术语“非对称”源于使用不同的密钥来执行这些相反的功能，每个都是另一个的逆——与传统的（“对称密钥”）加密形成对比，后者依赖于相同的密钥来执行两个操作。

通常，与一个密钥空间![$$\mathbf{K}$$](img/516136_1_En_1_Chapter_TeX_IEq5.png)、明文空间![$$\mathbf{M}$$](img/516136_1_En_1_Chapter_TeX_IEq6.png)和密文空间![$$\mathbf{C}$$](img/516136_1_En_1_Chapter_TeX_IEq7.png)相关的公钥加密算法包括以下三个算法。

+   密钥生成算法（KG）：给定一个安全参数*k*，生成一个公钥和私钥对![$$(\mathsf {pk},\mathsf {sk})$$](img/516136_1_En_1_Chapter_TeX_IEq8.png)，其中![$$\mathsf {sk}\in \mathbf{K}$$](img/516136_1_En_1_Chapter_TeX_IEq9.png)。公钥![$$\mathsf {pk}$$](img/516136_1_En_1_Chapter_TeX_IEq10.png)公布于众，而私钥![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq11.png)只有其所有者知道。

+   加密算法(*E*): 给定明文 ![$$m\in \mathbf{M}$$](img/516136_1_En_1_Chapter_TeX_IEq12.png) 和公钥 ![$$\mathsf {pk}$$](img/516136_1_En_1_Chapter_TeX_IEq13.png)，产生密文 *c*，表示为 ![$$c=E(m,\mathsf {pk})$$](img/516136_1_En_1_Chapter_TeX_IEq14.png)，其中 ![$$c\in \mathbf{C}$$](img/516136_1_En_1_Chapter_TeX_IEq15.png)。

+   解密算法(*D*): 给定密文 ![$$c=E(m,\mathsf {pk})$$](img/516136_1_En_1_Chapter_TeX_IEq16.png) 和私钥 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq17.png)，恢复明文 *m*，表示为 ![$$m=D(c,\mathsf {sk})$$](img/516136_1_En_1_Chapter_TeX_IEq18.png)。

加密算法 *E* 是明文空间 ![$$\mathbf{M}$$](img/516136_1_En_1_Chapter_TeX_IEq19.png) 到密文空间 ![$$\mathbf{C}$$](img/516136_1_En_1_Chapter_TeX_IEq20.png) 的映射。它必须是一个陷门单向函数。对于几乎所有的密文 ![$$c = E(m,\mathsf {pk})$$](img/516136_1_En_1_Chapter_TeX_IEq21.png)，从给定的 ![$$\mathsf {pk}$$](img/516136_1_En_1_Chapter_TeX_IEq22.png) 和 *c* 恢复明文 *m* 必须在计算上不可行。然而，由于消息的合法接收者必须能够从 *c* 恢复 *m*，单向函数还需要更多的要求。具体来说，每个 *E* 都必须有一个逆函数 *D*，并且这个逆函数必须容易获得一些额外的秘密信息 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq23.png)。额外的信息 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq24.png) 称为 *E* 的陷门，而函数 *E* 本身称为陷门单向函数。另外，还要求在知道 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq25.png) 的情况下，对于密文空间中的所有 *c*，都应该容易计算 ![$$m = D(c,\mathsf {sk})$$](img/516136_1_En_1_Chapter_TeX_IEq27.png)。数*n*作为公钥和私钥的模数。其长度，通常以位表示，是密钥长度。

1.  3.

    计算![$$\phi (n) = \phi (p)\phi (q) = (p - 1)(q - 1) = n - (p + q -1)$$](img/516136_1_En_1_Chapter_TeX_IEq28.png)，其中![$$\phi $$](img/516136_1_En_1_Chapter_TeX_IEq29.png)是欧拉函数。

1.  4.

    选择一个整数 *e*，使得 ![$$1< e < \phi (n)$$](img/516136_1_En_1_Chapter_TeX_IEq30.png) 并且 ![$$\text{ gcd }(e, \phi (n)) = 1$$](img/516136_1_En_1_Chapter_TeX_IEq31.png); 也就是说，*e* 和 ![$$\phi (n)$$](img/516136_1_En_1_Chapter_TeX_IEq32.png) 是互质的。选定的整数 *e* 被公布为公钥指数。如果 *e* 的位数较短且汉明重量较小（例如，![$$2^{16} + 1 = 65,537$$](img/516136_1_En_1_Chapter_TeX_IEq33.png)），则加密效率更高。然而，在某些设置中，已经证明 *e* 取值过小（如 3）会变得不那么安全 [1].

1.  5.

    将 *d* 定义为 ![$$d = e^{-1} \pmod {\phi (n)}$$](img/516136_1_En_1_Chapter_TeX_IEq34.png); 也就是说，*d* 是 ![$$e \pmod {\phi (n)}$$](img/516136_1_En_1_Chapter_TeX_IEq35.png) 的乘法逆元。乘法逆元可以使用扩展欧几里得算法计算得出。生成的数 *d* 被用作私钥。

公钥由模数 *n* 和公钥（或加密）指数 *e* 组成。私钥由模数 *n* 和私钥（或解密）指数 *d* 组成，必须保密。数字 *p*, *q*, 和 ![$$\phi (n)$$](img/516136_1_En_1_Chapter_TeX_IEq36.png) 也必须保密，因为它们可以用来计算 *d*。

**加密**。爱丽丝将她的公钥 (*n*, *e*) 传送给鲍勃，并保持私钥的秘密。鲍勃然后希望向爱丽丝发送一条消息 *M*。

首先，鲍勃将 *M* 转换为一个整数 *m*，使得 ![$$0 \le m < n$$](img/516136_1_En_1_Chapter_TeX_IEq37.png)，通过使用一个已知的可逆协议，即填充方案。然后鲍勃计算出密文 *c*，由![$$\begin{aligned} c= &amp; {} m^e (\bmod ~n). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_IEq38.png) 和 ![$$q=53$$](img/516136_1_En_1_Chapter_TeX_IEq39.png)。

1.  2.

    计算 ![$$n = pq = 61 \times 53=3233$$](img/516136_1_En_1_Chapter_TeX_IEq40.png)。

1.  3.

    计算乘积 ![$$\phi (n) = (p - 1)(q - 1)$$](img/516136_1_En_1_Chapter_TeX_IEq41.png) 的欧拉函数。在我们示例中，得到 ![$$\phi (3233)=(61-1)\times (53-1)=3120$$](img/516136_1_En_1_Chapter_TeX_IEq42.png)。

1.  4.

    选择任何 1<e<3120 的数，使其与 3120 互质。如果选择了质数作为 *e*，那么只需检查 *e* 不是 3120 的除数即可。在示例中，让我们取 ![$$e=17$$](img/516136_1_En_1_Chapter_TeX_IEq44.png)。

1.  5.

    计算 ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](img/516136_1_En_1_Chapter_TeX_IEq45.png)。

公钥是 ![$$(n, e) = (3233, 17)$$](img/516136_1_En_1_Chapter_TeX_IEq46.png) 的对。对于一个填充的明文消息 *m*，加密函数是 ![$$c = m^{17} \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ34.png) 私钥是 ![$$(n, d) = (3233, 2753)$$](img/516136_1_En_1_Chapter_TeX_IEq47.png) 的对。对于一个加密的密文 *c*，解密函数是 ![$$m = c^{2753} \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ35.png) 例如，为了加密 ![$$m = 65$$](img/516136_1_En_1_Chapter_TeX_IEq48.png)，我们计算 ![$$c=65^{17}=2790 \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ36.png) 为了解密 ![$$c = 2790$$](img/516136_1_En_1_Chapter_TeX_IEq49.png)，我们计算 ![$$m=2790^{2753} \pmod {3233} = 65.$$](img/516136_1_En_1_Chapter_TeX_Equ37.png)

### 1.2.3 数字签名模型

数字签名是一种用于验证

数字签名模型是由惠特菲尔德·迪菲（Whitfield Diffie）和马丁·赫尔曼（Martin Hellman）发明的。

图象显示了数字签名模型。该过程包括签名和验证。

图 1.6

数字签名模型

通常，数字签名方案包括以下三种算法。

+   一个关键的生成算法，它从可能的私钥集中均匀随机选择一个私钥。该算法输出一个私钥和相应的公钥。

+   一个签名算法，它使用私钥为给定消息生成签名。

+   一个签名验证算法，它接受或拒绝给定消息、公钥和签名的真实性声明。

数字签名方案必须满足以下两个主要性质。首先，应该能够使用相应的公钥来验证从固定消息和固定私钥生成的签名。其次，对于不知道方私钥的第三方生成有效签名，必须计算上不可行。数字签名是创建者能够附加一个位串作为签名的认证机制。

正式地，一个数字签名算法可以被定义为算法的三元组。

+   **密钥生成算法（\*KG\*）**。给定一个安全参数 *k*，生成一个公私钥对 ![$$(\mathsf {pk},\mathsf {sk})$$](img/516136_1_En_1_Chapter_TeX_IEq50.png)。公钥 ![$$\mathsf {pk}$$](img/516136_1_En_1_Chapter_TeX_IEq51.png) 公布给公众，而私钥 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq52.png) 只有其所有者知道。

+   **签名算法（\*S\*）**。给定一个消息 \*m* 和一个私钥 ![$$\mathsf {sk}$$](img/516136_1_En_1_Chapter_TeX_IEq53.png)，生成的签名 ![$$s=S(m,\mathsf {sk})$$](img/516136_1_En_1_Chapter_TeX_IEq54.png)。

+   **验证算法（\*V\*）**。给定一个消息 \*m\*，签名 \*s\* 和公钥 ![$$\mathsf {pk}$$](img/516136_1_En_1_Chapter_TeX_IEq55.png)，算法输出一个值 ![$$V(m,s,\mathsf {pk}) \in \{0, 1\}$$](img/516136_1_En_1_Chapter_TeX_IEq56.png)，其中 ![$$V(m,s,\mathsf {pk})$$](img/516136_1_En_1_Chapter_TeX_IEq57.png) 如果真实性被接受则等于 1，如果被拒绝则等于 0。

### 1.2.4 RSA 数字签名算法

罗纳德·里维斯特（Ron Rivest）、阿迪·夏米尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）提出了 RSA 数字签名算法，它是第一个实用的数字签名算法，以其姓氏的首字母缩写命名。

RSA 数字签名算法由以下三个算法组成：密钥生成、签名和验证算法，如下所述。

**密钥生成**。RSA 算法需要一个公钥和一个私钥。公钥可以被任何人知道，用于验证数字签名。私钥仅被签名者知道。签名者使用私钥签署消息。公钥可以用于在合理的时间内验证数字签名。RSA 数字签名算法的密钥生成方式与 RSA 加密算法的密钥生成方式相同。

**签名算法**。爱丽丝将她的公钥(*n*, *e*)发送给鲍勃，并保持私钥*d*的秘密。然后爱丽丝希望用她的数字签名发送一条消息*m*给鲍勃。

首先，爱丽丝使用她的私钥*d*为消息*m*计算签名，![$$\begin{aligned} s= &amp; {} m^d \pmod {n} \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ3.png)(1.3)这可以通过指数平方的方法快速完成。然后爱丽丝将(*m*, *s*)发送给鲍勃。**验证算法**。鲍勃通过使用爱丽丝的公钥(*n*, *e*)来验证她对消息*m*的签名*s*，检查以下模等式是否成立![$$\begin{aligned} m= &amp; {} s^e \pmod {n} \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ4.png)(1.4)如果上述等式有效，则签名是真实的，消息是由爱丽丝签名的。否则，必须拒绝签名。

接下来，我们给出一个 RSA 签名生成和验证的示例。为了方便，示例使用了小参数，但也可以使用 OpenSSL 生成并检查一个真实的密钥对。

1.  1.

    选择两个不同的素数，例如，![$$p=61$$](img/516136_1_En_1_Chapter_TeX_IEq58.png)和![$$q=53$$](img/516136_1_En_1_Chapter_TeX_IEq59.png)。

1.  2.

    计算![$$n = pq = 61\times 53 = 3233$$](img/516136_1_En_1_Chapter_TeX_IEq60.png)。

1.  3.

    计算乘积的欧拉函数值为![$$\phi (n) = (p - 1)(q - 1)$$](img/516136_1_En_1_Chapter_TeX_IEq61.png)。在示例中，我们得到![$$\phi (3233) = (61-1) \times (53-1) = 3120$$](img/516136_1_En_1_Chapter_TeX_IEq62.png)。

1.  4.

    选择任何介于 1 和 3120 之间的数![$$1&lt; e &lt; 3120$$](img/516136_1_En_1_Chapter_TeX_IEq63.png)，使其与 3120 互质。如果我们选择一个素数作为*e*，那么只需要检查*e*是否不是 3120 的除数。在我们的示例中，让我们取![$$e=17$$](img/516136_1_En_1_Chapter_TeX_IEq64.png)。

1.  5.

    计算 ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](img/516136_1_En_1_Chapter_TeX_IEq65.png)。公钥是 ![$$(n, e) = (3233, 17)$$](img/516136_1_En_1_Chapter_TeX_IEq66.png) 对，私钥是 ![$$(n, d) = (3233, 2753)$$](img/516136_1_En_1_Chapter_TeX_IEq67.png)。

对于消息 *m*，签名是 ![$$s = m^{2753} \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ38.png)进行签名验证时，需要检查以下等式是否成立 ![$$m=s^{17} \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ39.png)例如，为了签名 ![$$m = 2790$$](img/516136_1_En_1_Chapter_TeX_IEq68.png)，我们计算 ![$$s=2790^{2753}=65 \pmod {3233}.$$](img/516136_1_En_1_Chapter_TeX_Equ40.png)验证签名时，我们计算 ![$$65^{17}\pmod {3233} = 2790.$$](img/516136_1_En_1_Chapter_TeX_Equ41.png)由于 ![$$m = s^e\pmod {n}$$](img/516136_1_En_1_Chapter_TeX_IEq69.png)，因此可以接受签名。

## 1.3 哈希函数

原始的 RSA 数字签名算法只能签名小于*n*位的短消息。为了签名超过*n*位的长消息，首先必须使用一个哈希函数。哈希函数将每个较长的消息映射到一个较短的位字符串，称为消息的*哈希*。然后，RSA 数字签名算法可以用来生成原始消息的短哈希的签名。

### 1.3.1 哈希函数的概念

哈希函数是一种数学算法，它将任意大小的数据（通常称为“消息”）映射到一个固定大小的位数组（“哈希值”、“哈希”或“消息摘要”）。它是一个单向函数，这意味着实际上不可能逆向或反转计算，仅凭输出无法恢复函数的输入。理想情况下，找到一个产生给定哈希的消息的唯一方法是尝试通过所有可能的输入进行暴力搜索，看哪个输入产生匹配，或者使用匹配哈希的彩虹表。哈希函数是现代密码学的基本工具。

哈希函数必须是确定性的，这意味着相同的消息总是产生相同的哈希值。理想情况下，它还应具有以下特性。

+   对于任何给定消息，计算哈希值必须快速。

+   生成一个消息，使其产生给定的哈希值（即，逆转产生给定哈希值的过程）应该是不可行的。

+   找到两个具有相同哈希值的不同消息应该是不可行的。消息的小幅更改应使哈希值发生巨大变化，以至于新的哈希值与旧的哈希值（雪崩效应）看起来不相关。

哈希函数在数字签名、消息认证码（MACs）和其他形式的认证中具有许多安全应用。它们还可以用于哈希表中的数据索引、指纹识别、检测重复数据、文件的唯一标识以及检测意外数据损坏的校验和。在信息安全上下文中，哈希值有时被称为（数字）指纹、校验和，或者只是哈希值，尽管所有这些术语都代表具有相当不同属性和目的的一般函数。

大多数哈希函数被设计为接受任意长度的字符串作为输入，并产生固定长度的哈希值。

哈希函数必须能够抵御所有已知的密码分析攻击。在理论密码学中，哈希函数的安全级别是使用以下属性定义的。

+   **预图像阻力**。给定一个哈希值*h*，找到任何消息*m*使得![$$h = \mathsf {hash}(m)$$](img/516136_1_En_1_Chapter_TeX_IEq70.png)应该困难。这个概念与单向函数的概念有关。缺乏这一属性的函数容易受到预图像攻击。

+   **第二次预图像阻力**。给定一个输入![$$m_1$$](img/516136_1_En_1_Chapter_TeX_IEq71.png)，找到一个不同的输入![$$m_2$$](img/516136_1_En_1_Chapter_TeX_IEq72.png)使得![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](img/516136_1_En_1_Chapter_TeX_IEq73.png)应该困难。这一属性有时被称为*弱碰撞阻力*。缺乏这一属性的函数容易受到第二次预图像攻击。

+   **碰撞阻力**。找到两个不同的消息![$$m_1$$](img/516136_1_En_1_Chapter_TeX_IEq74.png)和![$$m_2$$](img/516136_1_En_1_Chapter_TeX_IEq75.png)使得![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](img/516136_1_En_1_Chapter_TeX_IEq76.png)应该困难。这样的一对被称为*密码学哈希碰撞*。这一属性有时被称为*强碰撞阻力*。它要求哈希值至少是预图像阻力所需的两倍长；否则，可以通过生日攻击找到碰撞。

碰撞阻力意味着第二次预图像阻力，但并不意味着预图像阻力。在理论密码学中，总是优先考虑较弱的假设，但在实践中，一个只是第二次预图像阻力的哈希函数被认为是安全的，因此不建议用于实际应用。

非正式地，这些属性意味着恶意敌方不能不改变其摘要的情况下替换或修改输入数据。因此，如果两个字符串有相同的摘要，我们可以非常有信心它们是相同的。第二图像阻力防止攻击者制作与攻击者无法控制的文档具有相同哈希值的文档。碰撞阻力防止攻击者创建具有相同哈希值的两个不同文档。

满足这些标准的函数可能仍然具有不希望的属性。目前，流行的哈希函数容易受到长度扩展攻击：给定![$$\mathsf {hash}(m)$$](img/516136_1_En_1_Chapter_TeX_IEq77.png)和![$$\mathsf {len}(m)$$](img/516136_1_En_1_Chapter_TeX_IEq78.png)，但不是*m*，通过选择一个合适的![$$m'$$](img/516136_1_En_1_Chapter_TeX_IEq79.png)，攻击者可以计算![$$\mathsf {hash}(m \Vert m')$$](img/516136_1_En_1_Chapter_TeX_IEq80.png)，其中![$$\Vert $$](img/516136_1_En_1_Chapter_TeX_IEq81.png)表示连接。这一特性可以用来破坏基于哈希函数的朴素认证方案。基于哈希的消息认证码（HMAC）构造可以解决这些问题。

在实际中，碰撞阻力对许多实际应用来说是不够的。除了碰撞阻力之外，还应该使敌方无法找到两个具有实质上相似摘要的消息，或者仅凭消息摘要推断出有关数据的有用信息。特别是，哈希函数应该尽可能地表现得像一个随机函数（在安全性的证明中通常称为随机预言机），同时仍然具有确定性和高效的可计算性。这排除了像 SWIFFT 函数[4]这样的函数，它可以严格证明是碰撞抵抗的，前提是某些理想格上的问题是计算上困难的，但作为一个线性函数，不满足这些额外的属性。

校验和算法，如 CRC（循环冗余校验）和其他循环冗余校验，设计来满足更弱的要求，通常不适用于哈希函数。例如，CRC 被用于 Wired Equivalent Privacy (WEP)加密标准的消息完整性，但很快就发现了一个攻击，该攻击利用了校验和的线性性质。

### 1.3.2 SHA-1

SHA-1（安全哈希算法 1）是一个哈希函数，它接受一个输入并产生一个 160 位（20 字节）的哈希值，称为消息摘要——通常表示为一个十六进制数，40 位数字。它是由美国国家安全局设计的，是美国联邦信息处理标准。

当输入的消息长度小于![$$2^{64}$$](img/516136_1_En_1_Chapter_TeX_IEq82.png)时，SHA-1 产生一个 160 位的输出，称为*消息摘要*。消息摘要可以用于例如签名算法，该算法生成或验证消息的签名。对消息摘要进行签名而不是消息本身通常会提高过程的效率，因为消息摘要通常比消息短得多。验证数字签名的人必须使用与创建数字签名的人相同的哈希算法。消息在传输过程中的任何更改都将以非常高的概率导致不同的消息摘要，并且签名将无法验证。

SHA-1 根据与麻省理工学院 Ronald L. Rivest 设计的 MD2、MD4 和 MD5 消息摘要算法相似的原则生成消息摘要，但生成更大的哈希值（160 位对 128 位）。SHA-1 是基于 Merkle-Damgård 构造设计的，如图 1.7 所示。![](img/516136_1_En_1_Fig7_HTML.png)

图反映了 Merkle Damgård 哈希函数构造。原始消息流向消息块 1 和消息块 2，而填充流向消息块 n。

图 1.7

Merkle-Damgård 哈希函数构造

要描述 SHA-1，让我们首先定义用于构建它的术语和函数。

+   十六进制数字（或十六进制数字）是集合![$$\{0, 1, \ldots , 9, A, \ldots , F\}$$](img/516136_1_En_1_Chapter_TeX_IEq83.png)的一个元素。每个十六进制数字是一个 4 位字符串的表示。例如：![$$7 = 0111$$](img/516136_1_En_1_Chapter_TeX_IEq84.png)和![$$A = 1010$$](img/516136_1_En_1_Chapter_TeX_IEq85.png)。

+   一个*单词*是一个 32 位字符串，可以表示为 8 个十六进制数字的序列。要将一个单词转换为 8 个十六进制数字，每个 4 位字符串都转换为其上述描述的十六进制等效物。例如，![$$1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.$$](img/516136_1_En_1_Chapter_TeX_Equ42.png)

+   0 到![$$2^{32} - 1$$](img/516136_1_En_1_Chapter_TeX_IEq87.png)由十六进制单词 00000123 表示。

+   一个*块*是一个 512 位字符串。每个块可以表示为 16 个单词的序列。

以下逻辑运算符将应用于单词。

+   位逻辑词运算![    对于正整数 n 和 m，n 除以 m 的余数表示为 n。+   运算 ![$$X + Y$$](img/516136_1_En_1_Chapter_TeX_IEq88.png) 定义如下。令 *X* 和 *Y* 分别为表示整数 *x* 和 *y* 的词，其中 ![$$0 \le x, y < 2^{32}$$](img/516136_1_En_1_Chapter_TeX_IEq89.png)。对于正整数 *n* 和 *m*，*n*除以*m*的余数表示为 ![$$n \pmod {m}$$](img/516136_1_En_1_Chapter_TeX_IEq90.png)。计算![$$\begin{aligned} z= &amp; {} (x + y) \pmod {2^{32}}. \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ5.png)(1.5)然后 ![$$0 \le z < 2^{32}$$](img/516136_1_En_1_Chapter_TeX_IEq91.png)。将 *z* 转换为词 *Z*，并将运算 ![$$X + Y$$](img/516136_1_En_1_Chapter_TeX_IEq92.png) 的值定义为 *Z*。

+   如果 *X* 是一个词而 *i* 是一个整数，使得 ![$$0 \le i < 32$$](img/516136_1_En_1_Chapter_TeX_IEq93.png)，那么 *循环左移操作* ![$$S^{i}(X)$$](img/516136_1_En_1_Chapter_TeX_IEq94.png) 定义如下![$$\begin{aligned} S^i(X)= &amp; {} (X \ll i) \,\text{ OR }\,(X \gg 32-i). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ6.png)(1.6)在上式中，![$$X \ll i$$](img/516136_1_En_1_Chapter_TeX_IEq95.png) 是通过丢弃 *X* 的最左边的 *i* 位，然后在右侧用 *i* 个零填充结果得到的（结果仍然有 32 位）。同样地，![$$X \gg i$$](img/516136_1_En_1_Chapter_TeX_IEq96.png) 是通过丢弃 *X* 的最右边的 *i* 位，然后在左侧用 *i* 个零填充结果得到的。因此 ![$$S^i(X)$$](img/516136_1_En_1_Chapter_TeX_IEq97.png) 等价于将 *X* 循环左移 *i* 位。

**填充**。消息填充的目的是使填充后的消息总长度为 512 的倍数。当 SHA-1 用于计算作为输入提供的一条消息或数据文件的消息摘要时，它按顺序处理 512 位的数据块来计算消息摘要。

消息或数据文件应被视为一个位串。消息的长度就是消息中的位数。（空消息长度为 0）。如果消息中的位数是 8 的倍数，为了紧凑起见，我们可以将消息表示为十六进制。

接下来，我们描述如何进行消息填充。简要来说，在消息的末尾添加一个“1”和一个*m*个“0”，再加上一个 64 位的整数，以产生长度为 512*n*的填充消息。64 位的整数是原始消息的长度。然后将填充后的消息作为*n*个 512 位块处理，使用 SHA-1 算法。

第一个 512 位的块，表示为*M*(1)，按以下步骤处理。

**步骤 1：初始化**。散列函数*H*按照以下方式初始化（用十六进制表示）：

![$$H_0 = 67452301$$](img/516136_1_En_1_Chapter_TeX_IEq98.png), ![$$H_1 = EFCDAB89$$](img/516136_1_En_1_Chapter_TeX_IEq99.png), ![$$H_2 = 98BADCFE$$](img/516136_1_En_1_Chapter_TeX_IEq100.png),

![$$H_3 = 10325476$$](img/516136_1_En_1_Chapter_TeX_IEq101.png), ![$$H_4 = C3D2E1F0.$$](img/516136_1_En_1_Chapter_TeX_IEq102.png)

**步骤 2：扩展**。将*M*(1)分为 16 个词![$$W(0), W(1), \ldots , W(15)$$](img/516136_1_En_1_Chapter_TeX_IEq103.png)，其中*W*(0)是最左边的单词。对于![$$t = 16$$](img/516136_1_En_1_Chapter_TeX_IEq104.png)到 79，令![$$\begin{aligned} W(t)= &amp; {} S¹(W(t-3) \,\text{ XOR }\,W(t-8) \,\text{ XOR }\,W(t-14) \,\text{ XOR }\,W(t-16)). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ7.png)(1.7)**步骤 3：通过循环进行混合**。令![$$A = H_0$$](img/516136_1_En_1_Chapter_TeX_IEq105.png)，![$$B = H_1$$](img/516136_1_En_1_Chapter_TeX_IEq106.png)，![$$C = H_2$$](img/516136_1_En_1_Chapter_TeX_IEq107.png)，![$$D = H_3$$](img/516136_1_En_1_Chapter_TeX_IEq108.png)，![$$E = H_4$$](img/516136_1_En_1_Chapter_TeX_IEq109.png)。对于![$$t = 0$$](img/516136_1_En_1_Chapter_TeX_IEq110.png)到 79，执行![$$\begin{aligned}&amp;\text{ TEMP } = S⁵(A) + f(t;B,C,D) + E + W(t) + K(t),\nonumber \\&amp;E = D; D = C; C = S^{30}(B); B = A; A = \text{ TEMP }, \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_IEq111.png)。重复执行步骤 1 至 4，处理其他 512 位块![$$M(2), \ldots , M(n)$$](img/516136_1_En_1_Chapter_TeX_IEq112.png)。最终输出![$$H_0, H_1,H_2,H_3, H_4$$](img/516136_1_En_1_Chapter_TeX_IEq113.png)为消息的散列摘要。

2005 年初，Vincent Rijmen 和 Elisabeth Oswald 发布了对 SHA-1 简化版本的攻击，即 80 轮中的 53 轮，其计算工作量少于 280 次操作。

2005 年 2 月， Wang 等人[8]宣布了一种攻击方法。这种攻击可以在 SHA-1 完整版本的散列函数中找到碰撞，所需的操作数少于 269 次。（如果采用暴力破解方法，则需要 280 次操作。）

作者写道：“特别是，我们的分析基于对 SHA-0 的原始差分攻击、对 SHA-0 的近碰撞攻击、多块碰撞技术，以及用于对 MD5 进行碰撞搜索攻击的消息修改技术。没有这些强大的分析技术，不可能破解 SHA-1。”作者展示了 58 轮 SHA-1 的一个碰撞，使用了 233 次哈希操作。描述完整攻击的论文于 2005 年 8 月在 CRYPTO 会议上发表。

自 2005 年以来，SHA-1 已经被认为在面对资金充足的对手时不再安全[4]。自 2010 年以来，许多组织建议更换 SHA-1。NIST 在 2011 年正式宣布不推荐使用 SHA-1，在 2013 年禁止其用于数字签名。到 2020 年，针对 SHA-1 的选择前缀攻击变得可行。建议尽可能快地从产品中移除 SHA-1，转而使用 SHA-2 或 SHA-3。在数字签名中使用 SHA-1 的情况下，更换 SHA-1 是迫切的。

### 1.3.3 SHA-2

SHA-2 与它的前身 SHA-1 相比有了显著的改变。SHA-2 家族包括六个散列函数，其摘要（散列值）为 224、256、384 或 512 位。这些函数分别表示为 SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。SHA-256 和 SHA-512 是使用八个 32 位和 64 位单词计算的新散列函数，它们使用不同的位移量和加法常数，但在其他方面结构几乎相同；唯一的区别是轮数。SHA-224 和 SHA-384 分别是 SHA-256 和 SHA-512 的截断版本，使用不同的初始值计算。SHA-512/224 和 SHA-512/256 也是 SHA-512 的截断版本，但初始值是使用联邦信息处理标准（FIPS）PUB 180-4 中描述的方法生成的。

**填充**。从长度为*L*位的原始消息开始，附上一个‘1’位，附上*K*个‘0’位，其中*K*是最小的满足![$$\ge 0$$](img/516136_1_En_1_Chapter_TeX_IEq114.png)的数，使得![$$L + 1 + K + 64$$](img/516136_1_En_1_Chapter_TeX_IEq115.png)是 512 的倍数，附上*L*作为一个 64 位的大端整数，使得处理后的总长度是 512 位的倍数，消息中的位为![$$L 1 00 \cdots \langle K~0's \rangle \cdots 00 \langle L \text{ as } 64 \text{ bit } \text{ integer }\rangle = 512n$$](img/516136_1_En_1_Chapter_TeX_IEq116.png)总位。

第一个 512 位块，用*M*(1)表示，按以下步骤处理。

**步骤 1：初始化**。以十六进制表示，哈希函数*H*初始化为以下形式：

![$$H_0= 6A09E667$$](img/516136_1_En_1_Chapter_TeX_IEq117.png), ![$$H_1= BB67AE85$$](img/516136_1_En_1_Chapter_TeX_IEq118.png), ![$$H_2= 3C6EF372$$](img/516136_1_En_1_Chapter_TeX_IEq119.png), ![$$H_3= A54FF53A$$](img/516136_1_En_1_Chapter_TeX_IEq120.png),

![$$H_4= 510E527F$$](img/516136_1_En_1_Chapter_TeX_IEq121.png), ![$$H_5= 9B05688C$$](img/516136_1_En_1_Chapter_TeX_IEq122.png), ![$$H_6= 1F83D9AB$$](img/516136_1_En_1_Chapter_TeX_IEq123.png), ![$$H_7= 5BE0CD19$$](img/516136_1_En_1_Chapter_TeX_IEq124.png).

**步骤 2：扩展**。将*M*(1)分为 16 个词 ![$$W(0), W(1), \dots , W(15),$$](img/516136_1_En_1_Chapter_TeX_IEq125.png) 其中*W*(0)是最左边的词。对于 ![$$i = 16$$](img/516136_1_En_1_Chapter_TeX_IEq126.png) 到 63，设![$$\begin{aligned} S_0= &amp; {} S⁷((W(i-15) )\,\text{ XOR }\,S^{18}((W(i-15))\,\text{ XOR }\,(W(i-15)\gg 3) \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ9.png)(1.9)![$$\begin{aligned} S_1= &amp; {} S^{17} (W(i-2)) \,\text{ XOR }\,S^{19}(W(i-2)) \,\text{ XOR }\,(W(i-2)\gg 10) \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ10.png)(1.10)![$$\begin{aligned} W(i)= &amp; {} W(i-16) + S_0 + W(i-7)+ S_1\ \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ11.png)(1.11)其中 ![$$S^i(X)=(X \gg i) \,\text{ OR }\,(X \ll 32-i)$$](img/516136_1_En_1_Chapter_TeX_IEq127.png)。**步骤 3：通过循环打乱**。令 ![$$A=H_0$$](img/516136_1_En_1_Chapter_TeX_IEq128.png)，![$$B=H_1$$](img/516136_1_En_1_Chapter_TeX_IEq129.png)，![$$C=H_2$$](img/516136_1_En_1_Chapter_TeX_IEq130.png)，![$$D=H_3$$](img/516136_1_En_1_Chapter_TeX_IEq131.png)，![$$E=H_4$$](img/516136_1_En_1_Chapter_TeX_IEq132.png)，![$$F=H_5$$](img/516136_1_En_1_Chapter_TeX_IEq133.png)，![$$G=H_6$$](img/516136_1_En_1_Chapter_TeX_IEq134.png)，![$$H=H_7$$](img/516136_1_En_1_Chapter_TeX_IEq138.png), ![$$G=F$$](img/516136_1_En_1_Fig9_HTML.png)

图展示了 S H A - 2 计算。它由 C h, 大写 sigma 1, M a 和大写 sigma 0 组成。

图 1.9

SHA-2 计算

**步骤 4：输出**。令![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3 = H_3 + D, H_4 = H_4 \,{+}\, E, H_5=H_5\,{+}\,F, H_6=H_6+G, H_7=H_7+H$$](img/516136_1_En_1_Chapter_TeX_IEq146.png)。重复执行上述步骤 1-4，处理其他 512 位块![$$M(2), M(3), \dots , M(n)$$](img/516136_1_En_1_Chapter_TeX_IEq147.png)。最终的输出![$$H_0, H_1,H_2,H_3, H_4$$](img/516136_1_En_1_Chapter_TeX_IEq148.png)是消息的哈希摘要。

SHA-2 哈希函数在某些广泛使用的安全应用程序和协议中实现，包括 TLS 和 SSL、PGP、SSH、S/MIME 以及 IPsec。

多种加密货币，包括比特币，都使用 SHA-256 算法来验证交易和计算工作量证明或权益证明。

## 1.4 椭圆曲线加密

椭圆曲线密码学（ECC）是一种基于有限域中椭圆曲线的代数结构的公钥密码学方法。与非 EC 密码学（基于简单的伽罗瓦域）相比，ECC 允许使用更小的密钥提供等效的安全性。例如，比特币就使用 ECC 作为其公钥加密系统，因为它更轻便。

### 1.4.1 实数域上的椭圆曲线

在数学中，椭圆曲线是一个光滑的、射影的、 genus 为一的代数曲线，上面有一个指定的点 *O*。椭圆曲线定义在一个域 *K* 上，并描述 *K* 的笛卡尔积中的点。如果域的特征数不同于 2 和 3，那么该曲线可以被描述为一个平面代数曲线，通过变量的一次线性变换后，由某些系数 *a* 和 *b* 在 *K* 中的方程 ![$$y^{2} = x^{3}+ax+b$$](img/516136_1_En_1_Chapter_TeX_IEq150.png) 的解 (*x*, *y*) 组成。曲线必须是非 singular 的，这意味着曲线没有尖点或自交。 （这等同于不等式 ![$$4a^{3}+27b^{2}\ne 0$$](img/516136_1_En_1_Chapter_TeX_IEq151.png)。) 始终理解曲线实际上位于射影平面上，点 *O* 是唯一的无穷远点。许多来源将椭圆曲线定义为具有这种形式的方程的曲线。

椭圆曲线是一种阿贝尔品种。这意味着它有一个通过代数方式定义的群法，相对于它是一个阿贝尔群，其中*O*作为单位元素。

虽然椭圆曲线的正式定义需要一些代数几何的背景知识，但是仅使用初等代数和几何就可以描述实数域上椭圆曲线的一些特性。 在这个背景下，椭圆曲线是一个由形式![$$\begin{aligned} y²&amp;=x³ + ax + b \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ18.png)（其中*a*和*b*是实数）定义的平面曲线，经过一次线性变量变换。这种方程称为*魏尔斯特拉斯方程*。椭圆曲线的定义还要求曲线是非 singular 的。从几何上看，这意味着图形没有尖点、自交点或孤立点。从代数上看，这只有在判别式![$$\begin{aligned} \Delta&amp;= -16(4a³ + 27b²) \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ19.png)不等于零时才成立。如果非 singular 曲线的判别式为正，则其图形有两个部分；如果为负，则有一个部分。例如，在图 1.10 中，第一个案例的判别式为 64，第二个案例为-368。

两个图形，都由椭圆曲线组成，分别表示 y 的平方等于 x 的立方减 x 和 y 的平方等于 x 的立方减 x 加 1。

图 1.10

实数域上的椭圆曲线

### 1.4.2 群规

在投影平面上工作时，我们可以在任何光滑的三次曲线 上定义一个群结构。

由于曲线关于*x*轴对称，给定任意点*P*，我们可以取![$$-P$$](img/516136_1_En_1_Chapter_TeX_IEq152.png)为其对面的点。我们取![$$-O$$](img/516136_1_En_1_Chapter_TeX_IEq153.png)为仅仅是*O*。如果*P*和*Q*是曲线上的两个点，那么我们可以唯一地描述一个第三个点![$$P + Q$$](img/516136_1_En_1_Chapter_TeX_IEq154.png)如下。首先，画出穿过*P*和*Q*的直线。这条直线通常会与三次曲线相交于第三个点*R*。然后我们取![$$P + Q$$](img/516136_1_En_1_Chapter_TeX_IEq155.png)为![$$-R$$](img/516136_1_En_1_Chapter_TeX_IEq156.png)，即*R*的对面点。这种加法定义在涉及到无穷远点和平行线 multiplicity 的少数特殊情况除外。第一个异常情况发生在其中一个点是*O*时。这时，我们定义![$$P + O = P = O + P$$](img/516136_1_En_1_Chapter_TeX_IEq157.png)，使得*O*成为该群的单位元。接下来，如果*P*和*Q*是彼此的相反点，我们定义![$$P + Q = O$$](img/516136_1_En_1_Chapter_TeX_IEq158.png)。最后，如果![$$P = Q$$](img/516136_1_En_1_Chapter_TeX_IEq159.png)，那么我们只有一个点，我们无法定义通过这些点的唯一直线。在这种情况下，我们使用该点处的切线作为我们的直线。在大多数情况下，切线会相交于第二个点*R*，我们可以取其相反点。然而，如果*P*碰巧是一个拐点（一个曲线凸度发生变化的点），那么我们取*R*为*P*本身，![$$P + P$$](img/516136_1_En_1_Chapter_TeX_IEq160.png)就是自己相反的点。群法则在图 1.11 中说明。![](img/516136_1_En_1_Fig11_HTML.png)

四幅图描绘了椭圆曲线的群法则，表示 P 加 Q 加 R 等于 0，P 加 Q 加 Q 等于 0，P 加 Q 加 0 等于 0，P 加 P 加 0 等于 0。

图 1.11

椭圆曲线群法则

上述群既可以用代数方法也可以用几何方法描述。给定曲线 ![$$y² = x³ + ax + b$$](img/516136_1_En_1_Chapter_TeX_IEq161.png) 在域 *K* 上，以及曲线上的点 ![$$P = (x_P, y_P)$$](img/516136_1_En_1_Chapter_TeX_IEq162.png) 和 ![$$Q = (x_Q, y_Q)$$](img/516136_1_En_1_Chapter_TeX_IEq163.png)，首先假设 ![$$x_P \not = x_Q$$](img/516136_1_En_1_Chapter_TeX_IEq164.png)（上面的第一块面板）。让我们定义 ![$$R=(x_R,y_R)=P+Q$$](img/516136_1_En_1_Chapter_TeX_IEq165.png)。计算![$$\begin{aligned} \lambda&amp;= \frac{y_P-y_Q}{x_P-x_Q}, \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ20.png)(1.20)![$$\begin{aligned} x_R&amp;= \lambda ²-x_P-x_Q, \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ21.png)(1.21)![$$\begin{aligned} y_R&amp;=y_P+\lambda (x_R-x_P). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ22.png)(1.22)如果 ![$$x_P = x_Q$$](img/516136_1_En_1_Chapter_TeX_IEq166.png)，那么有两种选项：如果 ![$$y_P = -y_Q$$](img/516136_1_En_1_Chapter_TeX_IEq167.png)（上面的第三和第四块面板），包括 ![$$y_P = y_Q = 0$$](img/516136_1_En_1_Chapter_TeX_IEq168.png)（第四块面板）的情况，和为 0。因此，曲线上的每个点的倒数是通过将其反射到 x 轴上找到的。如果 ![$$y_P = y_Q \not = 0$$](img/516136_1_En_1_Chapter_TeX_IEq169.png)，那么 ![$$Q = P$$](img/516136_1_En_1_Chapter_TeX_IEq170.png) 并且 ![$$R = (x_R, y_R)=2P$$](img/516136_1_En_1_Chapter_TeX_IEq172.png)为具有*q*个元素的有限域，令*E*为*K*上的椭圆曲线。尽管通常很难计算出椭圆曲线*E*上*K*的准确有理点数，但椭圆曲线上的 Hasse 定理给出了以下估计（包括无穷远点）![$$\begin{aligned} |\#E(K)-(q+1)| \le 2 \sqrt{q}. \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ26.png)(1.26)因此，曲线的点数大约与字段中的元素数相同。椭圆曲线*E*(*Fq*)的点集是一个有限阿贝尔群。它总是循环的，或者是两个循环群的乘积。例如，由![$$\begin{aligned} y^{2}=x^{3}-x \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ27.png)(1.27)定义的曲线在![$$F_{71}$$](img/516136_1_En_1_Chapter_TeX_IEq173.png)上有 72 个点（包括 71 个 affine 点和一个无穷远点），如图 1.12 所示。![](img/516136_1_En_1_Fig12_HTML.png)

椭圆曲线一组 affine 点的散点图，Y 的平方等于 x 的立方减 x，在有限域 F 的 71 次方。x 和 y 轴的范围从 0 到 72。

图 1.12

椭圆曲线![$$y² = x³ - x$$](img/516136_1_En_1_Chapter_TeX_IEq174.png)在有限域![$$F_{71}$$](img/516136_1_En_1_Chapter_TeX_IEq175.png)上的 affine 点集

### 1.4.4 椭圆曲线数字签名算法（ECDSA）

在密码学中，椭圆曲线数字签名算法（ECDSA）提供了数字签名算法（DSA）的一个变体，该算法使用椭圆曲线密码学。ECDSA 包括以下三个算法。

**密钥生成**。首先，选择曲线参数(![$$\text{ CURVE }, G, n$$](img/516136_1_En_1_Chapter_TeX_IEq176.png))。除了曲线的域和方程外，算法还需要确定曲线上的一个基点*G*，其阶为素数。数字*n*是点*G*的乘法阶。基点*G*的阶*n*必须是素数。

爱丽丝创建了一对密钥，包括一个随机选取的私钥整数![$$d_A$$](img/516136_1_En_1_Chapter_TeX_IEq177.png)（在区间![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq178.png)内），和一个公钥曲线点![$$Q_A = d_A \times G$$](img/516136_1_En_1_Chapter_TeX_IEq179.png)。这里![$$\times $$](img/516136_1_En_1_Chapter_TeX_IEq180.png)表示通过标量乘以椭圆曲线点。点![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq181.png)被公开，而![$$d_A$$](img/516136_1_En_1_Chapter_TeX_IEq182.png)则被爱丽丝保密。

**签名生成**。为了对消息*m*进行签名，爱丽丝按照以下步骤进行：

1.  1.

    计算![$$e = \mathsf {hash}(m)$$](img/516136_1_En_1_Chapter_TeX_IEq183.png)。（这里![$$\mathsf {hash}$$](img/516136_1_En_1_Chapter_TeX_IEq184.png)是一个加密哈希函数，如 SHA-2，其输出转换为整数。）

1.  2.

    记 ![$$L_n$$](img/516136_1_En_1_Chapter_TeX_IEq185.png) 为群阶 *n* 的位数，令 *z* 为 *e* 的 ![$$L_{n}$$](img/516136_1_En_1_Chapter_TeX_IEq186.png) 最左边的位。(注意 *z* 可以是 > *n*，但在二进制表示中不应该更长。)

1.  3.

    从 ![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq187.png) 中选择一个密码学上安全的随机整数 *k*。

1.  4.计算曲线点![$$\begin{aligned} (x_{1},y_{1})=k\times G. \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ28.png)(1.28)

1.  5.计算![$$\begin{aligned} r=x_{1} (\text {mod}~ n). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ29.png)(1.29)如果 ![$$r=0$$](img/516136_1_En_1_Chapter_TeX_IEq188.png)，返回步骤 3。

1.  6.计算![$$\begin{aligned} s=k^{-1}(z+rd_{A}) (\text {mod}~ n). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ30.png)(1.30)如果 ![$$s=0$$](img/516136_1_En_1_Chapter_TeX_IEq189.png)，返回步骤 3。

1.  7.

    签名是 (*r*, *s*) 对。

**签名验证**。为了使鲍勃验证爱丽丝的签名，他必须拥有她公钥曲线点 ![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq190.png) 的副本。鲍勃可以如下验证 ![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq191.png) 是否为有效的曲线点。

1.  1.

    检查 ![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq192.png) 是否等于单位元素 *O*，并且其坐标 otherwise 有效。

1.  2.

    检查 ![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq193.png) 是否位于曲线上。

1.  3.

    检查![$$n\times Q_A = O$$](img/516136_1_En_1_Chapter_TeX_IEq194.png)。

如果![$$Q_A$$](img/516136_1_En_1_Chapter_TeX_IEq195.png)是一个有效的曲线点，Bob 继续按照以下步骤验证签名。

1.  1.

    验证*r*和*s*是否是![$$[1, n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq196.png)中的整数。如果不是，则签名无效。

1.  2.

    计算![$$e=\mathsf {hash}(m)$$](img/516136_1_En_1_Chapter_TeX_IEq197.png)，其中![$$\mathsf {hash}$$](img/516136_1_En_1_Chapter_TeX_IEq198.png)是签名生成中使用的同一函数。用*z*表示*e*的![$$L_{n}$$](img/516136_1_En_1_Chapter_TeX_IEq199.png)最左边的位。

1.  3.计算![$$\begin{aligned} u_{1}=zs^{-1} (\text {mod}~ n), \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ31.png)(1.31)![$$\begin{aligned} u_{2}=rs^{-1}(\text {mod} ~n). \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ32.png)(1.32)

1.  4.计算曲线点![$$\begin{aligned} (x_1,y_1) = u_1 \times G+u_2 \times Q_A. \end{aligned}$$](img/516136_1_En_1_Chapter_TeX_Equ33.png)(1.33)如果![$$(x_1,y_1) = O$$](img/516136_1_En_1_Chapter_TeX_IEq200.png)则签名无效。

1.  5.

    如果![$$r = x_1 (\text {mod} ~n)$$](img/516136_1_En_1_Chapter_TeX_IEq201.png)，则签名有效，否则无效。

### 1.4.5 ECDSA 与 RSA 对比

以相同的级别提供安全性，ECC 所需的密钥长度比 RSA 短得多。以下表格展示了 ECDSA 与 RSA 的比较。

| 安全级别（位） | 所需 RSA 密钥长度（位） | 所需 ECC 密钥长度（位） |
| --- | --- | --- |
| 80 | 1024 | 160–223 |
| 112 | 2048 | 224–255 |
| 128 | 3072 | 256–383 |
| 192 | 7680 | 384–511 |
| 256 | 15,360 | 512+ |
