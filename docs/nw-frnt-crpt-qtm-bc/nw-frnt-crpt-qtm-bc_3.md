© 版权编辑（如适用）和作者，独家许可给 Springer Nature Switzerland AG 2020K. S. Mohamed

# 密码学概念：完整性、认证、可用性、访问控制和不可否认

Khaled Salah Mohamed^(1)(1) 美国加利福尼亚州弗里蒙特市西门子业务关键词哈希认证不可否认 MAC 访问控制数字签名 HDCP 入侵检测 HMAC 免疫

## 3.1 完整性：哈希概念

为了验证在通道上传输的数据的完整性，使用消息认证码（MAC）来检查消息和认证，确保信息的完整性在传输过程中没有被修改。

哈希函数是将域中的值映射到范围值的数学函数。哈希函数是满足以下三个属性的特殊数学函数：

+   输入可以是任意大小的。

+   输出是固定的。

+   高效可计算，即映射应该是高效可计算的。

哈希函数的目的是为了产生消息或数据的“指纹”以进行认证。哈希函数 *H*(*m*) 将输入消息 *m* 映射到哈希值 *h*，如方程 (3.1) 所描述的那样。消息 *m* 的长度是任意的。哈希 *h* 是固定长度的。通常，*h* 被称为 *m* 的 *消息摘要*。图 3.1 展示了哈希功能的抽象层次！$$ h=H(m) $$(3.1)![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png](img/501530_1_En_3_Fig1_HTML.png)

图 3.1

哈希

密码散列函数是单向函数，因为从*m*找到哈希*h*易，但反之则不易。给定一条消息，很难找到另一条具有相同哈希值的消息。给定一个哈希函数，很难找到具有相同哈希值的两条消息。在密码学中，雪崩效应是与用于加密的数学函数的特定行为相关的术语。

### 3.1.1 SHA-3

SHA 是由 NIST 和 NSA 于 1993 年设计的，1995 年修订为**SHA-1**。该算法生成 160 位散列值。现在，它是最受欢迎的散列算法。**SHA-2**使用了 Davies–Meyer 结构，这是 Merkle–Damgård 结构的一个实例，其中包含一个由 ARX 网络构建的分组密码（有时称为 SHACAL-2），类似于 MD4。**SHA-3**（安全哈希算法 3）是安全哈希算法标准家族的最新成员。SHA-3 使用海绵构造，其中“吸收”到海绵中，然后结果被“挤出”。在吸收阶段，消息块被异或到状态的子集中，然后作为整体使用排列函数进行变换。在“挤压”阶段，输出块从相同的状态子集中读取，与状态变换函数交替。写入和读取的状态部分的大小称为速率，而不受输入/输出影响的部分的大小称为容量。容量决定了方案的安全性。最大安全级别是容量的一半。为了确保消息可以被均匀地分成 r 位块，需要填充。改变一个位会导致输出中的每个位以 50%的概率发生变化，展示了**雪崩效应**[1, 2]。简而言之，SHA2（和 SHA1）是使用 Merkle–Damgård 结构构建的。另一方面，SHA3 是使用海绵函数构建的。

#### 3.1.1.1 Merkle–Damgård 构造

在密码学中，默克尔-达姆高德构造或默克尔-达姆高德哈希函数是一种从抗碰撞的单向压缩函数构建抗碰撞密码哈希函数的方法。 此构造在设计许多流行的哈希算法（如 MD5，SHA1 和 SHA2）时使用。 默克尔-达姆高德哈希函数首先应用 MD 兼容的填充函数来创建大小是固定数字的输入（例如 512 或 1024）的输入 - 这是因为压缩函数无法处理任意大小的输入。 然后，哈希函数将结果分成固定大小的块，并使用压缩函数逐个处理它们，每次将一个输入块与前一轮的输出结合起来。 为了使构造安全，默克尔和达姆高德建议使用填充对消息进行填充，该填充编码了原始消息的长度[3–5]。

#### 3.1.1.2 海绵函数

在密码学中，海绵函数或海绵构造是一类具有有限内部状态的算法，它们接受任意长度的输入比特流，并生成任意所需长度的输出比特流。 海绵函数具有理论和实际用途。 它们可用于模拟或实现许多密码原语，包括密码哈希函数，消息认证码，掩码生成函数，流密码，伪随机数生成器和认证加密。 海绵函数由三个组件构建：状态存储器，用于转换状态存储器的函数和填充函数。 状态存储器分为两个部分：比特率和容量。 填充函数附加足够的位到输入字符串，使得填充输入的长度为比特率的整数倍[6]。

海绵函数的运作如下：

+   状态* S *被初始化为零。

+   输入字符串被填充。

+   对于每个* r *比特块* B *的填充输入：

    +   *R*被*R* XOR *B*替换

    +   *S*被*f*(*S*)替换。

+   状态存储器的*R*部分被输出。

+   重复直到输出足够的比特为止：

    +   *S*被*f*(*S*)替换。

    +   状态存储器的*R*部分被输出

如果剩余的比特少于*r*位，则*R*将被截断。

### 3.1.2 HMAC-SHA256（散列消息认证码，安全散列算法）

#### 3.1.2.1 术语

B

输入到批准的哈希函数的块大小（以字节为单位）。

*H*

SHA-256 哈希函数。

ipad

内部填充；字节 x′36′重复了 B 次。

*K*

主机和设备之间共享的秘密密钥。

*K*[0]

经过任何必要的预处理以形成*B*字节密钥的密钥*K*。

*L*

批准的哈希函数的输出的块大小（以字节为单位）。

opad

外部填充；字节 x′5c′重复了 B 次。

*t*

MAC 的字节数。

文本

HMAC 计算的消息；文本不包括填充密钥。

x′N′

十六进制表示法，其中字符串“N”中的每个符号代表四个二进制位。

||

连接。

xor

异或操作。

a、b、c

在计算哈希值*H*^(*i*)时使用的 w 位字的工作变量。

*H*^((*i*))

第*i*个哈希值。*H*^(*0*)是初始哈希值；*H*^(*N*)是最终哈希值，并用于确定消息摘要。

*H*[*j*]^((*i*))

第*i*个哈希值的第*j*个字，其中*H*[*0*]^(*i*)是哈希值*i*的最左边的字。

*K*[*t*]

用于哈希计算的迭代*t*的常量值。

*k*

在填充步骤期间附加到消息中的零的数量。

*l*

消息*M*的长度（以比特为单位）。

*m*

消息块*M*^((*i*)）中的比特数。

*M*

要进行哈希处理的消息。

*M*^(*i*)

大小为*m*比特的消息块*i*。

*M*[*j*]^(*i*)

第*i*个消息块的第*j*个字，其中*M*[*0*]^(*i*)是消息块*i*的最左边的字。

*n*

当对单词进行操作时要旋转或移位的比特数。

*N*

填充消息中的块数。

*T*

在哈希计算中使用的临时 *w-* 位单词。

*w*

单词中的比特数。

*W*[*t*]

消息调度的第 *t* 个 *w-* 位单词。

^

按位与运算。

*或*

按位或（“包容性或”）运算。

*异或*

按位异或（“排他或”）运算。

!

按位补码运算。

+

模 2^(*w*) 的加法。

≪

左移位运算，其中 *x* ≪ *n* 是通过丢弃字 *x* 的左端 *n* 位，然后在右侧用 *n* 个零进行填充来获得的。

≫

右移位运算，其中 *x* ≫ *n* 是通过丢弃字 *x* 的右端 *n* 位，然后在左侧用 *n* 个零进行填充来获得的。

#### 3.1.2.2 介绍

HMAC_SHA 是基于安全的密码哈希函数的消息和共享密钥认证协议。它可以有效防止在传输过程中数据被拦截和篡改。

消息认证码（MAC）是使用 HMAC SHA-256 计算的，如 [7–9] 所定义。HMAC SHA-256 计算以密钥和消息作为输入。生成的 MAC 是 256 位（32 字节），作为请求或响应的一部分嵌入到数据帧中。用于 MAC 计算的密钥是 256 位认证密钥。接收器使用与发射器相同的密钥和 HMAC 函数对接收到的数据进行 MAC 计算，并将计算结果与接收到的 MAC 进行比较。如果两个值匹配，则数据已被正确接收。

HMAC-SHA-256 是使用 SHA-256 哈希函数计算 HMAC 消息认证码的实现。哈希函数可以是迭代的，并将消息分解为固定大小的块，并对它们进行迭代处理。对于 SHA-256，消息大小小于 2⁶⁴。每个消息块有 512 位。消息被填充，以便可以将其解析为 N x 512 块。HMAC 计算的输出与底层哈希函数相同，在我们的情况下为 256 位（32 字节）宽。在本文中，我们提出了用于物联网（Io）应用的 HMAC-SHA-256（散列消息认证码，安全哈希算法）算法的低延迟硬件实现。图 3.2 和表格 3.1 描述了 HMAC 算法的逐步过程。SHA-256 是带有 256 位输出的 SHA-2。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png](img/501530_1_En_3_Fig2_HTML.png)

图 3.2

HMAC 构造的图解

表格 3.1

通用 HMAC 算法

| 步骤 | 逐步描述 |
| --- | --- |
| *步骤 1* | *K* = 32 字节，B = 64 字节，*K* ≠ *B* |
| *步骤 2* | *K* < *B*：在 *K* 的末尾追加零，以创建一个 *B* 字节的字符串 *K*[0]（*K* 将被追加 32 个零字节 0x00） |
| *步骤 3* | 用 *ipad* 对 *K*0 进行异或运算以生成一个 *B* 字节的字符串：***K***[**0**] xor ***ipad*** |
| *步骤 4* | 将数据流 *text* 追加到步骤 4 的结果字符串：**(*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*** |
| *步骤 5* | 将步骤 5 生成的流应用于 *H*：**H((*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*****)** |
| *步骤 6* | 用 *opad* 对 *K*[*0*] 进行异或运算：***K***[**0**] xor ***opad*** |
| *步骤 7* | 将步骤 5 的结果追加到步骤 6：**(*****K***[**0**] xor ***opad*****) &#124;&#124; H((*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*****)** |
| *步骤 8* | 对步骤 7 的结果应用*H*：***H*****((*****K***[**0**] xor ***opad*****) &#124;&#124;** ***H*****((*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*****))** |
| *步骤 9* | 将步骤 8 的结果的最左边的*t*字节选择为 MAC |

#### 3.1.2.3 HMAC 算法

如[7]所指定的，安全哈希算法 SHA-256 的消息块大小为 512 位（即，*B* = 64 字节）。 使用 HMAC 函数计算数据“text”的 MAC 时，执行以下操作：![$$ {\displaystyle \begin{array}{c}\mathrm{MAC}\left(\mathrm{text}\right)t=\mathrm{HMAC}\left(K,\kern0.5em \mathrm{text}\right)t\\ {}=H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{opad}\right)\parallel H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{ipad}\right)\parallel \mathrm{text}\right)\right)t\end{array}} $$](img/501530_1_En_3_Chapter_TeX_Equ2.png)(3.2)

#### 3.1.2.4 SHA-256 算法

1.  1.

    填充消息*M*：

在哈希计算开始之前，消息*M*将被填充。 这种填充的目的是确保填充后的消息是 512 位或 1024 位的倍数，具体取决于算法。 假设消息*M*的长度为 l 位。 在消息末尾附加位“1”，然后附加 k 个零位，其中 k 是满足等式 l + 1 + k = 448mod 512 的最小非负解。 然后附加一个 64 位块，该块等于用二进制表示的数字 l。 例如，（8 位 ASCII）消息“abc”的长度为 8 × 3 = 24，因此消息用一个位“1”填充，然后是 448 − (24 + 1) = 423 个零位，然后是消息长度，形成如图 3.3 所示的 512 位填充消息。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png](img/501530_1_En_3_Fig3_HTML.png)

图 3.3

SHA-256 消息示例

1.  2.

    将填充消息解析为 N 个 512 位消息块，*M*^((1)), *M*^((2)), …, *M*^((*N*)).

1.  3.

    设置初始哈希值，*H*^((0))：

在为每个安全哈希算法计算哈希之前，必须设置初始哈希值，*H*^((0))。*H*^((0)) 中的字数和数量取决于消息摘要大小。

对于 SHA-256，初始哈希值 *H*^((0)) 应由以下八个 32 位字组成，以十六进制表示：![公式图片](img/501530_1_En_3_Chapter_TeX_Equa.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equb.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equc.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equd.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Eque.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equf.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equg.png)![公式图片](img/501530_1_En_3_Chapter_TeX_Equh.png)

1.  4.

    预处理完成后，按顺序处理每个消息块，*M*^((1))、*M*^((2))、…、*M*^((*N*))，使用以下步骤：

对于 *i* = 1 到 *N*：

{

1.  1.

    准备消息调度，{*W*[*t*]}

![公式图片](img/501530_1_En_3_Chapter_TeX_Equi.png)

1.  2.

    初始化八个工作变量，*a, b, c, d, e, f, g,* 和 *h*，使用（*i* − 1）的哈希值：

![$$ a={H}_0^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equj.png)![$$ b={H}_1^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equk.png)![$$ c={H}_2^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equl.png)![$$ d={H}_3^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equm.png)![$$ e={H}_4^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equn.png)![$$ f={H}_5^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equo.png)![$$ g={H}_6^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equp.png)![$$ h={H}_7^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equq.png)

1.  3.

    对于 *t* = 0 到 63

    {

![$$ {T}_1=h+\sum \limits_1^{\left\{256\right\}}(e)+ Ch\left(e,f,g\right)+{K}_t^{\left\{256\right\}}+{W}_t $$](img/501530_1_En_3_Chapter_TeX_Equr.png)![$$ {T}_2=\sum \limits_0^{\left\{256\right\}}(a)+ Maj\left(a,b,c\right) $$](img/501530_1_En_3_Chapter_TeX_Equs.png)![$$ h=g $$](img/501530_1_En_3_Chapter_TeX_Equt.png)![$$ g=f $$](img/501530_1_En_3_Chapter_TeX_Equu.png)![$$ f=e $$](img/501530_1_En_3_Chapter_TeX_Equv.png)![$$ e=d+{T}_1 $$](img/501530_1_En_3_Chapter_TeX_Equw.png)![$$ d=c $$](img/501530_1_En_3_Chapter_TeX_Equx.png)![$$ c=b $$](img/501530_1_En_3_Chapter_TeX_Equy.png)![$$ b=a $$](img/501530_1_En_3_Chapter_TeX_Equz.png)![$$ a={T}_1+{T}_2 $$](img/501530_1_En_3_Chapter_TeX_Equaa.png)}

1.  4.

    计算第 *i* 个中间哈希值 *H*^((*i*)):

![$$ {H}_0^{(i)}=a+{H}_0^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equab.png)![$$ {H}_1^{(i)}=b+{H}_1^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equac.png)![$$ {H}_2^{(i)}=c+{H}_2^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equad.png)![$$ {H}_3^{(i)}=d+{H}_3^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equae.png)![$$ {H}_4^{(i)}=e+{H}_4^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equaf.png)![$$ {H}_5^{(i)}=f+{H}_5^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equag.png)![$$ {H}_6^{(i)}=g+{H}_6^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equah.png)![$$ {H}_7^{(i)}=h+{H}_7^{\left(i-1\right)} $$](img/501530_1_En_3_Chapter_TeX_Equai.png)

}

在重复执行一至四步总共 *N* 次（即处理 *M*^(*(N)*)) 后，消息 *M* 的结果为 512 位消息摘要，

![$$ {H}_0^{(N)}{H}_1^{(N)}{H}_2^{(N)}{H}_3^{(N)}{H}_4^{(N)}\left|{H}_5^{(N)}{H}_6^{(N)}\left|{H}_7^{(N)}\right.\right.. $$](img/501530_1_En_3_Chapter_TeX_Equaj.png)

#### 3.1.2.5 HMAC-SHA256 举例说明

此 HMAC-SHA256 计算示例使用 284 字节的消息和 32 字节的密钥。 

*输入*：

+   ***文本***：284 字节的消息

    +   000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003.

+   ***密钥***：32 字节。

    +   0000000000000000000000000000000000000000011010110110010101111001

*步骤：*

1.  1.K[0]：在密钥末尾附加 32 字节的零，以创建一个 64 字节的消息

    +   00000000000000000000000000000000000000000110101101100101011110010000000000000000000000000000000000000000000000000000000000000000

1.  2.创建一个 64 字节的 ipad 模式，重复十六进制值 0x36。

    +   36363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636

1.  3.创建一个 64 字节的 opad 模式，重复十六进制值 0x5c。

    +   5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c

1.  4.将 K[0] 与 ipad 进行异或运算：***K***[**0**] xor ***ipad***。

    +   36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636

1.  5.在末尾连接文本：**(*****K***[**0**] xor ***ipad*****) ||** ***text***

    +   36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003

1.  6.对上面的值使用 SHA-256 算法进行哈希。

    +   上述方式扩展了消息。在这种情况下，待散列的数据消息为 2784 位（348 字节）。为了获得一个长度是 512 位倍数的填充消息，将 2784 位的消息填充为一个比特，然后是 223 个零比特，然后是表示消息长度的 64 位。消息现在变成了一个 6*512 位的填充消息。然后使用上述的 SHA-256 算法处理该填充消息以获得哈希值。

    +   663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1

1.  7.将附加密钥与 opad 进行异或运算：***K***[**0**] xor ***opad***

    +   5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c

1.  8.连接步骤 6 和步骤 7 的结果：

    +   **(*****K***[**0**] xor ***opad*****) || H((*****K***[**0**] xor ***ipad*****) ||** ***text*****)**

    +   5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1

1.  9.对步骤 8 的输出进行哈希，使用 SHA-256

    +   在进行 SHA-256 算法的哈希之前，消息应进行填充。在本例中，消息长度为 768 位（96 字节）。为了获得一个多于 512 位的填充消息，消息被填充了一个位，然后是 191 个零位，然后是表示消息长度的 64 位。消息现在是 2*512 位的填充消息。然后，使用上面解释的 SHA-256 算法处理这个填充的消息，以获得哈希值。a771af5ea520f789c0e6668c4c9cb6f30111d381503917af47af37c53b7adca2。

### 3.1.3 MD5 算法

MED5 算法的工作原理如下：

+   填充消息，使其长度为 448 mod 512。

+   将一个 64 位长度值附加到消息上。

+   初始化四字（128 位）MD 缓冲区（A、B、C、D）。

+   在 16 字（512 位）块中处理消息：在消息块和缓冲区上进行四轮 16 位操作。将输出添加到缓冲区输入以形成新的缓冲区值。

+   输出哈希值是最终缓冲区值。

### 3.1.4 布莱克

BLAKE 是一种基于丹·伯恩斯坦的 ChaCha 流密码的密码哈希函数，但在每个 ChaCha 轮之前会添加一个输入块的置换副本，与轮常量进行异或运算。与 SHA-2 一样，有两种不同字长的变体。ChaCha 在一个 4 × 4 的字数组上操作。BLAKE 重复地将一个 8 个字的哈希值与 16 个消息字结合在一起，将 ChaCha 结果截断以获得下一个哈希值。BLAKE-256 和 BLAKE-224 使用 32 位字，并分别产生 256 位和 224 位的摘要大小，而 BLAKE-512 和 BLAKE-384 使用 64 位字，并分别产生 512 位和 384 位的摘要大小。基于 BLAKE 的 BLAKE2 哈希函数于 2012 年宣布。基于 BLAKE2 的 BLAKE3 哈希函数于 2020 年宣布。BLAKE2 是一个密码哈希函数，**比 MD5、SHA-1、SHA-2 和 SHA-3 更快**（图 3.4），但至少与最新的标准 SHA-3 一样安全[11]。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png](img/501530_1_En_3_Fig4_HTML.png)

图 3.4

哈希函数速度 [10]

## 3.2 完整性：数字签名

在数字签名中，我们颠倒了公钥和私钥的角色。加密的哈希被称为“数字签名”，如图 3.5 所示。数字签名在电子商务中使用。对于真实系统，我们正在发送带有数字签名的消息，如图 3.6 所示。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png](img/501530_1_En_3_Fig5_HTML.png)

图 3.5

数字签名

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png](img/501530_1_En_3_Fig6_HTML.png)

图 3.6

带数字签名的消息发送

## 3.3 鉴权

鉴权回答以下问题“接收方如何知道远程通信实体是声称的那个实体？”。鉴权确保消息未被更改。消息来自所谓的发送方。消息序列未被更改。示例显示了一个鉴权邮件，如图 3.7，其中 Alice 想要提供发送者鉴权消息完整性，因此 Alice 对消息进行数字签名并发送消息和数字签名。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png](img/501530_1_En_3_Fig7_HTML.png)

图 3.7

鉴权邮件

### 3.3.1 HDCP

HDCP 是高带宽数字内容保护的缩写。HDCP 是由英特尔公司开发的规范，用于保护通过 DVI/HDMI 接口的数字娱乐内容。

数字内容保护有限责任公司（DCP）是授权 HDCP 的组织。HDCP 的工作原理在图 3.8 中有解释。每个 HDCP 发射器和接收器都有 40 个唯一的 56 位私钥。这些密钥由 DCP 提供给经许可的 HDCP 芯片供应商，在将芯片销售给设备制造商之前将密钥预装到芯片上。这些密钥绝不能离开芯片，也不能被任何其他设备读取。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png](img/501530_1_En_3_Fig8_HTML.png)

图 3.8

HDCP 的工作原理。**它由认证、数据加密组成**。

每个 HDCP 芯片还有一个称为密钥选择向量（KSV）的公共 40 位值。每个 KSV 由 20 个二进制 1 和 20 个二进制 0 组成。所有经许可的 HDCP 设备的 KSV 和密钥根据密码密钥交换协议在数学上相关联。在此方案中，任何两个经许可的设备都可以交换 KSV，并使用它们及其私钥来生成共享密钥。这个共享密钥可以用来加密和解密 TMDS 流。

### 3.3.2 验证码

CAPTCHA 是一个需要用户输入预先确定代码的验证过程。CAPTCHA 代表*Completely Automated Public Turing test to tell Computers and Humans Apart*。CAPTCHA 的存在是为了防止垃圾邮件通过自动表单提交填充您的站点，垃圾用户帐户，或更糟的是感觉到站点上可以利用的安全漏洞。CAPTCHA 的工作原理是提供一个对人类来说简单但对机器人来说难以回答的问题。已经开发了不同类型的 CAPTCHA，包括简单的数学问题和分类问题[12]。

## 3.4 可用性：入侵检测

### 3.4.1 人工免疫系统

人类暴露于一系列有害微生物（病原体或抗原）中，可以是单细胞或多细胞，如细菌、寄生虫和病毒。这些微生物可以损害人体。人体的天然免疫系统（NIS）是一个非常复杂的防御系统，可以防止这种损害。没有一个中央器官来控制免疫系统的功能。NIS 的部分包括：

1.  1.

    血液：尤其是白细胞。

1.  2.

    淋巴结：储存 T 细胞和 B 细胞，并**捕获**抗原/病原体。

1.  3.

    胸腺：产生 T 淋巴细胞，循环于全身寻找异常。

1.  4.

    骨髓：产生 B 淋巴细胞。

免疫器官分布于全身，见图 3.9。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png](img/501530_1_En_3_Fig9_HTML.png)

图 3.9

免疫器官分布于全身。

免疫系统在多年间有一个学习阶段。免疫系统能识别的每一个元素被称为***抗原*** **。** 最初属于我们身体并且对其功能无害的细胞被称为*(****自身抗原***），而导致疾病的元素被称为(***非自身抗原***）。当身体受到某些微生物的攻击时，免疫系统会记住它们以便能够区分外来细胞和身体细胞。

免疫系统由两种不同的细胞组成，称为 B 细胞和 T 细胞。这两种细胞在识别抗原的方式和功能角色方面相似但不同。B 细胞可以识别血液中的抗原，而 T 细胞需要其他辅助细胞呈现抗原。抗原被分子覆盖，称为*表位（epitopes）*。这使它们可以被 B 细胞表面的受体分子所识别，称为*抗体（Ab）*。

NIS 是多层次的系统。人体免疫系统（HIS）由三个层次组成：皮肤、先天免疫和后天免疫。皮肤是第一个屏障。第二个屏障是诸如温度之类的生理条件，为有害生物提供不适宜的生存条件。一旦病原体进入体内，它们将被先天免疫系统如嗜吞细胞（一种通过吞噬有害异物来保护身体的细胞）和后天免疫应答系统（淋巴细胞）处理，后者被认为是一种检测器。

当病原体与覆盖淋巴细胞表面的受体建立分子键时，病原体就被检测到。与病原体结合的受体数量将决定淋巴细胞对给定病原体的亲和力。如果结合很可能发生，则许多受体将与病原体表位结合，导致对该病原体的高亲和力；如果结合不太可能发生，则很少的受体将与表位结合，淋巴细胞对该病原体的亲和力较低。只有当淋巴细胞对病原体的亲和力超过某一亲和力阈值时，淋巴细胞才能被病原体激活。这些层次显示在图 3.10 中。B 细胞如何识别抗原的过程显示在图 3.11 中，图 3.12 显示了一个说明性示例。此外，图 3.13 显示了结合过程。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png](img/501530_1_En_3_Fig10_HTML.png)

图 3.10

人体内的保护层

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png](img/501530_1_En_3_Fig11_HTML.png)

图 3.11

B 细胞识别抗原

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png](img/501530_1_En_3_Fig12_HTML.png)

图 3.12

(**a**) 淋巴细胞识别红色病原体，(**b**) 淋巴细胞不识别红色病原体

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png](img/501530_1_En_3_Fig13_HTML.png)

图 3.13

当病原体与覆盖淋巴细胞表面的受体之间建立分子键时，病原体被检测到。

在 1990 年代，受到自然或生物免疫系统启发的**人工免疫系统（AIS）**已经成为计算智能系统中的一个新分支。AIS 作为连接两个领域的桥梁如图 3.14 所示。到目前为止，已经为不同应用开发了大量基于 AIS 的算法，例如模式识别、计算机安全、故障检测等各种应用 [13–30]。在本文中，首次提出了将 AIS 用于 RTL 级安全。所提出的系统由 Verilog 实现，并在 Xilinx FPGA 上进行测试，因为它为快速实现硬件架构和快速重新编程以及对同一硬件架构的各种修改版本进行实验测试提供了高效灵活的平台。也可以使用其他人工机器学习算法 [31]。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png](img/501530_1_En_3_Fig14_HTML.png)

图 3.14

AIS 是连接两个领域的桥梁

人工免疫系统（AIS）中的三个基本概念是亲和力、克隆选择算法和负选择算法。

1.  A.

    亲和力

在 AIS 中，抗体和抗原之间的亲和力是用欧几里得距离计算的。

如果抗体的坐标给定为:![$$ \mathrm{Ab}=\left({\mathrm{Ab}}_1,{\mathrm{Ab}}_2,\dots, {\mathrm{Ab}}_{\mathrm{n}}\right) $$](img/501530_1_En_3_Chapter_TeX_Equ3.png)(3.3)，抗原的坐标给定为:![$$ \mathrm{Ag}=\left({\mathrm{Ag}}_1,{\mathrm{Ag}}_2,\dots, {\mathrm{Ag}}_{\mathrm{n}}\right) $$](img/501530_1_En_3_Chapter_TeX_Equ4.png)(3.4)，那么它们之间的距离由以下方程得出:![$$ \mathrm{D}=\sqrt{\sum \limits_{i=o}^n{\left(\mathrm{A}{b}_i-\mathrm{A}{g}_i\right)}²\;} $$](img/501530_1_En_3_Chapter_TeX_Equ5.png)(3.5)

1.  B.

    负选择算法和**克隆选择**

负选择算法是用于 NIS 的主要算法。*P*是自集合。*C*是生成的候选非自集合。*M*是检测器。*P**是要保护的模式（怀疑）。该算法可以总结如下（图 3.15）：

1.  1.

    生成随机候选元素(*C*)。

1.  2.

    将*C*中的元素与*P*中的元素进行比较。如果匹配发生，则拒绝它。它是一个自模式。否则将*C*的这个元素存储在检测器集合*M*中。

1.  3.

    在生成检测器集合(*M*)后，算法的下一阶段是监视系统是否存在非自模式。对于检测器集合的所有元素，即对应于非自模式的元素，检查它是否与*P**的元素匹配，如果是，则识别出非自模式。

1.  4.

    必须采取行动。当 B 细胞受体识别具有一定亲和力的非自身抗原时，它被选择增殖并产生大量抗体。

1.  5.

    具有高抗原亲和力的激活的 B 细胞被选中成为具有长寿命的记忆细胞。这些记忆细胞在将来对相同抗原模式或类似抗原模式的反应中占主导地位，这被称为**克隆选择**。

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png](img/501530_1_En_3_Fig15_HTML.png)

图 3.15

**负选择算法是 NIS 中主要使用的算法**。 (**a**) 生成探测器集合。 (**b**) 监控不希望的（非自身）模式的存在。 *P*是自身集合。 *C*是生成的候选非自身。 *M*是探测器。 *P**是要保护的模式（怀疑）

## 3.5 访问控制

安全级别和解决方案总结在表 3.2 和图 3.16 中。密码是两个方之间共享的秘密。智能卡是内嵌电子元件的卡片，能够提供长密码或满足挑战要求。它可能具有显示屏，以允许读取密码，或者可以直接插入。生物识别使用一个或多个内在的身体特征或行为特征来识别某人，例如指纹识读器、手掌识读器、视网膜扫描或生物识别技术。虚拟专用网络（VPN）允许您在互联网上创建与另一个网络的安全连接。VPN 可用于访问受区域限制的网站，保护您在公共 Wi-Fi 上的浏览活动等。当您连接您的计算机（或其他设备，如智能手机或平板电脑）到 VPN 时，计算机会表现得好像它在同一个本地网络上一样。您所有的网络流量都通过安全连接发送到 VPN。因为您的计算机表现得好像它在网络上，这使得您可以安全地访问本地网络资源，即使您身在世界的另一边。您还可以像在 VPN 所在地一样使用互联网，这在您使用公共 Wi-Fi 或想要访问地理限制的网站时有一些好处[32]。表 3.2

安全级别和解决方案

| 安全级别 | 解决方案 |
| --- | --- |
| 低 | 你所知道的东西（PIN 码、密码） |
| 媒介 | 你所知道的东西 + 你所拥有的东西（门禁卡） |
| 高级 | 你知道的东西 + 你拥有的东西 + 你的本质（指纹） |

![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png](img/501530_1_En_3_Fig16_HTML.png)

图 3.16

访问控制：安全级别

## 3.6 不可否认性：可信第三方

确保合同或通信的一方无法否认其在文件上的签名的真实性或其起源的消息的发送。你不能否认自己做过的事情。为了减轻人们否认自己签名的风险，标准做法是涉及到一个可信的第三方。对于数字信息，最常用的**TTP**是证书颁发机构，它颁发公钥证书。任何人都可以使用公钥证书来验证数字签名，而不需要签名者和验证者之间的共享密钥。证书颁发机构的作用是权威地声明证书属于谁，意味着这个人或实体拥有相应的私钥。然而，数字签名在合法和伪造用途上在法庭上是相同的。拥有私钥的人可以创建有效的数字签名[33]。

## 3.7 结论

本章探讨了不同的密码学概念，如认证、完整性、可用性、访问控制和不可否认性。它介绍了数字签名、哈希函数和消息认证码（MAC）的概念。
