© 编辑（如适用）和作者，独家授权给施普林格自然瑞士公司 2020K. S. 莫哈默德[`doi.org/10.1007/978-3-030-58996-7_2`](https://doi.org/10.1007/978-3-030-58996-7_2)

# 2. 密码学概念：保密

卡莱德·萨拉赫·莫哈默德^(1 )(1)A Siemens Business, Fremont, CA, USA 关键词加密对称非对称 RSA 高级加密标准 DES 密码椭圆曲线密钥交换密码分析

## 2.1 密码学历史

密码学一词源自希腊词汇 Kryptos。Kryptos 用于描述任何隐藏、遮蔽、秘密或神秘的事物。密码学是研究数学技术，用于通过不安全的信道安全传输私密消息。密码学是保护我们的数据免受不同类型攻击者的基本技术，如中断、修改、伪造等。它已存在 2000 多年。他们给奴隶剃头，将消息刺青在头上，然后让头发生长[1]。密码学在书写中的第一次记录使用可以追溯到公元前约 1900 年，当时一名埃及抄写员在铭文中使用了非标准的象形文字。一些专家认为，密码学是在书写发明后的某个时候自发出现的，其应用范围从外交信函到战时作战计划。凯撒密码：将字母表中的每个字母按固定数量移位。很容易破解。维吉尼亚多表密码将凯撒的移位密码推广为多表密码。它使用关键字来选择加密行。*替换密码*：使用字典的 26 个字母的排列。很容易破解。然后在现代，我们有许多密码学算法，我们将在本章的其余部分中解释。现代密码学算法基于将大整数分解为其质数的基本过程，这被认为是棘手的[2][3]。在*对称*和*非对称*加密系统中，加密是将原始文本更改为不可读形式的过程，解密过程从无意义的文本中获取原始数据。对于分组密码，使用相等大小的明文和密文避免了数据扩展。在本章中，将讨论机密性。加密是实现机密性的主要工具[4]–[6]。

## 2.2 对称加密

图 2.1 显示了不同对称加密算法的摘要。对称意味着发送者和接收者有一个共享的秘密密钥。有两个基本操作可以构建强加密算法：*混淆* 和 *扩散*。在混淆中，加密操作会使密钥与密文之间的关系变得模糊，而实现混淆的常见元素是替换。在扩散中，加密操作会使一个明文符号的影响分散到许多密文符号中，其目标是隐藏明文的统计属性，实现扩散的常见元素是通过置换（即，转位）。雪崩效应被认为是任何加密算法的理想属性之一。无论是密钥还是明文的轻微变化都应导致密文的显著变化。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png](img/501530_1_En_2_Fig1_HTML.png)

图 2.1

对称加密算法。对称意味着发送者和接收者有一个共享的秘密密钥

### 2.2.1 历史算法：基于字母的算法

#### 2.2.1.1 凯撒密码

这是密码学最古老和最早的例子之一，由罗马帝国皇帝**凯撒大帝**在高卢战争期间发明。在这种算法中，字母 A 到 W 通过用字母代表字母的方法进行加密，该字母在字母表中的位置比原字母向前三个位置，而剩余的字母 A、B 和 C 则用 X、Y 和 Z 代表。这意味着使用了“偏移”为 3，虽然通过使用 1 到 25 之间的任何数字，我们也可以对加密文本产生类似的效果。因此，如今，偏移通常被视为凯撒密码（图 2.2）[7]。凯撒密码的 Python 代码显示在图 2.3 中。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png](img/501530_1_En_2_Fig2_HTML.png)

图 2.2

凯撒密码

*加密：C = P + K mod 26 (1)*

*解密：P = C − K mod 26 (2)*

![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png](img/501530_1_En_2_Fig3_HTML.png)

图 2.3

凯撒密码示例的 Python 代码：字母偏移 1 位

#### 2.2.1.2 代换密码

在代换密码中，我们取字母表字母并将它们按照正确的字母表顺序放置在随机顺序下。在加密和解密中，使用相同的密钥。这里的加密规则是“每个字母被其下面的字母替换”，而解密规则则相反[8]。代换密码不会通过固定数字进行偏移。而是通过随机数字进行偏移。代换密码的 Python 示例显示在图 2.4 中。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png](img/501530_1_En_2_Fig4_HTML.png)

图 2.4

代换密码示例的 Python 代码

#### 2.2.1.3 位移/多表密码

而不是替换字母，重新排列它们。移位可以被定义为通过规则和特定密钥在明文中对字母的更改。列移位密码可以被认为是移位密码中最简单的类型之一，有两种形式：第一种称为“完整的列移位”，而第二种称为“不完整的列移位”。无论使用哪种形式，都要使用矩形形状来水平表示书写的明文，其宽度应与正在使用的密钥的长度相对应。可以有任意多行以写入消息。当使用完整的列移位时，明文被写入，所有空列都填充了空值，以便每列的长度相同[9]。密钥不能有重复的字母。列移位密码示例的 Python 代码如图 2.5 所示。算法可以总结如下：

1.  1.

    消息按照固定长度的行写出，然后再按列读出，列根据密钥按某种乱序选择。

1.  2.

    行的宽度和列的排列通常由一个关键字定义。

1.  3.

    例如，密钥“KHALED”的长度为 6，排列是由关键字中字母的字母顺序定义的。在这种情况下，顺序将是“3 6 5 2 1 4”。

1.  4.

    任何多余的空格都填充了空值或留空。

1.  5.

    最后，消息按照关键字指定的顺序按列读取。

1.  6.

    要解密它，接收者必须通过将消息长度除以密钥长度来计算列长度。

1.  7.

    然后，再次按列将消息写出，然后通过重新组合关键字重新排序列。

![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png](img/501530_1_En_2_Fig5_HTML.png)

图 2.5

用于列移位密码示例的 Python 代码

#### 2.2.1.4 一次性密码本加密

现有的加密算法通常采用拥有较大密钥空间和复杂算法的常见策略。对于对称加密，使用一次性密码本是解决密钥分发问题的最简单方案。然而，随着技术的不断进步，越来越容易破解广泛使用的算法。一次性密码本的长度增加也是一个令人担忧的问题。多表密码持续了将近 400 年。1882 年，Frank Miller 发明了被称为一次性密码本的密码。在一次性密码本中，选择了一个与明文消息长度相同的密钥。明文中的偏移从不遵循重复模式，加密消息具有均匀的频率分布，从而不会泄漏信息。一次性密码本（OTP）密码由于以下原因是不可破解的[10]：

+   密钥与给定消息一样长。

+   密钥是真正随机的，特别是自动生成的。

+   密钥和明文计算为模 10/26/2。

+   每个密钥应该*仅使用一次*，并由发送方和接收方销毁。

+   应该有两份密钥副本：一份给发送方，另一份给接收方。

一次性密码本的问题在于，为了创建这样的密码，其密钥应该与明文一样长甚至更长。换句话说，如果您有一个 500 兆字节的视频文件需要加密，您将需要一个至少 4 吉比特长的密钥。

### 2.2.2 现代算法：基于比特的算法

#### 2.2.2.1 流密码

流密码使用从密钥生成的伪随机比特，并通过对明文和伪随机比特进行异或运算来加密明文。流密码使用类似于块密码的概念工具。替换是主要工具：每个明文的比特或字节通过异或运算与密钥材料相结合，将明文比特替换为密文比特。二进制异或运算非常简单。只有两种可能的值，1 和 0，如果两个输入相同，则结果为 0；否则为 1 [11]。流密码的安全性完全取决于“合适”的密钥流，而随机性起主要作用，因此随机数生成器 (RNG) 对此非常重要。*神经*密码学是公钥密码方案的新来源，它不基于数论，并且具有较少的计算时间和内存复杂性。神经密码学可用于在两个方之间生成一个公共秘密密钥 [12]。

##### E0 密码

E0 是蓝牙协议中使用的流密码。它生成一系列伪随机数，并使用异或运算符与数据结合。密钥长度可能有所不同，但通常为 128 位。在每次迭代中，E0 使用四个不同长度的移位寄存器（25、31、33、39 位）和两个内部状态（每个 2 位长）生成一个比特。在每个时钟周期中，寄存器被移位，并且两个状态使用当前状态、前一个状态和移位寄存器中的值进行更新。然后从移位寄存器中提取四位并将它们相加。该算法使用异或运算符将该和与 2 位寄存器中的值异或。结果的第一个比特用于编码 [13]。

#### 2.2.2.2 块密码

在块密码中，通常提到两个值：块大小和密钥大小。安全性取决于两者的值。许多块密码使用 64 位块或 128 位块。由于块的大小不宜过大，因此内存占用和密文长度较小。关于密文长度，在块密码中处理的是块而不是位。块密码可以是对称的或非对称的，稍后将在本章中讨论。

我们从*明文*开始。那是你可以阅读的东西。我们对明文应用数学算法。

该算法是*密码*。明文被转化为*密文*。在对称加密中，同一密钥用于加密和解密数据。发送方和接收方之间共享的密钥 K 应保密。加密/解密过程可以由等式(2.1)建模，并可见于图 2.6：![$$ P={D}_K\left({E}_k(P)\right) $$](img/501530_1_En_2_Chapter_TeX_Equ1.png)(2.1)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png](img/501530_1_En_2_Fig6_HTML.png)

图 2.6

对称密钥加密

对称加密速度快，适用于大数据量的加密和解密。对称加密算法的比较分析如表 2.1 所示。表 2.1

对称加密算法的比较分析[14, 15]

| 算法/参数 | DES | 3DES | AES | 布洛菲斯 |
| --- | --- | --- | --- | --- |
| 发表 | 1977 | 1998 | 2001 | 1993 |
| 由 | IBM | IBM | 文森特·里曼，琼·达曼 | 布鲁斯·施耐尔 |
| 算法结构 | 菲斯特尔 | 菲斯特尔 | 替代-置换 | 菲斯特尔 |
| 块密码 | 二进制 | 二进制 | 二进制 | 二进制 |
| 密钥长度 | 56 位 | 112 位，168 位 | 128 位，192 位和 256 | 32-448 位 |
| 灵活性或修改 | 否 | 是，从 56 位扩展到 168 位 | 是，256 位密钥大小是 64 的倍数 | 是，64-448 位密钥大小是 32 的倍数 |
| 轮数 | 16 | 48 | 10、12、14 | 16 |
| 块大小 | 64 位 | 64 位 | 128 位 | 64 位 |
| 吞吐量 | 低于 AES | 低于 DES | 低于 Blowfish | 高 |
| 安全级别 | 充分的安全性 | 充分的安全性 | 出色的安全性 | 出色的安全性 |
| 加密速度 | 慢 | 非常慢 | 快 | 快 |
| 效率 | 在软件和硬件中都较慢 | 在软件中较慢 | 在软件和硬件中都有效 | 在软件中高效 |
| 攻击 | 暴力破解 | 暴力破解、已知明文、已选明文 | 侧信道攻击 | 字典攻击 |

##### Rijndael 算法

Rijndael 是一种对称密钥加密算法，构建为块密码。它支持 128、192 和 256 位的密钥大小，数据处理以 128 位块为单位进行。此外，块大小可以与相应的密钥大小相同。这个最后的规范使 Rijndael 超过了 AES 设计条件所要求的限制，而高级加密标准本身被视为 Rijndael 算法的子集[16]。

##### SAFER 算法

在密码学中，SAFER（Secure And Fast Encryption Routine）是由 James Massey（IDEA 的设计者之一）代表 Cylink Corporation 设计的一类分组密码算法。第一个 SAFER 密码是 SAFER K-64，由 Massey 于 1993 年发布，块大小为 64 位。“K-64”表示 64 位密钥大小。人们对带有更大 128 位密钥版本的 SAFER 有一定的需求。该算法因几个原因而引起了兴趣。它是为软件设计的。与 DES 甚至 IDEA 不同，它不将块分成一些部分，其中的一些部分影响其他部分；相反，明文通过 S-boxes 直接改变，解密时通过它们的逆旋转替换。SAFER 使用了八轮。一轮的第一步是将该轮的第一个子密钥应用于该块的 8 个字节。每个子密钥字节应用于块的每个字节的操作取决于使用了哪个字节：序列是 XOR，add，add，XOR，XOR，add，add，XOR。然后使用 S-box。XOR 应用的字节通过常规的 S-box；通过加法应用的字节通过逆 S-box [17]。

##### AES 算法

数据加密标准（DES）是 2001 年之前的加密标准，后来被 AES 取代。高级加密标准（AES）是由美国国家标准与技术研究所（NIST）于 2001 年确定的电子数据加密的当前标准 [18]。AES 基于* Rijndael*密码，它是一个迭代块密码，具有固定的块长度并支持可变的密钥长度。使用 128 位块长度和三种不同的密钥大小，分别为 128、192 和 256 位，需要进行 10、12 和 14 轮加密。图 2.7 和图 2.8 分别显示了 AES 加密和解密。AES 的工作如下（图 2.9）：

1.  1.

    添加轮密钥：轮密钥与明文进行 XOR 运算，然后结果将转换为 4× 4 *矩阵*（状态）。

1.  2.

    Sub-Byte 转换是一个非线性的*替换*操作，适用于字节。它基于 Galois 场 GF(2⁸)，其不可约多项式为*m*(*x*) = *x*⁸ + *x*⁴ + *x*³ + *x* + 1，可以使用查找表完成。

1.  3.

    Shift Row 转换*将输入状态的每一行向左旋转*；第一行保持不变；第二行将向左旋转 1 步，而第二行将向左旋转两步；第三行将向左旋转 3 步。

1.  4.

    Mix columns：每个输入列被视为 GF(2⁸)上的多项式，并且*与常数多项式*a*(*x*) = {03}*x*3 + {01}*x*² + {01}*x* + {02}模*x*⁴ + 1 相乘。 *a*(*x*)的系数也是 GF(2⁸)的元素，并且在这个方程中用十六进制值表示。逆混合列转换是将每一列与*a*(*x*) = {0*B*}*x*3 + {0*D*}*x*² + {09}*x* + {0*E*}模*x*⁴ - 1 相乘。

1.  5.

    密钥扩展。

![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig7_HTML.png](img/501530_1_En_2_Fig7_HTML.png)

图 2.7

AES 加密

![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig8_HTML.png](img/501530_1_En_2_Fig8_HTML.png)

图 2.8

AES 解密

![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig9_HTML.png](img/501530_1_En_2_Fig9_HTML.png)

图 2.9

AES 加密

##### Blowfish

Blowfish 是一种 64 位对称密钥分组密码，用于高效加密数据。Blowfish 算法具有费斯特结构，这意味着它会对简单的加密函数进行 16 次迭代。它使用可变长度的密钥，范围从 32 位到最大 448 位。它是由安全专家布鲁斯·施奈尔于 1993 年首次引入的，并且从未被破解[19]。Twofish，也是由施奈尔设计，是 Blowfish 的继任者，它包含一个 128 位块以及长达 256 位的密钥[20]。

##### 描述

数据加密标准（DES）是由美国国家标准与技术研究院（NIST）发布的对称密钥分组密码。DES 是费斯特密码的一种实现。它使用 16 轮费斯特结构。分组大小为 64 位。尽管密钥长度为 64 位，但 DES 的有效密钥长度为 56 位，因为 64 位密钥中的 8 位仅用作加密算法的校验位（仅起校验位作用）。DES 结构如图 2.10 所示[21]。*费斯特密码*不是特定的分组密码方案。它是一个设计模型，从中衍生出许多不同的分组密码。DES 只是费斯特密码的一个示例。基于费斯特密码结构的加密系统使用相同的算法进行加密和解密。加密过程使用费斯特结构对明文进行多轮处理，每轮由“替代”步骤和置换步骤组成。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png](img/501530_1_En_2_Fig10_HTML.png)

图 2.10

DES 结构

##### 三重 DES/3DES

三重 DES 的基本方法是基于 DES。它将明文加密三次。三重 DES 的总密钥长度为 192 位，即在此分组密码中使用了三个 64 位密钥。与 DES 一样，每个密钥的有效长度为 56 位。在三重 DES 中，第一个加密的密文再次被第二个密钥加密，然后第三个密钥加密生成的加密密文。虽然此算法比 DES 安全得多，但对于许多实际应用来说速度太慢[22]。

##### RC4（Rivest Cipher 4）

这是 1987 年发布的一种流密码。这些技术的缺点是密钥流的生成，这是一个潜在的长序列，由 40 位至 128 位的密钥和 24 位的初始化向量组成。但加密很简单；实际的明文与密钥流进行异或操作。密钥输入是一个伪随机比特生成器，它创建一个字节号，即生成器的输出，并称之为密钥流。然后，密钥流与明文逐字节进行异或操作以生成密文。在没有密钥知识的情况下，无法预测密钥流。

##### RC5（Rivest Cipher 4）

这是 1994 年发布的一个分组密码算法，它使用可变的块大小、密钥大小和加密步骤。块大小可以是 32 位、64 位或 128 位，密钥大小可以从 0 到 2040 位。此外，轮数可以从 0 到 255。它由一些模加和异或（XOR）操作组成。它容易受到差分攻击的影响，使用大量的已选择的明文，其中输入差异也会影响输出[23]。

##### SEAL 算法

SEAL 是一种长度扩展的“虚假随机”，用一个隐藏的 160 位密钥将 32 位字符串 N 转换为 L 位字符串 SEAL。输出长度 *L* 旨在多样化，但通常限制在 64 千字节。密钥的用途是确定三个秘密图表：R、S 和 T；这些图表分别具有 256、256 和 512 个 32 位值，这些值是从安全哈希算法（SHA）中产生的。SEAL 是双淋浴源的成果。第一个生成器实现了一个系统，依赖于推断的图表 R 和 T。它映射了 32 位字符串 n 和 6 位计数器[24]。

## 2.3 非对称加密

许多应用程序使用非对称加密来保护两方之间的通信。非对称加密的主要问题之一是需要大量的计算和存储。

公钥密码学的概念起源于试图攻击与对称加密相关的两个最困难的问题。第一个问题是密钥分配，其中对称加密要求两个通信方已经共享一个密钥，该密钥已以某种方式分发给它们，或者使用 *密钥分配中心*。非对称算法依赖于一个密钥进行加密，而使用另一个但相关的密钥进行解密[25]。有许多方法用于密钥建立，包括证书和公钥基础设施（*PKI*）。

*公钥* 是可以自由分发的。它在数学上与私钥相关，但你不能（轻易地）从 *公钥* 反推 *私钥*。使用 *公钥* 加密数据。

只有拥有 *私钥* 的人才能解密。

用于加密（K[E]）和解密（K[D]）的密钥是不同的。但是，K[E] 和 K[D] 构成了一个唯一的密钥对。其中一个密钥是公开的，另一个是私有的。加密/解密过程可以通过方程(2.2)建模，并可在图 2.11 中看到。![$$ P={D}_{K_D}\left({E}_{K_E}(P)\right) $$](img/501530_1_En_2_Chapter_TeX_Equ2.png)(2.2)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png](img/501530_1_En_2_Fig11_HTML.png)

图 2.11

非对称密钥加密

公钥系统可用于加密和认证。一个密钥用于加密文档；另一个密钥用于解密。对称和非对称加密的比较如表 2.2 所示。表 2.2

对称和非对称加密的比较

| 对称加密 | 非对称加密 |
| --- | --- |
| 1\. 使用相同的算法和相同的密钥进行加密和解密 2\. 发件人和收件人必须共享算法和密钥 3\. 密钥必须保密 4\. 如果没有其他信息可用，解密消息必须是不可能的或至少是不切实际的 5\. 算法的知识加上密文样本必须不足以确定密钥 | 1\. 一种算法用于加密和解密，使用一对密钥，一个用于加密，一个用于解密 2\. 发件人和收件人必须分别拥有匹配的密钥对中的一个（不是相同的密钥）3\. 两个密钥中的一个必须保密 4\. 如果没有其他信息可用，解密消息必须是不可能的或至少是不切实际的 5\. 算法的知识加上一个密钥加上密文样本必须不足以确定另一个密钥 |

非对称加密的安全性依赖于计算问题，例如大素数的因数分解难题和离散对数问题。这种算法被称为单向函数，因为在一个方向上计算很容易，但反转很困难。公钥加密效果非常好，而且非常安全，但它基于复杂的数学。因此，您的计算机必须非常努力地使用该系统对数据进行加密和解密。在需要定期处理大量加密数据的应用中，由于计算开销，公钥系统可能非常慢。

### 2.3.1 RSA：分解计算问题

Rivest–Shamir–Adleman（RSA）方案已于 1978 年发布，自那时起，它是最广泛接受和实施的通用公钥加密方法[26]。加密和解密的形式如下，对于某个明文块*M*和密文块*C*：![$$ C={M}^e\operatorname{mod}n $$](img/501530_1_En_2_Chapter_TeX_Equ3.png)(2.3)![$$ M={C}^d\operatorname{mod}n={\left({M}^e\right)}^d\operatorname{mod}n={M}^{ed}\operatorname{mod}n $$](img/501530_1_En_2_Chapter_TeX_Equ4.png)(2.4)

发送方和接收方都必须知道*n*的值。明文被分块加密，每个块的二进制值都小于某个数*n*。也就是说，块大小必须小于或等于 log2。RSA 方案是一种块密码，其中明文和密文是介于 0 和*n*-1 之间的整数，其中*n*是某个数。发送方知道*e*的值，只有接收方知道*d*的值。因此，这是一种公钥加密算法，其公钥为= {*e*, *n*}，私钥为= {*d*, *n*}。

要使此算法适用于公钥加密，必须满足以下要求：

1.  1.

    可以找到*e*、*d*和*n*的值，使得*M*^(*ed*) mod *n* = *M*对所有*M < n*成立。

    通过选择*n = pq*，其中*p*和*q*是质数，完成这一过程。选择*e*，其中*1 < e < (p-1)(q-1)*且*gcd((p-1)(q-1), e) = 1*，这意味着*e*是*(p-1)(q-1)*的质数。选择*d*，其中*d = e*^(*−1*)*mod((p-1)(q-1))*或*de = 1 mod((p-1)(q-1))*。

1.  2.

    计算模*M*^(*e*) mod *n*和所有*M < n*值的*C*^(*d*)相对容易。

1.  3.

    在给定*e*和*n*的情况下确定*d*是不可行的。

以下是一个示例:

+   假设明文= 88。

+   *密钥生成*: *n* = 17 × 11 = 187。*e* = 7，其中*gcd(160, 7) = 1*。*D* = 23，其中*d*^(*7*)* = 1 mod 160*。

+   *加密过程*: *C* = 88⁷ mod 187 = 11。

+   *解密过程*: *M* = 11²³ mod 187 = 88。

### 2.3.2 ECC：离散对数问题（DLP）

椭圆曲线密码学（ECC）是一种基于有限域上椭圆曲线的代数结构的公钥密码技术。ECC 是一种用于低计算设备（如无线传感器网络（WSN）和物联网（IoT）设备）的非对称加密技术，因其降低了功耗并提高了设备性能而被广泛使用，这归功于其生成具有强加密机制的小密钥的能力。例如，使用 1024 位密钥的 RSA 算法加密等同于使用 160 位密钥的 ECC 加密。ECC 确保安全性取决于计算具有随机点的点乘的能力，以及在给定原始曲线和乘积点的情况下无法找出乘数。ECC 使用一个(*x*; *y*)对，它适合于方程*y*² = *x*³ + *ax* + *b* mod *p*，以及一个无穷远点（theta），其中*a*; *b* ϵ *Zp*且*4a³ + 27b² ≠ 0 mod p*。ECC 需要一个循环群*G*和我们使用的原始元素，或成对元素，是*G*的顺序。

### 2.3.3 ElGamal 加密系统

埃尔加马尔密码系统是一种由塔赫尔·埃尔加马尔在 1984 年提出的非对称密钥加密。该算法的安全性基于离散对数问题。对于给定的数字，没有现有的算法可以在多项式时间内找到其离散对数，但可以有效地推导出幂的逆操作。埃尔加马尔密码系统的另一个关键方面是随机加密。该算法可以建立一个安全的用于密钥共享的通道，并通常用作密钥认证协议。为了安全起见，该算法的密钥大小应大于 1024 位。埃尔加马尔算法的主要缺点是它相对耗时。

### 2.3.4 迪菲-赫尔曼算法：密钥交换

迪菲-赫尔曼（DH）密钥交换算法是一种在公共通信渠道上安全交换加密密钥的方法。密钥实际上并不交换，而是共同派生的。传统上，两个方之间的安全加密通信需要它们首先通过某种安全的物理手段交换密钥，例如由可信的信使运送的纸质密钥列表。迪菲-赫尔曼密钥交换方法允许两个没有彼此先前知识的方共同在不安全的通道上建立共享的秘密密钥。然后可以使用这个密钥来使用对称密钥密码加密后续通信。步骤如下[29]：

1.  1.

    爱丽丝和鲍勃公开约定使用模数 *p* 和基数 *g*（它是模 p 的原根）。

1.  2.

    爱丽丝选择一个秘密整数 ***a*** 然后发送给鲍勃 *A* = *g*^(***a***) mod *p*。

1.  3.

    鲍勃选择一个秘密整数 ***b*** 然后发送给爱丽丝 *B* = *g*^(***b***) mod *p*。

1.  4.

    爱丽丝计算 ***s*** = *B*^(***a***) mod *p*。

1.  5.

    鲍勃计算 ***s*** = *A*^(***b***) mod *p*。

1.  6.

    爱丽丝和鲍勃现在共享一个秘密 (s)。

破解这些加密系统的难度基于确定整数 r，使得*g*^(*r*) = *x* mod *p*的难度。整数 r 称为*x*对于基数*g*的离散对数问题，我们可以将其写为 ![$$ r={\log}_g^x $$](img/501530_1_En_2_Chapter_TeX_IEq1.png) mod p。离散对数问题是一个非常难以计算的问题，如果参数足够大的话。

### 2.3.5 EGC

椭圆曲线密码学(ECC)是一种基于有限域上椭圆曲线的代数结构的公钥密码学方法。ECC 允许使用比非 EC 密码学(基于普通的 Galois 域)更小的密钥来提供相同的安全性。椭圆曲线适用于密钥协商、数字签名、伪随机生成器和其他任务。间接地，它们可以通过将密钥协商与对称加密方案结合来用于加密。EGC 协议为在物联网中传输数据期间保护数据的目的提供了高水平的数据安全性[30–32]。

## 2.4 混合加密

加强密码学安全性的已知方法之一是将两种现有的密码学结合起来。两种密码学的组合也称为混合算法，例如对称密钥和基于公钥的系统的组合。对称密钥密码学比公钥密码学更快更高效，但在通过不安全的通道交换密钥时缺乏安全性。混合加密系统将对称密钥密码学的速度与公钥密码学的安全性结合起来。混合加密系统由用于密钥封装的公钥密码系统和用于数据封装的对称密钥密码系统组成。大多数计算机用户使用混合加密系统以 HTTP 安全(*HTTPS*)的形式[33]。

## 2.5 加密分析/攻击

对加密算法的分析通常被称为密码分析，是测试密码系统可靠性的重要方面。根据黑盒假设，密码算法在数学密码分析方面是可证明安全的。密码分析方法总结如下，并且不同安全级别上的不同类型攻击显示在表 2.3 中。攻击可以是被动的或主动的。*被动攻击*不会改变或以任何其他方式影响信息，并且不会对通信通道造成任何问题。这里的主要目标是未经授权地获取敏感和机密信息和数据的访问权限。被动攻击通常被称为信息窃取。这种攻击真正危险的地方在于，大多数情况下，所有者并不知道未经授权的人已经了解了所有者的数据。例如，攻击者可能会截获和窃听通信通道，并获取机密信息的知识，而发送者和接收者都无法发现这一点。*主动攻击*能够处理信息并以多种不同的方式更改它。更具体地说，攻击者可以更改数据的特定字段，如发起者名称和时间戳，并通常以未经授权的方式修改信息。此外，未经授权删除数据、意外传输信息或数据的启动以及最后，拒绝合法用户访问数据，即所谓的拒绝服务（DoS）攻击也是主动攻击的示例[34，35]。表 2.3

不同安全级别上的不同类型攻击

| 安全抽象级别 | 安全目标 | 侧信道攻击 |
| --- | --- | --- |
| 协议 | 鉴别通信 | 中间人，流量分析 |
| 算法 | 加密/散列 | 已知明文，已知密文 |
| 架构 | 功能集成（软件） | 堆栈破坏 |
| 微体系结构 | 架构集成（硬件） | 总线探测 |
| 电路 | 实施 | 差分功率分析 |

### 2.5.1 穷举/暴力攻击

密钥空间应足够长。表 2.4 显示了密码分析时间与密钥大小之间的关系。加密算法的安全性应具有更大的密钥空间，以更有效地抵御各种攻击，如统计攻击、差分攻击、已知明文攻击和穷举攻击。密钥空间的大尺寸也使得暴力攻击变得不可行。此外，加密算法对于密钥的敏感性在加密和解密过程中是其健壮性的关键点。密钥的敏感性越高，信息就越安全，因为密钥的轻微变化将导致完全不同的密文图像。这意味着除非拥有正确的密钥，否则无法恢复原始图像 [36–38]。表 2.4

密码分析时间与密钥大小

| 密钥大小 | 可能的密钥数量 | 破解时间 |
| --- | --- | --- |
| (每微秒 1 次加密) | (每微秒 10⁶次加密) |
| --- | --- |
| 32 | 10⁹ | 36 分钟 | 2\. 毫秒 |
| 56 | 10¹⁶ | 1100 年 | 10 小时 |
| 128 | 10³⁸ | 5 × 10²⁴ 年 | 5 × 10¹⁸ 年 |
| 26 个字符 | 10²⁶ | 6 × 10¹² 年 | 6 × 10⁶ 年 |

### 2.5.2 统计/直方图攻击

直方图是获取图像像素值分布的常用方法。加密后，数据的直方图应该是均匀的。这导致统计攻击失效。在信息理论中，熵是混乱的最重要特征。我们可以说反映信息源不可预测的随机性的数值特性称为熵。灰度为 2⁸的随机图像的理想*熵*值为 8。这意味着熵值越接近，图像的无序性就越大，最终加密方案披露的信息就越少。

### 2.5.3 差分攻击

攻击者经常对原始数据进行轻微更改，并使用提出的算法加密原始数据之前和之后的数据，通过比较两个加密图像找出原始数据和加密数据之间的关系。

### 2.5.4 已知/选择明文/密文攻击

#### 2.5.4.1 已知密文攻击（KCA）

在这种攻击中，攻击者拥有多个密文，但没有相应的明文。当可以从一个或多个密文中提取相应的明文时，这种攻击变得有效。此外，有时也可以通过此攻击发现加密密钥。然而，在实践中，执行此攻击的对手也对明文有一定的了解。这些信息可能是明文所写的语言或其中字符的可预见的统计分布。

#### 2.5.4.2 选择明文攻击（CPA）

在这里，对手可以自由访问加密过程，并且可以从他选择的任何明文创建任何密文。因此，基本上，攻击者可以拥有任何理想的明文-密文对。这使得查找加密密钥的过程更容易，因为攻击者可以通过创建更多的消息和密文对来获得有关加密操作的更多知识。

#### 2.5.4.3 已知明文攻击（KPA）

这种攻击与之前的攻击非常相似。攻击者知道发件人发送的明文和相应的密文。对手的目标是利用他们拥有的密文-明文对来获取信息。这可能导致发现加密密钥或算法的其他信息。与所选明文攻击的不同之处在于，明文不是由攻击者选择的，而是由消息的发送者选择的。

#### 2.5.4.4 所选密文攻击（CCA）

在这种类型的攻击中，对手或密码分析师有能力分析任何所选密文以及相应的明文。目标是获取受攻击的密码系统的秘密密钥或尽可能多的信息。该攻击建立在攻击者可以让受害者解密任何加密消息并将其发送给他的假设之上。攻击拥有的解密密文越多，系统获得的信息就越多，因此破解的可能性就越大。

#### 2.5.4.5 侧信道攻击

系统通过泄露信息的渠道遭到攻击，例如*时间消耗、功耗或电磁辐射*。定时攻击是一种侧信道攻击。攻击者可以访问设备或通过执行例如差分功耗分析（DPA）攻击而对它们进行物理损坏。在差分功耗分析中，攻击者向 FPGA 发送大量明文（位），FPGA 将相应地解密它们，同时攻击者将测量功耗轨迹，尝试获取密码算法密钥（使用统计技术和 CMOS 功耗模型的知识）。对抗这种攻击的许多对策，包括更改密钥传输或加密的时间以迷惑对手，并过滤电源线调节以防止功率监视行为。

*深度学习*技术可以在侧信道分析的情境中使用。与其他机器学习技术类似，深度学习技术在训练阶段为目标敏感变量的每个可能值构建一个概要模型，在攻击阶段，这些模型被用来输出在攻击轨迹获取期间最有可能使用的密钥。在侧信道攻击情境中，对手更感兴趣的是从密钥假设中推导出的每个可能值的概率计算。因此，为了恢复正确的密钥，对手计算最大或对数最大似然方法，就像模板攻击[39–41]一样。

#### 2.5.4.6 中间人攻击

此攻击依赖于站在两个通信方之间，以获取发送方的消息，对其进行更改和添加，然后将其转发给接收方。这需要攻击者知道加密密钥，才能加密消息的附加部分。一次性密码键和改变块长度使攻击者无法成功扮演中间人角色。

## 2.6 不同加密算法的比较

流密码通常比分块密码更快，因为在第二类密码中，需要逐个处理每个块才能加密，而在流密码中每次只需要处理一个比特或字节。因此，分块密码需要更多的内存分配，因为它们必须处理更大的数据块，并且有时还必须从上一个块继续操作。相反，流密码一次最多处理一个字节，因此它们的内存需求相对较低，因此在嵌入式系统和物联网设备等受限设备中实施起来更便宜，并且在轻量级密码算法中更通用。然而，流密码更难以有效地开发和设计，并且根据使用情况容易受到攻击。流密码不提供完整性保护和身份验证，而一些分块密码根据它们使用的模式能够同时提供完整性和机密性。另外，由于分块密码一次加密整个块，大多数情况下都有反馈模式，它们容易在传输中添加噪音，这可能会改变数据，因此剩余的传输对算法来说不合适。流密码不会面临这样的问题，因为比特或字节是单独加密的，而且大多数情况下在连接问题出现时都有解决方案。不同加密算法的比较评估显示在表 2.5 和表 2.6 中。DES 算法具有较低的加密和解密速度。AES 算法具有最低的内存利用率。RSA 具有非常高的内存利用率[42, 43]。由于低功耗，DES 设计在硬件中的性能比在软件程序中更好。3DES 比 DES 需要更长的时间，消耗更多的功耗，并且吞吐量更少。3DES 算法是最适合数据保护的，因为它使用三个密钥来加密和解密数据[44]。表 2.5

不同加密算法的比较

| 算法 | 加密和解密速度 | 可扩展性 | 漏洞 | 安全性 |
| --- | --- | --- | --- | --- |
| RSA | 高 | 不可扩展 | 暴力破解攻击 | 高 |
| DES | 低 | 可扩展 | 暴力破解攻击 | 中等 |
| AES | 低 | 不可扩展 | 密码分析攻击 | 高 |
| 3DES | 低 | 不可扩展 | 中间人攻击 | 高 |
| BLOWFISH | 低 | 可扩展 | 暴力破解攻击 | 低 |
| ECC | 低 | 可扩展 | 暴力破解攻击 | 中等 |

表 2.6

AES、DES 和 RSA 的比较

| 因素 | AES | DES | RSA |
| --- | --- | --- | --- |
| 开发年份 | 2000 | 1977 | 1978 |
| 密钥长度（位） | 128,192,256 | 56 | 1024 |
| 密钥类型 | 对称 | 对称 | 非对称 |
| 块大小（位） | 128 | 64 | 512 |
| 执行时间 | 快 | 中等 | 慢 |
| 轮数 | 10,12,14 | 16 | 1 |

## 2.7 密码学应用

强加密算法的需求非常高，它们的设计是具有挑战性的，特别是考虑到计算机的处理能力日益增长，而恶意方往往倾向于不断寻找安全系统中的新漏洞和漏洞。如今，密码学在许多类型的应用中被过度使用。

### 2.7.1 安全邮件

爱丽丝想将机密邮件“m”发送给鲍勃（图 2.12）。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig12_HTML.png](img/501530_1_En_2_Fig12_HTML.png)

图 2.12

发送安全邮件

爱丽丝：

+   生成随机对称私钥*K*[*S*]

+   使用*K*[*S*]解密*K**S*以恢复*m*

+   使用鲍勃的公钥加密*K*[*S*]

+   向鲍勃发送*K**S*和*K**B*

鲍勃：

+   使用他的私钥解密和恢复*K*[*S*]

+   使用*K*[*S*]解密*K**S*以恢复*m*

### 2.7.2 安全聊天

聊天客户端将使用加密算法与其他客户端进行端对端加密通信。有许多流行的会话建立协议用于实现现实世界的聊天系统，如 Signal 和 WhatsApp。

### 2.7.3 安全无线通信系统

图 2.13 显示了一个高级无线通信系统，加密在其中起着关键作用。*蓝牙*加密系统使用流密码 E0 对数据包的有效负载进行加密，每个有效负载都会重新同步。E0 流密码由有效负载密钥生成器、密钥流生成器和加密/解密部分组成。输入位由有效负载密钥生成器组合，并被移位到密钥流生成器的四个线性反馈移位寄存器（LSFR）。然后生成用于加密的密钥流位。然后对密钥流位和数据流位执行异或运算以生成密文。类似地，在解密过程中对密文执行异或运算以获取明文。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig13_HTML.png](img/501530_1_En_2_Fig13_HTML.png)

图 2.13

高级无线通信系统

*WLAN* 加密方法包括：

+   有线等效隐私（*WEP*）：有线等效隐私（WEP）是用于 IEEE 802.11 无线网络的安全算法。标准的 64 位 WEP 使用 40 位密钥（也称为 WEP-40），与 24 位初始化向量（IV）连接以形成 RC4 密钥。在起草原始 WEP 标准的时候，美国政府对密码技术的出口限制限制了密钥大小。一旦限制解除，接入点制造商就实施了扩展的 128 位 WEP 协议，使用 104 位密钥大小（WEP-104）。

+   Wi-Fi Protected Access（*WPA*）：Wi-Fi Protected Access（WPA）是 Wi-Fi 联盟对 WEP 标准日益明显的漏洞做出的直接回应和替代。WPA 于 2003 年正式采纳，比 WEP 正式退役提前一年。最常见的 WPA 配置是 WPA-PSK（预共享密钥）。WPA 使用的密钥为 256 位，比 WEP 系统中使用的 64 位和 128 位密钥显著增加。

+   Wi-Fi Protected Access 2（*WPA2*）：截至 2006 年，WPA 已被 WPA2 正式取代。WPA 和 WPA2 之间最重要的变化之一是强制使用 AES 算法，以及引入 CCMP（计数器模式密码块链接消息认证码协议）作为 TKIP 的替代。然而，TKIP 仍然在 WPA2 中保留为后备系统，并用于与 WPA 的互操作性。

*5G* 使用 256 位加密，相较于 4G 使用的 128 位标准有了实质性的提升。在 5G 中，用户的身份和位置都被加密，从他们接入网络的那一刻起就无法被识别或定位[46]。在旧的 2G 蜂窝系统中，用于保护空中接口并执行用户身份验证功能的加密算法并未公开披露。与我们讨论相关的 GSM 算法系列有 A3、A5 和 A8。A3 提供用户身份验证，A5 提供空中接口的保密性，而 A8 与 A3 有关，它提供了用户身份验证功能，但是在 SIM 卡中实现。UMTS 引入了在商用蜂窝系统中使用的第一个公开披露的加密算法。UEA（UMTS 加密算法）和 UIA（UMTS 完整性算法）是 UMTS 中使用的广义类别。UEA1 是一个 128 位分组密码，称为 KASUMI，它与日本密码 MISTY 相关。UIA1 是一种消息认证码（MAC），也基于 KASUMI。UEA2 是一种与 SNOW 3G 相关的流密码，而 UIA2 则基于相同算法计算 MAC。LTE 在部署 2G 和 3G 加密算法的经验教训基础上进行了改进。LTE 引入了一组新的加密算法和与 GSM 和 UMTS 不同得多的密钥结构。对于机密性和完整性，都有三组加密算法，分别称为 EPS 加密算法（EEA）和 EPS 完整性算法（EIA）。EEA1 和 EIA1 基于 SNOW 3G，与 UMTS 中使用的算法非常相似。EEA2 和 EIA2 基于高级加密标准（AES），其中 EEA2 由 AES 在 CTR 模式下定义（例如，流密码），而 EIA2 由 AES-CMAC（基于密码的 MAC）定义。EEA3 和 EIA3 都基于中国密码 ZUC。尽管这些新算法已经在 LTE 中引入，但网络实现通常包括旧算法，以确保向后兼容性，适配传统设备和蜂窝部署[47]。

### 2.7.4 安全的移动/智能手机

智能手机用户面临不同的威胁。这些威胁可能会干扰操作并将用户数据从智能手机转移。可以将手机中的攻击类型分为多种方式。其中一些解释如下：

+   *基于 Wi-Fi 的攻击*

    攻击者可以通过窃听拦截 Wi-Fi 通信。 WLAN 中的安全性更加脆弱。攻击者很容易就能破解密码，并进入受害者的本地网络。在攻击者成功破解身份密码的情况下，攻击手机和整个网络都成为可能。

+   *基于 Web 浏览器的攻击*

    在基于 Web 浏览器的攻击中，攻击者利用诸如基于栈的溢出和库中的其他漏洞之类的优势。这在所有类型的操作系统中都可能发生，无论是 Android 还是 iOS。智能手机也容易受到钓鱼和其他恶意网站的攻击，而智能手机最大的问题是它们还没有强大的防病毒保护。

+   *基于操作系统的攻击*

    可以应用任意数量的安全机制，但如果操作系统中存在漏洞，它可能会影响到某一天。由于智能手机处于早期阶段，开发人员对可能发生的攻击类型并不十分了解，因此操作系统存在多个漏洞。很可能规避操作系统的安全性并绕过字节码验证器，并获取核心操作系统的访问权限。类似地，在 Windows 移动操作系统中，可以轻松地编辑通用配置文件为可修改文件。恶意攻击者还可以在应用程序安装时进行目录修改，因为此时具有根权限。

## 2.8 结论

本章讨论了私钥和公钥密码学的基础。此外，它解释了这些密码系统的主要构建块的细节。此外，本章探讨了不同的密码分析技术。它涉及流密码、数据加密标准（DES）和 3DES、高级加密标准（AES）、块密码、RSA 密码系统以及基于离散对数问题、椭圆曲线密码学（ECC）、密钥交换算法等众多其他算法的公钥密码系统。此外，本章还提供了不同加密算法在加密速度、解码、复杂性、密钥长度、结构和灵活性方面的比较。
