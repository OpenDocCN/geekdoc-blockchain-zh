- en: '[CHAPTER 9](toc.xhtml#c09)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第9章](toc.xhtml#c09)'
- en: '[Wallets and Addresses](toc.xhtml#c09)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[钱包和地址](toc.xhtml#c09)'
- en: In the previous chapter, we looked at Bitcoin as a network protocol, its strength
    that makes it a great technological innovation, and its limitations and conditions
    that pose risks to its long-term existence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了比特币作为一个网络协议，它的优势使它成为一项伟大的技术革新，以及它的局限性和对其长期存在构成风险的条件。
- en: In this chapter, you will learn to access your bitcoins, send them to single
    or multiple addresses, and execute a smart agreement between parties.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何访问您的比特币，将它们发送到单个或多个地址，并执行各方之间的智能合约。
- en: 'To access your bitcoins, you need a software program that can generate addresses
    for receiving bitcoins and the software can sign a transaction in order to transfer
    it to the receiving parties. This software program is called a ***wallet***. This
    chapter focuses on private keys, public keys, addresses, and wallets. We will
    cover transactions and signing of transactions in detail in the next chapter.
    The signing of a transaction is also an essential part of wallet functionality.
    So, a wallet has three essential functionalities:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问你的比特币，你需要一个软件程序，它可以为接收比特币生成地址，并且该软件可以签署交易，以便将其转让给接收方。这个软件程序称为**钱包**。本章重点介绍私钥、公钥、地址和钱包。我们将在下一章详细介绍交易和交易签署。交易签署也是钱包功能的一个重要组成部分。因此，一个钱包有三个基本功能：
- en: It provides information about bitcoins you are holding.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了你持有的比特币信息。
- en: It provides addresses to receive bitcoins.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供地址以接收比特币。
- en: It helps sign a transaction so that it can be published on the network.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助签署交易，以便可以在网络上发布。
- en: 'Wallets can be classified in several ways. The following are the types of wallets
    based on the medium of usage:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包可以从多种方式进行分类。以下根据使用媒介的类型，是钱包的分类：
- en: '**Mobile wallets:** These are installed on mobile phones. Some of the famous
    ones are Electrum, Mycelium, Samourai, etc.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动钱包：**这些安装在手机上。一些著名的有Electrum、Mycelium、Samourai等。'
- en: '**Desktop wallets:** These are installed on the desktop. Some of the famous
    ones are Bitcoin Core, Armory, Electrum, etc.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桌面钱包：**这些安装在桌面上。一些著名的有比特币核心、Armory、Electrum等。'
- en: '**Hardware wallets:** These are separate hardware devices that are security-focused
    and considered to provide better security. Two companies mostly dominate this
    market: Ledger Nano and Trezor.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件钱包：**这些都是专注于安全性的独立硬件设备，被认为能提供更好的安全性。两家公司主要主导这个市场：Ledger Nano和Trezor。'
- en: Apart from the preceding wallet types, wallet services are also provided by
    most exchanges.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的钱包类型，大多数交易所也提供钱包服务。
- en: 'Wallets can also be classified based on keys as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包还可以根据密钥的类型进行如下分类：
- en: '**Deterministic wallets:** These wallets allow a user to generate keys deterministically
    using a seed. These wallets don’t need to store keys and so are safe from hacking
    and are also safe from the risk of losing the keys.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性钱包：**这些钱包允许用户使用种子确定性地生成密钥。这些钱包不需要存储密钥，因此可以从黑客攻击中安全，也可以从丢失密钥的风险中安全。'
- en: '**Non-Deterministic wallets:** These wallets store collections of keys. These
    are also called **Just a Bunch of Keys (JBOK)**.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非确定性钱包：**这些钱包存储密钥集合。这些也被称为**只是一堆密钥（JBOK）**。'
- en: 'Wallets can also be classified as hot and cold:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包还可以根据热钱包和冷钱包进行分类：
- en: '**Cold wallets** store private keys offline, and the signing of transactions
    happens offline, which makes them very secure. Hardware wallets are examples of
    cold wallets.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷钱包**将私钥存储在离线上，交易签署也在离线进行，这使得它们非常安全。硬件钱包是冷钱包的例子。'
- en: '**Hot wallets** encrypt private keys but keep them online. These wallets also
    sign transactions online. Most of the mobile and desktop wallets are online wallets.
    Bitcoin Core provides an online wallet.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热钱包**加密私钥但将其保持在线上。这些钱包也在线签署交易。大多数移动和桌面钱包都是在线钱包。比特币核心提供了一个在线钱包。'
- en: In this chapter, we will build a deterministic wallet. In the next chapter,
    you will learn how to use the wallet for signing a transaction offline.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个确定性钱包。在下一章中，您将学习如何离线使用该钱包签署交易。
- en: '***** Never use private keys or mnemonic code used anywhere in this book. Your
    bitcoins will get stolen *****'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***** 不要在任何地方使用本书中使用的私钥或助记词。你的比特币会被盗 *****'
- en: '[Structure](toc.xhtml#s192a)'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**结构](toc.xhtml#s192a)**'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mnemonic code
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 助记词代码
- en: Format and generation of private key, public key, and address
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥、公钥和地址的格式和生成
- en: Private key
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥
- en: Public key
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥
- en: Address
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Hierarchical Deterministic (HD) wallet
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层确定性（HD）钱包
- en: Master key generation
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握密钥生成
- en: Key derivation
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥导出
- en: Parent private key -> Child private key
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父私钥 -> 子私钥
- en: Parent public key -> Child public key
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父公钥 -> 子公钥
- en: Child private key -> Parent private key (Wallet private key leak)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子私钥 -> 父私钥（钱包私钥泄露）
- en: Deriving hardened child keys
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出硬化子密钥
- en: Extended keys
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展密钥
- en: Master extended public and private keys
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主扩展公钥和私钥
- en: Extended public and private keys
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展公钥和私钥
- en: Key derivation path
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥导出路径
- en: '[Objectives](toc.xhtml#s193a)'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[目标](toc.xhtml#s193a)'
- en: The objective of this chapter is to help you understand wallet, public keys,
    private keys, and Bitcoin addresses both in terms of functionality and implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您理解钱包、公钥、私钥以及比特币地址在功能和实现方面的知识。
- en: We will discuss the functions of wallets. Additionally, you will understand
    the different ways to classify them and learn to create your own hierarchical
    deterministic wallet and generate their seed. You will also learn about security
    related to wallets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论钱包的功能。此外，您将了解对它们进行分类的不同方法，并学会创建自己的分层确定性钱包和生成它们的种子。您还将学习与钱包相关的安全知识。
- en: This chapter also covers the format of private keys, public keys, and addresses,
    and you will also learn to generate them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了私钥、公钥和地址的格式，并且您还将学会生成它们。
- en: '[Mnemonic code](toc.xhtml#s194a)'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[助记词代码](toc.xhtml#s194a)'
- en: To create a deterministic wallet, you first need to learn to generate a random
    seed. This seed will help you generate private key and public key pairs. The random
    number you choose determines how secure the private key is against brute force
    or knowledge-based attacks. A good random number is truly random, which means
    it does not follow a pattern that an attacker can determine. Additionally, it
    is preferable that generation is well distributed, which means if we keep on generating
    it over a finite field, then after a significantly long time, the finite field
    is very well distributed, does not have large patches of density, and is not quite
    uniform. So, a random number needs to protect against both brute force attacks
    and intelligent attacks involving inferring patterns. This requires choosing the
    right source of randomness, also called the *source of entropy*. This is mostly
    collected from hardware sources such as fan noise or mouse movement. We can also
    use background noise as a source of entropy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个确定性的钱包，您首先需要学会生成一个随机种子。这个种子将帮助您生成私钥和公钥对。您选择的自然随机数决定了私钥相对于暴力破解或基于知识攻击的安全性。一个好的随机数确实是随机的，这意味着它不遵循攻击者可以确定的模式。此外，生成最好是良好的分布，这意味着如果我们继续在一个有限域上生成它，那么在很长一段时间后，这个有限域非常良好地分布，没有大量的密度区域，并且不是非常均匀。因此，随机数需要同时保护免受暴力攻击和推断模式的智能攻击。这需要选择正确的随机性来源，也称为*熵源*。这主要来自硬件来源，如风扇噪音或鼠标移动。我们也可以将背景噪音作为熵源。
- en: We will implement a program to generate the random seed using BIP 39.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个程序，使用BIP 39生成随机种子。
- en: 'Link: **[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 链接：**[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)**
- en: The document describes the method of generating seed, which consists of 12/18/24
    common English words. The set of words is not just a purely random sequence; it
    also contains checksum, and so, it cannot be randomly generated without following
    the method described in BIP.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文档描述了生成种子的方法，它由12/18/24个常见的英文单词组成。这个单词集合不仅仅是随机序列，还包括校验和，因此，不遵循BIP中描述的方法是无法随机生成的。
- en: There are 2048 mnemonic words with which seed is generated, which translates
    to 11 bits. The whole list of mnemonic words can be found at **[https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 共有2048个助记词用于生成种子，相当于11位。助记词的完整列表可以在**[https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)**找到。
- en: If we are preparing 12-word mnemonic code, we require 11*12 bits, which are
    132 bits.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们准备12个单词的助记词，我们需要11*12位，共132位。
- en: 132 bits consists of a 128-bit random number and 4-bit as its checksum.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 132位由一个128位的随机数和4位作为其校验和组成。
- en: 'We will refer to the bits in random numbers as entropy bits. Here’s an illustration
    of the process of getting a 12-word mnemonic seed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将随机数中的位称为熵位。以下是获取 12 个单词助记种子的过程示意图：
- en: '![](images/Figure-9.1.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.1.jpg)'
- en: '**Figure 9.1:** Illustration of mnemonic code generation from entropy'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.1：** 从熵生成助记码的示意图'
- en: 'The following formula is used to calculate the required bits:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下公式计算所需位数：
- en: '*Entropy Bit Count = Mnemonic Word count * 32 / 3*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵位数量 = 助记词数量 * 32 / 3*'
- en: 'Here’s the formula for **checksum_bit_count**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**checksum_bit_count**的公式：
- en: '*Checksum Bit Count = Mnemonic Word count/ 3*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*校验位数量 = 助记词数量 / 3*'
- en: 'This is the code to get the **checksum_bit_count** and **entropy_it_count**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取**checksum_bit_count**和**entropy_it_count**的代码：
- en: '`def getChecksumBitCount(mnemonic_length: int):`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getChecksumBitCount(mnemonic_length: int):`'
- en: '`if (mnemonic_length % 3) != 0:`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (mnemonic_length % 3) != 0:`'
- en: '`raise ValueError(‘Invalid Mnemonic code length’)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise ValueError(''无效的助记码长度'')`'
- en: '`checksum_bit_count = mnemonic_length // 3`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum_bit_count = mnemonic_length // 3`'
- en: '`return checksum_bit_count`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`return checksum_bit_count`'
- en: '`def getEntropyBitCount(mnemonic_length: int):`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getEntropyBitCount(mnemonic_length: int):`'
- en: '`if (mnemonic_length % 3) != 0:`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (mnemonic_length % 3) != 0:`'
- en: '`raise ValueError(‘Invalid Mnemonic code length’)`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise ValueError(''无效的助记码长度'')`'
- en: '`entropy_bit_count = (mnemonic_length * 32) // 3`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_bit_count = (mnemonic_length * 32) // 3`'
- en: '`return entropy_bit_count`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`return entropy_bit_count`'
- en: '**Program 9.1:** Program to get checksum bit count and entropy bit count from
    mnemonic seed length'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.1：** 从助记种子长度获取校验位数量和熵位数量的程序'
- en: 'The following is the code to generate entropy bits:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成熵位的代码：
- en: '`def getRandomNumberBits(bit_count: int):`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getRandomNumberBits(bit_count: int):`'
- en: '`r = random.SystemRandom().randrange(0, 1 << 32)`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`r = random.SystemRandom().randrange(0, 1 << 32)`'
- en: '`r_b = r.to_bytes((r.bit_length() + 7) // 8, ‘big’)`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`r_b = r.to_bytes((r.bit_length() + 7) // 8, ''big'')`'
- en: '`h = hashlib.sha256()`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hashlib.sha256()`'
- en: '`h.update(r_b)`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`h.update(r_b)`'
- en: '`h_b = h.digest()`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`h_b = h.digest()`'
- en: '`byte_count = bit_count // 8`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte_count = bit_count // 8`'
- en: '`rand_num_b = h_b[0:byte_count]`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand_num_b = h_b[0:byte_count]`'
- en: '`return rand_num_b`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`return rand_num_b`'
- en: '**Program 9.2:** Program to generate random numbers'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.2：** 生成随机数的程序'
- en: 'After this, we append checksum bits to the random number bits. Here’s the code
    to generate the bits:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将校验位附加到随机数位。以下是生成位的代码：
- en: '`def getMSBChecksumBits(checksum: int, checksum_bit_count: int):`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMSBChecksumBits(checksum: int, checksum_bit_count: int):`'
- en: '`msb_checksum = checksum >> (256 - checksum_bit_count)`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`msb_checksum = checksum >> (256 - checksum_bit_count)`'
- en: '`return msb_checksum`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`return msb_checksum`'
- en: '`def getEntropyWithChecksum(random_number: int,`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getEntropyWithChecksum(random_number: int,`'
- en: '`msb_checksum: int,`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`msb_checksum: int,`'
- en: '`checksum_bit_count: int):`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum_bit_count: int):`'
- en: '`shifted_random_number = random_number << checksum_bit_count`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`shifted_random_number = random_number << checksum_bit_count`'
- en: '`entropy_check_i = shifted_random_number | msb_checksum`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_i = shifted_random_number | msb_checksum`'
- en: '`return entropy_check_i`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`return entropy_check_i`'
- en: '`def convertIntToBytes(num: int, bit_count: int):`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`def convertIntToBytes(num: int, bit_count: int):`'
- en: '`size_bytes = math.ceil(bit_count / 8)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_bytes = math.ceil(bit_count / 8)`'
- en: '`num_s = (‘%x’ % num).zfill(size_bytes * 2)`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`num_s = (‘%x’ % num).zfill(size_bytes * 2)`'
- en: '`num_b = bytes.fromhex(num_s)`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`num_b = bytes.fromhex(num_s)`'
- en: '`return num_b`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`return num_b`'
- en: '`def getChecksum(b: bytes):`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getChecksum(b: bytes):`'
- en: '`return int.from_bytes(hashlib.sha256(b).digest(), byteorder=’big’)`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`return int.from_bytes(hashlib.sha256(b).digest(), byteorder=’big’)`'
- en: '`def getEntropyCheckBits(mnemonic_length: int):`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getEntropyCheckBits(mnemonic_length: int):`'
- en: '`entropy_bit_count = getEntropyBitCount(mnemonic_length)`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_bit_count = getEntropyBitCount(mnemonic_length)`'
- en: '`random_number_b = getRandomNumberBits(entropy_bit_count)`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_number_b = getRandomNumberBits(entropy_bit_count)`'
- en: '`checksum_bit_count = getChecksumBitCount(mnemonic_length)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum_bit_count = getChecksumBitCount(mnemonic_length)`'
- en: '`checksum = getChecksum(random_number_b)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum = getChecksum(random_number_b)`'
- en: '`msb_checksum = getMSBChecksumBits(checksum, checksum_bit_count)`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`msb_checksum = getMSBChecksumBits(checksum, checksum_bit_count)`'
- en: '`random_number = int.from_bytes(random_number_b, byteorder=’big’)`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_number = int.from_bytes(random_number_b, byteorder=’big’)`'
- en: '`entropy_check_i = getEntropyWithChecksum(random_number, msb_checksum, checksum_bit_count)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_i = getEntropyWithChecksum(random_number, msb_checksum, checksum_bit_count)`'
- en: '`bit_count = entropy_bit_count + checksum_bit_count`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`bit_count = entropy_bit_count + checksum_bit_count`'
- en: '`entropy_check_b = convertIntToBytes(entropy_check_i, bit_count)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_b = convertIntToBytes(entropy_check_i, bit_count)`'
- en: '`return entropy_check_b`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`return entropy_check_b`'
- en: '**Program 9.3:** Program to get entropy bits appended with checksum'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.3：** 附加了校验和的熵位获取程序'
- en: 'After this, we need to use these bits to select words from the list of 2048
    mnemonic word lists. This works by breaking the **entropycheck bits** into the
    11-bit list. Given here is the code that does this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要使用这些位来从2048个助记词列表中选择单词。这通过将**entropycheck位**分成11位列表来实现。以下是执行此操作的代码：
- en: '`def getMnemonicWordList():`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMnemonicWordList():`'
- en: '`word_list = []`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`word_list = []`'
- en: '`with open(‘mnemonic_word_list_english.txt’, ‘rt’) as word_file:`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`with open(‘mnemonic_word_list_english.txt’, ‘rt’) as word_file:`'
- en: '`word_list = word_file.read().splitlines()`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`word_list = word_file.read().splitlines()`'
- en: '`return word_list`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`return word_list`'
- en: '`def entropyCheckBits2List(entropy_check_b: bytes, size: int):`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`def entropyCheckBits2List(entropy_check_b: bytes, size: int):`'
- en: '`selector_int = int.from_bytes(entropy_check_b, byteorder=’big’)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector_int = int.from_bytes(entropy_check_b, byteorder=’big’)`'
- en: '`selector_list = []`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector_list = []`'
- en: '`while size >= 11:`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`while size >= 11:`'
- en: '`selector_list.append(selector_int & 0x07FF)`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector_list.append(selector_int & 0x07FF)`'
- en: '`selector_int = selector_int >> 11`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector_int = selector_int >> 11`'
- en: '`size -= 11`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`size -= 11`'
- en: '`return selector_list[::-1]`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`return selector_list[::-1]`'
- en: '`def getMnemonicWordCodeString(mnemonic_length: int):`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMnemonicWordCodeString(mnemonic_length: int):`'
- en: '`entropy_bit_count = getEntropyBitCount(mnemonic_length)`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_bit_count = getEntropyBitCount(mnemonic_length)`'
- en: '`checksum_bit_count = getChecksumBitCount(mnemonic_length)`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum_bit_count = getChecksumBitCount(mnemonic_length)`'
- en: '`entropy_check_bit_count = entropy_bit_count + checksum_bit_count`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_bit_count = entropy_bit_count + checksum_bit_count`'
- en: '`entropy_check_b = getEntropyCheckBits(mnemonic_length)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_b = getEntropyCheckBits(mnemonic_length)`'
- en: '`selector_list = entropyCheckBits2List(entropy_check_b,`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector_list = entropyCheckBits2List(entropy_check_b,`'
- en: '`entropy_check_bit_count)`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`entropy_check_bit_count)`'
- en: '`mnemonic_word_list = getMnemonicWordList()`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mnemonic_word_list = getMnemonicWordList()`'
- en: '`word_key_list = []`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`word_key_list = []`'
- en: '`for selector in selector_list:`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`for selector in selector_list:`'
- en: '`word = mnemonic_word_list[selector]`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`word = mnemonic_word_list[selector]`'
- en: '`word_key_list.append(word)`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`word_key_list.append(word)`'
- en: '`return word_key_list`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`return word_key_list`'
- en: '**Program 9.4:** Program to generate mnemonic word code in list'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序9.4：生成助记词单词代码列表的程序**'
- en: 'In this subtopic, you learned to generate the mnemonic seed. You can use it
    to generate a mnemonic seed of 12, 18, or 24 words. There is a tradeoff here:
    a 24-word seed gives more security, but it is more difficult to remember than
    a 12- or an 18-word code. In the next section, we will discuss private key, public
    key, and the address format used by Bitcoin.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子主题中，您学习了生成助记词种子。您可以使用它生成12、18或24个单词的助记词种子。这里有一个权衡：24个单词的种子提供更多的安全性，但比12个或18个单词的代码更难记住。在下一节中，我们将讨论私钥、公钥以及比特币使用的地址格式。
- en: '[Format and generation of private key, public key, and address](toc.xhtml#s195a)'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**私钥、公钥和地址的格式和生成**'
- en: In this subtopic, you will understand the format of private keys and address
    and learn to generate them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子主题中，您将了解私钥和地址的格式，并学习如何生成它们。
- en: '[Private key](toc.xhtml#s196a)'
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**[私钥](toc.xhtml#s196a)**'
- en: Private keys can be almost any 256-bit value. They can be between *0x1* to *0xFFFF
    FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥可以是几乎任何256位值。它们可以在*0x1*到*0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6
    AF48 A03B BFD2 5E8C D036 4140*之间。
- en: Private keys are represented in **Wallet Import Format (WIF)** format. This
    is the base58 format with a prefix and checksum.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥以**钱包导入格式（WIF）**表示。这是带有前缀和校验和的base58格式。
- en: 'Base58 scheme is defined in the following document:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Base58方案定义在以下文档中：
- en: '**[https://tools.ietf.org/id/draft-msporny-base58-01.html](https://tools.ietf.org/id/draft-msporny-base58-01.html)**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**[https://tools.ietf.org/id/draft-msporny-base58-01.html](https://tools.ietf.org/id/draft-msporny-base58-01.html)**'
- en: Public keys can be compressed or uncompressed. Both compressed and uncompressed
    public keys lead to different addresses, so the private key must carry the information
    regarding whether the public key it will generate will be compressed or uncompressed.
    To generate WIF format for the private key, we need to have information about
    the coin, network, and compression in the WIF format so that the resulting address
    belongs to a specific network and is deterministic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥可以压缩或展开。压缩和展开的公钥会导致不同的地址，因此私钥必须包含有关它将生成的公钥是压缩还是展开的信息。为了生成私钥的WIF格式，我们需要在WIF格式中了解关于硬币、网络和压缩的信息，以便生成的地址属于特定的网络且是确定的。
- en: 'The following is the prefix information:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要提供的 prefix 信息：
- en: '![](images/296.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](images/296.jpg)'
- en: '**Table 9.1:** Private key prefixes'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9.1：私钥前缀**'
- en: As seen in the preceding table, regtest uses the same private key prefixes as
    testnet.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，regtest使用与testnet相同的私钥前缀。
- en: To generate WIF format for the compressed public key, we add b’\01’ as a suffix
    to the generated private key.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为压缩的公钥生成 WIF 格式，我们将 b’\01’ 添加为生成的私钥的后缀。
- en: 'Base58 encoding string consists of the following characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Base58 编码字符串由以下字符组成：
- en: '*123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz*'
- en: There are 58 characters as the name suggests. To get the encoded string, we
    iteratively divide the number by 58 and subsequent quotients, convert remainders
    to base58 characters in each step, and concatenate encoded characters to get the
    final encoded string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，有 58 个字符。为了获取编码字符串，我们迭代地将数字除以 58，并在每一步将余数转换为 base58 字符，然后连接编码字符以获得最终编码字符串。
- en: 'The following illustration shows the logic to get WIF encoded private key for
    testnet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了为测试网获取 WIF 编码的私钥的逻辑：
- en: '![](images/Figure-9.2.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.2.jpg)'
- en: '**Figure 9.2:** Illustration of method of WIF encoding'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.2：** WIF 编码方法的图示'
- en: 'The following program encodes a number in base58 string:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将一个数字编码为 base58 字符串：
- en: '`g_alphabet=’123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz’`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_alphabet=’123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz’`'
- en: '`g_base_count = len(g_alphabet)`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_base_count = len(g_alphabet)`'
- en: '`def hash256(bstr: bytes):`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`def hash256(bstr: bytes):`'
- en: '`return hashlib.sha256(hashlib.sha256(bstr).digest()).digest()`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`return hashlib.sha256(hashlib.sha256(bstr).digest()).digest()`'
- en: '`def base58_encode(num: int):`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`def base58_encode(num: int):`'
- en: '`encode = ‘’`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode = ‘’`'
- en: '`if (num < 0):`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (num < 0):`'
- en: '`return ‘’`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ‘’`'
- en: '`while (num >= g_base_count):`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`while (num >= g_base_count):`'
- en: '`mod = num % g_base_count`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod = num % g_base_count`'
- en: '`encode = g_alphabet[mod] + encode`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode = g_alphabet[mod] + encode`'
- en: '`num = num // g_base_count`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`num = num // g_base_count`'
- en: '`if (num >= 0):`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (num >= 0):`'
- en: '`encode = g_alphabet[num] + encode`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode = g_alphabet[num] + encode`'
- en: '`return encode`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`return encode`'
- en: '**Program 9.5:** Program to encode number into base58 string'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.5：** 将数字编码为 Base58 字符串的程序'
- en: 'The following program postfix four bytes of checksum to the number before base58
    encoding to generate base58check encoding:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序在将数字进行 Base58 编码之前，在数字后缀四个字节的校验和，以生成 Base58check 编码：
- en: '`def base58checkEncode(prefix: bytes, b: bytes):`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`def base58checkEncode(prefix: bytes, b: bytes):`'
- en: '`with_prefix = prefix + b`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_prefix = prefix + b`'
- en: '`with_checksum = with_prefix + hash256(with_prefix)[0:4]`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_checksum = with_prefix + hash256(with_prefix)[0:4]`'
- en: '`val = int.from_bytes(with_checksum, byteorder=’big’)`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`val = int.from_bytes(with_checksum, byteorder=’big’)`'
- en: '`encode = base58_encode(val)`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode = base58_encode(val)`'
- en: '`if prefix == b’\x00’:`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`if prefix == b’\x00’:`'
- en: '`encoded_prefix = base58_encode(0)`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoded_prefix = base58_encode(0)`'
- en: '`encode = encoded_prefix + encode`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode = encoded_prefix + encode`'
- en: '`return encode`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`return encode`'
- en: '**Program 9.6:** Program to encode a number into Base-58-Check-Encode'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.6：** 将数字编码为 Base-58-Check-Encode 的程序'
- en: 'The following program converts private key hex code WIF format. It takes hex
    code of private key and a Boolean value stating if the key is supposed to be used
    to generate a compressed public key:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将私钥十六进制代码转换为 WIF 格式。它接受私钥的十六进制代码和一个布尔值，表示该密钥是否应用于生成压缩的公钥：
- en: '`PRIVKEY_PREFIX_MAINNET=0x80`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVKEY_PREFIX_MAINNET=0x80`'
- en: '`WIF_PREFIX_MAINNET_COMPRESSED=[‘L’, ‘K’]`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIF_PREFIX_MAINNET_COMPRESSED=[‘L’, ‘K’]`'
- en: '`WIF_PREFIX_MAINNET_UNCOMPRESSED=[‘5’]`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIF_PREFIX_MAINNET_UNCOMPRESSED=[‘5’]`'
- en: '`PRIVKEY_PREFIX_TESTNET=0xEF`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVKEY_PREFIX_TESTNET=0xEF`'
- en: '`WIF_PREFIX_TESTNET_COMPRESSED=[‘c’]`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIF_PREFIX_TESTNET_COMPRESSED=[‘c’]`'
- en: '`WIF_PREFIX_TESTNET_UNCOMPRESSED=[‘9’]`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIF_PREFIX_TESTNET_UNCOMPRESSED=[‘9’]`'
- en: '`def encodeWifPrivkey(privkey: int, for_compressed_pubkey: bool):`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`def encodeWifPrivkey(privkey: int, for_compressed_pubkey: bool):`'
- en: '`prefix_b = bytes.fromhex(‘%02x’ % PRIVKEY_PREFIX_TESTNET)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix_b = bytes.fromhex(‘%02x’ % PRIVKEY_PREFIX_TESTNET)`'
- en: '`privkey_b = bytes.fromhex(‘%064x’ % privkey)`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = bytes.fromhex(‘%064x’ % privkey)`'
- en: '`if for_compressed_pubkey == True:`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`if for_compressed_pubkey == True:`'
- en: '`privkey_b = privkey_b + b’\01’`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = privkey_b + b’\01’`'
- en: '`wif_encoded = base58checkEncode(prefix_b, privkey_b)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif_encoded = base58checkEncode(prefix_b, privkey_b)`'
- en: '`return wif_encoded`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`return wif_encoded`'
- en: '**Program 9.7:** Method to generate WIF encoded private key'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.7：** 生成 WIF 编码私钥的方法'
- en: 'We call this method for compressed public key as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种方法为压缩公钥的方法：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`h = 0x1f4b9c36e4f466464de890a341eba483eb3ed95932d797b0841afa1d8d83c420`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = 0x1f4b9c36e4f466464de890a341eba483eb3ed95932d797b0841afa1d8d83c420`'
- en: '`wif = encodeWifPrivkey(h, True)`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif = encodeWifPrivkey(h, True)`'
- en: '`print(wif)`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(wif)`'
- en: 'We get the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](images/Figure-9.3.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.3.jpg)'
- en: '**Figure 9.3:** Shows the generated WIF encoded private key for compressed
    public key'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.3：** 显示了生成的压缩公钥的 WIF 编码私钥'
- en: 'We call it for uncompressed public key as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称其为未压缩公钥时的方法：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`h = 0x1f4b9c36e4f466464de890a341eba483eb3ed95932d797b0841afa1d8d83c420`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = 0x1f4b9c36e4f466464de890a341eba483eb3ed95932d797b0841afa1d8d83c420`'
- en: '`wif = encodeWifPrivkey(h, False)`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif = encodeWifPrivkey(h, False)`'
- en: '`print(wif)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(wif)`'
- en: 'We get the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](images/Figure-9.4.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.4.jpg)'
- en: '**Figure 9.4:** Shows the generate WIF encoded private key for uncompressed
    public key'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.4：** 显示了未压缩公钥的生成的WIF编码私钥'
- en: '[Public key](toc.xhtml#s197a)'
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[公钥](toc.xhtml#s197a)'
- en: A private key is normally represented in WIF encoding. We use the WIF encoded
    private key to generate the public key and address. To generate public key from
    WIF encoded private key, we need to convert the private key back to hex code.
    The reason why we use WIF encoded string and not hex code is the size. Private
    key is presented as a 64-digit hex code or 53-character string. So, using WIF
    encode means 11 digits less to type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个私钥通常以WIF编码表示。我们使用WIF编码的私钥来生成公钥和地址。要从WIF编码的私钥生成公钥，我们需要将私钥转换回十六进制代码。我们使用WIF编码字符串而不是十六进制代码的原因是尺寸。私钥被表示为64位十六进制代码或53个字符的字符串。因此，使用WIF编码意味着少输入11位数字。
- en: 'First, we decode the WIF string and, along with the decoded hex-coded private
    key, we also get whether it is for testnet or mainnet and whether it is for compressed
    public key or uncompressed public key. Here’s the code to decode the WIF string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们解码WIF字符串，以及解码的十六进制编码的私钥，我们还得到它是用于测试网还是主网以及它是用于压缩公钥还是未压缩公钥。这是解码WIF字符串的代码：
- en: '`def base58_decode(s: str):`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`def base58_decode(s: str):`'
- en: '`decoded = 0`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`decoded = 0`'
- en: '`multi = 1`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`multi = 1`'
- en: '`s = s[::-1]`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = s[::-1]`'
- en: '`for char in s:`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`for char in s:`'
- en: '`decoded += multi * g_alphabet.index(char)`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`decoded += multi * g_alphabet.index(char)`'
- en: '`multi = multi * g_base_count`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`multi = multi * g_base_count`'
- en: '`return decoded`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`return decoded`'
- en: '`def base58checkDecode(s: str):`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`def base58checkDecode(s: str):`'
- en: '`with_checksum_int = base58_decode(s)`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_checksum_int = base58_decode(s)`'
- en: '`with_checksum_b = bytes.fromhex(‘%x’ % with_checksum_int)`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_checksum_b = bytes.fromhex(‘%x’ % with_checksum_int)`'
- en: '`decode_b = with_checksum_b[1:-4]`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode_b = with_checksum_b[1:-4]`'
- en: '`return decode_b`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`return decode_b`'
- en: '`def base58checkVerify(wif: str):`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`def base58checkVerify(wif: str):`'
- en: '`decoded_wif = base58_decode(wif)`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`decoded_wif = base58_decode(wif)`'
- en: '`wif_str = ‘%02x’ % decoded_wif`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif_str = ‘%02x’ % decoded_wif`'
- en: '`if len(wif_str) % 2 == 1:`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(wif_str) % 2 == 1:`'
- en: '`wif_str = ‘0’ + wif_str`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif_str = ‘0’ + wif_str`'
- en: '`postfix = bytes.fromhex(wif_str)[-4:]`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`postfix = bytes.fromhex(wif_str)[-4:]`'
- en: '`wif_without_postfix = bytes.fromhex(wif_str)[0:-4]`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif_without_postfix = bytes.fromhex(wif_str)[0:-4]`'
- en: '`h = hash256(wif_without_postfix)[0:4]`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hash256(wif_without_postfix)[0:4]`'
- en: '`if h == postfix:`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`if h == postfix:`'
- en: '`return True`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`return False`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`def getNetworkNCompression(wif_prefix: str):`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getNetworkNCompression(wif_prefix: str):`'
- en: '`if wif_prefix in WIF_PREFIX_MAINNET_COMPRESSED:`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`if wif_prefix in WIF_PREFIX_MAINNET_COMPRESSED:`'
- en: '`return ‘mainnet’, True`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ‘mainnet’, True`'
- en: '`elif wif_prefix in WIF_PREFIX_MAINNET_UNCOMPRESSED:`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif wif_prefix in WIF_PREFIX_MAINNET_UNCOMPRESSED:`'
- en: '`return ‘mainnet’, False`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ‘mainnet’, False`'
- en: '`elif wif_prefix in WIF_PREFIX_TESTNET_COMPRESSED:`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif wif_prefix in WIF_PREFIX_TESTNET_COMPRESSED:`'
- en: '`return ‘testnet’, True`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ‘testnet’, True`'
- en: '`elif wif_prefix in WIF_PREFIX_TESTNET_UNCOMPRESSED:`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif wif_prefix in WIF_PREFIX_TESTNET_UNCOMPRESSED:`'
- en: '`return ‘testnet’, False`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ‘testnet’, False`'
- en: '`def privkeyWif2Hex(privkey_wif: str):`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`def privkeyWif2Hex(privkey_wif: str):`'
- en: '`assert base58checkVerify(privkey_wif)`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert base58checkVerify(privkey_wif)`'
- en: '`wif_prefix = privkey_wif[0:1]`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`wif_prefix = privkey_wif[0:1]`'
- en: '`network, compress = getNetworkNCompression(wif_prefix)`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`network, compress = getNetworkNCompression(wif_prefix)`'
- en: '`privkey_b = base58checkDecode(privkey_wif)`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = base58checkDecode(privkey_wif)`'
- en: '`privkey_i = int.from_bytes(privkey_b, byteorder=’big’)`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_i = int.from_bytes(privkey_b, byteorder=''big'')`'
- en: '`if compress == True:`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`if compress == True:`'
- en: '`privkey_s = ‘%066x’ % privkey_i`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s = ''%066x'' % privkey_i`'
- en: '`else:`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`privkey_s = ‘%064x’ % privkey_i`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s = ''%064x'' % privkey_i`'
- en: '`return privkey_s, network, compress`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`return privkey_s, network, compress`'
- en: '**Program 9.8:** Program to encode private key into WIF encoding scheme'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.8：** 将私钥编码为 WIF 编码方案的程序'
- en: 'Bitcoin private key public key cryptography is based on **Elliptic Curve Digital
    Signature Algorithm (ECDSA)**. **Elliptic** c**urve** d**igital** s**ignature**
    a**lgorithm** uses e**lliptic** c**urve** c**ryptography**. As the name suggests,
    elliptic curve is a geometric representation of the following equation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币私钥公钥加密基于**椭圆曲线数字签名算法（ECDSA）**。**椭圆** c**urve** d**igital** s**ignature**
    a**lgorithm** 使用椭圆曲线密码学。正如名称所示，椭圆曲线是以下方程的几何表示：
- en: '*y² = x³+ ax + b*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*y² = x³+ ax + b*'
- en: 'Elliptic curve cryptography is based on an elliptic curve over a finite field,
    also called **Galois Fields**. Galois field can be a prime field or a binary field.
    Bitcoin uses a specific elliptic curve over a finite prime field called ***secp256k1***.
    Here’s the equation for *secp256k1*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学基于有限域上的椭圆曲线，也称为**伽罗瓦场**。伽罗瓦场可以是素域或二元域。比特币使用了一个特定的椭圆曲线，即有限素域上的*secp256k1*。以下是
    *secp256k1* 的方程：
- en: '*y² = x² + ax + b*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*y² = x² + ax + b*'
- en: Here
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里
- en: p = 2^(256) - 2^(32) - 2⁹ - 2⁸ - 2⁷ - 2⁶ - 2⁴-1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: p = 2^(256) - 2^(32) - 2⁹ - 2⁸ - 2⁷ - 2⁶ - 2⁴-1
- en: p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
- en: 'There is also a variable called **Generation Point,** and its value is:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为**生成点**的变量，其值为：
- en: '`G = (79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798,
    483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8)`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`G = (79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798,
    483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8)`'
- en: We use the ecdsa package in Python to generate public keys from private key
    hex code. Once the WIF private key is decoded, we use the ecdsa *package.* The
    e*cdsa* package uses signing key to denote private key and verifying key to denote
    public key.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中使用 ecdsa 包从私钥十六进制代码生成公钥。一旦 WIF 私钥被解码，我们使用 ecdsa *包。* e*cdsa* 包使用签名密钥表示私钥，使用验证密钥表示公钥。
- en: 'The following is the ecdsa package we use in the :'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在中使用的 ecdsa 包：
- en: '![](images/Figure-9.5.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.5.jpg)'
- en: '**Figure 9.5:** The pip3 package information about installed ecdsa package'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.5：** pip3 包关于已安装 ecdsa 包的信息'
- en: 'We also use cryptotools package for secp256k1 related operations. The following
    program converts WIF encoded private key to public key:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 cryptotools 包执行与 secp256k1 相关的操作。以下程序将 WIF 编码的私钥转换为公钥：
- en: '`from ecdsa import SigningKey, SECP256k1`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`from ecdsa import SigningKey, SECP256k1`'
- en: '`def compressPubkey(pubkey: bytes):`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`def compressPubkey(pubkey: bytes):`'
- en: '`x_b = pubkey[1:33]`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_b = pubkey[1:33]`'
- en: '`y_b = pubkey[33:65]`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`y_b = pubkey[33:65]`'
- en: '`if (y_b[31] & 0x01) == 0: # even`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (y_b[31] & 0x01) == 0: # even`'
- en: '`compressed_pubkey = b’\x02’ + x_b`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`compressed_pubkey = b’\x02’ + x_b`'
- en: '`else:`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`compressed_pubkey = b’\x03’ + x_b`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`compressed_pubkey = b’\x03’ + x_b`'
- en: '`return compressed_pubkey`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`return compressed_pubkey`'
- en: '`def privkeyHex2pubkey(privkey_s: str, compress: bool):`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`def privkeyHex2pubkey(privkey_s: str, compress: bool):`'
- en: '`if compress == True:`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`if compress == True:`'
- en: '`privkey_s = privkey_s[0:64]`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s = privkey_s[0:64]`'
- en: '`privkey_b = bytes.fromhex(privkey_s)`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = bytes.fromhex(privkey_s)`'
- en: '`sk = SigningKey.from_string(privkey_b, curve=SECP256k1)`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`sk = SigningKey.from_string(privkey_b, curve=SECP256k1)`'
- en: '`vk = sk.get_verifying_key()`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`vk = sk.get_verifying_key()`'
- en: '`pubkey_b = b’\x04’ + vk.to_string()`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = b’\x04’ + vk.to_string()`'
- en: '`if compress == True:`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`if compress == True:`'
- en: '`pubkey_b = compressPubkey(pubkey_b)`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = compressPubkey(pubkey_b)`'
- en: '`return pubkey_b`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`return pubkey_b`'
- en: '`def privkeyWif2pubkey(privkey: str):`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`def privkeyWif2pubkey(privkey: str):`'
- en: '`privkey_s, network, compress = privkeyWif2Hex(privkey)`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s, network, compress = privkeyWif2Hex(privkey)`'
- en: '`pubkey = privkeyHex2pubkey(privkey_s, compress)`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey = privkeyHex2pubkey(privkey_s, compress)`'
- en: '`return pubkey`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`return pubkey`'
- en: '**Program 9.9:** Program to get public key from WIF encoded private key'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.9：** 从 WIF 编码的私钥获取公钥的程序'
- en: In the preceding code, b’\x04’ is a prefix in the uncompressed public key, and
    b’\x02’ and n’\x03’ are used as a prefix in the compressed public key.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，b’\x04’是未压缩公钥的前缀，b’\x02’和n’\x03’被用作压缩公钥的前缀。
- en: 'We call the preceding program by executing the following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行以下代码调用上述程序：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`privkey_wif = ‘cNdY2QGfetwijtrqzCK5tAoc78NtGkQJ8smYVaugDW6puLXJvLZG’`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_wif = ‘cNdY2QGfetwijtrqzCK5tAoc78NtGkQJ8smYVaugDW6puLXJvLZG’`'
- en: '`print(‘privkey(WIF) = ‘, privkey_wif)`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘privkey(WIF) = ‘, privkey_wif)`'
- en: '`privkey_s, network, compress = privkeyWif2Hex(privkey_wif)`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s, network, compress = privkeyWif2Hex(privkey_wif)`'
- en: '`pubkey_b = privkeyWif2pubkey(privkey_wif)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = privkeyWif2pubkey(privkey_wif)`'
- en: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
- en: '`print(‘-----------------------------------------------------------’)`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘-----------------------------------------------------------’)`'
- en: '`privkey_wif = ‘91phZVP8Q5yMLEZbD41vfnGYWwEZuxbjQ5huSxiPUkkTiQw8SL2’`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_wif = ‘91phZVP8Q5yMLEZbD41vfnGYWwEZuxbjQ5huSxiPUkkTiQw8SL2’`'
- en: '`print(‘privkey(WIF) = ‘, privkey_wif)`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘privkey(WIF) = ‘, privkey_wif)`'
- en: '`privkey_s, network, compress = privkeyWif2Hex(privkey_wif)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s, network, compress = privkeyWif2Hex(privkey_wif)`'
- en: '`pubkey_b = privkeyWif2pubkey(privkey_wif)`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = privkeyWif2pubkey(privkey_wif)`'
- en: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
- en: 'And we get the following public keys:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下公钥：
- en: '![](images/Figure-9.6.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.6.jpg)'
- en: '**Figure 9.6:** Shows public key generated from WIF enconded private keys'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 9.6:** 显示从WIF编码的私钥生成的公钥'
- en: '[Address](toc.xhtml#s198a)'
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[地址](toc.xhtml#s198a)'
- en: When a merchant or a trader requests bitcoins against their service or product,
    they provide their Bitcoin address. We transfer the requested bitcoins to their
    address, and save any change left to a different address. In this subtopic, we
    will understand and generate addresses from the public key.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当商家或交易者要求以他们的服务或产品兑换比特币时，他们会提供他们的比特币地址。我们将请求的比特币转到他们的地址，并将剩余的任何找零保存到另一个地址。在本子主题中，我们将了解并从公钥生成地址。
- en: 'The following illustration shows how public-key-hash address is generated:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了如何生成公钥哈希地址：
- en: '![](images/Figure-9.7.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.7.jpg)'
- en: '**Figure 9.7:** Illustration of Address Generation mechanism'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 9.7:** 地址生成机制的说明'
- en: The public key to address conversion is a two-step process. In the first step,
    we calculate the hash of the public key, which is ***PKH*** or **public-key-hash**.
    In the second step, we encode PKH with the base58check algorithm. One important
    benefit of using checksum is that it is almost impossible to make a typing mistake
    and still generate a valid address. This is an important safety feature of Bitcoin.
    Mnemonic code also uses the base58check algorithm, and it provides the same benefit.
    Putting wrong order, or a wrong or repeated word will almost never lead to loss
    of funds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥到地址的转换是一个两步过程。在第一步，我们计算公钥的哈希，即***PKH*** 或 **公钥哈希**。在第二步，我们使用base58check算法编码PKH。使用校验和的一个重要好处是，几乎不可能在生成有效地址时犯打字错误。这是比特币的一个重要安全特性。助记符代码也使用base58check算法，并提供相同的好处。顺序放错，或者放错或重复的词几乎不会导致资金损失。
- en: Using hash160 and address instead of the public key provides enhanced security.
    If, in the future, quantum computers can translate public key to private key,
    then hashing public key will be still secure. So, unless we have exposed our public
    key, our bitcoins will be still secure. And this is significant as the breakdown
    of public key private key encryption will lead to mayhem for almost everything
    on the internet.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希160和地址代替公钥可以提供增强的安全性。如果将来量子计算机能够将公钥翻译成私钥，那么哈希公钥仍然会是安全的。所以，除非我们暴露了我们的公钥，我们的比特币仍然会是安全的。这对于几乎互联网上的所有事物来说都是重要的，因为公钥私钥加密的崩溃将导致混乱。
- en: It is possible to have a script instead of a public key. In that case, the public
    key is replaced by the script in the preceding figure. The public key address
    is called **Pay-to-Public-Key-Hash** or **P2PKH** address, and the script address
    is called **Pay-to-Script-Hash** or **P2SH** address.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用脚本代替公钥。在这种情况下，在前面的图中公钥被脚本替换。公钥地址被称为**Pay-to-Public-Key-Hash** 或 **P2PKH**
    地址，而脚本地址被称为 **Pay-to-Script-Hash** 或 **P2SH** 地址。
- en: 'The following table lists the version prefixes related to network and address
    type:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了与网络和地址类型相关的版本前缀：
- en: '![](images/306.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](images/306.jpg)'
- en: '**Table 9.2:** Table for address prefixes'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 9.2:** 地址前缀表'
- en: In the preceding table, we can see that `**testnet**` *and* `**regtest**` use
    the same version prefix.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们可以看到`**testnet**` *和* `**regtest**` 使用相同的版本前缀。
- en: 'The following program converts public key to address:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将公钥转换为地址：
- en: '`PKH_MAINNET_PREFIX = 0x00`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKH_MAINNET_PREFIX = 0x00`'
- en: '`SH_MAINNET_PREFIX = 0x05`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`SH_MAINNET_PREFIX = 0x05`'
- en: '`PKH_TESTNET_PREFIX = 0x6F`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKH_TESTNET_PREFIX = 0x6F`'
- en: '`SH_TESTNET_PREFIX = 0xC4`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`SH_TESTNET_PREFIX = 0xC4`'
- en: '`PKH_REGTEST_PREFIX = 0x6F`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKH_REGTEST_PREFIX = 0x6F`'
- en: '`SH_REGTEST_PREFIX = 0xC4`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`SH_REGTEST_PREFIX = 0xC4`'
- en: '`def hash160(secret: bytes):`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`def hash160(secret: bytes):`'
- en: '`secrethash = hashlib.sha256(secret).digest()`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrethash = hashlib.sha256(secret).digest()`'
- en: '`h = hashlib.new(‘ripemd160’)`'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hashlib.new(‘ripemd160’)`'
- en: '`h.update(secrethash)`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`h.update(secrethash)`'
- en: '`secret_hash160 = h.digest()`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret_hash160 = h.digest()`'
- en: '`return secret_hash160`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`return secret_hash160`'
- en: '`def pkh2address(pkh: bytes):`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`def pkh2address(pkh: bytes):`'
- en: '`prefix = PKH_TESTNET_PREFIX`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix = PKH_TESTNET_PREFIX`'
- en: '`address = base58checkEncode(bytes.fromhex(‘%02x’ % prefix), pkh)`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = base58checkEncode(bytes.fromhex(‘%02x’ % prefix), pkh)`'
- en: '`return address`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`return address`'
- en: '`def sh2address(sh: bytes):`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sh2address(sh: bytes):`'
- en: '`prefix = SH_TESTNET_PREFIX`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix = SH_TESTNET_PREFIX`'
- en: '`address = base58checkEncode(bytes.fromhex(‘%02x’ % prefix), pkh)`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = base58checkEncode(bytes.fromhex(‘%02x’ % prefix), pkh)`'
- en: '`return address`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`return address`'
- en: '`def pubkey2address(pubkey: bytes):`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`def pubkey2address(pubkey: bytes):`'
- en: '`pkh = hash160(pubkey)`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkh = hash160(pubkey)`'
- en: '`address = pkh2address(pkh)`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = pkh2address(pkh)`'
- en: '`return address`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`return address`'
- en: '**Program 9.10:** Program to convert public key into addresses'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**Program 9.10:** 将公钥转换为地址的程序'
- en: 'We call the preceding method using the following program to get address from
    compressed as well as uncompressed public keys:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下程序调用前面的方法，以获取压缩和未压缩公钥生成的地址：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`pubkey = ‘0240bb63da114aa89f4d2cf35d695d3e52e6add7a4bae06f190d947bef5c62b5e0’`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey = ‘0240bb63da114aa89f4d2cf35d695d3e52e6add7a4bae06f190d947bef5c62b5e0’`'
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = bytes.fromhex(pubkey)`'
- en: '`print(‘Compressed PubKey = ‘, pubkey_b.hex())`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Compressed PubKey = ‘, pubkey_b.hex())`'
- en: '`address = pubkey2address(pubkey_b)`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = pubkey2address(pubkey_b)`'
- en: '`print(‘Address = ‘, address)`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Address = ‘, address)`'
- en: '`print(‘-----------------------------------------------’)`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘-----------------------------------------------’)`'
- en: '`pubkey = ‘0440bb63da114aa89f4d2cf35d695d3e52e6add7a4bae06f190d947bef5c62b5e0e99601851593a9e54e2059a25d76512698acf60089935dedc015f1bb2bc81eda’`'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey = ‘0440bb63da114aa89f4d2cf35d695d3e52e6add7a4bae06f190d947bef5c62b5e0e99601851593a9e54e2059a25d76512698acf60089935dedc015f1bb2bc81eda’`'
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = bytes.fromhex(pubkey)`'
- en: '`print(‘Uncompressed PubKey = ‘, pubkey_b.hex())`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Uncompressed PubKey = ‘, pubkey_b.hex())`'
- en: '`address = pubkey2address(pubkey_b)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = pubkey2address(pubkey_b)`'
- en: '`print(‘Address = ‘, address)`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Address = ‘, address)`'
- en: 'And we get the following result:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下结果：
- en: '![](images/Figure-9.8.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.8.jpg)'
- en: '**Figure 9.8:** Shows addresses generated from public keys'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.8：** 显示了从公钥生成的地址'
- en: '[Hierarchical Deterministic (HD) wallet](toc.xhtml#s199a)'
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[分层确定性（HD）钱包](toc.xhtml#s199a)'
- en: 'In the earlier version, a wallet used to be a collection of private key public
    key pairs stored in a file. The file was required to be backed up multiple times
    and secured at multiple places. This was cumbersome and has led to the loss of
    coins for many in the initial years. However, there was one advantage: since these
    are not generated from a single seed, accidentally exposing the secret will not
    lead to loss of all the coins in the derived addresses. These were non-deterministic
    wallets.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本中，钱包是一个存储在文件中的私钥和公钥对的集合。这个文件需要备份多次，并在多个地方加以保护。这很繁琐，并且在最初几年导致了很多人丢失硬币。然而，有一个优点：由于这些不是从一个单一的种子生成的，意外暴露秘密不会导致在派生地址中丢失所有硬币。这些都是非确定性钱包。
- en: The alternative to this is deterministic wallets, which are generated using
    a single seed and an index. Hierarchical deterministic wallets require a string
    representing the hierarchical location of keys instead of the index value. This
    allows the generation of a very large number of keys from a single seed. Additionally,
    it provides a way to group addresses for different purposes by selecting a different
    hierarchical location in the hierarchy.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的替代方案是确定性钱包，它们使用一个单一的种子和一个索引生成。分层确定性钱包需要一个表示键的层次结构的字符串，而不是索引值。这使得从一个单一的种子生成大量的键成为可能。此外，它通过在层次结构中选择不同的层次位置，为不同目的提供了一种分组地址的方法。
- en: Hierarchical deterministic wallet uses 12-, 18- or 24-word mnemonic code, which
    makes it easier to remember seed and at the same time, provides similar security
    as any complex password. It is easier to remember and type 12 words. This is useful
    if the wallet requires typing them every time or you don’t want to write on paper.
    A 24-word code is more secure and recommended in most cases.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 分层确定性钱包使用12个、18个或24个单词的助记词，这使得更容易记住种子，同时提供与任何复杂密码相似的安全性。记住和输入12个单词更容易。如果钱包需要每次都输入它们，或者你不想把它们写在纸上，这很有用。24个单词的代码更安全，在大多数情况下都推荐使用。
- en: Using the deterministic wallet as defined in BIP32 makes it easier to generate
    the private key and public key pair or just public keys whenever required. This
    eliminates the need for the physical form of a wallet. So, while we are traveling
    and spending or trading, we can generate addresses and private keys as we require.
    There is still a risk that we can accidentally expose mnemonic code and lose all
    our savings, but if we always generate keys or addresses offline, we can almost
    remove this risk. There are specialized devices called hardware wallets that do
    just that and so, are considered the best way to store bitcoins.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如BIP32所定义的确定性钱包，可以在需要时更容易地生成私钥和公钥对，或者只生成公钥。这消除了对钱包的物理形式的需求。因此，在旅行和消费或交易时，我们可以根据需要生成地址和私钥。我们仍然有不小心暴露助记词并失去所有储蓄的风险，但如果我们总是离线生成键或地址，我们可以几乎消除这种风险。有专门的设备叫做硬件钱包，它们就是这么做的，因此，被认为是存储比特币的最佳方式。
- en: 'The following figure illustrates the keys generation using mnemonic code word
    list using BIP32 specification for hierarchical deterministic wallet:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了使用BIP32规范进行分层确定性钱包的mnemonic代码词列表生成密钥：
- en: '![](images/Figure-9.9.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.9.jpg)'
- en: '**Figure 9.9:** Illustration of key generation using Mnemonic Code Word List'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.9：** 使用Mnemonic代码词列表生成密钥的说明'
- en: BIP32 specification uses the pbkdf2-hmac algorithm to generate private keys.
    **pbkdf2** stands for **Password-Based Key Derivation Function 2**. pbkdf2 requires
    hashing algorithm as an input. We use SHA512 as the hashing algorithm required
    by pbkdf2\. Additionally, pbkdf2 is an iterative process of key derivation; the
    higher the number of iterations, the more secure is the derived key against brute
    force attacks, but a higher number also takes a long time to generate. If we generate
    a sufficiently large number of private key public key pairs once so that we don’t
    require to run the program again and again, we can have a much higher iteration
    count. Bitcoin Core does this and generates 100 private keys, public keys, and
    addresses in the first run. Once the keys and addresses are generated, wallet
    file is like a JBOK for the user. It is recommended that the iteration count should
    be more than 10,000\. Bitcoin Core uses 25,000 iterations, but there are quite
    popular wallets that use an iteration count of just 2048, which probably means
    2048 must be ok if we don’t want to create a JBOK wallet file and use it efficiently.
    We will use 10,000 to balance both time and security.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: BIP32规范使用pbkdf2-hmac算法生成私钥。**pbkdf2**代表**基于密码的密钥派生函数2**。pbkdf2需要散列算法作为输入。我们使用SHA512作为pbkdf2所需的散列算法。此外，pbkdf2是一个密钥派生的迭代过程；迭代次数越多，生成的密钥越安全，但迭代次数越多，生成密钥所需的时间也越长。如果我们一次性生成足够多的私钥公钥对，这样我们就不需要反复运行程序，我们可以有更高的迭代次数。比特币核心这样做，在第一次运行中生成100个私钥、公钥和地址。一旦生成了密钥和地址，钱包文件对用户来说就像是一个JBOK。建议迭代次数应该超过10,000。比特币核心使用25,000次迭代，但有些流行的钱包使用的迭代次数仅为2048，这意味着如果我不想创建一个JBOK钱包文件并有效使用它，2048应该是可以的。我们将使用10,000来平衡时间和安全性。
- en: 'The following figure shows how the seed is generated:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了种子的生成方式：
- en: '![](images/Figure-9.10.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.10.jpg)'
- en: '**Figure 9.10:** Illustration of the mechanism of generation of seed from Mnemonic
    Code word list'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.10：** 从Mnemonic代码词列表生成种子的机制说明'
- en: 'To do this in Python code, we require hmac and pbkdf2 packages. We use the
    pbkdf2 source from the following source code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中执行此操作，我们需要hmac和pbkdf2包。我们使用以下源代码中的pbkdf2：
- en: '**[https://github.com/sfstpala/python3-pbkdf2](https://github.com/sfstpala/python3-pbkdf2)**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**[https://github.com/sfstpala/python3-pbkdf2](https://github.com/sfstpala/python3-pbkdf2)**'
- en: 'We also need to use following package for secp256k1 elliptic curve cryptography:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下用于secp256k1椭圆曲线密码学的包：
- en: '![](images/Figure-9.11.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.11.jpg)'
- en: '**Figure 9.11:** The pip3 package information about installed cryptotools package'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.11：** 安装的cryptotools包的pip3包信息'
- en: 'The following code generates seed from the mnemonic code word list:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 从mnemonic代码词列表生成种子的代码如下：
- en: '`import pbkdf2`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`import pbkdf2`'
- en: '`import hashlib`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`import hashlib`'
- en: '`import hmac`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`import hmac`'
- en: '`import struct`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`import struct`'
- en: '`from cryptotools.ECDSA.secp256k1 import PublicKey, \`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`from cryptotools.ECDSA.secp256k1 import PublicKey, \`'
- en: '`PrivateKey, Point, G as secp256k1_G, \`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrivateKey, Point, G as secp256k1_G, \`'
- en: '`N as secp256k1_n, CURVE`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`N as secp256k1_n, CURVE`'
- en: '`iterations_g = 10000`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterations_g = 10000`'
- en: '`dklen_g = 64 # derived key length`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`dklen_g = 64 # 派生密钥长度`'
- en: '`def genSeedFromStr(password: str, salt: str):`'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genSeedFromStr(password: str, salt: str):`'
- en: '`password_b = password.encode(‘utf-8’)`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`password_b = password.encode(''utf-8'')`'
- en: '`salt_b = salt.encode(‘utf-8’)`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`salt_b = salt.encode(''utf-8'')`'
- en: '`seed = pbkdf2.pbkdf2(hashlib.sha512, password_b, salt_b, iterations_g, dklen_g)`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed = pbkdf2.pbkdf2(hashlib.sha512, password_b, salt_b, iterations_g, dklen_g)`'
- en: '`return seed`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`return seed`'
- en: '**Program 9.11:** Program to generate seed from Mnemonic Code word list and
    salt string'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序9.11：** 从Mnemonic代码词列表和盐字符串生成种子的程序'
- en: 'We passed a mnemonic code word list and a passcode to the seed generation method,
    as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将mnemonic代码词列表和密码传递给种子生成方法，如下所示：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ''__main__'':`'
- en: '`mnemonic_code_l = [‘moral’, ‘submit’, ‘comfort’, ‘cupboard’, ‘organ’,`'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`mnemonic_code_l = [''moral'', ''submit'', ''comfort'', ''cupboard'', ''organ'',`'
- en: '`‘expand’, ‘home’, ‘bid’, ‘dawn’, ‘ozone’, ‘omit’, ‘helmet’]`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`''expand'', ''home'', ''bid'', ''dawn'', ''ozone'', ''omit'', ''helmet'']`'
- en: '`mnemonic_code = ‘ ‘.join(mnemonic_code_l)`'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`mnemonic_code = '' '' .join(mnemonic_code_l)`'
- en: '`print(‘Mnemonic Code = ‘, mnemonic_code)`'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(''Mnemonic Code = '', mnemonic_code)`'
- en: '`seed = genSeedFromStr(mnemonic_code, ‘mnemonic’ + ‘mycomplexpasscode’)`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed = genSeedFromStr(mnemonic_code, ‘mnemonic’ + ‘mycomplexpasscode’)`'
- en: '`print(‘seed = %s’ % seed.hex())`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘seed = %s’ % seed.hex())`'
- en: 'And we get 512-bit seed as a result:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个512位的种子作为结果：
- en: '![](images/Figure-9.12.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.12.jpg)'
- en: '**Figure 9.12:** Shows the seed and mnemonic code generated from the program'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.12：** 从程序中生成种子和助记词代码'
- en: Once the seed is derived from mnemonic code using pbkdf2, we use the key to
    generate the master key pair and then further children’s key pairs. We use the
    HMAC code to generate these keys. HMAC stands for **Hash-based Message Authentication
    Code**.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从助记词代码中使用pbkdf2导出种子，我们使用该密钥生成主密钥对，然后进一步生成子密钥对。我们使用HMAC代码生成这些密钥。HMAC代表**基于哈希的消息认证码**。
- en: 'HMAC : Hash-based message authentication code'
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HMAC：基于哈希的消息认证码
- en: 'Following figure illustrates hash-based message authentication:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了基于哈希的消息认证：
- en: '![](images/Figure-9.13.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.13.jpg)'
- en: '**Figure 9.13:** Illustration of HMAC-based authentication mechanism'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.13：** 说明基于HMAC的认证机制'
- en: Bob shares secret with Alice, so Bob and Alice only know the secret. Bob needs
    to send a message (m) to Alice. He uses the HMAC-SHA512 hashing algorithm to generate
    hash (h) and sends it to Alice along with the message. When Alice receives the
    message, she again generates hash using same HMAC-SHA512 algorithm. If calculated
    hash is the same as received hash, she is sure that the message has not been tampered
    with.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃与爱丽丝分享秘密，所以鲍勃和爱丽丝只知道这个秘密。鲍勃需要给爱丽丝发送一个消息（m）。他使用HMAC-SHA512哈希算法生成哈希（h）并发送给爱丽丝，同时附带消息。当爱丽丝收到消息时，她再次使用相同的HMAC-SHA512算法生成哈希。如果计算出的哈希与收到的哈希相同，她可以确信消息没有被篡改。
- en: We use the HMAC-SHA512 algorithm for the generation of master key pairs and
    subsequent children’s key pairs.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HMAC-SHA512算法来生成主密钥对和随后的子密钥对。
- en: '[Master key generation](toc.xhtml#s200a)'
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[主密钥生成](toc.xhtml#s200a)'
- en: 'The following figure illustrates master private key generation and master chaincode
    generation, which will be required to generate children at the next level in the
    hierarchy of key pairs:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了主私钥生成和主链码生成，这些将在密钥对层次结构中生成下一级子密钥对时被需要：
- en: '![](images/Figure-9.14.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.14.jpg)'
- en: '**Figure 9.14:** Illustration of generation of master key address from seed
    bytes'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.14：** 说明如何从种子字节生成主密钥地址'
- en: 'Here’s the program:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序代码：
- en: '`def genMasterKeys(seed: bytes):`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genMasterKeys(seed: bytes):`'
- en: '`h = hmac.new(bytes(“Bitcoin seed”, ‘utf-8’),`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hmac.new(bytes(“Bitcoin seed”, ‘utf-8’),`'
- en: '`seed,`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed,`'
- en: '`hashlib.sha512).digest()`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashlib.sha512).digest()`'
- en: '`private_key = int.from_bytes((h[0:32]), byteorder=’big’)`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`private_key = int.from_bytes((h[0:32]), byteorder=’big’)`'
- en: '`chaincode = h[32:64]`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`chaincode = h[32:64]`'
- en: '`return private_key, chaincode`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`return private_key, chaincode`'
- en: '**Program 9.12:** Program to generate master private key and Chaincode pair'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序9.12：** 生成主私钥和链码对的程序'
- en: 'We call this method as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用此方法：
- en: '`privkey, chaincode = genMasterKeys(seed)`'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey, chaincode = genMasterKeys(seed)`'
- en: '`privkey_s = ‘%064x’ % privkey`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s = ‘%064x’ % privkey`'
- en: '`print(‘master privkey = %s’ % privkey_s)`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘master privkey = %s’ % privkey_s)`'
- en: '`print(‘master chaincode = %s’ % chaincode.hex())`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘master chaincode = %s’ % chaincode.hex())`'
- en: 'This generates the following master private key and chaincode:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下主私钥和链码：
- en: '![](images/Figure-9.15.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.15.jpg)'
- en: '**Figure 9.15:** Shows master private key and master chaincode generated from
    the program'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.15：** 从程序中生成的主私钥和主链码'
- en: '[Key derivation](toc.xhtml#s201a)'
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[密钥导出](toc.xhtml#s201a)'
- en: '[Parent private key -> Child private key](toc.xhtml#s202a)'
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[父私钥 -> 子私钥](toc.xhtml#s202a)'
- en: 'Each key pair at a tree location can generate children’s key pairs. For the
    first children, we have the following child private key derivation mechanisms:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 每个树位置的密钥对可以生成子密钥对。对于第一次生成的子，我们有以下子私钥导出机制：
- en: '![](images/Figure-9.16.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.16.jpg)'
- en: '**Figure 9.16:** Illustration of child private key derivation mechanism'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.16：** 说明子私钥导出机制'
- en: To derive child private key and child chaincode, we need parent private key,
    parent public key, parent chaincode, and index of the child to be derived. This
    method is used to derive child from index 0 to 2^(31) - 1.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导出子私钥和子链码，我们需要父私钥、父公钥、父链码以及要导出的子索引。此方法用于从索引0到2^(31) - 1导出子密钥。
- en: 'The following code implements the child key derivation procedure:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了子密钥导出过程：
- en: '`def finiteFieldAddition(a: int, b: int, modulo: int):`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`def finiteFieldAddition(a: int, b: int, modulo: int):`'
- en: '`return (a + b) % modulo`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`return (a + b) % modulo`'
- en: '`def genNormalChildPrivKey(privkey: int, chaincode: bytes, index: int):`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genNormalChildPrivKey(privkey: int, chaincode: bytes, index: int):`'
- en: '`privkey_s = ‘%064x’ % privkey`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_s = ‘%064x’ % privkey`'
- en: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
- en: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`h256 = int.from_bytes(h[0:32], byteorder=''big'')`'
- en: '`child_privkey = finiteFieldAddition(h256, privkey, secp256k1_n)`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey = finiteFieldAddition(h256, privkey, secp256k1_n)`'
- en: '`child_chaincode = h[32:64]`'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_chaincode = h[32:64]`'
- en: '`return child_privkey, child_chaincode`'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`return child_privkey, child_chaincode`'
- en: '**Program 9.13:** Program to generate child’s private key and chaincode from
    parent’s private key and chaincode'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.13：** 从父私钥和链码生成子私钥和链码的程序'
- en: 'The preceding code is run as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的运行如下：
- en: '`child_privkey_i, child_chaincode = genNormalChildPrivKey(privkey, chaincode,
    1)`'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey_i, child_chaincode = genNormalChildPrivKey(privkey, chaincode,
    1)`'
- en: '`child_privkey_wif = encodeWifPrivkey(child_privkey_i, True)`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey_wif = encodeWifPrivkey(child_privkey_i, True)`'
- en: '`print(“child privkey = %s” % child_privkey_wif)`'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`print("child privkey = %s" % child_privkey_wif)`'
- en: '`print(“child chaincode = %s” % child_chaincode.hex())`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`print("child chaincode = %s" % child_chaincode.hex())`'
- en: 'It gives us the following results:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了以下结果：
- en: '![](images/Figure-9.17.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/Figure-9.17.jpg)'
- en: '**Figure 9.17:** Shows child private key and child chaincode generated from
    the program'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.17：** 展示了从程序生成的子私钥和子链码'
- en: '[Parent public key -> Child public key](toc.xhtml#s203a)'
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[父公钥 -> 子公钥](toc.xhtml#s203a)'
- en: One of the important reasons why BIP32 is so useful is that we can derive child
    public keys and addresses without knowing parent private keys. This protects against
    accidentally exposing private keys; therefore, private keys for all the subsequent
    children.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: BIP32 如此有用的一个重要原因是，我们可以在不知道父私钥的情况下派生子公钥和地址。这可以防止意外暴露私钥；因此，后续所有子的私钥都是安全的。
- en: 'This is based on the following logic:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于以下逻辑：
- en: '*P[p]: Parent Private Key*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[p]：父私钥*'
- en: '*U[p]: Parent Public Key*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*U[p]：父公钥*'
- en: '*P[C]: Child Private Key*'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[C]：子私钥*'
- en: '*U[C]: Child Public Key*'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*U[C]：子公钥*'
- en: '*H[0-31]: 32 MSB of hmac(sha512) hash obtained from parent chaincode,public
    key and child index*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[0-31]：从父链码、公钥和子索引获得的 hmac(sha512) 哈希的 32 个 MSB*'
- en: '*G: Generation point in finite field elliptic curve*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*G：有限域椭圆曲线中的生成点*'
- en: 'As we learned in child private key derivation:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在子私钥派生中学到的：
- en: ⇒ *P[P]+H[0-31] = P[C] (1)*
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒ *P[P]+H[0-31] = P[C] (1)*
- en: 'Multiplying both sides by generation point G:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 将两边乘以生成点 G：
- en: '*P[P] G + H[0-31] G = P[C].G*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[P] G + H[0-31] G = P[C].G*'
- en: 'In the elliptic curve cryptography public key is derived as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线密码学中，公钥的派生如下：
- en: ⇒*U[x] = P[x].G (2)*
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒ *U[x] = P[x].G (2)*
- en: '*(1), (2)* ⇒ *U[P] + H[0-31] .G = U[C]*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*(1), (2)* ⇒ *U[P] + H[0-31] .G = U[C]*'
- en: G is a vector on the x, y coordinate in the finite field. Multiplying G with
    scalar hash requires elliptic curve finite field point multiplication, and addition
    of and requires elliptic curve finite field point addition. Plus, if the public
    key we are using is compressed, then we will require an un-compression algorithm
    using elliptic curve cryptography.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: G 是有限域中 x、y 坐标的向量。将 G 与标量哈希相乘需要进行椭圆曲线有限域点乘法，并且与相加需要进行椭圆曲线有限域点加法。另外，如果我们使用的公钥是压缩的，则需要使用椭圆曲线密码学解压算法。
- en: 'The following figure illustrates this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图所示：
- en: '![](images/Figure-9.18.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.18.jpg)'
- en: '**Figure 9.18:** Illustration of the derivation of child public key from parent
    public key and chaincode'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.18：** 从父公钥和链码派生子公钥的示意图'
- en: 'The following Python implementation generates child public key from parent
    public key:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Python 实现从父公钥生成子公钥：
- en: '`G_p = Point(secp256k1_G[0], secp256k1_G[1])`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`G_p = Point(secp256k1_G[0], secp256k1_G[1])`'
- en: '`def compressPubkey(pubkey_b: bytes):`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '内联代码 `def compressPubkey(pubkey_b: bytes):`'
- en: '`pubkey_P = PublicKey.decode(pubkey_b)`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_P = PublicKey.decode(pubkey_b)`'
- en: '`pubkey_b = PublicKey.encode(pubkey_P, compressed=True)`'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = PublicKey.encode(pubkey_P, compressed=True)`'
- en: '`return pubkey_b`'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`return pubkey_b`'
- en: '`def genNormalChildPubKey(pubkey_b: bytes, chaincode: bytes, index: int):`'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genNormalChildPubKey(pubkey_b: bytes, chaincode: bytes, index: int):`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
- en: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
- en: '`h256G = CURVE.point_mul(G_p, h256)`'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`h256G = CURVE.point_mul(G_p, h256)`'
- en: '`pubkey_b = compressPubkey(pubkey_b)`'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = compressPubkey(pubkey_b'
- en: '`pubkey_point = Point.from_compact(pubkey_b[1:])`'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_point = Point.from_compact(pubkey_b[1:])`'
- en: '`child_pubkey_point = h256G + pubkey_point`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_pubkey_point = h256G + pubkey_point`'
- en: '`child_pubkey_b = PublicKey.encode(child_pubkey_point, compressed=True)`'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_pubkey_b = PublicKey.encode(child_pubkey_point, compressed=True)`'
- en: '`child_chaincode = h[32:64]`'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_chaincode = h[32:64]`'
- en: '`return child_pubkey_b, child_chaincode`'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`return child_pubkey_b, child_chaincode`'
- en: '**Program 9.14:** Program to derive child public key and chaincode from parent
    public key and chaincode'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.14：** 从父公钥和链码派生子公钥和链码的程序'
- en: 'We call the preceding code as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用前面的代码：
- en: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
- en: '`child_pubkey_b, child_chaincode = genNormalChildPubKey(pubkey_b,`'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_pubkey_b, child_chaincode = genNormalChildPubKey(pubkey_b,`'
- en: '`chaincode, 1)`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`chaincode, 1)`'
- en: '`print(“child pubkey key = %s” % child_pubkey_b.hex())`'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“child pubkey key = %s” % child_pubkey_b.hex())`'
- en: '`print(“child chaincode = %s”% child_chaincode.hex())`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“child chaincode = %s”% child_chaincode.hex())`'
- en: 'This gives us the following result:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '![](images/Figure-9.19.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.19.jpg)'
- en: '**Figure 9.19:** Shows the generated child public key and chaincode'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.19：** 显示生成的子公钥和链码'
- en: We can see that the child chaincode derived with the private key is the same
    as the chaincode derived with the public key.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，用私钥派生的子链码与用公钥派生的链码相同。
- en: '[Child private key -> Parent private key (Wallet private key leak)](toc.xhtml#s204a)'
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[子私钥 -> 父私钥（钱包私钥泄露）](toc.xhtml#s204a)'
- en: There exists a risk when we use xpub. If we accidentally expose a child’s private
    key to an attacker who has access to the xpub of the parent, they can find all
    the private keys in the wallet and drain all the stored bitcoins.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 xpub 时存在风险。如果我们不小心将子私钥暴露给拥有父 xpub 的攻击者，他们可以找到钱包中的所有私钥，并提取所有存储的比特币。
- en: 'The following equation explains how this happens:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方程解释了这是如何发生的：
- en: '*P[p] + H[0-31] = P[C]*'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[p] + H[0-31] = P[C]*'
- en: ⇒ *P[C] - H_[0-31] =P[P]*
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒ *P[C] - H_[0-31] =P[P]*
- en: This shows that by knowing the HMAC-SHA256 hash and private key of the child,
    we can get the private key of the parent. And since we got the parent’s private
    key, we can get the private key of the parent’s parent by the same mechanism.
    Additionally, once the parent private key is known, we can derive the private
    keys of all its children. This means just by losing one private key and the corresponding
    xpub of the parent, the whole wallet can be drained of bitcoins.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，通过知道儿童的 HMAC-SHA256 哈希和私钥，我们可以获得父私钥。而且既然我们获得了父私钥，我们就可以通过同样的机制获得父的父私钥。此外，一旦父私钥被知道，我们可以派生出其所有孩子的私钥。这意味着，只需丢失一个私钥和相应的父
    xpub，整个钱包就可以被提取比特币。
- en: 'The following figure illustrates the stages of exposure:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图说明了曝光的阶段：
- en: '![](images/Figure-9.20.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.20.jpg)'
- en: '**Figure 9.20:** Illustration of an attacker deriving all the private keys
    using a single private key'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.20：** 攻击者使用一个私钥派生出所有私钥的示意图'
- en: When someone has got hold of your private key, they can derive more and more
    private keys from it, and finally, reach the master key and derive all keys, as
    we have done with the private key derivation.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当某人掌握了你的私钥时，他们可以从它派生出越来越多的私钥，最终到达主密钥并派生出所有的钥匙，正如我们用私钥派生所做的那样。
- en: 'The following program derives the private key of parent from child private
    key:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序从子私钥派生出父私钥：
- en: '`def genNormalParentPrivKey(child_privkey_i: int,`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genNormalParentPrivKey(child_privkey_i: int,`'
- en: '`pubkey_b: bytes,`'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b: bytes,`'
- en: '`chaincode: bytes,`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`chaincode: bytes,`'
- en: '`index: int):`'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`index: int):`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hmac.new(chaincode, pubkey_b + index_b, hashlib.sha512).digest()`'
- en: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
- en: '`privkey = finiteFieldAddition(-h256, child_privkey_i, secp256k1_n)`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey = finiteFieldAddition(-h256, child_privkey_i, secp256k1_n)`'
- en: '`return privkey`'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`return privkey`'
- en: '**Program 9.15:** Program to derive Parent Private Key from Child Private Key'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.15：** 从子私钥派生父私钥的程序'
- en: 'We call the preceding code as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用前面的代码：
- en: '`p_privkey_i = genNormalParentPrivKey(child_privkey_i,`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_privkey_i = genNormalParentPrivKey(child_privkey_i,`'
- en: '`pubkey_b, chaincode, 1)`'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b, chaincode, 1)`'
- en: '`p_privkey_wif = encodeWifPrivkey(p_privkey_i, True)`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_privkey_wif = encodeWifPrivkey(p_privkey_i, True)`'
- en: '`print(‘parent privkey = %064x’ % p_privkey_i)`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘parent privkey = %064x’ % p_privkey_i)`'
- en: 'This gives us the following result:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '![](images/Figure-9.21.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.21.jpg)'
- en: '**Figure 9.21:** Shows parent private key obtained using child private key,
    public key and chaincode'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.21:** 使用子私钥、公钥和链码获得的父私钥'
- en: We can see here that we derived the same master private key that we had got
    from the seed.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这里派生出了我们之前从种子得到的相同的主私钥。
- en: '[Deriving hardened child keys](toc.xhtml#s205a)'
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[派生硬化的子密钥](toc.xhtml#s205a)'
- en: In the previous sections, you learned normal key derivation, and you also learned
    that we could lose all bitcoin stored in the wallet by an easy-to-make mistake.
    To avoid this, BIP32 also suggests a modification to child derivation algorithms
    called hardened derivation.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，您学习了正常的密钥派生，同时也了解到我们可能会因为一个容易犯的错误而失去钱包中所有的比特币。为了避免这种情况，BIP32还建议对子派生算法进行修改，称为硬化派生。
- en: 'The following figure illustrates the procedure of hardened derivation:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图说明了硬化派生的过程：
- en: '![](images/Figure-9.22.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.22.jpg)'
- en: '**Figure 9.22:** Illustration of the derivation of Child Private Key from Hardened
    Parent Private Key'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.22:** 从硬化父私钥派生子私钥的过程'
- en: 'We see here that in hardened derivation, parent private key is used with byte
    0x00 as suffix to it instead of parent public key. The child index for hardened
    derivation is from 2^31 to 2^32-1:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，在硬化的派生中，父私钥使用字节0x00作为后缀，而不是父公钥。硬化的子派生的子索引从2^31到2^32-1：
- en: '`def genHardenedChildPrivKey(privkey: int, chaincode: bytes, index: int):`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`def genHardenedChildPrivKey(privkey: int, chaincode: bytes, index: int):`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`privkey_b = bytes.fromhex(‘%064x’ % privkey)`'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = bytes.fromhex(‘%064x’ % privkey)`'
- en: '`h = hmac.new(chaincode, b’\x00’ + privkey_b + index_b, hashlib.sha512).digest()`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hmac.new(chaincode, b’\x00’ + privkey_b + index_b, hashlib.sha512).digest()`'
- en: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`h256 = int.from_bytes(h[0:32], byteorder=’big’)`'
- en: '`child_privkey = finiteFieldAddition(h256, privkey, secp256k1_n)`'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey = finiteFieldAddition(h256, privkey, secp256k1_n)`'
- en: '`child_chaincode = h[32:64]`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_chaincode = h[32:64]`'
- en: '`return child_privkey, child_chaincode`'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`return child_privkey, child_chaincode`'
- en: '**Program 9.16:** Program to derive child private key from hardened parent
    private key'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.16:** 从硬化父私钥派生子私钥的程序'
- en: 'We call the preceding code as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用前面的代码：
- en: '`index = ((1<<31) + 1) # 2^31 + 1`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`index = ((1<<31) + 1) # 2^31 + 1`'
- en: '`child_privkey_i, child_chaincode = genHardenedChildPrivKey(privkey, chaincode,
    index)`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey_i, child_chaincode = genHardenedChildPrivKey(privkey, chaincode,
    index)`'
- en: '`child_privkey_wif = encodeWifPrivkey(child_privkey_i, True)`'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_privkey_wif = encodeWifPrivkey(child_privkey_i, True)`'
- en: '`print(“child privkey = %s” % child_privkey_wif)`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“child privkey = %s” % child_privkey_wif)`'
- en: '`print(“child chaincode = %s” % child_chaincode.hex())`'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“child chaincode = %s” % child_chaincode.hex())`'
- en: 'We get the following result:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](images/Figure-9.23.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.23.jpg)'
- en: '**Figure 9.23:** Shows hardened child private key and chaincode'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.23:** 显示硬化子私钥和链码'
- en: Unlike normal, child hardened children derivation does not support xpub or extended
    public keys. Consequently, to watch child addresses, we cannot use xpub; instead,
    we need to generate public keys and addresses offline and then pass them to the
    online wallet to watch them. This is a bit inconvenient compared to normal derivation,
    but as this is much more secure, it is recommended over normal derivation. In
    the next section, we will see how we can combine both to have a better tradeoff
    between security and convenience.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常的子派生不同，硬化的子派生不支持xpub或扩展公钥。因此，要观察子地址，我们无法使用xpub；相反，我们需要离线生成公钥和地址，然后将它们传递给在线钱包以观察。这与正常的派生相比有点不方便，但由于这更加安全，因此建议使用正常的派生。在下一节中，我们将了解如何将两者结合起来，以在安全和方便之间实现更好的权衡。
- en: '[Extended keys](toc.xhtml#s206a)'
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[扩展密钥](toc.xhtml#s206a)'
- en: BIP32 also describes xpub and xprv for mainnet and tpub and tprv for testnet.
    These are used by wallets to generate child keys and addresses. The xpub and tpub
    are used to generate only public keys, while xprv and tprv are used to generate
    private keys. The generated xpub or tpub can be given to the wallet to watch generated
    addresses without exposing private keys or seeds. The generated xprv or tprv can
    be given to the wallet to generate private keys. This makes HD Wallets convenient
    to use, and that is the reason BIP32 specification is used by almost all wallet
    software today, like Bitcoin Core, electrum, and hard wallets like nano or trezor.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: BIP32 还描述了主网的 xpub 和 xprv 以及测试网的 tpub 和 tprv。这些被钱包用来生成子密钥和地址。xpub 和 tpub 用于生成公钥，而
    xprv 和 tprv 用于生成私钥。生成的 xpub 或 tpub 可以提供给钱包以监视生成的地址，而无需暴露私钥或种子。生成的 xprv 或 tprv
    可以提供给钱包以生成私钥。这使得 HD 钱包易于使用，这也是为什么几乎所有的钱包软件都使用 BIP32 规范，如比特币核心、电子钱包以及硬件钱包如 nano
    或 trezor。
- en: 'The following illustration shows xprv derivation:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 xprv 的派生过程：
- en: '![](images/Figure-9.24.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.24.jpg)'
- en: '**Figure 9.24:** Illustration of the derivation of extended private key'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.24：** 扩展私钥派生的示意图'
- en: 'The following illustration shows xpub derivation:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 xpub 的派生过程：
- en: '![](images/Figure-9.25.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.25.jpg)'
- en: '**Figure 9.25:** Illustration of the derivation of extended public key'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.25：** 扩展公钥派生的示意图'
- en: For the Master xpub and xprv, depth is zero and parent fingerprint is 4-byte
    of zeroes.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主 xpub 和 xprv，深度为零，父指纹是零字节的 4 字节。
- en: '[Master extended public and private keys](toc.xhtml#s207a)'
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[主扩展公钥和私钥](toc.xhtml#s207a)'
- en: Master is the root of all keys, and knowing its xpub key will allow generating
    all subsequent keys. You should never have any reason to generate xpub or xprv
    for root. However, in this section, you learn to generate xpub and xprv.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '主是所有密钥的根，知道它的 xpub 密钥将允许生成所有后续密钥。您绝不应该有任何理由为根生成 xpub 或 xprv。然而，在本节中，您将学习生成
    xpub 和 xprv 的方法。 '
- en: 'The following code prepares master xpub and xprv:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码准备了主 xpub 和 xprv：
- en: '`XPUB_VERSION = ‘0488B21E’`'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`XPUB_VERSION = ‘0488B21E’`'
- en: '`XPRV_VERSION = ‘0488ADE4’`'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`XPRV_VERSION = ‘0488ADE4’`'
- en: '`TPUB_VERSION = ‘043587CF’`'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`TPUB_VERSION = ‘043587CF’`'
- en: '`TPRV_VERSION = ‘04358394’`'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`TPRV_VERSION = ‘04358394’`'
- en: '`def getMasterXPrv(chaincode_b: bytes, privkey: int):`'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMasterXPrv(chaincode_b: bytes, privkey: int):`'
- en: '`version_b = bytes.fromhex(TPRV_VERSION)`'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = bytes.fromhex(TPRV_VERSION)`'
- en: '`depth_b = b’\x00’`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth_b = b’\x00’`'
- en: '`fingerprint_p_b = bytes(4)`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`fingerprint_p_b = bytes(4)`'
- en: '`index_b = bytes(4)`'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = bytes(4)`'
- en: '`privkey_b = bytes.fromhex(‘%066x’ % privkey)`'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = bytes.fromhex(‘%066x’ % privkey)`'
- en: '`raw_xprv = depth_b + fingerprint_p_b + index_b + chaincode_b + privkey_b`'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw_xprv = depth_b + fingerprint_p_b + index_b + chaincode_b + privkey_b`'
- en: '`xprv = base58checkEncode(version_b, raw_xprv)`'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`xprv = base58checkEncode(version_b, raw_xprv)`'
- en: '`return xprv`'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`return xprv`'
- en: '`def getMasterXPub(chaincode_b: bytes, pubkey: str):`'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMasterXPub(chaincode_b: bytes, pubkey: str):`'
- en: '`version_b = bytes.fromhex(TPUB_VERSION)`'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = bytes.fromhex(TPUB_VERSION)`'
- en: '`depth_b = b’\x00’`'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth_b = b’\x00’`'
- en: '`fingerprint_p_b = bytes(4)`'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`fingerprint_p_b = bytes(4)`'
- en: '`index_b = bytes(4)`'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = bytes(4)`'
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = bytes.fromhex(pubkey)`'
- en: '`raw_xpub = depth_b + fingerprint_p_b + index_b + chaincode_b + pubkey_b`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw_xpub = depth_b + fingerprint_p_b + index_b + chaincode_b + pubkey_b`'
- en: '`xpub = base58checkEncode(version_b, raw_xpub)`'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`xpub = base58checkEncode(version_b, raw_xpub)`'
- en: '`return xpub`'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`return xpub`'
- en: '**Program 9.17:** Program to derive master XPrv and master XPub'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 9.17：** 派生主 XPrv 和主 XPub 的程序'
- en: 'We call the method as follows:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下调用该方法：
- en: '`xprv = getMasterXPrv(chaincode, privkey)`'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`xprv = getMasterXPrv(chaincode, privkey)`'
- en: '`print(‘xprv=%s’ % xprv)`'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘xprv=%s’ % xprv)`'
- en: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = privkeyHex2pubkey(privkey_s, True)`'
- en: '`xpub = getMasterXPub(chaincode, pubkey_b.hex())`'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`xpub = getMasterXPub(chaincode, pubkey_b.hex())`'
- en: '`print(‘xprv=%s’ % xpub)`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘xprv=%s’ % xpub)`'
- en: 'We get the following master xpub and xprv:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下主 xpub 和 xprv：
- en: '![](images/Figure-9.26.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.26.jpg)'
- en: '**Figure 9.26:** Shows xprv and xpub for master'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.26：** 显示了主 xprv 和 xpub'
- en: '[Extended public and private keys](toc.xhtml#s208a)'
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[扩展公钥和私钥](toc.xhtml#s208a)'
- en: We can generate xpub and xprv for a depth and index in the key derivation hierarchy
    if we have the key and chaincode of the root.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有根的密钥和链码，我们可以为密钥派生层次结构中的深度和索引生成 xpub 和 xprv。
- en: 'In the following code, we generate xprv and xpub for a given depth and index:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们根据给定的深度和索引生成 xprv 和 xpub：
- en: '`def getXPrv(p_pubkey: str,`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getXPrv(p_pubkey: str,`'
- en: '`chaincode_b: bytes,`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`chaincode_b: bytes,`'
- en: '`privkey: int,`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey: int,`'
- en: '`depth: int,`'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth: int,`'
- en: '`index: int):`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`index: int):`'
- en: '`version_b = bytes.fromhex(TPRV_VERSION)`'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = bytes.fromhex(TPRV_VERSION)`'
- en: '`p_pubkey_b = bytes.fromhex(p_pubkey)`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_pubkey_b = bytes.fromhex(p_pubkey)`'
- en: '`privkey_b = bytes.fromhex(‘%066x’ % privkey)`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`privkey_b = bytes.fromhex(‘%066x’ % privkey)`'
- en: '`depth_b = bytes([depth])`'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth_b = bytes([depth])`'
- en: '`p_fingerprint_b = hash160(p_pubkey_b)[0:4]`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_fingerprint_b = hash160(p_pubkey_b)[0:4]`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`raw_xprv = depth_b + p_fingerprint_b + index_b + chaincode_b + privkey_b`'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw_xprv = depth_b + p_fingerprint_b + index_b + chaincode_b + privkey_b`'
- en: '`xprv = base58checkEncode(version_b, raw_xprv)`'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`xprv = base58checkEncode(version_b, raw_xprv)`'
- en: '`return xprv`'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`return xprv`'
- en: '`def getXPub(p_pubkey: str,`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getXPub(p_pubkey: str,`'
- en: '`chaincode_b: bytes,`'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`chaincode_b: bytes,`'
- en: '`pubkey: str,`'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey: str,`'
- en: '`depth: int,`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth: int,`'
- en: '`index: int):`'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`index: int):`'
- en: '`version_b = bytes.fromhex(TPUB_VERSION)`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = bytes.fromhex(TPUB_VERSION)`'
- en: '`p_pubkey_b = bytes.fromhex(p_pubkey)`'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_pubkey_b = bytes.fromhex(p_pubkey)`'
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = bytes.fromhex(pubkey)`'
- en: '`depth_b = bytes([depth])`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth_b = bytes([depth])`'
- en: '`p_fingerprint_b = hash160(p_pubkey_b)[0:4]`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_fingerprint_b = hash160(p_pubkey_b)[0:4]`'
- en: '`index_b = struct.pack(‘>L’, index)`'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_b = struct.pack(‘>L’, index)`'
- en: '`raw_xpub = depth_b + p_fingerprint_b + index_b + chaincode_b + pubkey_b`'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw_xpub = depth_b + p_fingerprint_b + index_b + chaincode_b + pubkey_b`'
- en: '`xpub = base58checkEncode(version_b, raw_xpub)`'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`xpub = base58checkEncode(version_b, raw_xpub)`'
- en: '`return xpub`'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`return xpub`'
- en: '**Program 9.18:** Program to generate XPub and XPrv for a given depth and index'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序9.18:** 给定深度和索引生成XPub和XPrv的程序'
- en: 'We call the method as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下调用方法：
- en: '`# We are calculating for index=1 and depth=1`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 我们正在为index=1和depth=1计算`'
- en: '`child_xprv = getXPrv(pubkey_b.hex(), child_chaincode, child_privkey_i, 1,
    1)`'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_xprv = getXPrv(pubkey_b.hex(), child_chaincode, child_privkey_i, 1,
    1)`'
- en: '`print(‘child xprv:’)`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘child xprv:’)`'
- en: '`print(child_xprv)`'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(child_xprv)`'
- en: '`child_xpub = getXPub(pubkey_b.hex(), child_chaincode, child_pubkey_b.hex(),1,
    1)`'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_xpub = getXPub(pubkey_b.hex(), child_chaincode, child_pubkey_b.hex(),1,
    1)`'
- en: '`print(‘child xpub:’)`'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘child xpub:’)`'
- en: '`print(child_xpub)`'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(child_xpub)`'
- en: 'We get the following xprv and xpub for the given keys:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为给定的密钥得到以下的xprv和xpub：
- en: '![](images/Figure-9.27.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.27.jpg)'
- en: '**Figure 9.27:** Shows child xprv and child xpub'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.27:** 显示孩子xprv和xpub'
- en: We can register xpub with wallets in order to watch transactions in which the
    generated addresses are involved. BitcoinJ is one of the wallets that accepts
    xpub for watching addresses. The generated xprv can be used to generate child
    private key public key pairs for signing transactions. You should never expose
    or use xprv anywhere and even avoid using xpub. Always generate those addresses
    privately and register individual addresses with wallets to watch. This will protect
    against the risk of losing bitcoins.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注册xpub到钱包中，以便观察涉及生成的地址的交易。BitcoinJ是支持用xpub观察地址的钱包之一。生成的xprv可以用来生成签名交易的孩子私钥公钥对。你绝不应该在任何地方暴露或使用xprv，甚至应该避免使用xpub。总是私下生成这些地址，并将个人地址注册到钱包中观察。这将有助于防范丢失比特币的风险。
- en: '[Key derivation path](toc.xhtml#s209a)'
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[密钥派生路径](toc.xhtml#s209a)'
- en: As we know now, the beauty of a hierarchical deterministic wallet is that we
    can derive keys at any depth and any index deterministically. To be able to locate
    a key on a hierarchy, HD wallets use a notation called key derivation path.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们现在所知，分层确定性钱包的美妙之处在于我们可以以任何深度和任何索引确定性地派生密钥。为了能够在层次结构中定位一个密钥，HD钱包使用一种称为密钥派生路径的表示法。
- en: 'Here’s the notation for the key derivation path:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对密钥派生路径的表示：
- en: The master key is denoted by m.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主密钥用m表示。
- en: The normal key is denoted by the index number 0 to 2^(31)-1.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常密钥用索引号码0到2^(31)-1表示。
- en: The hardened key is denoted by the index numbers 2^(31) to 2^(32)-1.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬化密钥用索引号码2^(31)到2^(32)-1表示。
- en: The depth separator is forward slash /.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度分隔符是正斜杠/。
- en: 'As an example, key derivation path could be as follows:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，密钥派生路径可能如下所示：
- en: '*m/45/78’/56/9’*'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '*m/45/78’/56/9’*'
- en: Here, 78’ and 9’ are hardened keys, and 45 and 56 are normal keys.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，78’和9’是硬化密钥，而45和56是正常密钥。
- en: 'The following illustration shows key derivation including hardened keys:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图展示了包括硬化密钥的密钥派生：
- en: '![](images/Figure-9.28.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-9.28.jpg)'
- en: '**Figure 9.28:** Key derivation with hardened keys'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.28:** 包括硬化密钥的密钥派生'
- en: In the previous section, you learned that hardened keys are more secure but
    also less convenient to use.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你了解到硬化密钥更安全但也不太方便使用。
- en: '**Tip: To reduce the risk, we can have bottom level as normal derivations,
    which means xpub will help generate child indexes. However, we will also have
    parent as hardened, so if one child private key is exposed, it will expose the
    keys of other children of the same parent. But since the parent is hardened, it
    will not allow derivation of private keys of other indexes at the parent’s depth.
    We can keep the number of children under one parent limited to a small number
    like 20\. So, on each exposure of private key, we lose 20 addresses. We can further
    keep only limited bitcoins in each address so that losing them is not a large
    loss.**'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示：为了降低风险，我们可以将最低层设置为正常派生，这意味着xpub将帮助生成子索引。然而，我们也将父级设置为硬化，所以如果一个子私钥被暴露，它将暴露同一父级的其他子密钥。但由于父级是硬化的，它不会允许在父级深度派生其他索引的私钥。我们可以将每个父级下的子数限制在20个左右。所以，每次私钥暴露，我们都会失去20个地址。我们还可以在每个地址中进一步仅存储有限数量的比特币，这样失去它们就不会造成巨大损失。**'
- en: '**This may be a convenient compromise, but it is not a good option for Bitcoin,
    as Bitcoin is a high-value and high-network-fee cryptocurrency. This means storing
    in very small quantities is quite costly and losing even small denominations is
    a significant loss. In short, Bitcoin is not suitable for smaller transactions,
    trading, and having lower security. This strategy might work for other cryptocurrencies
    where network fees are not high.**'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**这可能是一种方便的妥协，但它不是比特币的好选择，因为比特币是一种高价值和高网络费用的加密货币。这意味着存储非常小的数量相当昂贵，即使失去小面额也是一笔可观的损失。简而言之，比特币不适合小额交易、交易和较低的安全性。这种策略可能适用于其他加密货币，那里的网络费用不高。**'
- en: '[Conclusion](toc.xhtml#s210a)'
  id: totrans-680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](toc.xhtml#s210a)'
- en: In this chapter, you started by learning about the need for a wallet. You then
    learned the different ways we can classify wallets and focused on implementing
    a hierarchical deterministic wallet based on the BIP32 specification. In the process
    of implementation, you learned about private key generation and structure. You
    learned to derive public key and address and generate P2PKH and P2PSH addresses
    for `**mainnet**` *and* `**testnet**`. You also learned to generate easy-to-remember,
    save, and write passwords called mnemonic code word lists. You used the mnemonic
    code to generate private keys deterministically by using the derivation path.
    In this chapter, we also discussed how to deal with security and convenience.
    We did not discuss elliptic curve cryptography as we will look at it in more detail
    in the upcoming chapters.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了钱包的必要性。然后，你学习了我们可以将钱包分类的不同方式，并专注于实现基于BIP32规范的分层确定性钱包。在实现过程中，你学习了私钥生成和结构。你学会了派生公钥和地址，并为`mainnet`
    *和* `testnet`生成P2PKH和P2PSH地址。你还学会了生成易于记忆、保存和书写的密码，称为助记词代码词列表。你使用助记词代码通过使用派生路径确定性地生成私钥。在本章中，我们还讨论了如何处理安全和便利性。我们没有讨论椭圆曲线密码学，因为我们将在接下来的章节中更详细地查看它。
- en: In the next chapter, you will learn to create the most widely used transaction
    types. You will learn to sign the transactions and validate a received transaction.
    The validation process will involve looking at the mempool and utxos stored in
    the LevelDB database.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习创建最常用的交易类型。你将学会签署交易并验证接收到的交易。验证过程将涉及查看mempool和存储在LevelDB数据库中的utxos。
- en: '[Points to remember](toc.xhtml#s211a)'
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[需记住的要点](toc.xhtml#s211a)'
- en: A wallet is a software program that stores the private key, public key, and
    addresses or has the ability to generate them on request.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钱包是一种软件程序，用于存储私钥、公钥和地址，或者能够在需要时生成它们。
- en: A wallet can tell the number of bitcoins a person is holding, and it can also
    sign a transaction before publishing it on the network.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钱包可以告诉一个人持有多少比特币，它还可以在将交易发布到网络之前签署交易。
- en: The mnemonic code word list can be 12/18/24 words. It is easier to remember
    and type 12 words, but a 24-word code is more secure.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 助记词代码词列表可以是12/18/24个单词。记住和输入12个单词更容易，但24个单词的代码更安全。
- en: To generate a secure mnemonic code, we need to generate a good random number.
    To generate a good random number, we need to find the right source of entropy.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了生成一个安全的助记词代码，我们需要生成一个好的随机数。为了生成一个好的随机数，我们需要找到正确的熵源。
- en: Pbkdf2 is an iterative process of key derivation, the higher is the number of
    iterations, the more secure is the derived key against brute force attacks.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pbkdf2是一种密钥派生迭代过程，迭代次数越多，派生密钥对暴力攻击的抵抗力越强。
- en: The recommended number of Pbkdf2 iterations is greater than 10000, but the higher
    the number, the more is the time taken to generate it.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议的Pbkdf2迭代次数大于10000，但次数越多，生成所需的时间越长。
- en: Extended Keys provide an encoding method, which, if supported, can allow the
    wallet to generate the required private keys or public keys using given extended
    keys.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展密钥提供了一种编码方法，如果支持，钱包可以使用给定的扩展密钥生成所需的私钥或公钥。
- en: BIP32 HD wallets supports the derivation of Normal Keys and Hardened Keys.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BIP32 HD钱包支持派生正常密钥和硬化密钥。
- en: If the private key of any of the child is exposed along with xpub, then someone
    can drain bitcoins stored in all the addresses of the wallet.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何子私钥的私钥泄露，那么伴随xpub，有人可以提取钱包中所有地址存储的比特币。
- en: Hardened keys do not allow the use of xpub, and losing one private key will
    not expose any other address.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬化密钥不允许使用xpub，失去一个私钥不会暴露任何其他地址。
- en: '[Questions](toc.xhtml#s212a)'
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[问题](toc.xhtml#s212a)'
- en: Why are hardware wallets considered the safest way to store coins?
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么硬件钱包被认为是存储硬币最安全的方式？
- en: What are the three functions of a wallet program?
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 钱包程序有哪三个功能？
- en: What are the pros and cons of using deterministic wallets?
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用确定性钱包的优缺点是什么？
- en: What are the benefits of using a mnemonic code word list?
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用助记词列表的好处是什么？
- en: Explain the use of extended keys.
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释扩展密钥的使用。
- en: 'Programming Questions:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程问题：
- en: 'BIP44 is based on BIP32 HD wallet that specifies derivation path for generating
    keys based on the following derivation path:'
  id: totrans-701
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BIP44基于BIP32 HD钱包，指定以下派生路径生成密钥：
- en: m / purpose’ / coin_type’ / account’ / change / address_index
  id: totrans-702
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: m / purpose’ / coin_type’ / account’ / change / address_index
- en: purpose = 44’
  id: totrans-703
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目的 = 44’
- en: cointype = 0’ for Bitcoin m*ainnet*
  id: totrans-704
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cointype = 0’用于Bitcoin主网
- en: 'account: identifier for the user account (Hardened)'
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 账户：用户账户的标识符（硬化）
- en: change = 0 (Normal) is for external address and 1 is for internal (change) address
  id: totrans-706
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: change = 0（正常）用于外部地址，1用于内部（change）地址
- en: 'address_index: Addresses are from index 0 (Normal) and upwards in sequence.'
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 地址索引：地址从索引0（正常）开始，按顺序向上。
- en: Write a program to implement HD wallet for BIP44.
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序实现BIP44的HD钱包。
- en: Write a program to generate 100 child addresses from given xpub.
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从给定的xpub生成100个子地址。
- en: Write a program to parse xprv and xpub.
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来解析xprv和xpub。
- en: 'True/False:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：
- en: Hardened derivation makes it harder to derive a child private key from the parent
    private key.
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬化派生使得从父私钥派生子私钥变得更加困难。
- en: Base58Check encoding protects the sender from typing the wrong address and consequently,
    paying to the wrong address.
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Base58Check编码保护发送者输入错误的地址，从而避免向错误地址支付。
- en: If I accidentally write a mnemonic code word list in the wrong sequence, I will
    always generate the wrong keys and the wrong address.
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不小心将助记词列表按错误顺序输入，我将总是生成错误的密钥和错误的地址。
- en: 'Fill in the blanks:'
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填空：
- en: A 24-word mnemonic code consists of ____-bit random number and ___-bit as its
    checksum.
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 24个单词的助记码由____位随机数和___位作为校验和组成。
- en: The maximum possible depth of the BIP32 HD wallet key is ______.
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BIP32 HD钱包密钥的最大可能深度是______。
- en: The full form of P2PSH is ___________ and that of P2PKH is ____________.
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: P2PSH的全称是___________，P2PKH的全称是____________。
