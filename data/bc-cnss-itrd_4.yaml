- en: protocol rules as there is no other strategy that would result in a better outcome.
    Each
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 协议规则，因为没有其他策略会导致更好的结果。每个
- en: participant is better off by just sticking to the rules of the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者最好只需遵守网络规则。
- en: If the other miners don’t switch their strategy, an attacker has no incentive
    to switch
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他矿工不改变策略，攻击者就没有动机改变
- en: their own strategy. Neither player can increase their payoffs by switching to
    a different strategy if the other player doesn’t switch their strategy. This means
    that in Bitcoin if all other miners are honest, an adversary has no incentive
    to change their strategy and try to perform malicious mining.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他们自己的策略。如果另一个玩家不改变策略，那么任何一方都无法通过转换策略来增加自己的报酬。这意味着在比特币网络中，如果所有其他的挖矿者都是诚实的，那么对手就没有动机改变策略，尝试进行恶意挖矿。
- en: Incentive mechanisms such as block reward and transaction fees in Bitcoin
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的区块奖励和交易费等激励机制
- en: discourage malicious behavior. These incentives encourage participants to behave
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止恶意行为。这些激励措施鼓励参与者的行为
- en: according to the protocol, which not only results in the creation of new bitcoins,
    that is, network progress is guaranteed, but also the security of the network
    is maintained.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据协议行事，这不仅导致了新比特币的产生，即保证了网络的进步，还维护了网络的安全性。
- en: Since 2009, the Bitcoin network has attracted so much investment in the form
    of
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自2009年以来，比特币网络以投资形式吸引了大量资金
- en: mining farms and Bitcoin businesses, exchanges, and services that network participants
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 沉默挖矿和比特币企业、交易所和服务，这些网络参与者
- en: will benefit more by protecting the network rather than destroying it. They
    gain by
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保护网络而不是摧毁它来获益。他们通过
- en: protecting the network. Even attackers cannot gain much. Imagine if some adversary
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 保护网络。即使攻击者也无法获得太多。想象一下，如果某些对手
- en: managed to find a way to move all coins owned by Satoshi Nakamoto into another
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设法找到一种方法将中本聪拥有的所有币转移到另一个
- en: account. There probably is no incentive for an attacker to do so, because the
    moment it
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 帐户。可能没有动机让攻击者这么做，因为在那一刻
- en: '235'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '235'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章区块链共识
- en: happens, the Bitcoin almost certainly will become worthless, because this event
    would
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发生，比特币几乎肯定会变得毫无价值，因为这种情况会
- en: imply that the very cryptography that protects the network has been broken (assuming
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 暗示着保护网络的密码学已经被攻破（假设
- en: that real Satoshi is not alive or has lost his private keys irrecoverably).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的中本聪已经过世或者已经无法找回他的私钥）。
- en: i have a feeling that satoshi is not moving his coins because that can cause
    Bitcoin
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一种感觉，中本聪不会转移他的硬币，因为这可能导致比特币
- en: to lose its value drastically.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 价值急剧下降。
- en: Similarly, even if an adversary somehow gains 51% of the network hash power,
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，即使对手以某种方式获得了51%的网络算力，
- en: taking over the entire network may not be beneficial anymore. Why? Because the
    best
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接管整个网络可能不再有益了。为什么？因为最好的
- en: course of action in such a situation for the adversary is to keep mining silently
    with some reasonable hash power to gain economic incentives (earn bitcoins) just
    like others on
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对手的最佳行动是悄悄地挖矿，拥有一定的算力来获得经济激励（赚取比特币），就像其他人一样
- en: the network, instead of utilizing the entire 51% hash power announcing the attack
    to the
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，而不是利用整体51%的算力来公布攻击
- en: world. That would just diminish the Bitcoin value almost entirely, and any gains
    by the
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 世界。这会几乎完全削弱比特币价值，而任何谋取利益的
- en: attacker would be worthless. Therefore, attackers do not have incentive to take
    over the
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者将是毫无意义的。因此，攻击者没有动机接管
- en: Bitcoin network, perhaps apart from some mishaps that occurred due to human
    errors
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络，也许除了由于人为错误导致的一些意外事件。
- en: and compromised keys. This is the elegance and beauty of Bitcoin that even attackers
    do
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以及被盗的密钥。这就是比特币的优雅之处，即使是攻击者也不能
- en: not gain by attacking the network. All participants gain by just playing by
    the rules. The dominant strategy for miners is to be honest.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不通过攻击网络来获取利益。所有参与者只需遵守规则，就能够获利。矿工的主导策略就是诚实。
- en: For the very first time in distributed computing, a network is created which
    does not
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算中，首次创建了一个网络，该网络不
- en: rely on any trusted third party and is permissionless, yet it doesn’t let any
    attacker take over the network. Here, I remember something, which is not directly
    relevant to Bitcoin,
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖于任何受信任的第三方，是无需许可的，但却不允许任何攻击者接管网络。在这里，我记得一些事情，虽然与比特币不直接相关，
- en: but helps to feel what many distributed computing experts might feel about Bitcoin
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但有助于感受许多分布式计算专家可能对比特币的感受
- en: when they first realize how elegant it is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们第一次意识到它有多么优雅时。
- en: '*It could not be true but it was true.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*它可能不是真的，但它是真的。*'
- en: —Mikhael Gromov
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: —Mikhael Gromov
- en: '[www.ams.org/notices/201003/201003FullIssue.pdf](http://www.ams.org/notices/201003/201003FullIssue.pdf)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.ams.org/notices/201003/201003FullIssue.pdf](http://www.ams.org/notices/201003/201003FullIssue.pdf)'
- en: With the advent of Bitcoin and novel combination of cryptography, distributed
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着比特币的出现和密码学、分布式
- en: computing, and economics, a new field of study has emerged, called Cryptoeconomics
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和经济学，出现了一门新的研究领域，称为Cryptoeconomics
- en: or Cryptonomics. This is depicted in Figur[e 5-7\.](#p254)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或Cryptonomics。这在图 [图5-7\.](#p254) 中有所描述
- en: '236'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '236'
- en: '![](index-254_1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](index-254_1.jpg)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '***Figure 5-7\.** Fusion of distributed computing, economics, and*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***图5-7\.** 分布式计算、经济学的融合*'
- en: '*cryptography – Bitcoin*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学-比特币*'
- en: We can also think of the fork resolution mechanism as a **Schelling point**
    solution. This is a game theory concept where a focal point or also called Schelling
    point is a solution that people choose by default in the absence of communication.
    Similarly, in the proof of work fork resolution mechanism, due to the longest
    (strongest) chain rule, nodes tend to choose the longest chain as a canonical
    chain to add the block that they’ve received without
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将分叉解决机制视为**谢林点**解决方案。这是博弈论概念，谢林点或称为谢林点是一种默认情况下人们选择的解决方案，当没有通信时。同样，在工作证明分叉解决机制中，由于最长（最强）链规则，节点倾向于选择最长链作为添加收到的区块的规范链，而不需
- en: any communication or direction from other nodes. This concept of cooperating
    without
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何来自其他节点的通信或指令。在没有合作的概念的情况下，
- en: communication was introduced by Thomas Schelling in his book *The Strategy of
    Conflict*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是由托马斯·谢林在他的书 *Conflict* 中提出的。
- en: '**Similarities Between PoW and Traditional BFT**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoW和传统BFT之间的相似之处**'
- en: Fundamentally, all consensus algorithms strive toward achieving safety and liveness
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，所有共识算法都致力于实现安全性和活力性
- en: 'properties. Either deterministic or probabilistic, basically all consensus
    algorithms have three main properties: agreement, validity, and termination. We
    have introduced these'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 属性。无论确定性还是概率性，基本上所有共识算法都具有三个主要属性：协议、有效性和终止。我们已经介绍了这些
- en: terms before. The question arises in Nakamoto consensus of whether we can redefine
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 术语。在Nakamoto共识中，问题出现了，我们是否能重新定义
- en: these properties in a way which is closer to the blockchain world. The answer
    is yes;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性以一种更接近区块链世界的方式被首次引入。答案是肯定的；
- en: agreement, validity, and liveness properties can be mapped to Nakamoto consensus–
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的协议、有效性和活力性属性可以映射到Nakamoto共识-
- en: specific properties of common prefix, chain quality, and chain growth, respectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 具体属性的共同前缀、链质量和链增长，分别。
- en: These terms were first introduce[d in https://eprint.iacr.org/2014/765.pdf](https://eprint.iacr.org/2014/765.pdf)
    [7].
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语首次在 https://eprint.iacr.org/2014/765.pdf 中被引入。[7]。
- en: '237'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '237'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Common Prefix**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**共同前缀**'
- en: This property implies that all honest nodes will share the same large common
    prefix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性意味着所有诚实的节点将共享相同的大型共同前缀。
- en: '**Chain Quality**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**链质量**'
- en: This property means that the blockchain contains a certain required level of
    correct
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性意味着区块链包含一定水平的正确性
- en: blocks created by honest miners. If the chain quality is compromised, then the
    validity
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由诚实的矿工创建。如果链的质量受损，那么有效性
- en: property of the protocol cannot be guaranteed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无法保证协议的特性。
- en: '**Chain Growth**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**链增长**'
- en: This property means that new correct blocks are constantly added to the blockchain
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性意味着新的正确区块不断被添加到区块链
- en: regularly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定期。
- en: These properties can be seen as the equivalent of traditional consensus properties
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以看作是传统共识属性的等价物
- en: in the Nakamoto world. Here, the common prefix is an agreement property, the
    chain
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nakamoto的世界中。在这里，共同前缀是一种协议属性，链
- en: quality is a validity property, and chain growth can be seen as a liveness property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 质量是有效性属性，链增长可以看作是活力属性。
- en: '**PoW As State Machine Replication**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoW 作为状态机复制**'
- en: A proof of work blockchain can be seen as a state machine replication mechanism
    where
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将工作证明区块链视为状态机复制机制，在这里
- en: first a leader is elected who proposes a sequence of transactions batched in
    a block.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先选举出一名领导者，他提出了一系列被批量处理的交易组成的区块。
- en: Second, the finalized (mined) block is broadcast to other nodes via a gossip
    protocol,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，最终化(挖矿)的区块通过消息传播协议广播给其他节点
- en: which is accepted and appended into their local blockchains, achieving log replication.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 被其他节点接受并追加到其本地区块链中，从而实现了日志复制。
- en: We can think of it as if the leader is proposing an order and all nodes updating
    their log (local blockchain) based on this order of transactions set in the block.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其理解为领导者提出一个顺序，并且所有节点都根据这个顺序的交易集合来更新它们的日志(本地区块链)。
- en: Let’s first see the leader election algorithm and replication algorithm in detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先详细了解领导者选举算法和复制算法。
- en: '**Leader Election Algorithm**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者选举算法**'
- en: A node that solves the proof of work puzzle is elected to finalize and broadcast
    its
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决工作量证明难题的节点被选中最终化并通过消息传递协议广播其
- en: candidate block. The leader in proof of work is elected as a function of computational
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 候选区块。工作量证明中的领导者是根据计算来选举的。
- en: power of the mining node. There is no voting required from other nodes as opposed
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 挖矿节点的算力。与传统BFT协议不同，其他节点不需要投票
- en: to other traditional BFT protocols. Also, unlike traditional BFT protocols,
    the leader is rotated every block. This approach has been used in later blockchain
    BFT protocols
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他传统BFT协议不同，领导者每个区块都会被轮换。这种方法已经在后来的区块链BFT协议中使用
- en: as well where the leader is rotated every block to thwart any attempts to sabotage
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以及领导者每个区块都被轮换为了破坏任何对挖掘尝试
- en: (compromise) the leader. Also, in traditional BFT protocols, usually the primary
    or
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (妥协)领导者。而且，与传统的BFT协议不同，通常是主节点或
- en: '238'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '238'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: leader is only changed when the primary fails, but in PoW a leader is elected
    every block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在主节点失败时，领导者才会更换，但在PoW中，领导者每个区块都会选举一次。
- en: Leader election in PoW is based on computational power; However, several techniques
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PoW中的领导者选举是基于计算能力的；然而，一些技术
- en: have been used in other permissioned blockchains, from simply randomly choosing
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 已经使用在其他许可的区块链上，从简单的随机选择到
- en: a leader or simple rotation formula to complex means such as verifiable random
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个领导者或简单的轮换公式转向了复杂的手段，比如可验证的随机
- en: functions. We will cover these techniques in Chapter [8 in detail.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数。我们将在第[8章详细介绍](https://doi.org/10.1007/978-1-4842-8179-6_8)
- en: The leader election formula is simply the same PoW formula that we have already
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者选举公式其实就是我们已经讲过的PoW公式
- en: covered in the section “How PoW Works.” A soon as any miner solves the proof
    of work, it
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在“PoW工作原理”一节中有详细介绍。一旦任何矿工解决了工作证明
- en: immediately is elected as a leader and earns the right to broadcast its newly
    mined block.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 立即被选举为领导者，并获得广播其新挖掘的区块的权利。
- en: At this point, the miner is also awarded 6.25 BTC. This reward halves every
    four years.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，矿工也会获得6.25个比特币的奖励。这个奖励每四年减半一次。
- en: At the leader election stage, the miner node has successfully solved the PoW
    puzzle,
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在领导者选举阶段，矿工节点已经成功解决了工作量证明难题，
- en: and now the log replication can start.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志复制可以开始了。
- en: '**Log Replication**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志复制**'
- en: The log replication or block replication to achieve consistency among nodes
    is achieved
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过日志复制或区块复制来实现节点之间的一致性
- en: by broadcasting the newly mined block to other nodes via a gossip dissemination
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过消息传播协议向其他节点广播新挖掘的区块
- en: 'protocol. The key differences between a normal log and a blockchain log are
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。普通日志和区块链日志之间的主要区别如下：
- en: • It is append-only and immutable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: • 它是只追加不可更改的。
- en: • Each new batch of transactions (block) has a hash of the previous
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: • 每一批新的交易(区块)都有前一个区块的散列
- en: block, thus linking it in a so-called proof of work chain or hash chain
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 区块，从而将其连接成所谓的工作证明链或哈希链
- en: or chain of blocks or blockchain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者区块链。
- en: • The blocks (content in the log) are verifiable from the previous block.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • 这些区块(日志中的内容)可以从之前的区块验证
- en: • Each block contains transactions and a block header. This structure
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个区块包含交易和区块头。这个结构
- en: was discussed in detail in Chapt[er 4\.](https://doi.org/10.1007/978-1-4842-8179-6_4)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[4章](https://doi.org/10.1007/978-1-4842-8179-6_4)中有详细讨论
- en: When a new block is broadcast, it is validated and verified by each honest node
    on
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的区块被广播时，每个诚实节点都会验证和验证它
- en: the network before it is appended to the blockchain. Log replication after leader
    election can be divided into three steps.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在将网络连接到区块链之前，领导者选举后的日志复制可以分为三个步骤。
- en: '**New Block Propagation**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**新区块传播**'
- en: A block is broadcast using the gossip protocol. We can visualize the block propagation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块使用流言协议进行广播。我们可以看到区块的传播
- en: mechanism in Figur[e 5-8\. N](#p257)otice that node 1 has sent a message, for
    example, a new block, to node 2, which is then sent to nodes 4, 14, and 13 by
    node 2\. A similar pattern
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 机制如图[5-8\. N](#p257)otice that node 1 has sent a message所示
- en: can be seen in the network for other nodes too.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中其他节点也能看到这种类型的传播。
- en: '239'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '239'
- en: '![](index-257_1.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](index-257_1.png)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '***Figure 5-8\.** Gossip protocol in Bitcoin*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***图5-8\.** 比特币中的流言协议*'
- en: This type of propagation ensures that eventually all nodes get the message with
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传播方式确保最终所有节点都收到消息。
- en: high probability. Moreover, this pattern does not overwhelm a single node with
    the
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ，此模式不会让单个节点不堪重负
- en: requirement of broadcasting a message to all nodes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 广播消息到所有节点的要求。
- en: '**Block Validation**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块验证**'
- en: 'Block validation can be seen as the state transition function (STF). This **block
    validation** **function** has the following high-level rules:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 区块验证可以看作是状态转换函数（STF）。此**区块验证** **函数**具有以下高级规则：
- en: • The block is syntactically correct.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块在语法上是正确的。
- en: • The block header hash is less than the network difficulty target.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块头哈希值小于网络难度目标。
- en: • The block timestamp is not more than two hours in future.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块时间戳不晚于未来两小时。
- en: • The block size is correct.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块大小是正确的。
- en: • All transactions are valid within the block.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: • 所有交易在区块内都是有效的。
- en: • It is referring to the previous hash.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: • 它指的是前一个哈希值。
- en: The protocol specifies very precise rules, details of which can be found a[t
    https://](https://en.bitcoin.it/wiki/Protocol_rules)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议规定了非常精确的规则，详细信息可以在[这里找到](https://en.bitcoin.it/wiki/Protocol_rules)
- en: '[en.bitcoin.it/wiki/Protocol_rules](https://en.bitcoin.it/wiki/Protocol_rules);
    however, the preceding list is a high-level list of block validation checks a
    node performs.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[en.bitcoin.it/wiki/Protocol_rules](https://en.bitcoin.it/wiki/Protocol_rules)；然而，上述列表是节点执行的区块验证检查的高级列表。'
- en: '240'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '240'
- en: '![](index-258_1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](index-258_1.png)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Append to the Blockchain**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**追加到区块链**'
- en: The block is finally inserted into the blockchain by the nodes. When appending
    to the
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 节点最终将区块插入区块链。附加到
- en: blockchain, it may happen that those nodes may have received two valid blocks.
    In that
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链，可能会发生这些节点收到两个有效区块的情况。在这种情况下
- en: case, a fork will occur, and nodes will have to decide which chain to append
    the block to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 情况下会发生分叉，节点将不得不决定将区块追加到哪个链上。
- en: We can visualize this concept in Figur[e 5-9\.](#p258)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图[5-9\.](#p258)中看到这个概念
- en: '***Figure 5-9\.** Proof of work as state machine replication*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '***图5-9\.** 工作量证明作为状态机复制*'
- en: 'As shown in Figur[e 5-9](#p258), proof of work as a state machine replication
    consists of two main operations: leader election through proof of work and then
    replication via a gossip'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[5-9](#p258)所示，工作量证明作为状态机复制由两个主要操作组成：通过工作量证明进行领导者选举，然后通过流言协议进行复制
- en: protocol and receiving node’s block validation and insertion mechanism. After
    proof
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和接收节点的区块验证和插入机制。经过工作
- en: of work on a node, if the proof of work is valid, then the block is treated
    the same as if it has been received from another node and eventually inserted
    into the local blockchain
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ，如果工作量证明有效，则将该区块视为来自其他节点并最终插入本地区块链的区块
- en: database after validation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 验证后插入到数据库中。
- en: A component that chooses which chain is conclusive in case of a conflict is
    called a
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生冲突时选择哪个链是决定性的组件被称为
- en: fork handler which embodies fork resolution rules on how to handle a fork.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代表叉分辨规则的叉分辨程序
- en: '241'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '241'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Fork Resolution**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**叉分辨**'
- en: Fork resolution can be seen as a fault tolerance mechanism in Bitcoin. Fork
    resolution
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，叉分辨可以看作是一种容错机制。叉分辨
- en: rules ensure that only the chain that has the most work done to produce it is
    the one
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 规则确保只有拥有最多工作的链是
- en: that is always picked up by the nodes when inserting a new block. When a valid
    block
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有效的区块被插入并最终发生分叉时
- en: arrives for the same height, then the fork resolution mechanism allows the node
    to
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到达相同高度时，叉分辨机制允许节点以高概率
- en: ignore the shorter chain and add the block only to the longest chain. Also note
    that this is not always the case that the longest chain has the most work done;
    it could happen
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略较短的链，只将区块添加到最长的链。还要注意，最长的链并不总是具有最多的工作量；这种情况可能发生
- en: that a shorter chain may have the most computational hash power behind it, that
    is, the
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 较短的链可能具有最多的计算散列能力，即
- en: accumulated proof of work, and in that case, that chain will be selected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 累积工作证明， 在这种情况下，将选择该链。
- en: We can calculate the accumulated proof of work by first calculating the difficulty
    of
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先计算
- en: a particular block, say B, then we can use the following formula. The difficulty
    of a block can be defined as finding how much harder it is to find a valid proof
    of work nonce for
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 特定区块B，那么我们可以使用以下公式。一个区块的难度可以定义为找到一个有效的工作证明计数器多难。
- en: this specific block B in comparison to the difficulty of a genesis block.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的区块B相对于创世区块的难度。
- en: '*Genesis*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*创世区块*'
- en: ( 216)×2562)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ( 216)×2562)
- en: '*block’s difficulty* *target* ='
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*区块的难度* *目标* ='
- en: '*B’s difficulty target*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*B的难度目标*'
- en: '*B’s difficulty target*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*B的难度目标*'
- en: We can say that the accumulated proof of work for a chain is the sum of the
    difficulty
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，链的累积工作证明是困难的总和
- en: of all blocks in the chain. The chain that has most proof of work behind it
    will be chosen for a new block to be appended.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 链中所有区块的总工作量。拥有最多工作量的链将被选中附加新的区块。
- en: the longest chain rule was originally simply the chain with the highest number
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最初最长链的规则只是简单地拥有最高数目的链
- en: of blocks. however, this simple rule was modified later, and the “longest” chain
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 区块。然而，这个简单规则后来被修改，“最长”的链
- en: became the chain with the most work done to create it, that is, the strongest
    chain.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 成为创建它工作量最多的链，也就是最强的链。
- en: In practice, there is a *chainwork* value in the block which helps to identify
    the chain with the most work, that is, the correct “longest” or “strongest” chain.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，在区块中存在一个*链工作*值，有助于确定具有最多工作量的链，也就是正确的“最长”或“最强”的链。
- en: For example, we use
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用
- en: bitcoin-cli getblockheader
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: bitcoin-cli getblockheader
- en: 0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003
- en: For block 687731, we get
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于区块687731，我们得到
- en: '242'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '242'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '{'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"result": {'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '"result": {'
- en: '"hash":'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '"hash":'
- en: '"0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003",'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '"0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003"，'
- en: '"confirmations": 1,'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '"confirmations": 1,'
- en: '"height": 687731,'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"height": 687731，'
- en: '"version": 547356676,'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"version": 547356676，'
- en: '"versionHex": "20a00004",'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '"versionHex": "20a00004",'
- en: '"merkleroot":'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"merkleroot":'
- en: '"73f4a59b854ed2d6597b56e6bc499a7e0b8651376e63e0825dbcca3b9dde61ae",'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"73f4a59b854ed2d6597b56e6bc499a7e0b8651376e63e0825dbcca3b9dde61ae"，'
- en: '"time": 1623786185,'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '"time": 1623786185,'
- en: '"mediantime": 1623781371,'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '"mediantime": 1623781371,'
- en: '"nonce": 2840970250,'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"nonce": 2840970250,'
- en: '"bits": "170e1ef9",'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '"bits": "170e1ef9",'
- en: '"difficulty": 19932791027262.74,'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"difficulty": 19932791027262.74,'
- en: '**"chainwork": "00000000000000000000000000000000000000001eb7091803**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**"chainwork": "00000000000000000000000000000000000000001eb7091803** '
- en: '**0b922df7533fd4",**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b922df7533fd4",**'
- en: '"nTx": 2722,'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '"nTx": 2722,'
- en: '"previousblockhash":'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '"previousblockhash":'
- en: '"00000000000000000000f341e0046c6d82979fdfa09ab324a0e8ffbabd22815d"'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '"00000000000000000000f341e0046c6d82979fdfa09ab324a0e8ffbabd22815d"'
- en: '},'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"error": null,'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '"error": null,'
- en: '"id": null'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": null'
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Notice the chainwork value when converted to a decimal results in an extremely
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意将链工作值转换为十进制后，结果是一个极端的大数，6663869462529529036756\. 而且可以看出，这个数是链头部的工作量背后的数量
- en: large number, 6663869462529529036756\. This is the amount of work behind this
    head of
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 大的数字，6663869462529529036756\. 这是这个头的工作量背后的数量
- en: the chain.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 链。
- en: 'There are several types of forks that can occur in the Bitcoin blockchain:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链中可能发生几种类型的分叉：
- en: • Regular fork
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: • 常规分叉
- en: • Hard fork
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: • 硬分叉
- en: • Soft fork
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: • 软分叉
- en: • Byzantine fork
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: • 拜占庭式分叉
- en: '243'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '243'
- en: '![](index-261_1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](index-261_1.png)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Regular fork**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规分叉**'
- en: A fork can naturally occur in the Bitcoin blockchain when two miners competing
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个竞争的矿工在同一时间内解决了作为解决证明工作巧合地几乎同时解决了它。因此，两个矿工矿工在同一时间内解决了作为解决证明工作巧合地几乎同时解决了它。因此，两个矿工可能会出现在比特币区块链中自然分叉
- en: to solve the proof of work happen to solve it almost at the same time. As a
    result, two
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 解决证明工作巧合地几乎同时解决了它。因此，两个
- en: new blocks are added to the blockchain. Miners will keep working on the longest
    chain
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 新的区块被添加到区块链。矿工将继续在最长的链上工作
- en: that they are aware of, and soon the shorter chain with so-called orphan blocks
    will be
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所知道的，很快，较短的链和所谓的孤立区块将
- en: ignored.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略。
- en: The diagram in Figur[e 5-10](#p261) shows how consensus finality is impacted
    by forks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-10中的图表显示了分叉对共识最终性的影响。
- en: '***Figure 5-10\.** Impact of forking on consensus finality*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 5-10\.** 叉分对共识最终性的影响*'
- en: Due to the forking possibility, consensus is probabilistic. When the fork is
    resolved,
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能出现分叉，共识是概率性的。当分叉解决时，
- en: previously accepted transactions are rolled back, and the longest (strongest)
    chain
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 先前接受的交易将被回滚，最长（最强）的链
- en: prevails.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 占优势。
- en: The probability of these regular forks is quite low. A split of one block can
    occur
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常规分叉的概率非常低。一个区块的分裂可能会发生。
- en: almost every two weeks and is quickly resolved when the next block arrives,
    referring
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每两周一次，并且在下一个区块到达时迅速解决，并提及
- en: to the previous one as a parent. The probability of occurrence of a two-block
    split is
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到先前的一个作为父级。两个区块分裂的概率是
- en: exponentially lower, which is almost once in 90 years. The probability of occurrence
    of a four-block temporary fork is once in almost 700,000,000 years.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 指数级降低，几乎是90年一次。四个区块的临时分叉发生的概率几乎是每7亿年一次。
- en: '**Hard fork**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬分叉**'
- en: A hard fork occurs due to changes in the protocol, which are incompatible with
    the
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 硬分叉是由于协议的更改而发生的，这些更改与
- en: existing rules. This essentially creates two chains, one running on the old
    rules and the new one on new rules.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现有规则。这实际上创建了两条链，一条在旧规则上运行，另一条在新规则上运行。
- en: We can visualize how a hard fork behaves in Figur[e 5-11\.](#p262)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图[5-11\.](#p262)中看到硬分叉的行为。
- en: '244'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '244'
- en: '![](index-262_1.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](index-262_1.png)'
- en: '![](index-262_2.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](index-262_2.png)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '***Figure 5-11\.** Hard fork*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 5-11\.** 硬分叉*'
- en: '**Soft fork**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**软分叉**'
- en: A soft fork occurs when changes in the protocol are backward compatible. It
    means
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当协议的更改是向后兼容时会发生软分叉。这意味着
- en: that there is no need to update all the clients; even if not all the clients
    are upgraded, the chain is still one. However, any clients that do not upgrade
    won’t be able to operate using the new rules. In other words, old clients will
    still be able to accept the new blocks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要更新所有客户端；即使不是所有客户端都升级，链仍然是一个。但是，任何不升级的客户端将无法使用新规则运行。换句话说，旧客户端仍然能够接受新的区块。
- en: This concept can be visualized in the diagram in Figure [5-12\.](#p262)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以在图[5-12\.](#p262)的图表中看到。
- en: '***Figure 5-12\.** Soft fork*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 5-12\.** 软分叉*'
- en: '245'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '245'
- en: '![](index-263_1.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](index-263_1.png)'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Byzantine fork**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭分叉**'
- en: A Byzantine fork or malicious fork can occur in scenarios where an adversary
    may try
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌对者可能尝试的情景中，拜占庭分叉或恶意分叉可能会发生。
- en: to create a new chain and succeeds in imposing its own version of the chain.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的链条，并成功地强加自己的链条版本。
- en: With this, we complete our discussion on forks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们完成了对分叉的讨论。
- en: A core feature of proof of work consensus is the Sybil resistance mechanism
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明共识的核心特性是Sybil抵抗机制
- en: which ensures that creating many new identities and using them is prohibitively
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其中确保创建许多新身份并使用它们成本高昂
- en: computationally complex. Let’s explore this concept in more detail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 计算上复杂。让我们更详细地探讨这个概念。
- en: '**Sybil Resistance**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sybil抵抗**'
- en: A Sybil attack occurs when an attacker creates multiple identities, all belonging
    to them to subvert the network relying on voting by using all those identities
    to cast vote in
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者创建多个身份并通过使用所有这些身份来投票来破坏依赖投票的网络时，Sybil攻击就会发生
- en: their favor. Imagine if an attacker creates more nodes than the entire network,
    then the
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的利益。想象一下，如果攻击者创建的节点比整个网络的节点还多，那么
- en: attacker can skew the network in their favor.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以倾斜网络以使之有利。
- en: A Sybil attack can be visualized in Figure [5-13](#p263), where an attacker
    is controlling more Sybil nodes than the network.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Sybil攻击可以在图[5-13](#p263)中看到，攻击者控制的Sybil节点比网络更多。
- en: '***Figure 5-13\.** Sybil attack*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 5-13\.** Sybil攻击*'
- en: Proof of work makes it prohibitively expensive for an attacker to use multiple
    nodes
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明使攻击者使用多个节点变得代价高昂
- en: controlled by them to participate in the network because each node will have
    to do
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由他们控制，以便参与网络，因为每个节点都必须进行
- en: computationally complex work in order to be part of the network. Therefore,
    an attacker
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为网络的一部分，需要复杂的计算工作。因此，攻击者
- en: controlling a large number of nodes will not be able to influence the network.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 控制大量节点的攻击者将无法影响网络。
- en: '246'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '246'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: '**Significance of Block Timestamp**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块时间戳的重要性**'
- en: The Bitcoin network with its heterogenous geographically dispersed nodes running
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络及其异分布式的地理分布节点在
- en: on the Internet appears to be an asynchronous network. This appears to be the
    case
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上表现为异步网络。这似乎就是情况
- en: because there is no upper bound on the processor speeds and no upper bound on
    the
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为处理器速度没有上限，通信延迟也没有上限。
- en: message delay. Usually, in traditional BFT consensus protocols, there is no
    reliance on
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 消息延迟。通常，在传统的BFT共识协议中，不依赖于
- en: a global physical clock, and network assumptions are usually partially synchronous
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 全球物理时钟，网络假设通常是部分同步的
- en: networks. However, in Bitcoin all blocks have a timestamp field, which is populated
    by
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。然而，在比特币中所有区块都有一个时间戳字段，由
- en: the local node which mined the block. This is part of the block validation process
    where
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘出区块的本地节点。这是区块验证流程的一部分，在这个过程中
- en: a block is accepted only if its timestamp is less than or equal to the median
    of the last 11
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块只有其时间戳小于或等于最近11个区块的中值时才会被接受
- en: blocks. Also, timestamps are vital for maintaining block frequency, difficulty
    retargeting, and network difficulty calculations. From this point of view, we
    can think of the Bitcoin network as loosely synchronous, where loose clock synchrony
    is required for the network
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 区块。此外，时间戳对于维护区块频率、难度重新定位和网络难度计算至关重要。从这一观点出发，我们可以将比特币网络看作是松散同步的，其中松散的时钟同步对于网络
- en: to make progress and ensure liveness.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以实现进展并确保活跃性。
- en: Note that the Bitcoin network is not partially synchronous because we defined
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，比特币网络不是部分同步的，因为我们定义
- en: partially synchronous and its variations earlier, and the Bitcoin network doesn’t
    seem to fit in any of those definitions. It is synchronous in the sense that blocks
    have a timestamp generated from the local node on which the block was produced;
    however, from a
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步及其变体，而比特币网络似乎不符合这些定义。它在区块的时间戳是从产生该区块的本地节点上生成的意义上是同步的；然而，从一个角度来看
- en: processor delay perspective, it is almost asynchronous. Also, in the block validation
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器延迟的角度来看，它几乎是异步的。此外，在区块验证
- en: mechanism, one of the rules requires that a block is produced within roughly
    the last
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 机制，其中规则之一要求区块在近期内生成；
- en: two hours (median of the previous 11 blocks), making Bitcoin an “almost synchronous”
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 两小时（前11个区块的中值），使Bitcoin成为“几乎同步”
- en: system. This is so because timestamps are essential for the proper functioning
    of the
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。这是因为时间戳对于系统
- en: Bitcoin system; however, due to large communication and processor delay tolerance,
    it
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Bitcoin系统；但由于大通信和处理器延迟容忍度，它
- en: can be thought of as a loosely synchronous system.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被看作是一个松散同步的系统。
- en: On the other hand, as timestamps are required only for proper functioning of
    the
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于时间戳仅用于适当功能的
- en: limited part of the system, that is, the difficulty calculations, and block
    validation and are not a requirement for achieving consensus (i.e., by choosing
    a leader by solving
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的有限部分，即难度计算和区块验证并不是实现共识的必要条件（即选择一个领导者来解决
- en: proof of work – mining), then from that point of view it is an asynchronous
    system, given that processor and communication delays have no defined upper bounds,
    except that
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明 - 挖矿），然后从这个角度来看它是一个异步系统，因为处理器和通信延迟没有定义的上界，除了
- en: messages will reach nodes eventually with a probabilistic guarantee of a gossip
    protocol.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 消息最终会以概率保证的八卦协议到达节点。
- en: In Bitcoin blocks, timestamps are not 100% accurate but enough to secure the
    proof
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币的区块中，时间戳并非100%准确，但足够保护证明
- en: of work mechanism. Originally, Satoshi envisioned a combination of a system
    clock, a
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 工作机制。最初，中本聪设想将系统时钟与
- en: median of other servers’ clocks, and NTP servers for clock adjustment. However,
    NTP
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 其他服务器时钟的中值，并且NTP服务器用于时钟调整。但是，NTP
- en: was never implemented, and the median of other nodes’ clock remained as the
    primary
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从未实现，并且其他节点时钟的中值仍然是主要的
- en: source for clock adjustment in the network.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟调整的来源。
- en: '247'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '247'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: Block timestamps not only serve to provide some variation for the block hash,
    which
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 区块时间戳不仅用于为区块哈希提供一些变化
- en: is useful in proof of work, but also helps to protect against blockchain manipulation
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对工作证明有用，但也有助于防止区块链操纵
- en: where an adversary could try to inject an invalid block in the chain. When a
    Bitcoin node connects to another node, it receives the timestamp in UTC format
    from it. The receiving
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对手可能会尝试向链中插入一个无效的块。 当比特币节点连接到另一个节点时，它从中接收了UTC格式的时间戳。 接收
- en: node then calculates the offset of the received time from the local system clock
    and
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 节点然后计算接收时间与本地系统时钟的偏移
- en: stores it. The network adjusted time is then calculated as the local UTC system
    clock plus the median offset from all connected nodes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 存储它。 网络调整时间然后被计算为本地UTC系统时钟加上所有连接节点的中位偏移。
- en: There are two rules regarding timestamps in Bitcoin blocks. A valid timestamp
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关比特币区块的时间戳有两条规则。 有效的时间戳
- en: must be greater than the median timestamp of the previous 11 blocks. It should
    also
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 必须大于前11个块的中位时间戳。 它还应该
- en: be less than the median timestamp calculated based on the time received from
    other
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 必须小于基于其他人接收的时间计算的中位时间戳
- en: connected nodes (i.e., network adjusted time) plus two hours. However, this
    network
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 连接节点（即，网络调整时间）加上两个小时。 但是，这个网络
- en: time adjustment must never be more than 70 minutes from the local system clock.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 时间调整永远不能超过本地系统时钟的70分钟。
- en: The conclusion is that Bitcoin is in fact secure only under a synchronous network
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，比特币实际上只在同步网络下是安全的。
- en: model. More precisely, it is a lockstep-free synchrony where there exists some
    known
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 模型。 更确切地说，它是一种无步步同步，存在某些已知的
- en: finite time bound, but execution is not in lockstep.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有限的时间边界，但执行不是同步的。
- en: '**A Caveat**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个警告**'
- en: The order of transaction is not consensus driven. Each miner picks up a transaction
    in
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 交易顺序不是由共识驱动的。 每个矿工都会选择一笔交易
- en: a hardcoded order within the client, and indeed there have been some attacks
    that can
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端内部硬编码顺序，事实上有一些可能会受到攻击
- en: result in transaction censorship or ignoring or reordering. Consensus is achieved
    in fact on the block, and that is also not through voting; once a miner has solved
    PoW, it just
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 导致交易审查或忽视或重新排序。 事实上，共识是在区块上实现的，也不是通过投票; 一旦矿工解决了PoW，它就
- en: simply wins the right to append a new block to the chain. Of course, it will
    be validated by other nodes when they receive it, but there is no real agreement
    or voting mechanism
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 只是赢得了附加新块的权利。 当然，当他们接收到时，它将被其他节点验证，但是没有真正的协议或投票机制
- en: after the mined block has been broadcast by the successful miner. There is no
    voting
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘成功后广播了挖掘的区块。 没有投票
- en: or consensus which agrees on this new block; the miner who is the elected leader
    and
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 或共识同意此新块; 被选举为领导者的矿工和
- en: because they solved PoW has won the right to add a new block. Other nodes just
    accept
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因为他们解决了PoW才赢得了添加新块的权利。 其他节点只是接受
- en: it if it passes the *valid()* predicate.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它通过了*有效()*断言。
- en: So, the caveat here is that when a candidate block is created by picking up
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的警告是，当候选块被捡起创建时
- en: transactions from the transaction pool, they are picked up in a certain order
    which a
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从交易池挑选的交易，它们按照一定的顺序
- en: miner can influence. For example, some miners may choose not to include transactions
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工可以影响。 例如，一些矿工可能选择不包括交易。
- en: without any fee and only include those which are paying fee. Fair for the miner
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 无需费用，只包括支付费用的交易。 矿工公平
- en: perhaps, but unfair for the user and the overall Bitcoin system! However, eventually
    all
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或许，但对用户和整个比特币系统不公平！ 但是，最终所有交易都将被
- en: transactions will be added, even those without a fee, but they might be considered
    only
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 交易将被添加，甚至没有费用的交易，但它们可能只被考虑
- en: after some considerable time has elapsed since their inclusion in the transaction
    pool.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 自它们包括在交易池中以来已经过了相当长的时间。
- en: If they’ve aged, then they’ll be eventually included. Moreover, under the assumption
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们太老了，那么它们最终将被包括。 此外，在假设下
- en: '248'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '248'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章区块链共识
- en: that usually there is a majority of honest miners always in the network, the
    transactions are expected to be picked up in a reasonable amount of time in line
    with the protocol
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有大多数诚实的矿工总是在网络中，预计交易将在与协议相一致的合理时间内被接受
- en: specification.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 规范。
- en: Let us now see what is that order.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看那个顺序。
- en: The transactions are picked up from the transaction pool based on its priority,
    which
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是基于其优先级从交易池中挑选的，这
- en: 'is calculated using the following formula [8]:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下公式计算[8]：
- en: '*sum*( *input value in base*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum*（*基础输入值*'
- en: '*units*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*单位*'
- en: × *input age*)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: × *输入年龄*)
- en: '*priority* ='
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先级* ='
- en: '*size in by*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*大小由*'
- en: '*ttes*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*ttes*'
- en: Σ( *v* × )
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Σ（* v * × ）
- en: '*i*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*'
- en: '*a*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*'
- en: '*p*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*'
- en: '*i*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*'
- en: '='
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '*s*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*'
- en: It is of concern that the ordering of transactions is not fair and leads to
    front running and other relevant attacks. We will discuss fair ordering in Chapter
    [10](https://doi.org/10.1007/978-1-4842-8179-6_10).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 关于交易排序不公平，导致抢先和其他相关攻击，这是一个值得关注的问题。我们将在第[10](https://doi.org/10.1007/978-1-4842-8179-6_10)章讨论公平排序。
- en: '**PoW As a Solution to Byzantine Generals Problem**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作证明作为拜占庭将军问题的解决方案**'
- en: This has been described by Satoshi Nakamoto himself in a post [5]. I will describe
    the
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经被中本聪本人在一篇文章[5]中描述过。我将描述
- en: logic here in a concise way.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁地表达这里的逻辑。
- en: Remember in the Byzantine generals problem, the problem is to agree on an attack
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在拜占庭将军问题中要记住，问题是要达成一致的攻击时间
- en: time in the presence of treacherous generals and the possibility of captured
    messengers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在拜占庭将军的存在和被捕信使的可能性下推迟
- en: In the case of proof of work, we can consider miners as generals where the understanding
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作证明的情况下，我们可以将矿工视为将军，而他们的理解是
- en: between generals is that any general can announce the attack time and the attack
    time
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将军之间的是，任何将军都可以宣布攻击时间和攻击时间
- en: heard first is accepted as the authoritative time to attack. The problem however
    is that
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先被接受为权威的攻击时间。然而，问题在于
- en: if two generals propose different times almost simultaneously, it could happen
    due to
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两位将军几乎同时提议不同的时间，这可能是由于
- en: messaging delays where some generals receive one of the attack times first,
    and some
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 传递延迟，有些将军首先收到其中一个攻击时间，另一些
- en: others receive the other attack time first, resulting in disagreement. In order
    to solve this problem, each general who receives an attack time starts to solve
    a complex math puzzle.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 其它收到另一个攻击时间，导致不一致。为了解决这个问题，每个收到攻击时间的将军开始解决一个复杂的数学难题。
- en: When a general solves this math puzzle (proof of work), it broadcasts that to
    the network.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个将军解决了这个数学难题（工作证明），他就会将其广播给网络。
- en: When other generals receive it, they switch to this new time.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他将军收到它时，他们切换到这个新时间。
- en: All generals are allowed to propose a time, but only one of the proposed times
    will
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 所有将军都可以提议一个时间，但只有一个提议的时间会
- en: eventually be accepted as valid by all generals.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最终被所有将军接受为有效。
- en: For a proposed time to be valid, the condition is that each general must solve
    a
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提议的时间要有效，条件是每个将军必须解决一个
- en: mathematical puzzle and attach it with the proposed time message; if other generals
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 数学难题并将其附加到提议的时间消息上；如果其他将军
- en: receive this message and see that the solution to the math puzzle is valid,
    they accept
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接收此消息并查看数学难题的解决方案是有效的时候，他们接受
- en: '249'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '249'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章区块链共识
- en: that time. This mathematical puzzle serves two purposes; first, it is a proof
    that the
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 那个时间。这个数学难题有两个目的；首先，它证明了
- en: general is honest as they have solved the math puzzle, and, second, it stops
    the generals from proposing too many times in quick succession, which will result
    in disagreement
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将军是诚实的，因为他们解决了数学难题，并且第二，在短时间内不允许将军提议过多次数，这将导致不一致
- en: and confusion between the generals. We can see that this mechanism can be seen
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 和将军之间的混淆。我们可以看到这种机制可以被视为
- en: as a solution to the Byzantine generals problem; however, with a compromise,
    that
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对拜占庭将军问题的解决方案；然而，通过妥协，那
- en: temporary disagreement is acceptable.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时的不一致是可以接受的。
- en: Bitcoin poW is a probabilistic consensus algorithm. the big question now arises
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币PoW是一种概率共识算法。现在产生一个重要问题
- en: whether deterministic consensus can be achieved when the number of nodes is
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点数
- en: unknown and in the presence of Byzantine nodes.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 未知的，存在拜占庭节点。
- en: Now let’s revisit the validity, agreement, and termination properties defined
    at the
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新审视在
- en: start of this chapter in the light of what we have learned so far about the
    proof of work algorithm.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们到目前为止对工作证明算法的学习，在这一章的开头。
- en: We can see clearly now that PoW is not a classical deterministic Byzantine consensus
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以清楚地看到，PoW不是一个传统的确定性拜占庭共识
- en: algorithm. It is a protocol with probabilistic properties.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 算法。这是一个具有概率性质的协议。
- en: Let’s revisit the properties now.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新讨论这些属性。
- en: '**Agreement**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**'
- en: An agreement property is probabilistic. This is the case because it can happen
    that two
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性属性是概率性的。这是因为可能出现两个
- en: different miners produce a valid block almost simultaneously, and some nodes
    add a
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的矿工几乎同时生成一个有效的区块，一些节点添加一个
- en: block from one miner and some other nodes from another. Eventually, however,
    the
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个矿工和另一些节点中阻止区块。然而，最终
- en: longest (strongest) chain rule will ensure that the chain with less proof of
    work behind
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最长（最强）链规则将确保具有较少工作量证明的链
- en: it is pruned and the longest chain prevails. This will result in previously
    accepted
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 它被修剪，最长的链胜出。这将导致先前被接受的
- en: transactions to be rolled back; thus, the agreement is probabilistic.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 可以回滚交易; 因此，协议是有概率的。
- en: '**Validity – Predicate Based**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效性 - 谓词为基础**'
- en: This is a deterministic property agreement where honest nodes only accept those
    blocks
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种确定性属性协议，诚实的节点只接受那些区块
- en: which are valid. Formally, we can say that if a correct process p eventually
    decides on b, then v must satisfy the application-specific valid() predicate.
    We discussed the validity predicate, that is, the block validation criteria, in
    detail earlier in the chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是有效的。严格来说，我们可以说，如果一个正确的进程p最终决定了b，则v必须满足应用特定的valid()谓词。我们之前在本章详细讨论了有效性谓词，即区块验证标准。
- en: '250'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第五章 区块链共识
- en: '**Termination**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止**'
- en: Termination is a probabilistic property. It is only achieved eventually due
    to the possibility of natural forks. This is because in the case of forks, the
    fork must be resolved in order to finally terminate a consensus process on the
    block. As there is a possibility that a previously accepted block is rolled back
    in favor of the heaviest/longest chain, the termination can only be guaranteed
    probabilistically. Usually, in order to ensure with high probability
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 终止是一个有概率的属性。由于天然叉，它最终得以实现但没有保障。这是因为在叉的情况下，必须解决叉才能最终终止区块上的共识过程。由于有可能先前接受的区块被回滚，以获得最重/最长的链，终止只能以概率方式保证。通常，为了高概率保障
- en: the finality of the transactions, in practice six confirmations are traditionally
    required.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中传统上需要六次确认才能保证交易已完成。
- en: This means that the block is at least six blocks deeper in the chain, which
    means that the possibility of a rollback is so low that it can never happen or
    happen once in a millennia.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该区块至少在链条中深入了六个区块，这意味着回滚的可能性如此之低，几乎不可能发生或发生在千年一次。
- en: With this, we complete our discussion on proof of work.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们就完成了对工作量证明的讨论。
- en: '**PoW Concerns**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoW问题**'
- en: There are several concerns regarding PoW, including attacks and extreme energy
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PoW存在几个问题，包括攻击和极端的能源
- en: consumption.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗。
- en: In the next section, we discuss some of the attacks that can be carried out
    against the
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论一些可以针对
- en: proof of work consensus, which adversely affects the Bitcoin network.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明共识，这对比特币网络产生不利影响。
- en: '**51% Attack**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**51%攻击**'
- en: A 51% attack on Bitcoin can occur when more than 50% of the mining hash power
    is
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币上的51%攻击可能发生在超过50%的挖矿哈希功率
- en: controlled by an adversary.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 被对手控制。
- en: Table [5-3](#p268) shows a list of actions that an adversary can possibly try
    to take after taking over more than 50% hash power of the network.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 表格[5-3](#p268)显示了对手在接管网络的50%以上哈希功率后可能尝试采取的行动列表。
- en: '***Table 5-3\.** List of actions by adversary*'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '***表格 5-3\.** 对手的行动列表*'
- en: '**Attack**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击**'
- en: '**Possibility**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能性**'
- en: '**Explanation**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释**'
- en: Censor transactions
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止交易
- en: 'Yes'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: Can ignore transactions
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 可以忽略交易
- en: Coin stealing
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 窃取硬币
- en: 'no'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Controlled by a private key
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由私钥控制
- en: Double-spend
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 双重支付
- en: 'Yes'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: Can create a private off-chain fork and exclude the block
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个私有的离线分支并排除该区块
- en: which contains previously spent transaction
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 包含先前已花费的交易
- en: Change protocol
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 更改协议
- en: 'no'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: a protocol cannot be changed as valid nodes will simply
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 一个协议无法更改，因为有效节点将简单地
- en: ignore the invalid blocks
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略无效区块
- en: '251'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第五章 区块链共识
- en: Note that some attacks are still impossible, while the most detrimental to a
    system
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些攻击仍然是不可能的，而对系统最有害的
- en: are possible, such as double-spend.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 是可能的，比如双重花费。
- en: '**Selfish Mining**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**自私挖矿**'
- en: This type of attack occurs when a miner who has found a block keeps it a secret
    instead
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个找到一个区块的矿工保密，而不是公开宣布时，就会发生这种类型的攻击
- en: of announcing it and keeps building on top of it privately. Imagine the attacker
    has
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 宣布并私下继续构建。想象一下攻击者有
- en: managed to create another block. Now the attacker has two blocks in their private
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 设法创建另一个区块。现在攻击者在他们自己的私人里有两个区块
- en: forked chain. At this point, the attacker waits for someone else to find a block.
    When
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉链。在这一点上，攻击者等待其他人找到一个区块。当
- en: the attacker sees this new block, they release their two-block chain. Because
    other
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者看到这个新区块，他们释放他们的双块链。因为其他
- en: miners are honest and abiding by the longest chain rule, they will accept this
    new chain
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工是诚实的，并遵守最长链规则，他们将接受这个新链
- en: being the longest. Now the block that was mined by someone else is orphaned
    despite
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 成为最长的。现在，其他人挖掘的区块将变为孤块，尽管
- en: spending resources on it, but that work is wasted. The attacker could also wait
    for a
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在它上花费资源，但这些工作都是浪费的。攻击者也可以等待一个
- en: longer chain to be created, albeit mostly by luck, but if the attacker manages
    to create
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更长的链条，尽管主要是靠运气，但如果攻击者设法创建
- en: such a private fork which is longer than the honest chain, then the attacker
    can release
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个比诚实链更长的私有分支，那么攻击者可以释放
- en: that as soon as some other block is announced. Now when the nodes see this new
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 只要其他区块一旦宣布。现在当节点看到这个新的
- en: longest chain, according to the rules, they will start mining on top of this
    new longer
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最长的链，根据规则，他们将开始在这个新的更长上进行挖掘
- en: chain and orphaning the other chains, which could just be one block shorter
    than the
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 链条并雏形其他链条，这可能只比
- en: attacker’s chain. All the work that has gone into creating the honest chain
    is now wasted, and the attacker gets the rewards, instead of other miners who
    did the work on the
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的链。所有为创建诚实链所做的工作现在都被浪费掉，并且攻击者获得奖励，而不是其他矿工为此工作的奖励
- en: honest chain.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实链。
- en: '**Race Attack**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞赛攻击**'
- en: This attack can occur in a situation where the adversary can make a payment
    to one
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击可能发生在对手能够向其中一方进行支付时
- en: beneficiary and then a second one to themselves or someone else. Now if the
    first
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 受益人，然后是支付给自己或其他人的第二个。现在，如果第一
- en: payment is accepted by the recipient after zero confirmations, then it could
    happen that
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 接受者在零确认后接受付款，接下来可能发生的是
- en: the second transaction is mined and accepted in the next block, and the first
    transaction could remain unmined. As a result, the first recipient may never get
    their payment.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 第二笔交易被挖掘并在下一个区块中得到接受，而第一笔交易可能保持未被挖掘。因此，第一收款人可能永远得不到他们的付款。
- en: '**Finney Attack**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**芬尼攻击**'
- en: The Finney attack can occur when a recipient of a payment accepts the payment
    with
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 芬尼攻击会发生在一个支付的接受者接受支付的情况下
- en: zero confirmations. It is a type of double-spend attack where an attacker creates
    two
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 零确认。这是一种双花攻击类型，攻击者创建两个
- en: transactions. The first of these transactions is a payment to the recipient
    (victim) and
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 交易。其中的第一笔交易是支付给收款人（受害者），并
- en: the second to themselves. However, the attacker does not broadcast the first
    transaction; instead, they include the second transaction in a block and mine
    it. Now at this point,
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一笔交易广播给自己。然而，攻击者并不广播第一笔交易；相反，他们将第二笔交易包含在一个区块中并挖掘它。现在在这一点上，
- en: '252'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '252'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链共识第 5 章
- en: the attacker releases the first transaction and pays for the goods. The merchant
    does not wait here for the confirmations and accepts the payment. Now the attacker
    broadcasts
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者释放第一笔交易并支付货物。商家在这里不等待确认，接受支付。现在攻击者广播
- en: the premined block with the second transaction that pays to themselves. This
    invalidates
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 预挖的区块，带有第二笔交易支付给他们自己。这使
- en: the first transaction as the second transaction takes precedence over the first
    one.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第一笔交易作为第二笔交易优先于第一笔交易。
- en: '**Vector76 Attack**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector76 攻击**'
- en: This attack is a combination of Finney and race attacks. This attack is powerful
    enough to reverse a transaction even if it has one confirmation.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击是芬尼和竞赛攻击的结合体。这种攻击足以撤销一笔交易，即使它只有一次确认。
- en: '**Eclipse Attack**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**日食攻击**'
- en: This attack attempts to obscure a node’s correct view of the network, which
    can lead to
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此攻击试图模糊节点对网络的正确观点，这可能导致
- en: disruption to service, double-spend attacks, and waste of resources. There are
    several
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 服务中断，双花攻击和资源浪费。有几种
- en: solutions to fix the issue, which have been implemented in Bitcoin. More details
    can be
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的解决方案已经在比特币中实施。更多细节可
- en: 'found here: [https://cs-people.bu.edu/heilman/eclipse/.](https://cs-people.bu.edu/heilman/eclipse/)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处找到：[https://cs-people.bu.edu/heilman/eclipse/。](https://cs-people.bu.edu/heilman/eclipse/)
- en: '**ESG Impact**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESG 影响**'
- en: ESG metrics represent an overall picture of environmental, social, and governance
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ESG指标代表环境、社会和治理的整体情况
- en: concerns. These metrics are used as a measure to assess a company’s exposure
    to
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点。这些指标被用来评估公司对ESG风险的暴露
- en: environmental, social, and governance risks. They are used by investors to make
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 环境、社会和治理风险。投资者用于做出
- en: investment decisions. Investors may not invest where ESG risks are higher and
    may
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 投资决策。投资者可能不会投资风险更高的ESG，也可能
- en: prefer companies where ESG risk is low.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 更偏好ESG风险较低的公司。
- en: Proof of work has been criticized for consuming too much energy. It is true
    that
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明已被批评为能源消耗过大。的确
- en: currently at the time of writing, the total energy consumption of the Bitcoin
    blockchain is more than the entire country of Pakistan [9].
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在撰写本文时，比特币区块链的总能源消耗量超过巴基斯坦的整个国家 [9]。
- en: There are environmental, social, and governance concerns (ESG concerns) that
    have
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 环境、社会和治理问题（ESG问题）引起了关注。
- en: been the cause of low interest from savvy mainstream investors. Nonetheless,
    Bitcoin
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 已经成为聪明的主流投资者低迷的原因。尽管如此，比特币
- en: largely can be seen as a success despite its ESG concerns.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其ESG问题，但基本上被视为成功。
- en: Not only has Bitcoin been criticized for its high energy consumption but often
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币不仅因其高能耗而受到批评，而且经常
- en: seen as a vehicle for criminal activities, where Bitcoin has been accepted as
    a mode of
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 被视为犯罪活动的工具，比特币已被接受为支付方式
- en: payment for illicit drugs and other criminal activities.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 支付非法药品和其他犯罪活动。
- en: A centralization problem is also a concern where some powerful miners with mining
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 集中化问题也是一个担忧，一些强大的矿工拥有矿业
- en: farms take up most of the hash rate of the Bitcoin network. The ASICs that are
    used to
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 农场占据了比特币网络的大部分哈希率。用于
- en: build these mining farms are produced only by a few manufacturers, which means
    that
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 建造这些矿场的挖掘机仅由少数制造商生产，这意味着
- en: this is also a highly centralized space. Moreover, a crackdown [13] on Bitcoin
    mining
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个高度集中的空间。此外，对比特币挖矿的严厉打击
- en: '253'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '253'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: could also result in more centralization, where only the most powerful miners
    may
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 可能导致更多的集中化，只有最强大的矿工可能
- en: be able to withstand this crackdown and survive, resulting in only a few surviving
    and
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 能够承受这种严厉打击并生存下来，导致只有少数幸存者和
- en: powerful miners at the end.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，强大的矿工。
- en: There are however points in favor of Bitcoin. Bitcoin can be used as a cross-border
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有利于比特币的观点。比特币可以用作跨境
- en: remittance mechanism for migrant families. It can also be used as a mode of
    payment in
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 移民家庭的汇款机制。它也可以用作支付方式
- en: struggling economies. It can serve the unbanked population, which is estimated
    to be 1.7
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱困难的经济。可以为估计为17亿的无银行人口提供服务
- en: billion [12]. Bitcoin serves as a vehicle for financial inclusion.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以十亿计算。比特币是金融包容的工具。
- en: We could think of scenarios where the heat produced by Bitcoin mining farms
    may
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象比特币挖矿农场产生的热量可能
- en: be used to heat up water and eventually homes. Even electricity could be generated
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 用来加热水，最终加热家庭。甚至可以通过生成电力
- en: and fed back into the electricity grid by using thermoelectric generators due
    to
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过使用热电发电机将热量馈回电网
- en: thermoelectric effect. Of course, economics and engineering need to be worked
    out;
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 热电效应。当然，经济学和工程学需要进行细化；
- en: however, this idea can work.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个想法是可行的。
- en: '*Thermoelectric power generator, any of a class of solid-state devices that*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*热电发电机，一类固体状态器件*'
- en: '*either convert heat directly into electricity or transform electrical energy*'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以直接将热量转化为电能，或者转化电能*'
- en: '*into thermal power for heating or cooling. Such devices are based on ther-*'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '*成热能或冷却。这些设备基于热*'
- en: '*moelectric effects involving interactions between the flow of heat and of*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '*moelectric效应涉及热量流动和之间的相互作用*'
- en: '*electricity through solid bodies. [11]*'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过固态体产生电。[11]*'
- en: — *Encyclopaedia Britannica*, March 1, 2007, [www.britannica.com/](http://www.britannica.com/technology/thermoelectric-power-generator)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: — *大英百科全书*，2007年3月1日，[www.britannica.com/](http://www.britannica.com/technology/thermoelectric-power-generator)
- en: '[technology/thermoelectric-power-generator](http://www.britannica.com/technology/thermoelectric-power-generator)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[technology/thermoelectric-power-generator](http://www.britannica.com/technology/thermoelectric-power-generator)'
- en: Payment systems and in fact any system require electricity to run. Bitcoin is
    criticized
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 付款系统和实际上任何系统都需要电力运行。比特币受到批评
- en: of consuming too much energy; however, this is the price paid for the strength
    of the
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗过多的能源；然而，这是为了保持
- en: system. The network difficulty rate is so high now that even many attackers
    colluding
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。现在网络的难度已经非常之高，以至于许多攻击者即使合谋
- en: together won’t be able to generate enough hash power to launch a 51% attack.
    So yes,
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 结合在一起的矿工无法生成足够的哈希算力来发动 51% 攻击。所以是的，
- en: electricity is consumed, but in return there are benefits. In addition to the
    security of Bitcoin, there are other benefits such as
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗了电力，但换来的是好处。除了比特币的安全性外，还有其他好处，如
- en: • Bitcoin can be used in suppressed regimes.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: • 比特币可以在被压制的政权中使用。
- en: • Borderless payments.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: • 无国界支付。
- en: • Bank the unbanked.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: • 银行无银行。
- en: • Smooth cross-border remittance.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: • 流畅的跨境汇款。
- en: • Alternative payment system which doesn’t have any intermediary.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: • 没有任何中介的替代支付系统。
- en: • Payments without a middleman.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: • 无中间人的支付。
- en: '254'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '254'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 章 区块链共识
- en: In summary, Bitcoin, despite its energy consumption and not living up to its
    original
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，比特币，尽管其能源消耗并没有达到其最初的预期
- en: philosophy of One CPU = One Vote, still can be seen as a successful project
    with many
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CPU=一个选票的哲学思想，仍然被视为一个成功的项目，拥有许多
- en: benefits.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 好处。
- en: '**Variants of PoW**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoW的变体**'
- en: There are two types of proof of work algorithms depending on the hardware it
    is
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它所依赖的硬件，有两种工作证明算法
- en: 'intended to run on:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在运行的。
- en: • CPU-bound PoW
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: • CPU绑定PoW
- en: • Memory-bound PoW
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: • 内存绑定PoW
- en: '**CPU-Bound PoW**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU绑定PoW**'
- en: These puzzles run at the speed of the processor. CPU-bound PoW refers to a type
    of PoW
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这些难题以处理器的速度运行。CPU绑定PoW是指一种PoW的类型
- en: where the processing required to find the solution to the cryptographic hash
    puzzle is
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找加密哈希难题的解决方案所需的处理是
- en: directly proportional to the calculation speed of the CPU or hardware such as
    ASICs.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 与CPU或ASIC等硬件的计算速度成正比。
- en: Because ASICs have dominated Bitcoin PoW and provide somewhat undue advantage
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ASIC已主导比特币工作证明并带来了某种不公平的优势
- en: to the miners who can afford to use ASICs, this CPU-bound PoW is seen as shifting
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些能够负担得起使用ASIC的矿工来说，这种CPU绑定的PoW被视为转移
- en: toward centralization. Moreover, mining pools with extraordinary hash power
    can shift
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 朝着中心化的方向前进。此外，拥有非同寻常哈希算力的矿池可以转移
- en: the balance of power toward them. Therefore, memory-bound PoW algorithms have
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 权力的平衡向他们倾斜。因此，内存绑定的PoW算法有
- en: been introduced, which are ASIC resistant and are based on memory-oriented design
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 被引入，这些算法抗ASIC，并基于内存导向设计
- en: instead of CPU.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是CPU。
- en: '**Memory-Bound PoW**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存绑定PoW**'
- en: Memory-bound PoW algorithms rely on system RAM to provide PoW. Here, the
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '内存绑定PoW算法依赖系统RAM来提供PoW。在这里， '
- en: performance is bound by the access speed of the memory or the size of the memory.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 性能被内存访问速度或内存大小所限制。
- en: This reliance on memory also makes these PoW algorithms ASIC resistant. Equihash
    is
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对内存的依赖也使得这些PoW算法抗ASIC。Equihash 是
- en: one of the most prominent memory-bound PoW algorithms.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 最突出的内存绑定PoW算法之一。
- en: There are other improvements and variations of proof of work, which we will
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工作证明的改进和变体，我们将
- en: introduce in Chapter [8](https://doi.org/10.1007/978-1-4842-8179-6_8).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [8](https://doi.org/10.1007/978-1-4842-8179-6_8) 章中介绍。
- en: '255'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '255'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 章 区块链共识
- en: '**Summary**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: 'In this chapter, we covered blockchain consensus:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了区块链共识：
- en: • Proof of work is the first blockchain consensus introduced with
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: • 工作证明是首个引入的区块链共识，有
- en: Bitcoin, which is also a solution to the Byzantine generals problem.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币，也是拜占庭将军问题的解决方案。
- en: • Blockchain consensus can be divided into two categories, the
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块链共识可以分为两类，即
- en: Nakamoto consensus and the traditional BFT based.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 中本共识和传统的BFT。
- en: • Traditional BFT is deterministic, whereas Nakamoto consensus is
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: • 传统的BFT是确定性的，而中本共识是
- en: probabilistic.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有概率性的。
- en: • Proof of work in Bitcoin is a Sybil resistance mechanism, a double-
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: • 比特币中的工作证明是一种Sybil抵抗机制，双重-
- en: spending prevention mechanism, and a solution to the Byzantine
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 防止机制，并解决了拜占庭
- en: generals problem.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 将军问题的主导策略。
- en: • Proof of work can be seen in the light of game theory where the
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: • 工作证明可以被看作是博弈论的光明面，其中
- en: protocol is a Nash equilibrium, and the dominant strategy for all
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 协议是一种纳什均衡，并对所有
- en: players is to be honest.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家是诚实的。
- en: • Proof of work is effectively a Byzantine fault–tolerant protocol.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: • 工作证明实际上是拜占庭容错协议。
- en: • Proof of work is a state machine replication protocol where a mined
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: • 工作证明是一种状态机复制协议，其中有一个挖掘
- en: block is announced and replicated to other nodes via a gossip
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 块通过八卦通告向其他节点复制。
- en: protocol.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。
- en: • Proof of work consumes high energy, and there are ESG concerns;
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: • 工作证明消耗能源，存在ESG担忧；
- en: however, there are benefits as well.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一些好处。
- en: '**Bibliography**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: '1\. Proof of work originally introduced in: Cynthia Dwork and Moni'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 工作证明最初是在：Cynthia Dwork和Moni
- en: Naor. Pricing via processing or combatting junk mail. In Ernest
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Naor。定价通过处理或打击垃圾邮件。在欧内斯特
- en: F. Brickell, editor, Advances in Cryptology – CRYPTO ’92, 12th
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: F. Brickell，编辑，密码学的进展 - CRYPTO'92，第12
- en: Annual International Cryptology Conference, Santa Barbara,
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 年度国际密码学会议，圣塔巴巴拉，
- en: California, USA, August 16–20, 1992, Proceedings, volume
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 美国加利福尼亚州，1992年8月16日至20日，会议录，卷
- en: 740 of Lecture Notes in Computer Science, pages 139–147\.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学讲义，第740页，139–147页。
- en: Springer, 1992\.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 斯普林格，1992年。
- en: '256'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '256'
- en: Chapter 5 BloCkChain Consensus
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章 区块链共识
- en: 2\. Okun, Michael. Distributed computing among unacquainted
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. Okun，Michael。在不相识的人之间进行分布式计算
- en: processors in the presence of Byzantine failures. Hebrew
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在拜占庭失败的情况下，处理器。希伯来
- en: University of Jerusalem, 2005\.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 耶路撒冷希伯来大学，2005年。
- en: 3\. [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)
- en: 4\. [www.cs.yale.edu/publications/techreports/tr1332.pdf](http://www.cs.yale.edu/publications/techreports/tr1332.pdf)
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. [www.cs.yale.edu/publications/techreports/tr1332.pdf](http://www.cs.yale.edu/publications/techreports/tr1332.pdf)
- en: 5\. [https://satoshi.nakamotoinstitute.org/emails/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. [https://satoshi.nakamotoinstitute.org/emails/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)
- en: '[cryptography/11/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[cryptography/11/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)'
- en: 6\. [https://hal.inria.fr/hal-01445797/document](https://hal.inria.fr/hal-01445797/document)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. [https://hal.inria.fr/hal-01445797/document](https://hal.inria.fr/hal-01445797/document)
- en: 7\. These terms were first introduced in [https://eprint.iacr.](https://eprint.iacr.org/2014/765.pdf)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 这些术语首次出现在[https://eprint.iacr.](https://eprint.iacr.org/2014/765.pdf)
- en: '[org/2014/765.pdf](https://eprint.iacr.org/2014/765.pdf)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '[org/2014/765.pdf](https://eprint.iacr.org/2014/765.pdf)'
- en: 8\. [https://en.bitcoin.it/wiki/Miner_fees#Priority_](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. [https://en.bitcoin.it/wiki/Miner_fees#Priority_](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)
- en: '[transactions](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[transactions](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)'
- en: 9\. Digiconomist[:](https://digiconomist.net/bitcoin-energy-consumption/)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. Digiconomist[:](https://digiconomist.net/bitcoin-energy-consumption/)
- en: '[https://digiconomist.net/bitcoin-energy-](https://digiconomist.net/bitcoin-energy-consumption/)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://digiconomist.net/bitcoin-energy-](https://digiconomist.net/bitcoin-energy-consumption/)'
- en: '[consumption/](https://digiconomist.net/bitcoin-energy-consumption/)'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[consumption/](https://digiconomist.net/bitcoin-energy-consumption/)'
- en: 10\. [www.hashcash.org](http://www.hashcash.org)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. [www.hashcash.org](http://www.hashcash.org)
- en: 11\. Strohl, G. Ralph and Harpster, Joseph W. "Thermoelectric
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. Strohl, G. Ralph和Harpster, Joseph W. "热电
- en: power generator." Encyclopedia Britannica, Mar. 1, 2007,
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 发电机。英国百科全书，2007年3月1日
- en: '[www.britannica.com/technology/thermoelectric-power-](http://www.britannica.com/technology/thermoelectric-power-generator)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.britannica.com/technology/thermoelectric-power-](http://www.britannica.com/technology/thermoelectric-power-generator)'
- en: '[generator](http://www.britannica.com/technology/thermoelectric-power-generator).
    Accessed June 25, 2021\.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[generator](http://www.britannica.com/technology/thermoelectric-power-generator)。2021年6月25日访问。'
- en: 12\. [https://globalfindex.worldbank.org/sites/globalfindex/](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. [https://globalfindex.worldbank.org/sites/globalfindex/](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)
- en: '[files/chapters/2017%20Findex%20full%20report_](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[files/chapters/2017%20Findex%20full%20report_](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
- en: '[chapter2.pdf](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[chapter2.pdf](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
- en: 13\. [www.coindesk.com/bitcoin-slips-37k-china-](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 13\. [www.coindesk.com/bitcoin-slips-37k-china-](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)
- en: '[vicecrackdown-mining](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[vicecrackdown-mining](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)'
- en: 14\. Introduction to the Distributed Systems channel by Chris
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 14．由Chris介绍分布式系统频道
- en: 'Coloh[an: www.distributedsystemscourse.com](http://www.distributedsystemscourse.com)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 'Coloh[an: www.distributedsystemscourse.com](http://www.distributedsystemscourse.com)'
- en: '15\. Bitcoin blockchain consensus[: https://youtu.be/f1ZJPEKeTEY](https://youtu.be/f1ZJPEKeTEY)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '15．比特币区块链共识[: https://youtu.be/f1ZJPEKeTEY](https://youtu.be/f1ZJPEKeTEY)'
- en: '257'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '257'
- en: '**CHAPTER 6**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章**'
- en: '**Early Protocols**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**早期协议**'
- en: In this chapter, I introduce early protocols. First, we start with a background
    on
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我引入了早期的协议。首先，我们从分布式的背景开始
- en: distributed transactions and relevant protocols, such as the two-phase commit.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事务和相关协议，比如两阶段提交。
- en: After that, we’ll continue our journey, look at the agreement protocols, and
    conclude
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将继续我们的旅程，看看协议的达成，然后总结
- en: the chapter with some fundamental results in distributed computing. This chapter
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章的一些基本结果。这一章
- en: introduces early consensus algorithms such as those presented in the works of
    Lamport
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了早期的共识算法，比如Lamport的作品中提出的那些
- en: et al., Ben-Or et al., and Toueg et.al. It is helpful to understand these fundamental
    ideas before continuing our voyage toward more complex and modern protocols.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: et al., Ben-Or 等人，Toueg 等人。在我们继续向更复杂和现代的协议迈进之前，理解这些基本思想是有帮助的。
- en: '**Introduction**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**介绍**'
- en: In my view, the 1980s was the golden age for innovation and discovery in distributed
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，20世纪80年代是分布式计算创新和发现的黄金时代
- en: computing. Many fundamental problems, algorithms, and results such as the Byzantine
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 计算。许多基本问题、算法和结果，比如拜占庭
- en: generals problem, FLP impossibility result, partial synchrony, and techniques
    to
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 将军问题，FLP不可能结果，部分同步，和技术
- en: circumvent FLP impossibility were discovered during the late 1970s and 1980s.
    Starting
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代末和80年代发现了绕过FLP不可能性的早期协议。开始
- en: from Lamport’s phenomenal paper “Time, Clocks, and the Ordering of Events in
    a
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 从Lamport的杰出论文“时间、时钟和事件排序在一个
- en: Distributed System” to the Byzantine generals problem and then Schneider’s state
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统”到拜占庭将军问题，然后是 Schneider 的状态
- en: machine replication paper, one after another, there were most significant contributions
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 复制机器论文，一个接一个，都有最重要的贡献
- en: made to the consensus problem and generally in distributed computing.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 对共识问题以及分布式计算中的一般贡献的作出了。
- en: Consensus can be defined as a protocol for achieving agreement. A high-level
    list of
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 共识可以被定义为实现一致性的协议。一个高层次的列表
- en: major contributions is described as follows.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 主要贡献描述如下。
- en: In his seminal paper in 1978, “Time, Clocks, and Ordering of Events in a Distributed
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在他1978年的里程碑论文中，“分布式
- en: System”, Lamport described how to order events using synchronized clocks in
    the
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 系统”，Lamport描述了如何使用同步时钟对事件进行排序
- en: absence of faults. Then in 1980, the paper “Reaching Agreement in the Presence
    of
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在不存在故障的情况下，可以达成一致。然后在1980年，论文“在存在
- en: Faults” posed the question if agreement can be reached in an unreliable distributed
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 故障”提出了一个问题：在一个不可靠的分布式中是否能达成一致
- en: system. It was proven that agreement is achievable if the number of faulty nodes
    in a
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。已经证明，如果在一个
- en: distributed system is less than one-third of the total number of processes,
    i.e. n>=3f+1, where n is the number of total nodes and f is the number of faulty
    processors. In the
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 分布系统的节点数小于总节点数的三分之一，即 n>=3f+1，其中 n 是总节点数，f 是故障处理器数量。在
- en: paper “The Byzantine Generals Problem” in 1982, Lamport et al. showed that agreement
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 论文“拜占庭将军问题”中，Lamport 等人表明了一致性
- en: '259'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '259'
- en: © Imran Bashir 2022
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: © Imran Bashir 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_6](https://doi.org/10.1007/978-1-4842-8179-6_6#DOI)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: I. Bashir, *区块链共识*, [https://doi.org/10.1007/978-1-4842-8179-6_6](https://doi.org/10.1007/978-1-4842-8179-6_6#DOI)
- en: CHapTer 6 early proToCols
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: is solvable using oral messages if more than two-thirds of the generals are
    loyal. In 1982, the paper “The Byzantine generals strike again” by Danny Dolev
    showed that unanimity
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超过三分之二的将军忠诚，就可以用口头消息解决。1982年，Danny Dolev的论文“The Byzantine generals strike
    again”表明一致性
- en: is achievable if less than one-third of the total number of processors are faulty
    and more than one-half of the network’s connectivity is available.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总处理器数量的三分之一以下是有故障的，而网络连接的一半以上是可用的，一致性
- en: Unanimity is a requirement where if all initial values of the processes are
    the same,
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是一个要求，即如果所有进程的初始值都相同，
- en: say v, then all processes decide on that value v. This is strong unanimity.
    However,
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 说v，那么所有的进程都会决定采用那个值v。这是强的一致性。然而，
- en: a weaker variant called weak unanimity only requires this condition to hold
    if all
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 较弱的一致性称为弱一致性，只需要在所有情况下才需要满足这个条件
- en: processes are correct; in other words, no processes are faulty.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是正确的；换句话说，没有进程是有故障的。
- en: The paper also provided the first proof that the distributed system must have
    3 *f* + 1
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 论文还提供了第一个证明，即分布式系统必须具有3 *f* + 1
- en: nodes to tolerate *f* faults. However, the celebrated FLP result appeared a
    little later which proved that deterministic asynchronous consensus is not possible
    even if a single
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 节点容忍*f*故障。然而，稍后出现的备受赞誉的FLP结果证明了即使是一个
- en: process is crash faulty. FLP impossibility implies that safety and liveness
    of a consensus protocol cannot be guaranteed in an asynchronous network.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是崩溃故障。FLP的不可能性意味着在异步网络中无法保证一致性协议的安全性和活性。
- en: Lamport’s algorithm was for a synchronous setting and assumed that eventually
    all
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport的算法是针对同步环境的，假设最终所有
- en: the messages will be delivered. Moreover, it wasn’t fault tolerant because a
    single failure will halt the algorithm.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将被传递。而且，它并不是容错的，因为一个故障将会停止算法。
- en: After the FLP impossibility result appeared, attempts started to circumvent
    it and
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: FLP不可能结果出现后，人们开始尝试规避它
- en: solve the consensus problem nevertheless. The intuition behind circumventing
    FLP is to
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一致性问题。绕过FLP的直觉是
- en: relax some stricter requirements of timing and determinism.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 放松一些关于时间和决定性的更严格的要求。
- en: Ben-Or proposed the earliest algorithms to sacrifice some level of determinism
    to
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Ben-Or提出了最早的算法来牺牲某种程度的确定性
- en: circumvent FLP. As FLP impossibility implies that under asynchrony, there will
    always
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 角度绕过FLP。因为FLP的不可能性意味着在异步情况下，总会
- en: be an execution that does not terminate, one way of avoiding that is to try
    and make
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 可以存在一种不终止的执行，避免的一种方法是尝试让
- en: termination probabilistic. So that instead of deterministic termination, probabilistic
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 终止是概率的。所以，与确定性终止相比，概率性终止
- en: termination is used. The intuition behind these algorithms is to use the “common
    coin”
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 终止被使用。这些算法的直觉是使用“公共硬币”
- en: approach, where a process randomly chooses its values if it doesn’t receive
    messages
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，在这种方法中，如果一个进程没有收到消息，它会随机选择它的值
- en: from other nodes. In other words, a process is allowed to select a value to
    vote on if
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 其他节点。换句话说，如果一个进程被允许选择一个值进行投票，那么该值就可以
- en: it doesn’t receive a majority of votes on the value from the rest of the processes.
    This
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它没有从其他进程收到大多数投票的值。这
- en: means that eventually more than half of the nodes will end up voting for the
    same value.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着最终多于一半的节点将最终投票给相同的值。
- en: However, this algorithm’s communication complexity increases exponentially with
    the
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种算法的通信复杂度随着指数增长
- en: number of nodes. Later, another approach that achieved consensus in a fixed
    number
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 节点数。稍后，另一种方法在固定数量内实现了共识
- en: of rounds was proposed by Rabin. These proposals required 5 *f* + 1 and 10 *f*
    + 1 rounds, respectively, as compared to the 3 *f* + 1 lower bound commonly known
    today.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了由Rabin提出的轮数更多的提议。与今天普遍知晓的下界3 *f* + 1相比，这些提议分别需要5 *f* + 1和10 *f* + 1轮。
- en: '260'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '260'
- en: CHapTer 6 early proToCols
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: Consensus protocols that relax timing (synchrony) requirements aim to provide
    safety
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性协议，放松时间（同步）要求的目的是提供安全性
- en: under all circumstances and liveness only when the network is synchronous. A
    significant
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下保障，并且只能在网络同步时保障活性。一个重要
- en: breakthrough was the work of Dwork, Lynch, and Stockmeyer, which for the first
    time
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Dwork，Lynch和Stockmeyer的工作是一个重大突破，这是第一次
- en: introduced a more realistic idea of partial synchrony. This model is more practical
    as it captures how real distributed systems behave. More precisely, distributed
    systems can be asynchronous for arbitrary periods but will eventually return to
    synchrony long enough for the system
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了更加真实的部分同步的概念。这个模型更加实际，因为它捕捉到了真实分布式系统的行为。更准确地说，分布式系统可能在任意时间段是异步的，但最终会长时间地返回到同步状态，从而可以在所有情况下保证安全性，并且只有在网络同步时才能保证活性。
- en: to make a decision and terminate. This paper introduced various combinations
    of processor and network synchrony and asynchrony and proved the lower bounds
    for such scenarios.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 做出决定然后终止。该论文介绍了处理器和网络同步和异步的各种组合，并且证明了这些情景的下界。
- en: '**Note** We discussed partial synchrony in detail in Cha[pter 3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**我们在第3章详细讨论了部分同步。'
- en: Table [6-1](#p277) shows the summary of results from the DLS88 paper showing
    a minimum number of processors for which a fault-tolerant consensus protocol exists.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 表[6-1](#p277)显示了DLS88论文结果摘要，显示了存在容错共识协议的最小处理器数量。
- en: '***Table 6-1\.** Minimum number of processors for which a fault-tolerant consensus*'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '***表6-1.** 最小处理器数量，适用于容错共识*。'
- en: '*protocol exists*'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '*存在协议*'
- en: '**Type of Fault**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障类型**'
- en: '**Synchronous Asynchronous Partially Synch Comms and Processor**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步异步部分同步通信和处理器**'
- en: Fail-stop
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 失效停止
- en: f
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: Na
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: Na
- en: 2f + 1
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 2f + 1
- en: omission
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 遗漏
- en: f
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: Na
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: Na
- en: 2f + 1
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 2f + 1
- en: authenticated Byzantine f
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 认证的拜占庭 f
- en: Na
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: Na
- en: 3f + 1
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 3f + 1
- en: Byzantine
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭
- en: 3f + 1
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 3f + 1
- en: Na
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: Na
- en: 3f + 1
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 3f + 1
- en: This paper introduced the DLS algorithm which solved consensus under partial
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了解决部分共识的DLS算法，
- en: synchrony.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 同步。
- en: 'Some major results are listed as follows, starting from the 1980s:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的结果如下，从1980年代开始：
- en: • Lamport showed in LPS 82 that under a synchronous setting, n > 2f
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: • Lamport在LPS82中表明，在同步设置下，n > 2f
- en: with authentication and n > 3f are at least required with oral messages.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行身份验证，并且口头消息中至少需要 n > 3f。
- en: • The FLP result in 1982 showed that even with a single crash failure,
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: • 1982年的FLP结果表明，即使出现单个坠机故障，
- en: consensus is impossible under asynchrony, and at least n > 3f are
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步性条件下，共识是不可能的，至少需要 n > 3f。
- en: required for safety.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性所需。
- en: • Ben-Or in 1983 proposed a randomized solution under asynchrony.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: • 1983年Ben-Or在异步条件下提出了一个随机解决方案。
- en: Now let’s go through distributed transaction which is a major concept in distributed
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来了解一下分布式事务，这是分布式中的一个重要概念
- en: systems.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。
- en: '261'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '261'
- en: CHapTer 6 early proToCols
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: '**Distributed Transactions**'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式事务**'
- en: A distributed transaction is a sequence of events spread across multiple processes.
    A
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事务是分布在多个进程中的事件序列。一个
- en: transaction either concludes with a commit or abort. If committed, all events
    are executed, and the output is generated, and if aborted, the transaction halts
    without complete
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 事务要么以提交要么中止。如果提交，所有事件都会被执行，输出会生成，如果中止，事务将停止而没有完全
- en: execution. A transaction is atomic if it executes and commits fully; otherwise,
    it rolls back with no effect. In other words, atomic transactions either execute
    in full or not at all.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 执行。如果事务完全执行和提交，则事务是原子的；否则，它会滚回，没有任何影响。换句话说，原子事务要么完全执行，要么不执行。
- en: There are four properties that a transaction must satisfy, commonly known as
    the
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个事务必须满足的属性，通常称为
- en: 'ACID consistency model:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: ACID一致性模型：
- en: '• **Atomicity**: Either the transaction events fully execute or not at all.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: • **原子性**：事务事件要么完全执行，要么不执行。
- en: '• **Consistency**: If a transaction commits, it results in a valid'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: • **一致性**：如果一个事务提交，那么它会产生一个有效的
- en: (consistent) state of the system. It satisfies some invariants.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: （一致）系统的状态。它符合某些不变量。
- en: '• **Isolation**: Unless the transaction is committed, no effects are visible.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: • **隔离性**：除非事务提交，否则不会有影响可见。
- en: '• **Durability**: A transaction once committed has a permanent effect.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: • **持久性**：一旦提交的事务会产生永久的影响。
- en: One point to note here is that consistency is guaranteed much easily in monolithic
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，一致性在单体结构中更容易得到保证
- en: architectures. In contrast, consistency is not immediate in distributed architectures,
    and distributed architectures rely on so-called eventual consistency. Eventual
    consistency
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 架构。相反，在分布式架构中一致性不是立即的，分布式架构依赖所谓的最终一致性。最终一致性
- en: means that all nodes in a system eventually (at some point in time in future)
    synchronize and agree on a consistent state of the system. ACID properties must
    hold even if some
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 表示系统中所有节点最终（在未来某个时间点）同步并达成一致的状态。即使存在协议，ACID属性也必须保持。
- en: nodes (processes) fail.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 节点（进程）失败。
- en: Atomicity, isolation, and durability are easier to achieve in monolithic architectures,
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性，隔离性和持久性在单体结构中更容易实现，
- en: but achieving these properties in distributed settings becomes more challenging.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 但在分布式环境中实现这些属性会变得更具挑战性。
- en: A two-phase commit protocol is used to achieve atomicity across multiple processes.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 一个两阶段提交协议用于在多个进程之间实现原子性。
- en: Replicas should be consistent with one another. Atomic commit protocols are
    in fact
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 副本应该彼此保持一致。原子提交协议实际上是
- en: a kind of consensus mechanism because in transaction commit protocols nodes
    must
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 一种共识机制，因为在事务提交协议中，节点必须
- en: come to an agreement to either commit if all is well or roll back in case something
    goes
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 达成一致意见，要么在一切正常时提交，要么在出现问题时回滚
- en: wrong. Imagine if a transaction is expected to be committed on all nodes in
    a distributed system (a network), then either it must commit on all or none to
    maintain replica
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 错误。想象一下，如果一个事务预期在分布式系统（一个网络）的所有节点上提交，那么它必须在所有节点上提交或不提交来维护副本
- en: consistency. We cannot have a situation where a transaction succeeds on some
    nodes
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。我们不能出现某些节点上的事务成功
- en: and not on others, leading to an inconsistent distributed system. This is where
    atomic
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 而不在其他节点上，导致不一致的分布式系统。这就是原子的地方
- en: commit comes in. It can be seen fundamentally as a consensus algorithm because
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 提交事件。可以从根本上看出这是一种共识算法，因为
- en: this protocol requires an agreement between all nodes in a network. However,
    there
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议要求网络中所有节点达成一致意见。但是，需要注意的是
- en: '262'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '262'
- en: CHapTer 6 early proToCols
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: are fundamental differences between atomic commit and consensus. In consensus,
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 原子提交和共识之间存在根本区别。在共识中，
- en: one or more nodes propose a value, and nodes decide on one of the values using
    the
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个节点提出一个值，节点使用
- en: consensus algorithm. This is usually achieved by majority consensus. In contrast,
    in
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法。这通常通过大多数共识来实现。相比之下，在
- en: an atomic commit protocol, all nodes are required to vote whether they commit
    or
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 原子提交协议，所有节点都必须投票，无论他们是否提交或
- en: abort the transaction. In consensus algorithms, there can be multiple values
    proposed
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 中止事务。在共识算法中，可能会提出多个值
- en: out of which one can be agreed upon, whereas in atomic commit the protocol must
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个可以达成一致，而在原子提交中，协议必须
- en: commit if all nodes vote to commit; otherwise, even if one node doesn’t agree,
    then the
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点投票以提交，则提交；否则，即使一个节点不同意，那么
- en: transaction must be aborted by all nodes. A major distinction between atomic
    commit
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 事务必须由所有节点中止。原子提交之间的一个重要区别
- en: and consensus is that in consensus algorithms, faults (crashed nodes) are tolerated
    due
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 共识是共识算法中，故障（崩溃节点）由于
- en: to the quorum availability rule, whereas in atomic commit even if one node fails,
    the
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守法定数量规则，而在原子提交中，即使一个节点失败，该
- en: transaction must abort on all nodes. To handle crashed nodes, a complete and
    strongly
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 事务必须在所有节点上中止。为处理崩溃的节点，需要完全和强烈
- en: accurate failure detector is used, which is implemented using a timeout mechanism.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超时机制实现的准确故障检测器。
- en: In addition to the ACID consistency model, another common consistency model
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ACID一致性模型外，另一个常见的一致性模型
- en: used in databases is the BASE model. BASE stands for basically available (BA),
    soft
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 基本可用（BA），软
- en: state (S), and eventually consistent (E). The databases using the BASE consistency
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 状态（S），最终一致（E）。使用BASE一致性的数据库
- en: model ensure availability by replicating data across nodes in the system. As
    the model
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通过在系统中的节点之间复制数据来确保可用性。由于该模型
- en: does not provide immediate consistency, the data values could change over time,
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供即时一致性，数据值随时间变化，
- en: which results in eventual consistency. In the BASE model, consistency is only
    achieved
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 结果最终一致。在BASE模型中，一致性只能实现
- en: eventually. However, it offers high availability, which is useful in many online
    services where immediate and strong consistency requirements are somewhat loose,
    like social
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 最终。但是，它提供高可用性，在许多需要立即和强烈一致性要求较低的在线服务中非常有用，比如社交
- en: networks and online video platforms. From a CAP theorem perspective, the BASE
    model
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和在线视频平台。从CAP定理的角度来看，BASE模型
- en: sacrifices consistency and favors high availability.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 牺牲一致性，偏向高可用性。
- en: Now we discuss the two-phase commit which is a famous commit protocol,
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们讨论著名的二阶段提交协议，
- en: achieving atomicity.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 实现原子性。
- en: '**Two-Phase Commit**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**二阶段提交**'
- en: A two-phase commit (2PC) is an atomic commit protocol to achieve atomicity.
    It was
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 两阶段提交（2PC）是一种原子提交协议，用于实现原子性。它
- en: first published in a paper by Lampson and Sturgis in 1979\. A two-phase commit
    enables
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次发表在1979年Lampson和Sturgis的一篇论文中。两阶段提交使
- en: updating multiple databases in a single transaction and committing/aborting
    atomically.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个事务中更新多个数据库并原子地提交/中止。
- en: As the name suggests, it works in two phases. The first phase is the vote collection
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，它分为两个阶段。第一阶段是投票收集
- en: phase in which a coordinator node collects votes from each node participating
    in
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段，在该阶段，协调者从参与的每个节点收集投票
- en: the transaction. Each participant node either votes yes or no to either commit
    the
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 事务。每个参与节点要么投赞成 要么反对，不论是提交事务还是中止
- en: transaction or abort the transaction. When all votes are collected, the coordinator
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 事务或中止事务。当收集到所有的投票后，协调者
- en: '263'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '263'
- en: CHapTer 6 early proToCols
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 章节6早期协议
- en: (transaction manager) starts the second phase, called the decision phase. In
    the decision phase, the coordinator commits the transaction if it has received
    all yes votes from other nodes; otherwise, it aborts the transaction. Any node
    that had voted yes to commit
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: （事务管理器）启动第二阶段，称为决策阶段。在决策阶段，如果协调者从其他节点收到了所有的yes票，它会提交事务；否则，它会中止事务。任何投票赞成提交的节点
- en: the transaction waits until it receives the final decision from the coordinator
    node. If it receives no from the coordinator, it will abort the transaction; otherwise,
    it will commit the transaction. Nodes that voted no immediately terminate the
    transaction without
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 事务等待直到它从协调者节点那里收到最终的决定。如果从协调者那里得到的是no，就会中止事务；否则，就会提交事务。投票no的节点立即终止事务而不需要
- en: waiting to receive a decision from the coordinator. When a transaction is aborted,
    any
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 等待来自协调者的决定。当一个事务被中止时，所有
- en: changes made are rolled back. The changes are made permanent after committing
    at
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 所做的更改将被回滚。在提交后才会使更改永久
- en: nodes that said yes when they receive a commit decision from the coordinator.
    Any
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调者收到提交决定时，投票yes的任何节点。任何
- en: changes made by the transaction are not permanent, and any locks are released
    after
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 事务所做的任何更改都不是永久的，任何锁在
- en: a write operation is performed. All participants send the acknowledgment back
    to
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 执行写操作。所有参与者发送确认收据
- en: the coordinator after they’ve received the decision from the coordinator. As
    a failure
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 就接收到协调者的决定后将其发送给协调者。作为一种失败
- en: handling mechanism, a logging scheme is used in two-phase commits. In this scheme,
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 处理机制，两阶段提交中使用了一种日志方案。在该方案中，
- en: all messages are written to a local stable storage before they are sent out
    to the recipients in the network. When the coordinator fails (crashes), it writes
    its decision to the local disk in the log, and when it recovers, it sends its
    decision to other nodes. If no decision was made before the crash, then it simply
    aborts the transaction. When a node fails
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息都会在发送到网络中的接收方之前被写入本地稳定存储。当协调者失败（崩溃）时，它会将其决定写入日志中的本地磁盘，当它恢复时，它会将其决定发送给其他节点。如果崩溃前没有做出决定，那么就干脆中止事务。当一个节点崩溃
- en: (other than the coordinator node), the coordinator waits until it times out,
    and a decision is made to abort the transaction for all.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: （除了协调者节点之外），协调者会等待直到超时，然后做出中止所有事务的决定。
- en: Figur[e 6-1 sho](#p281)ws the two-phase commit protocol in action. Here, the
    client (application) starts the transaction as usual and performs a usual read/write
    operation
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1显示了两阶段提交协议的行动。这里，客户端（应用程序）开始传统的事务并执行传统的读/写操作
- en: on the database nodes, that is, on the transaction participant nodes. After
    a normal
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据库节点进行正常
- en: transaction execution on each participant, when the client is ready to commit
    the
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与者节点上的事务执行，当客户准备提交
- en: transaction, the coordinator starts the first phase, that is, the prepare phase.
    It sends the prepare request to all nodes and asks them whether they can commit
    or not. If the
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 事务，协调者开始第一阶段，即准备阶段。它向所有节点发送准备请求，并询问它们是否可以提交或不。如果
- en: participants reply with a yes, it means that they are willing and ready to commit
    the
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者回复yes，表示他们愿意并准备好承诺
- en: transaction, then the coordinator starts the second phase called the commit
    phase. This
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 事务，然后协调者启动称为提交阶段的第二阶段。这
- en: is when the coordinator sends out the commit decision, and the transaction is
    finally
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 当协调者发送提交决定的时候，事务最终得到
- en: committed, and a commit actually takes place. If any of the participant nodes
    replies to
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 已提交，并且实际上真的提交了。如果任何参与节点回复
- en: the prepare request with a no, then the coordinator sends out the abort request
    in phase
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 发送一个no的准备请求，那么协调者在第一阶段中发送终止请求
- en: two, and all nodes abort accordingly. Note that after the first phase, there
    is a decision point where the coordinator decides whether to commit or abort.
    The action after the
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 两者，并且所有节点都相应中止。请注意，在第一阶段之后，有一个决策点，协调者决定是提交还是中止。在
- en: decision phase is either commit or abort, based on the yes or no received from
    the
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 决策阶段要么是提交要么是中止，取决于从参与者那里收到的是肯定还是否定
- en: participants.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者。
- en: '264'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '264'
- en: '![](index-281_1.png)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![](index-281_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 早期协议
- en: '***Figure 6-1\.** The two-phase commit algorithm – a successful scenario*'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-1\.** 两阶段提交算法 - 一个成功的场景*'
- en: The two-phase commit is a blocking algorithm because if the coordinator goes
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 两阶段提交是一种阻塞算法，因为如果协调者发生故障
- en: down after the “prepare” phase but before sending out its decision, other nodes
    have
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在“准备”阶段之后但在发送决定之前崩溃，其他节点将
- en: no way of finding out what has been decided by the coordinator. Now they are
    stuck
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法弄清楚协调者做出了什么决定。现在他们陷入了困境
- en: in an uncertain state where they have agreed earlier to commit by saying yes/ok
    in the
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 处于不确定状态，他们早先同意通过在准备阶段回复肯定/ok来提交
- en: prepare phase but are now waiting to hear the final decision from the coordinator.
    Nodes
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 准备阶段，但现在他们正在等待协调者的最终决定。节点们
- en: cannot either commit or abort on their own after responding yes in the prepare
    phase
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在参与准备阶段之后，他们也无法自行提交或中止
- en: because it will violate the atomicity property. The protocol in this situation
    blocks until the coordinator recovers. This means that the two-phase commit algorithm
    is not fault
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这将违反原子性属性。在这种情况下，协议会一直阻塞，直到协调者恢复。这意味着两阶段提交算法不具备容错
- en: tolerant if the coordinator or a participant fails. In other words, 2PC is not
    partition
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果协调者或参与者失败，2PC不具备分区容忍性。换句话说，2PC不是分区容错的
- en: tolerant.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍。
- en: More precisely, if the coordinator crashes just after the prepare phase before
    sending
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，如果协调者在发送准备阶段之后立即崩溃
- en: the decision, other nodes then have no idea what decision is made by the coordinator.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 决定，其他节点就无法知道协调者做出了什么决定。
- en: At this stage, participants cannot commit or abort, and the protocol is blocked
    until the coordinator comes back online and participants receive the decision.
    The coordinator is
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，参与者无法提交或中止，协议被阻塞，直到协调者重新上线并参与者收到决定。协调者是
- en: a single point of failure in this protocol. There are ways to overcome this
    problem using a consensus mechanism or total order broadcast protocol. The commit
    protocol can use
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个协议中存在单点故障。可以通过使用一致性机制或总排序广播协议来克服这个问题。提交协议可以使用
- en: consensus to elect a new coordinator.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性来选举一个新的协调者。
- en: Also, note that if we remove the second phase and hence no rolling back, it
    becomes
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果我们移除第二阶段，因此没有回滚，它就变成了
- en: a one-phase commit, that is, the primary/backup replication. Sounds familiar?
    We
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一阶段提交，即主/备份复制。听起来耳熟吗？我们
- en: discussed this in Chapter [3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)章中讨论过。
- en: '265'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '265'
- en: CHapTer 6 early proToCols
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 早期协议
- en: '**Three-Phase Commit**'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '**三阶段提交**'
- en: As we saw in the two-phase commit, it is not fault tolerant and blocks until
    the failed
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在两阶段提交中看到的那样，它不具备容错性，并且会一直阻塞直到故障
- en: coordinator recovers. If the coordinator or a participant fails in the commit
    phase, the
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 协调者恢复。如果协调者或参与者在提交阶段失败，那么
- en: protocol cannot recover reliably. Even when the coordinator is replaced or recovers,
    it
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 协议无法可靠地恢复。即使协调者被替换或恢复，它
- en: cannot proceed to process the transaction reliably from where the failure occurred.
    The
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 无法从故障发生的地方可靠地处理事务。该
- en: three-phase commit solves this problem by introducing a new pre-commit intermediate
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 三阶段提交通过引入一个新的预提交中间过程来解决这个问题
- en: phase. After receiving a yes from all the participants, the coordinator moves
    to this
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段。在收到所有参与者的肯定答复后，协调者转向这个
- en: intermediate phase. Unlike 2PC, here, the coordinator does not immediately broadcast
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 中间阶段。不同于2PC，这里，协调者不会立即广播
- en: commit; instead, it sends a pre-commit first, which indicates the intention
    to commit
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 提交；相反，它首先发送一个预提交，表示打算提交
- en: the transaction. When participants receive the pre-commit message, they reply
    with the
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 事务。当参与者收到预提交消息时，他们用相同的
- en: ack messages. When the coordinator receives this ack from all participants,
    it sends the
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 确认消息。当协调者从所有参与者那里收到这个确认消息时，它发送
- en: commit message and proceeds as in the two-phase commit. If a participant fails
    before
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: commit消息并像两阶段提交那样继续。如果参与者在
- en: sending back a message, the coordinator can still decide to commit the transaction.
    If the coordinator crashes, the participants can still agree to abort or commit
    the transaction.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 返回消息，协调者仍然可以决定提交交易。如果协调者崩溃，参与者仍然可以同意中止或提交交易。
- en: This is so because no actual commit or abort has taken place yet. The participants
    now
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为尚未发生任何实际的提交或中止。参与者现在
- en: have another chance to decide by checking that if they have seen a pre-commit
    from the
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 另一次决定，通过检查他们是否看到了协调者的预提交
- en: coordinator, they commit the transaction accordingly. Otherwise, the participants
    abort
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 协调者，他们相应地提交交易。否则，参与者会中止
- en: the transaction, as no commit message has been seen from the coordinator.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 交易，因为协调者没有发送提交消息。
- en: This process can be visualized in Figur[e 6-2\.](#p283)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在[图6-2\.](#p283)中可以可视化
- en: '266'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '266'
- en: '![](index-283_1.png)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![](index-283_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 早期协议
- en: '***Figure 6-2\.** Three-phase commit protocol*'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-2\.** 三阶段提交协议*'
- en: Roughly speaking, commit protocols can be seen as agreement protocols because
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 大致而言，提交协议可以被看作是协议的协议，因为
- en: participants need to decide whether to accept the value proposed by the coordinator
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者需要决定是否接受协调者提出的值
- en: or not. Of course, it is a simple protocol and not fault tolerant, but it does
    achieve an agreement among parties; hence, it can be seen as a consensus mechanism.
    Moreover,
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 或者。当然，这是一个简单的协议，没有容错能力，但它确实实现了各方之间的一致；因此，它可以被看作一种共识机制。而且，
- en: we can say that validity is achieved because a participant proposes a final
    agreed-upon
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，有效性得到了实现，因为参与者提出了一个最终达成一致的值
- en: value. Also, termination is guaranteed because every participant makes progress.
    If there are no failures, eventually all participants respond to the coordinator,
    and the protocol moves forward and, finally, both phases end. Strictly speaking,
    however, distributed
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个协议是简单的，没有容错能力，但却可以在各方之间达成一致，因此可以看作是一种共识机制。此外，
- en: commit protocols are not consensus protocols.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 提交协议不是共识协议。
- en: Now, after this introduction to the most straightforward consensus protocols
    or
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在介绍了最直接的共识协议或
- en: distributed commit protocols (depending on how you look at them), let us focus
    on
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式提交协议（取决于你如何看待它们），让我们专注于
- en: some early fault-tolerant consensus protocols that provide the foundation of
    what we see
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 一些早期的容错共识协议，为我们所见到的提供了基础
- en: today as consensus protocols in various distributed systems and blockchains.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 如今在各种分布式系统和区块链中被称为共识协议。
- en: '267'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '267'
- en: CHapTer 6 early proToCols
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 早期协议
- en: '**Oral Message Algorithm**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**口头消息算法**'
- en: The oral message (OM) algorithm was proposed to solve the Byzantine generals
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为解决拜占庭将军问题提出的口头消息（OM）算法
- en: problem in the “Byzantine Generals Problem” paper in 1982 by Lamport et.al.
    This
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了“拜占庭将军问题”的 1982年Lamport等人的论文
- en: recursive algorithm runs under the synchronous network model. It assumes a collection
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法在同步网络模型下运行。它假设有一个集合
- en: of N generals where all generals are connected as a complete graph. One general
    is
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同连接的N个将军中的一个完整图形。一位将军
- en: the “commander” responsible for starting the protocol. Other generals (N – 1)
    called
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: “指挥官”负责启动该协议。其他将军（N-1）被称为
- en: “lieutenants” orally pass around the message they receive. The commander knows
    that
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: “中尉”口头传递他们接收到的消息。指挥官知道
- en: at most f generals will be faulty (traitors) and starts the consensus algorithm
    with a
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 最多f个将军将会出错（叛徒），并使用递归算法运行共识算法
- en: known value of f. There is also a default value, either “retreat” or “attack.”
    The intuition behind this algorithm is that you tell others what message you received
    on receiving
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 已知f的默认值。还有一个默认值，要么是“撤退”，要么是“进攻”。这个算法背后的直觉是，你告诉别人你收到了什么消息
- en: every message. The participants accept the majority decision, which ensures
    the safety
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息。参与者接受多数决定，这确保了安全性
- en: property of the algorithm.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的属性。
- en: There are two *interactive consistency* requirements that need to be met called
    IC1
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个*交互一致性*要求需要满足，称为IC1
- en: 'and IC2:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 和IC2：
- en: '1\. **IC1**: All loyal lieutenants obey the same order.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. **IC1**：所有忠诚的中尉都遵守同样的命令。
- en: '2\. **IC2**: If the commanding general is loyal, then every loyal'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. **IC2**：如果指挥官忠诚，那么每个忠诚的
- en: lieutenant obeys its order.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 中尉遵从他的命令。
- en: Some assumptions about the system model are
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统模型的一些假设是
- en: 1\. The absence of message can be detected. This is due to
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 可以检测到消息的缺失。这是因为
- en: synchronous communication.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 同步通信。
- en: 2\. Every sent message is delivered correctly.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 每个发送的消息都被正确传递。
- en: 3\. The receiver of the message knows who sent it.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 消息的接收者知道是谁发送的。
- en: An oral message is a message whose contents are under complete control of the
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 口头消息是其内容完全受控的消息
- en: sender. The sender can send any possible message.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者。发送者可以发送任何可能的消息。
- en: There is no solution to the Byzantine generals problem unless more than two-thirds
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 除非超过三分之二，否则拜占庭将军问题没有解决办法。
- en: of generals are loyal. For example, if there are three generals and one is a
    traitor, then there is no solution to BGP if oral messages are used. Formally
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 将军是忠诚的。例如，如果有三位将军，其中一位是叛徒，那么如果使用口头消息，拜占庭协议是不可能达成的。具体而言
- en: '• **Lemma 1**: There is no solution to the Byzantine generals problem for'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '• **引理 1**: 对于拜占庭将军问题没有解决办法'
- en: 3m + 1 generals with > m traitors.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 3m + 1 个将军中有 > m 个叛徒。
- en: In other words, if n <= 3m, then a Byzantine agreement is not possible. The
    algorithm
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果 n <= 3m，则不可能达成拜占庭协议。算法
- en: is recursive.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 是递归的。
- en: '268'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '268'
- en: '![](index-285_1.png)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![](index-285_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: CHapTer 6 早期协议
- en: '**Algorithm**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法**'
- en: '**Base case: OM(0)**'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本情况: OM(0)**'
- en: 1\. The commander broadcasts a proposed value to every lieutenant.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 指挥官向每个中尉广播建议的值。
- en: 2\. Every lieutenant accepts the received value. If no value is received,
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 每个中尉接受接收到的值。如果没有收到值，
- en: then it uses the DEFAULT value, either set to retreat or attack, at
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用默认值，可以是撤退或进攻，在
- en: the start of the algorithm.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的开始。
- en: '**With traitor(s): OM(m), where m > 0**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**有叛徒的情况: OM(m)，其中 m > 0**'
- en: 1\. The commander sends the proposed value to every lieutenant.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 指挥官将建议的值发送给每个中尉。
- en: 2\. Every lieutenant runs OM(m-1) and acts as the commander to
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 每个中尉现在运行 OM(m-1)，并起到指挥官的作用
- en: send the value received in step 1 to all the other lieutenants.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 将在步骤 1 中接收的值发送给所有其他中尉。
- en: 3\. Each lieutenant maintains a vector from which it uses the majority
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 每个中尉都维护一个向量，其中使用大多数值
- en: value out of the values received.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的值中选择大多数。如果没有接收到任何值，
- en: The base case and OM(1) case are depicted in Figure [6-3](#p285).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况和 OM(1) 情况如图 [6-3](#p285) 所示。
- en: '***Figure 6-3\.** OM base case vs. OM(1) case, where the commander is the traitor*'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '***Figure 6-3\.** OM 基本情况与 OM(1) 情况，指挥官为叛徒*'
- en: We can also visualize the case where a lieutenant is the traitor as shown in
    Figur[e 6-4\.](#p286)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以看到中尉是叛徒的情况，如图 [6-4\.](#p286) 所示。
- en: '269'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '269'
- en: '![](index-286_1.png)'
  id: totrans-885
  prefs: []
  type: TYPE_IMG
  zh: '![](index-286_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: CHapTer 6 早期协议
- en: '***Figure 6-4\.** OM case with M=1 where a lieutenant is a traitor*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '***Figure 6-4\.** M=1 的情况下 OM，其中一个中尉是叛徒*'
- en: 'We can formally describe the algorithm as shown in the following code:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以正式描述算法，如下所示：
- en: '**Base case**'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本情况**'
- en: OM(0)- base case
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: OM(0)- 基本情况
- en: DEFAULT := Default value
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: DEFAULT := 默认值
- en: Commander C broadcasts its proposed value to all Lieutenants
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 指挥官 C 向所有中尉广播其建议的值
- en: 'For i = 1 : N – 1 do'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 i = 1 : N – 1 do'
- en: Li stores the value from C in an array as Vi
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: Li 将从 C 中的值存储为 Vi 的数组
- en: Vi = DEFAULT if no value received
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: Vi = 如果没有收到值，则为默认值
- en: Li accepts Vi
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: Li 接受 Vi
- en: End for
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '**Case with f > 0, OM(m)**'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**f > 0 的情况，OM(m)**'
- en: Commander C broadcast its value to all lieutenants
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 指挥官 C 广播其值给所有中尉
- en: 'For I = 1 : n-1 do'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 I = 1 : n-1 do'
- en: Li stores the value from commander as vi
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: Li 将指挥官的值存储为 vi
- en: Vi = default if no value received from the commander
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: Vi = 默认值，如果没有从指挥官那里收到值
- en: Li runs OM(m-1) now as commander to send the value vi to other N – 2
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: Li 现在以指挥官的身份运行 OM(m-1)，向其他 N – 2 人发送值 vi
- en: Lieutenants
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 中尉
- en: End for
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '270'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '270'
- en: '![](index-287_1.png)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![](index-287_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: CHapTer 6 早期协议
- en: 'For I = 1 : N – 1 do'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 I = 1 : N – 1 do'
- en: 'For j = 1 : N – 1 AND j ≠ i do'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 j = 1 : N – 1 并且 j ≠ i do'
- en: Li stores the value received from Lj as vj
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Li 将从 Lj 接收的值存储为 vj
- en: Vj = default if no value received
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: Vj = 默认值，如果没有接收到值
- en: End for
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: Li chooses majority from {v1, v2, v3, , , , vn-1}
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: Li 从 {v1, v2, v3, , , , vn-1} 中选择大多数
- en: End for
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: As you may have noticed, this algorithm, while it works, is not very efficient
    due
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个算法虽然有效，但由于
- en: to the number of messages required to be passed around. More precisely, from
    a
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 对于要传递的消息数量而言， 这个算法效率不是很高。
- en: communication complexity perspective, this algorithm is exponential in the number
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 从通信复杂性的角度来看，这个算法是指数级的，消息数量
- en: of traitors. If there are no traitors, as in the base case, then its constant,
    *O*(1), otherwise its *O*( *mn*), which means that it grows exponentially with
    the number of traitors, which makes it impractical for a large number of *n*.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 叛徒。如果没有叛徒，如基本情况，那么它是常数，*O*（1），否则是*O*（*mn*），这意味着它随着叛徒数量呈指数增长，这使得对于大量*n*来说是不切实际的。
- en: Using the space-time diagram, we can visualize the base case as shown in Figure
    [6-5](#p287).
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时空图，我们可以将基本情况可视化，如图[6-5](#p287)所示。
- en: '***Figure 6-5\.** Oral message protocol – base case – with no traitors*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-5\.** 口头信息协议-基本情况-没有叛徒*'
- en: We can also visualize the m > 0 case where the commander is the traitor sending
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将m > 0的情况可视化，其中指挥官是叛徒，发送
- en: conflicting messages to lieutenants in Figur[e 6-6\.](#p288)
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[e 6-6\.](#p288) 中向中尉发送了冲突的消息
- en: '271'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '271'
- en: '![](index-288_1.png)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![](index-288_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: '***Figure 6-6\.** Oral message protocol case where m =1, the commander is a
    traitor*'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-6\.** 口头信息协议情况下m =1，指挥官是叛徒*'
- en: In the digital world, commanders and lieutenants represent processes, and the
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字世界中，指挥官和中尉代表进程，以及
- en: communication between these processes is achieved by point-to-point links and
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是通过点对点链接和
- en: physical channels.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 物理通道。
- en: So far, we have discussed the case with oral messages using no cryptography;
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了不使用密码口头信息的情况;
- en: however, another solution with signed messages is also possible where digital
    signatures
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一种带有签名消息的解决方案也是可能的，数字签名
- en: are used to guarantee the integrity of the statements. In other words, the use
    of oral
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 用于保证陈述完整性。换句话说，口头使用
- en: messages does not allow the receiver to ascertain whether the message has been
    altered
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 信息不允许接收者确定消息是否已经被篡改
- en: or not. However, digital signatures provide a data authentication service that
    enables
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 或不。但是，数字签名提供了一项数据认证服务，使
- en: receiving processes to check whether the message is genuine (valid) or not.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 接收进程检查消息是否真实（有效）。
- en: Based on whether oral messages are used, or digital signatures have been used,
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 根据是否使用口头信息，或者使用数字签名，
- en: Table [6-1](#p277), earlier in this chapter, summarizes the impossibility results
    under various system models.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 表[6-1](#p277)，本章早期总结了各种系统模型下不可能性的结果。
- en: '**Signed Message Solution to Byzantine Generals Problem**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭将军问题的签名消息解决方案**'
- en: The main issue with the oral message algorithm is that it needs 3 *t* + 1 (also
    denoted as 3 *f* + 1) nodes to tolerate *t* (also denoted as *f*) failures, which
    is expensive in terms of computational resources required. It is also difficult
    because traitors can lie about what other nodes said. The time complexity of this
    algorithm is *O*( *nm*).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 口头消息算法的主要问题是，需要3 *t* + 1（也表示为3 *f* + 1）个节点来容忍 *t*（也表示为 *f*）的失败，这在计算资源方面是昂贵的。这也很困难，因为叛徒可以说出其他节点所说的话。该算法的时间复杂度为*O*（*nm*）。
- en: '272'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '272'
- en: CHapTer 6 early proToCols
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: There is a signed solution to BGP which was proposed in the same BGP paper by
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题中存在一种签名解决方案，该解决方案是由同一篇拜占庭将军问题论文中提出的
- en: 'Lamport, Shostak, and Pease. It uses digital signatures to sign the messages.
    Here are the additional assumptions under this model:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport，Shostak和Pease。 它使用数字签名对消息进行签名。在此模型下的其他假设如下：
- en: 1\. The signature of a loyal general cannot be forged, and any
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 忠诚将军的签名不能被伪造，任何
- en: modification of the general’s messages is detectable.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 将军的消息的修改是可以检测的。
- en: 2\. Anyone can verify the authenticity of the general’s signature.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 任何人都可以验证将军的签名的真实性。
- en: Under this model, each lieutenant maintains a vector of signed orders received.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型下，每个中尉都维护着接收到的签名订单的向量。
- en: Then, the commander sends the signed messages to the lieutenants.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将军向中尉发送签名的消息。
- en: 'Generally, the algorithm works like this:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，该算法的工作方式是这样的：
- en: A lieutenant receives an order from either a commander or other lieutenants
    and
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 一名中尉收到指令，可以来自指挥官或其他中尉
- en: saves it in the vector that he maintains after verifying the message's authenticity.
    If there are less than m signatures on the order, the lieutenant adds a signature
    to the order
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存在接收的已签名订单的向量中。如果订单上没有超过m个签名，则中尉会向订单添加一个签名
- en: (message) and relays this message to other lieutenants who have not seen it
    yet. When a
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: （消息）并将此消息传递给其他尚未看到的中尉。当一个
- en: lieutenant does not receive any newer messages, he chooses the value from the
    vector as
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 中尉没有收到任何更新的消息，他就从已经看过的向量中选择数值
- en: a decision consensus value.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 决策共识值。
- en: The lieutenants can detect that the commander is a traitor by using signed
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 中尉可以通过使用签名来检测出指挥官是否是叛徒
- en: messages because the commander's signature appears on two different messages.
    Our
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们可以通过验证指挥官的签名在两个不同的消息上来检测出叛徒。我们的
- en: assumptions under this model are that signatures are unforgeable, and anyone
    can verify
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型下的假设是签名不可伪造的，并且任何人都可以验证
- en: the signature's authenticity. This implies that the commander is a traitor because
    only he could have signed two different messages.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 签名的真实性。这意味着指挥官是叛徒，因为只有他可以在两个不同的消息上签名。
- en: Formally, the algorithm is described as follows.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，该算法描述如下。
- en: 'Algorithm: For n generals and m traitor generals where *n* > 0\. In this algorithm,
    each lieutenant *i* keeps a set *Vi* of properly signed messages it has received
    so far. When the commander is honest, then the set *Vi* contains only a single
    element.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：对于 n 个将军和 m 个叛徒将军，其中 *n* > 0。在这个算法中，每个中尉 *i* 都会保持一个到目前为止接收到的正确签署消息的集合 *Vi*。当指挥官是诚实的时候，那么集合
    *Vi* 只包含一个单一元素。
- en: '**Algorithm SM(m)**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 SM(m)**'
- en: 'Initialization:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化：
- en: '*Vi* = { }, that is, empty'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vi* = { }，也就是，空集'
- en: 1\. Commander
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 指挥官
- en: '*C* sends the signed message (value) to every'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* 向每一个'
- en: lieutenant.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 中尉。
- en: 2\. For each *i*
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 对于每个 *i*
- en: 'a. If lieutenant *i* receives a message of the form *v* : 0 from the'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 'a. 如果中尉 *i* 收到形如 *v* : 0 的消息，而该消息'
- en: commander and has not yet received any message (order) from
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 指挥官并且还没有收到任何命令（消息）时
- en: the commander, that is, *Vi* is empty, then
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 即指挥官 *Vi* 为空的话，那么
- en: '273'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '273'
- en: '![](index-290_1.png)'
  id: totrans-973
  prefs: []
  type: TYPE_IMG
  zh: '![](index-290_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 早期协议
- en: i. Set *Vi* = { *v*}.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: i. 设置 *Vi* = { *v*}。
- en: 'ii. It sends the message *v* : 0 : *i* to every other lieutenant.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 'ii. 将消息 *v* : 0 : *i* 发送给每一个其他中尉。'
- en: 'b. If lieutenant *i* receives a message like *v* : 0 : *j* 1\. … *jk* and *v*
    is not in the set, *Vi*, then'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 'b. 如果中尉 *i* 收到像 *v* : 0 : *j* 1\. … *jk* 这样的消息，并且 *v* 不在集合 *Vi* 中，那么'
- en: i. *Vi* = *Vi* + { *v*}, that is, add *v* to *Vi*.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: i. *Vi* = *Vi* + { *v*}，也就是，将 *v* 添加到 *Vi* 中。
- en: 'ii. If *k* < *m*, then send message *v* : 0 : *j* 1… *jk* : *i* to every lieutenant
    other than *j* 1… *jk*.'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 'ii. 如果 *k* < *m*，那么将消息 *v* : 0 : *j* 1… *jk* : *i* 发送给除了 *j* 1… *jk* 之外的所有中尉。'
- en: 3\. For each *i*
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 对于每个 *i*
- en: a. When no more messages received by lieutenant *i*, then it obeys
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: a. 当中尉 *i* 不再接收到更多消息时，那么它遵守
- en: the order (message) via the function *choice* ( *Vi*), which obtains
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数 *choice* ( *Vi*) 获取命令（消息）。
- en: a single order from a set of orders. *Choice*( *V*) = *retreat* if set *V* is
    empty or it consists of more than one element. If there is only a
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 从一组命令中进行选择。如果集合 *V* 为空或包含多于一个元素，则 *Choice*( *V*) = *retreat*。如果只有一个
- en: single element *v* in set *V*, then *choice*( *V*) = *v*.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 *V* 中的单一元素 *v*，那么 *choice*( *V*) = *v*。
- en: 'Here, *v* : *i* is the value *v* signed by general *i*, and *v* : *i* : *j*
    is the message *v* : *i* counter signed by general *j*. Each general *i* maintains
    a set *Vi* which contains all orders received.'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，*v* : *i* 是由将军 *i* 签署的值 *v*，而 *v* : *i* : *j* 是由将军 *j* 签署的消息 *v* : *i*。每个将军
    *i* 维护一个包含所有接收到的命令的集合 *Vi*。'
- en: The diagram in Figur[e 6-7 vis](#p290)ualizes a traitor commander scenario.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7 的图示了叛徒指挥官的场景。
- en: '***Figure 6-7\.** Example of a signed message protocol with SM(1) – traitor*'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 6-7\.** 具有 SM(1) – 叛徒的签名消息协议示例*'
- en: '*commander*'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '*指挥官*'
- en: '274'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '274'
- en: CHapTer 6 early proToCols
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 早期协议
- en: With signed messages, it’s easy to detect if a commander is a traitor because
    its
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 使用签名消息，很容易就能检测出指挥官是否是叛徒，因为他
- en: signature would appear on two different orders, and by the assumption of unforgeable
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 签名会出现在两个不同的指令上，根据签名不可伪造的假设
- en: signature, we know that only the commander could have signed the message.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 签名，我们知道只有指挥官才能在消息上签名。
- en: Formally, for any *m*, the algorithm *SM*( *m*) solves the Byzantine generals
    problem if there are at most *m* traitors. The lieutenants maintain a vector of
    values and run a choice function to retrieve the order *choice* { *attack*, *retreat*}.
    Timeouts are used to ascertain if no more messages will arrive. Also, in step
    2, lieutenant *i* ignores any message *v* that is already in the set *Vi*.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，对于任意的 *m*，算法 *SM*( *m*) 在最多 *m* 个叛徒的情况下解决了拜占庭将军问题。中尉维护了一个值的向量，并运行一个选择功能来检索命令
    *choice* { *attack*, *retreat*}。超时用于确定是否不会再有更多的消息到达。此外，在步骤 2 中，中尉 *i* 忽略任何已经在集合
    *Vi* 中的消息 *v*。
- en: This algorithm has message complexity *O*( *nm* + 1), and it requires *m* +
    1 number of rounds. This protocol works for *N* ≥ *m* + 2\.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的消息复杂度为 *O*( *nm* + 1)，并且需要 *m* + 1 轮。该协议对于 *N* ≥ *m* + 2\ 有效。
- en: In contrast with the oral message protocol, the signed message protocol is more
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 与口头消息协议相比，签名消息协议更加
- en: resilient against faults; here, if at least two generals are loyal in three
    generals, the problem is solvable. In the oral message, even if there is a single
    traitor in three generals, the problem is unsolvable.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 抵御故障；在这里，如果三名将军中至少有两名忠诚，该问题是可解的。在口头消息中，即使三名将军中有一个叛徒，问题也是不可解的。
- en: '**DLS Protocols Under Partial Synchrony**'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分同步下的DLS协议**'
- en: After the FLP impossibility result, one of the ways that researchers introduced
    to
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: FLP不可能性结果之后，研究人员介绍的一种方式
- en: circumvent the FLP impossibility is to use the partial synchrony network model.
    There
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 回避FLP不可能性的一种方式是使用部分同步网络模型。那里
- en: are some important concepts presented in this paper, such as rotating coordinators,
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 该论文中提出了一些重要的概念，例如轮换协调员
- en: consensus, termination under partial synchrony, and implementation of the round-based
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 共识、部分同步终止和基于回合的实现
- en: mechanism. We discussed various models, including partial synchrony, in Chapter
    [3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 机制。我们在第[3\.]章中讨论了各种模型，包括部分同步。
- en: The paper describes four algorithms for crash-stop, omissions, Byzantine,
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 该论文描述了四种算法，用于该论文中的崩溃停止、遗漏、拜占庭
- en: and authenticated Byzantine faults under partial synchrony. The key idea in
    these
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分同步状态下认证的拜占庭故障。这些中的关键思想
- en: algorithms is that the agreement and validity are always satisfied, whereas
    termination is guaranteed when the system stabilizes, that is, has good episodes
    of synchrony.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 算法总是满足协议和有效性，而当系统稳定时保证终止，也就是，具有良好的同步事件。
- en: A basic round model is introduced where protocol execution is divided into rounds
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了一个基本的回合模型，其中协议执行被分为回合
- en: of message exchange and local computations. Each round comprises a send step,
    a
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 的消息交换和本地计算。每个回合包括一个发送步骤、一个
- en: receive step, and a computation step. In addition, the basic round model assumes
    a
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 接收步骤和计算步骤。此外，基本回合模型假设一个
- en: round, called the global stabilization round, during which or after correct
    processes
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 全局稳定化回合，其中或者正确进程之后
- en: receive all messages sent from correct processes.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 收到所有来自正确进程发送的消息。
- en: In this section, algorithm 2 is presented, a consensus algorithm for Byzantine
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，介绍了算法2，一个拜占庭共识算法
- en: faults with authentication. It assumes a network model with partially synchronous
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 具有认证的拜占庭故障。它假设有部分同步的网络模型
- en: communications and processors that can be Byzantine. This model is also adopted
    for
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是拜占庭的通信和处理器。这个模型也适用于
- en: most, if not all, blockchain networks.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是全部，区块链网络。
- en: '275'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '275'
- en: CHapTer 6 early proToCols
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: The algorithm achieves strong unanimity for a set V with an arbitrary value
    under
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法实现了在任意值集V下的强一致性
- en: Byzantine faults with authentication.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 具有认证的拜占庭故障。
- en: The algorithm progresses in phases. Each phase *k* consists of four consecutive
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 算法分为阶段进行。每个阶段 * k * 包括四个连续的
- en: rounds, from 4 *k* – 3 to 4 *k*. Each phase has a unique coordinator c which
    leads the phase.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 回合，从4 * k * – 3到4 * k *。每个阶段都有一个独特的协调员c来主导该阶段。
- en: A simple formula *k* = *i* ( *mod n*) is used to select the coordinator from
    all processes, where *k* is the phase, *i* is the process number, and *n* is the
    total number of processes.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单公式 * k * = * i *（* mod n *）用于从所有进程中选择协调员，其中 * k * 是阶段，* i * 是进程号， * n *
    是进程总数。
- en: 'Each process maintains some variables:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都维护一些变量：
- en: • A local variable PROPER, which contains a set of values that the
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: • 本地变量PROPER，其中包含进程p
- en: process knows to be proper.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 进程知道是合适的。
- en: • A local variable ACCEPTABLE, which contains value v that process
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: • 本地变量ACCEPTABLE，其中包含过程p
- en: p has found to be acceptable. Note that a value v is acceptable to
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: p已经被发现是可以接受的。请注意，值v对
- en: process p if p does not have a lock on any value except possibly v.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 进程p如果p对除了可能v之外的任何值都没有锁定
- en: Also, value v is proper.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，值v是合适的。
- en: • A local variable LOCK which keeps the locked value. A process may
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: • 本地变量LOCK，保存锁定的值。一个进程可以
- en: lock a value in a phase if it believes that some process may decide on
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个阶段中的锁定一个进程认为一些进程可能决定
- en: this value. Initially, no value is locked. A phase number is associated
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值。最初，没有值被锁定。一个相位号被关联
- en: with every lock. In addition, a proof of acceptability of the locked
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 每把锁。此外，已锁定值的可接受性证明
- en: value is also associated with every lock. Proof of acceptability is in the
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 该值也与每一个锁绑定。接受性的证明在
- en: form of a set of signed messages sent by *n* − *t* processes, indicating
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 由*n*–*t*个进程发送的一组签名消息的形式，指示
- en: that the locked value is acceptable and proper, that is, it is in their
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定的值是可接受且正确的，也就是说，它在他们的
- en: PROPER sets at the start of the given phase.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: PROPER在给定阶段开始时设定。
- en: '**Algorithm** *N* ≥ 3 *t* + 1 – **Byzantine faults with authentication**'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法** *N* ≥ 3*t* + 1 – **带认证的拜占庭错误**'
- en: '**Trying phase k**'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试第k阶段**'
- en: '**Rounds:**'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮次：**'
- en: '**Round 1: Round 4k – 3**'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1轮：第4k – 3轮**'
- en: Each process including the current coordinator sends an authenticated list of
    all its
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 包括当前协调员在内的每个进程都发送其所有验证过的列表
- en: acceptable values to the current coordinator. Processes use the message format
    *E*( *list*, *k*), where *E* is an authentication function, *k* is the phase,
    and *list* is all acceptable values.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 将可接受的值发送给当前的协调员。进程使用消息格式*E*( *list*, *k*)，其中*E*是认证函数，*k*是阶段，*list*是所有可接受的值。
- en: '**Round 2: Round 4k – 2**'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2轮：第4k – 2轮**'
- en: The current coordinator chooses a value to propose. If a value is to be proposed
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的协调员选择要提议的一个值。如果要提议一个值
- en: by the coordinator, the coordinator must have received at least *n* – *t* responses
    from the processes suggesting that this value is acceptable and proper at phase
    *k*. If there is more than one possible value that the coordinator may propose,
    then it will choose one
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 由协调员，协调员必须从进程中至少收到*n*−*t*个响应，表明这个值在第*k*阶段是可接受且正确的。如果协调员可能提议超过一个可能的值，则会选择一个
- en: arbitrarily.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 任意的。
- en: '276'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '276'
- en: CHapTer 6 early proToCols
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: The coordinator broadcasts a message of the form *E*( *lock*, *v*, *k*, *proof*),
    where the *proof* is composed of the set of signed messages *E*( *list*, *k*)
    received from the *n* − *t* processes that found *v* acceptable and proper.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 协调员广播的消息形式为*E*( *lock*, *v*, *k*, *proof*)，其中*proof*由*n*−*t*个发现*v*可接受且正确的过程发送的签名消息*E*(
    *list*, *k*)组成。
- en: '**Round 3: Round 4k – 1**'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3轮：第4k – 1轮**'
- en: If any process receives an *E*( *lock*, *v*, *k*, *proof*) message, it validates
    the proof to ascertain that *n* − *t* processors do find *v* acceptable and proper
    at phase *k*. If the proof is valid, it locks *v*, associating the phase number
    *k* and the message *E*( *lock*, *v*, *k*, *proof*) with the lock, and sends an
    acknowledgment to the current coordinator. In this
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何进程收到一条*E*( *lock*, *v*, *k*, *proof*)消息，它会验证证明以确保对*v*在阶段*k*可接受和正确的*n*−*t*个处理器。如果证明有效，它会锁定*v*，将阶段号*k*和消息*E*(
    *lock*, *v*, *k*, *proof*)与锁定关联，并向当前的协调员发送确认。在这个
- en: case, the processes release any earlier lock placed on *v*. If the coordinator
    receives acknowledgments from at least 2 *t* + 1 processors, then it decides on
    the value *v*.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，进程会释放对*v*的任何早期的锁定。如果协调员收到至少2*t* + 1个处理器的确认，则决定值*v*。
- en: '**Round 4: Round 4k**'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4轮：第4k轮**'
- en: This is where locks are released. Processes broadcast messages of the form
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 这是释放锁的地方。进程以以下形式广播消息
- en: '*E*( *lock v*, *h*, *proof*), indicating that they have a lock on value *v*
    with associated phase *h* and the associated proof and that a coordinator sent
    the message at phase *h*, which caused the lock to be placed. If any process has
    a lock on some value *v* with associated phase *h* and receives a properly signed
    message *E*( *lock*, *w*, *h*’, *proof*′) with *w* ≠ *v* and *h*′ ≥ *h*, then
    the process releases its lock on *v*. This means that if a most recent properly
    signed message is received by a process indicating a lock on some value which
    is different from'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*( *lock v*, *h*, *proof*)，表示它们对值*v*以及相应阶段*h*的锁定和相关证明，并且一个协调员在阶段*h*发送了消息，导致放置了锁。如果任何进程对某个值*v*有关联阶段*h*的锁定，并接收到一个正确签名的消息*E*(
    *lock*, *w*, *h*’, *proof*′)，其中*w* ≠ *v*且*h*’ ≥ *h*，那么该进程会释放对*v*的锁定。这意味着，如果某个进程收到了最近的正确签名消息，表示对一些不同的值的锁定。'
- en: its locally locked value and the phase number is either higher or equal to the
    current
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 其本地锁定值以及阶段编号要么高于要么等于当前编号。
- en: phase number, then it will release the lock from the local locked value.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段号，然后会释放本地锁定值的锁。
- en: '**Notes**'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: Assuming that the processes are correct, two different values cannot be locked
    in the
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 假设进程是正确的，那么两个不同的值不能被锁定在
- en: same phase because the correct coordinator will never send conflicting messages
    which
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的阶段，因为正确的协调员永远不会发送冲突的消息
- en: may suggest locks on two different values.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 可能暗示着对两个不同值的锁。
- en: This algorithm achieves consistency, strong unanimity, and termination under
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法实现了一致性，强一致性和终止
- en: partial synchrony, with Byzantine faults and authentication, where *n* ≥ 3 *t*
    + 1\.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步，带有拜占庭故障和认证，其中*n* ≥ 3*t* + 1。
- en: Authenticated Byzantine means that failures are arbitrary, but messages can
    be signed
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 认证拜占庭意味着故障是任意的，但消息可以签名
- en: with unforgeable digital signatures.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可伪造的数字签名。
- en: Consistency means no two different processes decide differently. Termination
    means
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性意味着没有两个不同的进程做出不同的决定。终止意味着
- en: every process eventually decides. Unanimity has two flavors, strong unanimity
    and weak
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程最终都会做出决定。一致性有两种口味，强一致性和弱一致性。
- en: unanimity. Strong unanimity requires that if all processes have the same initial
    value
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。强一致性要求如果所有进程都有相同的初始值
- en: v and if any correct process decides, then it only decides on v. Weak unanimity
    means
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: v并且如果任何正确的进程做出决定，则只会做出v的决定。弱一致性意味着
- en: that if all processes have the same initial value v and all processes are correct,
    then if any process decides, it decides on v. In other words, strong unanimity
    means that if all initial values are the same, for example, v, then v is the only
    common decision. Under weak
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有进程都有相同的初始值v，并且所有进程都是正确的，那么如果任何进程做出决策，则将在v上做出决策。换句话说，强一致性意味着如果所有初始值都相同，例如v，那么v是唯一的共同决定。在弱
- en: unanimity, this condition is expected to hold only if all processes are correct.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 一致，只有当所有进程都正确时，才预计会满足此条件。
- en: '277'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '277'
- en: CHapTer 6 early proToCols
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: '**Ben-Or Algorithms**'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ben-Or算法**'
- en: The Ben-Or protocol was introduced in 1983\. It is named after its author Michael
    Ben-
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: Ben-Or协议于1983年提出。这是以其作者Michael Ben-
- en: Or. This was the first protocol that solved the consensus problem with probabilistic
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 或。这是第一个使用概率解决共识问题的协议
- en: termination under a model with a strong adversary. The Ben-Or algorithm proposed
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有强对手的模型下终止。Ben-Or算法提出
- en: how to circumvent an FLP result and achieve consensus under asynchrony. There
    are
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 如何规避FLP结果并在异步情况下达成共识。有
- en: two algorithms proposed in the paper. The first algorithm tolerates *t* < *n*/2
    crash failures, and the second algorithm tolerates *t* < *n*/5 for Byzantine failures.
    In other words, with *N* > 2 *t* it tolerates crash faults and achieves an agreement,
    and with *N* > 5 *t* the protocol tolerates Byzantine faults and reaches an agreement.
    The protocol achieves consensus
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在论文中提出的两个算法。第一个算法容忍*t* < *n*/2次崩溃故障，第二个算法容忍*t* < *n*/5的拜占庭故障。换句话说，当*N* > 2*t*时，它容忍崩溃故障并达成一致，并且当*N*
    > 5*t*时，协议容忍拜占庭故障并达成一致。该协议实现了共识
- en: under the conditions described earlier, but the expected running time of the
    protocol
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述条件下，但是协议的预期运行时间
- en: is exponential. In other words, it requires exponential running time to terminate
    in the
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 是指数。换句话说，它需要指数运行时间才能在其中终止
- en: worst case because it can require multiple rounds to terminate. It can however
    terminate
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况下，因为可能需要多轮才能终止。但是它可以终止。
- en: in constant time if the value of *t* is very small, that is, *O*(√ *n*).
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 常数时间内如果*t*的值非常小，即*O*(√*n*)。
- en: This protocol works in asynchronous rounds. A round simulates time because all
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议在异步轮中运行。一轮模拟时间，因为所有
- en: messages are tagged with a round number, and because of this, processes can
    figure out
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 消息带有轮数标记，因此，即使它们以异步方式到达，进程也可以弄清楚
- en: which messages belong to which round even if they arrive asynchronously. A process
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些消息属于哪个轮次，即使它们是异步到达。一个进程
- en: ignores any messages for previous rounds and holds messages for future rounds
    in a
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略以前轮的任何消息，并将未来轮的消息保存在一个
- en: buffer. Each round has two phases or subrounds. The first is the proposal (suggestion)
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区。每轮有两个阶段或子轮。第一个是提案（建议）
- en: phase, where each process p transmits its value v and waits until it receives
    from other
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段，在此过程p将其值v传输并等待，直到从其他进程接收到
- en: '*n* − *t* processes. In the second phase, called the decision (ratification)
    phase, the protocol checks if a majority is observed and takes that value; otherwise,
    it flips a coin. If a certain threshold of processes sees the same majority value,
    then the decision is finalized. In'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* − *t* 过程。在第二阶段，即决策（批准）阶段中，协议检查是否观察到多数并采取该值；否则，它会抛硬币。如果一定数量的过程看到相同的多数值，那么决定就会最终确定。'
- en: case some other value is detected as a majority, then the processor switches
    to that
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 就会检测到其他值为多数，则处理器会切换到该
- en: value. Eventually, the protocol manages to terminate because at some point all
    processes
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 值。最终，该协议成功终止，因为在某个时刻所有进程
- en: will flip the coin correctly and reach the majority value. You may have noticed
    that this protocol only considers binary decision values, either a 0 or 1\. Another
    important aspect to keep in mind is that the protocol cannot wait indefinitely
    for all processes to respond because they could be unavailable (offline).
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 将正确翻转硬币并达到大多数值。您可能已经注意到，此协议仅考虑二进制决策值，即0或1。另一个需要注意的重要方面是协议不能无限期地等待所有进程响应，因为它们可能不可用（脱机）。
- en: This algorithm works only for binary consensus. There are two variables that
    need
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法仅适用于二进制共识。有两个需要的变量
- en: to be managed in the algorithm, a value which is either 0 or 1 and phase (p),
    which
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法中要管理一个值，要么是0，要么是1，以及相位（p）
- en: represents the stage where the algorithm is currently at. The algorithm proceeds
    in
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 代表算法当前所处的阶段。算法分为
- en: rounds, and each round has two subrounds or phases.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 轮次，并且每个轮次有两个子回合或阶段。
- en: '278'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '278'
- en: CHapTer 6 early proToCols
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章早期协议
- en: Note that each process has its own coin. This class of algorithms that utilize
    such
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个进程都有自己的硬币。这种类别的算法利用这样的
- en: coin scheme is called local coin algorithms. Local coin tossing is implemented
    using a
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地硬币算法实现局部硬币抛掷。局部硬币抛掷使用一个
- en: random number generator that outputs binary numbers. Each process tosses its
    own
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出二进制数字的随机数生成器。每个进程都抛掷自己的
- en: coin and outputs 0 or 1, each with probability ½. The coin is tossed by a process
    to pick a new local value if a majority was not found.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币，并以概率½输出0或1。进程抛掷硬币以选取新的本地值，如果没有找到大多数。
- en: '**The algorithm for benign faults/crash faults only – non-Byzantine:**'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '**只针对良性故障/崩溃故障的算法-非拜占庭式:**'
- en: 'Each process p executes the following algorithm:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程 p 执行以下算法：
- en: 'Process p: Initial value x = 0 or 1'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 进程 p：初始值 x = 0 或 1
- en: '**0:** set r = 1'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '**0:** 设置 r = 1'
- en: '**--First subround or phase – proposal phase**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '**-- 第一个子回合或阶段-提议阶段**'
- en: '**1:** Broadcast (1, r, x) to all processes including itself'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '**1:** 广播（1, r, x）给所有包括自身的进程'
- en: '**2:** Wait until messages of type (1,r,*) are received from n - t processes.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**2:** 等待直到从 n - t 个进程接收到类型为（1, r, *）的消息。'
- en: '**2(a):** If > n /2 messages received have the same value v, then'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(a):** 如果收到 > n /2 个相同值 v 的消息，则'
- en: '**--second subround or phase – decision phase**'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 第二子回合或阶段-决策阶段**'
- en: '**2(b):** Broadcast the message (2, r, v, D) to all processes'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(b):** 将消息（2，r，v，D）广播给所有进程'
- en: including itself.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 包括自身。
- en: '**2(c):** else broadcast the message (2, r, ?) to all processes'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(c):** 否则将消息（2, r, ?）广播给所有进程'
- en: including itself.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 包括自身。
- en: '**3:** Wait until messages of type (2, r, *) arrive from n - t processes.'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**3:** 等待从 n - t 个进程接收到类型为（2, r, *）的消息。'
- en: '**3(a):** If there is 1 D type messages (2, r, v, D), then vote v i.e'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(a):** 如果有 1 个 D 类型消息（2, r, v, D），则投票 v 即'
- en: set x = v
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 x = v
- en: '**3(b):** If there are > t, D type messages then decide v.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(b):** 并非 > t 个 D 类型消息，则决定 v。'
- en: '**3(c):** Else set x = 0 or 1 each with probability 1/2 by doing the'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(c):** 否则通过进行同等概率为 1/2 的投票将 x 设置为 0 或 1'
- en: coinflip
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: coinflip
- en: '**4:** Start the next round by setting r = r + 1 and go to 1\.'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '**4:** 通过设置 r = r + 1 开始下一轮并转到 1\.'
- en: Here, r is the round number; x is the initial preference or value proposed by
    the
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，r 是回合数；x 是由
- en: process; 1 is the first subround, round, or phase of the main round; 2 is the
    second
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 进程；1 是主回合的第一个子回合、回合或阶段；2 是第二
- en: subround, round, or phase of the main round; * can be 0 or 1; ? represents no
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 子回合、回合或阶段的主回合；* 可以是0或1；？代表没有
- en: majority observed; N is the number of nodes (processes); D is an indication
    of approval
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到大部分；N 是节点（进程）的数量；D 是一个批准的指示
- en: (ratification) – in other words, it is an indication that the process has observed
    a majority of the same value – t is the number of faulty nodes; v is the value;
    and coinflip() is a
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: （ratification）- 换句话说，这表明该进程已观察到大部分相同的值- t 是故障节点的数量；v 是值；coinflip() 是一个
- en: uniform random number generator that generates either 0 or 1\.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成0或1的均匀随机数生成器\。
- en: We can visualize this protocol in the diagram shown in Figure [6-8](#p296).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图 [6-8](#p296) 中显示的图表中可视化该协议。
- en: '279'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '279'
- en: '![](index-296_1.png)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![](index-296_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章早期协议
- en: '***Figure 6-8\.** Ben-Or crash fault tolerant only agreement protocol – (non-Byzantine)*
    If *n* > 2 *t*, the protocol guarantees with probability 1 that all processes
    will eventually decide on the same value, and if all processes start with the
    value *v*, then within one round all processes will decide on *v*. Moreover, if
    in some round a process decides on *v* after receiving more than *t* D type messages,
    then all other processes will decide on *v* within the next round.'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-8\.** Ben-Or仅崩溃容错一致性协议-（非拜占庭）* 如果*n* > 2 *t*，该协议有1的概率保证所有进程最终决定相同的值，并且如果所有进程从值*v*开始，则在一轮内所有进程将决定*v*。此外，如果在某一轮中的进程在收到超过*t*的D类型消息之后决定*v*，则在下一轮内所有其他进程将决定*v*。'
- en: The protocol described earlier works for crash faults; for tolerating Byzantine
    faults,
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的协议适用于崩溃故障；为容忍拜占庭故障，
- en: slight modifications are required, which we describe next.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行微小的修改，我们接下来进行描述。
- en: '280'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '280'
- en: CHapTer 6 early proToCols
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: '**The Ben-Or algorithm for Byzantine faults:**'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ben-Or算法用于拜占庭故障：**'
- en: 'Each process p executes the following algorithm:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程p执行以下算法：
- en: 'Process p: Initial value x = 0 or 1'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 进程p：初始值x = 0或1
- en: '**0:** set r = 1'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '**0:** 设置r = 1'
- en: '**--First subround or phase – proposal phase**'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 第一子轮次或阶段 - 提案阶段**'
- en: '**1:** Broadcast (1, r, x) to all processes including itself'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**1:** 向所有进程（包括自身）广播（1，r，x）'
- en: '**2:** Wait until messages of type (1,r,*) are received from N - t processes.'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**2:** 等待来自N - t进程的类型（1，r，*）的消息。'
- en: '**2(a):** If more than (N + t)/2 messages have the same value v, then'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(a):** 如果超过（N + t）/2个消息具有相同的值v，则'
- en: '**--second subround or phase – decision phase**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 第二个子轮次或阶段 - 决策阶段**'
- en: '**2(b):** Broadcast the message (2, r, v, D) to all processes'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(b):** 向所有进程广播消息（2, r, v, D）'
- en: including itself.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 包括自身。
- en: '**2(c):** else Broadcast the message (2, r, ?) to all processes'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**2(c):** 否则，向所有进程广播消息（2，r，?）'
- en: including itself.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 包括自身。
- en: '**3:** Wait until messages of type (2, r, *) arrive from n - t processes.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '**3:** 等待来自n - t进程的类型为（2, r, *）的消息到达。'
- en: '**3(a):** If there are at least t + 1 D type messages (2, r, v, D), then'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(a):** 如果至少有t + 1个D类型的消息（2, r, v, D），那么'
- en: vote v i.e set x = v
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 投票v，即设置x = v
- en: '**3(b):** If there are more than (n + t)/2 D type messages then decide v.'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(b):** 如果有超过（n + t）/2个D类型的消息，则决定v。'
- en: '**3(c):** Else set x to 0 or 1 each with probability 1/2 by doing the'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**3(c):** 否则通过做的1/2的概率将x设置为0或1'
- en: coinflip
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: coinflip
- en: '**4:** Start the next round by setting r = r + 1 and go to 1\.'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**4:** 通过设置r = r + 1开始下一轮，然后转到1\。'
- en: Here, r is the round number; x is the initial preference or value proposed by
    the
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，r是轮次编号；x是由发起进程提出的初始偏好或值
- en: process; 1 is the first subround, round, or phase of the main round; 2 is the
    second
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 进程；1是主轮次的第一子轮次，轮次或阶段；2是主轮次的第二
- en: subround, round, or phase of the main round; * can be 0 or 1; ? represents no
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 子轮次，轮次或阶段的主轮次；*可能为0或1；？表示没有
- en: majority observed; N is the number of nodes (processes); D is an indication
    of approval
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到的多数；N是节点（进程）的数量；D是批准的指示
- en: (ratification) – in other words, it is an indication that the process has observed
    a majority of the same value – t is the number of faulty nodes; v is the value;
    and coinflip() is a
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: （认证）- 换句话说，这是表明进程观察到了大多数相同值的指示- t是有故障的节点数；v是值；coinflip()是一种均匀随机数生成器，生成0或1。
- en: uniform random number generator that generates either 0 or 1\.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 生成均匀随机数的生成器，生成0或1\。
- en: We can visualize this protocol in Figure [6-9](#p298).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图[6-9](#p298)中可视化这个协议。
- en: '281'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '281'
- en: '![](index-298_1.png)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![](index-298_1.png)'
- en: CHapTer 6 early proToCols
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: '***Figure 6-9\.** Ben-Or Byzantine agreement protocol*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-9\.** Ben-Or拜占庭一致性协议*'
- en: In the first subround or phase of the protocol, every process broadcasts its
    proposed
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议的第一子轮次或阶段中，每个进程都广播其提出的
- en: '*n* + *t*'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* + *t*'
- en: preferred value and awaits *n* − *t* messages. If more than
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 首选值并等待*n* - *t*的消息。如果超过
- en: processes agree, then a
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 进程同意，然后
- en: '2'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: majority is achieved, and the preferred value is set accordingly.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了大多数，根据情况设置首选值。
- en: In the second subround or phase of the protocol, if a majority is observed in
    the first
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议的第二个子轮次或阶段中，如果在第一个子轮次中观察到多数
- en: subround, then an indication of majority is broadcast (2, *r*, *v*, *D*); otherwise,
    if no majority (?) was observed in the first subround, then no majority is broadcast.
    The protocol then
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 子轮次，然后广播大多数的指示（2，*r*，*v*，*D*）；否则，如果在第一个子轮次中没有观察到大多数（？），则不会广播大多数。然后协议
- en: waits for *n* – *t* confirmations. If at least *t* + 1 confirmations of a majority
    of either 0 or 1
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 *n* – *t* 个确认。如果至少 *t* + 1 个确认多数为 0 或 1
- en: are observed, then the preferred value is set accordingly. Here, only the preferred
    value *n* + *t*
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 被观察到，那么首选的值会相应地设置。这里，只有首选的值 *n* + *t*
- en: is set, but no decision is made. A decision is made by p if more than
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 被设置，但没有做出决定。如果超过
- en: confirmations
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 确认
- en: '2'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '*n* + *t*'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* + *t*'
- en: are received, only then the value is decided. If neither *t* + 1 confirmations
    nor
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到*t* + 1个确认后，才会决定价值。如果既没有 *t* + 1 个确认，也没有
- en: '2'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: confirmations are received, then the coin is flipped to choose a uniform random
    value,
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 确认收到 *t* + 1 条后，就会抛硬币选择一个统一的随机值，
- en: either 0 or 1\.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 为 0 或 1\。
- en: '282'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '282'
- en: CHapTer 6 early proToCols
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章早期协议
- en: Note that, by waiting for *n* – *t* messages, the Byzantine fault case where
    Byzantine processes maliciously decide not to vote is handled. This is because
    in the presence of t faults, at least n is honest. In the second subround, *t*
    + 1 confirmations of a majority value *n* + *t*
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过等待 *n* – *t* 条消息，处理拜占庭故障的情况被处理了，即拜占庭进程恶意决定不投票。这是因为在存在 t 个故障的情况下，至少有 n
    个是诚实的。在第二个子轮中，多数值 *n* + *t* 的 *t* + 1 个确认
- en: mean that at least one honest process has observed a majority. In the case of
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着至少有一个诚实的进程观察到了多数派。在
- en: ', it'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: ，它
- en: '2'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: means a value has been observed by a majority.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着多数人观察到了某个值。
- en: So, in summary, if *n* > 5 *t*, this protocol guarantees with probability 1
    that all processes will eventually decide on the same value, and if all processes
    start with the
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，如果 *n* > 5 *t*，这个协议肯定以 1 的概率保证所有进程最终决定相同的值，并且如果所有进程从头开始
- en: value v, then within one round all processes will decide on *v*. Moreover, if
    in some round ( *n* + *t*)
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v，那么在一轮内所有进程都会决定 *v*。此外，如果在某一轮内（ *n* + *t*）
- en: an honest process decides on v after receiving more than
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个诚实的进程在收到超过
- en: D type messages, then
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: D 类型的消息，那么
- en: '2'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: all other processes will decide on v within the next round.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他进程将在下一轮内对 v 做出决策。
- en: '*Note that I have used t to denote faulty processes, which is in line with
    the original* *paper on the subject. However, in literature f is also widely used
    to denote faults, either* *Byzantine or crash. So, t + 1 or f + 1 means the same
    thing, as t and f denote the same thing.*'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我使用 t 来表示故障进程，这符合原始论文上的内容。然而，在文献中也有广泛使用 f 来表示故障，无论是拜占庭故障还是崩溃。因此，t + 1
    或 f + 1 意思相同，因为 t 和 f 指代的是同一件事情。*'
- en: Now the question arises as to how this protocol achieves an agreement, validity,
    and
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，该协议如何实现一致性、有效性和
- en: termination. Let’s try to answer these questions.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 终止。让我们试着回答这些问题。
- en: An agreement is possible because at most one value can be in a majority in the
    first
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是可能的，因为第一轮中最多只能有一个值属于多数
- en: phase (subround) of the main round. If some process observes the *t* + 1 D type
    message (ratification message of the form (2, r, v, D)), then every process observes
    at least one ratification message of the form (2, r, v, D). Finally, if every
    process sees a ratification message of the form (2, r, v, D), then every process
    votes for value v (accepts value v)
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段（子轮）的主轮。如果某个进程观察到 *t* + 1 个 D 类型消息（形式为 (2, r, v, D) 的认证消息），那么每个进程至少观察到形式为
    (2, r, v, D) 的认证消息。最后，如果每个进程都看到形式为 (2, r, v, D) 的认证消息，那么每个进程都会为值 v 投票（接受值 v）
- en: in the first subround (phase) of r + 1 and decides on v in the second subround
    (phase)
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一轮（阶段）中决定 v 并在第二轮（阶段）中决定 v
- en: unless it has decided already.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 除非它已经做出了决定。
- en: Validity is possible because if all processes vote for (accept) their common
    value v in
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 有效性是可能的，因为如果所有进程在
- en: a round, then all processes broadcast (2, r, v, D) and decide in the second
    subround of
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 一轮，然后所有进程广播 (2, r, v, D) 并在第二个子轮中决定
- en: the round. Also, note that the preferred value of only one of the processes
    is broadcast in the first subround of the round.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 该轮内为它们共同的值 v 投票（接受），那么一致性是可能的。此外，请注意，只有一个进程的首选值在该轮的第一子轮中被广播。
- en: The reason why Ben-Or terminates is because eventually the majority of the
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: Ben-Or 终止的原因是因为最终大多数
- en: nonfaulty processes will flip a coin to achieve the same random value. This
    majority
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 非故障进程将掷硬币以获得相同的随机值。这个多数
- en: value is then observed by the honest processes, which then propagate the D type
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 值被诚实的进程观察到，然后传播类型为 D 的信息
- en: message (ratification message) with the majority value. Eventually, honest processes
    will receive the D type message (ratification message), and the protocol will
    terminate.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 消息（认证消息）与大多数值。最终，诚实的进程将收到D型消息（认证消息），协议就会终止。
- en: Also, note that the reason why two subrounds are required is because in the
    first
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意所需两个子轮的原因是由于在第一
- en: phase the number of preferred value proposals is reduced to at most one, and
    then in the
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段中，首选值提案的数量最多减少至一个，然后在
- en: second subround, a simple majority vote is sufficient to make the decision.
    It is possible to design a consensus algorithm with only one round, but that will
    require a minimum
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子轮，简单的多数投票就足以做出决定。可以设计一个仅需一轮的共识算法，但这需要一个最小的
- en: '283'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '283'
- en: CHapTer 6 early proToCols
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章 早期协议
- en: number of processes to be 3 *f* + 1\. With two rounds under asynchrony, the
    2 *f* + 1 lower bound is met.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的数量为3 * f * + 1.在异步情况下，通过两轮，满足了2 * f * + 1的下界。
- en: The Ben-Or algorithms described earlier do not use any cryptographic primitives
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 早期描述的Ben-Or算法并不使用任何密码原语
- en: and assume strong adversary. However, a lot of work has also been carried out
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 并假设强对手。然而，也开展了大量的工作
- en: where an asynchronous Byzantine agreement is studied under the availability
    of
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步拜占庭协议可用的情况下
- en: cryptographic primitives. Of course, under this model the adversary is assumed
    to be
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 密码原语。当然，根据这个模型，假定对手是
- en: always computationally bounded. Some prominent early protocols under this model
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 总是计算上有限的。在这种模型下的著名的早期协议
- en: are described earlier, such as the signed message protocol and the DLS protocol
    for the
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如使用带有签名消息协议和DLS协议的内容。
- en: authenticated Byzantine failure model. There are other algorithms that process
    coin
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 签名的拜占庭故障模型。还有其他处理硬币的算法
- en: tosses cooperatively or, in other words, use global or shared coin tossing mechanisms.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 以合作方式抛掷，或者换句话说，使用全局或共享的抛硬币机制。
- en: A shared coin or global coin is a pseudorandom coin that produces the same result
    at
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个共享的或全局的硬币是一种产生相同结果的伪随机硬币
- en: all processes in the same round. This attribute immediately implies that convergence
    is
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有同一轮的进程。这个属性立即意味着收敛
- en: much faster in the case of shared coin–based mechanisms. A similar technique
    was first
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享硬币机制下，速度要快得多。这种技术最早
- en: used in Rabin’s algorithm [14] utilizing cryptographic techniques which reduced
    the
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rabin算法中使用了[14]，利用减少
- en: expected time to the constant number of rounds.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 预期时间到达常数轮次。
- en: After this basic introduction to early consensus protocols, I’ll now introduce
    early
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种早期共识协议的基本介绍之后，我现在将介绍早期
- en: replication protocols, which of course are fundamentally based on consensus,
    but can be
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 复制协议，当然基本上是基于共识的，但可以
- en: classified as replication protocols rather than just consensus algorithms.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 划分为复制协议而不仅仅是共识算法。在
- en: We saw earlier, in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3),
    that replication allows multiple replicas to achieve consistency in a distributed
    system. It is a method to provide high availability in a
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们已经看到，在第[三章](https://doi.org/10.1007/978-1-4842-8179-6_3)，复制使得多个复本在分布式系统中实现一致性。这是提供高可用性的方法。
- en: distributed system. There are different models including primary backup replication
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统。包括主备份复制在内的不同模型
- en: and active replication. You can refer to Chapt[er 3 t](https://doi.org/10.1007/978-1-4842-8179-6_3)o
    read more about state machine replication and other techniques.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 和主动复制。你可以参考第[三章](https://doi.org/10.1007/978-1-4842-8179-6_3)来了解更多关于状态机复制和其他技术。
- en: '**Consensus Using Failure Detectors**'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用故障检测进行共识**'
- en: We discussed failure detectors and its different classes earlier in Chapt[er
    3\. H](https://doi.org/10.1007/978-1-4842-8179-6_3)ere, we present the outline
    of an algorithm called the *Chandra-Toueg consensus protocol* to solve consensus
    using an eventually strong ⋄ *S* failure detector, which is the weakest failure
    detector for solving consensus [10]. Recall that an eventually strong failure
    detector
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[三章](https://doi.org/10.1007/978-1-4842-8179-6_3)中讨论了故障检测器及其不同的类别。在这里，我们介绍了一种称为*Chandra-Toueg一致性协议*的算法，使用最终强⋄*S*故障检测器来解决共识问题。这是用于解决共识问题的最弱的故障检测器。记得最终强故障检测器
- en: satisfies strong completeness and eventual weak accuracy properties.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 满足强完备性和最终的弱精度属性。
- en: 
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: This protocol considers an asynchronous network model with *f*
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议考虑了异步网络模型与*f*
- en: '*n*'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*'
- en: <  2 , that is, with at
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: <  2 ，即，在
- en:  *n* +1
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* +1
- en: least
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的
- en: correct processes. Less than *n*/2 failed process assumption allows processes
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的进程。少于*n*/2 失败进程的假设使进程能够
- en:  2 
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh:  2 
- en: to wait to receive majority responses regardless of what the failure detector
    is suspecting.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 等待收到大多数响应，无论故障检测器怀疑的是什么。
- en: '284'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '284'
- en: CHapTer 6 early proToCols
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章早期协议
- en: The protocol works in rounds under asynchrony with a rotating coordinator. The
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议在异步的条件下工作，并且有一个轮转的协调者。这个
- en: protocol uses reliable broadcast which ensures that any message broadcast is
    either not
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 协议使用可靠广播来确保所广播的任何消息要么不是
- en: received (delivered) at all by any process or exactly once by all honest processes.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 被任何进程接收（交付）或者被所有诚实的进程只接收一次。
- en: The algorithm works as follows.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 算法工作如下。
- en: 'Each process maintains some variables:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都维护一些变量：
- en: • Estimate of the decision value – proposed value
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: • 决定值的估计—提议的值
- en: • State
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: • 状态
- en: • Process’s current round number
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: • 进程当前的轮次号
- en: • Last round in which the process updated its estimate (preference)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: • 过程更新其估计（优先级）的最后一轮。
- en: Until the state is decided, the processes go through multiple incrementing
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 直到状态被决定，进程会通过多次递增
- en: asynchronous rounds each divided into four phases or subrounds, and coordinators
    are
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的轮次分成四个阶段或子轮次，并且协调者们是
- en: rotated until a decision is reached. Coordinators are chosen in a round-robin
    fashion
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 以轮换的方式选择协调者直到达成决定。协调者
- en: 'using the formula ( *r mod n*) + 1, where *r* is the current round number,
    and *n* is the total number of processes:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式（*r mod n*） +1，这里*r*是当前轮次号，*n*是总进程数：
- en: 1\. All processes send their estimate (preference) to the current
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.所有进程向当前发送其估计（首选）。
- en: coordinator using a message of type (process id, current round
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息类型（进程id，当前轮
- en: number, estimate, round number when the sender updated its
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送方更新其广播接受和决定该值时的数字、估计、轮数。
- en: estimate).
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 估计）。
- en:  *n* +1
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* +1
- en: 2\. The current coordinator waits to collect a majority  2 
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.当前协调者等待收集大多数 2 
- en: estimates and chooses the proposed value with the most recent
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 估计，并选择了最新提议的值
- en: (largest) value of the last updated round as its estimate and then
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: （最大）最后更新的轮次作为其估计值，然后
- en: proposes the new estimate to all processes.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 提议了新的估计值给所有进程。
- en: 3\. Each process waits for the new proposal (estimate) from the
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.每个进程都在等待从新提案（估计）。
- en: current coordinator or for the failure detector to suspect the
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的协调者或者故障检测器怀疑
- en: current coordinator. If it receives a new estimate, it updates its
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的协调者。如果它收到了新的估计值，它会更新它的
- en: preference, updates the last round variable to the current round,
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级，更新最后一轮的变量为当前轮次，
- en: and sends the ack message to the current coordinator. Otherwise,
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 并向当前的协调者发送ack消息。否则，
- en: it sends *nack*, suspecting that the current coordinator has crashed.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 它发送了*nack*，怀疑当前的协调者已经崩溃。
- en: '285'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '285'
- en: CHapTer 6 early proToCols
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章早期协议
- en:  *n* +1
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* +1
- en: 4\. The current coordinator waits for the 
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 当前的协调者等待
- en: – that is, a majority of
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '- 也就是说，大多数'
- en: 2 
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 2 
- en: replies from processes, either *ack* or *nack*. If the current coordinator
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 来自进程的回复，要么*ack*要么*nack*。 如果当前的协调者
- en:  *n* +1
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* +1
- en: receives a majority of acks, meaning 
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 收到了大多数的ack，意味着
- en: has accepted its
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 已经接受了其
- en: 2 
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 2 
- en: estimate, then the estimate is locked, and the coordinator does a
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 估计，然后估计被锁定，协调者做了个
- en: reliable broadcast of the decide message (decided value).
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠地广播决定消息（决定的值）。
- en: • Finally, any undecided process that delivers a value via the reliable
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: • 最后，任何未决定的进程通过可靠的方式交付一个值
- en: broadcast accepts and decides on that value.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 广播接受并决定该值。
- en: Note that there are other algorithms in the paper [10] as well, but I have described
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本文[10]中还有其他算法，但我已经描述了
- en: here only the one that solves consensus using an eventually strong failure detector.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个使用最终强故障探测器解决共识的。
- en: Now let’s see how agreement, validity, and termination requirements are met.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一下一致性、有效性和终止条件是如何满足的。
- en: The **agreement** is satisfied. Let’s think about a scenario where it is possible
    that two coordinators broadcast, and some processes end up accepting a value from
    the first
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性**得以满足。让我们考虑一个可能的情景，即两个协调者广播，一些进程最终接受了来自第一个'
- en: coordinator and some from the other. This will violate the agreement because,
    here,
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 协调者和一些来自其他。这将违反一致性，因为在这里，
- en: two processes are deciding differently, that is, two different values are both
    chosen.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 两个进程在决定时有不同的选择方式，也就是说，两个不同的值都被选择。
- en: However, this cannot occur because for the first coordinator to send a decision,
    it must
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不可能发生，因为对于第一个协调者发送决定，它必须
- en: have received enough acknowledgments (acks) from the majority of the processes.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 已经收到足够多的确认（acks）来自大多数进程。
- en: All subsequent coordinators looking for the majority will see an overlap with
    the
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后续找到大多数的协调者将与之重叠
- en: previous one. The estimate will be the most recent one. As such, any two coordinators
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个。 估计将是最近的一个。因此，任何两个协调者
- en: broadcasting the decision are sending out the same decision.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 广播决定正在发送相同的决定。
- en: '**Validity** is also satisfied because every estimate is some process’s input
    value. The protocol design does not allow generating any new estimates.'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效性**也得到满足，因为每个估计值都是某个进程的输入值。协议设计不允许生成任何新的估计值。'
- en: The protocol eventually **terminates** because the failure detector, an eventually
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 协议最终**终止**是因为故障检测器，最终
- en: strong failure detector, will eventually stop suspecting some correct process,
    which
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 强故障检测器，最终将停止怀疑一些正确的进程，而
- en: will eventually become the coordinator. With the new coordinator, in some round,
    all
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 最终将成为协调者。有了新的协调者，在某一轮中，所有
- en: correct processes will wait to receive this new coordinator’s estimate and will
    respond
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的进程将等待接收这个新的协调者的估计，并将做出回应
- en: with enough ack messages. When the coordinator collects the majority of ack
    messages,
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 带有足够的ACK消息。当协调者收集到大多数ACK消息时
- en: it will send its decided estimate to all, and all processes will terminate.
    Note that if
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 它将向所有人发送其决定的估计值，并且所有进程都将终止。请注意，如果
- en: some process ends up waiting for a response from an already terminated process,
    it
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进程最终等待来自已经终止的进程的响应，
- en: will also eventually get the message by retransmission through other correct
    nodes and
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 最终也会通过其他正确的节点和重传得到消息
- en: eventually decide and terminate. For example, suppose a process gets stuck waiting
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 最终决定和终止。例如，假设一个进程陷入等待
- en: for messages from a crashed coordinator. Eventually, due to the strong completeness
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自崩溃协调者的消息。最终，由于强制性的完成
- en: property of the eventually strong failure detector, the failed coordinator will
    be
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 最终强故障检测器的属性，失败的协调者将会
- en: suspected, ensuring progress.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑，确保进展。
- en: '286'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '286'
- en: CHapTer 6 early proToCols
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: CHapTer 6早期协议
- en: '**Summary**'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: This chapter covered early protocols that provide a solid foundation for most
    of the
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了早期协议，为大多数提供了坚实的基础
- en: consensus research done today. With the advent of blockchains, many of these
    protocols
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的共识研究。随着区块链的出现，许多这些协议
- en: inspired the development of new blockchain age protocols, especially for permissioned
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 激发了新的区块链时代协议的发展，特别是针对授权的
- en: blockchains. For example, Tendermint is based on the DLS protocol, that is,
    algorithm 2
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。例如，Tendermint基于DLS协议，即算法2
- en: from the DLS paper.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 来自DLS论文。
- en: We did not discuss every algorithm in this chapter, but this chapter should
    provide
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在本章中讨论每个算法，但本章应提供
- en: readers with a solid foundation to build on further. To circumvent FLP impossibility,
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 给读者提供了一个坚实的基础来进一步建立。为了规避FLP的不可能性，
- en: randomness can be introduced into the system by either assuming the randomized
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过假设随机化的方式将随机性引入系统
- en: model or local coin flips at the processes. The first proposal that assumes
    a randomized
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 模型或本地硬币翻转进程。假设第一个假设随机化
- en: model (also called fair scheduling, randomized scheduling) mechanism is by Bracha
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 模型（也称为公平调度，随机调度）机制是由Bracha提出的
- en: and Toueg [17]. Algorithms based on the second approach where processes are
    provided
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 和Toueg [17]。基于第二种方法的算法，其中提供进程
- en: with a local coin flip operation were first proposed by Ben-Or [2], which is
    the first
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地硬币翻转操作首先是由Ben-Or [2]提出的，这是第一个
- en: randomized consensus protocol. The first approach to achieve the expected constant
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化共识协议。实现预期的常数的第一种方法
- en: number of rounds by using the shared coin (global coin) approach implemented
    using
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用
- en: digital signatures and a trusted dealer is published in Rabin [14]. Protocols
    utilizing
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名和信任的经销商是由Rabin [14]发布的。利用协议
- en: failure detectors were proposed by Chandra and Toueg [15]. An excellent survey
    of
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: Chandra和Toueg [15]提出了故障检测器的许多优秀调查。一个优秀的调查
- en: randomized protocols for asynchronous consensus is by Aspnes [16].
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 异步一致性的随机化协议由 Aspnes [16] 提出。
- en: Randomized protocols are a way to circumvent an FLP result, but can we refute
    the
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化协议是规避 FLP 结果的一种方法，但我们能反驳
- en: FLP impossibility result altogether? Sounds impossible, but we’ll see in Chapter
    [9](https://doi.org/10.1007/978-1-4842-8179-6_9) that refuting the FLP result
    might be possible.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 9 的第[9](https://doi.org/10.1007/978-1-4842-8179-6_9) 章中我们将看到反驳 FLP 不可能性结果。听起来不可能，但我们将在第9
    章中看到。
- en: In the next chapter, we will cover classical protocols such as PBFT, which is
    seen as a
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论经典协议，如 PBFT，这被视为
- en: natural progression from the viewstamped replication (VR) protocol, which we
    will also
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 从已有的 VR 协议发展而来，我们也将
- en: introduce in the next chapter. While VR dealt with crash faults only, PBFT also
    dealt with Byzantine faults. We’ll cover other protocols, too, such as Paxos,
    which is the foundation of most if not all consensus protocols. Almost all consensus
    algorithms utilize the
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章介绍的。虽然 VR 仅处理崩溃故障，PBFT 也处理了拜占庭故障。我们还将讨论其他协议，如 Paxos，这是大多数共识协议的基础。几乎所有共识算法都利用
- en: fundamental ideas presented in Paxos in one way or another.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos 中提出的基本思想以一种或多种方式出现。
- en: '**Bibliography**'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: 1\. Impossibility of distributed consensus with one faulty process
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 具有一个故障进程的分布式一致性的不可能性
- en: J. Assoc. Computer. Mach., 32 (No. 2) (1985), pp. 374–382\.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: J. Assoc. Computer. Mach., 32 (No. 2) (1985), pp. 374–382\.
- en: '2\. M. Ben-Or: Another advantage of free choice: Completely'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. M. Ben-Or: 自由选择的另一个优势：完全'
- en: asynchronous agreement protocols.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 异步一致性协议。
- en: '287'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '287'
- en: CHapTer 6 early proToCols
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章 早期协议
- en: 3\. L. Lamport, R. Shostak, M. Pease, the Byzantine Generals
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. L. Lamport, R. Shostak, M. Pease, 拜占庭将军
- en: problem, ACM Transactions on Programming Languages and
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 问题,” ACM 编程语言和
- en: Systems, vol. 4 (no. 3) (1982), pp. 382–401, July 1982\.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 系统, vol. 4 (no. 3) (1982), pp. 382–401, 1982 年 7 月.
- en: 4\. Lampson, Butler, and Howard E. Sturgis. “Crash recovery in a
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. Lampson, Butler, 和 Howard E. Sturgis. “崩溃恢复
- en: distributed data storage system.” (1979).
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式数据存储系统.” (1979).
- en: 5\. Skeen, D., 1981, April. Nonblocking commit protocols. In
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. Skeen, D., 1981, 四月. 非阻塞提交协议。 在
- en: Proceedings of the 1981 ACM SIGMOD international conference
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 1981 年 ACM SIGMOD 国际会议论文集
- en: on Management of data (pp. 133–142).
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据管理的(p. 133–142).
- en: 6\. Dwork, C., Lynch, N., and Stockmeyer, L., 1988\. Consensus in the
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. Dwork, C., Lynch, N., 和 Stockmeyer, L., 1988\. 共识
- en: presence of partial synchrony. Journal of the ACM (JACM), 35(2),
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步的情况下。ACM 杂志（JACM），35(2),
- en: pp. 288–323\.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: pp. 288–323\.
- en: 7\. G. Bracha, “Asynchronous Byzantine agreement protocols,” Inf.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. G. Bracha, “异步的拜占庭协议,” 信息。
- en: Comput., 1987\.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: Comput., 1987\.
- en: 8\. S. Toueg, “Randomized Byzantine agreements,” in PODC, 1984\.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. S. Toueg, “随机化的拜占庭协议,” in PODC, 1984\.
- en: 9\. G. Bracha and S. Toueg, “Resilient consensus protocols,” in
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. G. Bracha 和 S. Toueg, “弹性一致性协议,” in
- en: PODC, 1983\.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: PODC, 1983\.
- en: 10\. Chandra, T.D. and Toueg, S., 1996\. Unreliable failure detectors for
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. Chandra, T.D. 和 Toueg, S., 1996\. 不可靠的故障检测器
- en: reliable distributed systems. Journal of the ACM (JACM), 43(2),
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的分布式系统。ACM 杂志（JACM）, 43(2),
- en: pp. 225–267\.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: pp. 225–267\.
- en: 11\. Martin Kleppmann’s lectures on distributed computing –
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. Martin Kleppmann 的分布式计算讲座 -
- en: Kleppmann, M., 2018\. Distributed systems[. www.cl.cam.ac.uk/](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: Kleppmann, M., 2018\. 分布式系统[. www.cl.cam.ac.uk/](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)
- en: '[teaching/2021/ConcDisSys/dist-sys-notes.pdf](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '[teaching/2021/ConcDisSys/dist-sys-notes.pdf](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)'
- en: '12\. Distributed Algorithms: A Verbose Tour – by Fourre Sigs.'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. 分布式算法：冗长之旅 - Fourre Sigs 撰写.
- en: '13\. Lindsey Kuper – lectures on distributed systems[: https://](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '13\. Lindsey Kuper – 讲授分布式系统[: https://](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
- en: '[youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCv](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '[youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCv](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
- en: '[nn5I_exhYx](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '[nn5I_exhYx](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
- en: 14\. Rabin, M.O., 1983, November. Randomized Byzantine generals.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 14\. Rabin, M.O., 1983, 十一月. 随机化的拜占庭将军。
- en: In 24th annual symposium on foundations of computer science
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学基础研究年会第24 届年度
- en: (sfcs 1983) (pp. 403–409). IEEE.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: （sfcs 1983) (p. 403–409). IEEE.
- en: '288'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '288'
- en: CHapTer 6 early proToCols
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章 早期协议
- en: 15\. Chandra, T.D. and Toueg, S., 1996\. Unreliable failure detectors for
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 15. Chandra, T.D. and Toueg, S., 1996. 不可靠的故障检测器
- en: reliable distributed systems. Journal of the ACM (JACM), 43(2),
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的分布式系统。 ACM杂志（JACM），43(2)，
- en: pp. 225–267\.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: pp. 225–267\.
- en: 16\. Aspnes, J., 2003\. Randomized protocols for asynchronous
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 16. Aspnes, J., 2003. 异步随机化协议
- en: consensus. *Distributed Computing*, *16*(2), pp. 165–175\.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。 *分布式计算*，*16*(2), pp. 165–175\.
- en: 17\. Bracha, G. and Toueg, S., 1985\. Asynchronous consensus
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 17. Bracha, G. and Toueg, S., 1985. 异步一致
- en: and broadcast protocols. *Journal of the ACM (JACM)*, *32*(4),
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 和广播协议。 *ACM杂志（JACM）*，*32*(4),
- en: pp. 824–840\.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: pp. 824–840\.
- en: '289'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '289'
- en: '**CHAPTER 7**'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '**第七章**'
- en: '**Classical Consensus**'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**经典一致性**'
- en: Consensus and replication protocols that appeared in the 1980s have made profound
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在1980年代的一致性和复制协议产生了深远的影响
- en: contributions in consensus protocol research. Early replication protocols like
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性协议研究方面的贡献。 早期的复制协议，例如
- en: viewstamped replication provided deep insights into how fault-tolerant replication
    can
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 视图复制提供了深刻的见解，说明容错复制如何能够
- en: be designed and implemented. Around the same time, Paxos was introduced, which
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实施。 同时，Paxos也被介绍, 它
- en: offered a practical protocol with rigorous formal specification and analysis.
    In 1999,
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个具有严格的正式规范和分析的实用协议。 1999年，
- en: the first practical Byzantine fault–tolerant protocol was introduced. This chapter
    covers these classical protocols in detail, their design, how they work, and how
    they provide
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实际的拜占庭容错协议被介绍。 本章详细介绍了这些经典协议，它们的设计，工作原理以及它们如何提供
- en: safety and liveness guarantees. Moreover, some ideas on how and if we can use
    them in
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和活性保证。 此外，关于如何以及是否可以在中使用它们的一些想法
- en: the blockchain are also presented. Additionally, recently developed protocols
    such as
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链也呈现出来。 此外，最近开发的协议，例如
- en: RAFT are also discussed, which builds on previous classical protocols to construct
    an
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: RAFT也被讨论了，它建立在之前的经典协议基础上构建了一个
- en: easy-to-understand consensus protocol.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 易于理解的一致性协议。
- en: '**Viewstamped Replication**'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图复制**'
- en: A viewstamped replication approach to replicate among peers was introduced by
    Brian
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: Brian引入了一种基于视图的复制方法
- en: Oki and Barbara Liskov in 1988\. This is one of the most fundamental mechanisms
    to
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: Oki和Barbara Liskov在1988年。 这是最基本的机制之一
- en: achieve replication to guarantee consistency (consistent view) over replicated
    data. It
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 实现复制以保证一致性（一致视图）
- en: works in the presence of crash faults and network partitions; however, it is
    assumed that eventually nodes recover from crashes, and network partitions are
    healed. It is also a
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现崩溃故障和网络分区的情况下运行; 但是假设节点最终会从崩溃中恢复，并且网络分区会被修复。 它也是一个
- en: consensus algorithm because to achieve consistency over replicated data, nodes
    must
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性算法, 因为要实现复制数据的一致性，节点必须
- en: agree on a replicated state.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 同意复制状态。
- en: Viewstamped replication has two primary purposes. One is to provide a distributed
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 视图复制有两个主要目的。 一个是提供分布式
- en: system which is coherent enough that the clients see that as if they are communicating
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 系统足够一致，以至于客户端会感觉到自己在与系统通信
- en: with a single server. The other one is to provide state machine replication.
    State machine replication requires that all replicas start in the same initial
    state and operations are deterministic. With these requirements (assumptions),
    we can easily see that if all
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 同时提供单个服务器。 另一个是提供状态机复制。 状态机复制要求所有副本从相同的初始状态开始，并且操作是确定性的。 在有了这些要求（假设）之后，我们可以很容易地看到，如果所有
- en: replicas execute the same sequence of operations, then they will end up in the
    same
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 复制副本执行相同的操作序列，那么它们最终将处于相同的
- en: '291'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '291'
- en: © Imran Bashir 2022
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: © Imran Bashir 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_7](https://doi.org/10.1007/978-1-4842-8179-6_7#DOI)
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: I. Bashir, *区块链共识*, [https://doi.org/10.1007/978-1-4842-8179-6_7](https://doi.org/10.1007/978-1-4842-8179-6_7#DOI)
- en: Chapter 7 ClassiCal Consensus
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典一致性
- en: state. Of course, the challenge here is to ensure that operations execute in
    the same order at all replicas even in the event of failures. So, in summary the
    protocol provides fault tolerance and consistency. It is based on a primary backup
    copy technique.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 状态一致。 当然，挑战在于确保操作即使在发生故障时也会以相同的顺序在所有副本上执行。 所以，总的来说，该协议提供了容错和一致性。 它基于主备份副本技术。
- en: 'There are three subprotocols in the viewstamped replication (VR) protocol:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 视图复制（VR）协议中有三个子协议：
- en: '• **Normal operation protocol**: Handles client requests and achieves'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: • **正常操作协议**：处理客户端请求并实现
- en: replication under normal conditions
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下的复制
- en: '• **View change protocol**: Handles primary failure and starts a new view'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: • **视图更改协议**：处理主要故障并启动新的视图
- en: with a new primary
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 或有新的主要
- en: '• **Replica recovery protocol**: Handles rejoining of a failed replica that'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: • **副本恢复协议**：处理再加入失败的副本
- en: has now recovered
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经恢复了
- en: VR is inspired by the two-phase commit protocol, but unlike the two-phase commit,
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: VR受到两阶段提交协议的启发，但与两阶段提交协议不同，
- en: it’s a failure-resilient protocol and does not block if the primary (coordinator
    in 2PC
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个具有故障容忍功能的协议，并且不会在主要（2PC中的协调者）发生故障时阻塞
- en: terminology) or replicas fail. The protocol is reliable and ensures availability
    if no more than f replicas are faulty. It uses replica groups of 2f + 1 and tolerates
    crash failures under asynchrony with f+1 quorum sizes.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 术语）或副本失败。该协议是可靠的，并且在不超过f个副本故障的情况下保证可用性。它使用2f + 1的副本组，并在异步性和f+1法定人数下容忍崩溃故障。
- en: Every replica maintains a state which contains information such as configuration,
    replica number, current view, current status – normal or view change or recovering,
    assigned op
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本都维护一个包含配置、副本编号、当前视图、当前状态 - 正常或视图更改或恢复、分配的操作
- en: number to the latest request, log containing entries which contain the requests
    received
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 达到最新请求的编号，包含接收到的请求的条目的日志
- en: so far with their op numbers, and the client table which consists of the most
    recent client request, with status if it has been executed or not and associated
    result for that request.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，他们的操作编号，以及客户表，其中包含最新的客户端请求，其状态是否已执行以及该请求的相关结果。
- en: Let’s see how the normal operation works in VR. First, let’s see the list of
    variables
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看VR中正常操作是如何工作的。首先，让我们看看变量列表
- en: 'and their meanings:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 及其含义：
- en: '• **op**: Client operation'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: • **op**：客户端操作
- en: '• **c**: Client ID'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: • **c**：客户ID
- en: '• **s**: Number assigned to the request'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: • **s**：分配给请求的编号
- en: '• **v**: View number known to the client'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: • **v**：客户端已知的视图号
- en: '• **m**: Message received from the client'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: • **m**：从客户端接收到的消息
- en: '• **n**: The op number assigned to the request'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: • **n**：分配给请求的操作编号
- en: '• **i**: Nonprimary replica'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: • **i**：非主副本
- en: '• **x**: Result'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: • **x**：结果
- en: '292'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '292'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '**Protocol Steps**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议步骤**'
- en: 1\. A client sends a request message of the form <REQUEST op, c, s,
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 客户端发送形式为<REQUEST op, c, s，
- en: v> message to the primary replica.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: v>消息发送到主要副本。
- en: 2\. When received by the primary
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当主要接收时
- en: a. It increments the op number.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它递增操作编号。
- en: b. It adds the request message at the end of the log.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它将请求消息添加到日志的末尾。
- en: c. It sends a <PREPARE m, v, n> to other replicas.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它向其他副本发送<PREPARE m, v, n>。
- en: '3\. When replicas receive the prepare message, they do the following:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当副本接收到准备消息时，它们会执行以下操作：
- en: a. The prepare message is only accepted if all previous requests preceding the
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: a. 只有在前面的所有请求之前的所有请求都已经
- en: op number in the prepare message have entries in their log.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 准备消息中的操作编号在其日志中具有条目。
- en: b. Otherwise, they wait until the missing entries are updated – via state
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: b. 否则，它们将等待直到缺少的条目通过状态更新 - 通过状态
- en: transfer.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 转移。
- en: c. They append the request to their log.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它们将请求附加到它们的日志中。
- en: d. They send the <PREPAREOK v, n, i> message to the primary replica.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: d. 他们向主副本发送<PREPAREOK v, n, i>消息。
- en: 4\. The primary waits for f PREPAREOK messages from other replicas;
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 主要等待其他副本的f PREPAREOK消息;
- en: when received, it
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到时，它
- en: a. Considers the operation to be committed
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: a. 认为操作已经提交
- en: b. Executes any pending operations
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: b. 执行任何待处理的操作
- en: c. Executes the latest operation
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: c. 执行最新的操作
- en: d. Sends the message <REPLY v, s, x> to the client
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: d. 向客户端发送消息<REPLY v, s, x>
- en: 5\. After the commit, the primary replica informs other replicas about
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 在提交后，主要副本通知其他副本
- en: the commit.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 提交。
- en: 6\. Other replicas execute it after appending it in their log but only
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 其他副本在将其附加到其日志后执行它，但只有
- en: after executing any pending operations.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任何待处理操作后。
- en: This process is visualized in Figur[e 7-1\.](#p309)
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在图7-1中可视化。(链接至#p309)
- en: '293'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '293'
- en: '![](index-309_1.png)'
  id: totrans-1474
  prefs: []
  type: TYPE_IMG
  zh: '![](index-309_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: '***Figure 7-1\.** VR protocol – normal operation*'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-1** VR协议-正常操作*'
- en: When the primary fails, the view change protocol initiates. Failure is indicated
    by
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 当主要失败时，视图更改协议启动。故障通过以下方式指示：
- en: 'timeout at replicas:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的超时：
- en: '• **v**: View number'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: • **v**：视图号
- en: '• **l**: Replica’s log/new log'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: • **l**：副本的日志/新日志
- en: '• **k**: The op number of the latest known committed request that the'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '• **k**: 最新已知提交请求的操作数'
- en: replica is aware of
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品知道
- en: '• **I**: Replica identifier'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '• **I**: 复制品标识符'
- en: '**View Change**'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图更改**'
- en: 'A view change protocol works as follows:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改协议的工作如下：
- en: 1\. When a replica suspects the primary of failure, it
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当一个复制品怀疑主节点故障时，它
- en: a. Increments its view number
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: a. 增加视图号
- en: b. Changes its status to view change
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将其状态更改为视图更改
- en: c. Sends a <DOVIEWCHANGE v, l, k, i> message to the primary of the
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: c. 向复制品的主节点发送<DOVIEWCHANGE v, l, k, i>消息
- en: next view
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个视图
- en: 2\. When the new primary gets f+1 of the DOVIEWCHANGE
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当新主节点获得f+1个DOVIEWCHANGE
- en: message, it
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 消息时，它
- en: '294'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '294'
- en: '![](index-310_1.png)'
  id: totrans-1494
  prefs: []
  type: TYPE_IMG
  zh: '![](index-310_1.png)'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: a. Chooses the most recent log in the message and picks that as its new log
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: a. 选择消息中最近的日志并将其选为新日志
- en: b. Sets the op number to that of the latest entry in the new log
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将操作号设置为新日志中最新条目的编号
- en: c. Changes its status to normal
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将其状态更改为正常
- en: d. Sends the <STARTVIEW v, l, k> message to other replicas, indicating the
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: d. 向其他复制品发送<STARTVIEW v, l, k>消息，指示
- en: completion of the view change process
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更改过程完成
- en: 3\. Now the new primary
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 现在，新的主节点
- en: a. Sequentially executes any unexecuted committed operations
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: a. 顺序执行任何尚未执行的已提交操作
- en: b. Sends a reply to the client
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: b. 向客户端发送一个回复
- en: c. Starts accepting new client requests
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: c. 开始接受新的客户端请求
- en: 4\. Other replicas upon receiving the startview message
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 其他复制品收到startview消息后
- en: a. Replace their log with the one in the message
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: a. 用消息中的日志替换他们自己的日志
- en: b. Set their op number to the one in the latest entry in the log
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将其操作号设置为日志中最新条目的编号
- en: c. Set their view number to what is in the message
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将他们的视图号设置为消息中的值
- en: d. Change their status to normal
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将他们的状态更改为正常
- en: e. Send PREPAREOK for uncommitted messages
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: e. 为未提交消息发送PREPAREOK
- en: The view change protocol repeats if even a new primary fails.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连新的主节点都失败，则视图更改协议将重复。
- en: Figur[e 7-2 vis](#p310)ualizes this process.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2 vis](#p310)ualizes this process.
- en: '***Figure 7-2\.** View change in VR*'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-2.** 视图更改 in VR*'
- en: '295'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '295'
- en: Chapter 7 ClassiCal Consensus
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 经典共识
- en: The key safety requirement here is that all committed operations make it to
    the next
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键安全要求是所有已提交操作都到达下一个
- en: views with their order preserved.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 保存他们的顺序的视图。
- en: VR is not discussed with all intricate details on purpose, as we focus more
    on
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: VR故意没有深入讨论，因为我们更专注于
- en: mainstream protocols. Still, it should give you an idea about the fundamental
    concepts
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 主流协议。但是，这应该给您一个关于基本概念的思路
- en: introduced in VR, which play an essential role in almost all replication and
    consensus
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: VR中引入的机制，在几乎所有复制和共识中都起着重要作用
- en: protocols, especially PBFT, Paxos, and RAFT. When you read the following sections,
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，特别是PBFT，Paxos和RAFT。当你阅读以下章节时，
- en: you will see how PBFT is an evolved form of VR and other similarities between
    VR and
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到PBFT是VR的演进形式以及VR和其他相似之处
- en: different protocols introduced in this chapter. When you read the section on
    RAFT, you
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的不同协议。当您阅读关于RAFT的部分时，您
- en: will find good resemblance between VR and RAFT.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 会发现VR和RAFT之间有很大的相似之处。
- en: Let’s look at Paxos first, undoubtedly the most influential and fundamental
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看Paxos，毫无疑问是最有影响力和基础性的
- en: consensus protocol.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性协议。
- en: '**Paxos**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '**Paxos**'
- en: Leslie Lamport discovered Paxos. It was proposed first in 1988 and then later
    more
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: Leslie Lamport发现了Paxos。它首次提出于1988年，然后更多
- en: formally in 1998\. It is the most fundamental distributed consensus algorithm
    which
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1998 年正式提出。这是最基本的分布式共识算法，可以
- en: allows consensus over a value under unreliable communications. In other words,
    Paxos
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在不可靠的通信环境中就一个值达成共识。换句话说，Paxos
- en: is used to build a reliable system that works correctly, even in the presence
    of faults.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建可靠系统，即使在存在故障的情况下也能正常运行。
- en: Paxos made state machine replication more practical to implement. A version
    of Paxos
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos使得状态机复制更加实用。Paxos的一个版本
- en: called multi-Paxos is commonly used to implement a replicated state machine.
    It runs
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为多Paxos常用于实现复制状态机。它运行
- en: under a message-passing model with asynchrony. It tolerates fewer than *n*/2
    crash faults, that is, it meets the lower bound of 2 *f* + 1\.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步消息传递模型下。它容忍少于*n*/2个崩溃故障，也就是说，它满足了2 *f* + 1的下限。
- en: Earlier consensus mechanisms did not handle safety and liveness separately.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 较早的共识机制没有单独处理安全性和活性。
- en: The Paxos protocol takes a different approach to solving the consensus problem
    by
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos协议通过不同的方法解决一致性问题
- en: separating the safety and liveness properties.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 分离安全性和活跃性属性。
- en: There are three roles that nodes in a system running the Paxos protocol can
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Paxos协议的系统中的节点有三种角色。
- en: 'undertake. A single process may assume all three roles:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 承担。单个过程可能扮演所有三种角色：
- en: '• **Proposer**: Proposes values to be decided. An elected proposer acts'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: • **提议者**：提出要决定的值。当选举出的提议者行动时
