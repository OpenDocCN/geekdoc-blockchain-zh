- en: 1 Distributed ledger technologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 分布式账本技术
- en: Distributed Ledger Technologies (DLTs) enable an innovative special form of
    electronic data processing and its memorizing. As the main part, a distributed
    ledger is a decentralized database that allows all the members of a concerned
    network to read and write data in it. Unlike centralized databases, no central
    instance allowing data writing and reading is needed here. Instead of having a
    centralized control, any network member can add data anytime, after which a process
    of data actualization follows. Each network member is provided with the newest
    up-to-date state of a database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式账本技术（DLTs） enable an innovative special form of electronic data processing
    and its memorizing. As the main part, a distributed ledger is a decentralized
    database that allows all the members of a concerned network to read and write
    data in it. Unlike centralized databases, no central instance allowing data writing
    and reading is needed here. Instead of having a centralized control, any network
    member can add data anytime, after which a process of data actualization follows.
    Each network member is provided with the newest up-to-date state of a database.
- en: As DLTs reduce the cost of trust and revolutionize transactions between individuals,
    companies, and governments and minimize successful frauds, error possibility,
    and paper-intensive processes, they are considered a progressive technology of
    the future. They can have a crucial impact on society in every respect, especially
    in machine-to-machine (M2M) communications, one of the basic technologies for
    the Internet of Things (IoT). Besides providing security, privacy, and decentralized
    operation, DLTs stand for reliable, autonomous, and trusted IoT platforms now
    and in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 DLT 降低信任成本，革新个人、公司和政府之间的交易，并将成功的欺诈、错误可能性降到最低，以及减少依赖纸张的流程，它们被认为是未来的进步技术。它们在各个方面对社会产生重要影响，特别是在物联网（IoT）的基本技术之一——机器对机器（M2M）通信方面。除了提供安全性、隐私性和去中心化操作外，DLT
    还代表现在和未来可靠的、自主的、可信赖的 IoT 平台。
- en: DLT follows a new data recording, sharing, and synchronizing method across multiple
    ledgers (data stores). A distributed ledger (DL) is a database that is independently
    created, maintained, and updated by each node (or participant) in a large network.
    All the records of a distributed ledger are shared and synchronized by consensus
    between nodes across the network. This happens without the help of any central
    authority. Consequently, each network node has its ledger copy, identical to others.
    Every time the ledger has to be updated with the new record(s), reaching a consensus
    results in getting identical copies on all nodes. This synchronization process
    is very fast, so that changes in a node’s ledger are copied into the ledgers on
    other nodes in just a few seconds (or perhaps minutes).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: DLT 遵循一种新的跨多个账本（数据存储）的数据记录、共享和同步方法。分布式账本（DL）是一个由大型网络中的每个节点（或参与者）独立创建、维护和更新的数据库。分布式账本的所有记录通过网络中节点之间的共识共享和同步。这个过程不依赖任何中央权威。因此，每个网络节点都拥有与其他节点相同的账本副本。每次账本需要用新记录更新时，节点之间达成共识就会在所有节点上获得相同的副本。这种同步过程非常快，因此节点账本的变化会在几秒钟（或许几分钟）内复制到其他节点的账本中。
- en: Cryptographic signatures are used to secure access to the ledger’s content,
    so that all DL data is accurate and safe. In many cases, to succeed in a cyberattack,
    an attacker has to target most DL copies simultaneously. Besides, if one or few
    copies are corrupted, the system as a whole will not be compromised.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 加密签名用于保护账本内容的访问，因此所有 DL 数据都是准确和安全的。在许多情况下，为了成功进行网络攻击，攻击者必须同时针对大多数 DL 副本。此外，如果一个或几个副本被损坏，整个系统将不会受到影响。
- en: Any node may create a data block with which the actual will be updated. Then,
    the information (created block) is broadcast across the network, after which other
    nodes check its validity through a consensus mechanism, that is, pre-defined validation
    method. After the community (i.e., a valid majority of network nodes) has validated
    a new block, each node, that is, participant, adds it to its copy of the ledger.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何节点都可以创建一个数据块来更新实际的账本。然后，信息（创建的块）在网络中广播，之后其他节点通过共识机制验证其有效性，即预定义的验证方法。社区（即网络节点的有效多数）验证新块后，每个节点，即参与者，将其添加到其账本副本中。
- en: As for consensus mechanisms, there are several of them, such as a Proof of Work
    (PoW), Proof of Stake (PoS), Proof of Space (PoSpace), and so on. PoW can be the
    solution to a mathematical problem or puzzle or a suitable hash value found through
    the iterative execution of the appropriate hash function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共识机制，有几种类型，比如工作量证明（PoW）、权益证明（PoS）、空间证明（PoSpace）等。PoW可以是解决一个数学问题或谜题，或者是通过适当哈希函数的迭代执行找到的合适哈希值。
- en: A consensus accomplished by PoS is a process in which a new block is validated
    only by the participants having enough high stakes, that is, by the rich members.
    They have many native tokens (cryptocurrency) of a concrete DL on their accounts.
    The PoS concept is based on the idea that the trustworthiness in the network (and
    in the value of token) decreases if everyone could perform block validations,
    which consequently increases the possibility of validation of illegitimate blocks.
    Hence, the only way of keeping the system’s trust is by leaving the block validation
    to in the members who might lose much money if acting in irresponsible ways. Regarding
    energy consumption, PoS is faster and more efficient than PoW (but less proven).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过PoS实现的共识是一个过程，只有拥有足够高权益的参与者，即富有的成员，才能验证新块。他们在他们的账户上有许多具体DL的本地代币（加密货币）。PoS概念基于这样一个想法，即如果每个人都能执行块验证，网络中的信任度（以及代币的价值）就会降低，这进而增加了验证非法块的可能性。因此，唯一保持系统信任的方式是将块验证留给可能会因不负责任行为而损失很多钱的成员。关于能源消耗，PoS比PoW更快、更有效（但不如PoW那样经过验证）。
- en: In the PoSpace concept, the available space (memory) on hard discs of the miners’
    computers is the resource used for mining (instead of computational power used
    with PoW). It is also called Proof of Capacity (PoC). Compared to PoW, this concept
    also saves time and energy. PoSpace is a good solution for anti-spam measures
    and the prevention of DoS attacks. It could also be useful in preventing the centralization
    of mining power in mining pools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在PoSpace概念中，矿工计算机硬盘上可用的空间（内存）是用于采矿的资源（而不是PoW中使用的计算能力）。它也被称为容量证明（PoC）。与PoW相比，这个概念也节省时间和能源。PoSpace是防止垃圾邮件和预防DDoS攻击的好解决方案。它也可能有助于防止采矿权力在矿池中的集中。
- en: 'There are two types of DLs: public and private, depending on the peer-to-peer
    (P2P) network they rely on. Based on control by certain entities, there are also
    two types of DLs: permissionless and permissioned. In a permissionless DL, each
    node of the network hosts the full and freshest copy of the complete ledger. Every
    ledger update (addition of a new block) is communicated to all nodes in the network,
    which then collectively validate the new block by obeying a consensus mechanism.
    Having accepted the validation, a new block is added to each node’s copy of the
    ledger. Data consistency across the network is assured in that way. This means
    that a permissionless DL is fully democratic and with no central control, provided
    each participant follows the predefined rules. In a permissioned DL, however,
    a central entity grants the permissions to nodes for accessing the network and
    making changes to the ledger. At the same time, the central entity can also verify
    the identity of the participants who try to access the network.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DL有两种类型：公共和私有，这取决于他们依赖的对等网络（P2P）。基于某些实体的控制，还有两种类型的DL：无需许可和需要许可。在无需许可的DL中，网络的每个节点都托管着完整且最新的账本副本。账本更新的每一个新块（添加新块）都通过网络中的所有节点进行传播，然后集体通过遵守共识机制来验证新块。接受验证后，新块将添加到每个节点的账本副本中。这样保证了网络中的数据一致性。这意味着无需许可的DL是完全民主的，没有中心控制，前提是每个参与者都遵循预定义的规则。然而，在需要许可的DL中，一个中心实体授予节点访问网络和修改账本的权限。同时，中心实体还可以验证尝试访问网络的参与者的身份。
- en: As there are a number of DLT applications that boost autonomous driving, this
    chapter will consider basic DLT architectures and their properties and several
    use cases of these technologies in the concept of autonomous vehicles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多DLT应用促进了自动驾驶，本章将考虑基本的DLT架构及其特性，以及这些技术在自动驾驶车辆概念中的几个用例。
- en: 'Three basic DLT architectures will be considered for comparing DLT characteristics
    in the remaining part of the paper: chain or list, Directed Acyclic Graph (DAG)
    as a tangle, and DAG as a tree. A typical representative of the chain or list
    is a blockchain, which is the basis for the oldest and most widely used cryptocurrency
    – the Bitcoin (BTC), invented in 2008 by Satoshi Nakamoto [[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)].
    DAG is a finite directed graph with no directed cycles and consists of many finite
    vertices and edges. Each edge is directed from one vertex to another but with
    no back loops. Tangle is a basis for IOTA, a cryptocurrency that is one of the
    main concurrences of the BTC, especially in the field of M2M communications. IOTA
    was founded in 2015 by David Sonstebo, Sergey Ivancheglo, Dominik Schiener, and
    Serguei Popov [[2](9783110681123_008192.xhtml#b_9783110681130-005_ref_002)] and
    has worked formally as IOTA Foundation since 2017\. DAG as a tree is the newest
    DLT architecture, which is the basis for the so-called hashgraph. Hashgraph is
    a data structure that records the data about who gossiped with whom and in which
    order. US professor Leemon Baird invented hashgraph in 2016 [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)].'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文剩余部分将考虑三种基本的DLT架构来比较DLT特征：链或列表、有向无环图（DAG）作为纠缠、以及DAG作为树。链或列表的典型代表是区块链，它是比特币（BTC）的基础，比特币是最古老和最广泛使用的加密货币，由2008年的中本聪发明
    [[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)]. DAG是一个没有有向循环的有限有向图，由许多有限顶点和边组成。每条边都是从一个顶点指向另一个顶点，但没有反向循环。纠缠是有向无环图的基础，是IOTA的基础，IOTA是与BTC的主要竞争对手之一，特别是在机器对机器通信领域。IOTA于2015年由David
    Sonstebo，Serguei Ivancheglo，Dominik Schiener和Serguei Popov [[2](9783110681123_008192.xhtml#b_9783110681130-005_ref_002)]
    创立，自2017年以来正式作为IOTA基金会运作。DAG作为树的架构是最新型的DLT，是所谓的哈希图的基础。哈希图是一种记录了关于谁与谁闲聊以及顺序的数据结构。美国教授Leemon
    Baird在2016年发明了哈希图 [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)]。
- en: 1.1 Digital money – cryptocurrencies
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 数字货币 – 加密货币
- en: 'DLTs are widely used in the financial sector as cryptocurrencies or crypto
    money. These days, the world is witnessing the true gold rush for cryptocurrencies.
    Many of those involved in the so-called easy money business related to DLTs understand
    how cryptocurrencies work. Still, others ask a simple question: “How is it possible
    to make real money from nothing?” Jokes are made comparing cryptocurrencies with
    some modern physicists’ hypothesis that the whole universe came from nothing.
    So, if this applies to the universe, why could it not be applied to cryptocurrencies,
    too?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: DLTs在金融领域被广泛应用，作为加密货币或加密货币。如今，全世界正见证加密货币真正的淘金热。许多涉及所谓轻松赚钱业务的人了解加密货币是如何运作的。然而，其他人提出了一个简单的问题：“如何可能从无中赚取真正的钱？”有人开玩笑地将加密货币与一些现代物理学家的假设相比较，即整个宇宙来自无。所以，如果这对宇宙适用，为什么不能应用于加密货币呢？
- en: 'These are other most often asked questions: “How come the whole system is still
    functioning?,” “Is it a kind of fraud?,” “How long will it last?,” “Why do people
    believe in digital money when there is no supreme authority to guarantee it?,”
    “Is the whole thing and the euphoria related to this only one of the numerous
    economic bubbles with the growing mechanism based on human greed, with the inevitable
    final collapse?,” and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常被问到的问题：“整个系统是如何仍然运作的？”，“这是一种欺诈吗？”，“它会持续多久？”，“在没有最高权威保证的情况下，人们为什么相信数字货币？”，“整个事情以及与之相关的狂热只是基于人类贪婪的众多经济泡沫之一，随着机制的增长而不可避免地最终崩溃？”等等。
- en: And yet, many financial experts foresee a bright future of cryptocurrencies
    and a further evolution of DLTs. They say that they will enable numerous services
    such as absolute trust, security, and transparency, showing the way to the societies
    that have a high level of justice, without criminal and corruption, that is, to
    the societies that many utopists had only been dreaming of.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多金融专家预测加密货币的美好未来和DLTs的进一步发展。他们表示，这将使众多服务如绝对信任、安全和透明度成为可能，为拥有高水平的正义、没有犯罪和腐败的社会指明方向，即许多乌托邦主义者仅能梦想的社会。
- en: 'Let us remember some of the facts about money: the first forms of human transactions
    were in pieces of a material (e.g., copper, silver, or gold) which had a value
    by itself. For example, gold was (and still is) a precious metal due to its characteristics
    that make it suitable for various applications. For this reason, people believed
    (and they still do) that the value of gold can be exchanged for other goods, that
    is, used for trading, while being aware that it could be turned into a useful
    or a beautiful and valuable object. The keyword here is trust, that is, the faith
    in the value of the objects named coins or money.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回忆一些关于货币的事实：人类最早的经济交易是以某种物质（比如铜、银或金）的碎片形式进行的，这些物质本身就有价值。例如，黄金（现在仍然）是一种贵金属，因为它具有多种应用的特性。因此，人们（现在仍然）认为黄金的价值可以兑换成其他商品，即用于交易，同时意识到它可以被制成有用或美丽而珍贵的物品。这里的关键词是信任，即对被称为硬币或货币的物品价值的信仰。
- en: This faith in coins can be (and many times in history was) jeopardized by making
    coins with a certain (often unknown) percentage of other materials of lesser worth,
    making unfair trade and fraudulent behavior quite possible in that manner. The
    natural evolutionary step was to ensure a community where each used coin is worth
    the labeled value. Only a few powerful central authorities could have obtained
    such an assurance (e.g., emperors, kings, governments, and other community rulers).
    The guarantee mechanism was based on the monopoly of money production, the power
    and reputation of the authority, and the insurance measures (using advanced technology
    of the time) taken to make money difficult to forge by common people. Suppose
    the aforementioned conditions are fulfilled to some extent, it can be said that
    there is an informal agreement in the community that a given currency can be used
    for trading. The key terms related to real money that should be remembered, here,
    are central authority and its reputation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对硬币的这种信仰可能会（在历史上的很多次）因为铸造含有其他价值较低的材料（往往未知）的硬币而受到威胁，从而使不公平的交易和欺诈行为变得可能。自然演化的一个步骤是确保一个社区中每种使用的货币都等于其标称价值。只有少数强大的中央权力机构才能获得这种保证（例如，皇帝、国王、政府和社区统治者等其他社区领导者）。保证机制是基于货币生产的垄断、权威的力量和声誉以及采取的措施（使用当时先进的技术）使普通人难以伪造货币。如果上述条件在一定程度上得到满足，可以说社区中存在一种非正式的协议，即某种货币可用于交易。在这里应该记住与真实货币相关的关键词是中央权威和其声誉。
- en: Money is a dynamic category whose value can vary very much, depending on many
    factors (e.g., inflation). All conditions are not always needed for general consent
    on the money value. There were some specific circumstances (in history) in some
    places where central authority had not guaranteed the value of money. Still, the
    trust in the means of payment had been achieved due to the peculiarities or rareness
    of the things and objects found in nature, which had been used then for trading,
    for example, bear claws or shells.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 货币是一个动态的分类，其价值可能因许多因素（例如，通货膨胀）而有很大变化。并非总是需要所有条件才能对货币价值达成普遍共识。在某些地方的历史上，曾有一些特定情况，那里没有中央权力机构保证货币的价值。然而，由于自然中发现的事物或物品的独特性或稀有性，交易手段的信任仍然得以实现，例如熊爪或贝壳。
- en: An interesting example is the use of huge and immovable sacred stones as money
    in a few isolated Pacific islands. The stones had been changing hands after each
    transaction between tribe members. The ownership of each stone was carved on it
    as in a ledger (wordings show similarity with today’s ledgers).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是在一些偏远的太平洋岛屿上，使用巨大的不可移动的圣石作为货币。每次部落成员之间的交易后，这些石头就会易手。每块石头的所有权都在上面刻有类似账本的文字（文字显示与今天的账本有相似之处）。
- en: It is useful to draw a parallel and note a distinction between cryptocurrency
    and paper money. Taken by itself, a piece of paper almost has no value. Yet, banknotes,
    pieces of paper have definite values as the central bank of a country, the authority
    which issued them, guarantees (by its assets or by the reserves in gold, or even
    by the reputation of their country), that each banknote can be changed for a piece
    of gold or another thing of a certain value. Each banknote should represent a
    certain amount of gold that the bank has saved in its vaults, and it was the case
    from the very beginning. But it is known that for a long time, many currencies
    (including the US Dollar, the British Pound, and the Euro) have no gold coverage
    – they are called fiat currencies. Despite this fact, these currencies are (more
    or less) concurrent and worthy at their markets. The trust in a currency generally
    depends on the strength of the country’s economy, reputation, and many other factors.
    The similarity between a cryptocurrency and a fiat currency is that their value
    is based on the trust in the system, while the mechanisms which keep that trust
    differ.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将加密货币与纸币货币并行讨论并区分是有用的。单就其本身而言，一张纸几乎没有任何价值。然而，银行券，这些纸片有着确定的价值，因为一个国家的中央银行，发行它们的权威机构，通过其资产或黄金储备，甚至通过它们国家的声誉，对这些银行券进行担保，即每张银行券都可以兑换一定价值的黄金或其他物品。每张银行券应该代表银行在金库中保存的一定量的黄金，从最初开始就是这样。但是众所周知，很长一段时间内，许多货币（包括美元、英镑和欧元）都没有黄金支持——它们被称为法定货币。尽管事实如此，这些货币在其市场上（或多或少）还是同时具有价值。对一种货币的信任通常取决于该国经济的实力、声誉和其他许多因素。加密货币与法定货币价值的相似之处在于，它们的价值都是基于对系统的信任，而维持这种信任的机制则不同。
- en: 'Another new phenomenon has emerged in recent years: paper money and coins are
    not being used in many countries. Plastic or virtual money (through debit/credit
    cards and gadgets) is broadly adopted instead, now, and real money has its material
    representative, no more. Still, it is stored as information in the computer systems
    of banks holding the customers’ accounts. From their side, banks guarantee (with
    their reputation, as the recognized authorities) that the stored information on
    the account states of their customers are true.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来出现了另一种新现象：许多国家不再使用纸币和硬币。现在，广泛采用塑料或虚拟货币（通过借记卡、信用卡和设备），而真实货币则没有更多的物质代表。然而，它作为信息存储在持有客户账户的银行的计算机系统中。从他们那里，银行以他们的声誉（作为公认的权威）保证，存储在账户状态上的客户信息是真实的。
- en: Taking into consideration all the above-exposed facts, we could think of cryptocurrencies
    as not so strange. Even more – they may look like the next natural evolutionary
    step in the story of money.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到以上暴露的所有事实，我们可以认为加密货币并不那么奇怪。甚至更多——它们可能看起来是货币故事中的下一个自然演变步骤。
- en: 1.2 Blockchain
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 区块链
- en: Blockchain is a reliable transaction register (or ledger) containing all transactions
    up to this very moment. It is a big and continuously growing file comprising a
    list of records called blocks (or blocks of transactions) where each block in
    the list is linked (i.e., chained) with the previous and the next block, using
    cryptography (see Fig. 1.1). The key conditions are that besides transaction data,
    each block has a header that contains a cryptographic hash of the previous block’s
    header, a timestamp that transactions relate to, and six other fields (if the
    Bitcoin blockchain [[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)]
    is concerned; see [Fig. 1.2](#b_9783110681130-001_fig_002)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个可靠的交易注册（或账本）系统，包含了截至目前为止的所有交易。它是一个庞大且持续增长的文件，由一系列称为区块（或交易区块）的记录组成，每个区块列表中的区块都通过密码学与前一个和后一个区块链接（即链式链接）（见图1.1）。关键条件是，除了交易数据外，每个区块都有一个包含前一个区块头部的密码学散列值的头部，一个与交易相关的时间戳，以及六个其他字段（如果涉及到比特币区块链[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)；（见图1.2）。
- en: '![](../graphic/converted/b_9783110681130-001_fig_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_001.jpg)'
- en: 'Fig. 1.1: BTC blockchain – line topology.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：BTC区块链——线性拓扑。
- en: '![](../graphic/converted/b_9783110681130-001_fig_002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_002.jpg)'
- en: 'Fig. 1.2: Structure of a block and connection with the next block in the BTC
    blockchain.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：BTC区块链中一个区块的结构及其与下一个区块的连接。
- en: Let us suppose that a BTC blockchain (just one of the cryptocurrencies using
    blockchain technology) records all BTC transactions that people have ever made.
    In other words, blockchain is a financial book with precise and reliable data
    on all past transactions of money (between community members) from the very beginning.
    Or even simpler said – blockchain is a reliable transaction register (or ledger)
    that contains all transactions up to this very moment. It is a big and continuously
    growing file. For example, a BTC blockchain (each cryptocurrency has its blockchain,
    just like Bitcoin), now, has a few hundreds of GB and records all BTC transactions
    between people.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个比特币区块链（仅是使用区块链技术的众多加密货币中的一种）记录了人们所做的一切比特币交易。换句话说，区块链就是一个具有精确可靠数据的金融账本，包含社区成员之间自始至终的所有货币交易（比特币交易）。或者更简单地说——区块链是一个可靠的交易注册表（账本），包含了直至此刻的所有交易。这是一个庞大且持续增长的文件。例如，一个比特币区块链（每种加密货币都有自己的区块链，就像比特币一样），现在，有几百GB的大小，并记录了人们之间的所有比特币交易。
- en: 'The key point of the whole system is that no one can ever delete or modify
    any of these transactions, and this is the main reason why blockchain has become
    a hot topic. It offers absolute permanency and reliability of the recorded data,
    so that no hacker can get into this blockchain database and change the fact that,
    for instance, John Smith possesses 20 BTCs. Such properties of BTC are accomplished
    by two most significant factors:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统的关键点是，没有人能删除或修改这些交易，这也是区块链成为热门话题的主要原因。它提供了记录数据的绝对持久性和可靠性，因此，没有黑客能进入这个区块链数据库，更改例如约翰·史密斯拥有20个比特币的事实。比特币具有这样的属性，是由两个最重要的因素实现的：
- en: Decentralization
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去中心化
- en: The algorithm for the verification of transactions, which is closely related
    to the blockchain structure
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与区块链结构紧密相关的交易验证算法
- en: The concept of decentralization is achieved when the list of all transactions
    (blockchain) is stored in many computers worldwide, where each of these computers
    (called nodes) contains a file of the complete blockchain (which should be identical
    to the blockchain file of any other node). Unlike centralized banking systems
    where each bank keeps customers’ transaction data on its servers (well protected
    and backed up), the nodes keeping a blockchain belong to ordinary people all over
    the world, who have accepted to take part in this DL voluntarily. There is neither
    a central authority nor a central register to keep data. People with node computers
    are mutually independent, except that their computers host the nodes that maintain
    a blockchain. Nodes are always connected using a protocol for inter-node communication,
    thus creating a global peer-to-peer (P2P) network. However, this network is like
    any other P2P network running over the Internet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化的概念是在全球许多计算机中存储所有交易（区块链）时实现的，其中每台计算机（称为节点）都包含一个完整的区块链文件（与其他任何节点的区块链文件应该相同）。与集中式银行系统不同，在集中式银行系统中，每家银行在其服务器上保留客户的交易数据（得到很好的保护和备份），存储区块链的节点属于世界各地的普通人，他们自愿参与这个分布式账本（DL）。这里既没有中央权威机构，也没有中央注册机构来保存数据。拥有节点计算机的人们彼此独立，只不过他们的计算机托管了维护区块链的节点。节点总是通过节点间通信协议连接，从而创建一个全球点对点（P2P）网络。然而，这个网络就像运行在互联网上的任何其他P2P网络一样。
- en: A fresh copy of the file of blockchain is kept on the disk of each node. Besides,
    some nodes (miners) can also verify the newest transactions (e.g., in BTCs) between
    any two people in the world. Furthermore, there are many other computers with
    only a transaction verification function. They are also called miners, although
    they are not nodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点硬盘上都保存着区块链文件的副本。此外，一些节点（矿工）还可以验证世界上任何两个人之间的最新交易（例如，比特币交易）。此外，还有许多其他计算机只有交易验证功能。它们也被称为矿工，尽管它们不是节点。
- en: 'Let us take the following example: A wants to send 100 EUR (in BTCs) to B:
    in the beginning, a computer (or a smartphone) of A announces to all miners in
    the network that A wants to transfer 100 EUR to B. At that moment, this is called
    an invalidated transaction, and it is not written into the register yet.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下示例为例：A想要向B发送100欧元（以比特币计）：起初，A的计算机（或智能手机）向网络中的所有矿工宣布A想要将100欧元发送给B。此刻，这被称为无效交易，且尚未记录在注册表中。
- en: The first thing for a miner to do next is check if A has enough money (at least
    100 EUR and something more for the provision). Now, the miner checks this by passing
    through the complete blockchain, seeing all transactions that person A has ever
    had, and calculating if there is enough money available. As there is no such category
    as the account state, the amount of money A possesses is always counted again,
    based on all the transactions A has ever had up to that moment. That is a very
    favorable trait, making the blockchain additionally safe. If one wanted to manipulate
    another person’s account, one would have to change the transactions from the past,
    which is impossible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工接下来要做的第一件事是检查A是否拥有足够的资金（至少100欧元，还要有一些备用金）。现在，矿工通过遍历整个区块链，查看A所进行过的所有交易，并计算是否有足够的资金可用。由于没有账户状态这样的分类，A所拥有的资金总是基于A到那一刻所进行过的所有交易再次计算。这是一个非常有益的特性，使区块链更加安全。如果有人想操纵另一个人的账户，他们必须改变过去的交易，这是不可能的。
- en: 'Having finished this (easier) first step, that is, the confirmation of A’s
    solvency, the second and more difficult step follows. There, miners compete with
    each other: the winner is the first one managing to embed the new transaction;
    that is, to append it to the end of the blockchain.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了（相对容易）的第一步，也就是确认A的偿付能力之后，第二步，也是更难的一步，紧随其后。在那里，矿工彼此竞争：胜者是第一个成功嵌入新交易的人；也就是说，把它附加到区块链的末尾。
- en: Only one particular transaction has been mentioned so far (between person A
    and person B) as the single one, which should be validated and added to the blockchain.
    In reality, a block that is to be appended to the end of the BTC blockchain contains,
    on average, 1,500 transactions accumulated from around the world in ten minutes.
    In general, for different types of the blockchain (other than BTC blockchain),
    the frequency of appearance of new blocks is different, so there are blockchains
    where one block of transactions appears even every five seconds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，只提到了一个特定的交易（A和B之间的交易），作为唯一需要验证并添加到区块链的交易。实际上，要附加到BTC区块链末尾的区块平均包含来自世界各地的1,500笔交易，这些交易是在十分钟内积累的。一般来说，对于不同类型的区块链（除了BTC区块链），新块出现的频率是不同的，所以有些区块链上甚至每五秒钟就会出现一个交易区块。
- en: The transaction data of each block (of the BTC blockchain) consists of the latest
    valid transactions, whereby the size of the block is limited to 1 MB (although
    with the use of Segregated Witness protocol upgrade [[4](9783110681123_008192.xhtml#b_9783110681130-005_ref_004)]
    from August 2017, block limit has been extended to 4 MB, for practical purposes).
    The participants’ identities in a transaction are encrypted prior, using their
    private keys. All transactions in a block are hashed through a cryptographic scheme
    known as a hash tree or Merkle tree [[5](9783110681123_008192.xhtml#b_9783110681130-005_ref_005)].
    The 256-bit long result of hashing, that is, the root of the Merkle tree, is put
    into the block header as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块的交易数据（BTC区块链）包括最新的有效交易，从而限制了区块的大小为1MB（尽管在使用隔离见证协议升级（[[4](9783110681123_008192.xhtml#b_9783110681130-005_ref_004)]）从2017年8月起，区块限制已扩展到4MB，但出于实际考虑）。交易中的参与者身份在交易前使用他们的私钥进行加密。区块中的所有交易都通过一种被称为哈希树或默克尔树（[[5](9783110681123_008192.xhtml#b_9783110681130-005_ref_005)）的加密方案进行哈希。哈希的256位长结果，即默克尔树的根，也放入区块头部。
- en: The links between blocks make a blockchain practically unbreakable, as each
    block contains the hash value of the previous block’s header. The catch is in
    the 32-bit block header field named nonce (from number-used-once), the value of
    which all the miners in the world are trying to guess every ten minutes, to append
    a new block to the blockchain (and, consequently, to get a reward for the invested
    work, if successful). Once a new block is put to the blockchain, all the transactions
    from that block are considered verified, and miners immediately go on finding
    new nonce for the next block of transactions. The first miner who verifies these
    transactions by guessing the right value of nonce (in the previous block) gets
    a reward. With a BTC blockchain, the reward consists of two parts – the first
    is a transaction fee, paid in BTCs by money-transaction senders from the just
    verified block, and the second part is a certain amount of new BTCs generated
    from nothing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 区块之间的链接使区块链实际上变得不可破解，因为每个区块都包含前一个区块头的哈希值。关键在于名为nonce（一次使用的数字）的32位区块头字段，其值是全球所有矿工每十分钟尝试猜测的，以便在区块链上添加一个新块（如果成功，则获得奖励）。一旦新的区块被添加到区块链上，那个区块的所有交易都被认为是验证过的，矿工们会立即开始为下一个交易区块寻找新的nonce。第一个验证这些交易的矿工（猜测前一个区块的nonce的正确值）会获得奖励。在BTC区块链上，奖励由两部分组成——第一部分是交易费，由刚刚验证的区块中的货币交易发送者以BTC支付，第二部分是从无中产生的特定数量的新的BTC。
- en: What is the right value of nonce? There is no such value, that is, no tangible
    value has been set in advance. More specifically, the algorithm is designed, so
    that the goal to be achieved is to adjust the hash value of the last verified
    block header in blockchain to be small enough, that is, to be less than or equal
    to a given number (target). This practically means that this hash value, which
    is to be put in the header of the next (i.e., of the newest) block, begins with
    several zeros. The adjustment of the hash value is performed through an iterative
    process of incrementing the value of nonce and computing a new hash (of the complete
    block header) for each new nonce. The process stops when the currently computed
    hash satisfies the given condition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是正确的nonce值？并没有这样一个值，也就是说，没有预先设定的具体值。更具体地说，算法被设计成，要实现的目标是将区块链上最后一个已验证区块头的哈希值调整得足够小，也就是要小于或等于给定的数字（目标）。这实际上意味着这个哈希值，即要放入下一个（即最新的）区块头的值，以几个零开头。通过逐次增加nonce的值并计算新的哈希（完整的区块头）来调整哈希值。每次新的nonce计算一次新的哈希。当当前计算的哈希满足给定条件时，过程停止。
- en: 'Knowing the properties of the cryptographic hash functions (in the case of
    BTC, SHA-256 algorithm is used, i.e., the hash is 256 bits long), it is obvious
    that the probability of guessing a hash with a given number of leading zeros is
    extremely small (in one attempt). If the goal (for a given level of difficulty)
    is to compute a hash where, for example, the first 72 bits are zeros (or in hexadecimal
    notation: hash = 00000000 00000000 00xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
    xxxxxxxx), and assuming a uniform distribution of hash values, the probability
    of success in one attempt would be 2^(−72) = 1/4,722,000,000,000,000,000,000\.
    With such a small probability, the time needed for a specialized mining computer
    (e.g., with the processing power of 16 Thash/s) to solely find the winning combination
    of nonce and hash would be more than nine years, by a rough estimate! Still, on
    average, a new block is being added to the blockchain every ten minutes. How is
    it achieved?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解加密哈希函数的特性（在BTC的情况下，使用SHA-256算法，即哈希值为256位长），很明显，猜测具有给定前导零的哈希的概率极其小（在一次尝试中）。如果目标（对于给定的难度级别）是计算一个哈希值，例如，前72位为零（或十六进制表示：hash
    = 00000000 00000000 00xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx），假设哈希值均匀分布，一次尝试成功的概率将是2^(-72)
    = 1/4,722,000,000,000,000,000,000。由于概率如此之小，对于专门的挖矿计算机（例如，每秒处理能力为16 Thash/s）来说，单纯找到nonce和哈希的获胜组合需要的时间可能超过九年，粗略估计！然而，平均而言，每十分钟就会在区块链上添加一个新块。这是如何实现的呢？
- en: The answer is in the enormous processing power obtained by the combined effort
    of the computers of all miners in the world. The precise number of BTC miners
    is difficult to be determined, as it is always changing, with a growing trend.
    When they are not mining BTCs, many of them use their computers for mining other
    cryptocurrencies as well, and a few are mining from time to time, for example,
    during the time intervals when a miner’s computer is not used for playing games.
    Eventually, the exact number of miners is not very important, as the processing
    powers of their computers are different. On the other hand, however, it all depends
    on the miners’ readiness to invest in hardware, together with all expenses for
    electric power, among others.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于全世界矿工计算机联合起来的巨大处理能力。确切的BTC矿工人数难以确定，因为它总是在变化，呈现增长趋势。当它们不挖BTC时，许多矿工还用他们的计算机去挖其他加密货币，少数矿工则是偶尔挖矿，例如，在矿工的计算机不用于玩游戏的时间间隔。最终，矿工的确切人数并不重要，因为他们的计算机处理能力不同。另一方面，这全取决于矿工投资硬件的意愿，以及所有电力等费用。
- en: These days, a great number of miners are gathered in mining pools, as they are
    aware that mining solely is not profitable, because a block’s verification process
    would take an unacceptably long time. Mining pools are joint groups of miners
    that acquire advantages such as much more frequent verifications of transaction
    blocks. Miners from a pool share the rewards for successful verifications, proportional
    to the miners’ mining powers contributed to the pool. Apart from that, most BTC
    mining is done on the Application Specific Integrated Circuits (ASICs) in large,
    thermally-regulated data centers and warehouses with low-cost electricity. The
    owners of such warehouses rent the processing resources to miners.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大量的矿工聚集在挖矿池中，因为他们意识到单独挖矿是没有利润的，因为区块的验证过程会花费太长时间。挖矿池是矿工的联合团体，能够获得更频繁验证交易块等优势。池中的矿工根据他们对池贡献的挖矿能力分享成功验证的奖励。除此之外，大多数BTC挖矿都是在大型的、有恒温调节的数据中心和仓库中使用
    Application Specific Integrated Circuits (ASICs) 进行的，这些地方电力成本低。这些仓库的拥有者将处理资源租给矿工。
- en: As the world’s mining power is increasingly growing, the same is expected from
    the frequency of block verifications and the acceleration of BTCs’ issuance. But
    these have not happened yet, due to the applied algorithm known as Difficulty,
    which adjusts the difficulty level for solving the verification problem. The algorithm
    keeps the average block verification frequency almost constant. A new block is
    added to the blockchain every 10 min approximately, or more precisely – within
    two weeks, 2016 blocks should be added to the blockchain. Every two weeks, the
    algorithm changes the value of the block header field named Difficulty target
    ([Fig. 1.2](#b_9783110681130-001_fig_002)), according to the statistics of the
    total mining power and the number of transactions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着全球挖矿力量的日益增长，预计区块验证的频率也会增长，BTC的发行速度也会加快。但是这些还没有发生，这是因为应用的算法被称为难度（Difficulty），它调整了解决验证问题的难度级别。该算法使平均区块验证频率几乎保持恒定。大约每10分钟在区块链上添加一个新块，更精确地说——在两周内，应该在区块链上添加2016个块。每两周，根据总挖矿力量和交易数量的统计，算法会改变区块头字段名为难度目标（Difficulty
    target）的值（见图1.2）。
- en: 'The value of the 32-bit Difficulty target field corresponds (in a bit more
    complex way) to the difficulty of finding the hash, which is small enough to satisfy
    the condition for block verification. It has been mentioned earlier that the hash
    value written in the verified block must be less than or equal to a given value,
    called target_value (in [Fig. 1.3](#b_9783110681130-001_fig_003) named X). A reference
    value called difficulty_1_target is also defined to represent the 256-bit number,
    where the leading 32 bits are zero, the next 16 bits are one, and the rest are
    zero, or in hexadecimal notation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 32位难度目标字段的价值（稍微复杂一点）对应于找到哈希的难度，足够小以满足区块验证的条件。前面提到过，验证区块中写的哈希值必须小于或等于一个给定值，称为目标值（在图1.3中称为X）。还定义了一个参考值，称为难度1目标（difficulty_1_target），用来表示256位数字，其中前32位为零，接下来16位为1，其余为零，或者用十六进制表示：
- en: <math alttext="" altimg="../graphic/b_9783110681130-001_ineq_001.png"><mtable
    columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mo>=</mo></mtd><mtd><mn>00000000</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0000</mn><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" altimg="../graphic/b_9783110681130-001_ineq_001.png"><mtable
    columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mo>=</mo></mtd><mtd><mn>00000000</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0000</mn><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>
- en: '![](../graphic/converted/b_9783110681130-001_fig_003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_003.jpg)'
- en: 'Fig. 1.3: Adding of a new block at the end of the BTC blockchain.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：在BTC区块链末尾添加新块。
- en: (1.1)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_001.png"><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mrow><msub><mi>f</mi><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">x</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub></mrow><mo>×</mo><msub><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">c</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></mrow><mo>×</mo><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>224</mn></mrow></msup></mrow></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (1.1)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_001.png"><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mrow><msub><mi>f</mi><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">x</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub></mrow><mo>×</mo><msub><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">c</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></mrow><mo>×</mo><mrow><msup><mn>2</mn><mrow><mn>2
- en: 'A parameter known as Difficulty is defined as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为难度（Difficulty）的参数定义为：
- en: (1.2)<math alttext="Difficulty=difficulty_1_target∕target_value" altimg="../graphic/b_9783110681130-001_eq_002.png"><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mo>=</mo><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi
    mathvariant="normal">_</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">t</mi><mrow><mo>/</mo></mrow><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></math>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: (1.2)<math alttext="Difficulty=difficulty_1_target∕target_value" altimg="../graphic/b_9783110681130-001_eq_002.png"><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mo>=</mo><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi
    mathvariant="normal">_</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">t</mi><mrow><mo>/</mo></mrow><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></math>
- en: 'Thus, it shows how many times it is more difficult to find a hash below the
    current target value than to find a hash below difficulty_1_target. The Difficulty
    is a floating-point value, and in the Difficulty target field of the block header,
    it is represented by exponent and mantissa of the target_value, where the first
    8 bits are exponent. The rest of the 24 bits are mantissa. If, for example, target_value
    (in hexadecimal notation) is “17**2*f*4*f*7*b***”, the following predefined formula
    should be used to calculate the target_value of hash:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它显示了找到一个哈希值低于当前目标值比找到一个哈希值低于`difficulty_1_target`更为困难多少倍。难度是一个浮点值，在区块头的难度目标字段中，它由目标值的小数点和指数表示，其中前8位是指数。剩下的24位是尾数。例如，如果目标值（用十六进制表示）是“17**2*f*4*f*7*b***”，则应使用以下预定义公式来计算哈希的目标值：
- en: target_value = <math alttext="" altimg="../graphic/b_9783110681130-001_ingr_002.png"><mrow><mn
    mathvariant="bold">2</mn><mi mathvariant="bold">f</mi><mn mathvariant="bold">4</mn><mi
    mathvariant="bold">f</mi><mn mathvariant="bold">7</mn><mi mathvariant="bold">b</mi></mrow><mo>⋅</mo><msub><mrow><msup><mn>2</mn><mrow><mn>8</mn><mo>⋅</mo><mfenced
    open="(" close=")"><mrow><mn>17</mn><mo>−</mo><mn>3</mn></mrow></mfenced></mrow></msup></mrow><mrow><mfenced
    open="(" close=")"><mrow><mi>h</mi><mi>e</mi><mi>x</mi></mrow></mfenced></mrow></msub><mo>=</mo></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目标值 \( target_value = 2^{28} \cdot 17^{-3} \cdot hex(2f4f7b) = 0x... \)
- en: (1.3)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_003.png"><mtable
    columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00</mn><mrow><mn
    mathvariant="bold">2</mn><mi mathvariant="bold">f</mi><mn mathvariant="bold">4</mn><mi
    mathvariant="bold">f</mi><mn mathvariant="bold">7</mn><mi mathvariant="bold">b</mi></mrow><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: （1.3）\( 00000000 00000000 00 2f4f7b00000000 00000000 \)
- en: 'and using (1) and (2) we have the result for Difficulty (in decimals):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 利用（1）和（2），我们可以得到难度 \( Difficulty \)（十进制）的结果：
- en: (1.4)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_004.png"><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mo>=</mo><mn>5</mn><mo>,</mo><mn>949</mn><mo>,</mo><mn>437</mn><mo>,</mo><mn>371</mn><mo>,</mo><mn>609</mn></mrow></mrow><mrow><mrow><mn>.53</mn></mrow></mrow><mo>≈</mo><mrow><mrow><mn>5</mn></mrow></mrow><mrow><mrow><mn>.95</mn><mo>×</mo><mn>1</mn></mrow></mrow><mrow><msup><mrow><mrow><mn>0</mn></mrow></mrow><mrow><mrow><mrow><mn>12</mn></mrow></mrow></mrow></msup></mrow><mfenced
    open="(" close=")"><mrow><mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mn>5</mn></mrow></mrow><mrow><mrow><mn>.95</mn><mi
    mathvariant="normal">T</mi></mrow></mrow></mrow></mfenced></math>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （1.4）\( D_i ffciul ty = 5,949,437,371,609 \) ，约等于 \( 5.95 \times 10^{12} \)
    或 \( 5.95 \times 2^{32} \) 的 \( 0.53 \) 倍。
- en: 'The number of leading binary zeros in the target_value of hash can be calculated
    from Difficulty as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过难度 \( Difficulty \) 计算目标值 hash 的前导二进制零的数量：
- en: (1.5)<math alttext="Numberofleadingzeros=log2(Difficulty)+32" altimg="../graphic/b_9783110681130-001_eq_005.png"><mrow><mtext>Number</mtext><mtext>of</mtext><mtext>leading</mtext><mtext>zeros</mtext><mo>=</mo><msub><mrow><mi>log</mi></mrow><mn>2</mn></msub><mrow><mo>(</mo><mrow><mtext>Difficulty</mtext></mrow><mo>)</mo></mrow><mo>+</mo><mn>32</mn></mrow></math>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: （1.5）\( \text{Number of leading zeros} = \log_2(Difficulty) + 32 \)
- en: In this example, the result is 74.44\. This can also be seen from the hexadecimal
    representation of target_value in (3), where the first 18 nibbles (4-bit blocks)
    represent 72 binary zeros, and the next nibble 2[(hex)] = 0010[(bin)] adds two
    more zeros, which, on the whole, gives 74 leading zeros.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，结果是 74.44。这也可以从（3）中目标值 \( target_value \) 的十六进制表示看出，前18个字节（4位块）表示72个二进制零，下一个字节
    \( 2[(hex)] = 0010[(bin)] \) 又增加了两个零，总共给出了74个前导零。
- en: 'Suppose we want to assure that a block is verified every 10 min. In that case,
    Difficulty should be tuned relative to the computational power of the entire Bitcoin
    network, so that it can make a targeted number of calculations per second needed
    for achieving of the goal that average time for finding a hash below or equal
    to target_value is ten minutes. This number of hash operations per second (known
    as hash power or hash rate) can be derived and calculated from Difficulty as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要确保每10分钟验证一个区块。在这种情况下，Difficulty应相对于整个比特币网络的计算能力进行调整，以便能够实现目标，即找到一个散列值低于或等于目标值所需的目标平均时间是十分钟。每秒的散列操作次数（称为散列功率或散列率）可以从Difficulty以下方式导出和计算：
- en: (1.6)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_006.png"><mrow><mrow><mi
    mathvariant="normal">H</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">e</mi></mrow></mrow><mo>=</mo><mrow><mfrac><mrow><mfenced
    open="{" close="}"><mrow><mi>N</mi><mfenced open="(" close=")"><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfenced></mrow></mfenced></mrow><mrow><mn>10</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （1.6）\[Hash_rate=\frac{N(Difficulty)}{10min}\]
- en: 'where {*N*(Difficulty)} is the expected number of hash attempts (for a given
    Difficulty) before finding a valid hash:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中{*N*(Difficulty)}是在给定Difficulty下找到一个有效散列的期望尝试次数：
- en: (1.7)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_007.png"><mfenced
    open="{" close="}"><mrow><mi>N</mi><mfenced open="(" close=")"><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfenced></mrow></mfenced><mo>=</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mrow><mrow><mrow><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><mi
    mathvariant="normal">_</mi><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></mrow></mfrac></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: （1.7）\[N(Difficulty)=\frac{2^{256}}{targe_t\_value}\]
- en: 'By combining (2), (6), and (7), we have:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合（2）、（6）和（7），我们得到：
- en: (1.8)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_008.png"><mrow><mrow><mi
    mathvariant="normal">H</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">e</mi></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>10</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow><mo>⋅</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mstyle
    displaystyle="true"><mrow><mrow><mfrac><mrow><mrow><mrow><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow></mrow><mi
    mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mrow><mrow><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow></mrow><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfrac></mrow></mrow></mstyle></mfrac></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>600</mn><mi>s</mi></mrow></mfrac></mrow><mo>⋅</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mrow><mrow><msup><mn>2</mn><mrow><mn>224</mn></mrow></msup></mrow></mrow></mfrac></mrow><mo>⋅</mo><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="normal">D</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow></mrow><mo>⋅</mo><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow><mrow><mo>/</mo></mrow><mn>600</mn><mi>s</mi></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （1.8）\[H_a\]sh\[a\]rt\[e\]=\frac{1}{10m i n} \cdot \frac{2^{256}}{d i f f i
    c u l t y_{1_t a r g e t}}=\frac{1}{600s} \cdot \frac{2^{256} \cdot 2^{224}}{D
    i f f i c u l t y} \cdot D i f f i c u l t y=\frac{D i f f i c u l t y \cdot 2^{32}}{600s}
- en: For example, if Difficulty = 5.95 T, using (1.8), the hash rate is 42,587,731,567,771,
    900,000 hashes/s, that is, 42.6 Exahash per second (42.6 EH/s). With the same
    Difficulty, a computer with 16 TH/s processing power should be mining for around
    50 years to find a solution (time = 600s × 42.6EH/s / 16TH/s).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果难度为5.95 T，使用(1.8)，哈希率为42,587,731,567,771,900,000哈希/秒，即42.6每秒艾哈希（42.6 EH/s）。在相同的难度下，一台具有16
    TH/s处理能力的计算机应该需要大约50年的时间来找到一个解决方案（时间=600秒×42.6EH/s / 16TH/s）。
- en: 'This huge Difficulty makes it easier to find a particular sand grain among
    all of Earth’s sand grains than to find a successful hash. Mining pools can find
    a solution in about ten minutes due to their appropriate hash power. However,
    the disadvantage is the enormous consumption of (electric) energy. Currently,
    the total power spent by all Bitcoin miners in the world equals the energy consumption
    of a developed country. So, a logical question comes up: Why is it all necessary?
    Why the mining algorithm is designed that way, that is, with the artificially
    added computational difficulty?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个巨大的难度使得找到一个特定沙粒比找到一个成功哈希更容易。由于适当的哈希能力，矿池大约十分钟内可以找到一个解决方案。然而，缺点是（电）能源消耗巨大。目前，全世界比特币矿工的总耗电量等于一个发达国家的能源消耗。所以，一个逻辑问题出现了：这为什么是必要的？为什么挖矿算法是这样设计的，即人为添加的计算难度？
- en: 1.2.1 Concept of proof of work
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 工作量证明的概念
- en: The answer to the previous questions and to how new BTCs are issued can be found
    in the applied concept, PoW. The PoW concept is used for maintaining blockchain
    (DL) consistent, strong and unbreakable, which are key factors that create trustworthiness
    of the whole system and consensus in the community about the real value of cryptocurrency.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前问题的答案以及新比特币是如何发行的，可以在应用的概念——工作量证明（PoW）中找到。PoW概念用于维护区块链（DL）的一致性、强大且不可破解，这些都是创建整个系统信任度以及社区关于加密货币真实价值共识的关键因素。
- en: The concept of PoW is not new. It has been used in computer networks with client–server
    mechanisms as a measure to discourage Denial of Service (DoS) attacks and other
    abuses such as spam. The main property of PoW is its asymmetry – a client’s relatively
    hard work when compared to the ease with which the result can be checked by a
    server. In the case of a BTC blockchain, the result of the very difficult job
    of finding a valid nonce-hash pair by a successful miner (i.e., mining pool) is
    very easily confirmed by other miners.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明的概念并不新鲜。它已用于具有客户端-服务器机制的计算机网络中，作为阻止服务拒绝（DoS）攻击和其他滥用行为（如垃圾邮件）的措施。PoW的主要特性是其非对称性——客户端相对于服务器轻松检查结果的相对艰辛工作。在比特币区块链的情况下，成功矿工（即矿池）找到有效nonce-哈希对的非常困难工作的结果很容易被其他矿工确认。
- en: It has already been mentioned that the trustworthiness of the BTC also contributed
    to the decentralization of the blockchain. Let us remember that the BTC blockchain,
    as a DL of transaction blocks is realized using nodes, that is the computers connected
    to the BTC P2P network. BTC full nodes are the computers running the BTC Core
    client with the complete blockchain. A transaction is a process of sending BTCs
    from the BTC wallet (i.e., address) of a sender to the BTC wallet of a person
    who receives money. Money senders broadcast transactions to the network. Full
    nodes validate transactions and relay them to other nodes by broadcasting messages
    across the network. Within this decentralized infrastructure (P2P network), a
    set of miners collect transaction records, verify that each transaction is signed
    correctly and is not in conflict with previous transactions. They also check that
    the sender (whose identity is hidden behind an address) does not move more BTCs
    than is contained in the address (passing through the entire blockchain) and perform
    other functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提到过，比特币的信任度也促进了区块链的去中心化。让我们回想一下，比特币区块链作为一个交易块的DL，是通过节点实现的，即连接到比特币P2P网络的计算机。比特币全节点是运行着比特币核心客户端并拥有完整区块链的计算机。交易是将从发送者的比特币钱包（即地址）发送到收款人比特币钱包的比特币发送过程。货币发送者向网络广播交易。全节点验证交易，并通过广播消息跨网络将它们传递给其他节点。在这个去中心化的基础设施（P2P网络）中，一组矿工收集交易记录，验证每个交易是否正确签名且与之前的交易不冲突。他们还检查发送者（其身份隐藏在地址后面）不会移动比地址中包含的比特币更多的比特币（通过整个区块链）并执行其他功能。
- en: Each miner independently collects valid transactions and aggregates them into
    a candidate block. Then, a miner attempts to solve his candidate block through
    the PoW, that is, through the process of finding a valid hash (as described in
    Section 1.2). The first miner who successfully solves a candidate block broadcasts
    his solution to the network (including other miners) to be added to the blockchain.
    The key thing here is that the new block will be added to the blockchain only
    if more than 50% of miners say it has been solved correctly. And before saying
    that, miners have to make their calculations on the solved block, comparing their
    results to the solution that was broadcast. Two different candidate blocks may
    be solved at about the same time. In that situation, two solutions will propagate
    through the network (this situation is known as a blockchain fork). Still, eventually,
    only one will win, that is, it will be added to the blockchain (the first accepted
    by most miners). At the same time, the other solved block (the orphan) will stale,
    and the transactions from this block (the ones which are not included in the winning
    block) will wait for the next round, to be collected and verified within some
    of the forthcoming candidate blocks. The triggering moment for the decision of
    which of two solutions will win is after about 10 min, when the next block is
    added the first time (somewhere in the network) on top of the winning block. Then,
    the newly added block will be broadcast as the solution (where the previous winning
    block is included in the blockchain). The community will quickly accept it, assuming
    that the last added block was the only offered solution at the moment, which is
    the most common case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矿工独立收集有效的交易并将它们汇总到一个候选区块中。然后，矿工通过PoW（即寻找一个有效散列的过程，如第1.2节所述）尝试解决他的候选区块。成功解决一个候选区块的第一位矿工将他的解决方案广播到网络（包括其他矿工），以添加到区块链上。在此关键之处是，只有当超过50%的矿工表示它已经被正确解决时，新的区块才会被添加到区块链上。在表示之前，矿工需要在已解决的区块上进行计算，将他们的结果与广播的解决方案进行比较。两个不同的候选区块可能会在大约同一时间被解决。在这种情况下，两个解决方案将通过网络传播（这种情况被称为区块链分叉）。然而，最终只会胜出一个，即，它将被添加到区块链上（大多数矿工首先接受的）。与此同时，另一个已解决的区块（孤儿）将变得无效，并且来自这个区块的交易（未包含在胜出区块中的）将等待下一轮，被收集并在一些即将到来的候选区块中被验证。决定两个解决方案中将胜出的是在大约10分钟后，下一个区块首次（在网络的某个地方）添加到胜出的区块之上时。然后，新添加的区块将被广播为解决方案（其中包含之前的胜出区块在区块链中）。社区会迅速接受它，假设在那一刻只有一个解决方案被提出，这是最常见的情况。
- en: Having received the news that the candidate block has been solved, a miner should
    only verify that the solution is correct, as the solution is already known. However,
    although a solved block can be added to the blockchain only if it is verified
    by at least 50% of miners, they do not have to verify it. A miner first decides
    whether it should wait to verify the block before starting on the next block or
    start immediately with solving the next block, assuming the previous block was
    correct. The benefit of making the assumption is that there will not be any wasted
    time spent on verification, which increases the profit by about 10%. As a result,
    many large mining pools skip this verification process and, just using the newly
    appended blockchain, immediately start working on the next block.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 收到候选区块已被解决的的消息后，矿工应仅验证解决方案的正确性，因为解决方案已知。然而，尽管只有当至少50%的矿工验证通过后，才能将解决后的区块添加到区块链上，但矿工们并不需要进行验证。矿工首先决定是应该在开始下一个区块之前等待验证该区块，还是假设前一个区块是正确的立即开始解决下一个区块。做出这种假设的好处是，不会有时间浪费在验证上，这能增加大约10%的利润。因此，许多大型矿池跳过这一验证过程，仅仅使用新追加的区块链，立即开始工作在下一个区块上。
- en: Using a procedure involving PoW and the consensus of more than half of the participants,
    the so-called trustless truth is accomplished. Trustless truth is a term that
    denotes the state of a community where there is a consensus about something (here,
    about the trust in the BTC), whereby no one trusts anyone. Nevertheless, just
    because of this overall distrust, a set of rules (or a mechanism like PoW) is
    imposed on all participants. Eventually, everyone is confident about some common
    thing of interest.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过涉及PoW和超过一半参与者的共识过程，所谓的不可信真相得以实现。不可信真相是一个表示社区就某事达成共识（在这里，是对BTC的信任）的术语，从而没有人信任任何人。尽管如此，正因为这种普遍的不信任，所有参与者都受到一套规则（或像PoW这样的机制）的约束。最终，每个人都对某些共同利益的事物充满信心。
- en: In this case, the BTC blockchain is such a giant and reliable data structure,
    just because of the huge amount of computational work needed for its growth. This
    work (due to general distrust) must be proven through PoW and verified by the
    majority of miners. If someone tried to change (i.e., forge) some of the previous
    transactions, just to change the state of someone’s digital wallet, he would have
    to create a new consistent version of the blockchain (with one changed block).
    It would have to pass the verification process by the miners’ community. Changing
    a block inside the blockchain (which can only be done by making a new block containing
    the same predecessor) requires regenerating all successor blocks and redoing all
    the work they contain. This is practically impossible due to the tremendous work
    the forger would have to do, on its own. The more blocks in the blockchain after
    the targeted block there are, the more difficult it is to create some other version
    of the blockchain, which the targeted block tampers with. In this way, a decentralized
    system with incorporated trustless truth mechanisms gains the reputation of the
    monetary authority that only some centralized monetary institutions, for example,
    central banks in various countries enjoy,. Furthermore, the BTC has become a global
    monetary system that is not under the control of any government or any central
    authority.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，比特币（BTC）区块链就像一个巨大且可靠的的数据结构，这正是因为其成长需要大量的计算工作。这项工作（由于普遍的不信任）必须通过工作量证明（PoW）并由大部分矿工验证。如果有人试图篡改（即伪造）之前的某些交易，仅仅为了改变某人数字钱包的状态，他必须创建区块链的一个新的一致版本（其中一个区块被改变）。它必须通过矿工社区的验证过程。在区块链内改变一个区块（只能通过创建一个包含相同前驱块的新块来实现）需要重新生成所有后续区块，并重新执行它们包含的所有工作。由于伪造者必须独立完成大量的工作，这实际上是不可能的。在目标区块之后的区块链中区块越多，创建某种篡改目标块的区块链版本就越困难。正是这样，一个内置不信任真相机制的去中心化系统获得了只有某些集中的货币机构，例如，各国的中央银行才享有的货币权威声誉。此外，BTC已经成为一个不受任何政府或中央权威控制的全球货币系统。
- en: Apart from decentralization and PoW mechanism, the reason for such a sustainable
    development and value for the BTC also lies in the monetary policy, that is, in
    the policy of BTC issuance. It is the main motivating factor (the incentive) for
    the army of miners worldwide to do the transaction verification job. Although
    it seems now that every 10 min, a new number of BTCs appears out of thin air in
    the ever continuing process of block solving, the BTC, still, has no inflationary
    character – that is, the total amount of BTCs is limited by its design, which
    is why it is often called digital gold.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了去中心化和PoW机制之外，BTC可持续发展和价值的理由还在于货币政策，即BTC发行政策。这是全球矿工队伍进行交易验证工作的主要激励因素。尽管现在看来，每10分钟，新的BTC数量就会在解决块的过程不断出现，但BTC仍然没有通货膨胀的特性——也就是说，BTC的总量由其设计决定，这就是为什么它常被称为数字黄金。
- en: 'BTC is the oldest and most known digital currency launched on the Internet
    in 2009\. Now, it cannot exceed a total amount of 21 million (precisely: 20,999,999.9769
    BTC). In the beginning, the reward for solving the block was 50 BTC, and the Difficulty
    of the opening blocks in the blockchain was 1, that is, the hashes were with only
    8 leading binary zeros. As said before, the Difficulty of block solving adjusts
    every 2016 blocks, that is, about every 14 days, depending on the miners’ total
    computation power. The BTC block reward halves every 210,000 blocks. Currently,
    the reward is 6.25 BTC and was last halved from 12.5 BTC with block 630,000 on
    May 27, 2020\. Many miners may leave the job after that because of their reduced
    profit, but on the other hand, with miners’ reduced power, the Difficulty will
    be reduced accordingly. Consequently, less electricity will be required to mine
    each new BTC.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: BTC是2009年互联网上推出的最古老和最知名的数字货币。现在，它的总金额不能超过2100万（精确地说：20,999,999.9769 BTC）。最初，解决区块的奖励是50
    BTC，区块链中打开区块的难度是1，即散列值只有8个前导二进制零。如前所述，解决区块的难度每2016个区块调整一次，即大约每14天，根据矿工的总计算能力。BTC区块奖励每210,000个区块减半。目前，奖励是6.25
    BTC，上一次从12.5 BTC减半是在2020年5月27日的第630,000个区块。许多矿工可能会在那之后离开，因为他们的利润减少了，但另一方面，随着矿工权力的减少，难度也会相应降低。因此，挖掘每个新的BTC所需的电力将减少。
- en: Lastly, let us point out that by the year 2032, almost all BTCs will have been
    mined when the reward would drop below 1 BTC, and the only incentive of the miners
    (if anyone remains) will be the transaction fees. But it is not possible to have
    precise predictions about the BTC’s future and survival by that time, after all.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们指出，到2032年，当奖励降至1 BTC以下时，几乎所有的BTC都将被挖出，矿工（如果还有人留下的话）的唯一激励将是交易费用。但毕竟，不可能对BTC的未来和生存有精确的预测。
- en: 1.2.2 Vulnerabilities of the BTC and issues handling
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 BTC的漏洞和问题处理
- en: Even before the BTC, there had been attempts to create sustainable digital money.
    All the attempts had failed because there were no reliable mechanisms to successfully
    prevent scenarios in which transactions are copied and spent (i.e., realized)
    twice. It is good to know that the BTC successfully solves this double-spending
    problem through the blockchain concept with PoW, where each transaction is time-stamped.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在BTC之前，就有尝试创造可持续的数字货币。所有尝试都失败了，因为缺乏可靠机制成功防止交易被复制并两次花费（即实现）的场景。好在BTC通过PoW和区块链概念成功解决了这个双重支付问题，每个交易都有时间戳。
- en: A double-spending problem appears if two transactions (one of which is tricky)
    are sent into the network using the same private key (of a fraudulent money sender)
    to different receiving addresses. As these two transactions propagate through
    the network, one part of the network will accept one transaction and the other
    part, another. The defense mechanism inherent in the BTC blockchain is that only
    the transaction that miners first resolve into the next block (by any of two network
    parties) will be verified. The other one will be rejected as invalid. Such a confirmation
    mechanism through which the BTC manages the double-spending problem is enabled
    by a chronologically ordered, time-stamped transaction ledger, that is, by the
    blockchain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用相同的私钥（欺诈性货币发送者的）发送到不同接收地址的两个交易（其中一个是有欺骗性的）进入网络，就会出现双重支付问题。当这两个交易通过网络传播时，网络的一部分将接受一个交易，另一部分则接受另一个。BTC区块链固有的防御机制是，只有矿工首先在任何两个网络方解决到下一个区块的交易将被验证。另一个将被拒绝为无效。BTC通过时间顺序、时间戳的交易账本，即通过区块链，实现这种确认机制，从而成功处理双重支付问题。
- en: The other breakthrough incorporated in the BTC is the use of PoW as a probabilistic
    solution to the class of failures known as the Byzantine Generals Problem [[6](9783110681123_008192.xhtml#b_9783110681130-005_ref_006)],
    which is a generalized version of the Two Generals’ Problem. It can be said that
    the BTC P2P network as a distributed system is Byzantine fault-tolerant (BFT).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: BTC中另一个融入的突破是使用PoW作为解决一类称为拜占庭将军问题的失败概率解决方案[[6](9783110681123_008192.xhtml#b_9783110681130-005_ref_006)]，这是将军问题的泛化版本。可以说，BTC
    P2P网络作为分布式系统是拜占庭容错（BFT）。
- en: The Byzantine Generals Problem can be presented, in a nutshell, through the
    situation in which more generals (each with his army) have to reach a consensus
    about the time of the attack in the forthcoming battle against the surrounded
    enemy. If they don’t attack all together simultaneously, that is, if a few generals
    issue the order for attack and other generals do not, the enemy will overcome
    the armies that have attacked, gain strategic advantage, and eventually win the
    battle. Generals communicate to one another via messengers, that is, each general
    forwards a received message to the nearest few generals, depending on their spatial
    positions on terrain. The initial message with the information on the time of
    the attack is sent from the chief general to the few nearest generals and then
    relayed to the others. The problem occurs if some of the generals (the traitors)
    alter the received message and forward the messages with a different time of attack
    to other generals. This will lead to an unsynchronized attack and, eventually,
    to defeat in the battle. Since loyal generals do not know who the possible traitors
    are, they must create a communication protocol and the decision rules. These must
    ensure that, in a situation where some generals have received two or more messages
    with different times of attack, only the right message is accepted by all, and
    the false ones are rejected. It is shown [[7](9783110681123_008192.xhtml#b_9783110681130-005_ref_007)]
    that this problem can only be solved if the number of traitorous generals does
    not exceed one-third of all generals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题可以用一句话概括，即更多将军（每个都有自己的军队）必须就即将到来的战斗中对被包围的敌人发起攻击的时间达成共识。如果他们不同时一起攻击，也就是说，如果一些将军发布了攻击命令而其他将军没有，敌人将克服已经发起攻击的军队，获得战略优势，并最终赢得战斗。将军们通过信使相互沟通，也就是说，每位将军都将收到的消息转发给最近的几个将军，这取决于他们在地形上的空间位置。最初的含有攻击时间信息的消息是从总将军发送给最近的几个将军，然后转发给其他人。如果一些将军（叛徒）改变了收到的消息并将带有不同攻击时间的消息转发给其他将军，就会发生问题。这将导致攻击不同步，最终在战斗中失败。由于忠诚的将军不知道可能的叛徒是谁，他们必须创建一个通信协议和决策规则。这些必须确保在某些将军收到了两个或更多带有不同攻击时间的消息的情况下，只有正确的消息被所有人接受，而错误的消息被拒绝。文献[[7](9783110681123_008192.xhtml#b_9783110681130-005_ref_007)]表明，只有当叛徒将军的数量不超过所有将军的三分之一时，才能解决这个问题。
- en: When talking about the Byzantine Generals Problem in the context of distributed
    systems (such as the BTC P2P network), this problem concerns the corrupted components
    of the system having the symptoms that prevent other system’s components from
    reaching an agreement among them (i.e., consensus). Such an agreement is needed
    for the correct operation of the system. Byzantine fault assumes any fault that
    causes a component to present different symptoms to different parts of the system.
    A Byzantine fault tolerance (BFT) system can accomplish its correct functioning
    if there are not too many faulty components, that is, if, at most, one-third of
    all components are faulty. BFT systems often include PoW as the mechanism to combat
    false pieces of information from corrupted components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论分布式系统中的拜占庭将军问题（比如比特币P2P网络）时，这个问题涉及到系统中的腐败组件表现出阻止其他系统组件之间达成一致（即共识）的症状（i.e.,共识）。这种一致性对于系统的正确运行是必需的。拜占庭错误假设任何导致组件向系统的不同部分呈现不同症状的错误。拜占庭容错（BFT）系统如果腐败组件不多，即最多只有一
    third 的组件出现故障，就能实现其正确功能。BFT系统通常包括PoW作为对抗腐败组件提供虚假信息机制。
- en: If we want to translate the Byzantine Generals Problem into a BTC environment,
    we can have a situation with a solved candidate block. Having found the solution,
    the miner adds the block to the blockchain (say, the *n*-th block) and broadcasts
    it to other nodes. Then, other nodes check the received blockchain with the added
    *n*-th block. Having done it and confirming the nonce, each miner adds this new
    block to the top of its copy of the blockchain. When the other miners continue
    adding the next solved blocks about every 10 min (i.e., blocks *n *+ 1, *n *+ 2,
    … ) on top of block *n*, that block becomes solidified. The latest block on the
    top of the blockchain is usually unstable, but once there are more blocks on top
    of it, it is said to be more guaranteed. As each new block is difficult to add
    (because of PoW), a block within the blockchain is said to be secure after one
    hour approximately, that is, when six blocks are added after it. This is why most
    cryptocurrency exchanges and other services that accept Bitcoin usually wait for
    the so-called six blocks confirmation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将拜占庭将军问题翻译成比特币环境中的情景，我们可以设想一个已解决候选区块的情况。找到解决方案后，矿工将区块添加到区块链（比如说第*n*个区块）中，并将其广播给其他节点。然后，其他节点用添加的第*n*个区块检查收到的区块链。完成这一步并确认nonce后，每个矿工都将这个新块添加到其区块链复制品的顶部。当其他矿工在大约每10分钟继续添加一个已解决的区块（即区块*n*+1、*n*+2、…）到区块*n*的顶部时，这个区块就固化了。区块链顶部的最后一个区块通常是不稳定的，但是一旦它上面有更多的区块，它就被认为更加有保障。由于每个新块都难以添加（因为需要工作量证明PoW），所以在区块链中的一个区块在添加大约一个小时后就被认为是安全的，也就是说，在其后面添加了六个区块后。这就是为什么大多数加密货币交易所和其他接受比特币的服务通常会等待所谓的六区块确认。
- en: The last added block in the blockchain is considered unstable because it is
    quite possible (but not very often) that at that time, some other miner can find
    another solution and thus cause a fork in the blockchain. In this situation, the
    blockchain is split into two competing paths forward. Forks in a BTC blockchain
    appear regularly, and so far, each fork has been quickly resolved when an additional
    block was added to one of these two arms of the blockchain (which was lucky to
    be first prolonged). At the same time, the entire network abandons the block from
    the other arm (the orphan) since the winning arm contains more PoW. Hypothetically,
    if a fork remains unresolved, two competing blockchain histories would co-exist,
    compromising the whole system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中最后添加的区块被认为是不可靠的，因为当时很可能（但并不经常发生）另一个矿工能找到另一个解决方案，从而在区块链中引起分叉。在这种情况下，区块链被分成两条竞争性路径。BTC区块链的分叉经常出现，到目前为止，每当在一个区块链的这两条路径上添加一个额外的区块（幸运的是首先延伸的那条路径）时，每个分叉都会迅速解决。与此同时，整个网络放弃另一条路径（孤儿路径）的区块，因为胜出的路径包含了更多的PoW。假设如果一个分叉未能解决，两条竞争性的区块链历史将会共存，从而损害整个系统。
- en: Theoretically, the Byzantine Generals Problem could appear if several miners
    or a mining pool do not follow the generally accepted rules when new blocks are
    added – namely, a very powerful attacker could try to troll the BTC community
    by adding enough hash power and outperforming the entire hash power of the network
    (the so-called “51% attack” [[8](9783110681123_008192.xhtml#b_9783110681130-005_ref_008)]).
    One could try to impose their version of a blockchain, that is, initiate forking
    so that the last few (still unsolidified) blocks in the blockchain are replaced
    by some other blocks (in the new branch of the blockchain). These blocks might
    contain false transactions that nullify the transactions from the regular blockchain
    branch (causing double-spending) or corrupt the blockchain in another way. The
    attacker’s version of the blockchain will be propagated through the network and
    accepted by the rest of the miners’ community only if it contains more PoW than
    the regular version. This could happen only if the attacker owns a computing power
    sufficient to solve six consecutive blocks in a row (i.e., faster than the rest
    of miners). The probability of such an event in a given time becomes almost 100%,
    as the attacker’s hash power comes closer to 50% of the total mining power [[9](9783110681123_008192.xhtml#b_9783110681130-005_ref_009)].
    In 2014, six blocks were solved in a row by the same mining pool, which concentrated
    more than 40% of the total hash power owned by the entire mining community. But
    then, some of the miners from that mining pool voluntarily moved to other pools
    trying to prevent unwanted effects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果几个矿工或一个矿池在添加新块时没有遵循普遍接受的规定，拜占庭将军问题可能会出现——即，一个极其强大的攻击者可能会通过增加足够的哈希算力并超越网络的整体哈希算力（所谓的“51%攻击”）[[8](9783110681123_008192.xhtml#b_9783110681130-005_ref_008)]]
    来嘲讽BTC社区。攻击者可能会尝试推行他们版本的区块链，也就是，发起分叉，以使区块链中的最后几个（尚未固定的）区块被其他区块替换（在区块链的新分支中）。这些区块可能包含虚假交易，使常规区块链分支的交易无效（导致双重花费）或以其他方式损坏区块链。只有当攻击者的区块链版本包含比常规版本更多的PoW时，攻击者的区块链版本才会通过网络传播并被其他矿工社区接受。这只有在攻击者拥有解决连续六个区块的计算能力（即比其他矿工快）时才可能发生。在给定时间内发生此类事件的可能性几乎达到100%，因为攻击者的哈希算力接近整个挖矿能力的50%[[9](9783110681123_008192.xhtml#b_9783110681130-005_ref_009)]。2014年，同一个矿池连续解决了六个区块，该矿池集中了整个矿工社区超过40%的哈希算力。但是，然后，该矿池的一些矿工自愿移至其他矿池，试图防止不良后果。
- en: An attacker might have significant hash power in a grey situation (somewhere
    between 30 and 50%), where there may be two or more different versions of a blockchain
    in the network. Consequently, it would lead to the crash of the BTC. But this
    will not happen due to the introduced PoW, which significantly reduces the probability
    of solving six consecutive blocks by the same entity. Besides, one may think that
    even with such a reduced probability, the attacker would have enough time to crash
    the system eventually. However, it is practically impossible, just due to the
    hash power added by the attacker. This is because, due to the increased overall
    computational power, the Difficulty of the involved PoW will also increase (after
    a maximum of two weeks). As a result, the attacker’s hash power will still not
    be large enough to achieve his intention. So, it can be said that the BTC blockchain
    is a BFT system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能在一个灰色情境中拥有显著的哈希算力（大约在30%到50%之间），在这种情况下，网络上可能存在区块链的两个或更多不同版本。因此，这可能导致BTC的崩溃。但是，由于引入了PoW，同一个实体连续解决六个区块的概率被大幅降低，因此这种情况不会发生。此外，有人可能会认为，即使概率已经降低，攻击者仍会有足够的时间最终崩溃系统。然而，实际上这是不可能的，仅因为攻击者增加的哈希算力。这是因为，由于整体计算能力的提高，涉及的PoW的难度也会增加（在最多两周之后）。因此，攻击者的哈希算力仍然不足以实现其目的。所以，可以说BTC区块链是一个BFT系统。
- en: BTC’s market value has reached several peaks so far. On the other hand, this
    increase in value motivated many attackers to try to hack or manipulate the BTC
    system, and a similar situation arose with a few other cryptocurrencies. Among
    many network-based types of attacks, two might disrupt the operation of the BTC
    network – partition attack and Delay Attack. Both attacks exploit some weaknesses
    of the Border Gateway Protocol (BGP) – not to confuse with the Byzantine Generals
    Problem – a broadly used routing protocol by the routers on the Internet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 至今BTC的市场价值已经达到了几个高峰。另一方面，这种价值的增加激励了许多攻击者尝试黑掉或操纵BTC系统，类似的情况也出现在少数其他加密货币上。在许多网络攻击类型中，两种可能会中断BTC网络的运行——分区攻击和延迟攻击。这两种攻击都利用了边界网关协议（BGP）的一些弱点——不要与拜占庭将军问题混淆，这是一个在互联网上由路由器广泛使用的路由协议。
- en: These and other network-based attacks are possible since the BTC network is
    highly centralized, as seen from the Internet protocol routing perspective, –
    namely the three most significant Tier-1 Internet providers can intercept more
    than 60% of connections in the BTC network [[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)].
    Apart from that, more than 60% of all BTC nodes are concentrated in five countries,
    led by the USA with around one-quarter of all nodes. On the other hand, mining
    power is concentrated in only one country – Chinese mining pools control approximately
    80% of total hash power. The largest five mining pools are located in China, which
    mines approximately 70% of all new BTCs [[11](9783110681123_008192.xhtml#b_9783110681130-005_ref_011)].
    As a result, the centralization of mining power in a single country is one of
    the biggest issues for the BTC community, at the moment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BTC网络高度集中，从互联网协议路由的角度来看，即三个最大的 Tier-1 互联网提供商可以拦截BTC网络中超过60%的连接[[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)]。除了这一点，超过60%的BTC节点都集中在五个国家，美国为首，拥有约四分之一的所有节点。另一方面，挖矿能力集中在只有一个国家——中国的挖矿池控制着大约80%的总哈希能力。最大的五个挖矿池位于中国，挖掘约70%的所有新BTC[[11](9783110681123_008192.xhtml#b_9783110681130-005_ref_011)]。因此，挖矿能力集中在单一国家是BTC社区目前面临的最大问题之一。
- en: The precondition of a partition attack is the isolation of a group of victim
    nodes from the BTC network, where an attacker deliberately voids Internet traffic
    from/to the attacked nodes. In this way, the BTC network is split into two parts
    by the attacker (the smaller and the bigger), with no communication between them.
    Consequently, the block is solved in both network parts, and then each solved
    block is broadcast within its part. When the attacker stops the attack and establishes
    the communication between these parts again, all blocks mined within the smaller
    part (with less mining power) will be discarded, as will all the transactions
    and the miners’ revenue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分区攻击的前提条件是将一组受害者节点从BTC网络中隔离，其中攻击者故意取消针对被攻击节点的互联网流量。这样，攻击者将BTC网络分为两部分（一部分较大，一部分较小），它们之间没有通信。结果，这两个网络部分都解决了区块，然后在每个部分内广播已解决的区块。当攻击者停止攻击并重新建立这些部分之间的通信时，所有在较小部分（具有较少的挖矿能力）挖出的区块都将被丢弃，以及所有交易和矿工的收入也将被丢弃。
- en: The Delay Attack effectively slows down the propagation of blocks towards a
    victim. The main goal is to keep the victim node uninformed about a new block
    for almost 20 min. Unlike a partition attack where the victim’s connection is
    voided, in a delay attack, the attacker conducts a Man-in-the-Middle attack between
    a victim and its peer node, modifying BTC messages sent from the victim. Due to
    the manipulation, a victim node (i.e., the miner) gets a different piece of information
    from the requested as the answer, that is, it gets what it did not ask for – that
    is, after mining a new block somewhere in the network, the new block’s hash is
    announced and propagated through the network, reaching the victim node via its
    peer and via the attacker who intercepts the communication between the victim
    and its peer. Then, through the same channel (TCP connection with the peer node),
    the victim requests the solved block that matches the received hash. Nevertheless,
    the attacker alters this request to the peer (on behalf of the victim) by requesting
    the previously solved block that matches the other (i.e., the earlier) hash. After
    that, the victim’s peer node sends the requested older block to the victim, and
    upon receipt, the victim ignores that block (as outdated) but still waits for
    the next 20 min to repeat the request. Eventually, the victim receives the right
    block from the same peer (while TCP connection with the peer is still alive).
    When the victim finally gets the asked block, it is too late then, as a new block
    is (most probably) solved and added to the blockchain. In this way, the victim
    wastes its computing power and time instead of solving the next block. The possible
    profit is lost as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟攻击有效地减缓了区块向受害者的传播速度。主要目标是让受害节点几乎20分钟内无法获取新区块的信息。与分区攻击不同，在这种攻击中，受害者的连接被切断，攻击者在受害节点和其对等节点之间进行中间人攻击，修改从受害者发送的BTC消息。由于这种操纵，受害者节点（即矿工）从请求的答案中得到不同的信息，也就是说，它得到了它没有询问的——即在网络的某个地方挖出新区块后，新区块的散列值被宣布并通过网络传播，通过其对等节点以及通过拦截受害者和其对等节点之间通信的攻击者到达受害者节点。然后，通过相同的通道（与对等节点的TCP连接），受害者请求与接收到的散列值匹配的已解决区块。然而，攻击者将这个请求改为对等节点（以受害者的名义）请求另一个（即更早的）散列值匹配的已解决区块。之后，受害者的对等节点将请求的旧区块发送给受害者，收到后，受害者忽略这个区块（因为过时），但仍等待20分钟重复请求。最终，受害者从同一对等节点收到正确的区块（同时与对等节点的TCP连接仍然有效）。当受害者最终得到请求的区块时，已经太晚了，因为一个新的区块（很可能）已经被解决并添加到区块链中。这样，受害者浪费了自己的计算力和时间，而不是解决下一个区块。潜在的利润也会丢失。
- en: Various measures can be used to combat or prevent both partition and Delay Attacks.
    They may include multi-homing [[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)]
    of a mining pool (to prevent Delay Attack), various filtering techniques applied
    by Internet service providers (against partition attack), BGP traffic monitoring,
    or upgrades of the BGP protocol (on appropriate routers) with security patches.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用多种措施来对抗或预防分区攻击和延迟攻击。这些措施可能包括矿池的多重接入[[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)]（以防止延迟攻击）、互联网服务提供商采用的各种过滤技术（对抗分区攻击）、BGP流量监控或在适当的路由器上升级BGP协议（带安全补丁）。
- en: 'Numerous threats to different entities of the BTC system can also appear, which
    might cause problems if not treated properly. Without going into details, let
    us just name some of them: theft vulnerability of digital wallets, Sybil attack
    [[12](9783110681123_008192.xhtml#b_9783110681130-005_ref_012)] (through creation
    of pseudo-identities of nodes), Denial of Service (DoS) attacks, energy consumption,
    tracing a coin’s history (connecting identity with address), clock drift on a
    victim node (time jacking), illegal content in the blockchain, and so on.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币系统的不同实体可能会出现多种威胁，如果处理不当，可能会导致问题。不详细说明，我们只需列举其中一些：数字钱包的盗窃漏洞、Sybil攻击[[12](9783110681123_008192.xhtml#b_9783110681130-005_ref_012)]（通过创建节点的伪身份）、拒绝服务（DoS）攻击、能源消耗、追踪币的历史（将身份与地址连接）、受害节点上的时钟漂移（时间劫持）、区块链中的非法内容等等。
- en: 1.2.3 Alternative platforms and cryptocurrencies based on blockchain
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 替代平台和基于区块链的加密货币
- en: In the previous sections, the focus was on the BTC as the oldest and most prominent
    cryptocurrency. Besides, it served as a suitable example to explain the blockchain
    concept and mechanisms such as DL, PoW, community consensus, trustless truth,
    or incentive mechanism.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，重点关注了BTC作为最古老和最突出的加密货币。此外，它还作为一个合适的例子来解释区块链概念和机制，如去中心化交易（DL）、工作量证明（PoW）、社区共识、无需信任的真相，或者激励机制。
- en: The success of the BTC paved the way for many alternate cryptocurrencies, known
    as altcoins. Among hundreds of altcoins, many are based on the same framework
    as the BTC, that is, they too include P2P network, blockchain, and a mining process
    with a kind of PoW to verify transactions on the web. On the other hand, altcoins
    differ among themselves and differ from the BTC in many ways – such as in PoW
    algorithms, procedural variations, different ways of spending energy for block
    mining, or the improvements taken for achieving better anonymity of users. After
    the BTC, the new alternate cryptocurrencies that emerged were created with the
    main goal of replacing the BTC, or, at least, repeat its success. Many altcoins
    are targeting the perceived constraints and shortcomings of the BTC and aim to
    achieve a few competitive advantages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: BTC的成功为许多替代加密货币（山寨币）铺平了道路。在成百上千的山寨币中，许多是基于与BTC相同的框架，也就是说，它们也包含P2P网络、区块链以及一种PoW来验证网络上的交易。另一方面，山寨币之间以及与BTC在许多方面都有所不同——比如在PoW算法、程序变化、不同的挖矿能量消耗方式，或为提高用户匿名性所做的改进。在BTC之后，新出现的替代加密货币的主要目标是取代BTC，或者至少重复它的成功。许多山寨币旨在解决BTC所认为的限制和缺点，并力求取得一些竞争优势。
- en: More than 1,500 altcoins have been created and launched on the Internet until
    now, and the new ones can show up at any time. However, many older cryptocurrencies
    are no longer present on the market. Currently, some of the altcoins with the
    largest market capitalizations are Ether (ETH), Cardano (ADA), Ripple (XRP), Litecoin
    (LTC), Zcash (ZEC), Dash (DASH), and Monero (XMR).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，已经有超过1500种山寨币在互联网上被创建并推出，新的山寨币随时可能出现。然而，许多较早的加密货币已不再在市场上流通。目前，市值最大的几种山寨币包括以太坊（ETH）、卡尔达诺（ADA）、瑞波币（XRP）、莱特币（LTC）、门罗币（ZEC）、达世币（DASH）和门罗币（XMR）。
- en: LTC, often mentioned as the silver to the BTC’s gold, is very similar to the
    BTC in terms of functionality. The main differences are the average time needed
    for block solving of 150 s (four times shorter than the BTC’s 10 min), the total
    amount of coins that can be mined (84 million LTCs compared to 21 million BTCs),
    and the applied PoW algorithm – LTC runs a script. This sequential function also
    involves SHA-256 [[13](9783110681123_008192.xhtml#b_9783110681130-005_ref_013)]
    computations of hash but requires much more memory than the BTC’s hash computations
    (known as double hash or hash-hash algorithm).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: LTC，常被称为BTC的银，在功能上与BTC非常相似。主要区别在于平均解块时间需要150秒（比BTC的10分钟短四倍），可挖矿的硬币总数（8400万LTC与2100万BTC），以及所采用的工作量证明（PoW）算法——LTC运行一个脚本。这个顺序函数还涉及SHA-256
    [[13](9783110681123_008192.xhtml#b_9783110681130-005_ref_013)]哈希计算，但比BTC的哈希计算（称为双哈希或哈希哈希算法）要求更多的内存。
- en: ETH is a bit more specific since it is not a digital currency – it, is not meant
    to be used for online payment of goods and services but as the incentive mechanism
    to power the Ethereum blockchain. In other words, ETH is the native digital currency
    (token) of the Ethereum network, based on which the Ethereum blockchain is designed
    for various decentralized applications using smart contracts (see Section 2).
    With the public Ethereum network’s mining process, about every 12–15 s, a new
    block is verified, and the reward for this is 5 ETH. The PoW algorithm (called
    ethash) requires more memory than the one in the BTC. And also, for running various
    DApps, universal computing hardware is needed (like CPUs), so the expensive ASIC
    chips specialized in BTC mining, are not suitable for Ethereum mining.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊（ETH）稍微具体一些，因为它不是一个数字货币——它不是用来在线支付商品和服务的，而是作为推动以太坊区块链的激励机制。换句话说，ETH是以太坊网络的本地数字货币（代币），基于此，以太坊区块链被设计用来支持使用智能合约的各种去中心化应用（参见第2节）。在公共以太坊网络的挖矿过程中，大约每12-15秒，一个新的区块被验证，奖励是5
    ETH。PoW算法（称为ethash）比BTC的算法需要更多的内存。而且，为了运行各种DApps，还需要通用计算硬件（如CPU），所以专门用于BTC挖矿的昂贵ASIC芯片，不适用于以太坊挖矿。
- en: The Ethereum DLT was the pioneer of the second generation of blockchain systems.
    Unlike the BTC, they are capable of smart contacts and decentralized applications.
    For a long time, Ethereum has been the only viable choice for DL platform selection
    for DApps. The possible alternatives were immature or had lacking DL ecosystems
    (see Section 2.7.1). The Ethereum technology is implemented in a large public
    network, with important crypto-market capitalization. In addition, the Ethereum
    ecosystem (see Section 2.7.1.1.) provides efficient community support, development
    tools, and libraries. Alternatives to PoW consensus have been supported in the
    Ethereum clients before, and one can use them in private or consortium networks.
    In 2021, the Ethereum Foundation also marked a clear migration path from the PoW
    consensus in the public network to the PoS. The Ethereum technology is, therefore,
    always an option for most advanced DApp designs. For the same reasons, many examples
    in this book refer to the Ethereum network, nodes, and applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊分布式账本技术（DLT）是第二代区块链系统的先驱。与比特币（BTC）不同，以太坊支持智能合约和去中心化应用。长期以来，以太坊一直是分布式应用（DApps）选择DL平台的可行选择。之前的可行替代方案要么不够成熟，要么其分布式账本生态系统存在不足（见第2.7.1节）。以太坊技术已在大规模的公共网络中实施，并且拥有重要的加密货币市场市值。此外，以太坊生态系统（见第2.7.1.1节）提供了高效的社区支持、开发工具和库。在以太坊客户端中，对工作量证明（PoW）共识的替代方案早已得到支持，并且可以在私有或联盟网络中使用。2021年，以太坊基金会也明确标识了从公共网络中的PoW共识迁移到权益证明（PoS）的清晰路径。因此，以太坊技术始终是大多数先进DApp设计的一个选项。出于相同的原因，本书中许多例子都涉及到以太坊网络、节点和应用。
- en: Nevertheless, other viable DLTs and ecosystems are emerging. Some of them are
    presented in Section 2.7.1\. They might differ from Ethereum in some of the approaches
    taken but share many of the common principles related to DL networks, performance,
    decentralized applications, and security, covered in Sections 2\. and 3.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，其他可行的DLT和生态系统正在涌现。其中一些在第2.7.1节中介绍。它们可能在某些方法上与以太坊不同，但它们与分布式账本网络、性能、去中心化应用和安全等常见原则（在第2节和第3节中介绍）有很多共同之处。
- en: 1.3 IOTA project – tangle
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 IOTA项目——纠缠
- en: The Internet of Things (IoT) is becoming a reality with the expectation of deploying
    billions of IoT devices (shortly). Many of them are to be involved in different
    kinds of money transactions and micropayments. Therefore, there appeared a need
    for providing a universal platform that would support a huge number of transactions
    efficiently. This support should be much better than what the existing blockchain
    platforms can provide. A solution that should obtain key support to the IoT is
    offered by the IOTA project [[14](9783110681123_008192.xhtml#b_9783110681130-005_ref_014)].
    It is a new distributed ledger technology significantly different than the blockchain.
    IOTA is based on a specific DAG structure known as tangle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）随着预期部署数十亿个物联网设备（很快）而成为现实。其中许多将涉及不同类型的货币交易和微支付。因此，出现了一种需要提供一个能够有效支持大量交易的平台的需求。这种支持应该比现有区块链平台能够提供的要好得多。为物联网提供关键支持的解决方案由IOTA项目提供[[14](9783110681123_008192.xhtml#b_9783110681130-005_ref_014)]。这是一种与区块链显著不同的新的分布式账本技术。IOTA基于一种特定的有向无环图（DAG）结构，称为纠缠。
- en: The IOTA project began in 2015, intending to provide a more suitable cryptocurrency
    for payments (transactions) between billions of future IoT devices and obtain
    a reliable platform for many other applications, which might include M2M communication
    between those devices. As such, the implementation of the IOTA protocol had to
    be cheap, fast, and scalable, which was the key explanation for developing the
    tangle, instead of using already mature blockchain technology. The rapid growth
    of IoT significantly increased the demand for micropayments between IoT devices.
    At first, the BTC was seen to solve the needs of micropayments. However, it did
    not prove to be a good choice for two reasons. The first r is the relatively high
    fees as the amounts of money included in transactions reduce with micropayments,
    and the other reason is the roles of participants. – some miners verify transactions
    and “normal users” who issue transactions in the BTC society; hence, miners may
    be issuers, too. With this ambiguity, the probability of possible conflicts stays
    high, and conflict resolution wastes everyone’s resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: IOTA 项目始于 2015 年，旨在为未来的数十亿物联网设备提供更适合的加密货币支付（交易）方式，并为许多其他应用提供一个可靠的平台，这些应用可能包括设备间的机器对机器（M2M）通信。因此，IOTA
    协议的实施必须具有成本低廉、速度快和可扩展的特点，这是开发网络而不是使用已经成熟的区块链技术的关键解释。物联网的快速增长显著增加了物联网设备之间的微支付需求。起初，BTC
    被认为可以解决微支付的需求。然而，有两个原因使其并不适合。第一个原因是相对较高的费用，因为随着微支付的进行，交易中的金额减少，而另一个原因是参与者角色不明确。在
    BTC 社会中，一些矿工验证交易，“正常用户”发行交易；因此，矿工也可能是发行者。这种模糊性使得潜在冲突的概率保持高位，冲突解决浪费了每个人的资源。
- en: The key differences between IOTA and other blockchain-based systems such as
    the BTC or Ethereum are that IOTA’s DLT includes no miners, no transaction blocks,
    no transaction fees or rewards paid in IOTA tokens, and no difficult PoW. Instead,
    when a participant broadcasts a transaction, the first thing to be done is to
    validate, that is, approve two (randomly chosen) previous transactions and perform
    a small amount of PoW. As a reward, the transaction is allowed to be attached
    to those two previous ones. After that, the attached transaction (called a tip)
    waits to be approved by a new transaction (of another participant), which then
    waits for its approval, later on. This pay-it-forward verification system makes
    financial rewards unnecessary.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 BTC 或以太坊等其他基于区块链的系统相比，IOTA 的主要区别在于，IOTA 的分布式账本技术不包含矿工、交易区块、以 IOTA 代币支付的交易费或奖励，也没有复杂的工作量证明（PoW）。相反，当一个参与者广播一个交易时，首先要做的就是验证，即批准两个（随机选择的）前一个交易并执行少量
    PoW。作为奖励，该交易被允许附着在这两个前一个交易之后。之后，被附着的交易（称为提示）等待另一个参与者的新交易批准，然后该新交易又等待其后的批准。这种传递式验证系统使得金融奖励变得
    unnecessary。
- en: Besides, the whole amount of the cryptocurrency (the IOTA tokens or IOTAs, in
    short) has already been created at the beginning of the tangle (i.e., at the genesis
    moment) and distributed to the project founders. After different transactions
    between participants (the founders and the new participants), IOTAs change hands.
    The smallest amount of IOTAs is one token (unlike the BTC, it is not divisible),
    while the total amount created in the genesis is (3^(33)−1)/2 ≈ 2.779 × 10^(15)
    IOTAs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，整个加密货币的总数（即 IOTA 代币或简称 IOTAs）已经在网络的起点（即创世纪时刻）创建完毕，并分发给了项目创始人。在参与者（创始人及新参与者）之间的不同交易中，IOTA
    代币会易手。IOTA 代币的最小单位为一件代币（与 BTC 不同，它不可分割），而创世纪时刻创建的总数为 (3^(33)−1)/2 ≈ 2.779 × 10^(15)
    IOTAs。
- en: As mentioned before, a tangle is a DAG, where each point represents an individual
    transaction (and not a transaction block), while arrows represent approvals. On
    a graph representing the tangle, each transaction points to the two previous transactions
    (the so-called parents) approved by that transaction (the so-called child). To
    clarify, the approvals (arrows on the graph) are in the opposite direction of
    the timeline’s direction ([Fig. 1.4](#b_9783110681130-001_fig_004)). A transaction
    can be approved many times directly (by the transactions that directly point to
    it) or indirectly (by all further transactions that may indirectly point to it,
    following the arrows on the graph).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所提到的，梅尔叉（Merkle）是一种DAG（有向无环图），其中的每个点代表一个单独的交易（而不是交易区块），而箭头则代表批准。在表示梅尔叉的图中，每个交易指向其批准的两个之前的交易（所谓的父交易）。为了说明，图中的批准（箭头）方向与时间线的方向相反([图1.4](#b_9783110681130-001_fig_004))。一个交易可以直接（由直接指向它的交易）或间接（由可能间接指向它的所有后续交易，跟随图中的箭头）获得多次批准。
- en: '![](../graphic/converted/b_9783110681130-001_fig_004.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_004.jpg)'
- en: 'Fig. 1.4: Tangle – graph representation.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：梅尔叉的图表示法。
- en: The first transaction in the tangle is called genesis. All IOTAs were created
    in the genesis, and there is no mechanism ever to create new ones. All transactions
    in the tangle approve the genesis directly or indirectly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 梅尔叉中的第一个交易被称为创世纪。所有的IOTA都是在创世纪中创建的，并且再也没有新的机制来创建新的IOTA。梅尔叉中的所有交易直接或间接地批准创世纪。
- en: Having been approved by a large number of newer transactions, a transaction
    becomes a part of the consensus that is practically impossible to be changed.
    The consistency of a tangle is accomplished through a small PoW computation that
    has to be done by each transaction, making it too difficult for an attacker to
    fork or spam the tangle after consensus has been achieved. The consensus about
    a valid transaction is reached by applying the Random Walk Monte Carlo (RWMC)
    Algorithm [[15](9783110681123_008192.xhtml#b_9783110681130-005_ref_015)]. This
    algorithm has to do with the way a new transaction selects two parent transactions
    to approve. The algorithm practically guides the transaction towards the tips
    (the not-approved transactions, yet) that have parents as young as possible. However,
    it is possible (but with a small probability) to select lazy tips, that is, tips
    that directly approve some older transactions (already verified by some earlier
    transactions in the past).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个交易被大量新交易批准后，它就成为了实际上不可能被改变的一部分共识。梅尔叉的一致性是通过每个交易必须完成的小型工作量证明（PoW）计算来实现的，这使得攻击者在达成共识后
    fork 或 spam 梅尔叉变得非常困难。有效的交易的共识是通过应用随机游走蒙特卡洛（RWMC）算法来实现的[[15](9783110681123_008192.xhtml#b_9783110681130-005_ref_015)]。这个算法与新交易选择两个父交易来批准的方式有关。该算法实际上引导交易走向尽可能年轻父母的尖端（尚未批准的交易）。然而，选择懒惰尖端（直接批准一些较旧交易，这些交易已经被过去的一些早期交易验证过）是有可能的（但概率很小）。
- en: The mechanism of selection of a tip from the set of actual tips at the moment
    (in which it is also possible to be selected a lazy tip) is based on a random
    walk through the graph from the genesis towards the tangle’s end (along the timeline),
    that is, towards the tips. When a particular tip is reached (i.e., selected),
    the walk stops. The walk is performed one more time, so that two tips are chosen
    first for validation. If the chosen tips are successfully validated (i.e., checked
    for inconsistency), they become parent transactions of the new transaction (which,
    practically, directly approves its parents). The cumulative weight of a transaction
    in the tangle is the total number of all transactions that came after, and at
    the same time, approved that transaction directly or indirectly (more precisely,
    this total number is additionally increased by 1). During the walk, at each branching
    point, the branch that will be chosen is the one that leads towards the next child
    transaction and that has the largest cumulative weight. Nevertheless, a certain
    amount of randomness will be introduced in the walk, that is, the transactions
    with the biggest cumulative weights at each branching point may not always be
    included in the path. It can be said that the walk is guided towards the heaviest
    branch. As new transactions come up, the tangle is forced to grow fastest in the
    directions that follow the paths with the heaviest transactions (in the sense
    of the cumulative weight). In contrast, the transactions appended to the lightest
    branches are orphaned, that is, it is most likely that they will never become
    a part of the consensus (since the probability of their approval by any new transaction
    is small). The growth of the tangle reminds one of the forced growth of a tree
    in one direction (e.g., where the tree receives the most light), while the growth
    in other directions is also possible but significantly reduced.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前时刻从实际尖端集合中选择一个尖端（也可以选择一个懒惰尖端）的机制是基于从创世纪向纠缠末端（沿着时间线）的随机游走，即向尖端。当达到一个特定的尖端（即，被选中）时，游走停止。再次执行一次游走，以便首先选择两个尖端进行验证。如果选定的尖端成功验证（即，检查不一致性），它们成为新交易的父母交易（实际上，直接批准其父母）。在纠缠中交易的累积权重是后来所有交易的总数，同时，这些交易直接或间接地（更准确地说，这个总数还会额外增加1）。在游走过程中，在每个分叉点，将被选择的分支是引导向下一个子交易的分支，并且具有最大的累积权重。尽管如此，在游走中会引入一定量的随机性，即在每个分叉点，具有最大累积重量的交易可能不会总是包含在路径中。可以说，游走被引导向最重的分支。随着新交易的产生，纠缠被迫在具有最重交易（就累积权重而言）的方向上最快增长。相比之下，附加到最轻分支上的交易是孤儿化的，即，它们最有可能永远不会成为共识的一部分（因为任何新交易批准它们的概率很小）。纠缠的增长让人联想到一棵树在某一方向上的强制生长（例如，树在该方向上接收最多的光线），而在其他方向上的生长也是可能的，但显著减少。
- en: In the description given so far, the transactions in the tangle’s interior are
    indirectly approved by all or by the majority of tips (~ 95% of tips). For that
    reason, they are considered confident and are expected to be present in the tangle
    forever, that is, there is a consensus on their immutability as parts of the ledger.
    The cumulative weight of a transaction is the measure of PoW performed after it,
    which secures the transaction’s consistency and immutability in the same way that
    a block in a blockchain is secured and consolidated by PoW of later blocks. Larger
    cumulative weight of a transaction indicates that the transaction is more confident.
    When a transaction in the tangle reaches enough cumulative weight, it is safely
    included in the consensus. This is equivalent to the claim that the transaction
    becomes a part of the consensus if it is validated (mostly indirectly) by the
    majority of tips.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止给出的描述中，纠缠内部的交易由所有或大多数尖端间接批准（~ 95%的尖端）。因此，它们被认为是可靠的，并预计将永远存在于纠缠中，即，就其作为账本一部分的不可变性达成共识。交易的累积权重是在其之后执行的PoW量，它以与区块链中区块通过后续块的PoW确保一致性和不可变性相同的方式，确保交易的
    consistency and immutability。交易的累积权重越大，表明交易越可靠。当纠缠中的交易达到足够的累积权重时，它安全地包含在共识中。这相当于声称，如果交易由大多数尖端（主要间接）验证，则该交易成为共识的一部分。
- en: A common characteristic of blockchain-based systems and IOTA/tangle platform
    is that the IOTA network is also a P2P network of nodes (i.e., users, entities,
    and participants). But unlike, for instance, the BTC, nodes are entities, which,
    by design, both validate and issue transactions, since before issuing a transaction,
    a node must approve two earlier transactions issued by other nodes. Furthermore,
    each node is incentivized to remain active in propagating new transactions from
    other nodes through the network, although a node may not have other new transactions
    to issue. We need to avoid terminology confusion between nodes in the IOTA P2P
    network and sites in the tangle. A site is a transaction (issued by a node) in
    a tangle graph representation. Additionally, the tangle (as a representative of
    DLs) is the ledger for storing transactions that consist of a set of sites issued
    by nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基于区块链的系统和IOTA/tangle平台的一个共同特征是，IOTA网络也是一个节点的P2P网络（即用户、实体和参与者）。但是与BTC等系统不同，节点是实体，设计上既验证也发布交易，因为在一个节点发布交易之前，必须批准其他节点发布的两个早期交易。此外，每个节点都有动力在网络上传播来自其他节点的交易，尽管该节点可能没有其他新交易需要发布。我们需要避免在IOTA
    P2P网络中的节点和tangle中的网站之间的术语混淆。网站是在tangle图表示中由节点发布的交易。此外，tangle（作为DL的代表）是存储由节点发布的一组网站的交易账本。
- en: As for matters of timing, it can be said that the IOTA network is asynchronous,
    where a transaction may be issued at any moment by some node, and, after propagation
    through the network, it reaches different nodes at different time instances. This
    means that any other node, at the moment when it issues its transaction, does
    not operate with the actual state of a tangle but with the state from a few moments
    ago. Consequently, a node, while running a tip selection algorithm, is unaware
    of the hidden tips that the node would be informed of shortly after that moment.
    Each node keeps (i.e., refreshes) its version of the tangle. In general, the versions
    on different nodes are not the same. Different nodes may see (more or less) different
    sets of transactions at any moment. However, these differences relate, at the
    most, to hidden tips, the newest tips, and recently verified transactions. In
    contrast, older transactions as a part of the consensus are common (i.e., the
    same) for a great majority of nodes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 至于时间问题，可以说IOTA网络是异步的，其中某个节点可以在任何时刻发布交易，并且在网络传播后，它会在不同的时间实例到达不同的节点。这意味着在任何其他节点发布其交易的时刻，它并不操作tangle的实际状态，而是操作几秒钟前的状态。因此，在运行提示选择算法时，节点不知道那些在此刻之后不久会被告知的隐藏提示。每个节点保持（即刷新）其tangle的版本。一般来说，不同节点上的版本并不相同。不同的节点在任何时刻可能看到（或多或少）不同的交易集。然而，这些差异最多只与隐藏提示、最新提示和最近验证的交易有关。相比之下，作为共识的一部分，较旧的交易对于大多数节点来说是共同的（即相同的）。
- en: A node does not always necessarily contain the latest version of the ledger
    or continuously forwards received updates (the new received tips) to its neighbors
    (peers) in the network. It is quite possible that when a node has a new transaction
    to issue, it can choose to verify two parent transactions from an older state
    of the tangle (when the node may work offline and is not always connected to the
    Internet). After verification, the node broadcasts its new transaction (which
    is appended to the verified parent transactions) through the network. The node
    does not help the community as it does not approve any new transaction.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 节点并不总是包含账本的最新版本，也不总是将其接收到的更新（新的接收到的提示）转发给网络中的邻居（对等节点）。节点有可能会在较早的账本状态下验证两个父交易（当节点可能离线工作且不总是连接到互联网时）（此时节点会选择验证两个父交易）。验证后，节点通过网络广播其新交易（附加到已验证的父交易上）。由于节点不批准任何新交易，因此它并不帮助社区。
- en: On the other hand, such lazy behavior is punished by the protocol in two ways.
    Firstly, the issued transaction will probably be considered by the remaining part
    of the network as a lazy tip, because other active nodes have fresher versions
    of the tangle. Since the lazy tips will be most probably orphaned, it is unlikely
    that such transactions will ever become a part of the consensus. Nodes are motivated
    to maintain their ledger versions as fresh as possible. Secondly, nodes are directly
    motivated to share new transactions from other nodes, as they increase the probability
    of verifying their recently issued transactions in that way. When verified, they
    also increase their cumulative weights, which enlarge the chances of becoming
    part of the consensus, finally. However even in a case when a node has no transactions
    for issuing, it is incentivized to propagate transactions from other nodes. According
    to the protocol, the mechanism that forces nodes to propagate transactions is
    that every node calculates the statistics about the number of new transactions
    received from each peer. If a node does not share new transactions, it will be
    dropped by its peers. So, next time the node has a transaction to issue, it will
    not be able do it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种懒惰行为会被协议在两个方面惩罚。首先，发行的交易可能会被网络的其余部分认为是懒惰的尖端，因为其他活跃节点有更新的tangle版本。因为懒惰的尖端很可能会变成孤儿节点，所以这种交易不太可能成为共识的一部分。节点有动力保持他们的账本版本尽可能新鲜。其次，节点有直接的动力去分享来自其他节点的交易，因为这样做可以增加他们验证最近发行的交易的几率。当验证成功，他们的累计权重也会增加，这增加了成为共识一部分的机会。然而，即使在一个节点没有发行交易的情况下，它也有动力传播其他节点的交易。根据协议，迫使节点传播交易机制是每个节点计算从每个对等节点接收的新交易的数量。如果一个节点不分享新交易，它将被它的对等节点抛弃。所以，下次节点有交易要发行时，它将无法做到。
- en: With the above-described incentive mechanisms, which do not include any transaction
    fee, the tangle is getting cheap – one of the desired features in IoT applications
    (which is not the case with Ethereum and other blockchains). Tangle is seen as
    a good IoT support, as it is also fast and scalable. Unlike blockchain, tangle
    does not assume transaction blocks, so the number of transactions per second is
    measured in thousands, that is, it is much higher than in a BTC blockchain. And
    also, the tangle is scalable by design, since the more transactions are created,
    the more transactions are validated and confirmed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述描述的激励机制，且不包含任何交易费用，网络延迟降低——这是物联网应用中期望的功能（以太坊和其他区块链则不然）。因为tangle支持物联网，并且速度快、可扩展，所以被看作是一个良好的物联网支撑。与区块链不同，tangle不假设交易区块，所以每秒的交易次数以千计，也就是说，远高于比特币区块链。另外，tangle的设计本身就是可扩展的，因为创建的交易越多，验证和确认的交易也就越多。
- en: The participants issuing transactions also contribute to the tangle’s security
    through resolving possible conflicts – namely, during the verification of two
    parent transactions, a node checks if the verified transactions are conflicting.
    A transaction may be conflicting with some other transaction (i.e., with the tangle
    history) in different ways. For example, an entity (a person or an IoT device)
    purchasing some goods or service and sending IOTA tokens to the other entity (seller)
    in a transaction, may have a negative account balance calculated from all previous
    transactions in the tangle (beginning from the genesis event). The negative balance
    can be a result of conflict between earlier transactions. Also, even with a positive
    account state, a dishonest entity might spend its money twice by issuing two different
    transactions to different sellers in a short period (double-spending problem),
    resulting in two conflicting transactions. As there is no conflict prevention
    mechanism, the tangle may contain pairs of conflicting transactions for a while.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 发行交易的参与者通过解决可能存在的冲突也为tangle的安全性做出贡献——具体来说，在验证两个父交易时，一个节点检查已验证的交易是否冲突。一个交易可能与其他交易（即tangle历史）以不同方式冲突。例如，一个实体（一个人或物联网设备）在交易中购买一些商品或服务，并将IOTA代币发送给另一个实体（卖家），可能从tangle中的所有先前交易（从创世纪事件开始）中计算出一个负余额。负余额可能是早期交易之间的冲突结果。另外，即使账户状态为正，一个不诚实的实体也可能在短时间内向不同的卖家发行两笔不同的交易（双重花费问题），导致两个冲突的交易。因为没有冲突预防机制，tangle可能暂时包含一对冲突的交易。
- en: When a node selects two tips for its child transaction to be appended to them,
    it has to validate those tips first. The validation of a tip includes checking
    the tip’s signature and its PoW, as well as making sure that the tip is not in
    conflict with any of the transactions in its validation path, that is, with the
    transactions which are directly and indirectly referenced (i.e., validated) by
    this tip. Suppose the node finds that the selected tip conflicts. The node leaves
    that tip and chooses another one, while the previously selected tip is forgotten.
    In that way, a node resolves conflicts directly. The same happens if the node
    finds a conflict between any two transactions in the validation path of the selected
    tip. In that case, the conflict is said to have been resolved indirectly. If a
    node issues a new transaction that indirectly approves conflicting transactions,
    it risks that other nodes will not approve its new transaction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点为其子交易选择两个顶点时，它首先必须验证这些顶点。验证一个顶点包括检查顶点的签名和它的算力证明，以及确保顶点与其验证路径中的任何交易不冲突，即与这个顶点直接和间接引用（即验证）的交易。假设节点发现所选顶点存在冲突。节点放弃该顶点并选择另一个，而之前选定的顶点将被遗忘。这样，节点直接解决冲突。如果节点发现所选顶点验证路径中的任何两个交易之间存在冲突，情况也是如此。在这种情况下，冲突被认为是以间接方式解决的。如果一个节点发布的新交易间接批准了冲突交易，那么它就有风险，其他节点不会批准其新交易。
- en: Another situation in which the tangle performs self-purification through resolving
    conflicts is when a node selects two tips where the validation path of the first
    tip contains a transaction that conflicts with a transaction in the validation
    path of the second selected tip. This is when none of the two transactions in
    the conflict belongs to the intersection of validation paths of these two tips.
    In such a case, the node does not see the conflict. Therefore, both of the two
    conflicting transactions are indirectly approved by the node by appending its
    transaction to the selected tips. Furthermore, a few new transactions might be
    appended to it without seeing the conflict.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，当一个节点选择两个顶点，其中第一个顶点的验证路径包含与第二个选定顶点验证路径中的交易冲突的交易时，网络通过解决冲突进行自我净化。在这种情况下，两个冲突交易都不属于这两个顶点验证路径的交集。在这种情况下，节点看不到冲突。因此，节点通过将交易附加到选定的顶点间接批准了这两个冲突交易。此外，可能还有几个新的交易附加到它而看不到冲突。
- en: Nevertheless, a new transaction will select a tip with the validation path containing
    both conflicted transactions sooner or later. Then, the conflict will be registered
    and resolved by abandoning that tip. That tip will be orphaned together with several
    previous transactions that the tip has directly or indirectly validated. These
    orphaned transactions will include only one of the conflicting transactions (and
    a few subsequent transactions which have approved it). In contrast, the branch
    that contains the second conflicting transaction (the one with a higher cumulative
    weight) will survive. Hence, the conflict is resolved, and only one of the two
    conflicting transactions stays in the ledger. Several innocent transactions, which
    have approved the other conflicting transaction (because they had not been in
    a position to detect the conflict), will be orphaned as collateral damage. However,
    most probably, they will be picked up and reissued by the participants (nodes)
    involved in these transactions as sellers (payment recipients).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新的交易最终会选择一个包含两个冲突交易的验证路径的顶点。然后，冲突将被注册并通过对该顶点的放弃来解决。与该顶点直接或间接验证的几个先前交易也将变成孤儿交易。这些孤儿交易只包含冲突交易中的一个（以及批准它的几个后续交易）。相比之下，包含第二个冲突交易（具有更高累积权重）的分支将存活下来。因此，冲突得到解决，只留下两个冲突交易中的一个在账本中。几个无辜的交易，因为它们没有处于检测冲突的位置而批准了另一个冲突交易，将作为附带损害变成孤儿交易。然而，很可能，它们会被参与这些交易的卖方（收款方）节点捡起并重新发布。
- en: As already pointed out, a tangle began in the genesis event, where the very
    first transaction started distributing a predefined total amount of IOTA tokens.
    As the tangle grows and the total number of transactions increases, the size of
    the ledger is continually getting bigger, which may be a problem, especially for
    IoT applications. To reduce the size of a tangle, the IOTA Foundation makes snapshots
    of the full network from time to time. A snapshot contains states on the accounts
    of all users (wallets’ balances), but it does not contain transaction history,
    that is, all previous transactions are erased. Such a snapshot represents a new
    genesis state of a tangle (like a new beginning), but with the difference that
    the total amount of 2.779 × 1015 tokens has already been distributed to all existing
    users at that moment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经指出的，在创世事件中就开始出现了一个混乱的局面，那时最初的交易开始分配一个预定义的IOTA代币总量。随着tangle的增长和交易总数的增加，账本的大小也在不断增大，这对于物联网应用来说可能是一个问题。为了减小tangle的大小，IOTA基金会时不时地从全网络中抓取快照。一个快照包含了所有用户账户的状态（钱包余额），但它不包含交易历史，也就是说，所有之前的交易都被抹去了。这样的快照代表了一个tangle的新创世状态（就像一个新的开始），不同之处在于到那一刻，2.779×10¹⁵个代币已经被分配给了所有现有的用户。
- en: Currently, the IOTA network is not fully developed, and the number of users
    is far beyond the number for which the tangle was initially designed. As a result,
    the community’s total computing power (hash rate) is still relatively low. Consequently,
    the current tangle is vulnerable to double-spending attacks, which would be possible
    if an attacker owned more than one-third of the total network hash rate. To prevent
    attacks of this kind and for security reasons, IOTA users apply (voluntarily and
    temporarily) a different consensus mechanism through the so-called Coordinator.
    This mechanism assumes that the IOTA Foundation issues a milestone transaction
    every two minutes. All transactions approved directly or indirectly by a milestone
    transaction are immediately considered part of consensus (i.e., with the confirmation
    confidence of 100%). In the future, when the IOTA network reaches a large enough
    computing power, the Coordinator will not be necessary, that is, IOTA Foundation
    will shut it down and let the tangle evolve entirely on its own.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，IOTA网络还没有完全发展起来，用户数量远远超过了tangle最初设计的用户数量。结果，社区的总体计算能力（哈希率）仍然相对较低。因此，当前的tangle容易受到双重支付攻击，如果攻击者拥有超过总网络哈希率的三分之一，这种攻击是可能的。为了防止这类攻击和出于安全考虑，IOTA用户（自愿且暂时）通过所谓的协调员应用不同的共识机制。这种机制假设IOTA基金会每两分钟发布一个里程碑交易。所有直接或间接由里程碑交易批准的交易立即被认为是共识的一部分（即，具有100%的确认信心）。将来，当IOTA网络达到足够的计算能力时，协调员将不再必要，也就是说，IOTA基金会将关闭它，让tangle完全自主地发展。
- en: A special characteristic of the tangle is that all processing and software calculations
    are run in ternary logic, or more precisely, in the balanced ternary logic. Unlike
    binary computing, where a binary digit (bit) can take one of two values (0 and
    1), a digit in a balanced ternary, called Tritt, can be –1, 0, or + 1\. A word
    of three Tritts is called Tryte (analogously to byte), and it can have 3³ = 27
    different states (values). Each of Tryte states is designated in IOTA with one
    of the 26 uppercase letters “A”, “B”, “C”, …, “X”, “Y”, “Z” and the number “9”
    as a symbol (symbol “9” in balanced ternary logic represents value + 1).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: tangle的一个特殊特征是所有的处理和软件计算都是在三进制逻辑中进行的，更确切地说，是在平衡三进制逻辑中进行的。与二进制计算不同，在那里一个二进制数字（位）可以有两个值（0和1），平衡三进制中的一个数字，称为Tritt，可以是-1、0或+1。由三个Tritts组成的一个词称为Tryte（与字节相对应），它可以有3³=27种不同的状态（值）。Tryte状态中的每一个在IOTA中用一个大写字母“A”、“B”、“C”…、“X”、“Y”、“Z”和数字“9”作为符号表示（在平衡三进制逻辑中，符号“9”代表值+1）。
- en: Computer theory defines a measure for the efficiency of a hypothetical computer
    with the radix (base) *R*, called radix economy, as the product of *R* and the
    number of digits in that base. Theoretically, base *e* = 2.71 (Euler’s number,
    i.e., the base of natural logarithm) would be maximally efficient in storing information.
    Still, for a real computer, radix *R* = 3 is the best choice, since this is the
    integer closest to *e*. Furthermore, balanced ternary has an advantage over positive
    ternary (also called vanilla ternary, where digits can have values 0, 1, and 2)
    in allowing the encoding of positive and negative numbers in the same way. There
    is no such thing as the binary representation of negative numbers in the 2’s complement,
    so no-sign Tritt is needed. Also, there are other advantages, for example, simpler
    truth tables for digit addition, subtraction, multiplication, and division.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机理论定义了一个用于衡量假设计算机效率的量，即基数*R*的基数经济，是*R*和该基数下的数字数量的乘积。从理论上讲，基数*e*=2.71（即欧拉数，自然对数的基数）在存储信息方面是最有效的。然而，对于实际的计算机来说，基数*R*=3是最佳选择，因为这是最接近*e*的整数。此外，平衡三进制在允许以相同方式编码正负数方面比正三进制（也称为香草三进制，其中数字可以具有值0、1和2）具有优势。在2的补码中不存在负数的二进制表示，因此需要无符号Tritt。此外，它还有其他优点，例如，更简单的真值表用于数字加法、减法、乘法和除法。
- en: The rationale for involving ternary computing in IOTA is also based on research
    in this area, whereby ternary and quantum computing are seen as the near future.
    Ternary computers (except a few experimental ones) do not exist. Therefore, the
    whole ternary logic (including computing of cryptographic hash function, like
    SHA-3) is emulated and run by conventional binary computers in IOTA.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及三进制计算在IOTA中的理由也基于这一领域的研究所得，即三进制和量子计算被视为不久的将来。三进制计算机（除了一些实验性的）并不存在。因此，整个三进制逻辑（包括计算加密哈希函数，如SHA-3）在IOTA中是由传统的二进制计算机模拟和运行的。
- en: 1.3.1 IOTA bundle
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 IOTA捆绑包
- en: As we have already previously explained, a new transaction’s first step is to
    select two tips (using the random walk) that are to be approved by that transaction.
    And yet, the real implementation is a bit more complicated since, most commonly,
    a common transaction is issued through the so-called bundle of several individual
    transactions ([Fig. 1.5](#b_9783110681130-001_fig_005)), where each transaction
    has the same value as its internal field named Bundle Hash. In other words, for
    each real transfer of IOTAs from one participant to another, the appropriate software
    client issues not only one transaction but a chain of *N* individual transactions
    related to that transfer (which are indexed in reversed order from *N *– 1 to
    0). All transactions in a bundle together approve the two selected tips according
    to a specific scheme (this will be explained in the following chapters).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前已经解释过的，一个新交易的第一个步骤是选择两个端点（使用随机游走）来被那个交易批准。然而，真正的实现稍微有点复杂，因为通常，一个公共交易是通过所谓的几个单独交易组成的捆绑包发行的（[图1.5](#b_9783110681130-001_fig_005)），其中每个交易都有与其内部字段“捆绑哈希”相同的值。换句话说，对于从一方到另一方的每个IOTA的实际转移，相应的软件客户端发行的不仅仅是
    一个交易，而是一系列*N*个与该转移相关的单独交易（这些交易从*N*-1到0反向索引）。捆绑包中的所有交易共同根据特定方案批准所选的两个端点（这将在接下来的章节中解释）。
- en: '![](../graphic/converted/b_9783110681130-001_fig_005.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_005.jpg)'
- en: 'Fig. 1.5: Transactions bundling in a tangle – an example of a bundle with six
    transactions.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：在纠缠中交易的捆绑 - 一个包含六个交易的捆绑包的例子。
- en: The selected tip chosen after the first random walk is called the trunk tip.
    The other tip, which is chosen after the second random walk, is called the branch
    tip. The first individual transaction in the bundle (with index *N *– 1) approves,
    that is, points to both trunk and branch tip, while the remaining *N *– 1 individual
    transactions (with indices from *N *– 2 to 0) all together point to the trunk
    tip. Each of these *N *– 1 transactions, besides the trunk tip, also approves
    the previous transaction in the bundle (with the index higher by 1) through the
    internal field Trunk Transaction (which contains the hash value of the previous
    transaction in the bundle), see [Fig. 1.6](#b_9783110681130-001_fig_006). This
    means that the value written in the Trunk Transaction field is equal to the value
    written in the Transaction Hash field of the previous transaction in the bundle.
    In contrast, the value of the Branch Transaction field is equal to the hash of
    the trunk tip (written in the Transaction Hash field of the trunk tip). As already
    explained, the first transaction in the bundle approves both selected tips, but
    in a slightly different way – its Trunk Transaction field now points to the trunk
    tip, and the Branch Transaction field points to the branch tip.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次随机游走后选择的最尖端被称为树干尖端。另一个尖端是在第二次随机游走后选择的，被称为分支尖端。束中的第一个个人交易（索引为*N* – 1）批准，即，同时指向树干尖端和分支尖端，而剩下的*N*
    – 1个个人交易（索引从*N* – 2到0）都一起指向树干尖端。除了树干尖端之外，这些*N* – 1个交易中的每一个都通过内部字段树干交易（其中包含束中前一个交易的哈希值）批准束中的前一个交易（索引高一个），见[图1.6](#b_9783110681130-001_fig_006)。这意味着树干交易字段中的值等于束中前一个交易的交易哈希字段的值。相比之下，分支交易字段的值等于树干尖端的哈希（写入交易哈希字段中的树干尖端）。如前所述，束中的第一个交易批准了两个选定的尖端，但方式略有不同——现在它的树干交易字段指向树干尖端，而分支交易字段指向分支尖端。
- en: '![](../graphic/converted/b_9783110681130-001_fig_006.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_006.jpg)'
- en: 'Fig. 1.6: Way of transactions bundling in a tangle.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：在网络中交易的束绑方式。
- en: In the end, each tip belongs to its bundle as the last (not approved) individual
    transaction of the bundle, since the random walk algorithm selects only those
    not-yet-approved transactions (each of the earlier transactions in a bundle is
    already approved by the last one, i.e., by the tip).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个尖端都属于其束的一部分，作为束中最后的（未批准的）个人交易，因为随机游走算法只选择那些尚未批准的交易（束中的每个早期交易已经被最后一个交易，即尖端所批准）。
- en: 'There are three types of individual transactions in an IOTA bundle: input,
    output, and meta transaction. The type of a transaction depends on the sign of
    the number written in the internal field, Value, representing the amount of IOTA
    tokens (IOTAs) that are to be added (through this individual transaction) to the
    account specified by the field, Address. As a result, the content of the field,
    Value, in an input transaction is a negative number, which means that the given
    address is charged for the specified amount of IOTAs. An output transaction adds
    IOTAs to the given address since the written value is positive, while a Meta transaction
    is neutral as the value written in it equals 0\. Meta transactions are used as
    extensions of input transactions, usually having the tail parts of the input transactions’
    signatures.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在IOTA束中有三种个人交易类型：输入、输出和元交易。交易类型取决于内部字段中数值的符号，Value，它表示将通过个人交易添加（通过这个交易）到由字段Address指定的账户中的IOTA代币（IOTAs）的数量。因此，输入交易中的Value字段是一个负数，这意味着给定的地址被收取了指定数量的IOTAs。由于输出交易中的数值为正，因此它将IOTAs添加到给定的地址，而元交易是中性的，因为其中写入的值等于0。元交易通常用作输入交易的扩展，通常具有输入交易签名的尾部部分。
- en: 'Let us explain it with the following example: if client A wants to make a purchase
    and transfer, for example, 700 IOTAs to client B, the client software on A’s side
    will create a bundle of input, output, and (probably) meta transactions which
    are to be integrated into the tangle. Thereby, either all transactions inside
    the bundle will be accepted by the nodes in the IOTA network or none of them.
    In the process of bundle creation, at first, the output transaction containing
    the address *b* of client B in the Address field and the positive value of 700
    in the Value field is prepared. This transaction gets assigned index 0 (this transaction
    is indexed as the beginning of the bundle of *N* transactions, but it will be
    issued last in time, in the burst of *N* bundled transactions).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的例子来解释：如果客户端A想要进行一笔购买并转账，比如将700个IOTA转给客户端B，A端的钱包软件将会创建一组输入、输出交易（可能还会有元交易），这些交易需要集成到tangle中。这样，要么这个交易包内的所有交易都会被IOTA网络中的节点接受，要么一个也不接受。在创建交易包的过程中，首先准备一个输出交易，在交易地址字段中包含B客户端的地址*b*，在交易价值字段中填写正数700。这个交易被分配索引0（这个交易作为*N*个交易交易包的起始交易，但会在*N*个交易包一起发布时最后发出）。
- en: 'Next, the input and meta transactions are prepared. If client A has, for example,
    three addresses (i.e., three accounts) *a*[1], *a*[2], and *a*[3] generated from
    the same private keys seed, with the account states of 200, 600, and 350 IOTAs
    on them, respectively, the three corresponding input transactions will have the
    following values written in the Index, Address and Value fields: {1, *a*[1], –200},
    {3, *a*[2], –600} and {5, *a*[3], –350}. Since input transactions need to contain
    transaction signatures where the address security level is two by default, a meta
    transaction is added after each input transaction to carry the second part of
    the signature of the preceding input transaction. These three meta transactions
    will have the following indices, addresses, and values: {2, *a*[1], 0}, {4, *a*[2], 0}
    and {6, *a*[3], 0}.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，准备输入和元交易。如果客户端A有三个地址（即三个账户）*a*[1]、*a*[2]和*a*[3]，由相同的私钥种子生成，分别在其账户状态下有200、600和350个IOTA，那么这三个相应的输入交易将在索引、地址和价值字段中填写以下值：{1,
    *a*[1], –200}、{3, *a*[2], –600}和{5, *a*[3], –350}。因为输入交易需要包含默认安全级别为二的地址的交易签名，所以每个输入交易后面都添加一个元交易以携带前一个输入交易的第二部分签名。这三个元交易将有以下索引、地址和价值：{2,
    *a*[1], 0}、{4, *a*[2], 0}和{6, *a*[3], 0}。
- en: An output transaction is prepared as the last one to balance the transfer (the
    so-called remaining transaction). Since client A spent 200 + 600 + 350 = 1,150 tokens
    through the three input transactions, and client B received 700 tokens through
    the first output transaction, a new output transaction is created, which returns
    the difference of 1,150 – 700 = 450 tokens to client A. This transaction has index
    7 (the biggest in the bundle), value 450 (positive), and address *a*[4] (created
    from the same seed as the addresses *a*[1], *a*[2], and *a*[3] of client A).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个作为最后交易的输出交易以平衡转账（所谓的剩余交易）。因为客户端A通过三个输入交易花费了200+600+350=1,150个代币，而客户端B通过第一个输出交易收到了700个代币，因此创建一个新的输出交易，将1,150-700=450个代币返给客户端A。这个交易有索引7（在交易包中最大），价值450（正数），地址为*a*[4]（由与客户端A的*a*[1]、*a*[2]、*a*[3]地址相同的种子创建）。
- en: 'In the end, the complete bundle in a given example contains eight individual
    transactions with the following {“Index”, “Address”, “Value”} triplets: {0, *b*, 700},
    {1, *a*[1], –200}, {2, *a*[1], 0}, {3, *a*[2], –600}, {4, *a*[2], 0}, {5, *a*[3], –350},
    {6, *a*[3], 0}, and {7, *a*[4], 450}. The first and last transactions in this
    example are of the output type, while the transactions in the middle are of input
    or meta-type. In general, the total number of transactions in a bundle is not
    limited, but practically, under given network constraints and limitations of the
    PoW difficulty, the issuance of bundles with over 30 transactions is discouraged.
    A typical bundle for a transfer between two clients (sender and receiver of tokens)
    consists of four transactions: one output (to receiving client), one input (from
    sender), one meta-transaction, and the balancing transaction.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给定示例中的完整交易包包含了八个单独的交易，其包含的{“Index”, “Address”, “Value”}三元组如下：{0, *b*, 700},
    {1, *a*[1], –200}, {2, *a*[1], 0}, {3, *a*[2], –600}, {4, *a*[2], 0}, {5, *a*[3],
    –350}, {6, *a*[3], 0}, 和 {7, *a*[4], 450}。在此示例中，第一个和最后一个交易属于输出类型，而中间的交易属于输入或元类型。通常，交易包中的交易总数是没有限制的，但实际上，在给定的网络约束和PoW难度限制下，不鼓励发行包含超过30笔交易的交易包。两个客户端之间（令牌发送者和接收者）进行转账的一个典型交易包由四个交易组成：一个输出（给接收者），一个输入（来自发送者），一个元交易，以及一个平衡交易。
- en: 1.4 Hashgraph
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 哈希图
- en: 'Led by the BTC development so far, blockchain technology has made a significant
    breakthrough in the DL area and has opened up the opportunity for creating numerous
    decentralized applications, apart from cryptocurrency (which is only one of them,
    but the most popular one). Several DL systems based on DAGs have also emerged,
    aiming to develop new technologies with the best possible and most desirable features.
    However, these features are often in opposition to one another. Hence, the existing
    systems such as BTC, Ethereum, or IOTA/Tangle are just the trade-offs based on
    the level of their realization. An ideal DLT should certainly have the following
    properties: immutability, low latency, security, scalability, low computing difficulty,
    DDoS resistance, as well as modesty in Internet bandwidth requirements. It is
    also important that such a system should not require any expensive server. It
    should be fair, fast, cheap, and Byzantine fault-tolerant. Finally, it should
    have the ability to achieve a consensus under circumstances of the absolute trustless
    truth, that is, enforce the community’s rules, even when nobody trusts anyone.
    A good candidate that fulfills all these requirements is a DL platform known as
    hashgraph.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由比特币的发展至今所引领，区块链技术在分布式账本领域取得了重大突破，并除了加密货币（这只是其中之一，但最受欢迎）之外，为创建众多去中心化应用开辟了机会。基于DAG的几个分布式账本系统也应运而生，旨在开发具有最佳可能和最理想特性的新技术。然而，这些特性往往是相互对立的。因此，现有的系统如比特币、以太坊或IOTA/Tangle只是基于它们实现水平的权衡。一个理想的分布式账本技术（DLT）应该当然具备以下属性：不可变性、低延迟、安全性、可扩展性、低计算难度、DDoS抵抗性，以及网络带宽要求的谦逊。此外，这样一个系统不应当需要任何昂贵的服务器。它应当是公平、快速、便宜，并具有拜占庭容错性。最后，它应当具备在绝对不可信的事实情况下达成共识的能力，即，执行社区的规则，即使没有人信任任何人。满足所有这些要求的良好的候选者是一个名为hashgraph的分布式账本平台。
- en: Hashgraph [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)] is a
    new DAG-based consensus alternative to the blockchain. Simply put, a DAG is a
    finite directed graph without loops between any two elements. In graph theory,
    a graph is a structure consisting of a set of points (vertices, elements, squares)
    where any two points can be in relation, that is, connected by a line (edge, arc).
    A directed graph means that each line between two points is directed, that is,
    has an arrow. Thus, a DAG can be considered to be a finite set of points connected
    by arrows, so that there is no way to start at any point X and follow a sequence
    of arrows that eventually loops back to X again, that is, that there are no directed
    cycles. A DAG can have a tree topology (as a special case), but generally, DAGs
    have no regular topology. Blockchain could be considered as the simplest DAG with
    the points (blocks) connected in a chain, that is, one where each point (except
    the first and the last one) has one predecessor (parent) and one successor (child).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hashgraph [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)] 是一种新的基于
    DAG 的共识机制，它是区块链的替代方案。简单来说，DAG 是一个没有任意两个元素之间循环的有限有向图。在图论中，图是由一个点集（顶点、元素、方块）组成，其中任何两个点都可以有关系，即，通过一条线（边、弧）连接。有向图意味着每两个点之间的线是单向的，即，有箭头。因此，DAG
    可以被认为是通过箭头连接的有限点集，这样在任何点 X 出发，沿着箭头的序列最终不可能循环回到 X，即，不存在有向循环。DAG 可以有一个树形拓扑（作为一个特例），但通常，DAG
    没有规则的拓扑。区块链可以被认为是具有点（区块）链式连接的最简单的 DAG，即，每个点（除了第一个和最后一个）有一个前驱（父节点）和一个后继（子节点）。
- en: 'There are similarities between graph representations of hashgraph and IOTA/tangle:
    both have topologies of a DAG where each element (event, i.e., site) has exactly
    two direct ancestors (parents). However, this is their only similarity. It can
    be concluded that the DAG of a hashgraph represents the history of all communications
    (the so-called gossips) between a community (population) members.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: hashgraph 的图表示与 IOTA/tangle 相似：两者都有 DAG 的拓扑，其中每个元素（事件，即站点）恰好有两个直接前驱（父节点）。然而，这仅是他们唯一的相似之处。可以得出结论，hashgraph
    的 DAG 表示了一个社区（人口）成员之间的所有通信（所谓的八卦）的历史。
- en: 'Hashgraph runs a gossip protocol, which, in brief, can be described as follows:
    in the hashgraph’s P2P network of nodes, at any moment, every node, X (member
    of the population, participant) can synchronize with its randomly chosen neighbor,
    Y (peer), where X sends a sync message to Y, containing information about new
    transaction(s), about previous sync messages (gossips) between nodes in the population,
    or both. Thereby, node X sends everything it knows so far and what node Y does
    not know, that is, X sends everything to Y, except the pieces of information that
    X is sure that Y has already learned.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Hashgraph 运行一个八卦协议，简要描述如下：在 hashgraph 的 P2P 网络节点中，在任何时刻，每个节点 X（人口成员，参与者）都可以与它的随机选择的邻居
    Y（对等体）同步，其中 X 向 Y 发送一个同步消息，包含有关新交易的信息，关于人口节点之间的先前同步消息（八卦），或两者都有。因此，节点 X 发送它迄今为止所知道的一切以及节点
    Y 不知道的，即 X 发送除 X 确信 Y 已经了解的信息以外的所有信息给 Y。
- en: When a node receives a sync message, it creates a data structure called an event.
    In general, an event contains (as payload) a set of the most recent transactions
    learned from the node’s clients, that is, from users (digital wallets), and the
    timestamp representing the moment at which the node claims to have received the
    sync. A sync message from node X to node Y consists of all the events known to
    X and unknown to Y (i.e., for which X supposes that they are unknown to Y). On
    the other hand, node Y extracts only (to its own) unknown events until that moment
    (since Y may have already learned some of the received events from other nodes’
    syncs, which node X was unaware of). Node Y uses the new information to update
    its copy of the hashgraph ledger as the overall picture of all events and syncs
    in the population, from the beginning.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点接收到一个同步消息时，它会创建一个称为事件的数据结构。通常，事件包含（作为有效载荷）从节点的客户端（即用户，数字钱包）学习到的最新交易，以及节点声称接收到同步的时刻的时间戳。从节点
    X 到节点 Y 的同步消息包含 X 已知而 Y 未知的所有事件（即，X 认为它们对 Y 是未知的）。另一方面，节点 Y 只提取直到那一刻的未知事件（因为节点
    Y 可能已经从其他节点的同步中学习到了一些接收的事件，而节点 X 不知道）。节点 Y 使用新信息更新其 hashgraph 账本的副本，作为人口中所有事件和同步的整体视图，从开始。
- en: In the graph representation, for example, when a node A receives a gossip (sync)
    from a node B, that gossip event is shown on the graph as a circle (vertex) in
    column A, with two lines (edges) going down to the immediately preceding gossip
    events by nodes A and B ([Fig. 1.7](#b_9783110681130-001_fig_007)). The hashgraph
    diagram (such as the one in [Fig. 1.7c](#b_9783110681130-001_fig_007)) is used
    only for its presentation and explanation, that is, there is no actual graph stored
    in memory anywhere.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形表示中，例如，当节点A从节点B接收到一条八卦（同步）信息时，这个八卦事件在图中显示为节点A列中的一个圆圈（顶点），并有两条线（边）向下延伸至节点A和B立即之前的八卦事件
    ([图1.7](#b_9783110681130-001_fig_007))。哈希图 diagram（如图1.7c中的那个）仅用于其展示和解释，也就是说，在任何地方都没有实际存储的图形。
- en: '![](../graphic/converted/b_9783110681130-001_fig_007.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_007.jpg)'
- en: 'Fig. 1.7: Structure of hashgraph.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：哈希图结构。
- en: For sharing of transactions, each node runs two endless parallel program loops
    in its software. It asynchronously receives and collects new transactions from
    its clients (wallets) and the sync messages from other nodes (thereby creating
    events) in the first loop. In the second program loop, the node occasionally sends
    syncs to its neighbor nodes. This process of gossip spreading, that is, sharing
    the existing and creating the new events, should stop when each node collects
    every piece of information (on all transactions) created or received at the beginning,
    that is, when a consensus about all transactions and about the timeline of their
    occurrences is reached. However, as new transactions appear all the time, the
    process practically never stops, since there is always something new to gossip
    about. At the same time, nodes are continuously reaching the consensus on the
    previous events and fast. Practically, at any moment, every node can see almost
    the same picture (i.e., the history) of all events as the other nodes are seeing.
    In contrast, the differences (between nodes’ views on overall gossip history)
    are only related to the latest events (which may be old a few seconds, maximally).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交易分享，每个节点在其软件中运行两个无尽的并行程序循环。它在第一个循环中异步接收和收集其客户端（钱包）和其他节点（从而创建事件）的同步消息。在第二个程序循环中，节点偶尔向其邻近节点发送同步信息。这种八卦传播的过程，即分享现有和创建新事件，应该在每个节点收集到最初创建或接收的每条信息（所有交易）时停止，即当对所有交易及其发生时间线达成共识时。然而，由于不断有新交易出现，这个过程实际上从未停止，因为总有新的事情可以八卦。与此同时，节点持续地对之前的事件达成共识并且速度快。实际上，在任何时刻，每个节点都可以看到几乎与其他节点看到的相同的图片（即所有事件的历史）。相比之下，节点之间对整体八卦历史的看法差异仅与最新事件（可能几秒钟内最旧）有关。
- en: Knowing that sync messages include information not only on the events’ transactions
    but information on the events per se, as well, it can be said that hashgraph represents
    gossip about transactions, as well as gossip about gossip. This is important because,
    from the history of gossips, a node can conclude which information other nodes
    know and which they do not.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 知道同步消息包含关于事件交易的信息，以及关于事件本身的信息，因此可以说哈希图表示关于交易的八卦，以及关于八卦的八卦。这是重要的，因为从一个节点的八卦历史，节点可以推断出其他节点知道哪些信息，以及哪些不知道。
- en: Let us conclude, in short, that hashgraph is a hybrid data structure – the combination
    of a hash and a graph, which keeps records about who gossiped to whom and in what
    order. Hashgraph does not require any PoW (so there is no mining), since reaching
    the consensus relies on a procedure known as virtual voting. Unlike blockchain,
    where transaction data is stored in blocks, hashgraph stores data in events, so
    an event can be comprehended as a container of transactions, although an event
    may be empty. In the hashgraph, an event and all the transactions contained in
    it almost immediately become part of a permanent record, that is, of the copy
    of a ledger on every node. This is performed as soon as the node gossips that
    event and all other nodes hear about it. Also, in only a few seconds, every node
    will know, with 100% certainty, about the event’s position in the hashgraph’s
    history, and every node will know that every other node knows this (which is of
    even greater importance).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简洁地结论，hashgraph是一个混合数据结构——哈希和图的组合，它记录了谁向谁八卦以及顺序。Hashgraph不需要任何PoW（所以没有挖掘），因为达成共识依赖于一个称为虚拟投票的程序。与区块链不同，在区块链中，交易数据存储在块中，而hashgraph以事件的形式存储数据，所以可以将事件理解为交易容器，尽管事件可能是空的。在hashgraph中，一个事件及其包含的所有交易几乎立即成为每个节点上的账本副本的一部分。当节点八卦这个事件以及所有其他节点听说它时，就会执行这个操作。此外，在几秒钟内，每个节点将能够以100%的确定性了解事件在hashgraph历史中的位置，并且每个节点都知道其他每个节点也知道这一点（这更为重要）。
- en: Furthermore, unlike the BTC blockchain, where a block and the whole PoW invested
    in its solving might be sometimes wasted (e.g., in the case of a blockchain forking,
    when two candidate blocks are solved at about the same time, after which only
    one block survives), with hashgraph, no event is ever sacrificed, so hashgraph’s
    efficiency is 100%, as well. Finally, hashgraph is a Byzantine fault-tolerant
    system, where the BFT property is absolute, that is, mathematically proven (the
    case will be discussed later).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与BTC区块链不同，在BTC区块链中，一个块及其为解决它而投入的整个PoW有时可能会被浪费（例如，在区块链分叉的情况下，当两个候选块几乎同时被解决后，只有一个块幸存），在hashgraph中，没有任何事件会被牺牲，所以hashgraph的效率也是100%。最后，hashgraph是一个拜占庭容错系统，其中BFT属性是绝对的，即，数学上得到证明（稍后讨论这个案例）。
- en: '[Figure 1.7a](#b_9783110681130-001_fig_007) shows the beginning of a hashgraph
    for the population with five members (participants, nodes) in the network, named
    from A to E. Over time, as new events are created, the hashgraph grows upwards.
    Grey circles at the bottom of [Fig. 1.7a](#b_9783110681130-001_fig_007) represent
    events created by each member, at the start. Every new event created by a member
    will be added above the last event on the vertical line that belongs to that member.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.7a](#b_9783110681130-001_fig_007)显示了一个由网络中五名成员（参与者，节点）组成的hashgraph的开始，从A到E命名。随着时间的推移，当创建新事件时，hashgraph向上增长。[图1.7a](#b_9783110681130-001_fig_007)底部的小灰圈代表每个成员在开始时创建的事件。每个成员创建的每个新事件都将添加到属于该成员的垂直线上的最后一个事件上方。'
- en: 'An event is a small data structure, which can contain zero or more transactions.
    Every event has two parent events below it (except the start events): one, which
    is called self-parent, and the other one, which is called other-parent. A vertical
    line connects an event and its self-parent event (they are in the same column
    since the same node creates both), while an angled line connects the event with
    its other-parent event (earlier created by another node). Besides the field for
    transactions (if they exist), there are three more fields in the data structure
    of an event: two fields containing hashes of two parent events and the field for
    the timestamp of the event’s creation ([Fig. 1.7b](#b_9783110681130-001_fig_007)).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种小的数据结构，它可以包含零个或多个交易。每个事件下面都有两个父事件（除非是开始事件）：一个称为自父事件，另一个称为他父事件。一条垂直线连接事件和它的自父事件（因为同一个节点创建了两者，所以它们位于同一列），而一条斜线连接事件与其他父事件（由另一个节点稍早创建）。除了交易字段（如果存在的话）外，事件的数据结构中还有三个额外的字段：两个字段包含两个父事件的哈希值以及事件创建时间的时间戳字段([图1.7b](#b_9783110681130-001_fig_007))。
- en: A node that has created an event also signs it digitally. When the node gossips
    that event to another node, the signature is sent together with the gossiped event(s).
    The whole hashgraph structure is firmly bonded and protected, that is, made cryptographically
    immutable, since each event contains hashes of its parents – that is, after each
    received sync message and creating a new event, a node can pass through the hashgraph
    from the starting (or from some later) event/s and calculate by itself, the hashes
    of the events below the other parent, as well as the other parent’s hash. In that
    way, the node can check the correctness of the other-parent event (and the events
    below) and validate it, which it certainly does. After sync is received, only
    validated events are included in the node’s copy of the hashgraph. Furthermore,
    nodes in the hashgraph’s P2P network communicate to each other using TLS encryption
    protocol (on top of TCP), which additionally protects the exchange of sync messages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建事件的节点还会为该事件签名。当节点将事件传播给其他节点时，签名会与传播的事件一起发送。整个hashgraph结构因为每个事件都包含其父事件的哈希值——也就是说，在接收到每个同步消息并创建新事件后，节点可以穿过hashgraph从起始（或稍后的）事件/s开始，自行计算其他父事件及其哈希值。这样，节点可以检查其他父事件（及其以下事件）的正确性并验证它，它肯定会这么做。在接收到同步消息后，只有经过验证的事件才会包含在节点的hashgraph副本中。此外，hashgraph的P2P网络中的节点使用TLS加密协议（在TCP之上）相互通信，这进一步保护了同步消息的交换。
- en: '[Figure 1.7c](#b_9783110681130-001_fig_007) shows an example of a hashgraph
    (with five nodes/participants) for the first few events, where it can be seen
    who gossiped which events to whom and in what order. For example, participant
    (node) C first gossips (sends sync) event C1 to participant A which, upon the
    receipt of C1, creates event A2\. Node A saves events C1 and A2 in its file system
    and the transactions that might be contained in them. Event A2 as payload contains
    only new transactions (if any collected in the meantime) with the timestamp of
    the event’s creation and the hashes of its parents A1 and C1 as overhead. Then,
    participant E gossips event E1 to D, after which participant D creates event D2\.
    In the next step, A synchronizes with B, so A gossips everything he knows (events
    A1 and C1) to B, who then creates event B2\. The gossip from [Fig. 1.7c](#b_9783110681130-001_fig_007)
    is then spread as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7c（#b_9783110681130-001_fig_007）显示了一个hashgraph（五个节点/参与者）的例子，其中可以查看到谁传播了哪些事件以及传播的顺序。例如，参与者（节点）C首先传播（发送同步）事件C1给参与者A，在收到C1后，A创建事件A2。节点A在其文件系统中保存事件C1和A2以及可能包含的交易。事件A2作为有效载荷只包含新交易（如果在此期间收集到任何交易）以及事件创建的时间戳和父事件A1和C1的哈希值作为开销。然后，参与者E传播事件E1给D，之后参与者D创建事件D2。在下一步中，A与B同步，因此A将他所知道的一切（事件A1和C1）传播给B，B随后创建事件B2。图1.7c（#b_9783110681130-001_fig_007）的传播如下进行：
- en: 'SYNC (B→E): B gossips events B2, B1, A2, A1, and C1; node E creates event E2'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (B→E): B传播事件B2、B1、A2、A1和C1；节点E创建事件E2。'
- en: 'SYNC (D→C): D gossips events D2, D1, and E1; node C creates event C2'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (D→C): D传播事件D2、D1和E1；节点C创建事件C2。'
- en: 'SYNC (C→A): C gossips events C2, D2, D1, and E1 (C does not send C1 since C
    knows that A has already learned of C1 in the previous C→A sync); node A creates
    event A3'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (C→A): C传播事件C2、D2、D1和E1（C没有发送C1，因为C知道A在前一次C→A同步中已经了解了C1）；节点A创建事件A3。'
- en: 'SYNC (C→B): C gossips events C2, C1, D2, D1, and E1 (at that moment, C does
    not know that B has already learned of C1 in A→B sync, since node C is yet unaware
    of that sync, so the event C1 was not excluded from this gossip); from this moment,
    node B knows of all starting events A1–E1; node B creates event B3'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (C→B): C传播事件C2、C1、D2、D1和E1（此刻，C不知道B已经在A→B同步中了解了C1，因为节点C还不知道那次同步，所以事件C1没有被从这个传播中排除）；从这一刻起，节点B知道了所有起始事件A1-E1；节点B创建事件B3。'
- en: 'SYNC (B→E): B gossips events B3, C2, D2, and D1 (now, B knows that E has learned
    of B2, B1, A2, A1, and C1, so these events are not gossiped about, neither is
    E1, since it was created by E); from this moment, node E knows of all starting
    events A1–E1; node E creates event E3'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (B→E): B传播事件B3、C2、D2和D1（现在，B知道E已经了解了B2、B1、A2、A1和C1，所以这些事件不再被传播，E1也没有被传播，因为它是由E创建的）；从这一刻起，节点E知道了所有起始事件A1-E1；节点E创建事件E3。'
- en: 'SYNC (B→A): B gossips events B2, B1, C2, D2, D1, and E1 (at that moment, B
    does not know that A has learned of C2, so C2 was not excluded from the gossip;
    on the other hand, B knows that A knows of C1, so C1 is not sent); from this moment
    node, C knows of all starting events A1–E1; node A creates event A4'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (B→A): B传播事件B2、B1、C2、D2、D1和E1（此时，B不知道A已经了解到C2，所以C2没有被排除在传播之外；另一方面，B知道A知道C1，所以C1不需要传播）；从这一刻起，节点C知道了所有起始事件A1–E1；节点A创建事件A4'
- en: 'SYNC (E→C): E gossips events E2, B3, B2, B1, A2, and A1 (now E sees C2 via
    B3\. Hence, E knows that C knows of D2, D1, and E1, so these events are not gossiped
    about); from this moment, node C knows of all starting events A1–E1; node C creates
    event C3'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (E→C): E传播事件E2、B3、B2、B1、A2和A1（现在E通过B3看到了C2。因此，E知道C知道D2、D1和E1，所以这些事件不需要再传播）；从这一刻起，节点C知道了所有起始事件A1–E1；节点C创建事件C3'
- en: 'SYNC (A→D): A gossips events A4, A3, A2, A1, B3, B2, B1, C2, and C1; finally,
    from this moment, node D knows of all starting events A1–E1; node D creates event
    D3'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SYNC (A→D): A传播事件A4、A3、A2、A1、B3、B2、B1、C2和C1；最后，从这一刻起，节点D知道了所有起始事件A1–E1；节点D创建事件D3'
- en: This process occurs very fast, so every node in the community learns of all
    starting events (A1–E1) and their transactions in a very short time (~ a second).
    The same also applies to any new transaction/event that appears later. At every
    moment, all nodes reach a full consensus on the transactions’ and events’ existence
    from the start and up to very close to the actual moment. However, for hashgraph
    applications (cryptocurrency, smart contracts, file storage), to be resistant
    to double-spending, Byzantine Generals Problem, Sybil attacks, and other types
    of misuses, this kind of consensus is not enough. The community must also achieve
    the consensus on the exact order in time of all events, and for that purpose,
    the virtual voting consensus algorithm is used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常快，所以社区中的每个节点都能在很短的时间内（约一秒）了解到所有起始事件（A1–E1）及其交易。同样的情况也适用于后来出现的任何新交易/事件。在每一刻，所有节点都能对从开始到实际时刻的交易和事件的存在达成完全共识。然而，对于hashgraph应用（加密货币、智能合约、文件存储），为了抵抗双重支付、拜占庭将军问题、Sybil攻击和其他类型的滥用，这种共识是不够的。社区还必须就所有事件的时间顺序达成共识，为此，使用了虚拟投票共识算法。
- en: Virtual voting is a voting process in which the community of nodes collectively
    and democratically establishes the consensus on the transactions’ order in time,
    that is, on the transactions’ timestamps. It is called virtual because nodes do
    not send their votes over the Internet (the Yes/No decisions regarding famous
    witnesses, which will be explained later). Instead, each node calculates what
    votes other nodes would have sent, based on its knowledge of what other nodes
    know. Each transaction’s timestamp adopted by consensus represents the moment
    when the majority (more than 50%) of the network members (nodes) learned of that
    transaction. The consensus timestamp of a transaction is determined as the median
    value in a set of timestamps that pick the moments when each node says that it,
    for the first time, received an event (through gossip) having this transaction.
    In other words, timestamps written in events created upon each node’s first reception
    of gossip with the given transaction are seen as elements of the set of timestamps,
    whereby the set’s median value is declared as the transaction’s consensus timestamp.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟投票是一种投票过程，在这个过程中，节点社区共同民主地建立对交易顺序的共识，即对交易的时间戳。之所以称为虚拟，是因为节点没有通过互联网发送它们的投票（关于著名见证人的是/否决定，稍后解释）。相反，每个节点根据它对其他节点所知道的信息来计算其他节点会发送的投票。共识时间戳的交易代表了网络成员（节点）中的大多数（超过50%）首次了解到该交易的时刻。交易的共识时间戳是根据每个节点首次接收到包含给定交易的事件（通过传播）的时刻所选择的时间戳集合中的中位数来确定的。换句话说，节点首次接收到包含给定交易传播时，事件中写入的时间戳被视为集合中时间戳的元素，集合的中位数被宣布为交易的共识时间戳。
- en: And yet, every node is not allowed by default to delegate its event, that is,
    the event’s timestamp to be an element of the mentioned set of timestamps. To
    get this allowance, each node must create, a bit later, an event that is elected
    as the famous witness, that is, as the event, which the hashgraph shows that most
    nodes have learned of, fairly soon after it was created. Generally speaking, virtual
    voting is the Byzantine agreement mechanism that determines which nodes may delegate
    (and which may not) the timestamps for calculation of the events’ median (i.e.,
    consensus) timestamps.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认情况下，每个节点都不能委托其事件，即事件的 时间戳成为所提及的时间戳集合的一个元素。要获得这个允许，每个节点必须稍后创建一个被选为著名见证人的事件，即作为这样一个事件，hashgraph
    显示大多数节点在它创建后相对较短的时间内已经了解的事件。总的来说，虚拟投票是确定哪些节点可以委托（以及哪些节点不可以）计算事件的中位数（即共识）时间戳的拜占庭共识机制。
- en: In a population of members (nodes), any group that gathers more than two-thirds
    of the total number of nodes represents the so-called supermajority (while for
    a simple majority, only more than 50% of nodes are needed). The term supermajority
    can also refer to events, that is, to the witnesses of a round (explained below),
    in which case, it represents a group that counts at least 2/3 of witnesses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员（节点）群体中，任何聚集超过节点总数三分之二的任何团体都代表了所谓的超多数（而对于简单多数，只需要超过 50% 的节点）。超多数这个词也可以指事件，即一轮的见证人（下面解释），在这种情况下，它代表一个至少有
    2/3 见证人的团体。
- en: If, in a hashgraph diagram, there is at least one path between any two events
    X and Y, that connects them directly or via other events (e.g., assuming that
    X is older than Y), it is said that Y sees X and that event X is an ancestor of
    event Y, that is, Y is a descendant of X. If X and Y are linked via only one path,
    which includes events Z and W, it is said that Y sees X through Z and W. In general,
    Y can see X via more paths and each path can include more events, whereby different
    paths may partly overlap (i.e., may have common events). The union of all events
    belonging to all paths between X and Y represents the set of events through which
    Y sees X. If the supermajority of nodes creates such a set of events, it is said
    that Y strongly sees X.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 hashgraph 图中，任何两个事件 X 和 Y 之间至少有一条路径，它直接连接它们或通过其他事件（例如，假设 X 比 Y 旧），那么就说 Y
    看到 X，事件 X 是事件 Y 的祖先，即，Y 是 X 的后代。如果 X 和 Y 仅通过一条包含事件 Z 和 W 的路径连接，那么就说 Y 通过 Z 和 W
    看到 X。通常，Y 可以通过更多的路径看到 X，每条路径都可以包括更多的事件，从而不同的路径可能部分重叠（即，可能具有共同的事件）。X 和 Y 之间所有路径所属事件的并集代表
    Y 通过哪些事件看到 X 的集合。如果大多数节点创建这样一个事件集合，那么就说 Y 强烈地看到 X。
- en: 'The hashgraph is divided into the portions of events called rounds (see [Fig.
    1.8](#b_9783110681130-001_fig_008)). It starts with round 1, and the starting
    events (from each node) are called witnesses of round 1\. As the hashgraph grows,
    an event will appear at one moment, which strongly sees a supermajority of the
    round 1 witnesses. Round 2 begins from that moment, while this event becomes a
    witness of round 2\. The division of rounds is based on a rule that each next
    round begins with the first event, which strongly sees a supermajority of the
    witnesses in the last round (the event does not have to see all the witnesses
    from the last round). This event becomes the first witness of the next round.
    Each node may have created at most one witness in a round implying that some nodes
    may have created no witness in the round. Also, when an event is first gossiped
    to a node, that node can immediately calculate the round created of the event,
    that is, the serial number of the round the event belongs to. The round created
    of an event is calculated as follows: if the event sees strongly a supermajority
    of witnesses of round *r*, where *r* is the max of the round created of the event’s
    parents, then the round created of the event is *r *+ 1; otherwise, the round
    created of the event is *r*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希图被划分为称为轮次的事件部分（参见[图1.8](#b_9783110681130-001_fig_008)）。它从轮次1开始，每个节点起始的事件被称为轮次1的见证者。随着哈希图的增长，一个事件会在某一时刻出现，它强烈地看到轮次1的大部分见证者。轮次2从那一刻开始，而这个事件变成了轮次2的见证者。轮次的划分基于一个规则，每个下一个轮次都从最后一个轮次中强烈看到大多数见证者的第一个事件开始（这个事件不必看到上一个轮次的所有见证者）。这个事件成为下一个轮次的第一个见证者。每个节点在一轮中最多可能创建一个见证者，这意味着一些节点在这一轮中可能没有创建见证者。另外，当一个事件首次被传播到一个节点时，该节点可以立即计算出事件的轮次，即事件所属的轮次的序列号。事件的轮次计算如下：如果事件强烈地看到轮次*r*的大部分见证者，其中*r*是事件父母的轮次创建中的最大值，那么事件的轮次创建为*r*+1；否则，事件的轮次创建为*r*。
- en: '![](../graphic/converted/b_9783110681130-001_fig_008.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_008.jpg)'
- en: 'Fig. 1.8: Example of seeing strongly and illustration of division on rounds.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：强烈看到示例及轮次划分说明。
- en: The following step is used to determine which of the witnesses in a given round
    will be (virtually) elected as the famous witnesses. Every witness in a round
    can become famous if some conditions are satisfied. Whether the *i*-th witness,
    W*[n,i]* from round *n* will be famous or not is up to the witnesses from upper
    rounds, *n *+ 1 and *n *+ 2 (in most cases). Firstly, each witness, W*[n ]*[+1]*[,j]*
    from round *n *+ 1 gives his virtual vote, that is, answers “Yes” if he can see
    W*[n,i]* (strongly seeing is not mandatory here) or the answer “No” in the opposite
    case. Next, these votes are counted by witnesses from round *n *+ 2.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是用来确定给定轮次中的哪些见证者将被（虚拟地）选为著名见证者。每个轮次的见证者都有可能成为著名见证者，如果满足某些条件的话。来自轮次*n*的第*i*个见证者W*[n,i]*是否会变得著名，取决于来自上层轮次*n*+1和*n*+2的见证者（在大多数情况下）。首先，来自轮次*n*+1的每个见证者W*[n ]*[+1]*[,j]*投下他的虚拟票，即，如果他能看到W*[n,i]*（这里强烈看到不是强制性的）或者在相反的情况下投下“否”票。接下来，这些投票由来自轮次*n*+2的见证者进行计数。
- en: As a result of this, a witness, W*[n ]*[+2]*[,k]* from round *n *+ 2 takes into
    account (i.e., collects) only the votes from round *n *+ 1 witnesses, which he
    strongly sees. The votes from other round *n *+ 1 witnesses, not strongly seen
    by W*[n ]*[+2]*[,k]* (if any of them exist), are not considered. If the number
    of collected “Yes” votes is greater than or equal to 2/3 of the total number of
    nodes (a supermajority), then it is decided that witness, W*[n,i]* is famous.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，来自轮次*n*+2的见证者W*[n ]*[+2]*[,k]*只考虑（即收集）来自轮次*n*+1的见证者的投票，他自己强烈地看到这些见证者。来自其他未强烈地被W*[n ]*[+2]*[,k]*看到的轮次*n*+1的见证者（如果存在的话）的投票不予考虑。如果收集的“是”票数大于或等于节点总数的2/3（即超级多数），则认为见证者W*[n,i]*是著名的。
- en: The same virtual voting procedure is performed for each round *n* witnesses,
    so eventually a group of the famous witnesses of round *n* will be formed, the
    fame of which was finally decided by only one witness from round *n *+ 2, that
    is by a witness who counted the votes of round *n *+ 1 witnesses. It was mathematically
    proven that the same result of the election of the round *n* famous witnesses
    would be obtained if any other round *n *+ 2 witness counts the votes of round
    *n *+ 1 witnesses.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对每一轮*n*的见证节点执行相同的虚拟投票程序，最终会形成一组第*n*轮的著名见证节点，其声誉最终由来自第*n*+2轮的一个见证节点决定，即由一个计算第*n*+1轮见证节点投票的见证节点。数学上已经证明，如果第*n*+2轮的任何其他见证节点计算第*n*+1轮见证节点的投票，都会得到第*n*轮著名见证节点选举的相同结果。
- en: The nodes that have created famous witnesses of round *n* are given the allowance
    to make decisions on consensus timestamps of some events (i.e., transactions)
    from round *n *– 1\. More precisely said, the creator nodes of the round *n* famous
    witnesses are qualified to determine the consensus timestamps of the events from
    round *n *– 1, which are seen by all famous witnesses of round *n*. If an event
    is seen by all the round *n* famous witnesses, this event is said to be received
    (by the community of nodes) in round *n*, that is, that it has round received
    of *n.* For example, to determine the consensus timestamp of a round *n – *1 event,
    X*[n]*[–1] which has round received of *n*, each node A*[i]* from this privileged
    group (of the creators of the round *n* famous witnesses) first picks the event,
    Y*[i],* which was created by that node when it first received a gossip with given
    event, X*[n]*[–1] (it may often happen that Y*[i]* is just the famous witness
    of round *n*, created by that node). In the next phase, the timestamp of event
    Y*[i]* is delegated as one of the candidates for the consensus timestamp of event,
    X*[n]*[–1]. Lastly, the candidate timestamps delegated by all qualified (i.e.,
    privileged) nodes are sorted into an array of timestamps beginning from the oldest
    one, and the timestamp in the middle (the median value) is declared as the consensus
    timestamp of event, X*[n]*[–1]. In case there are two middle timestamps in the
    array (i.e., when the number of candidates is even), the latter is chosen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那些创建了第*n*轮著名见证节点的节点被赋予了决定某些事件（即交易）的共识时间戳的权限（从第*n*轮的-1轮开始）。更准确地说，第*n*轮著名见证节点的创建节点有资格确定第*n*-1轮所有著名见证节点看到的事件的共识时间戳。如果一个事件被第*n*轮的所有著名见证节点看到，那么这个事件在第*n*轮被社区节点接收，即它具有轮次接收*n*。例如，要确定第*n*-1轮事件的共识时间戳，X*[n]*[–1]，具有轮次接收*n*，这个特权群体（第*n*轮著名见证节点的创建节点）中的每个节点A*[i]*首先选择一个事件，Y*[i]，*当它第一次接收到关于给定事件X*[n]*[–1]的八卦时创建的（经常会发生Y*[i]*就是那个节点创建的第*n*轮著名见证）。接下来，事件Y*[i]*的时间戳被委托为事件X*[n]*[–1]的共识时间戳的候选之一。最后，所有合格（即特权）节点委托的候选时间戳被排序成一个从最古老的一个开始的时间戳数组，数组中间的时间戳（中位数）被宣布为事件X*[n]*[–1]的共识时间戳。如果数组中有两个中间时间戳（即候选人数是偶数），则选择后者。
- en: Getting the timestamp consensus (see [Fig. 1.9](#b_9783110681130-001_fig_009))
    of event X*[n]*[–1] is repeated for every event from round *n *– 1 having round
    received of *n*, while other round *n *– 1 events wait to be seen by all famous
    witnesses from round *n *+ 1 (or higher). As the hashgraph grows with time, the
    consensus timestamps of the events, which belong to rounds *n*, *n *+ 1, *n *+ 2,
    … (having round received of *n *+ 1, *n *+ 2, *n *+ 3 … respectively) are determined
    by following the same virtual voting procedure on the upper rounds’ witnesses.
    In this way, the consensus timestamps of events (and of the transactions contained)
    begin being determined after practically two rounds, that is, in only a few seconds
    after the given event’s creation. The consensus on the existence of an event is
    achieved even faster. Of course, the virtual voting process may encounter ties
    regarding the election of the round *n* famous witnesses. The witnesses from round
    *n *+ 3 (and even from higher rounds) are engaged in resolving the voting ties.
    This certainly prolongs the time of reaching the timestamp consensus, that is,
    the consensus on the time order of the round *n *– 1 events, but, even then, the
    whole process is very fast.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 获取事件X*[n]*[–1]的时间戳共识（见[图1.9](#b_9783110681130-001_fig_009)），对于每一轮从*n *– 1开始的拥有*n *轮接收的事件都重复进行，而其他*n *– 1轮的事件则等待被来自*n *+ 1（或更高）轮的所有著名见证人看到。随着时间戳图的增长，事件的时间戳共识，属于*n*,
    *n *+ 1, *n *+ 2, …（分别具有*n *+ 1, *n *+ 2, *n *+ 3 …的轮接收）由在上轮见证人上遵循相同的虚拟投票程序来确定。这样，事件的时间戳共识（以及包含的事件交易）实际上在经过两轮后开始确定，即在给定事件创建后仅几秒钟。事件存在的共识甚至更快达成。当然，虚拟投票过程可能会在选举*n*轮著名见证人时遇到平局。来自*n *+ 3轮（甚至更高轮）的见证人被用来解决投票平局。这无疑延长了达到时间戳共识的时间，即*n *– 1轮事件的时间顺序共识，但即便如此，整个过程仍然非常快。
- en: '![](../graphic/converted/b_9783110681130-001_fig_009.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../graphic/converted/b_9783110681130-001_fig_009.jpg)'
- en: 'Fig. 1.9: Illustration of procedure of finding famous witnesses and consensus
    order of events.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：寻找著名见证人和事件共识顺序的过程说明。
- en: After determining consensus timestamps of all events in a round, the consensus
    on their time order is automatically achieved, which was the aim of the whole
    procedure. The consensus timestamps of events are assigned to the transactions
    they contain, so the consensus on the order of transactions is determined too.
    The consensus timestamp of a transaction is fair, since it reflects the moment
    when the majority of nodes received that transaction, as this timestamp cannot
    be corrupted or significantly changed by a malicious node. In case some malicious
    nodes try to delay or stop a transaction and thus exclude it from gossips, the
    transaction will bypass that obstacle due to the random nature of the gossip protocol.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了一轮中所有事件的时间戳共识后，它们的时间顺序共识自动实现，这是整个过程的目标。事件的时间戳共识被分配给它们包含的交易，因此交易顺序的共识也被确定。交易的共识时间戳是公平的，因为它反映了大多数节点接收到该交易的时刻，因为这个时间戳无法被恶意节点篡改或显著改变。在某些恶意节点试图延迟或阻止交易并因此将其排除在八卦之外的情况下，由于八卦协议的随机性，交易将绕过这个障碍。
- en: The whole idea of splitting into rounds, elections of famous witnesses, etc.,
    might seem too complicated. But this is not an issue, since the software that
    implements the hashgraph on a node does not require any special hardware – it
    requires nothing more than an average computer with a CPU for universal purposes.
    It does require an Internet connection with the bandwidth necessary for downloading
    and uploading a given number of transactions per second and exchanging syncs with
    other nodes in the hashgraph’s P2P network. Thus, the amount of gossiped data
    between two nodes is minimal. As mentioned earlier, within a sync message, a node
    sends only the events it supposes to be unknown to its peer/neighbor node. Moreover,
    some events are sent without hashes of the events’ parents (when sending node
    can conclude that the receiving node can calculate those hashes). Besides, the
    hashgraph’s virtual voting algorithm does not require any additional bandwidth.
    As a reference to be noted, a fast home Internet connection (of each node) would
    be fast enough to support the same number of transactions per second as the entire
    VISA card network can handle worldwide. Another indicator of the hashgraph’s speed
    is the test results for the network of 32 computers (nodes) spread across eight
    regions around the globe. Namely, when this network runs at 50,000 transactions
    per second, the consensus on the time order of transactions is reached in 3 s.
    If the whole network is concentrated in a single region, the time needed for consensus
    is 0.75 s. Also, the same number of computers (spread in eight regions worldwide)
    can provide the performances required by credit cards – the latency of fewer than
    7 s to handle up to 200,000 transactions per second.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 整个分成多个轮次、选举知名见证人等想法可能会显得过于复杂。但这并不是问题，因为实现hashgraph的节点软件并不需要任何特殊硬件——它只需要一台平均的个人电脑，配备有通用CPU即可。它需要一个有足够带宽的互联网连接，以每秒下载和上传给定数量的交易，并在hashgraph的P2P网络中与其他节点交换同步。因此，两个节点之间的八卦数据量最小。如前所述，在同步消息中，节点只发送它认为对其邻居节点未知的事件。此外，有些事件在发送时没有事件父节点哈希（当发送节点可以推断出接收节点可以计算出那些哈希值时）。另外，hashgraph的虚拟投票算法不需要任何额外的带宽。作为一个值得注意的参考，每个节点的快速家庭互联网连接（每个节点）将有足够的速度来支持与整个VISA卡网络相同的每秒交易数量。hashgraph速度的另一个指标是来自全球八个地区分布的32台计算机（节点）的网络测试结果。具体来说，当这个网络运行在每秒50,000笔交易时，交易的
    时间顺序共识 在3秒内达成。如果整个网络集中在一个地区，达成共识所需的时间为0.75秒。同样，同样数量的计算机（在全球八个地区分布）可以提供信用卡所需的表现——延迟在7秒内处理多达200,000笔交易每秒。
- en: There are other advantages of the described concept of virtual voting. The most
    important one is the hashgraph’s BFT property, achieved in the strict sense of
    the BFT definition (and mathematically proven), unlike blockchain or tangle technologies
    where BFT is accomplished only as a possibility. To be specific, the hashgraph’s
    honest members will be able to keep running a given application (e.g., cryptocurrency)
    correctly, even where the number of fraudulent members/nodes is very close to
    1/3 of the whole population. The BFT property of a hashgraph is a direct consequence
    of the implemented rules (i.e., of the Byzantine protocols) within virtual voting.
    The strongly seeing and the supermajorities of nodes and witnesses are required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的虚拟投票概念还有其他优势。最重要的一个是hashgraph的BFT属性，在BFT定义的严格意义上实现（并且有数学证明），与区块链或tangle技术中BFT只是作为一种可能性实现不同。具体来说，hashgraph的诚实成员将能够正确地运行给定的应用程序（例如，加密货币），即使欺诈成员/节点的数量非常接近整个人口的三分之一。hashgraph的BFT属性是实施规则（即拜占庭协议）在虚拟投票中的直接结果。需要强烈可见性和超级多数的节点和见证人。
- en: The second advantage is that all voting processes and getting consensus timestamps
    are performed virtually and independently by each node. Every member/node does
    everything on its own, as if it was alone on a desert island and without the need
    for any additional communication with anyone (except the regular gossip). Besides
    a reduced demand for Internet bandwidth, the benefit of this is also an increased
    speed of realization and verification of transactions. To be specific, an alternative
    consensus algorithm that would obtain BFT property certainly should be running
    separate Byzantine protocols, including a large amount of communication between
    all members. Thus, if the aim is to determine the consensus order of all events
    in time, each separate communication between two nodes would contain several Yes/No
    questions (in both directions), where each question would have the form, “did
    event X come before event Y?” However, such an algorithm would be very slow due
    to the delays in communication between nodes over the Internet, and perhaps due
    to its complexity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优点是所有投票过程和获取共识时间戳都是由每个节点虚拟且独立完成的。每个成员/节点都是自己干一切事情，就像它独自一个在荒岛上，并且不需要与任何人（除了常规八卦）进行额外的交流。除了减少了对互联网带宽的需求外，这种方法的优点还包括了实现和验证交易的加速速度。具体来说，如果想要获得BFT属性的替代共识算法，当然应该运行单独的拜占庭协议，包括所有成员之间的大量通信。因此，如果目标是确定所有事件的时间共识顺序，那么两个节点之间的每一次单独通信都会包含几个是/否问题（两个方向都有），每个问题都具有这样的形式：“事件X是否在事件Y之前发生？”然而，由于节点之间通过互联网通信的延迟，以及可能由于其复杂性，这种算法将非常缓慢。
- en: 'Instead of all mentioned so far, by applying the virtual voting algorithm,
    the Byzantine agreement protocol is run only for witnesses, whereby famous witnesses
    are chosen as a result of a small number of questions, such as: “Is this witness
    famous?” In this way, the process of time event ordering (through performing some
    sorting algorithm) is avoided. As already explained, the time order of events
    is (automatically) determined as soon as their consensus timestamps are found,
    as the median values of the candidate timestamps delegated by the nodes that have
    created the famous witnesses.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用虚拟投票算法，仅对见证人运行拜占庭协议，从而通过少数问题（例如：“这个见证人是否著名？”）选择出著名的见证人。这种方式避免了事件时间排序（通过执行某种排序算法）的过程。如前所述，一旦找到共识时间戳，事件的时间顺序（自动）就确定了，这是由创建著名见证人的节点委派的候选时间戳的中值。
- en: In the previous paragraphs, some of the factors for realizing an application
    based on hashgraph are that it should be fast, cheap, Byzantine fault-tolerant,
    resistant to double-spending and DDoS attacks, and modest in the bandwidth demands.
    Other desirable features of hashgraph are related to its organizational structure
    designed to make these features real. For the time being, Hashgraph is a project
    in its developing phase. It is led by Hedera Hashgraph, LLC – the company which
    also provides a public ledger platform for this project. It was mentioned earlier
    that a DL could be permissionless or permissioned, depending on whether a central
    entity grants the permissions to nodes for accessing the network or not. Also,
    it was mentioned that a DL network could be private or public based on the P2P
    network used. The Hedera hashgraph platform is designed to be public and to have
    permissionless (i.e., open) consensus with a permissioned (closed) governance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的段落中，实现基于hashgraph的应用程序的一些因素是它应该快速、便宜、能够容忍拜占庭错误、抵抗双重花费和DDoS攻击，并且对带宽的需求适中。hashgraph的其他一些期望的特征与其组织结构有关，该结构旨在实现这些特征。目前，Hashgraph是一个处于开发阶段的项目。它由Hedera
    Hashgraph, LLC领导——这家公司还为此项目提供了一个公共账本平台。前面提到，DL可以是无需许可或需要许可的，这取决于中心实体是否授权节点访问网络。此外，还提到，基于使用的P2P网络，DL网络可以是私有的或公共的。Hedera
    hashgraph平台旨在是公共的，并具有无需许可（即开放）的共识和需要许可（关闭）的治理。
- en: The closed governance model is based on the idea that the platform will be governed
    by a council of up to 39 reputable organizations and enterprises from different
    industries and regions worldwide, with highly respected brands. The Hedera Hashgraph
    Council (HHC) is a governing body aiming at supporting the evolution of a stable
    and decentralized public ledger infrastructure based on the hashgraph consensus
    algorithm. HHC will follow the rules to ensure that no single member or a small
    group of members will have control over the body as a whole. On behalf of the
    council, the elected Governing Board will establish the council membership policy,
    then regulate the network rules and token issuance, and approve changes to the
    platform codebase. The governance rules foster the philosophy of decentralization
    and prevent the concentration of power over the process of reaching the consensus
    on the transaction order in the platform. Such a governing model will also eliminate
    the risk of ledger splitting, guarantee the codebase integrity, and provide open
    access to the protected core. Protected core means that the hashgraph consensus
    algorithm is not license-free. Specifically, the intellectual property rights
    in the algorithm are held by Swirlds, Inc. (the company founded by the inventors
    of the algorithm). At the same time, the HHC has a license from Swirlds to use
    it for the Hedera public DL platform. On the other hand, neither license nor Hedera’s
    approval will be required to use the Hedera hashgraph platform or write software
    that uses the platform services. In contrast, the applications built upon the
    platform can be open source or proprietary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭式治理模型基于这样一个理念：平台将由来自全球不同行业和地区、品牌声望极高的最多39家知名组织和企业组成的理事会进行治理。Hedera Hashgraph理事会（HHC）是一个治理机构，旨在支持基于hashgraph共识算法的稳定和去中心化公共账本基础设施的发展。HHC将遵循规则，确保不会由单一成员或少数成员控制整个机构。代表理事会的当选治理委员会将制定理事会成员政策，然后规范网络规则和代币发行，批准平台代码库的更改。治理规则弘扬去中心化的理念，防止在平台中就交易顺序达成共识的过程中权力集中。这样的治理模型还将消除分账风险，保证代码库的完整性，并提供对受保护核心的开放访问。受保护的核心意味着hashgraph共识算法并非免费许可。具体来说，算法中的知识产权由Swirlds,
    Inc.（由算法的发明人创立的公司）持有。同时，HHC从Swirlds获得许可，将其用于Hedera公共DL平台。另一方面，使用Hedera hashgraph平台或编写使用平台服务的软件，既不需要许可也不需要Hedera的批准。相比之下，建立在平台上的应用程序可以是开源的或专有的。
- en: Properties necessary for the broad adoption of a DL platform are trust and stability.
    Hedera’s governance model (with its governing rules) and the implemented strong
    security mechanisms are just the key factors for a stable decentralized platform
    that creates trust. Apart from that, the HHC’s policies and structure are intended
    to guarantee a wide and fair distribution of native cryptocurrency of the Hedera
    DL platform and to ensure a full network nodes’ application. As a result, the
    nodes will be compensated for the services in maintaining the Hashgraph platform
    through the specially designed incentive model. And consequently, at the same
    time, the new nodes (i.e., new node operators) will be able to join the network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式账本平台广泛采用所必需的特性是信任和稳定性。Hedera的治理模型（及其治理规则）以及实施的强大安全机制正是创建信任的稳定去中心化平台的关键因素。除此之外，HHC的政策和结构旨在确保Hedera
    DL平台原生加密货币的广泛和公平分配，并确保网络节点的全面应用。因此，节点将通过专门设计的激励模型，为维护Hashgraph平台的服务获得补偿。同时，新的节点（即新的节点运营商）将能够加入网络。
- en: 'The entire system of payments (incentives) and fees introduced by Hedera significantly
    differs from the incentive mechanism of the BTC (or other altcoins), where the
    clients (i.e., digital wallets) pay a fee for each verified transaction. At the
    same time, nodes earn money through mining if they are successful in solving the
    PoW tasks. As explained, the Hashgraph is not based on PoW, so there is no mining
    that would motivate nodes to perform transaction verification. Instead, Hedera
    hashgraph’s paying model is based on three types of fees to nodes or to Hedera
    paid by clients, and on two types of payments which Hedera pays to nodes or governing
    members:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Hedera 引入的整个支付（激励）和费用系统与 BTC（或其他山寨币）的激励机制有显著不同，在 BTC 中，客户（即数字钱包）为每个验证的交易支付费用。与此同时，如果节点成功解决
    PoW 任务，它们通过挖矿赚钱。如前所述，Hashgraph 不是基于 PoW，因此没有激励节点进行交易验证的挖矿。相反，Hedera hashgraph
    的支付模型基于三种向节点或由客户支付给 Hedera 的费用，以及两种 Hedera 支付给节点或治理成员的支付方式：
- en: Node fee – a client pays this fee to a node for a provided service. Suppose
    the client wants to transfer cryptocurrency from his to another’s account. In
    that case, he contacts a node that submits the transaction to the network (on
    the client’s behalf), that is, the node puts that transaction into the next event
    it creates and gossips it to a neighbor node to be put into consensus through
    the hashgraph consensus mechanism. Node fee is not determined in advance, but
    it is negotiated between node and client.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点费 – 客户为此费用向节点支付，以获取节点提供的服务。假设客户想要将加密货币从他的账户转移到另一个账户。在这种情况下，他联系一个节点，该节点代表客户将交易提交给网络（即节点将其放入创建的下一个事件中，并将其八卦给邻居节点，通过
    hashgraph 共识机制达成共识）。节点费不是预先确定的，而是由节点和客户之间协商确定的。
- en: Service fee – a client pays this fee to Hedera for the service provided by the
    platform. The fee is calculated based on the service provided (transaction, file
    storage, or smart contract) and the quantity of the service (e.g., in the case
    of file storage, the service fee depends on the number and sizes of stored files).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务费 – 客户向 Hedera 支付此费用，以获取平台提供的服务。该费用基于所提供的服务（交易、文件存储或智能合约）和服务量（例如，在文件存储的情况下，服务费用取决于存储文件的数量和大小）计算。
- en: Network fee – with this fee, a client compensates the node for the network costs,
    that is, for the cost of gossiping the client’s transaction, the cost of temporarily
    storing the transaction in memory, and the cost of calculating the timestamp consensus
    of the event containing the transaction. The fee for each transaction has a fixed
    part and a variable part, which depends on the number of bytes in the transaction.
    The network fee is paid to the node, but then, it is forwarded to Hedera.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络费 – 通过这笔费用，客户补偿节点因网络费用，即因八卦客户交易、在内存中临时存储交易以及计算包含交易的事件的时间戳共识而产生的费用。每笔交易的费用包括固定部分和可变部分，后者取决于交易的字节数。网络费支付给节点，然后节点将其转交给
    Hedera。
- en: Incentive payment – to incentivize nodes to maintain the Hashgraph, Hedera makes
    payments to nodes once a day. This money is taken from the amount that Hedera
    collects from the service and network fees. The amount paid to a node is proportional
    to the stake the node owns, but to be paid, the node must be online and active
    the whole day (e.g., it may be that during 24-h period, the node contributes with
    a minimum of one event each, to at least 90% of rounds)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激励支付 – 为了激励节点维护 Hashgraph，Hedera 每天向节点支付一次费用。这笔钱来自 Hedera 从服务和网络费用中收取的金额。支付给节点的金额与节点拥有的股份成比例，但要想获得支付，节点必须全天在线并保持活跃（例如，可能在
    24 小时内，节点至少贡献了一个事件，占至少 90% 的轮次）
- en: Dividend payments – Hedera may make these payments periodically to the governing
    members as a reward for their role in governance.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股息支付 – Hedera 可能会定期向治理成员支付这些费用，作为对他们参与治理工作的奖励。
- en: Through the combination of open (permissionless) consensus and closed (permissioned)
    governance, the Hedera hashgraph platform aims to build more public trust than
    an entirely closed system, which is the key factor for a cryptocurrency to achieve
    global acceptance. The open consensus model assumes a process where nodes join
    the network and (in the way explained earlier) reach the transaction timestamp
    consensus, that is, the consensus in the time order of transactions. In order
    to ensure transparency, this process enables the possibility of anonymous individuals
    joining the network as node operators. On the other hand, it opens the door for
    various misuses of the Hashgraph. These include Sybil attacks or the cases of
    the concentration of power over consensus by a few dishonest members, who could
    use their power to, for instance, modify the ledger inappropriately, counterfeit
    the cryptocurrency, or influence the consensus order of transactions, among others.
    Nevertheless, these threats are prevented by designing a consensus model that
    encourages the emergence of a decentralized network with many thousands of nodes.
    Weighting votes inhibit the conspiracies of groups of nodes and Sybil attacks
    in the hashgraph virtual voting algorithm.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过开放（无需许可）共识和封闭（需要许可）治理的结合，Hedera hashgraph平台旨在建立比完全封闭系统更多的公众信任，这是加密货币实现全球接受的关键因素。开放共识模型假设一个过程，其中节点加入网络，并通过之前解释的方式达到交易时间戳共识，即交易的共识时间顺序。为了确保透明度，这个过程允许匿名个人加入网络作为节点运营商。另一方面，它为Hashgraph的各种滥用打开了大门。这些包括Sybil攻击或者由少数不诚实成员集中共识权力的情况，他们可能会利用他们的权力不适当地修改账本，伪造加密货币，或影响交易共识顺序等。尽管如此，这些威胁可以通过设计一个鼓励出现拥有成千上万节点的去中心化网络的共识模型来防止。在hashgraph虚拟投票算法中，加权投票抑制了节点群体的阴谋和Sybil攻击。
- en: The virtual voting algorithm described earlier in this section assumed that
    the votes of all relevant nodes in the hashgraph were equal. Hedera introduced
    a modification in the algorithm to eliminate collisions – the weighting of nodes’
    votes based on the nodes’ stakes. In other words, each node casts one vote for
    each coin (of Hedera native cryptocurrency) the node owns, so the influence of
    a node on the consensus process is proportional to the amount of cryptocurrency
    in the node’s possession. This type of consensus is known as the Proof of Stake
    (PoS), the idea of which is explained in Section 1\. When a node joins the network,
    it must declare accounts that it can control, while the amount of cryptocurrency
    in those accounts is used as the stake that weights the node’s votes in the hashgraph
    virtual voting algorithm. As mentioned, each node is paid by Hedera on a daily
    basis (for serving as a node) – the payments are proportional to its stake, so
    the stake of a node is effectively earning interest.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头描述的虚拟投票算法假设hashgraph中所有相关节点投票是平等的。Hedera在算法中引入了一个修改以消除冲突——即根据节点股份来加权节点的投票。换句话说，每个节点对其拥有的每个赫达拉本地加密货币币（Hedera
    native cryptocurrency）投一票，因此节点对共识过程的影响与其所拥有的加密货币数量成比例。这种共识被称为权益证明（PoS），其想法在第一节中解释。当一个节点加入网络时，它必须声明它可以控制的账户，而这些账户中的加密货币数量用作在hashgraph虚拟投票算法中加权节点投票的股份。如前所述，每个节点每天都会从Hedera那里获得收益（作为节点的服务）——收益与其股份成比例，因此节点的股份实际上是在赚取利息。
- en: The vote weighting in the virtual voting algorithm is relatively easy to implement
    – it can be done through a simple redefinition of the notions of the majority,
    supermajority, and the median value. Instead of at least 2/3 of the number of
    nodes in the community, the term supermajority now represents a group of nodes
    whose stakes in the sum have at least 2/3 of the total amount of money on the
    accounts of all nodes in the community. Similarly, the term majority is redefined,
    and it now means more than 50% of the total amount of stakes. The median of the
    timestamps in a set S of the events’ timestamps now becomes the weighted median,
    which can be considered as the median value of the new enlarged set, *S[enlarged]*
    of the timestamps, where each timestamp *t[i]* from *S* is, in *S[enlarged]*,
    represented by *n[i]* identical copies of itself, assuming that *n[i]* is equal
    to the stake of the node that has created the event with timestamp *t[i]*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟投票算法中的投票加权相对容易实现——它可以通过简单地重新定义多数、超级多数和中间值的概念来完成。不再是社区中节点的至少2/3，超级多数现在代表了一组节点，这些节点的总赌注至少占社区所有节点账户中总金额的2/3。同样，多数也被重新定义，现在意味着总赌注超过50%。事件时间戳集合S中的时间戳的中位数现在变成了加权中位数，可以认为是新扩大集合*S[enlarged]*的中位数值，其中每个来自S的时间戳*t[i]*在*S[enlarged]*中由*n[i]*个自己相同的副本表示，假设*n[i]*等于创建具有时间戳*t[i]*的事件的节点的赌注。
- en: The new meaning of supermajority implicitly changes the definition of strong
    seeing of events in the Hashgraph. Together with the new meaning of the median
    (i.e., weighted median), it influences the order of the consensus transactions,
    so that the wealthier (hence, the more trusted) nodes have more power to reach
    the consensus than some group of new nodes with insincere intentions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 新的超级多数意义隐含地改变了Hashgraph中强视图事件的定义。结合新的中位数意义（即加权中位数），它影响了共识交易的顺序，使得更富有（因此更受信任）的节点比一些有虚假意图的新节点组更有力量达成共识。
- en: Besides the described mechanisms incorporated in the Hashgraph, such as the
    fee and payment model aimed at incentivizing node operators to participate, or
    the PoS model for inhibition of Sybil attacks and other malicious behaviors, Hedera
    introduces the so-called sharding architecture to ensure future scalability of
    the platform, which is also necessary for the success of a public permissionless
    ledger. This architecture comes from the separation of governance from consensus.
    As the network is expected to expand over time to millions of nodes (all voting
    on distributed consensus), the sharding architecture enables continuous platform
    decentralization.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Hashgraph中整合的描述机制，例如旨在激励节点运营商参与的费用和支付模型，或者用于抑制Sybil攻击和其他恶意行为的PoS模型，Hedera引入了所谓的分片架构以确保平台未来的可扩展性，这对于公共非许可账本的成功也是必要的。这种架构来自于治理与共识的分离。由于预计网络会随着时间的推移扩展到数百万个节点（所有节点都在分布式共识上投票），分片架构实现了平台的持续去中心化。
- en: In its initial phase, the Hedera network will certainly have a relatively small
    number of nodes belonging to a single shard (partition, group). With the expected
    increase of their number in the network, nodes will randomly be grouped in different
    shards. The entity in charge of allocating nodes to shards is called the master
    shard, which randomly assigns new nodes to different shards, once a day. At the
    same time, the master shard moves some nodes between shards to ensure that the
    total amount of cryptocurrency staked in a shard is large enough and that no node
    in a shard owns a large fraction of that amount. All nodes in a shard establish
    consensus on the transactions they collected from their clients and gossiped among
    themselves, that is, they share the same state of their client’s accounts, which
    is a subset of the state of the entire ledger.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在其初始阶段，Hedera网络肯定会有相对较少的节点属于单个分片（分区、组）。随着网络中节点数量的预期增加，节点将随机分组到不同的分片。负责分配节点到分片的实体称为主分片，它每天随机将新节点分配到不同的分片。同时，主分片将一些节点在分片之间移动，以确保分片中的加密货币赌注总额足够大，且分片中的任何节点都不拥有大量该金额。分片中的所有节点就他们从客户那里收集并相互传播的交易建立共识，也就是说，他们共享相同的客户账户状态，这是整个账本状态的一个子集。
- en: Shards are not mutually isolated – occasionally, any member in a shard can send
    a message to a randomly chosen member in some other shard. Each shard maintains
    outgoing message queues for all other shards. Suppose client, *C[a]* of node A
    in the shard *α* wants to send some amount of cryptocurrency to client, *C[b]*
    of node B in the shard *β*. This transaction is first gossiped by node A to the
    nodes in the shard *α*. After reaching the consensus on the order in the shard
    *α*, the account state of client, *C[a]* is decreased by the amount being sent.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分片之间并非相互隔离——偶尔，分片中的任何成员都能向另一个分片中的随机成员发送消息。每个分片都维护着向其他所有分片发送的消息队列。假设分片*α*中的节点A的客户端，*C[a]*想要向分片*β*中的节点B的客户端，*C[b]*发送一些加密货币。这笔交易首先由节点A向分片*α*中的节点传播。在分片*α*中达到顺序共识后，客户端*C[a]*的账户状态会减去要发送的金额。
- en: An inter-shard message is also created and put in the outgoing queue for the
    shard *β.* Subsequently, at one moment, some node, X, from the shard *α* will
    check that queue and, seeing that it is not empty, X will send this inter-shard
    message (which contains transaction *C[a]*→*C[b]*) together with other messages
    (with other transactions from the shard *α* to *β*, if any) to a randomly chosen
    node, Y, in the shard *β.* When Y receives that list of messages, it creates an
    event containing all the transactions from the received messages and submits this
    event to the nodes in the shard *β* through gossip. When a transaction, *C[a]*→*C[b]*
    reaches consensus in the shard *β* (and if the sequence number of the assigned
    inter-shard message is correct), the effect of the transaction will be applied
    on all nodes in *β*, and the account balance of *C[b]* will be increased by the
    amount being sent.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也会创建一个跨分片消息，并放入分片*β*的消息队列中。随后，在某个时刻，分片*α*中的某个节点，X，会检查那个队列，看到不为空时，X会将这个跨分片消息（包含交易*C[a]*→*C[b]*）与其他消息（如果有其他分片*α*到*β*的交易）发送给分片*β*中的一个随机节点，Y。当Y收到那列表中的消息时，它会创建一个包含收到的所有交易的事件，并通过八卦方式将此事件提交给分片*β*中的节点。当分片*β*中的交易*C[a]*→*C[b]*达到共识（且如果分配的跨分片消息的序列号正确）时，该交易的影响将在*β*中的所有节点上应用，并且*C[b]*的账户余额会增加发送的金额。
- en: The positive effects of the sharding architecture can be seen from the above
    described (and simplified) example of the communication between shards in a situation
    when the number of nodes in the network is very large. The number of gossips between
    nodes in the entire network would be many times greater without it, consensus
    and transactions delay would be much longer, and the nodes’ ledger files would
    be much bigger. The separation on shards minimizes the total amount of gossip
    messages in the network, since each transaction is gossiped only within shards
    relevant for that transaction.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面描述的（并且简化的）分片之间通信的例子可以看出，分片架构的积极效果在网络节点数量非常大的情况下尤为明显。如果没有分片，整个网络节点之间的八卦次数会多得多，共识和交易延迟会更长，节点的账本文件会大得多。分片上的分离最小化了网络中的八卦消息总量，因为每个交易只在与该交易相关的分片中进行八卦。
- en: 'The Hedera hashgraph platform comprises three layers: the Internet layer, hashgraph
    consensus layer, and service layer. The Internet layer provides a basic communication
    infrastructure for the nodes, that is, for the computers connected to a P2P network,
    communicating by TCP/IP connections with applied TLS encryption. The hashgraph
    consensus layer represents the described process in which nodes take transactions
    from their clients. They share them throughout the network using gossip protocol
    and run the hashgraph consensus algorithm to reach the consensus in time transaction
    order. Then, each node applies the transactions’ effects in consensus order, that
    is, modifies its copy of the shared state (of the clients’ accounts), which is
    identical with the copies on all other nodes of a given shard.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 霍德拉哈希图平台由三层组成：互联网层、哈希图共识层和服务层。互联网层为节点提供基本的通信基础设施，也就是为连接到P2P网络的计算机提供服务，这些计算机通过TCP/IP连接进行通信，并应用TLS加密。哈希图共识层代表描述的过程，其中节点从他们的客户端那里获取交易。他们通过八卦协议将它们分享到整个网络，并运行哈希图共识算法以及时达成交易顺序的共识。然后，每个节点在其共享状态（客户端账户）的副本上应用交易的效应，即修改与其他节点给定分片的相同副本。
- en: 'A service layer provides three initial services, relying on the two lower layers:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层提供了三种初始服务，依赖于下面两层：
- en: Cryptocurrency
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密货币
- en: File storage
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件存储
- en: Smart contracts
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约
- en: By offering these services, Hedera intends to realize the idea similar to one
    of the Ethereum networks, where its native cryptocurrency (ETH) is primarily used
    as the incentive tool to power the Ethereum blockchain, primarily designed to
    support different decentralized applications (e.g., in the form of smart contracts).
    Hedera also uses its native cryptocurrency to incentivize nodes (to serve as nodes)
    through its payment model. However, unlike Ethereum, this is not the only (i.e.,
    primary) role of the Hedera cryptocurrency, as the service of processing transactions
    between clients is also important. The developers of decentralized applications
    on the Hedera platform will use its initial services and pay for them in Hedera
    tokens (native cryptocurrency) through the service fees. The Hedera cryptocurrency
    is expected to have a high transaction rate as well, due to the very fast hashgraph
    consensus algorithm. This leads to low network fees, making small, micro transactions
    practical. Therefore, the Hedera cryptocurrency should be suitable for IoT applications,
    too.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供这些服务，Hedera 旨在实现类似于以太坊网络之一的想法，其中其原生加密货币（ETH）主要用于作为激励工具来推动以太坊区块链，主要设计用来支持各种去中心化应用（例如，以智能合约为形式）。Hedera
    还使用其原生加密货币通过其支付模型激励节点（作为节点）。然而，与以太坊不同，这并不是 Hedera 加密货币的唯一（即主要）角色，因为服务客户端之间交易的处理也很重要。在
    Hedera 平台上开发去中心化应用的开发者将使用其初始服务，并通过服务费以 Hedera 代币（原生加密货币）支付。由于 Hedera 采用了非常快速的哈希图共识算法，Hedera
    加密货币预计也将具有高交易率。这导致网络费用低，使小额、微交易变得可行。因此，Hedera 加密货币也应该适用于物联网（IoT）应用。
- en: Hedera tokens are also used as the means of weighting the virtual voting mechanism
    within Hedera’s staking model – as mentioned. In contrast, PoS contributes to
    network security, for example, to inhibit Sybil attacks. On that aspect, tokens
    should act as the motivating factor for the responsible use and governance of
    the Hedera platform. The total amount of cryptocurrency that Hedera plans to issue
    is 50 billion tokens; thus, the token release schedule will be very slow in the
    beginning. In the first year, the expected distribution of tokens is that about
    65% of the total amount will be held by Hedera Treasury and the rest by trusted
    nodes, that is, the nodes hosted by Hedera management, employees, investors, developers,
    and Swirlds, Inc. Thus, only 10% of the total amount should be circulating among
    clients through transactions, and this amount is expected to increase slowly.
    To be specific, the amount of circulating tokens should not exceed the threshold
    of 33% for at least five years from the initial release. The goal of these precautions
    is to prevent situations in which an attacker (or group of attackers), who owns
    one-third of the tokens, could disrupt the network (since in the Hedera’s PoS
    model, a transaction becomes final when validated by the nodes that hold at least
    two-thirds of tokens in the sum).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Hedera 代币还用作 Hedera 质押模型中虚拟投票机制的权重手段——如前所述。相比之下，权益证明（PoS）有助于网络安全，例如，抑制 Sybil
    攻击。在这方面，代币应作为激励因素，促使负责使用和治理 Hedera 平台。Hedera 计划发行的加密货币总量为 500 亿代币；因此，代币的发行时间表在开始时会非常缓慢。在第一年，预计代币的分配情况是，大约
    65% 的总代币将由 Hedera 财政部持有，其余由可信节点持有，即由 Hedera 管理、员工、投资者、开发者和 Swirlds, Inc. 托管的节点。因此，只有总量的
    10% 应该通过交易在客户端之间流通，并且预计这个数量会缓慢增加。具体来说，流通中的代币数量不应超过初始发行后至少五年内的 33% 的阈值。这些预防措施的目标是防止攻击者（或攻击者群体），拥有代币的三分之一，可能破坏网络（因为在
    Hedera 的 PoS 模型中，当至少持有代币总量的三分之二的节点验证后，交易才会最终确定）。
- en: Using the second initial service of Hedera – the file storage, users will be
    able to store decentralized files or pointers to files on the Hedera hashgraph
    platform, reliably and transparently. This means that the copy of each added file
    is stored on every node with 100% availability and with the consensus on the exact
    content of the file. The consensus is reached in the same way as for transactions,
    that is, by using a hashgraph consensus algorithm. The concerning events in the
    hashgraph now contain another type of data (instead of transactions). As every
    node in a shard holds an identical copy of the file, it will not be lost if one
    or a few more nodes are corrupted or out of service. A stored file can be deleted
    from the platform only by the entities with a given consent. Decentralized applications
    could use this service to realize different types of registers (such as land ownership
    registers, property title registers, movable asset registries, etc.).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hedera的第二个初始服务——文件存储，用户将能够在Hedera hashgraph平台上可靠且透明地存储去中心化文件或文件的指针。这意味着每个添加的文件的副本都会存储在每一个节点上，实现100%的可用性，并且对文件确切内容达成共识。共识是以与交易相同的方式达成的，即通过使用hashgraph共识算法。hashgraph中的相关事件现在包含另一种数据类型（代替交易）。由于分片中的每个节点都持有文件的同一份副本，即使有一个或几个节点损坏或服务中断，文件也不会丢失。只有拥有特定授权的实体才能从平台上删除存储的文件。去中心化应用可以利用这项服务来实现不同类型的注册表（如土地所有权注册表、房产标题注册表、动产资产登记册等）。
- en: The third initial service of Hedera – smart contracts, is enabled through the
    possibility of containing short computer programs (i.e., code) instead of transactions
    within hashgraph’s events. The execution of these programs, which are written
    in Solidity programming language, is guaranteed on all (honest) nodes as soon
    as the consensus on the events is reached. It is done in the same way the effects
    of a transaction are guaranteed to be applied to the account states of the relevant
    clients on each node’s copy of the ledger, at the moment when the community validates
    the transaction and reaches the timestamp consensus on that transaction. The smart
    contract service allows developers to easily build a broad spectrum of decentralized
    applications on top of the Hedera platform. Smart contracts practically open up
    the possibility of signing the contracts between people, organizations, entities,
    and so on, where it is guaranteed (with 100% confidence) that each clause of a
    signed contract will be executed precisely and at the exact moment as has been
    agreed (i.e., written in the program code). Currently, large libraries of the
    code written in Solidity can be run on the Hedera platform (although the Solidity
    programming language was initially developed to execute smart contracts on Ethereum’s
    platform). More about smart contracts and decentralized applications are covered
    in Section 2.4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Hedera的第三个初始服务——智能合约，是通过在hashgraph事件中包含简短的计算机程序（即代码）而不是交易来实现的。这些用Solidity编程语言编写的程序的执行保证在所有（诚实的）节点上一旦事件达成共识就立即进行。其执行方式与交易的效力保证应用于相关客户端在每节点账本副本中的账户状态相同，此刻社区验证交易并在交易上达成时间戳共识。智能合约服务允许开发者在Hedera平台上轻松构建广泛类型的去中心化应用。智能合约实际上开启了人与人、组织、实体等之间签订合同的可能性，并确保（以100%的自信）每个签署合同的条款都将被精确地、在约定的确切时刻执行（即在程序代码中编写）。目前，可以在Hedera平台上运行用Solidity编写的的大型代码库（尽管Solidity编程语言最初是为了在以太坊平台上执行智能合约而开发的）。关于智能合约和去中心化应用的更多信息在2.4节中介绍。
- en: It is clear now that hashgraph technology comprises all the characteristics
    needed to overcome today’s gap between cryptocurrency and the real world. The
    hashgraph’s inventors aimed to create a part of the current cyberspace that can
    be shared among members, who have agreed to act upon the predefined rules. This
    space will be independent, with no negative effects on the members (based on monopoly)
    or the security issues that big technology companies may have, hosting large amounts
    of confidential data. During the testing phase, there will be a small number of
    nodes within the Hedera network, after which the trusted nodes (all run by the
    HHC members) will join the network. In the next phase, other participants will
    be gradually included until the moment of allowed membership to anyone ready to
    host the node, provided they meet the necessary technical requirements of bandwidth,
    computing power, and storage. In the final stage, the Hedera network is expected
    to have millions of nodes worldwide and that many of them will be run by ordinary
    people who want to stay anonymous.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚，hashgraph技术包含了克服当今加密货币与现实世界之间差距所需的所有特征。hashgraph的发明者旨在创建一个可以由达成共识、按照预定义规则行事的成员共享的当前网络空间。这个空间将是独立的，不会对成员产生负面影响（基于垄断）或大型科技公司可能面临的安全问题，后者需要托管大量机密数据。在测试阶段，Hedera网络内将有一定数量的节点，之后由HHC成员运行的信任节点将加入网络。在下一阶段，将逐渐包括其他参与者，直到允许任何准备托管节点的成员加入，前提是他们满足带宽、计算力和存储所需的技术要求。在最后阶段，预计Hedera网络将拥有全球数百万个节点，其中许多将由希望保持匿名的普通人运行。
