- en: ©  Vikram Dhillon, David Metcalf, and Max Hooper 2017Vikram Dhillon, David Metcalf
    and Max HooperBlockchain Enabled Applications[https://doi.org/10.1007/978-1-4842-3081-7_7](A430562_1_En_7_Chapter.xhtml)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: ©  Vikram Dhillon, David Metcalf, and Max Hooper 2017Vikram Dhillon, David Metcalf
    and Max HooperBlockchain Enabled Applications[https://doi.org/10.1007/978-1-4842-3081-7_7](A430562_1_En_7_Chapter.xhtml)
- en: '7. Ethereum Tokens: High-Performance Computing'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 以太坊令牌：高性能计算
- en: 'Vikram Dhillon^(1 ), David Metcalf¹ and Max Hooper¹(1)Orlando, Florida, USAIn
    the Ethereum ecosystem, transfer of value between users is often realized by the
    use of tokens that represent digital assets. Ether is the default token and the
    de facto currency used for transactions and initializing smart contracts on the
    network. Ethereum also supports the creation of new kinds of tokens that can represent
    any commonly traded commodities as digital assets. All tokens are implemented
    using the standard protocol, so the tokens are compatible with any Ethereum wallet
    on the network. The tokens are distributed to users interested in the given specific
    use case through an ICO. In this chapter, we focus our attention on tokens created
    for a very specific use case: high-performance computing (HPC) . More precisely,
    we discuss a model of distributed HPC where miners offer computational resources
    for a task and get rewarded in some form of Ethereum tokens.We begin our discussion
    with an overview and life cycle of a token in the network. Then, we dive into
    the first token, Ethereum Computational Market (ECM), which is the most generalized
    and comprehensive distributed processing system. ECM will be our standard model
    for HPC using tokens, and we will introduce concepts such as dispute resolution
    (firm and soft) and verifiability of off-chain processing with on-chain rewards.
    The second token we cover is Golem , which posits itself as the Airbnb for unused
    CPU cycles. The first release, called Brass Golem , will allow distributed rendering
    of 3D objects using Blender. Future releases will enable more advanced functionality
    such as processing big-data analytics. The third token we present is Supercomputing
    Organized by Network Mining (SONM) , which extends the idea of fog computing to
    create an Ethereum-powered machine economy and marketplace. SONM has published
    a more technically oriented roadmap focused on neural networks and artificial
    intelligence. The initial use case would be to provide decentralized hosting to
    run a Quake server. The last token we talk about in this chapter is iEx.ec, which
    leverages well-developed desktop grid computing software along with a proof-of-computation
    protocol that will allow for off-chain consensus and monetization of resources
    offered.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Vikram Dhillon^(1 ), David Metcalf¹ 和 Max Hooper¹(1)美国佛罗里达州奥兰多 在以太坊生态系统中，用户之间的价值转移通常通过代表数字资产的令牌来实现。以太是默认令牌，也是网络上的交易和初始化智能合约的事实标准货币。以太坊还支持创建新类型的令牌，可以将任何常见交易商品表示为数字资产。所有令牌都使用标准协议实现，因此这些令牌与网络上的任何以太坊钱包兼容。令牌通过ICO分配给对给定特定用例感兴趣的用户。在本章中，我们将注意力集中在为非常特定的用例创建的令牌上：高性能计算（HPC）。更确切地说，我们将讨论分布式HPC的模型，在该模型中，矿工提供计算资源进行任务，并以某种形式的以太令牌获得奖励。我们从网络中的令牌的概述和生命周期开始讨论。然后，我们深入探讨第一个令牌，以太坊计算市场（ECM），这是最广泛的、最全面的分布式处理系统。ECM将成为我们使用令牌进行HPC的标准模型，我们将介绍诸如纠纷解决（严格和软性）和通过链外奖励验证链外处理的概念。我们涵盖的第二个令牌是Golem，它将自己定位为未使用的CPU周期的Airbnb。第一个版本，称为黄铜Golem，将允许使用Blender进行3D对象的分布式渲染。未来的版本将实现更高级的功能，如处理大数据分析。我们在本章讨论的第三个令牌是SONM（Supercomputing
    Organized by Network Mining），它将雾计算的概念扩展到创建以太坊动力机器经济和市场。SONM已发布了一个更技术导向的路线图，重点放在神经网络和人工智能上。最初的用例将是提供去中心化的主机以运行Quake服务器。在本章中，我们谈论的最后一个令牌是iEx.ec，它利用了成熟的桌面网格计算软件，以及一个将允许链外共识和资源货币化的计算证明协议。
- en: Tokens and Value Creation
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令牌与价值创造
- en: 'To understand the concept of tokens, we first need to understand the context
    in which they operate, “fat” protocols. At Consensus 2017, Naval Ravikant talked
    about the idea of “fat” protocols and the fundamental differences between Internet
    companies and the next generation of startups building on the blockchain. Currently,
    the Internet stack is composed of two slices, a “thin” slice of protocols that
    power the World Wide Web and a “fat” slice of applications that are built on top
    of the protocols. Some of the largest Internet companies such as Google and Facebook
    captured value in the application layer, but then had to invent new protocols
    and an infrastructure layer to actually scale. When Internet companies reached
    that size, they had validated their core business model and had enough resources
    to allocate toward creation of new protocols.Blockchain-based companies operate
    on a different stack with a “thin” slice of application layer and a “fat” slice
    of protocol layer. The value concentrates in the protocol layer, and only a fraction
    spills over to the application layer. Joel Monégro and Balaji S. Srinivasan proposed
    two probable reasons for the large interest and investment in the protocol layer:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解令牌的概念，我们首先需要了解它们所处的背景，“**fat**”协议。“2017年共识大会”上，纳瓦尔·拉维坎特谈到了“**fat**”协议的概念以及互联网公司与基于区块链的下一代初创公司之间的根本区别。目前，互联网栈由两个部分组成，一个是为万维网提供动力的“**thin**”协议层，另一个是建立在协议之上的“**fat**”应用层。一些最大的互联网公司，如谷歌和Facebook，在应用层捕获了价值，但随后不得不发明新的协议和基础设施层以实际扩展规模。当互联网公司达到那个规模时，它们已经验证了其核心商业模式，并且有足够的资源用于创建新的协议。基于区块链的公司在不同的栈上运行，其中应用层是“**thin**”，协议层是“**fat**”。价值集中在协议层，只有一小部分流向应用层。Joel
    Monégro和Balaji S. Srinivasan提出了对协议层的巨大兴趣和投资的两个可能原因：
- en: 'Shared data layer : In a blockchain stack, the nature of underlying architecture
    is such that key data are publicly accessible through a blockchain explorer. Furthermore,
    every member of the network has a complete copy of the blockchain to reach consensus
    on the network. A pertinent example of this shared data layer in practical usage
    is the ease with which a user can switch between exchanges such as Poloniex and
    Kraken. or vice-versa. The exchanges all have equal and free access to the underlying
    data or the blockchain transactions.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享数据层：在区块链堆栈中，底层架构的性质是通过区块链浏览器公开访问关键数据。此外，网络的每个成员都拥有区块链的完整副本，以便就网络达成共识。在实际用途中，这种共享数据层的一个相关例子是用户可以轻松在不同交易所之间切换，如
    Poloniex 和 Kraken，反之亦然。所有交易所都可以平等和免费地访问底层数据或区块链交易。
- en: 'Access tokens: Tokens can be thought of as analogous to paid API keys that
    provide access to a service. In the blockchain stack, the protocol token is used
    to access the service provided by the network, such as file storage in the case
    of Storj. Historically, the only method of monetizing a protocol was to build
    software that implemented the new protocol and was superior to the competition.
    This was possible for research divisions in well-funded companies, but in academia,
    the pace of research was slower in the early days because the researchers creating
    those protocols had little opportunity for financial gain. With tokens, the creators
    of a protocol can monetize it directly through an ICO and benefit more as the
    token is widely adopted and others build services on top of the new protocol.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问代币：代币可以类比为提供对服务访问的付费 API 密钥。在区块链堆栈中，协议代币用于访问网络提供的服务，例如在 Storj 中的文件存储。从历史上看，对协议进行货币化的唯一方法是构建实现新协议且优于竞争对手的软件。这对于资金充足的公司的研究部门是可能的，但在学术界，研究的速度在早期较慢，因为创建这些协议的研究人员几乎没有财务上的机会。有了代币，协议的创建者可以通过
    ICO 直接货币化，随着代币被广泛采用并有其他人在新协议上构建服务，他们可以获得更多的利益。
- en: 'Due to proper incentives, a readily available data sharing layer, and application
    of tokens beyond the utility of a currency, developers are spending considerable
    time on the underlying protocols to crack difficult technical problems. As a result,
    startups building on the blockchain stack will inevitably spend more time on the
    “fat” protocol layer and solve technical challenges to capture value and differentiate
    themselves from a sea of Ethereum tokens.Recently, with more tokens up and coming
    in the Ethereum ecosystem, cross-compatibility has become a concern. To address
    this issue, a new specification called ERC20 has been developed by Fabian Vogelsteller.
    ERC20 is a standard interface for tokens in the Ethereum network. It describes
    six standard functions that every access token should implement to be compatible
    with DApps across the network. ERC20 allows for seamless interaction with other
    smart contracts and decentralized applications on the Ethereum blockchain. Tokens
    that only implement a few of the standard functions are considered partially ERC20-compliant.
    Even partially compliant tokens can easily interface with third parties, depending
    on which functions are missing.NoteSetting up a new token on the Ethereum blockchain
    requires a smart contract. The initial parameters and functions for the token
    are supplied to the smart contract that governs the execution of a token on the
    blockchain.To be fully ERC20-compliant, a developer needs to incorporate a specific
    set of functions into their smart contract that will allow the following actions
    to be performed on the token:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于适当的激励措施、一个方便的数据共享层以及代币的应用超出了货币的实用性，开发者们正在花费大量时间解决底层协议中的困难技术问题。因此，在区块链堆栈上构建的初创公司将不可避免地花费更多的时间在“庞大”的协议层上，并解决技术挑战以捕获价值并使自己与以太坊代币的海洋中区分开来。最近，随着以太坊生态系统中更多的代币涌现，跨兼容性已经成为一个关注点。为了解决这个问题，Fabian
    Vogelsteller 开发了一个新的规范，叫做 ERC20。ERC20 是以太坊网络上的代币的标准接口。它描述了每个访问代币应实现的六个标准函数，以便与网络上的
    DApps 兼容。ERC20 允许与以太坊区块链上的其他智能合约和去中心化应用程序进行无缝交互。只实现少量标准函数的代币被认为是部分 ERC20 兼容的。即使是部分兼容的代币也可以根据缺少的功能与第三方轻松接口。注意：在以太坊区块链上设置新代币需要一个智能合约。将初始参数和功能提供给管理在区块链上执行代币的智能合约。要完全符合
    ERC20，开发者需要将一组特定的函数纳入他们的智能合约中，以允许对代币执行以下操作：
- en: 'Get the total token supply: totalSupply()'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取总代币供应量：totalSupply()
- en: 'Get an account balance: balanceOf()'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取账户余额：balanceOf()
- en: 'Transfer the token: transfer(), transferFrom()'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转移代币：transfer()，transferFrom()
- en: 'Approve spending of the token: approve(), allowance()'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批准代币的支出：approve()，allowance()
- en: 'When a new token is created, it is often premined and then sold in a crowdsale
    also known as an ICO. Here a premine refers to allocating a portion of the tokens
    for the token creators and any parties that will offer services for the network
    (e.g., running full nodes). Tokens have a fixed sale price. They can be issued
    and sold publicly during an ICO at the inception of a new protocol to fund its
    development, similar to the way startups have used Kickstarter to fund product
    development.The next question we should ask regarding tokens is this: Given that
    tokens are digital, what do token buyers actually buy? Essentially, what a user
    buys is a private key. This is the analogy we made to paid API keys: Your private
    key is just a string of a characters that grants you access. A private key can
    be understood to be similar to a password. Just as your password grants you access
    to the e-mail stored on a centralized database like Gmail, a private key grants
    you access to the digital tokens stored on a decentralized blockchain stack like
    Ethereum.TipThe key difference between a private key and a password stored on
    a centralized database is that if you lose your private key , you will not be
    able to recover it. Recently, there have been some attempts to restore access
    to an account through a recovery service using a cosigner who can verify the identity
    of the user requesting recovery.Ultimately, tokens are a better funding and monetization
    model for technology, not just startups. Currently, even though base cryptocurrencies
    such as Ethereum have a larger market share, tokens will eventually amount to
    100 times the market share. Figure [7-1](#Fig1) provides a summary of the differences
    between value creation for traditional Internet companies and companies building
    on the blockchain stack using Ethereum tokens. Let’s begin with our first token,
    which will serve as a model for all the tokens that follow. Michael Oved at Consensys
    suggested that tokens will be the killer app that everyone has been waiting for:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新代币被创建时，通常会进行预挖矿，然后在所谓的众筹销售中出售，也被称为 ICO。这里的预挖矿指的是为代币创建者和任何为网络提供服务的方（例如，运行全节点）分配一部分代币。代币有固定的销售价格。它们可以在新协议初始阶段公开发行和销售，以筹集其开发资金，类似于初创企业使用
    Kickstarter 筹集产品开发资金的方式。关于代币，我们应该问的下一个问题是：鉴于代币是数字化的，购买代币的人实际上购买了什么？基本上，用户购买的是私钥。这就是我们将其比作付费
    API 密钥的类比：您的私钥只是一串字符，授予您访问权限。私钥可以理解为类似于密码。就像您的密码授予您访问存储在像 Gmail 这样的集中式数据库上的电子邮件一样，私钥授予您访问存储在像以太坊这样的分布式区块链堆栈上的数字代币。提示私钥和存储在集中式数据库上的密码之间的关键区别在于，如果您丢失私钥，您将无法恢复它。最近，一些尝试通过恢复服务恢复对帐户的访问的尝试已经出现，该服务使用可以验证用户请求恢复身份的联合签名者。最终，代币是技术的更好融资和变现模型，不仅仅是初创企业。当前，即使基本加密货币（例如以太坊）占据了更大的市场份额，代币最终也将达到市场份额的
    100 倍。图 [7-1](#Fig1) 概述了为传统互联网公司和使用以太坊代币构建的区块链堆栈的公司创建价值的差异。让我们从我们的第一个代币开始，这将成为随后所有代币的模型。Consensys
    的 Michael Oved 提出代币将成为每个人都在等待的杀手级应用程序：
- en: If killer apps prove the core value of larger technologies, Ethereum tokens
    surely prove the core value of blockchain, made evident by the runaway success
    that tokens have brought to these new business models.We are now seeing a wave
    of launches that break tokens through as the first killer app of blockchain technology.
    Bitcoin, in many ways, is a “proof of concept” for a blockchain-based asset. The
    Ethereum platform is proving that concept at scale.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果杀手级应用程序证明了更大技术的核心价值，那么以太坊代币无疑证明了区块链的核心价值，这一点由代币为这些新业务模式带来的巨大成功所证明。我们现在正在看到一波通过代币作为区块链技术的首个杀手级应用程序而突破的推出潮。在许多方面，比特币是基于区块链资产的“概念验证”。以太坊平台正在证明这个概念的规模化。
- en: '![A430562_1_En_7_Fig1_HTML.jpg](Images/A430562_1_En_7_Fig1_HTML.jpg)Figure
    7-1.An overviwew of a blockchain stack used by tokensThis model is based on Joyce
    J. Shen’s description of distributed ledger technology. The traditional Internet
    companies such as Google and Facebook created and captured value in the application
    layer by harvesting data that users generated. Blockchain companies have a different
    dynamic in terms of ownership and the technology available. The blockchain itself
    provides a mechanism for consensus and a shared data layer that is publicly accessible.
    Ethereum further provides a Turing-complete programming language and node-to-node
    compatibility through an EVM that can run the instructions contained in a smart
    contract. Using smart contracts, a full application can be constructed to run
    on the blockchain and a collection of applications becomes a full decentralized
    service such as Storj.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![A430562_1_En_7_Fig1_HTML.jpg](Images/A430562_1_En_7_Fig1_HTML.jpg)图 7-1.
    代币使用的区块链堆栈概述这一模型基于 Joyce J. Shen 对分布式分类账技术的描述。诸如 Google 和 Facebook 之类的传统互联网公司通过收集用户生成的数据在应用程序层中创建和捕获价值。区块链公司在所有权和可用技术方面有不同的动态。区块链本身提供了一种共识机制和公开可访问的共享数据层。以太坊进一步提供了一种图灵完备的编程语言和通过
    EVM 实现节点之间的兼容性，EVM 可以运行智能合约中包含的指令。使用智能合约，可以构建一个完整的应用程序来运行在区块链上，一系列应用程序成为像 Storj
    这样的完整分散式服务。'
- en: Ethereum Computational Market
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊计算市场
- en: 'ECM is a very simplistic and functional token for off-chain computations and
    the first token we consider in this chapter. It serves as a general model covering
    all the necessary features that an HPC token would need. ECM is designed to facilitate
    execution of computations off-chain that would be too costly to perform within
    the EVM. In essence, ECM is a decentralized version of Amazon’s EC2\. The key
    technical advance in ECM is the computation marketplace, which allows one user
    (the customer) to pay another (the host) for executing an algorithm off-chain
    and report the results back to the customer. Additionally, to preserve the integrity
    of the computation being done off-chain, each algorithm also has an on-chain implementation.
    This on-chain component can be used to verify whether the submitted end result
    is indeed correct. This on-chain implementation also plays a role in resolving
    disputes. Let’s take a look at the life cycle of a request through ECM in Figure
    [7-2](#Fig2). ECM uses some terminology specific to the project for describing
    the life cycle of a request when it’s initially received to the final resolution.
    We employ some of this terminology in Figure [7-2](#Fig2), along with a few additional
    terms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ECM 是用于链下计算的非常简单和实用的代币，也是我们在本章中考虑的第一个代币。它作为一个通用模型，涵盖了 HPC 代币所需的所有必要特性。ECM 的设计是为了促进在以太坊虚拟机内执行成本过高的计算。本质上，ECM
    是亚马逊 EC2 的分散版本。ECM 中的关键技术进步是计算市场，它允许一个用户（客户）向另一个用户（主机）支付执行链下算法并向客户报告结果的费用。此外，为了保护链下执行的计算的完整性，每个算法还具有一个链上实现。此链上组件可用于验证提交的最终结果是否确实正确。此链上实现还在解决争议方面发挥作用。让我们通过图
    [7-2](#Fig2) 来看一下 ECM 请求的生命周期。ECM 使用特定于项目的一些术语来描述请求从最初接收到最终解决的生命周期。我们在图 [7-2](#Fig2)
    中使用了一些此术语，以及一些额外的术语：
- en: 'Pending: Indicates when a request is received. Every request begins in the
    pending status .'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待处理：指示收到请求的状态。每个请求都从待处理状态开始。
- en: 'Waiting for resolution: A request for computation is submitted to the network
    , and a host computed the algorithm and is now reporting the result. This is a
    decision point for the customer: Either the answer will be accepted and the request
    moves to soft resolution status, or the answer is challenged, in which case the
    request moves to needing resolution state.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待解决：将计算请求提交到网络，并且主机计算了算法并现在正在报告结果。这是客户的决策点：要么接受答案并且请求移至软解决状态，要么挑战答案，此时请求移至需要解决状态。
- en: 'Needs resolution: When an answer is challenged, this path is taken from the
    decision tree. The request is changed to needs resolution status and on-chain
    verification component of the algorithm is required.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要解决：当答案受到挑战时，决策树将采用此路径。请求将更改为需要解决状态，并且算法的链上验证组件是必需的。
- en: 'Resolving: This is the interim period as on-chain computation is being performed
    for a request. The request will remain in this status until the computation has
    been completed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决中：这是在请求进行链上计算时的中间期。请求将保持此状态，直到计算完成。
- en: 'Firm vs. soft resolution: Once the on-chain computation has been completed,
    the request is set to the firm resolution status. If no challenges are made within
    a certain window of time after the answer has been submitted to the customer,
    the request is set to soft resolution.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬解决 vs. 软解决：一旦链上计算完成，请求将设置为硬解决状态。如果在提交答案给客户端后的一段时间内没有提出挑战，请求将被设置为软解决状态。
- en: 'Finalized: Once an answer is obtained either through soft or hard resolution,
    the original request can be set to finalized status . This unlocks the payment
    from the customer’s end and allows the host to receive payment for off-chain computation.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已完成：一旦通过软或硬解决方案获得答案，原始请求可以设置为已完成状态。这将解除客户端的付款限制，并允许主机接收用于链下计算的付款。
- en: '![A430562_1_En_7_Fig2_HTML.jpg](Images/A430562_1_En_7_Fig2_HTML.jpg)Figure
    7-2.Life cycle of a request as it goes through ECMNoteThe reader should understand
    that Ethereum Computational Markets is presented here as a generic model to highlight
    all the components of a HPC token. That’s why we go through the technical details
    of computing requests, on and off-chain processing, market dynamics and other
    concepts. In the later sections, all the generic components are replaced by well-thought-out
    mechanisms and features.Each request state just described is broken down further
    into the workflow here. Once a task request is processed off-chain, there is a
    decision point concerning the final answer. If the customer challenges the answer
    provided by the host, the on-chain component of the algorithm will execute and
    the request will go through a few states of needing resolution. On the other hand,
    if no challenges are made, the request moves to soft resolution and is considered
    finalized. The host receives payment after the request has reached the finalized
    state.Now that we have an understanding of how a request gets processed in ECM,
    let’s talk about the marketplace and individual markets within that marketplace.
    The concept that we have referred to as an algorithm being computed off-chain
    is made from three separate contracts: a broker contract , a factory contract
    , and an execution contract.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![A430562_1_En_7_Fig2_HTML.jpg](Images/A430562_1_En_7_Fig2_HTML.jpg)图 7-2.请求在
    ECM 中经历的生命周期注读者应了解，以太坊计算市场在这里被呈现为一个通用模型，以突出高性能计算令牌的所有组件。这就是为什么我们会详细介绍计算请求的技术细节、链上和链下处理、市场动态和其他概念。在后面的章节中，所有通用组件都将被经过深思熟虑的机制和特性所取代。刚才描述的每个请求状态在此处进一步分解为工作流程。一旦任务请求在链下被处理，就会有一个关于最终答案的决定点。如果客户对主机提供的答案提出质疑，则算法的链上组件将执行，并且请求将经历一些需要解决的状态。另一方面，如果没有提出挑战，则请求将移至软解决状态，并且被视为已完成。主机在请求达到已完成状态后收到付款。既然我们已经了解了
    ECM 中如何处理请求，那么让我们谈谈市场以及市场内的个别市场。我们所指的算法在链下计算的概念由三个单独的合同组成：一个经纪合同、一个工厂合同和一个执行合同。'
- en: 'Broker: A contract that facilitates the transfer of a request from the customer
    to the host who will carry out the computation.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Broker：一个合同，用于将客户的请求转发给将执行计算的主机。
- en: 'Execution: A contract used for on-chain verification of a computation. This
    contract can carry out one cycle of on-chain execution in the event that the submitted
    answer is challenged.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Execution：用于计算验证的合同。在提交的答案受到挑战时，此合同可以执行一次链上执行。
- en: 'Factory: A contract that handles the deployment of the execution contract on-chain
    in the case of dispute resolution. This contract supplies relevant metadata such
    as the compiler version required to recompile the bytecode and verify it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Factory：一个合同，在争议解决的情况下负责将执行合同部署到链上。该合同提供相关的元数据，如重新编译字节码和验证所需的编译器版本。
- en: 'The marketplace itself has verticals (markets within a marketplace) that execute
    specialized types of contracts and algorithms, creating use-case-specific HPC
    economics on the Ethereum blockchain using tokens. Figure [7-3](#Fig3) provides
    a visual summary of the three contracts that are a component of each market. What
    is required to make a computation request on ECM? There are primarily two functions
    that create a request and provide all the necessary details. Here, the requestExecution
    function is used to create a request for computation and this function takes two
    arguments. First is a set of inputs to the function itself and second is the time
    window during which a submitted answer can be challenged before the request turns
    to soft resolved status. This time window is given in number of blocks, because
    blocks are created at a definitive time interval in Ethereum. Finally, this function
    also specifies the payment being offered for this computation. The getRequest
    function returns all the metadata regarding the request. The following are some
    of the relevant parameters returned from the metadata:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 市场本身具有竖直方向（市场内的市场），执行特定类型的合同和算法，利用令牌在以太坊区块链上创建特定用例的 HPC 经济。图 [7-3](#Fig3) 提供了每个市场组件的三个合同的可视摘要。在
    ECM 上发出计算请求需要什么？主要有两个函数来创建请求并提供所有必要的详细信息。这里，requestExecution 函数用于创建计算请求，此函数接受两个参数。首先是函数本身的输入集，第二个是提交答案可以被挑战的时间窗口，直到请求变为软解决状态为止。此时间窗口以区块数量给出，因为以太坊中的区块在确定的时间间隔内创建。最后，此函数还指定了为此计算提供的付款。getRequest
    函数返回有关请求的所有元数据。以下是从元数据返回的一些相关参数：
- en: 'address requester : The address of the customer that requested the computation.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求者地址：请求计算的客户的地址。
- en: 'bytes32 resultHash : The SHA3-hash of the result from a given computation.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果哈希：给定计算结果的 SHA3-哈希值。
- en: 'address executable : The address of the executable contract that was deployed
    on-chain to settle a challenged answer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行地址：部署在链上以解决挑战答案的可执行合同的地址。
- en: 'uint status : The status of a request, at a given time through the life cycle.
    It is an unsigned integer corresponding to the status of a request given by numbers
    0 through 7.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'uint status：给定时间点通过生命周期的请求状态。它是一个无符号整数，对应于通过数字 0 到 7 给出的请求状态。  '
- en: 'uint payment : The amount in wei that this request will pay (to the host) in
    exchange for completion of a computation. Wei is the smallest unit of Ether that
    can be transferred between users, similar to Satoshis in Bitcoin.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint payment：此请求将支付的金额（给主机），以完成计算。Wei 是以太的最小单位，可在用户之间转移，类似于比特币中的 Satoshis。
- en: 'uint softResolutionBlocks : A time window given by number of blocks within
    which a challenge to an answer must be submitted. If no challenges are submitted
    to an answer in that interval, the request changes to soft resolution.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint softResolutionBlocks：在此区块数量的时间窗口内，必须提交对答案的挑战。如果在该间隔内未对答案提交挑战，则请求更改为软解决状态。
- en: 'uint requiredDeposit : Amount in wei that must be provided when submitting
    an answer to a request, or by a challenger objecting a submitted answer. This
    deposit is locked until the request moves to finalized state and then is released
    back to the host.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交答案时需要提供的金额（以wei为单位）：这笔金额需要在提交答案时或者由质疑者质疑提交答案时提供。这笔押金会被锁定，直到请求进入最终状态，然后才会被释放回主机账户。
- en: 'It is important to note that in our discussion, a few tasks such as answer
    verification, conflict resolution, and challenges have required deposits. The
    deposits are used as a countermeasure to reduce the potential for Sybil attacks
    on the network. A Sybil attack is an attack where a single adversary is controlling
    multiple nodes on a network, and now, the adversary can manipulate PoW on the
    network.![A430562_1_En_7_Fig3_HTML.jpg](Images/A430562_1_En_7_Fig3_HTML.jpg)Figure
    7-3.Overview of a market in the marketplaceThe three components in a market necessary
    for responding to a request by a user (customer) are the broker contract, an execution
    contract, and a factory contract. The broker contract facilitates a customer–host
    interaction and the other two contracts play a role in dispute resolution. In
    the case of challenges to a submitted answer, the broker will initiate the deployment
    of the execution contract through its factory contract (also called FactorBase,
    shown with the red workflow), which consolidates the information and prepares
    for one-cycle execution of the algorithm. The gas necessary for execution will
    be taken from a deposit that the challenger is required to submit. We discuss
    the submission and challenge process next.Next, we talk about the submitting an
    answer back to the customer and the challenge process. Submitting an answer for
    a computation done off-chain is performed with the answerRequest function . This
    function takes a unique ID of the request being answered as an input. The actual
    submission of a potential answer requires a deposit in Ether. This deposit is
    locked until the request has reached either a soft or hard resolution state. We
    discuss the importance of holding deposits from involved parties shortly. Once
    a request has been finalized, the deposit made by the host who submitted an answer
    is reclaimed, along with the reward for performing the computation. If a submitted
    answer does not fall within the expectations of the request submitted by a customer,
    a participant can challenge the answer. This initiates an on-chain verification
    process that will execute one cycle of the computation within the EVM to verify
    whether the submitted answer is correct. If the submitted answer was found to
    be incorrect during on-chain computation, the host’s deposit will have had the
    gas costs of that computation deducted from it. The challenger will get a large
    portion of the reward from the customer’s deposit, and the dispute will be resolved.For
    a request where a submitted answer has been challenged, the request moves to the
    needs resolution state. This is accomplished by calling the initializeDispute
    function , which serves as a transition between the point at which a challenge
    is made and the beginning of on-chain verification. Now the broker contract will
    use a factory to deploy an executable contract initialized with the inputs for
    this request. The gas costs for calling this function and performing one-cycle
    execution are reimbursed from the challenger’s deposit. Throughout the resolving
    state on a request, the executeExecutable function is called until the on-chain
    verification has been completed. At this point, the request is moved to a hard
    resolution state and eventually finalized. The gas charges and reward system might
    seem complicated, but it follows a simple principle: The correct answer receives
    payment for the computation, and incorrect submitters must pay for gas during
    on-chain verification. Let’s recap:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在我们的讨论中，一些任务（例如答案验证、冲突解决和质疑）需要提供押金。这些押金用作减少网络中Sybil攻击可能性的对策。Sybil攻击是指单个对手控制网络上的多个节点，并且现在对手可以操纵网络上的PoW。![A430562_1_En_7_Fig3_HTML.jpg](Images/A430562_1_En_7_Fig3_HTML.jpg)图7-3.市场的概述市场中对用户（客户）请求做出响应所必需的三个组件是经纪合同、执行合同和工厂合同。经纪合同促进了客户-主机的交互，另外两个合同在纠纷解决中发挥作用。在对提交答案提出质疑的情况下，经纪将通过其工厂合同（也称为FactorBase，用红色工作流程显示）启动执行合同的部署，该合同整合信息并准备一周期执行算法。执行所需的gas将从质疑者被要求提交的押金中获取。我们接下来讨论提交和质疑过程。接下来，我们谈论将答案提交给客户以及质疑过程。对于在链下进行的计算提交答案，使用answerRequest函数执行。此函数以请求被答复的唯一ID作为输入。实际提交潜在答案需要以以太币为押金。此押金将被锁定，直到请求达到软解决或硬解决状态。我们很快会讨论涉及各方持有押金的重要性。一旦请求最终化，由提交答案的主机支付的押金将被返还，同时还包括执行计算的奖励。如果提交答案不符合客户提交的请求的预期，参与者可以对答案提出质疑。这将启动链上验证过程，该过程将在EVM中执行一周期的计算以验证提交的答案是否正确。如果在链上计算中发现提交的答案不正确，将从主机的押金中扣除该计算的gas成本。质疑者将从客户押金中获得大部分奖励，纠纷将得到解决。对于被质疑的提交答案的请求，请求将转移到需要解决状态。通过调用initializeDispute函数来实现这一点，该函数充当了质疑提出和链上验证开始之间的过渡。现在，经纪合同将使用工厂来部署一个初始化为此请求的输入的可执行合同。调用此函数和执行一周期计算的gas成本将从质疑者的押金中报销。在请求的解决状态中，将调用executeExecutable函数，直到链上验证完成。此时，请求将转移到硬解决状态，最终定稿。gas费用和奖励系统可能看起来很复杂，但它遵循一个简单的原则：正确答案将获得计算的支付，而错误的提交者必须在链上验证期间支付gas费用。让我们回顾一下：
- en: In the case of soft resolution, a host reclaims the initial deposit and a reward
    given by the customer for executing the computation.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于软解决的情况，主机将收回初始押金和客户为执行计算支付的奖励。
- en: If there were no correct submitted answers, the gas costs for verification are
    split evenly among the users who submitted answers. The reward payment returns
    to the customer who originally requested the computation.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有正确提交的答案，则验证的燃气费用将平均分配给提交答案的用户。奖励支付将返回最初请求计算的客户。
- en: In the case of hard resolution, the incorrect host reclaims the remaining deposit
    after gas costs have been deducted (for on-chain verification). This host does
    not receive a reward for the computation.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在难度较大的解决方案的情况下，扣除燃气费用后，错误的主机可以收回剩余的押金（用于链上验证）。该主机不会因计算而获得奖励。
- en: If a challenger wins hard resolution, they reclaim their deposit along with
    the reward payment. The gas costs are debited from the incorrect host’s deposit.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果挑战者在难度较大的解决方案中获胜，则他们将收回押金以及奖励支付。燃气费用从错误的主机的押金中扣除。
- en: 'On-chain verification of a computation is by nature an expensive task due to
    gas costs. ECM is designed such that off-chain computation would be cheaper than
    running a task in EVM. From a technical standpoint, there are two types of on-chain
    execution implementations: stateless and stateful computations. Figure [7-4](#Fig4)
    shows a contrast between the two implementations.![A430562_1_En_7_Fig4_HTML.jpg](Images/A430562_1_En_7_Fig4_HTML.jpg)Figure
    7-4.Two models for factory execution contracts in ECMAn executable contract is
    stateless if the computation is self-sufficient in that it does not require external
    sources of data. Essentially, the return value from a previous step is used as
    the input for the next step. Piper Merriam (the creator of ECM) proposed that
    stateless executable contracts are superior to stateful implementations for two
    main reasons: lower overhead while writing the algorithm and reduced complexity
    because the computation cycles are self-sustaining. An example highlighted by
    Piper is the Fibonacci sequence written as a stateless implementation with the
    algorithm returning the latest Fibonacci numbers as the input for the next cycle
    of execution. The overhead of writing this in a stateless form is very minor and
    there is no additional complexity of introducing local storage.TipFor stateless
    contracts, the execution contract is identical to algorithm sent as a request
    to the marketplace for computation. Here, on-chain verification would run the
    execution contract for one cycle and hosts would run it for as many cycles as
    necessary to obtain the final answer.An executable contract is stateful if the
    computation is not self-sufficient in that it requires an additional data source
    and the return values from the previous step. This additional data source is often
    in the form of a data structure holding local storage. Let’s go back to our example
    of the Fibonacci sequence and make it stateful. To do this, the algorithm would
    store each computed number in the contract storage and only return the latest
    number to the algorithm for the next cycle of execution. Every step of execution
    would require the algorithm to search the last number stored to compute the next
    number. By including storage, now the algorithm will search through saved results
    and print out any desired Fibonacci sequence that has been computed. This reliance
    on local state is what makes this instance of the contract stateful. Stateful
    contracts also enable new and complex features such as using lookup tables and
    search, but also cause an increase in the complexity of the written algorithm.During
    on-chain verification, a single cycle of the execution contract will be executed.
    However, a self-contained contract in stateless form will be executed efficiently
    and without any additional complexity. In stateless contracts, each step executed
    inside an EVM is elementary so it falls within the gas limits of that virtual
    machine. On the other hand, some contracts require additional storage due to the
    complexity of execution. In such cases, a stateful contract is executed where
    local storage is bound to the EVM during the on-chain verification. This storage
    is temporary and only exists through the duration of the on-chain processing.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于燃气费用，链上验证计算本质上是一项昂贵的任务。ECM 设计为离线计算比在 EVM 中运行任务更便宜。从技术角度来看，有两种类型的链上执行实现：无状态和有状态计算。图
    [7-4](#Fig4) 显示了这两种实现之间的对比。![A430562_1_En_7_Fig4_HTML.jpg](Images/A430562_1_En_7_Fig4_HTML.jpg)图
    7-4.ECM 中工厂执行合同的两种模型如果计算是自给自足的，则可执行合同是无状态的，因为它不需要外部数据源。基本上，上一步的返回值被用作下一步的输入。Piper
    Merriam（ECM 的创始人）提出，无状态可执行合同比有状态实现更优越，原因有两个：编写算法时的开销更低，并且由于计算周期是自我维持的，所以减少了复杂性。Piper
    强调的一个例子是将 Fibonacci 序列写成无状态实现，其中算法返回最新的 Fibonacci 数作为下一个执行周期的输入。以无状态形式编写此内容的开销非常小，并且没有引入本地存储的额外复杂性。提示对于无状态合同，执行合同与作为计算市场请求的算法相同。在这里，链上验证将运行执行合同进行一个周期，并且主机将运行它多少个周期以获得最终答案。如果计算不是自给自足的，则可执行合同是有状态的，因为它需要额外的数据源和上一步的返回值。这种额外的数据源通常以持有本地存储的数据结构形式存在。让我们回到
    Fibonacci 序列的例子并使其有状态。为此，算法将每个计算的数字存储在合同存储中，并仅将最新的数字返回给算法以进行下一个执行周期。执行的每个步骤都需要算法搜索上次存储的最后一个数字来计算下一个数字。通过包含存储，现在算法将搜索保存的结果并打印出已计算的任何所需
    Fibonacci 序列。这种对本地状态的依赖是使合同的这一实例成为有状态的原因。有状态合同还能够实现新的和复杂的功能，如使用查找表和搜索，但也会增加编写算法的复杂性。在链上验证期间，将执行执行合同的一个周期。但是，在无状态形式下的自包含合同将高效地执行，而不会增加任何额外的复杂性。在无状态合同中，EVM
    内执行的每个步骤都是基本的，因此它落在该虚拟机的燃气限制范围内。另一方面，由于执行的复杂性，一些合同需要额外的存储。在这种情况下，将执行有状态合同，其中本地存储与链上验证期间的
    EVM 绑定。此存储是临时的，并且仅在链上处理的持续时间内存在。
- en: Golem Network
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Golem 网络
- en: 'Golem ( [https://golem.network/](https://golem.network/) ) is a decentralized
    general-purpose supercomputing network. In addition to being a marketplace for
    renting computational resources, Golem aims to power microservices and allow asynchronous
    task execution. As a technology stack, Golem offers both Infrastructure-as-a-Service
    (IaaS) and Platform-as-a-Service (PaaS) through a decentralized blockchain stack
    for developers. In Golem, there are three components that function as the backbone
    of a decentralized market:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Golem（[https://golem.network/](https://golem.network/)）是一个去中心化的通用超级计算网络。除了作为租用计算资源的市场外，Golem还旨在支持微服务并允许异步任务执行。作为一个技术栈，Golem通过去中心化的区块链技术栈为开发者提供基础设施即服务（IaaS）和平台即服务（PaaS）的功能。在Golem中，有三个组件作为去中心化市场的支柱：
- en: 'Decentralized farm : A mechanism to send, organize, and execute computation
    tasks from individual users known as requesters and hosts known as providers (of
    computational resources). This provides the users competitive prices for tasks
    such as computer-generated imagery (CGI) rendering and machine learning on network
    access.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化农场：一种从个人用户（称为请求者）发送、组织和执行计算任务，以及主机（提供计算资源）之间的机制。这为用户提供了在网络访问上进行计算生成的图像（CGI）渲染和机器学习等任务的竞争价格。
- en: 'Transaction framework : Golem has a custom payment framework for developers
    to monetize services and software developed to run on the decentralized network.
    This framework can be customized to capture value in new and innovative methods
    such as escrows, insurance, and audit proofs on the Ethereum blockchain.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易框架：Golem为开发者提供了一个定制的支付框架，用于将运行在去中心化网络上的服务和软件货币化。这个框架可以定制以采用新的创新方法捕获价值，比如在以太坊区块链上的担保、保险和审计证明。
- en: 'Application registry : Developers can create applications (for particular tasks)
    that take advantage of Golem as a distribution channel and a marketplace with
    new and unique monetization schemes. These applications can be published to the
    application registry, which essentially functions as an app store for the network.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用注册表：开发者可以创建应用程序（针对特定任务），利用Golem作为分发渠道和市场，提供新颖独特的货币化方案。这些应用程序可以发布到应用注册表，它本质上是网络的应用商店。
- en: 'Golem’s premise in building the marketplace is that not all members will request
    additional resources for extensive computation at all times. As such, the requesters
    can become providers and rent their own hardware to earn extra fees. Figure [7-5](#Fig5)
    provides an overview of how the three components in Golem work in sync. Currently,
    Golem inherits the integrity (Byzantine fault tolerance) and consensus mechanisms
    from Ethereum for the deployment, execution, and validation of tasks. However,
    eventually Golem will use fully functional micropayment channels for running microservices.
    This will allow users to run services like a note-taking app, website hosting,
    and even large-scale streaming applications in a completely decentralized manner.
    Several more optimizations are needed before Golem reaches a level of maturity,
    and currently the most pressing developments are concerning execution of tasks.
    Before Golem can execute general-purpose tasks, we need to ensure that the computation
    takes place in an isolated environment without privileges, similar to an EVM but
    expanded with more features. We also need whitelist and blacklist mechanisms along
    with digital signatures recognized in the application registry that allow providers
    to build a trust network and for users to run applications cryptographically signed
    by trusted developers. Additionally, a network-wide reputation system is necessary
    to reward the providers that have participated the most during computation tasks
    and also to detect a malicious node and mitigate tasks efficiently.NoteThe first
    release dubbed Brass Golem will only allow one type of task to be executed on
    the network, CGI rendering. The main goals of this release are to validate the
    task registry, and basic task definition scheme. The developers want to integrate
    IPFS for decentralized storage, a basic reputation system for the providers involved,
    and docker integration in the network.![A430562_1_En_7_Fig5_HTML.jpg](Images/A430562_1_En_7_Fig5_HTML.jpg)Figure
    7-5.The Golem technology stackThree main components of the Golem stack are shown
    in Figure [7-5](#Fig5). Software developers create applications that automate
    routine tasks and publish them on the application registry. For instance, a time-limited
    rendering application can eliminate the need for any complicated transactions
    or task tracking. The buyer will simply make a single-use deposit and use the
    application until the time is up. When buyers use applications from the registry,
    the revenue generated is used to compensate the developers for their app. The
    registry contains two types of applications : verified apps from trusted developers
    and new apps from unconfirmed developers. Eventually verifiers pool in the newly
    uploaded applications and track them closely for any suspicious activity. After
    a few uses, the new applications also achieve verified status. The developers
    also receive minor compensation from the execution of these applications on the
    provider nodes. Providers requisition the hardware for apps and the lion’s share
    of revenue generated from running a task is given back to the providers (miners).
    The transaction mechanism assures the proper delivery of funds to the appropriate
    party and the buyer is charged for task execution by the same mechanism.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Golem 在构建市场的基础上的假设是，并非所有成员都会始终请求额外的资源进行大量计算。因此，请求者可以成为提供者，并租用自己的硬件来赚取额外费用。图
    [7-5](#Fig5) 概述了 Golem 中三个组件如何同步工作。目前，Golem 从以太坊继承了部署、执行和验证任务的完整性（拜占庭容错）和共识机制。但是，最终
    Golem 将使用完全功能的微支付通道来运行微服务。这将允许用户以完全去中心化的方式运行诸如记事应用、网站托管甚至大规模流媒体应用等服务。在 Golem 达到成熟水平之前还需要进行几项优化工作，目前最紧迫的发展是关于任务执行。在
    Golem 可以执行通用任务之前，我们需要确保计算在一个没有特权的隔离环境中进行，类似于 EVM 但具有更多功能。我们还需要白名单和黑名单机制，以及在应用注册表中识别的数字签名，允许提供者建立信任网络，并让用户运行由可信开发者加密签名的应用程序。此外，还需要一个网络范围内的声誉系统来奖励参与计算任务最多的提供者，并且检测到恶意节点并有效地缓解任务。请注意，首次发布的
    Brass Golem 将只允许在网络上执行一种类型的任务，即 CGI 渲染。此版本的主要目标是验证任务注册表和基本任务定义方案。开发人员希望将 IPFS
    集成为去中心化存储、为参与者提供基本声誉系统，并将 Docker 集成到网络中。 ![A430562_1_En_7_Fig5_HTML.jpg](Images/A430562_1_En_7_Fig5_HTML.jpg)
    图 7-5.Golem 技术栈Golem 技术栈的三个主要组件显示在图 [7-5](#Fig5) 中。 软件开发人员创建自动化常规任务的应用程序，并将其发布到应用程序注册表中。例如，一款限时渲染应用程序可以消除任何复杂的交易或任务跟踪的需求。买家只需进行一次性押金，然后使用应用程序直到时间用完。当买家使用注册表中的应用程序时，生成的收入用于补偿开发者的应用程序。注册表包含两种类型的应用程序：来自可信开发者的经过验证的应用程序和来自未经确认开发者的新应用程序。最终，验证者汇集新上传的应用程序并密切跟踪其是否存在可疑活动。经过几次使用后，新应用程序也获得了经过验证的状态。开发者还从在提供者节点上执行这些应用程序中获得的微小补偿中受益。提供者为应用程序征用硬件，而从运行任务中产生的绝大部分收入将返还给提供者（矿工）。交易机制确保将资金正确地交付给适当的方，并且买家通过相同的机制为任务执行付费。
- en: Application Registry
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用注册表
- en: 'The application registry provides requesters with a massive repository to search
    for specific tools or applications fitting their needs. The registry is an Ethereum
    smart contract among three entities: the authors, validators, and providers. What’s
    the design rationale behind adding these three entities? For general-purpose computing,
    the code is isolated in a sandbox and then executed with the bare minimum privileges.
    Potential software bugs could wreak havoc in a provider’s sandbox, however, executing
    malicious code in a virtual machine with the intention of escalation of privileges,
    or even take over the machine. That’s why sandboxing alone is not enough for Golem.
    One could ask whether the code can be evaluated automatically for safety and security.
    Theoretically, this is not plausible. We cannot determine the outcome of a complex
    algorithm before executing it due to the halting problem.NoteThe halting problem
    is the problem of determining whether a program will finish running or continue
    to run forever given an arbitrary computer program and an input.To enable secure
    and trusted code execution on host machines, the application registry is split
    among three parties that are responsible for maintaining integrity of the network.
    Authors publish decentralized applications to the registry, validators review
    and certify DApps as safe by creating a whitelist , and providers maintain blacklists
    of problematic DApps . Validators also maintain blacklists by marking applications
    as malicious or spam, and providers often end up using a blacklist from validators.
    Similarly, providers can preapprove certain Golem-specific applications (certified
    by validators) to execute on their nodes.Providers can also elect to curate their
    own whitelists or blacklists . The default option for Golem is to run using a
    whitelist of trusted applications. The first set of apps will be verified by the
    developers to kickstart Golem, however, after the initial distribution, the network
    will rely on validators. On the other hand, providers can also take the approach
    of relying only on blacklists. This approach has the advantage of maximizing the
    reach of a provider (to the marketplace) and offering a wide range of applications
    that can be executed on a node. Eventually, providers will become specialized
    and fine-tune their nodes to be incredibly efficient at running one kind of task.
    This allows the providers more control over what runs on their nodes and custom
    hardware options for a computing farm. Ultimately, this option is available to
    developers who want to maximize their profits and are willing to run dedicated
    machines with bleeding-edge software.In a decentralized network like Golem, we
    will see a divide between traditional and vanguard validators. Traditional validators
    will maintain a set of stable applications that perform very routine tasks. For
    instance, a request for a complex 3D rendering can launch a preemptible rendering
    instance on a provider’s nodes. Once the job is completed, the instance will terminate
    to free up memory and send the output to the requester. On the other hand, vanguard
    validators will include and approve software that pushes the boundaries of what
    is possible with Golem. Running new and experimental software on a provider’s
    node will require better sandboxing and hardening of the virtual machine. But
    these features can be a premium add-on running on special nodes offered by a provider.
    Monetizing the premium add-ons will also disincentivize scammers and malicious
    entities. Overall, this design approach makes the network more inclusive, costly
    for scammers, and innovative for developers.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用注册表为请求者提供了一个庞大的存储库，用于搜索符合其需求的特定工具或应用程序。 注册表是以太坊智能合约，由三个实体组成：作者、验证者和提供者。 为什么要添加这三个实体的设计理念？
    对于通用计算，代码被隔离在沙盒中，然后以最低权限执行。 潜在的软件错误可能会在提供者的沙盒中造成严重破坏，然而，在虚拟机中执行恶意代码的目的是提升权限，甚至接管机器。
    这就是为什么单单沙盒化对于 Golem 是不够的。 有人可能会问代码是否可以自动评估其安全性和保密性。 从理论上讲，这是不可能的。 我们无法在执行复杂算法之前确定其结果，这是由于停机问题。请注意，停机问题是指在给定任意计算机程序和输入的情况下，确定程序是否会完成运行或继续永远运行的问题。为了在主机上实现安全可信的代码执行，应用注册表分为三方，负责维护网络的完整性。
    作者将去中心化应用程序发布到注册表中，验证者通过创建白名单对 DApps 进行审查和认证，将其标记为安全，而提供者则维护问题 DApps 的黑名单。 验证者还通过将应用程序标记为恶意或垃圾邮件来维护黑名单，提供者经常使用验证者的黑名单。
    同样，提供者也可以预先批准某些经过验证者认证的特定 Golem 应用程序在其节点上执行。提供者还可以选择管理自己的白名单或黑名单。 Golem 的默认选项是使用信任应用程序的白名单。
    第一批应用程序将由开发人员进行验证，以启动 Golem，然而，在初始分发之后，网络将依赖于验证者。 另一方面，提供者也可以选择仅依赖于黑名单。 这种方法的优点在于最大程度地扩展提供者的影响力（到市场）并提供可以在节点上执行的各种应用程序。
    最终，提供者将变得专业化，并调整其节点，以在运行一种任务时变得非常高效。 这使提供者能够更好地控制其节点上运行的内容，并为计算农场提供定制的硬件选项。 最终，此选项可供想要最大化利润并愿意运行具有最新软件的专用机器的开发人员使用。
    在像 Golem 这样的去中心化网络中，我们将看到传统和前卫验证者之间的分歧。 传统验证者将维护一组稳定的应用程序，执行非常常规的任务。 例如，对复杂的 3D
    渲染的请求可以启动提供者节点上的可抢占式渲染实例。 一旦工作完成，实例将终止以释放内存，并将输出发送给请求者。 另一方面，前卫验证者将包括并批准推动 Golem
    可能性边界的软件。 在提供者节点上运行新的和实验性软件将需要更好的沙盒化和虚拟机加固。 但是这些功能可以作为提供者提供的特殊节点上的高级附加功能。 将高级附加功能货币化还将降低欺骗者和恶意实体的积极性。
    总的来说，这种设计方法使网络更具包容性，对于欺骗者来说更加昂贵，并且对于开发人员来说更具创新性。
- en: Transaction Framework
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易框架
- en: 'The transaction framework can be considered analogous to Stripe, an API for
    monetizing applications running on Golem. After the crowdsale, the network will
    use Golem Network Token (GNT) for all transactions between users, to compensate
    software developers and computation resource providers. The transaction framework
    is built on top of Ethereum, so it inherits the underlying payment architecture
    and extends it to implement advanced payment schemes such as nanopayment mechanisms
    and transaction batching. Both innovations mentioned here are unique to Golem,
    so let’s talk about why they are necessary to the network. To power microservices,
    Golem will have to process a very high volume of small transactions. The value
    of a single payment is very low and these payments are also known as nanopayments
    . However, there is one caveat when using nanopayments: The transaction fees cannot
    be larger than the nanopayment itself. To solve this problem, Golem uses transaction
    batching. This solution aggregates nanopayments and sends them at once as a single
    Ethereum transaction to reduce the applied transaction fees. For instance, Golem
    developers note that the cost of ten payments processed in a single transaction
    is approximately half the cost of ten payments processed in ten transactions.
    By batching multiple transactions, a significantly lower transaction fee will
    be passed on to a user paying for per-unit usage (per-node or per-hour) of a microservice.NoteFor
    providers, another model to power microservices is credit-based payment for per-unit
    hosting. Here, the requester makes a deposit of timelocked GNT and at the end
    of the day, the provider automatically deducts the charges for usage. The remaining
    credits are released back to the requester.In Golem, nanopayments work in the
    context of one-to-many micropayments from a requester to many providers that assist
    in completing the computational tasks. The payments carried out for microservices
    are on the scale of $0.01 and for such small sums, the transaction fees are relatively
    large even on Ethereum. The idea here is that instead of making individual transactions
    of $0.01, the requester (payer) issues a lottery ticket for a lottery for a $1
    prize with 1/100 chance of winning. The value of such a ticket is $0.01 for the
    requester and the advantage is that on average only one ticket in 100 will lead
    to an actual transaction. This is a probabilistic mechanism to allow nanotransactions,
    but it does not guarantee that one given Golem node will be compensated adequately
    if the number of tasks computed is small. Bylica et al. provided the mathematical
    background to assuring fair distribution of income from this lottery system as
    the network expands, adding more requesters and providers. Essentially, as the
    number of tasks by requesters increases, the income a node generates from probabilistic
    lottery rewards will approach the amount it would receive if being paid with individual
    transactions.The lottery system to be implemented in Golem is much more predictable
    for the providers than a completely probabilistic scheme. The provider is assured
    that among the tickets issued to reward the providers of a single task, there
    are no hash collisions and only one ticket is winning. Moreover, if there are
    100 providers participating in the lottery payment, then the nanopayment protocol
    guarantees that the task would only have to be paid out once. Bylica and collaborators
    discussed a few counterclaim mechanisms in place to prevent malicious entities
    from claiming to be lottery winners and cashing out. A brief sketch of the lottery
    process is provided as follows. After a task has been completed, the payer initiates
    a new lottery to pay out the participating providers. The payer creates a lottery
    description L that contains a unique lottery identifier and calculates its hash
    h(L). The hash is written to the Ethereum contract storage. The payer also announces
    the lottery description L to the Golem network, so that every participating node
    can verify that the payment has the correct value and check that h(L) is indeed
    written to the Ethereum storage. The winner of a lottery payout can be uniquely
    determined by cross-referencing a given description L and a random value R that
    is unknown to all parties except the lottery smart contract. After a certain amount
    of time, if the reward has not been claimed, the smart contract computes the winning
    provider’s address (given the L and R) and transfers the reward from the contract’s
    associated storage to the winner. The hash of the lottery h(L) is also removed
    from the contract storage and a new lottery payout cycle can now begin. The nanopayment-based
    lottery payment system is illustrated in Figure [7-6](#Fig6).![A430562_1_En_7_Fig6_HTML.jpg](Images/A430562_1_En_7_Fig6_HTML.jpg)Figure
    7-6.Nanopayment-based lottery payment systemOn a macroscale, Andrzej Regulski
    wrote a post describing some of the economic principles behind GNT and long-term
    appreciation in value of the token enabled by this transaction framework. The
    most pertinent items from his post are quoted here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 交易框架可以被视为类似于Stripe的东西，Stripe是一个用于赚取应用程序运行时费用的API。 在众筹结束后，网络将使用Golem Network
    Token (GNT)来进行用户之间的所有交易，以补偿软件开发者和计算资源提供者。 交易框架建立在以太坊之上，因此它继承了底层的支付架构，并扩展到实现高级支付方案，如纳米支付机制和交易批处理。
    这里提到的两项创新都是Golem独有的，所以让我们谈谈它们为什么对网络是必要的。 为了支持微服务，Golem将不得不处理大量的小额交易。 单笔支付的价值非常低，这些支付也被称为纳米支付。
    但是，在使用纳米支付时有一个注意事项：交易费用不能大于纳米支付本身。 为了解决这个问题，Golem使用了交易批处理。 这种解决方案聚合了纳米支付，并一次性将它们作为单个以太坊交易发送，以减少应用的交易费用。
    例如，Golem的开发人员指出，使用单笔交易处理的十笔支付的成本约为使用十笔交易处理的十笔支付的一半。 通过批处理多个交易，将大大降低交易费用，这将传递给为微服务的每个单位使用（每个节点或每小时）支付的用户。
    对于提供者来说，另一个用于支持微服务的模型是基于信用的按单位主机付费。 在这里，请求者存入了定时锁定的GNT押金，一天结束时，提供者会自动扣除使用费用。 剩余的信用额将退还给请求者。
    在Golem中，纳米支付在请求者向帮助完成计算任务的多个提供者进行一对多的微支付的背景下发挥作用。 用于微服务的支付的规模为$0.01，对于如此小的金额，即使在以太坊上，交易费用也相对较高。
    这里的想法是，与其进行$0.01的单独交易，请求者（付款人）发行了一个价值为$1的彩票，这个彩票有1/100的中奖机会。 这样的票价值对于请求者来说是$0.01，优点是平均而言，只有100中才会导致实际交易。
    这是一个概率机制，允许纳米交易，但并不保证一个给定的Golem节点会在计算任务量较小时得到充分的补偿。 Bylica等人提供了数学背景，以确保从这种抽奖系统的收入公平分配，当网络扩展并添加更多请求者和提供者时。
    本质上，随着请求者任务的增加，节点从概率抽奖奖励中生成的收入将接近于如果以单独交易支付的金额。在Golem中要实施的抽奖系统对于提供者来说比完全概率性方案要可预测得多。
    提供者可以确保，在用于奖励单个任务的提供者的票据中，没有哈希冲突，并且只有一个票是中奖的。 此外，如果有100个提供者参与抽奖支付，那么纳米支付协议保证该任务只需支付一次。
    Bylica和合作者讨论了几种反索赔机制，以防止恶意实体声称是抽奖赢家并兑现。 抽奖过程的简要概述如下。 任务完成后，付款人启动新的抽奖以支付参与提供者。
    付款人创建包含唯一抽奖标识符的抽奖描述L，并计算其哈希h(L)。 该哈希写入以太坊合约存储。 付款人还向Golem网络宣布抽奖描述L，以便每个参与节点都可以验证付款是否具有正确的价值，并检查h(L)是否确实写入了以太坊存储。
    抽奖支付的获奖者可以通过交叉参考给定描述L和一个对所有参与方都未知的随机值R来唯一确定。 一段时间后，如果奖励没有被认领，智能合约将计算出获奖提供者的地址（给定L和R），并将奖金从合同的关联存储转移到获奖者。
    抽奖的哈希h(L)也将从合同存储中移除，现在可以开始新的抽奖支付周期。 纳米支付的抽奖支付系统如[图7-6](#Fig6)所示。![A430562_1_En_7_Fig6_HTML.jpg](Images/A430562_1_En_7_Fig6_HTML.jpg)图7-6.基于纳米支付的抽奖支付系统在宏观上，Andrzej
    Regulski撰写了一篇文章，描述了GNT背后的一些经济原理以及由此交易框架带来的代币长期升值。 他的文章中最相关的内容如下引用：
- en: GNT will be necessary to interact with the Golem network. At first, its sole
    role is to enable the transfer of value from requestors to providers, and to software
    developers. Later on, the Transaction Framework will make it possible to assign
    additional attributes to the token, so that, for example, it is required to store
    deposits in GNT.The number of GNT (i.e., the supply) is going to be indefinitely
    fixed at the level created during the Golem crowdfunding. No GNT is going to be
    created afterwards.A depreciation or appreciation of the token is neutral to the
    operations of the network, because users are free to set any ask/bid prices for
    compute resources in Golem, thus accommodating any fluctuations in GNT value.The
    constant amount of tokens will have to accommodate a growing number of transactions,
    hence increasing the demand for GNT. With a reasonable assumption that the velocity
    of the token (i.e., the number of transactions per unit of the token in a specific
    period) is constant over time, this conclusion can be drawn from the quantity
    theory of money. This, in turn, means that the overall success and growth of the
    Golem network implies a long-run appreciation of the GNT.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 Golem 网络进行交互将需要 GNT。起初，它的唯一作用是实现请求者向提供者和软件开发者的价值转移。之后，交易框架将使得能够为代币分配额外属性，例如，将其要求用于在
    GNT 中存储存款。GNT 的数量（即供应量）将无限期地固定在 Golem 众筹期间创建的水平上。之后不会再创建任何 GNT。代币的升值或贬值对网络的运营是中性的，因为用户可以自由设定
    Golem 中计算资源的任何要价/出价，从而适应 GNT 价值的任何波动。固定数量的代币将不得不适应日益增长的交易数量，从而增加对 GNT 的需求。合理假设代币的速度（即在特定周期内每单位代币的交易数量）随时间恒定，可从货币数量论中得出此结论。这反过来意味着
    Golem 网络的整体成功和增长意味着 GNT 的长期升值。
- en: 'This payment framework can also be used as a fallback mechanism for conflict
    resolution. If a task challenge remains open after going through the traditional
    Golem mechanics , we need a method for hard resolution (as we saw in the ECM section).
    Here, we can use a TrueBit-style “trial” for final resolution. TrueBit is a smart-contract-based
    dispute resolution layer built for Ethereum. It integrates as an add-on on top
    of the existing architecture for Ethereum projects such as Golem. The design principle
    for TrueBit is to rely on the only trusted resource in the network to resolve
    a dispute: the miners. A hard resolution using TrueBit relies on a verification
    subroutine involving limited-resource verifiers known as judges.In TrueBit’s verification
    game , there are three main players: a solver, a challenger, and judges. The solver
    presents a solution for a task, a challenger contests the presented answer, and
    the judge decides on whether the challenger or solver is correct. The purpose
    of using the verification subroutine is to reduce the complexity of on-chain computation.
    This is done as the game proceeds in rounds, where each round narrows down the
    scope of computation until only a trivial step remains. This last step is executed
    on-chain by a smart contract (judge) who issues the final verdict on which party
    is correct. Note that the judges in this scheme are constrained in terms of computational
    power. Therefore, only very simplistic computations are ultimately carried out
    on-chain for the judge to make a ruling. At the end of this game, if the Solver
    was in fact cheating, it will be discovered and punished. If not, then the Challenger
    will pay for the resources consumed by the false alarm. We provide an outline
    sketch of the verification game as follows. A visual guide to the verification
    game is provided in Figure [7-7](#Fig7).NoteThe verification game works iteratively,
    with a reward structure benefiting the verifiers (challengers) who diligently
    search for errors. Accurate detection and eventual verification of errors results
    in challengers being rewarded with a substantial jackpot.![A430562_1_En_7_Fig7_HTML.jpg](Images/A430562_1_En_7_Fig7_HTML.jpg)Figure
    7-7.Verification gameTo begin the trial, a challenger requests verification of
    a solution. The solvers get to work and provide their solutions. Verifiers get
    paid to check whether the solvers are providing accurate solutions for off-chain
    processing. If there is still a dispute, judges will perform on-chain processing
    looking for the first disagreement with the proposed solution. In the end, either
    the cheating solver is penalized, or the challenger will pay for the resources
    consumed by the false alarm.TrueBit is an advanced on-chain execution mechanism
    compared to the on-chain verification implemented in ECM . It allows the ability
    to verify computations at a lower cost than running the full instruction because
    only one step is executed on-chain. Using TrueBit as a dispute resolution layer
    for off-chain computations, smart contracts can enable third-party programs to
    execute well-documented routines in a trustless manner. Even for advanced machine
    learning applications such as deep learning that require terabytes of data, as
    long as the root hash of training data is encoded in the smart contract, it can
    be used to verify the integrity of off-chain computations. The reason TrueBit
    works for large data sets is simply due to the Merkle roots mapping the state
    of the network at a given time t, and a challenger’s ability to perform binary
    search. For a project like Golem aiming to achieve HPC toward a variety of use
    cases, TrueBit can enable large data sets to be used off-chain with an on-chain
    guarantee of accurate outputs.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此支付框架也可以用作冲突解决的备用机制。如果任务挑战在经过传统的Golem机制后仍然保持开放状态，我们需要一种硬解决方法（正如我们在ECM部分所看到的）。在这里，我们可以使用TrueBit风格的“审判”进行最终解决。TrueBit是一个基于以太坊的智能合约的争议解决层。它作为一个附加组件集成到了以太坊项目如Golem的现有架构之上。TrueBit的设计原则是依赖于网络中唯一可信赖的资源来解决争议：矿工。使用TrueBit进行硬解决依赖于一个涉及被称为法官的有限资源验证者的验证子程序。在TrueBit的验证游戏中，有三个主要参与者：求解器、挑战者和法官。求解器提出了一个任务的解决方案，挑战者对提出的答案提出质疑，法官决定挑战者或求解器谁是正确的。使用验证子程序的目的是减少链上计算的复杂性。这是通过游戏进行的，其中每一轮都缩小了计算的范围，直到只剩下一个微不足道的步骤。这最后一步由一个智能合约（法官）在链上执行，法官发出最终的判决，确定哪一方是正确的。请注意，该方案中的法官在计算能力方面受到限制。因此，最终只有非常简单的计算会在链上执行，以供法官作出裁决。在这个游戏结束时，如果求解器实际上作弊了，它将被发现并受到惩罚。如果没有，那么挑战者将为错误警报消耗的资源付费。我们提供了验证游戏的概要如下。验证游戏的视觉指南如图[7-7](#Fig7)所示。注意，验证游戏是迭代进行的，奖励结构有利于勤奋搜索错误的验证者（挑战者）。准确检测和最终验证错误会使挑战者获得大量的奖金。![A430562_1_En_7_Fig7_HTML.jpg](Images/A430562_1_En_7_Fig7_HTML.jpg)图7-7.验证游戏要开始试验，挑战者请求验证解决方案。求解器开始工作并提供他们的解决方案。验证者获得报酬来检查求解器是否为离线处理提供准确的解决方案。如果仍然存在争议，法官将进行链上处理，寻找与所提出的解决方案的第一个不一致之处。最后，要么作弊的求解器受到惩罚，要么挑战者将为错误警报消耗的资源付费。TrueBit与在ECM中实现的链上验证相比是一种先进的链上执行机制。它允许以较低的成本验证计算，因为只有一个步骤在链上执行。使用TrueBit作为离线计算的争议解决层，智能合约可以使第三方程序以不可信赖的方式执行良好文档化的例程。即使对于需要大量数据的高级机器学习应用程序，如深度学习，只要训练数据的根哈希被编码在智能合约中，它就可以用于验证离线计算的完整性。TrueBit适用于大数据集的原因仅仅是由于Merkle根映射了网络在给定时间t的状态，以及挑战者执行二分搜索的能力。对于像Golem这样的项目，旨在实现面向各种用例的HPC，TrueBit可以使大数据集在链下使用，并在链上保证输出的准确性。
- en: Supercomputing Organized by Network Mining
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由网络挖掘组织的超级计算
- en: 'SONM is a decentralized implementation of the fog computing concept using a
    blockchain. To understand how SONM works within the framework of fog computing,
    we first need to define two networking concepts: IoT and IoE. The European Commission
    defines the IoT architecture as a pervasive network of objects that have IP addresses
    and can transfer data over the network. IoT lends itself to the broader concept
    of Internet of Everything (IoE) , which provides a seamless communication bus
    and contextual services between objects in the real world and the virtual world.
    IoE is defined by Cisco as:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SONM 是利用区块链实现的雾计算概念的分散实现。要了解 SONM 如何在雾计算框架内运作，首先需要定义两个网络概念：IoT 和 IoE。欧洲委员会将
    IoT 架构定义为具有 IP 地址并可以在网络上传输数据的普遍对象网络。IoT 适用于更广泛的“万物互联”（IoE）概念，它在现实世界和虚拟世界之间提供无缝的通信总线和环境服务。Cisco
    将 IoE 定义为：
- en: The networked connection of people, process, data, and things. The benefit of
    IoE is derived from the compound impact of connecting people, process, data, and
    things, and the value this increased connectedness creates as “everything” comes
    online.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 人、流程、数据和事物的网络连接。IoE 的好处源自于连接人、流程、数据和事物，以及这种增加的连接性所创造的“一切”上线的价值。
- en: 'Whereas IoT traditionally refers to devices connected to each other or cloud
    services, IoE is an umbrella term for a heavier focus on people as an essential
    component attached to the business logic for generating revenue. From an engineering
    standpoint, IoT is the messaging layer focusing on device-to-device communication
    and IoE is the monetization layer allowing startups to capitalize on the interaction
    between people and their devices. A staggering amount of data is generated from
    devices connected in an IoT network. Transferring these data to the cloud for
    processing requires enormous network bandwidth, and there are delays between when
    the data are generated and processing these data and receiving the results (from
    hours to days). A major limitation of IoT technology is that transfer delay period.
    Recently, a growing concern has been the loss of value on actionable data due
    to the transfer and processing stages: By the time we receive those processed
    results, it becomes too late to act on those data.One solution presented by Ginny
    Nichols from Cisco is called fog computing. Fog computing reduces the transfer
    delay by shifting the processing stage to lower levels of the network. Instead
    of processing a task by offloading it to a centralized cloud, fog computing pushes
    high-priority tasks to be processed by a node closest to the device actually generating
    the data. For a device to participate in the fog, it must be capable of processing
    tasks, local storage, and have some network connectivity. The concept of fog computing
    is a metaphor for the fact that fog forms close to the ground. Therefore, fog
    computing extends the cloud closer to the devices (ground) that produce IoT data
    to enable faster action. In fog computing, data processing is said to be concentrated
    at the edge (closer to the devices generating data) rather than existing centrally
    in the cloud. This allows us to minimize latency and enable faster response to
    time-sensitive tasks or reduce the time within which an action can be taken on
    data. SONM makes this layer of fog computing available to a decentralized network
    of participants for processing computationally intensive tasks.NoteThe need for
    faster response time to data (or business analytics) collected by large enterprises
    stimulated the development of real-time computational processing tools such as
    Apache Spark, Storm, and Hadoop. These tools allow for preprocessing of data as
    they are being collected and transferred. In a similar manner, fog computing seems
    to be an extension of IoT developed in response to the need for rapid response.SONM
    is built on top of Yandex.Cocaine (Configurable Omnipotent Custom Applications
    Integrated Network Engine). Cocaine is an open-source PaaS stack for creating
    custom cloud hosting engines for applications similar to Heroku. SONM has a complex
    architecture designed to resemble the world computer model of Ethereum. The SONM
    team designed this world computer with components that are parallel to a traditional
    personal computer, with one major difference: The components are connected to
    a decentralized network.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而   IoT 传统上是指相互连接或连接到云服务的设备，而 IoE 则是一个更加重视人作为与业务逻辑相结合的重要组成部分以生成收入的总称。从工程的角度来看，IoT
    是侧重于设备之间通信的消息传递层，而 IoE 则是允许初创企业资本化人与其设备之间交互的货币化层。在 IoT 网络中连接的设备会产生大量数据。将这些数据传输到云进行处理需要庞大的网络带宽，并且在生成数据和处理数据以及接收结果之间存在延迟（从几小时到几天）。IoT
    技术的一个主要限制是传输延迟期间。最近，人们越来越关注由于传输和处理阶段而导致可操作数据价值损失的问题：当我们收到这些经过处理的结果时，已经为时过晚了。Cisco
    的 Ginny Nichols 提出的一个解决方案称为雾计算。雾计算通过将处理阶段转移到网络的较低层来减少传输延迟。雾计算不是将任务交给集中式云进行处理，而是将高优先级任务推送到实际生成数据的设备最近的节点进行处理。要使设备参与雾计算，它必须能够处理任务、具有本地存储功能，并具有一些网络连接性。雾计算的概念是雾靠近地面的隐喻。因此，雾计算将云延伸到生成
    IoT 数据的设备（地面）附近，以实现更快的响应。在雾计算中，数据处理被认为是集中在边缘（靠近生成数据的设备）而不是集中在云中的。这使我们能够将延迟最小化，并实现对时效任务的更快响应或减少采取数据行动的时间。SONM
    使雾计算这一层面可用于分布式网络的参与者以处理计算密集型任务。需要更快的数据响应时间（或大型企业收集的业务分析）推动了实时计算处理工具的开发，如 Apache
    Spark、Storm 和 Hadoop。这些工具允许在数据收集和传输过程中对数据进行预处理。类似地，雾计算似乎是对 IoT 的一种延伸，是对快速响应需求的响应。SONM
    是建立在 Yandex.Cocaine（可配置万能自定义应用程序集成网络引擎）之上的雾计算概念的分散实现。SONM 的复杂架构设计成与以太坊的世界计算机模型相似。SONM
    团队设计了这个世界计算机，其组件与传统的个人计算机并行，但有一个主要区别：这些组件连接到分散网络。
- en: 'CPU/processor (load balancer): In SONM’s architecture , the processor (hub)
    serves as a load balancer and task scheduler. The entire network can be represented
    as a chain of hub nodes (or hubs) that distribute tasks, gather results from a
    computing fog, pay miners for services, and provide status updates on the overall
    health of the network. Each hub node is analogous to a processor’s core, and the
    number of cores (or hub nodes) can be extended or reduced on the network as necessary.
    In a personal computer, the cores are locally accessible to the processor, however,
    in SONM, the cores are decentralized by nature. The hubs provide support to the
    whole network for coordinating the execution of tasks. More specifically, hubs
    provide the ability to process and parallelize high-load computations on the fog
    computing cloud.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU/处理器（负载均衡器）：在SONM的架构中，处理器（中心）充当负载均衡器和任务调度程序。整个网络可以被表示为一系列中心节点（或中心），它们分发任务，从计算雾中收集结果，为服务支付矿工，并提供关于网络整体健康状况的状态更新。每个中心节点类似于处理器的核心，并且核心的数量（或中心节点）可以根据需要在网络上扩展或减少。在个人计算机中，核心可由处理器本地访问，但在SONM中，核心具有去中心化的性质。中心为整个网络提供支持，协调任务的执行。更具体地说，中心提供在雾计算云上处理和并行化高负载计算的能力。
- en: 'BIOS (blockchain): For SONM, the BIOS is the Ethereum blockchain. Ethereum
    offers a reliable backbone for network consensus and payment mechanisms that SONM
    can inherit. However, the base Ethereum implementation lacks a load balancer and
    high gas costs have inspired alternatives on top of the blockchain such as SONM.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BIOS（区块链）：对于SONM，BIOS是以太坊区块链。以太坊为网络共识和支付机制提供了可靠的基础，SONM可以继承。然而，基本的以太坊实现缺乏负载均衡器，并且高昂的燃气成本已经激发了在区块链上的替代方案，如SONM。
- en: 'Graphics processing unit (GPU) : The GPU for SONM is the fog computing cloud.
    More specifically, this fog is comprised of the miners in the SONM network that
    are making computational resources available to buyers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形处理单元（GPU）：SONM的GPU是雾计算云。更具体地说，这片雾由SONM网络中的矿工组成，他们为买家提供计算资源。
- en: 'Connected peripherals: The buyers in SONM are equivalent to peripheral devices.
    They connect to the network and pay for any resources they use. The requests are
    broadcast on the blockchain and miners select what they want to execute on their
    machines. Then, the load balancer dictates the execution of tasks.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的外围设备：在SONM中，买家相当于外围设备。他们连接到网络并支付他们使用的任何资源。请求在区块链上广播，矿工选择要在他们的机器上执行的内容。然后，负载均衡器决定任务的执行。
- en: 'Hard disk: Storage in SONM will be implemented using well-established decentralized
    storage solutions such as IPFS or Storj .'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘：SONM中的存储将使用诸如IPFS或Storj之类的成熟的去中心化存储解决方案实现。
- en: 'Serial bus: This communication module is used for message passing and data
    transfer within the network between the sender (a node) and working machines.
    This serial bus is based on Ethereum Whisper, and enables broadcast and listening
    functions for messages on the network.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行总线：这个通信模块用于网络内的消息传递和数据传输，发送者（节点）和工作机器之间的通信。这个串行总线基于以太坊Whisper，并为网络上的消息提供广播和监听功能。
- en: 'Plug-ins circuit board : A plug-ins board can be thought of as an expansion
    pack for the network. It allows SONM to expand its processing capabilities by
    seamlessly integrating compatible networks and computation farms.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件电路板：插件电路板可以被视为网络的扩展包。它允许SONM通过无缝集成兼容的网络和计算农场来扩展其处理能力。
- en: Figure [7-8](#Fig8) provides a visual representation of the world computer’s
    components that just discussed.![A430562_1_En_7_Fig8_HTML.jpg](Images/A430562_1_En_7_Fig8_HTML.jpg)Figure
    7-8.World computer implemented in SONMThe communication bus forms the backbone
    of this architecture, connecting at every level to the components of the world
    computer. The workflow of a request through SONM begins with a buyer requesting
    computational resources. This request is broadcast on the blockchain and the serial
    bus so that other components can verify if a particular request is legitimate.
    The miners accept the task, and the load balancer distributes the task to be executed
    in the fog computing cloud . If necessary, the load balancer can also assign a
    task to run on an application-specific grid network compatible with SONM through
    the plug-ins board . The fog cloud also has local storage in the form of a decentralized
    service such as Storj or IPFS that is used as necessary. Finally, the load balancer
    also has two more important roles, to follow up with the task results and overall
    network health. The load balancer (hub) collects the results of a task after it
    has been completed and sends it back to the buyer. A health indicator reports
    on the status of every component in the world computer to the load balancer and
    the network to make better decisions regarding task assignment and execution.The
    smart contract system in SONM is a set of protocols (smart contracts) for blockchain
    governance and management of decentralized applications implemented on the network.
    This system of smart contracts maintains the integrity of the network and provides
    several countermeasures against malicious entities that we discuss later. Furthermore,
    SONM uses formal definitions and rigorous proofs to demonstrate the security of
    communication (cryptographically secure message passing) between buyers and providers.
    The interactions between various parties on the network are modeled using a high-level
    mathematical framework called pi-calculus . This framework is a formal language
    for describing secure and concurrent interactions within a multiparty system over
    well-defined channels. The governance prototype in SONM includes a DAO, a court
    contract, a network-wide registry of hubs, and a factory contract to deploy new
    applications to the SONM network (e.g., the whitelist, hub factory, and hub wallet).
    This model is extended to include some new elements (deployed by the factory)
    necessary for management of DApps that run on the network. Currently, the process
    of buying computational resources appears very fragmented on the network. However,
    in future releases, buyers will complete a prepurchase computing form to indicate
    their hardware selection, the DApps they want to use, and any special execution
    parameters. Let’s look at the complete set of smart contracts used in the current
    SONM blockchain government in more depth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [7-8](#Fig8) 提供了刚刚讨论的世界计算机组件的视觉表示。![A430562_1_En_7_Fig8_HTML.jpg](Images/A430562_1_En_7_Fig8_HTML.jpg)图
    7-8.SONM 实现的世界计算机通信总线形成该架构的骨干，连接到世界计算机的各个组件。通过 SONM 的请求工作流程始于买方请求计算资源。此请求广播到区块链和串行总线，以便其他组件验证特定请求是否合法。矿工接受任务，负载平衡器将任务分配到雾计算云中执行。如有必要，负载平衡器还可以通过插件板将任务分配到与
    SONM 兼容的应用专用网格网络上运行。雾云还具有本地存储，例如 Storj 或 IPFS 形式的去中心化服务，根据需要使用。最后，负载平衡器还有两个更重要的角色，跟踪任务结果和整体网络健康状况。负载平衡器（中心）在任务完成后收集任务结果并将其发送回给买方。健康指示器报告世界计算机中每个组件的状态给负载平衡器和网络，以更好地决策任务分配和执行。SONM
    中的智能合约系统是一组用于区块链治理和管理在网络上实现的去中心化应用程序的协议（智能合约）。这套智能合约系统维护网络的完整性，并提供了几项针对恶意实体的对策，我们稍后会讨论。此外，SONM
    使用正式定义和严格证明来证明买家和提供者之间的通信的安全性（加密安全消息传递）。网络上各方之间的互动使用称为 pi-calculus 的高级数学框架进行建模。这个框架是用于描述多方系统内安全和并发交互的形式语言，通过明确定义的通道。SONM
    中的治理原型包括 DAO、法庭合约、中心的网络注册表和用于将新应用程序部署到 SONM 网络的工厂合约（例如白名单、中心工厂和中心钱包）。这个模型被扩展以包括一些新元素（由工厂部署），用于管理运行在网络上的
    DApps 所需。目前，在网络上购买计算资源的流程看起来非常分散。但在未来的发布版本中，买家将完成一个预购计算表单，以指示他们的硬件选择、他们想要使用的 DApps
    以及任何特殊的执行参数。让我们更深入地研究当前 SONM 区块链治理中使用的完整智能合约集合。
- en: 'SONM token: This is the default currency of the network. The token is used
    to reward miners for providing computational resources and for user transactions
    within the network.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SONM 代币：这是网络的默认货币。代币用于奖励提供计算资源的矿工，并用于网络内用户交易。
- en: 'DAO: This is the regulatory body of SONM that grants users voting rights and
    administrative actions to manage decentralized applications. DApps on the network
    are required to pay taxes to be included in the DAO and gain access to the court.
    The DAO also has executive privileges to perform actions such as blacklisting
    a hub, releasing and locking funds to ensure proper payout for miners, and suspending
    or banning a hub.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAO：这是SONM的监管机构，授予用户投票权和管理去中心化应用程序的管理权限。网络上的 DApps 必须向 DAO 支付税款以获得访问权限，并获得法庭的支持。DAO
    还具有执行特权，例如列入黑名单的中心、释放和锁定资金以确保矿工的适当支付，以及暂停或禁止中心。
- en: NoteThe court will be implemented as a dispute resolution smart contract accessible
    through the DAO. It will offer protection against unfair buyers or providers in
    the market, along with result verification in case of challenges toward a solution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：法庭将作为通过 DAO 可访问的争议解决智能合约来实施。它将提供保护，防止市场上的不公平买家或提供者，并在挑战解决方案时提供结果验证。
- en: 'Hub factory: A hub has two extensions in the smart contract system , a factory
    and a wallet. The wallet can only be created by a hub wallet factory. The factory
    creates a new wallet contract and then registers this contract in the whitelist
    .'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心工厂：中心在智能合约系统中有两个扩展，一个是工厂，一个是钱包。钱包只能由中心钱包工厂创建。工厂创建一个新的钱包合同，然后将该合同注册到白名单中。
- en: 'Hub wallet: The hub wallet is a contract that receives payments from buyers
    and facilitates the payout of tokens to miners for services. The wallet is created
    by a factory and it can exist in one of four possible states: Created, Registered,
    Idle, or Suspected/Punished. Initially, all wallets exist in the Created state
    and have a fixed amount of frozen funds. In the Created state, a contract can
    be registered on the whitelist. This contract now switches to the Registered state,
    and has access to advanced functions such as transfer and payday. Now this wallet
    can begin to pay out miners (but not itself) within a specified amount of time,
    called the payout period. After the end of the payout period, the wallet can transfer
    the remaining money to the owner’s wallet using the payday function. If a connected
    hub is caught performing malicious behavior, the DAO can blacklist the hub and
    seize the frozen funds. The DAO can further decide to change the state of the
    wallet to Suspected or Punished depending on the case.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心钱包：中心钱包是一个合同，用于接收买家的付款，并促成将代币支付给矿工以换取服务。该钱包由一个工厂创建，可以存在四种可能的状态之一：已创建（Created）、已注册（Registered）、空闲（Idle）或者可疑/受惩罚（Suspected/Punished）。最初，所有钱包都处于已创建状态，并拥有固定数量的冻结资金。在已创建状态下，合同可以被注册到白名单上。该合同现在切换到已注册状态，并且可以访问高级功能，例如转账和发薪日。现在，该钱包可以开始在指定的时间内支付矿工（但不能支付自己）。在支付期结束后，钱包可以使用发薪日功能将剩余资金转移到所有者的钱包中。如果连接的中心被发现进行恶意行为，DAO
    可以将该中心列入黑名单，并没收冻结资金。DAO 还可以根据情况决定将钱包状态更改为可疑或受罚。
- en: 'Whitelist: The whitelist is a registry-type contract that contains detailed
    information about hubs across the network along with their status. All wallets
    created by the factory are registered in this whitelist contract. Initially, this
    whitelist serves as a registry for trusted hubs verified by SONM developers to
    be safe and secure. Eventually, this functionality will be expanded to open ratings
    for new and emerging hubs.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白名单：白名单是一个注册类型的合同，包含网络中各个中心的详细信息及其状态。工厂创建的所有钱包都注册在这个白名单合同中。最初，这个白名单作为 SONM 开发人员验证为安全可靠的受信任中心的注册表。最终，这个功能将扩展到为新兴中心开放评级。
- en: 'RegApp: This is a simple web app made with React.js used for hub-node registration
    . This application adds a node to the whitelist contract. It should be noted that
    the RegApp is language agnostic and only needs a web interface to register the
    node. In this instance, React.js was used, but other web programming languages
    can work just as well.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RegApp：这是一个使用 React.js 制作的简单 Web 应用程序，用于中心节点注册。该应用程序将节点添加到白名单合同中。值得注意的是，RegApp
    是与语言无关的，只需要一个 Web 接口来注册节点。在这个例子中，使用了 React.js，但其他 Web 编程语言同样有效。
- en: 'PayOut app: A payment application that runs on the SONM network to pay and
    process the tokens given to miners for their services. This application is an
    example of the types of DApps that a factory contract would deploy.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PayOut 应用程序：运行在 SONM 网络上的支付应用程序，用于向矿工支付和处理他们服务所得的代币。这个应用程序是工厂合同部署的 DApp 类型的示例。
- en: 'Figure [7-9](#Fig9) provides a visual companion to the smart contract system
    just discussed. Anthony Akentiev from Chain Cloud reviewed the SONM whitepaper
    and provided some comments regarding the crowdfunding efforts using SOMN token
    to fund the development of this smart contracts architecture in future releases:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图[7-9](#Fig9)提供了刚讨论的智能合约系统的视觉辅助。来自 Chain Cloud 的 Anthony Akentiev 审查了 SONM 白皮书，并就使用
    SOMN 代币进行众筹以资助未来版本中智能合约架构的开发提供了一些评论：
- en: 'The crowdfunding is divided into 2 stages—the presale and the ICO. 19% and
    20% of all funds are sent to the team as a reward. Development and marketing will
    require equal amounts of money: 34% for the development and 32% for marketing
    after the presale; 30% for the development and 33% for marketing after the ICO.
    It looks good and fair.Conclusion — 45/60One of the best Whitepapers that I have
    read. Big project. Big goals. The presale and ICO are gonna be big.'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 众筹分为 2 个阶段——预售和 ICO。19% 和 20% 的所有资金作为奖励发送给团队。开发和营销将需要相等的资金：预售后开发 34%，营销 32%；ICO
    后开发 30%，营销 33%。看起来很好，很公平。结论——45/60 我读过的最好的白皮书之一。大项目。宏伟目标。预售和 ICO 将会很大。
- en: '![A430562_1_En_7_Fig9_HTML.jpg](Images/A430562_1_En_7_Fig9_HTML.jpg)Figure
    7-9.Overview of the smart contract system in SONMRecall that the smart contract
    system in SONM is further made from several contracts working together. The first
    of these contracts is a migration function that allows users who purchased the
    SONM presale token (SPT, during the presale that Akentiev mentioned) to exchange
    their token for the SONM token (SNM) and participate in the network. Next is the
    hub factory contract used in SONM for deployment of applications. In the current
    implementation, the hub factory creates the hub wallet used to compensate miners
    for their computational resources. The factory also deploys a network-wide whitelist
    contract that serves as a registry of hubs active on the network and wallets created
    in each hub. Finally, the factory deploys a payout application that releases SNM
    tokens to miners for the provided services. The last smart contract we consider
    here is the DAO, which provisions several administrative functions to stop malicious
    entities. These functions include delisting a hub (from the whitelist contract)
    if caught in fraud, freezing funds by suspending a hub wallet, or conflict resolution
    in case of challenges using the court.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![A430562_1_En_7_Fig9_HTML.jpg](Images/A430562_1_En_7_Fig9_HTML.jpg)图 7-9.SONM智能合约系统概述回想一下，SONM中的智能合约系统是由几个合同共同工作进一步构建的。其中第一个合同是迁移功能，允许购买SONM预售代币（SPT，在Akentiev提到的预售期间）的用户将他们的代币兑换为SONM代币（SNM）并参与网络。接下来是SONM中用于部署应用程序的中心工厂合同。在当前的实现中，中心工厂创建用于补偿矿工计算资源的中心钱包。该工厂还部署了一个全网络白名单合同，用作网络上活跃的中心和每个中心创建的钱包的注册表。最后，工厂部署了一个支付应用程序，为提供的服务向矿工释放SNM代币。我们在这里考虑的最后一个智能合约是DAO，它为阻止恶意实体提供了几个管理功能。这些功能包括在欺诈行为中发现中心时将其从白名单合同中删除，通过暂停中心钱包冻结资金，或者在挑战情况下使用法院解决冲突。'
- en: Buyer–Hub–Miner Interactions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 买家-中心-矿工互动
- en: 'Posting a task on the SONM network requesting computational resources requires
    a fair amount of communication between the buyer and the miner who will execute
    the task. For instance, before processing can begin, there are several verification
    interactions that occur between a miner, the assigning hub, and the buyer. Once
    the buyer is verified, a hub will assign the task to a miner’s fog computing cloud
    and ensure the miner is paid for their services. This collective set of interactions
    is defined here as client–hub–miner communication. This interchange can be best
    demonstrated visually in Figures [7-10](#Fig10) and [7-11](#Fig11). Figure [7-10](#Fig10)
    explains the miner–hub interactions when a computation begins and Figure [7-11](#Fig11)
    provides the full picture by introducing the client and miner payout.![A430562_1_En_7_Fig10_HTML.jpg](Images/A430562_1_En_7_Fig10_HTML.jpg)Figure
    7-10.Miner–hub verificationA hub broadcasts information about an active hub wallet,
    and the hub owner’s IP address to the blockchain. This information is gathered
    by a listening agent and then dispatched to a miner. Before executing any tasks,
    a miner will go through a series of steps to validate the assigning hub. This
    process ensures that the hub can be trusted and that there are sufficient funds
    to pay for the computation in the hub wallet. A miner requests more information
    on the assigning hub through a global list called the hubs pool list. This network-wide
    list contains all the verified and unconfirmed hubs. To verify itself, a hub wallet
    sends its address on the blockchain and a history of past transactions as proof
    of authentication. The miner accepts the proof and can now begin the computation.
    It must be noted that all components of this validation process including hub
    broadcasts, verification requests, wallet information, and hubs pool list use
    the same infrastructure: the blockchain. The requests and broadcasts are shared
    to the rest of the network using the messaging bus built with Whisper on top of
    the blockchain. The dashed blue line in Figure [7-10](#Fig10) indicates a continuation
    of processes happening on the blockchain with notifications moving to the messaging
    bus. In addition to the pool list, the miner can also request other miners to
    independently verify the assigning hub’s credentials. Over time, the miner builds
    a personal rating list for hubs across the network that have assigned tasks. This
    list can be used to automate task acceptance and skip the verification steps for
    a highly trusted hub.![A430562_1_En_7_Fig11_HTML.jpg](Images/A430562_1_En_7_Fig11_HTML.jpg)Figure
    7-11.Buyer–hub–miner interactionsAfter the initial verification of the assigning
    hub has been completed, the buyer puts forth an initial deposit. This deposit
    is a rough estimate of the computation costs, and it is stored in the hub wallet.
    The miner verifies this deposit and the buyer signs an agreement on the blockchain
    with the estimated costs along with a hash of the raw file. This agreement is
    sent to the miner as the computational task is assigned by a hub. The raw file
    is made available to the miner for download through a torrent. After the file
    has been downloaded, the task description along with any special parameters are
    applied and the processing begins. Once the task is completed, the results are
    made available from the fog computing cloud, and the hub collects these results.
    This hub now makes the results available for the buyer to download through a separate
    torrent. At this point, the agreement has been completed and funds from the hub
    wallet are released to the miner for offering their computational resources. In
    future releases, there will be proper locking mechanisms to account for over-
    or underestimation of the costs. Until the buyer adjusts for any errors in the
    estimates, the results will not be released by the hub .'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在SONM网络上发布请求计算资源的任务需要买方和执行任务的矿工之间进行相当多的沟通。例如，在处理开始之前，矿工、分配中心和买方之间会进行几次验证交互。一旦买方经过验证，中心将任务分配给矿工的雾计算云，并确保矿工得到他们服务的报酬。这一系列的互动在这里被定义为客户-中心-矿工的通信。这种交流可以通过图[7-10](#Fig10)和[7-11](#Fig11)最好地进行可视化展示。图[7-10](#Fig10)解释了当计算开始时的矿工-中心交互，图[7-11](#Fig11)通过引入客户和矿工报酬提供了全面的图景。![A430562_1_En_7_Fig10_HTML.jpg](Images/A430562_1_En_7_Fig10_HTML.jpg)图7-10.矿工-中心验证中心广播有关活跃中心钱包的信息以及中心所有者的IP地址到区块链。这些信息由一个监听代理收集，然后发送给一个矿工。在执行任何任务之前，矿工将经过一系列步骤来验证分配中心。这个过程确保中心是可信的，并且有足够的资金支付中心钱包中的计算费用。矿工通过一个全局列表，即中心池列表，请求有关分配中心的更多信息。这个网络范围的列表包含了所有经过验证和未经确认的中心。为了验证自身，中心钱包会在区块链上发送其地址和过去交易的历史作为身份验证的证据。矿工接受这个证据后就可以开始计算了。必须注意的是，这个验证过程的所有组件，包括中心的广播、验证请求、钱包信息和中心池列表都使用相同的基础设施：区块链。请求和广播通过在区块链之上构建的基于Whisper的消息总线与网络的其余部分共享。图[7-10](#Fig10)中的虚线蓝线表示在区块链上发生的过程的继续，通知传递到消息总线。除了池列表之外，矿工还可以请求其他矿工独立验证分配中心的凭据。随着时间的推移，矿工在整个网络中为分配任务的中心建立了个人评级列表。这个列表可以用来自动接受任务并跳过对高度信任中心的验证步骤。
- en: Superglobal Operation System for Network Architecture
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超全球操作系统网络架构
- en: 'So how does a buyer know whether a miner satisfies the required dependencies
    to compile and run an application that the buyer requested? How does a buyer know
    what applications are compatible with a miner’s setup? These questions are handled
    by the operating system for SONM. A world computer is not complete without an
    operating system (OS) to power it, and the OS for SONM is called the Superglobal
    Operation System for Network Architecture (SOSNA) .NoteIn this chapter, we have
    discussed SONM only in the context of buyers and providers for HPC services, however,
    the first use cases for early versions of SONM focuses on running a Quake server
    in a completely decentralized manner. The roadmap includes the message passing
    protocols and the payout app next.The problem of dependency management and compatibility
    for compilers will be handled by using containers on host machines. A container
    is simply a minimal virtual machine that can load any specified configuration,
    from installing new libraries to standard tools such as the GNU compiler toolchain.
    The container runs in a minimal isolated environment on the host system. This
    is done to prevent any escalation of privilege attacks by malicious programs running
    within the container. SOSNA can be divided into three main components : the blockchain
    layer comprised of the smart contract system, a grid core, and a layer of consumer-facing
    applications. We already discussed the blockchain layer and API (enabled by the
    smart contracts) in detail. Let’s shift our focus to the grid core. In SONM, any
    grid-compatible PaaS stack can be plugged in to work with the network such as
    BOINC (Berkeley Open Infrastructure for Network Computing) or Yandex.Cocaine.A
    simplified implementation of grid architecture involves two units: multiple worker/slave
    modules and a master module. These two units form a computing cloud, and a fog
    computing cloud extends this idea to hundreds of instances deployed across all
    types of machines. What defines a grid network as such is that a master machine
    manages workers distributed across distance to different geographic locations.
    The master essentially behaves like a hub, as it manages execution of applications
    on miners’ machines, balances load, schedules tasks, and collects the results.
    More generally, we can suggest that a master module works like a traditional miner
    pool.Any application executing inside a container is referred to as a service
    . Technically, all services in SONM are RPC-based and accept a specific set of
    messages to execute directives. Each service has a list of functions that can
    be referenced by sending messages to that service after a connection has been
    established. This set of functions is called a service protocol . A protocol can
    be dynamically obtained from a service once it becomes active by resolving the
    service name using a locator. The use of a locator can be thought of in analogy
    to hostname resolution using DNS. We return to the locator service shortly. On
    startup, a node loads the settings specified in a configuration file, including
    all the services to start on this particular node. The services lack the ability
    to communicate code over the network, so they can only receive messages in this
    state. To allow access to the network and RPC-compatible communication , the node
    will start a special service called the locator. Every other service running in
    the container becomes attached to the locator for receiving and sending messages.
    Once the locator service is activated, it binds to a public endpoint in the network
    and broadcasts the connection to the blockchain. What steps does a buyer need
    to perform to access a particular service for their task? Using the locator service,
    a buyer needs to go through the following five steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 买方如何知道矿工是否满足编译和运行买方请求的应用程序所需的依赖关系？买方如何知道哪些应用程序与矿工的设置兼容？这些问题由SONM的操作系统处理。没有操作系统（OS）来支持，世界计算机是不完整的，而SONM的操作系统称为超全球网络体系结构操作系统（SOSNA）。在本章中，我们只讨论了SONM在HPC服务的买方和提供者的背景下，然而，早期版本的SONM的第一个用例侧重于以完全分散的方式运行Quake服务器。路线图包括消息传递协议和下一步的支付应用程序。编译器的依赖管理和兼容性问题将通过在主机机器上使用容器来处理。容器只是一个最小的虚拟机，可以加载任何指定的配置，从安装新库到标准工具，如GNU编译器工具链。容器在主机系统上的最小隔离环境中运行。这样做是为了防止在容器内运行的恶意程序进行特权攻击。SOSNA可以分为三个主要组件：由智能合约系统组成的区块链层、网格核心和一层面向消费者的应用程序。我们已经详细讨论了区块链层和API（由智能合约启用）。让我们将注意力转向网格核心。在SONM中，任何与网络兼容的网格PaaS堆栈都可以插入以与网络一起工作，如BOINC（伯克利开放基础设施网络计算）或Yandex.Cocaine。网格架构的简化实现包括两个单元：多个工作/从属模块和一个主模块。这两个单元形成一个计算云，而雾计算云将这个想法扩展到部署在所有类型的机器上的数百个实例。定义网格网络的是，主机管理分布在不同地理位置的工人。主机基本上像一个中心，因为它管理应用程序在矿工机器上的执行，平衡负载，调度任务和收集结果。更普遍地，我们可以建议主模块的工作方式类似于传统矿工池。容器内执行的任何应用程序都称为服务。从技术上讲，SONM中的所有服务都是基于RPC的，并接受一组特定的消息来执行指令。每个服务都有一个可以在建立连接后通过发送消息到该服务来引用的函数列表。这组函数称为服务协议。一旦服务变为活动状态，就可以从服务中动态获取协议，方法是使用定位器解析服务名称。定位器的使用可以类比于使用DNS进行主机名解析。在启动时，节点加载指定在配置文件中的设置，包括在该特定节点上启动的所有服务。服务缺乏通过网络进行通信的代码的能力，因此它们只能在此状态下接收消息。为了允许访问网络和基于RPC的通信，节点将启动一个特殊的名为定位器的服务。容器中运行的每个其他服务都将附加到定位器以接收和发送消息。一旦定位器服务被激活，它就会绑定到网络中的一个公共端点，并将连接广播到区块链。买方需要执行哪些步骤才能访问特定服务来执行他们的任务？使用定位器服务，买方需要执行以下五个步骤：
- en: 1.Connect to locator endpoint on a public port.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.连接到公共端口上的定位器端点。
- en: 2.Send a resolve request with the name of a service to the locator.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2.向定位器发送一个包含服务名称的解析请求。
- en: 3.Receive a message back from the locator with information about the endpoint
    container, the protocol description, and function calls.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 从定位器收到一条消息，其中包含有关端点容器、协议描述和函数调用的信息。
- en: 4.Receive a confirmation message indicating that the request for information
    was completed.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 接收到确认消息，指示请求信息已完成。
- en: 5.Request for a specific miner with the endpoint information that matches the
    locator message and call the required service for task execution and processing.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 使用与定位器消息匹配的端点信息请求特定矿工，并调用所需的任务执行和处理服务。
- en: A visual companion to the components of SOSNA is provided in Figure [7-12](#Fig12).![A430562_1_En_7_Fig12_HTML.jpg](Images/A430562_1_En_7_Fig12_HTML.jpg)Figure
    7-12.Overview of SOSNA architectureWe start at the blockchain layer , which provides
    the consensus framework to the network, along with the smart contract system for
    governance. Next is the messaging bus layer that serves as a two-way communication
    channel between the various components of the world computer and users in the
    network. This layer also exists on both sides, allowing the blockchain to communicate
    to the consumer-facing applications and the grid core to coordinate task execution.
    On the very top, we have a consumer application layer where buyers can access
    the network and post requests for services. The RegApp is an early example of
    consumer applications that buyers would interact with in the future. Eventually,
    the consumer layer would split into more verticals with features such as trusted
    runtime skipping the verification stages from users with a high reputation in
    the network. On the opposite end, at the very bottom we have the grid core. This
    is the heart of SONM where the fog cloud computing takes place. The grid is essentially
    a parallel implementation of several hundred master and slave modules. The slave
    modules run containers where services execute, and these services are connected
    to a locator. The locator runs on a public port accessible to the buyer through
    the consumer-apps layer .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'SOSNA 组件的可视化伴随着图 [7-12](#Fig12)。![A430562_1_En_7_Fig12_HTML.jpg](Images/A430562_1_En_7_Fig12_HTML.jpg)图
    7-12.SOSNA 架构概览我们从区块链层开始，该层为网络提供共识框架，同时具有治理的智能合约系统。接下来是消息总线层，它作为世界计算机各个组件与网络中的用户之间的双向通信渠道。该层还存在于两侧，允许区块链与面向消费者的应用程序通信，以及网格核心协调任务执行。在最顶层，我们有一个消费者应用程序层，购买者可以访问网络并发布服务请求。RegApp
    是未来购买者将与之交互的消费者应用程序的早期示例。最终，消费者层将分成更多的垂直领域，具有诸如跳过用户网络中具有高声望的用户的验证阶段等功能。在相反的一端，在最底层我们有网格核心。这是
    SONM 的核心，雾化云计算发生的地方。该网格本质上是几百个主从模块的并行实现。从模块运行容器，服务执行，这些服务连接到定位器。定位器在公共端口上运行，通过消费者应用层使购买者可以访问。 '
- en: iEx.ec
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iEx.ec
- en: 'We conclude this chapter with a short discussion of the iEx.ec platform, which
    is also a distributed HPC token using a domain-specific blockchain. iEx.ec is
    built on a mature set of research technologies called XtremWeb developed for desktop
    grid computing by INRIA. So what is a desktop grid ? The idea behind desktop grid
    computing is to collect the computation resources of idle machines connected to
    the network to execute intensive parallel applications, at a very small cost (or
    free, in the case of volunteer desktop grid) compared to a traditional supercomputer.
    XtremWeb-HEP is a decentralized version of its predecessor, designed to execute
    tasks that require intensive computing resources in a marketplace of miners. This
    open-source desktop grid stack belongs to the Cycle Stealing family that uses
    idle resources on machines connected to the network for executing data-intensive
    applications. XtremWeb-HEP implements most of the features necessary in an HPC
    token that we have previously seen: fault tolerance, hybrid public–private infrastructure,
    deployment of virtual images (containers), load balancing, and a payment mechanism
    for the miners. The DApps running on the network will rely on iEx.ec architecture
    to automatically search for all the computing resources needed to run the app,
    provision resources, and release funds to the appropriate parties. Using a well-established
    and well-tested software stack offers three main advantages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用对 iEx.ec 平台的简短讨论结束这一章节，该平台也是一个使用特定领域区块链的分布式 HPC 代币。iEx.ec 是建立在由法国国家计算机与自动化研究所（INRIA）开发的
    XtremWeb 成熟研究技术之上的。那么什么是桌面网格？桌面网格计算的理念是收集连接到网络的空闲计算机的计算资源，以执行密集型并行应用，与传统超级计算机相比，成本非常低（或者在志愿者桌面网格的情况下是免费的）。XtremWeb-HEP
    是其前身的一个分散版本，旨在在矿工市场执行需要大量计算资源的任务。这个开源桌面网格堆栈属于 Cycle Stealing 家族，使用连接到网络的机器上的空闲资源来执行数据密集型应用程序。XtremWeb-HEP
    实现了我们之前看到的 HPC 代币中大多数必要的功能：容错性、混合公共-私有基础设施、虚拟镜像（容器）的部署、负载均衡和矿工的支付机制。网络上运行的 DApps
    将依赖于 iEx.ec 架构，自动搜索运行应用所需的所有计算资源，分配资源，并向适当的各方释放资金。使用一个成熟和经过充分测试的软件堆栈带来三个主要优势：
- en: 'Resilience: If one computation node fails , the task can be reassigned to other
    working nodes and continue with minimal downtime.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 韧性：如果一个计算节点失败，任务可以重新分配给其他工作节点，并在最小的停机时间内继续。
- en: 'Efficiency: The base performance of applications across the network is high,
    despite hardware configuration changes that occur for workers from one node to
    another.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率：尽管工作节点之间的硬件配置发生变化，但网络上应用的基本性能仍然很高。
- en: 'Pluggable nodes: New nodes can be added to the network without any special
    configuration, and nodes become integrated after a quick setup.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件式节点：新节点可以添加到网络中，而无需任何特殊配置，并在快速设置后成为集成的节点。
- en: In iEx.ec, any actions that happen externally or off-chain are referred to as
    a contribution. For instance, providing a data set, transferring files, and performing
    a computation are all actions that would require token transactions between the
    relevant parties. How do we know whether the action actually took place correctly?
    How can a particular transaction or set of transactions be associated with a particular
    action that was performed off-chain ? A new protocol is needed to verify that
    a contribution took place and which transactions correspond to it. iEx.ec has
    proposed a proof-of-contribution as a new consensus mechanism for off-chain contributions.
    This new mechanism also plays a role in enabling an enterprise feature in iEx.ec
    called a service-level agreement (SLA) . Using an SLA allows for resource utilization
    tracking and trusted computing resource orders from the customer to a provider.
    The iEx.ec team predicts that content distribution to parties on the network will
    be a tremendously important function of DApps using the iEx.ec blockchain. The
    buyers will have access to complex data sets on the blockchain through a smart
    contract, and a simple payment structure for running their application along with
    access to the data set. Using proof-of-contribution, iEx.ec can guarantee that
    the content providers are actually giving access to data sets, and that the file
    was accessible during the processing. For payment purposes, the duration of access
    can also be recorded to protect the buyer against overcharging. In addition, iEx.ec
    will have several countermeasures against malicious entities that claim file transfers
    failed to reduce data charges.The first few releases of iEx.ec will focus on consolidating
    the core features and a financial trading use case that requires HPC. This service,
    called eFast , will employ sophisticated computational prediction methods to allow
    small investors to make better trading decisions. The objective is to create diverse
    portfolios using cluster analysis of different stocks, but the computational complexity
    of such an analysis is so immense that only large financial institutions can afford
    it. A decentralized service like iEx.ec can reduce the processing cost to one
    tenth of what it would traditionally cost on a computation farm.NoteGolem and
    iEx.ec share similar goals for product development, but they differ in business
    approach. Golem aims to build the core infrastructure of the network and attract
    HPC and cloud customers. On the other hand, iEx.ec first focuses on building DApps
    that will run on the network to attract regular cloud customers that have a need
    for those applications at a cheaper rate.How do tasks get assigned and executed
    on iEx.ec? There are two algorithms that manage this process, a matchmaking algorithm
    for execution and a scheduler for assignment. Let’s briefly talk about both of
    them. A matchmaking algorithm is used in distributed systems to match pairs of
    resource providers and potential buyers according to the description of resources
    provided by the buyer. Recall that in SONM, this task was taken over by a load
    balancer; however, in iEx.ec, an algorithm performs resource provisioning. Eventually,
    the developers propose to store smart contracts on the blockchain that describe
    the availability of computational resources and the resources required to run
    a task. This can include information such as available RAM, processor or CPU,
    disk space, and the type of GPU. For a host machine, the tasks would be deployed
    to a virtual machine instance or a hypervisor, and the buyer would specify the
    runtime instructions. The matchmaking algorithm can implement more intricate policies
    beyond a simple one-to-one match and iEx.ec can monetize the more complex matches.
    There are several design choices for the matchmaking algorithm , but iEx.ec will
    be using a language called ClassAd, which has been well tested in the scientific
    literature. The second algorithm is the scheduler , which is critical to any distributed
    computing system. The performance and scalability of a network depends on the
    effectiveness of its scheduler. The design challenge for iEx.ec is to create a
    scheduler enabled with multiple-criteria decision analysis that can select optimal
    computing resources for each task and schedule it appropriately to fit the buyer’s
    criteria. A multicriteria might fit a customer’s needs based on the cost vs. performance
    benchmarks. One customer might want to minimize the price of computation if it
    takes longer, whereas another might want to minimize the time required. These
    are the types of scenarios that will be handled by a scheduler in iEx.ec.A versatile
    schedule and efficient matchmaking algorithm allow for very interesting upgrades
    to the core blockchain technology in the context of HPC. One remarkable example
    is the ability to use domain-specific blockchains (or sidechains). A sidechain
    is an adaptable blockchain designed to meet specific infrastructure requirements
    for running applications that would underperform in a generalized environment.
    The goal of such a blockchain is to maximize performance and minimize any time
    delays between execution. Normally, an application would go through the standard
    blockchain; however, in the case that a large amount of tasks are submitted, some
    of the tasks can be offloaded to a sidechain for tracking. The sidechain will
    track the amount of time spent on host machines and report the information back
    to the network. This offloading can reduce the traffic on the generalized blockchain.
    An advanced system of smart contracts would be developed to enable this switch.
    Figure [7-13](#Fig13) provides a visual companion to the iEx.ec architecture.![A430562_1_En_7_Fig13_HTML.jpg](Images/A430562_1_En_7_Fig13_HTML.jpg)Figure
    7-13.Overview of iEx.ec architectureThe top layer is a consumer-facing application,
    E-Fast . It is the first use case of iEx.ec that provides the infrastructure to
    run sophisticated financial prediction algorithms in a massively distributed setting
    for a fraction of the cost. Underneath is the Ethereum blockchain layer that provides
    consensus for the network and task-tracking for reimbursement of miners. The blockchain
    also acts as a platform for the smart contract system that will eventually run
    in the network. It is important to note that the blockchain layer does not interact
    with every level of iEx.ec; the distributed cloud level is managed more directly
    through a middleware XtremWeb-HEP. This is the resource management layer comprised
    of a task scheduler and a verified data repository. The scheduler coordinates
    between the blockchain and assigning tasks to workers on host machines. The repository
    contains large data sets from various fields such as finance and genomics that
    are made accessible to applications that buyers want to execute. The buyer connects
    to the resource management layer and provides a description of the task along
    with the source of data. This information is also recorded on the blockchain.
    Both components of the middleware connect to the deployed workers and use the
    description and execute the task. The final results are collected by the middleware
    and made available to the buyer after a payment is recorded on the blockchain.
    The last layer is a distributed cloud of miners. Notice here that we don’t need
    a master module because the middleware performs that function. The tasks are executed
    in containers or virtual machines and the results are reported back to the resource
    layer. This reduces the overall complexity of the network , as the only code running
    on host machines are the containers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在iEx.ec中，发生在外部或链外的任何操作都被称为贡献。例如，提供数据集、传输文件和执行计算都是需要在相关方之间进行代币交易的操作。我们如何知道操作是否确实正确地进行了？如何将特定的交易或一组交易与链外执行的特定操作相关联？需要一个新的协议来验证贡献是否发生以及哪些交易与之对应。iEx.ec提出了作为链外贡献的新共识机制的贡献证明。这种新机制还在使iEx.ec中的企业功能成为可能，被称为服务级别协议（SLA）。使用SLA可以跟踪资源利用情况，并允许客户向提供者下达受信任的计算资源订单。iEx.ec团队预测，在使用iEx.ec区块链的DApps中，向网络上的各方分发内容将是一个非常重要的功能。购买方将通过智能合约在区块链上获得对复杂数据集的访问，并获得运行其应用程序以及访问数据集的简单支付结构。通过贡献证明，iEx.ec可以保证内容提供者确实提供了对数据集的访问，并且在处理过程中文件是可访问的。为了支付目的，访问的持续时间也可以记录下来以保护购买方免受过度收费的影响。此外，iEx.ec还将采取几项针对声称文件传输失败的恶意实体的对策，以减少数据费用。iEx.ec的最初几个版本将集中
    consoli核心功能和一个需要HPC的金融交易用例。这项服务名为eFast，将使用复杂的计算预测方法，使小型投资者能够做出更好的交易决策。目标是使用不同股票的聚类分析创建多样化的投资组合，但这种分析的计算复杂性非常巨大，只有大型金融机构才能负担得起。像iEx.ec这样的去中心化服务可以将处理成本降低到传统计算农场的十分之一。请注意，Golem和iEx.ec在产品开发目标上有类似的目标，但在业务方法上有所不同。Golem的目标是构建网络的核心基础设施，并吸引HPC和云客户。另一方面，iEx.ec首先专注于构建将在网络上运行的DApps，以吸引对这些应用程序有需求且以更便宜的价格提供的常规云客户。任务如何分配和执行在iEx.ec上？有两种算法来管理这个过程，一个用于执行的匹配算法，另一个用于分配的调度器。让我们简要谈谈这两个算法。匹配算法在分布式系统中用于根据购买方提供的资源描述匹配资源提供者和潜在购买方。回想一下，在SONM中，这项任务由负载均衡器接管；然而，在iEx.ec中，一个算法执行资源配置。最终，开发人员建议将描述计算资源可用性和运行任务所需资源的智能合约存储在区块链上。这可以包括可用的RAM、处理器或CPU、磁盘空间和GPU类型等信息。对于主机，任务将部署到虚拟机实例或hypervisor，并且购买方将指定运行时指令。匹配算法可以实现更复杂的策略，而不仅仅是简单的一对一匹配，iEx.ec可以从更复杂的匹配中获利。有几种匹配算法的设计选择，但iEx.ec将使用一个称为ClassAd的语言，这在科学文献中已经经过了良好的测试。第二个算法是调度器，对于任何分布式计算系统来说都至关重要。网络的性能和可扩展性取决于其调度器的有效性。iEx.ec的设计挑战是创建一个启用多标准决策分析的调度器，它可以为每个任务选择最佳计算资源并适当安排以符合购买方的标准。多标准可能根据成本与性能基准来满足客户需求。一个客户可能希望在计算时间较长时最小化计算价格，而另一个客户可能希望最小化所需时间。这些是iEx.ec中调度器将处理的场景类型。一个多功能的调度器和高效的匹配算法允许在HPC的核心区块链技术上进行非常有趣的升级。一个显著的例子是能够使用特定领域的区块链（或侧链）。侧链是一个可适应的区块链，设计用于满足特定基础设施要求，以运行在广义环境中表现不佳的应用程序。这种区块链的目标是最大化性能，并最小化执行之间的任何时间延迟。通常，一个应用程序会通过标准的区块链进行；然而，如果提交了大量任务，一些任务可以被卸载到侧链进行跟踪。侧链将跟踪在主机上花费的时间，并将信息报
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at Ethereum tokens from the perspective of HPC applications.
    We first introduced the market utility and rationale behind introducing tokens
    as apps on Ethereum. Then, we discussed the prototype HPC token called ECM. This
    token performs all the basic functions that would be needed in a computational
    market where customers can purchase computational power from clusters run by dedicated
    buyers. The token allows for dispute resolution and on-chain verification in a
    transparent computational power market. We then delved into the more complex computational
    tokens, such as Golem and SONM. We described both in heavy detail, covering the
    major technical advancements and how those two tokens differ from each other.
    Finally, we concluded by covering iEx.ec, which is built on distributed cloud
    computing software that has been tested for years. The iEx.ec team implemented
    a decentralized version of Xtreme-Web HPC to perform the same task as Golem and
    SOMN and enable a computational market.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从 HPC 应用的角度看了以太坊代币。我们首先介绍了在以太坊上将代币作为应用的市场效用和理由。然后，我们讨论了原型 HPC 代币 ECM。该代币执行了在由专门买家运行的集群中客户可以购买计算能力的计算市场中所需的所有基本功能。该代币允许在透明的计算能力市场中进行争议解决和链上验证。然后，我们深入研究了更复杂的计算代币，如
    Golem 和 SONM。我们详细描述了这两者，涵盖了主要的技术进步以及这两个代币之间的区别。最后，我们总结了涉及 iEx.ec 的内容，该项目建立在经过多年测试的分布式云计算软件上。iEx.ec
    团队实现了 Xtreme-Web HPC 的分散版本，以执行与 Golem 和 SOMN 相同的任务并启用计算市场。
- en: References
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: The main references used to prepare this chapter were the ECM GitHub documentation,
    Golem whitepaper, SONM whitepaper, iEx.ex whitepaper and Fred Wilson's blog post
    on tokens.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编写本章的主要参考资料包括 ECM GitHub 文档、Golem 白皮书、SONM 白皮书、iEx.ex 白皮书以及 Fred Wilson 在代币上的博客文章。
