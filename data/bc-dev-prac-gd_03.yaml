- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_3](https://doi.org/10.1007/978-1-4842-4847-8_3)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Elad Elrom 2019 Elad Elrom The Blockchain Developer [https://doi.org/10.1007/978-1-4842-4847-8_3](https://doi.org/10.1007/978-1-4842-4847-8_3)
- en: 3. Creating Your Own Blockchain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 创建您自己的区块链
- en: 'Elad Elrom^([1](#Aff2) )(1)New York, NY, USAIn this chapter, I will cover how
    to build your very own blockchain P2P network. This is a seven-step process, so
    in each section I’ll start with a brief introduction followed by an exercise.
    You can download the code for each of the following exercises from GitHub and
    follow along:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Elad Elrom^(1)(1)New York, NY, USA在本章中，我将介绍如何构建您自己的区块链P2P网络。这是一个七个步骤的过程，因此在每个部分，我都会先简要介绍，然后进行一个练习。您可以从GitHub下载以下每个练习的代码并跟随进行：
- en: Creating a basic P2P network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本P2P网络
- en: Sending and receiving blocks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和接收块
- en: Registering miners and creating new blocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册矿工和创建新块
- en: Setting up a name-value database, LevelDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置名称-值数据库，LevelDB
- en: Creating a private-public wallet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建私钥-公钥钱包
- en: Using API services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API服务
- en: Creating a command-line interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令行界面
- en: This chapter will drill down into the code, and the examples in this chapter
    are simple in nature and intended for learning purposes. They will give you a
    better understanding of blockchain and the elements that are needed to achieve
    a fully working prototype of a blockchain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入代码，本章中的示例性质简单，旨在用于学习目的。它们将帮助您更好地理解区块链以及实现区块链的完全工作原型的所需元素。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not feasible to create a full production-grade blockchain in this short
    instructional chapter; however, I will give you the fundamentals for creating
    a basic working one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的教程章节中创建一个完整的生产级区块链是不切实际的；然而，我将为您提供创建基本工作区块链的基础知识。
- en: Creating a Basic P2P Network
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本P2P网络
- en: The first step in creating your blockchain is to create a P2P network. As you
    saw in previous chapters, the P2P network was the key to making blockchain work.
    In cryptocurrency the P2P network can help prevents the double spending issue
    for PoW and is also the core architecture behind PoS. In a blockchain, it allows
    you to sync any data needed on a network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建区块链的第一个步骤是创建一个P2P网络。正如您在之前的章节中看到的那样，P2P网络是使区块链工作的关键。在加密货币中，P2P网络可以帮助防止PoW的双重支付问题，也是PoS背后的核心架构。在区块链中，它允许您在网络上同步所需的数据。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Peer-to-peer (P2P) is a type of computer network that uses a distributed architecture.
    Each peer or node shares the workload and is equal to the other peers, meaning
    there should not be any privileged peer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点（P2P）是一种计算机网络类型，使用分布式架构。每个节点或同伴共享工作负载，与其他同伴平等，意味着不应有任何特权节点。
- en: '*“We have proposed a system for electronic transactions without relying on
    trust. We started with the usual framework of coins made from digital signatures,
    which provides strong control of ownership, but is incomplete without a way to
    prevent double-spending. To solve this, we proposed a peer-to-peer network using
    proof-of-work to record a public history of transactions that quickly becomes
    computationally impractical for an attacker to change if honest nodes control
    a majority of CPU proof-of-worker.”*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们提出了一种无需信任的电子交易系统。我们以由数字签名组成的硬币的通常框架开始，这提供了对所有权的强大控制，但如果没有防止双重支付的方法则是不完整的。为此，我们提出了一种使用工作量证明的点对点网络，以记录交易的公共历史，如果诚实的节点控制了大多数CPU证明-of-worker，则攻击者很快就会变得计算上不可行。”
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—*Bitcoin: A Peer-to-Peer Electronic Cash System*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —《比特币：一种点对点电子现金系统》
- en: In this chapter, I will show you how to create your blockchain with Node.js,
    but you can do this with any other programming language because the principles
    are the same. You will be setting up your machine with the WebStorm integrated
    development environment (IDE) that will be used throughout this book. To download
    WebStorm, go to [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)
    . WebStorm offers a 30-day trial; however, it’s not necessary, and you can choose
    any IDE of your liking and achieve the same results. At the time of writing, the
    WebStorm version is 2018.2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何使用Node.js创建您的区块链，但您可以使用任何其他编程语言来实现，因为原理是相同的。您将使用WebStorm集成开发环境（IDE）设置您的机器，该IDE将在本书中使用。要下载WebStorm，请访问
    [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/) 。WebStorm提供30天的试用版；然而，这不是必要的，您可以选择喜欢的任何IDE，并取得相同的结果。在撰写本文时，WebStorm版本是2018.2。
- en: 'Step 1: Basic P2P Network Exercise'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：基本P2P网络练习
- en: '**Setting Up Your Project**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置你的项目**'
- en: 'In this exercise, you will set up your project and create a basic P2P network
    to send and receive messages. After you are able to send and receive messages,
    you will be able to create a block class and a chained library and tie several
    blocks together to create a blockchain. You will need Node.js installed on your
    machine; there are many ways to install it. One easy way is through the prebuilt
    installer manager; find one that fits your platform here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    .'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将设置你的项目并创建一个基础的对等（P2P）网络以发送和接收消息。在你能够发送和接收消息之后，你将能够创建一个区块类和一个链式库，并将几个区块结合起来创建一个区块链。你的机器上需要安装Node.js；安装方式有很多。一种简单的方式是通过预构建的安装程序管理器；在这里找到适合你平台的安装程序：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)。
- en: After you have downloaded WebStorm, you can create a new project. Select File
    ➤ Create New Project ➤ Node.js Express App ➤ CREATE. In Location, call the project
    **Blockchain**, and click Create (see Figure [3-1](#Fig1)).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下载WebStorm后，你可以创建一个新项目。选择文件➤创建新项目➤Node.js Express App➤创建。在位置处，将项目命名为**区块链**，然后点击创建（见图[3-1](#Fig1)）。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig1_HTML.jpg)
- en: Figure 3-1
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1
- en: WebStorm  , creating a new project wizard
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm，创建新项目向导
- en: '**Creating a P2P Network**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建P2P网络**'
- en: 'Create a folder and name it **Blockchain**. Then create a file and name it
    p2p.js and write the following code. Alternatively, you could just clone the code
    from GitHub.https://github.com/Apress/the-blockchain-developer/blob/master/chapter2/step1/p2p.js>
    git clone https://github.com/Apress/the-blockchain-developer**Tip** You can clone
    the entire code listings in this book from GitHub. Use the following Terminal
    command: > git clone [https://​github.​com/​Apress/​the-blockchain-developer/​chapter3/​step1/​](https://github.com/Apress/the-blockchain-developer/chapter3/step1/)const
    crypto = require(''crypto''),    Swarm = require(''discovery-swarm''),    defaults
    = require(''dat-swarm-defaults''),    getPort = require(''get-port'');const peers
    = {};let connSeq = 0;let channel = ''myBlockchain'';const myPeerId = crypto.randomBytes(32);console.log(''myPeerId:
    '' + myPeerId.toString(''hex''));const config = defaults({    id: myPeerId,});const
    swarm = Swarm(config);(async () => {    const port = await getPort();    swarm.listen(port);    console.log(''Listening
    port: '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info)
    => {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }        conn.on(''data'', data => {            let
    message = JSON.parse(data);            console.log(''----------- Received Message
    start -------------'');            console.log(                ''from: '' + peerId.toString(''hex''),                ''to:
    '' + peerId.toString(message.to),                ''my: '' + myPeerId.toString(''hex''),                ''type:
    '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');        });        conn.on(''close'', ()
    => {            console.log(`Connection ${seq} closed, peerId: ${peerId}`);            if
    (peers[peerId].seq === seq) {                delete peers[peerId]            }        });        if
    (!peers[peerId]) {            peers[peerId] = {}        }        peers[peerId].conn
    = conn;        peers[peerId].seq = seq;        connSeq++    })})();setTimeout(function(){    writeMessageToPeers(''hello'',
    null);}, 10000);writeMessageToPeers = (type, data) => {    for (let id in peers)
    {        console.log(''-------- writeMessageToPeers start -------- '');        console.log(''type:
    '' + type + '', to: '' + id);        console.log(''-------- writeMessageToPeers
    end ----------- '');        sendMessage(id, type, data);    }};writeMessageToPeerToId
    = (toId, type, data) => {    for (let id in peers) {        if (id === toId) {            console.log(''--------
    writeMessageToPeerToId start -------- '');            console.log(''type: '' +
    type + '', to: '' + toId);            console.log(''-------- writeMessageToPeerToId
    end ----------- '');            sendMessage(id, type, data);        }    }};sendMessage
    = (id, type, data) => {    peers[id].conn.write(JSON.stringify(        {            to:
    id,            from: myPeerId,            type: type,            data: data        }    ));};Listing
    3-1'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个名为**区块链**的文件夹。然后创建一个名为p2p.js的文件，并写入以下代码。或者，你也可以直接从GitHub克隆代码。<https://github.com/Apress/the-blockchain-developer/blob/master/chapter2/step1/p2p.js>git
    clone <https://github.com/Apress/the-blockchain-developer/chapter3/step1/>const
    crypto = require(''crypto''),    Swarm = require(''discovery-swarm''),    defaults
    = require(''dat-swarm-defaults''),    getPort = require(''get-port'');const peers
    = {};let connSeq = 0;let channel = ''myBlockchain'';const myPeerId = crypto.randomBytes(32);console.log(''myPeerId:
    '' + myPeerId.toString(''hex''));const config = defaults({        id: myPeerId,});const
    swarm = Swarm(config);(async () => {    const port = await getPort();    swarm.listen(port);    console.log(''Listening
    port: '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info)
    => {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }        conn.on(''data'', data => {            let
    message = JSON.parse(data);            console.log(''----------- Received Message
    start -------------'');            console.log(                ''from: '' + peerId.toString(''hex''),                ''to:
    '' + peerId.toString(message.to),                ''my: '' + myPeerId.toString(''hex''),                ''type:
    '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');        });        conn.on(''close'', ()
    => {            console.log(`Connection ${seq} closed, peerId: ${peerId}`);            if
    (peers[peerId].seq === seq) {                delete peers[peerId]            }        });        if
    (!peers[peerId]) {            peers[peerId] = {}        }        peers[peerId].conn
    = conn;        peers[peerId].seq = seq;        connSeq++    })})();setTimeout(function(){    writeMessageToPeers(''hello'',
    null);}, 10000);writeMessageToPeers = (type, data) => {    for (let id in peers)
    {        console.log(''-------- writeMessageToPeers start -------- '');        console.log(''type:
    '' + type + '', to: '' + id);        console.log(''-------- writeMessageToPeers
    end ----------- '');        sendMessage(id, type, data);    }};writeMessageToPeerToId
    = (toId, type, data) => {    for (let id in peers) {        if (id === toId) {            console.log(''--------
    writeMessageToPeerToId start -------- '');            console.log(''type: '' +
    type + '', to: '' + toId);            console.log(''-------- writeMessageToPeerToId
    end ----------- '');            sendMessage(id, type, data);        }    }};sendMessage
    = (id, type, data) => {    peers[id].conn.write(JSON.stringify(        {            to:
    id,            from: myPeerId,            type: type,            data: data        }));};Listing
    3-1'
- en: Shows Node.js P2P Network initial code to send and receive messages
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了Node.js P2P网络初始代码以发送和接收消息
- en: To get this example to work, you need to run two instances of this code. You
    can run it from two separate machines as would be done in real life, or you could
    run two instances from the same machine via Terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子运行，你需要运行这个代码的两个实例。你可以从两台不同的机器上运行，就像现实生活中那样，或者你可以在同一台机器上通过终端运行两个实例。
- en: 'Your code needs to find and connect peers, deploy servers that are used to
    discover other peers, and get an available TCP port. That is done by utilizing
    these three libraries:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码需要找到并连接对等体，部署用于发现其他对等体的服务器，并获取一个可用的TCP端口。这是通过使用这三个库来完成的：
- en: '**discovery-swarm**: Used to create a network swarm that uses discovery-channel
    to find and connect peers'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**discovery-swarm**：用于创建一个网络蜂群，该蜂群使用发现通道来找到并连接对等体'
- en: '**dat-swarm-defaults**: Deploys servers that are used to discover other peers'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dat-swarm-defaults**：部署用于发现其他对等体的服务器'
- en: '**get-port**: Gets available TCP ports'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-port**：获取可用的TCP端口'
- en: To install these libraries, run this command:> npm install crypto discovery-swarm
    dat-swarm-defaults get-port --saveNow that are libraries are installed, open two
    Terminal instances and navigate to the location of the library. Run the following
    command:> node p2p.jsTo run the code from the clone library on GitHub, navigate
    to the code, follow these Terminal commands to install the libraries, and run
    a node.js instance attaching our p2p.js code:> cd [location]/chapter2/step2> npm
    install> node p2p.jsFigure [3-2](#Fig2) shows the output of running the Node.js
    code.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些库，运行这个命令：> npm install crypto discovery-swarm dat-swarm-defaults get-port
    --save现在这些库已经安装好了，打开两个终端实例，导航到库的位置。运行以下命令：> node p2p.js要从GitHub上的克隆库运行代码，导航到代码，按照这些终端命令来安装库，并运行一个node.js实例，附上我们的p2p.js代码：>
    cd [位置]/chapter2/step2> npm install> node p2p.js图[3-2](#Fig2)显示了运行Node.js代码的输出。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig2_HTML.jpg)
- en: Figure 3-2
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2
- en: P2P running two peers in Terminal
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行两个对等体
- en: As you can see in Figure [3-2](#Fig2), the network generated a random peer ID
    for your machine and picked a random port utilizing the discovery libraries you
    installed. Then the code was able to discover other peers on the network and send
    and receive messages to and from these peers. You are now connected on a P2P network
    with other users.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图[3-2](#Fig2)中所看到的，网络为你的机器生成了一个随机的对等体ID，并利用你安装的发现库随机选择了一个端口。然后代码能够发现网络上的其他对等体，并与其他对等体发送和接收消息。你现在与其他用户连接在P2P网络上。
- en: Let’s walk through the code to better understand how it all works. The first
    lines of code are an import statement  for the open source libraries that you
    are using in your code.  const crypto = require('crypto'),    Swarm = require('discovery-swarm'),    defaults
    = require('dat-swarm-defaults'),    getPort = require('get-port');
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来更好地理解它是如何工作的。代码的第一行是导入你将在代码中使用的开源库的声明。const crypto = require('crypto'),
    Swarm = require('discovery-swarm'), defaults = require('dat-swarm-defaults'),
    getPort = require('get-port');
- en: Notice that you use const to set your variable instead of let. You want to ensure
    there is no rebinding, and you always refer to the same object, so selecting const
    is advised according to best practices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你使用const来设置你的变量，而不是let。你希望确保没有重新绑定，并且总是引用同一个对象，所以根据最佳实践建议选择const。
- en: 'Next, you set your variables to hold an object with the peers and connection
    sequence, and you choose a channel name that all your nodes will be connecting
    to. You also set a randomly generated peer ID for your peer utilizing the crypto
    library.const peers = {};let connSeq = 0;let channel = ''myBlockchain'';const
    myPeerId = crypto.randomBytes(32);console.log(''myPeerId: '' + myPeerId.toString(''hex''));Next,
    you generate a config object that holds your peer ID. Then you use the config
    object to initialize the swarm library. The swarm library can be found here: [https://github.com/mafintosh/discovery-swarm](https://github.com/mafintosh/discovery-swarm)
    . What it does is create a network swarm that uses the discovery-channel library
    to find and connect peers on a UCP/TCP network.const config = defaults({    id:
    myPeerId,});const swarm = Swarm(config);Now that everything is set up and ready,
    you will be creating a Node.js async function to continuously monitor swarm.on
    event messages.(async () => {You listen on the random port selected, and once
    a connection is made to the peer, you use setKeepAlive to ensure the network connection
    stays with other peers.    const port = await getPort();    swarm.listen(port);    console.log(''Listening
    port: '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info)
    => {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }Once you receive a data message on the P2P network,
    you parse the data using JSON.parse, which is a Node.js native command, so you
    do not need to include any import statement. This command decodes your message
    back into an object, and the toString command  converts bytes into a readable
    string data type.        conn.on(''data'', data => {            let message =
    JSON.parse(data);            console.log(''----------- Received Message start
    -------------'');            console.log(                ''from: '' + peerId.toString(''hex''),                ''to:
    '' + peerId.toString(message.to),                ''my: '' + myPeerId.toString(''hex''),                ''type:
    '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');        });You also listen to a close event  ,
    which will indicate that you lost a connection with peers, so you can take action,
    such as delete the peers from your peers list object.        conn.on(''close'',
    () => {            console.log(`Connection ${seq} closed, peerId: ${peerId}`);            if
    (peers[peerId].seq === seq) {                delete peers[peerId]            }        });        if
    (!peers[peerId]) {            peers[peerId] = {}        }        peers[peerId].conn
    = conn;        peers[peerId].seq = seq;        connSeq++    })})();Here, you will
    be using a setTimeout Node.js native function to send a message after ten seconds
    to any available peers. The first message you will be sending is just an “hello”
    message. You create methods called writeMessageToPeers  and writeMessageToPeerToId
    to handle your object, so it’s formatted with the data you want to transmit and
    who you want to send it to.setTimeout(function(){    writeMessageToPeers(''hello'',
    null);}, 10000);The writeMessageToPeers method  will be sending messages to all
    the connected peers.writeMessageToPeers = (type, data) => {    for (let id in
    peers) {        console.log(''-------- writeMessageToPeers start -------- '');        console.log(''type:
    '' + type + '', to: '' + id);        console.log(''-------- writeMessageToPeers
    end ----------- '');        sendMessage(id, type, data);    }};Additionally, you
    will be creating another method, writeMessageToPeerToId, that will be sending
    the message to a specific peer ID, in case you want to communicate with just one
    specific peer.writeMessageToPeerToId = (toId, type, data) => {    for (let id
    in peers) {        if (id === toId) {            console.log(''-------- writeMessageToPeerToId
    start -------- '');            console.log(''type: '' + type + '', to: '' + toId);            console.log(''--------
    writeMessageToPeerToId end ----------- '');            sendMessage(id, type, data);        }    }};Lastly,
    sendMessage is a generic method that you will be using to send a message formatted
    with the params you would like to pass and includes the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，你需要设置变量以保存包含对等节点和连接序列的对象，并选择一个所有节点都将连接到的通道名称。你还利用加密库为你的对等节点生成一个随机生成的对等ID。const
    peers = {};let connSeq = 0;let channel = ''myBlockchain'';const myPeerId = crypto.randomBytes(32);console.log(''myPeerId:
    '' + myPeerId.toString(''hex''));接下来，你需要生成一个包含你的对等ID的配置对象。然后你使用这个配置对象来初始化蜂群库。蜂群库可以在这里找到：[https://github.com/mafintosh/discovery-swarm](https://github.com/mafintosh/discovery-swarm)
    。它的作用是创建一个网络蜂群，使用发现通道库在UCP/TCP网络上查找并连接对等节点。const config = defaults({    id: myPeerId,});const
    swarm = Swarm(config);现在一切设置就绪，你将创建一个Node.js异步函数，以持续监控蜂群.on事件消息。(async () => {你监听随机选定的端口，一旦与对等节点建立连接，你使用setKeepAlive确保网络连接与其他对等节点保持在一起。    const
    port = await getPort();    swarm.listen(port);    console.log(''Listening port:
    '' + port);    swarm.join(channel);    swarm.on(''connection'', (conn, info) =>
    {        const seq = connSeq;        const peerId = info.id.toString(''hex'');        console.log(`Connected
    #${seq} to peer: ${peerId}`);        if (info.initiator) {            try {                conn.setKeepAlive(true,
    600);            } catch (exception) {                console.log(''exception'',
    exception);            }        }一旦你在P2P网络上接收到数据消息，你使用JSON.parse解析数据，这是一个Node.js本地命令，所以你不需要包含任何导入声明。这个命令将你的消息解码回一个对象，而toString命令将字节转换为可读的字符串数据类型。        conn.on(''data'',
    data => {            let message = JSON.parse(data);            console.log(''-----------
    Received Message start -------------'');            console.log(                ''from:
    '' + peerId.toString(''hex''),                ''to: '' + peerId.toString(message.to),                ''my:
    '' + myPeerId.toString(''hex''),                ''type: '' + JSON.stringify(message.type)            );            console.log(''-----------
    Received Message end -------------'');'
- en: '**to/from**: The peer ID you are sending the message from and to'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送/接收方**：你发送消息的和对端点ID'
- en: '**type**: The message type'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：消息类型'
- en: '**data**: Any data you would like to share on the P2P network'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：您希望在P2P网络上分享的任何数据'
- en: 'These params will be useful once you share your blockchain block. Notice that
    the message you pass needs to be a string and cannot be an object, so you are
    using a JSON.stringify native function to encode your messages before sharing
    them over the P2P network.sendMessage = (id, type, data) => {    peers[id].conn.write(JSON.stringify(        {            to:
    id,            from: myPeerId,            type: type,            data: data        }    ));};'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数在你分享你的区块链区块时会很有用。请注意，你传递的信息需要是一个字符串，不能是一个对象，所以你在通过P2P网络分享之前，使用JSON.stringify本地函数来编码你的消息。
- en: In this exercise, you downloaded and installed the WebStorm IDE and created
    your project, which includes a basic P2P network. You were able to keep a connection
    to a TCP network random port and send and receive messages including encoding
    and decoding these messages. You are ready to move to the next exercise and send
    an actual block between each node on your network.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你下载并安装了WebStorm IDE，并创建了你的项目，其中包括一个基础的P2P网络。你能够保持对TCP网络随机端口的连接，并发送和接收消息，包括对这些消息的编码和解码。你现在可以进入下一个练习，并在你的网络上的每个节点之间发送一个实际的区块。
- en: Creating Genesis Block and Sharing Blocks
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建创世区块和分享区块
- en: In the next exercise, you will be creating block objects that you can share
    between your nodes. But before you do that, let’s take a closer look at the Block
    object. The Block object is not the same for every blockchain. Different blockchains
    utilize different types of Block objects; you will be using a Block object similar
    to bitcoin; I covered in details during Chapter [2](475651_1_En_2_Chapter.xhtml).
    To better understand the architecture, take a look at a Unified Modeling Language
    (UML) diagram of the Block and the BlockHeader objects you will be using in the
    next exercise, as shown in Figure [3-3](#Fig3).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将创建可以在你节点之间分享的区块对象。但在你这样做之前，让我们更仔细地看看区块对象。不同的区块链使用不同类型的区块对象；你将使用与比特币相似的区块对象；我在第[2](475651_1_En_2_Chapter.xhtml)章中详细介绍了它。为了更好地理解架构，请查看下一练习中将使用的区块和区块头对象的统一建模语言（UML）图，如图[3-3](#Fig3)所示！[../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig3_HTML.jpg)
- en: Figure 3-3
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3
- en: Block and BlockHeader UML diagram
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 区块和区块头UML图
- en: 'As a reminder, from Chapter [2](475651_1_En_2_Chapter.xhtml), the Block object
    contains the following properties:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，从第[2](475651_1_En_2_Chapter.xhtml)章起，区块对象包含以下属性：
- en: '***index***: GenesisBlock is our first block, we assign the block index with
    the value of 0.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：创世区块是我们的第一个区块，我们将区块索引值设定为0。'
- en: '***txns***: This is the raw transaction in the block. I don’t want to focus
    on just cryptocurrencies in this chapter, so think of this as any type of data
    you want to store.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***交易***：区块中的原始交易。在本章中，我不想只关注加密货币，所以将其视为您想要存储的任何类型的数据。'
- en: 'Included in the Block object is the BlockHeader object, which contains the
    following properties:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 区块对象中包含区块头对象，该对象包含以下属性：
- en: '***Version***: At the time of writing, there are four block versions. Version
    1 is the genesis block (2009), and version 2 is a soft fork of bitcoin core 0.7.0
    (2012). Version 3 blocks were a soft fork of bitcoin core 0.10.0 (2015). Version
    4 blocks are BIP65 in bitcoin core 0.11.2 (2015).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：在撰写本文时，共有四个区块版本。版本1是创世区块（2009年），版本2是比特币核心0.7.0的软分叉（2012年）。版本3区块是比特币核心0.10.0的软分叉（2015年）。版本4区块是比特币核心0.11.2中的BIP65。'
- en: '***Previous block header hash***: This is an SHA-256 (Secure Hash Algorithm)
    hash function of the previous block’s header. It ensures that the previous block
    cannot be changed as this block needs to be changed as well.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***前一个区块头哈希**：这是前一个区块头的SHA-256（安全哈希算法）哈希函数。它确保前一个区块无法更改，因为此区块需要更改。'
- en: '***Merkle root hash***: A Merkle tree is a binary tree that holds all the hashed
    pairs of the tree.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Merkle根哈希**：Merkle树是一个二叉树，包含树中所有哈希对的哈希值。'
- en: '***Time***: This is the Unix epoch time when the miner started hashing the
    header.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***时间**：矿工开始哈希头部时的Unix纪元时间。'
- en: As you recall, bitcoin also includes a difficulty property for the miners that
    gets recalculated every 2,016 blocks. Here you won’t use the nBits and nounce
    params, as you are not doing PoW.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所回忆的，比特币还包含一个矿工的难度属性，每2016个块重新计算一次。在这里，你不会使用nBits和nounce参数，因为你没有做PoW。
- en: '***nounce***: The nonce in a bitcoin block is a 32-bit (4-byte) field whose
    value is adjusted by miners so that the hash of the block will be less than or
    equal to the current target of the network.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***nounce***：比特币块中的nonce是一个32位（4字节）的字段，其值由矿工调整，以便块的哈希值小于或等于网络当前的目标。'
- en: '***nBits***: This refers to the target. The target is a 256-bit number and
    inversely proportional to the difficulty. It is recalculated every 2,016 blocks.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***nBits***：这指的是目标。目标是一个256位的数字，与难度成反比。每2016个块重新计算一次。'
- en: In terms of P2P communication, the flow of blocks between each peer on the P2P
    network consists of requesting the latest block from a peer on the network and
    then receiving a block request. Figure [3-4](#Fig4) shows the flow diagram.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就P2P通信而言，P2P网络中每个对等体之间的块流动包括从网络上的一个对等体请求最新的块，然后接收一个块请求。图[3-4](#Fig4)显示了流程图。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig4_HTML.jpg)
- en: Figure 3-4
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4
- en: Flow diagram of P2P communications requesting latest block and receiving latest
    block
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: P2P通信请求最新块和接收最新块的流程图
- en: Now that you understand the architecture and the flow of blocks in the P2P network,
    in the following exercise you will be sending and requesting blocks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了架构以及P2P网络中块的流动，在接下来的练习中，你将发送和请求块。
- en: 'Step 2: P2P Network Sending Blocks Exercise'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：P2P网络发送块练习
- en: '**Setting** **Up a** **Block Class and Chain Library**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置** **块类和链库**'
- en: 'In this exercise, you will create your blockchain. The blockchain consists
    of two files: block.js and chain.js. The file Block.js will hold the block class
    object, and chain.js will be the glue with methods to handle the interactions
    with the blocks. In terms of the Block object, you will be creating properties
    similar to the properties that bitcoin core holds. Take a look at Listing [3-2](#PC17),
    block.js file include Block and BlockHeader objects.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建你自己的区块链。区块链由两个文件组成：block.js和chain.js。文件Block.js将包含块类对象，而chain.js将是处理与块交互的方法的粘合剂。就块对象而言，你将创建与比特币核心类似的属性。查看列表[3-2](#PC17)，block.js文件包括Block和BlockHeader对象。
- en: '*Listing 3-2. block.js*exports.BlockHeader = class BlockHeader {    constructor(version,
    previousBlockHeader, merkleRoot, time) {        this.version = version;        this.previousBlockHeader
    = previousBlockHeader;        this.merkleRoot = merkleRoot;        this.time =
    time;    }};exports.Block = class Block {    constructor(blockHeader, index, txns)
    {        this.blockHeader = blockHeader;        this.index = index;        this.txns
    = txns;    }}As you can see, chain.js contains the first block, which is called
    the *genesis* block, as well as a method to receive the entire blockchain object,
    add a block, and retrieve a block. Note that you will be adding a library called
    moment  to save the time in a Unix time format in your chain.js library. To do
    so, install moment with npm.> npm install moment --save'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3-2。 block.js*exports.BlockHeader = class BlockHeader {    constructor(version,
    previousBlockHeader, merkleRoot, time) {        this.version = version;        this.previousBlockHeader
    = previousBlockHeader;        this.merkleRoot = merkleRoot;        this.time =
    time;    }};exports.Block = class Block {    constructor(blockHeader, index, txns)
    {        this.blockHeader = blockHeader;        this.index = index;        this.txns
    = txns;    }}如你所见，chain.js包含第一个块，称为*创世块*，以及接收整个区块链对象、添加块和检索块的方法。注意你将在chain.js库中添加一个名为moment的库，以保存时间以Unix时间格式。为此，使用npm安装moment。>
    npm install moment --save
- en: Now that you have the block.js file created, you can create the chain.js class;
    see Listing [3-3](#PC19).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了block.js文件，你可以创建chain.js类；参见列表[3-3](#PC19)。
- en: '*Listing 3-3. chain.js*let Block =  require("./block.js").Block,    BlockHeader
    =  require("./block.js").BlockHeader,    moment = require("moment");let getGenesisBlock
    = () => {    let blockHeader = new BlockHeader(1, null, "0x1bc3300000000000000000000000000000000000000000000",
    moment().unix());    return new Block(blockHeader, 0, null);};let getLatestBlock
    = () => blockchain[blockchain.length-1];let addBlock = (newBlock) => {    let
    prevBlock = getLatestBlock();    if (prevBlock.index < newBlock.index && newBlock.blockHeader.previousBlockHeader
    === prevBlock.blockHeader.merkleRoot) {        blockchain.push(newBlock);    }}let
    getBlock = (index) => {    if (blockchain.length-1 >= index)        return blockchain[index];    else        return
    null;}const blockchain = [getGenesisBlock()];if (typeof exports != ''undefined''
    ) {    exports.addBlock = addBlock;    exports.getBlock = getBlock;    exports.blockchain
    = blockchain;    exports.getLatestBlock = getLatestBlock;}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*Listing 3-3. chain.js*的翻译：let Block = require("./block.js").Block, BlockHeader
    = require("./block.js").BlockHeader, moment = require("moment");let getGenesisBlock
    = () => {    let blockHeader = new BlockHeader(1, null, "0x1bc3300000000000000000000000000000000000000000000",
    moment().unix());    return new Block(blockHeader, 0, null);};let getLatestBlock
    = () => blockchain[blockchain.length-1];let addBlock = (newBlock) => {    let
    prevBlock = getLatestBlock();    if (prevBlock.index < newBlock.index && newBlock.blockHeader.previousBlockHeader
    === prevBlock.blockHeader.merkleRoot) {        blockchain.push(newBlock);    }}let
    getBlock = (index) => {    if (blockchain.length-1 >= index)        return blockchain[index];    else        return
    null;}const blockchain = [getGenesisBlock()];if (typeof exports != 'undefined'
    ) {    exports.addBlock = addBlock;    exports.getBlock = getBlock;    exports.blockchain
    = blockchain;    exports.getLatestBlock = getLatestBlock;}
- en: You now have a block object that is included in chain.js. Your library can create
    your genesis block and add a block to your blockchain object. You also will be
    able to send and request blocks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个包含在chain.js中的区块对象。您的库可以创建创世区块并将区块添加到区块链对象中。您还将能够发送和请求区块。
- en: 'Next, in your P2P network class, you can use the chain.js file you created.
    First you need to import the class chain.js.const chain =  require("./chain");Then
    you can define a message type to request and receive the latest block. When you
    send messages in your P2P network, you need to be able to figure out the purpose
    of messages. By using a MessageType property  , you can define a switch mechanism
    so different messages types will be used for different functions.let MessageType
    = {    REQUEST_LATEST_BLOCK: ''requestLatestBlock'',    LATEST_BLOCK: ''latestBlock''};Once
    a connection data event message is received, you can create your switch code to
    handle the different types of requests, as shown in Listing [3-4](#PC22).switch
    (message.type) {    case MessageType.REQUEST_BLOCK:        console.log(''-----------REQUEST_BLOCK-------------'');        let
    requestedIndex = (JSON.parse(JSON.stringify(message.data))).index;        let
    requestedBlock = chain.getBlock(requestedIndex);        if (requestedBlock)        writeMessageToPeerToId(peerId.toString(''hex''),
    MessageType.RECEIVE_NEXT_BLOCK, requestedBlock);        else            console.log(''No
    block found @ index: '' + requestedIndex);        console.log(''-----------REQUEST_BLOCK-------------'');        break;    case
    MessageType.RECEIVE_NEXT_BLOCK:        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        chain.addBlock(JSON.parse(JSON.stringify(message.data)));        console.log(JSON.stringify(chain.blockchain));        let
    nextBlockIndex = chain.getLatestBlock().index+1;        console.log(''-- request
    next block @ index: '' + nextBlockIndex);        writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: nextBlockIndex});        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        break;}Listing
    3-4'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '在您的P2P网络课程中，您可以使用您创建的chain.js文件。首先，您需要导入chain.js类。const chain = require("./chain");然后，您可以定义一种消息类型来请求和接收最新的区块。当您在P2P网络中发送消息时，您需要能够弄清楚消息的目的。通过使用MessageType属性，您可以定义一个切换机制，以便不同的消息类型用于不同的功能。let
    MessageType = {    REQUEST_LATEST_BLOCK: ''requestLatestBlock'',    LATEST_BLOCK:
    ''latestBlock''};一旦收到连接数据事件消息，您就可以创建一个switch代码来处理不同类型的请求，如列表[3-4](#PC22)所示。switch
    (message.type) {    case MessageType.REQUEST_BLOCK:        console.log(''-----------REQUEST_BLOCK-------------'');        let
    requestedIndex = (JSON.parse(JSON.stringify(message.data))).index;        let
    requestedBlock = chain.getBlock(requestedIndex);        if (requestedBlock)        writeMessageToPeerToId(peerId.toString(''hex''),
    MessageType.RECEIVE_NEXT_BLOCK, requestedBlock);        else        console.log(''No
    block found @ index: '' + requestedIndex);        console.log(''-----------REQUEST_BLOCK-------------'');        break;    case
    MessageType.RECEIVE_NEXT_BLOCK:        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        chain.addBlock(JSON.parse(JSON.stringify(message.data)));        console.log(JSON.stringify(chain.blockchain));        let
    nextBlockIndex = chain.getLatestBlock().index+1;        console.log(''-- request
    next block @ index: '' + nextBlockIndex);        writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: nextBlockIndex});        console.log(''-----------RECEIVE_NEXT_BLOCK-------------'');        break;}Listing
    3-4'
- en: Message Switch and Handlers
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 消息切换和处理
- en: 'Lastly, you will set a timeout request that will send a request to retrieve
    the latest block every 5,000 milliseconds (5 seconds).setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: chain.getLatestBlock().index+1});}, 5000);'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，你将设置一个超时请求，每5000毫秒（5秒）发送一个请求以获取最新块。setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_BLOCK,
    {index: chain.getLatestBlock().index+1});}, 5000);'
- en: 'You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/)
    .'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载完整的练习：[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step2/)
    。
- en: In this exercise, you were able to generate your genesis block and create a
    mechanism to request and receive blocks by sending messages requests. The ability
    to request and receive blocks allows you to sync new peers that enter the P2P
    network. You also need a sync for any additional blocks you generate after the
    genesis block creation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，你能够生成你的创世块并创建一个通过发送消息请求来请求和接收块的机制。请求和接收块的能力使你能够同步进入P2P网络的新同伴。你在创世块创建后还需要一个同步，以同步你生成的任何额外块。
- en: Registering Miners and Creating New Blocks
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册矿工和创建新块
- en: At this point, you have a basic P2P network, and you are able to connect peers
    in the network, create a genesis block, and send and receive blocks. The next
    step is being able to generate new blocks. As you saw in Chapter [2](475651_1_En_2_Chapter.xhtml),
    proof of work is based on creating a mathematical problem and rewarding miners
    that find the solution for the problem first. However, in this example, you will
    take an approach of proof of stake (PoS)  where you trust each miner to generate
    your blocks. Each peer will register as a miner and will take a turn to mine a
    block. You can see an overview of each miner generating a block in Figure [3-5](#Fig5).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你已经有一个基本的P2P网络，你能够连接网络中的同伴，创建创世块，发送和接收块。下一步是能够生成新块。正如你在第[2](475651_1_En_2_Chapter.xhtml)章所见，工作量证明是基于创建一个数学问题，并奖励首先找到问题解决方案的矿工。然而，在这个例子中，你将采取一种权益证明（PoS）的方法，你信任每个矿工来生成你的块。每个同伴将注册为矿工，并将轮流挖出块。你可以在图[3-5](#Fig5)中看到每个矿工生成块的概述。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig5_HTML.jpg)
- en: Figure 3-5
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5
- en: Your blockchain handles mining using a simple PoS mechanism
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你的区块链使用简单的权益证明（PoS）机制来处理挖矿
- en: Lastly, before you start your next exercise, revisit Figure [3-4](#Fig4) to
    better understand your flow. The flow shows how your P2P network handles peer
    communications requesting the latest block and receiving the latest block. In
    the next exercise, you will register your peers as miners and create new blocks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在你开始下一个练习之前，回顾图[3-4](#Fig4)，以更好地理解你的流程。流程显示了你的P2P网络如何处理 peer 通信，请求最新块并接收最新块。在下一个练习中，你将注册你的同伴作为矿工并创建新块。
- en: 'Step 3: Register Miners and Creating New Blocks Exercise'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：注册矿工和创建新块练习
- en: '**Register Miners**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册矿工**'
- en: 'In this exercise, you will register miners and create new blocks. You can download
    the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3)
    .'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，你将注册矿工并创建新块。你可以从这里下载完整的练习：[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step3)
    。
- en: To automate the process of generating a block every x number of minutes, you
    can use a Node.js library called cron, which is similar to the Linux library that
    automates tasks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化每x分钟生成一个块的过程，你可以使用一个名为cron的Node.js库，它类似于Linux库，用于自动化任务。
- en: To install the cron open source library, run the following command:> npm install
    cron --saveNext, in your p2p.js file, you will create two variables to keep track
    of the registered miners as well as who mined the last block so you can assign
    the next block to the next miner.let registeredMiners = [];let lastBlockMinedBy
    = null;You are also going to add two messages types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装cron开源库，请运行以下命令：> npm install cron --save接下来，在你的p2p.js文件中，你将创建两个变量来跟踪注册的矿工以及谁挖出了最后一个块，以便你可以将下一个块分配给下一个矿工。let
    registeredMiners = [];let lastBlockMinedBy = null;你还将添加两种消息类型。
- en: REQUEST_ALL_REGISTER_MINERS
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REQUEST_ALL_REGISTER_MINERS
- en: REGISTER_MINER
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REGISTER_MINER
- en: 'let MessageType = {    REQUEST_BLOCK: ''requestBlock'',    RECEIVE_NEXT_BLOCK:
    ''receiveNextBlock'',    RECEIVE_NEW_BLOCK: ''receiveNewBlock'',    REQUEST_ALL_REGISTER_MINERS:
    ''requestAllRegisterMiners'',    REGISTER_MINER: ''registerMiner''};Before you
    register your peers as miners, you will request to receive all the existing registered
    miners in the network, and then you will add your peer as a miner in a registeredMiners
    object. You do that by running a timer to update your miners every five seconds.setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_ALL_REGISTER_MINERS,
    null);}, 5000);Now, that have an automated timeout command that can point to a
    handler to update the list of registered miners you can also automate a command
    to register your peer as a miner;setTimeout(function(){    registeredMiners.push(myPeerId.toString(''hex''));    console.log(''----------Register
    my miner --------------'');    console.log(registeredMiners);    writeMessageToPeers(MessageType.REGISTER_MINER,
    registeredMiners);    console.log(''---------- Register my miner --------------'');},
    7000);In your switch command, you want to modify the code to be able to set handlers
    for incoming messages regarding the registrations of miners. You want to keep
    track of the registered miners as well as handle a message once a new block is
    mined. See Listing [3-5](#PC28) for the miner’s handlers.case MessageType.REQUEST_ALL_REGISTER_MINERS:        console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);        writeMessageToPeers(MessageType.REGISTER_MINER, registeredMiners);        registeredMiners
    = JSON.parse(JSON.stringify(message.data));        console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);        break;    case MessageType.REGISTER_MINER:        console.log(''-----------REGISTER_MINER-------------
    '' + message.to);        let miners = JSON.stringify(message.data);        registeredMiners
    = JSON.parse(miners);        console.log(registeredMiners);        console.log(''-----------REGISTER_MINER-------------
    '' + message.to);        break;Listing 3-5'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '定义MessageType对象，包含以下键值对：REQUEST_BLOCK: ''requestBlock''，RECEIVE_NEXT_BLOCK:
    ''receiveNextBlock''，RECEIVE_NEW_BLOCK: ''receiveNewBlock''，REQUEST_ALL_REGISTER_MINERS:
    ''requestAllRegisterMiners''，REGISTER_MINER: ''registerMiner''；在注册自己的矿工之前，你需要请求获取网络中所有已注册的矿工信息，然后将在注册的矿工对象中添加自己的矿工信息。你可以通过运行一个定时器，每五秒更新一次你的矿工信息。setTimeout(function(){writeMessageToPeers(MessageType.REQUEST_ALL_REGISTER_MINERS,
    null);}, 5000);现在，你有一个自动超时的命令，可以指向一个处理器来更新注册矿工的列表，你也可以自动化一个命令将你的矿工信息注册到系统中；setTimeout(function(){registeredMiners.push(myPeerId.toString(''hex''));console.log(''----------Register
    my miner --------------'');console.log(registeredMiners);writeMessageToPeers(MessageType.REGISTER_MINER,
    registeredMiners);console.log(''---------- Register my miner --------------'');},
    7000);在你的switch命令中，你希望修改代码，以便能够为矿工注册的消息设置处理器。你希望跟踪已注册的矿工，以及处理新区块挖出后的消息。参见列表[3-5](#PC28)中的矿工处理器。case
    MessageType.REQUEST_ALL_REGISTER_MINERS:console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);writeMessageToPeers(MessageType.REGISTER_MINER, registeredMiners);registeredMiners
    = JSON.parse(JSON.stringify(message.data));console.log(''-----------REQUEST_ALL_REGISTER_MINERS-------------
    '' + message.to);break;case MessageType.REGISTER_MINER:console.log(''-----------REGISTER_MINER-------------
    '' + message.to);let miners = JSON.stringify(message.data);registeredMiners =
    JSON.parse(miners);console.log(registeredMiners);console.log(''-----------REGISTER_MINER-------------
    '' + message.to);break;Listing 3-5'
- en: Miner’s Handlers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工处理器
- en: '**Unregister Miners**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注销矿工**'
- en: 'You also need to unregister a miner once a connection with the miner is closed
    or lost.    console.log(`Connection ${seq} closed, peerId: ${peerId}`);    if
    (peers[peerId].seq === seq) {        delete peers[peerId];        console.log(''---
    registeredMiners before: '' + JSON.stringify(registeredMiners));        let index
    = registeredMiners.indexOf(peerId);        if (index > -1)            registeredMiners.splice(index,
    1);        console.log(''--- registeredMiners end: '' + JSON.stringify(registeredMiners));    }});'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '当与矿工的连接关闭或丢失时，你还需要注销矿工。console.log(`Connection ${seq} closed, peerId: ${peerId}`);if
    (peers[peerId].seq === seq) {delete peers[peerId];console.log(''--- registeredMiners
    before: '' + JSON.stringify(registeredMiners));let index = registeredMiners.indexOf(peerId);if
    (index > -1)registeredMiners.splice(index, 1);console.log(''--- registeredMiners
    end: '' + JSON.stringify(registeredMiners));}'
- en: '**Mine a New Block**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**挖出一个新块**'
- en: As opposed to bitcoin, which generates a block every 10 minutes, your blockchain
    will be improved and will generate a block every 30 seconds. To achieve that,
    you already installed the open source cron library for Node.js. The cron library
    works the same as the Linux cron. You can utilized the cron library to set how
    often to call the same code again, which will be used to call your miners every
    30 seconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币不同，比特币每10分钟产生一个区块，而你的区块链将会更高效，每30秒产生一个区块。为了实现这一点，你已经安装了适用于Node.js的开源cron库。这个cron库的工作方式与Linux的cron相同。你可以使用cron库来设置如何频繁地再次调用相同的代码，这将会用于每30秒调用一次你的矿工。
- en: To do so, first include the library in your code’s import statement on top of
    the p2p.js file.let CronJob = require('cron').CronJob;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先需要在p2p.js文件的顶部在你的代码的导入声明中包含这个库。let CronJob = require('cron').CronJob;
- en: Next, you can set your cronjob  to run every 30 seconds, and job.start(); will
    start the job, as shown in Listing [3-6](#PC31).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以将你的计划任务（cronjob）设置为每30秒运行一次，`job.start()`将会启动任务，正如列表[3-6](#PC31)所展示的。
- en: '*Listing 3-6. crobjob to Mine a New Block*const job = new CronJob(''30 ∗ ∗
    ∗ ∗ ∗'', function() {    let index = 0; // first block    if (lastBlockMinedBy)
    {        let newIndex = registeredMiners.indexOf(lastBlockMinedBy);        index
    = ( newIndex+1 > registeredMiners.length-1) ? 0 : newIndex + 1;    }    lastBlockMinedBy
    = registeredMiners[index];    console.log(''-- REQUESTING NEW BLOCK FROM: '' +
    registeredMiners[index] + '', index: '' + index);    console.log(JSON.stringify(registeredMiners));    if
    (registeredMiners[index] === myPeerId.toString(''hex'')) {        console.log(''-----------create
    next block -----------------'');        let newBlock = chain.generateNextBlock(null);        chain.addBlock(newBlock);        console.log(JSON.stringify(newBlock));        writeMessageToPeers(MessageType.RECEIVE_NEW_BLOCK,
    newBlock);        console.log(JSON.stringify(chain.blockchain));        console.log(''-----------create
    next block -----------------'');    }});job.start();Reviewing the code, notice
    that the first block’s index is 0, so after the first block is mined, lastBlockMinedBy
    will be set, and you will be requesting the next block from your next miner.let
    newIndex = registeredMiners.indexOf(lastBlockMinedBy);index = ( newIndex+1 > registeredMiners.length-1)
    ? 0 : newIndex + 1;To generate and add a new block, you will be calling chain
    generateNextBlock and addBlock. Lastly, you will broadcast the new block to all
    the connected peers.let newBlock = chain.generateNextBlock(null);chain.addBlock(newBlock);writeMessageToPeers(MessageType.RECEIVE_NEW_BLOCK,
    newBlock);In your code, your switch will handle the new incoming blocks.case MessageType.RECEIVE_NEW_BLOCK:    if
    ( message.to === myPeerId.toString(''hex'') && message.from !== myPeerId.toString(''hex''))
    {        console.log(''-----------RECEIVE_NEW_BLOCK------------- '' + message.to);        chain.addBlock(JSON.parse(JSON.stringify(message.data)));        console.log(JSON.stringify(chain.blockchain));        console.log(''-----------RECEIVE_NEW_BLOCK-------------
    '' + message.to);    }    break;To see this code in action, run three instances
    of your code.> node p2p.jsYou can see the messages of registering each peer as
    a miner, as well as your code starting to mine blocks every 30 seconds in order,
    as shown in Figure [3-6](#Fig6).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig6_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig6_HTML.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-6. 挖矿新区块的 crobjob*'
- en: Figure 3-6
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6
- en: Code registering miners and generating new blocks
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注册矿工和生成新区块的代码
- en: In this exercise, you were able to register your peers as a miners, generate
    new blocks, and share blocks with other peers; you used a simple PoS for the consensus
    mechanism and were able to test the functionality by creating three peers. The
    consensus mechanism is simple and does not take into account every use case that
    can happen or security. In the next step, you will save your blocks in a LevelDB
    database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你能够注册你的 peers 作为矿工，生成新区块，并将区块与其他 peers 分享；你使用了一个简单的 PoS 作为共识机制，并通过创建三个
    peers 测试了功能。这个共识机制很简单，并没有考虑到可能发生的一切用例或安全性。在下一步，你将在 LevelDB 数据库中保存你的区块。
- en: Storing Blocks in LevelDB
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 LevelDB 中存储区块
- en: If you run your blockchain for a few hours, you will notice that the number
    of blocks created grows, which can become a problem as currently these blocks
    are stored in your computer’s memory cache. As you add more and more blocks, the
    memory usage will grow, and eventually your code will crash. Further, without
    storing your blocks in a database, you will not be able to start and stop your
    P2P network, as the blocks are not saved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的区块链几小时，你会注意到创建的区块数量增长，这可能成为一个问题，因为目前这些区块存储在你的计算机内存缓存中。随着你添加越来越多的区块，内存使用将会增长，最终你的代码将会崩溃。此外，不将你的区块存储在数据库中，你将无法启动和停止你的
    P2P 网络，因为区块没有被保存。
- en: To accommodate these use cases and others, you will be using a LevelDB database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这些用例及其他用例，你将使用一个 LevelDB 数据库。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A LevelDB database stores name-value pairs in what is called a *level-up* and
    *level-down* fashion. It is an ideal option for blockchain networks. In fact,
    bitcoin uses LevelDB to store not only block information but also transaction
    information. See [https://github.com/bitcoin-core/leveldb](https://github.com/bitcoin-core/leveldb)
    .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**LevelDB** 数据库以所谓的 *层级提升* 和 *层级降低* 的方式存储键值对。它是区块链网络的理想选择。实际上，比特币使用 LevelDB
    不仅存储区块信息，还存储交易信息。参见 [https://github.com/bitcoin-core/leveldb](https://github.com/bitcoin-core/leveldb)
    。'
- en: 'Step 4: Leveldb to Store Blocks Exercise'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：使用 Leveldb 存储区块练习
- en: '**LevelDB**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**LevelDB**'
- en: 'In this exercise, you will implement a database to store your blocks. You can
    download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain)
    . Remember to run the install command to retrieve all the npm modules.> npm installTo
    get started on your own from the previous step, you will be using a Node.js LevelDB
    wrapper so you can communicate with LevelDB through your code. Install the library
    via npm.>  npm install level -saveNext, make a directory where you will be saving
    the database.> mkdir dbYou can now implement the database. In your chain.js library,
    you will add some code to save your block in the LevelDB database, as shown in
    Listing [3-7](#PC39).let level = require(''level''),    fs = require(''fs'');let
    db;let createDb = (peerId) => {    let dir = __dirname + ''/db/'' + peerId;    if
    (!fs.existsSync(dir)){        fs.mkdirSync(dir);        db = level(dir);        storeBlock(getGenesisBlock());    }}Listing
    3-7'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将实现一个数据库来存储你的区块。你可以从这里下载完整的练习：[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step4/blockchain)
    。记得运行安装命令以获取所有的 npm 模块。> npm install
- en: Storing Blocks in LevelDB
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LevelDB 中存储区块
- en: As you can see, you use the __dirname Node.js  native class to give you the
    directory path location because you need the full path to save your database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你使用 __dirname Node.js 原生类来提供目录路径位置，因为你需要完整的路径来保存你的数据库。
- en: Because you are running multiple instances of your P2P network on the same machine,
    you cannot use the same path for each peer because the database needs to be separate.
    What you can do is set each database’s location in a separate path location using
    the folder name as the name of your peer ID; then each database can be stored
    in the db folder. Also notice that you save the first block, getGenesisBlock().
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你正在同一台机器上运行你 P2P 网络的多个实例，你不能为每个对等实体使用相同的路径，因为数据库需要是分开的。你可以为每个数据库的路径设置一个单独的位置，使用文件夹名作为你的对等
    ID 名称；然后每个数据库可以存储在 db 文件夹中。同时注意你保存了第一个区块，getGenesisBlock()。
- en: 'Next, you create a storeBlock method  to store the new block.let storeBlock
    = (newBlock) => {    db.put(newBlock.index, JSON.stringify(newBlock), function
    (err) {        if (err) return console.log(''Ooops!'', err) // some kind of I/O
    error        console.log(''--- Inserting block index: '' + newBlock.index);    })}When
    you generate a new block using the generateNextBlock method  , you can now store
    the block in the LevelDB database.storeBlock(newBlock);You are also going to add
    a method to be able to retrieve a block from the LevelDB database.let getDbBlock
    = (index, res) => {    db.get(index, function (err, value) {        if (err) return
    res.send(JSON.stringify(err));        return(res.send(value));    });}Make sure
    you expose the createDb and getDbBlock methods  .if (typeof exports != ''undefined''
    ) {    exports.createDb = createDb;    exports.getDbBlock = getDbBlock;}Lastly,
    in your P2P network code, all you need to do is create a database once you start
    the code.chain.createDb(myPeerId.toString(''hex''));To see the code in action,
    run an instance of the P2P network.> node p2p.jsYou can monitor the database’s
    data in the db folder using the tail command with the -f flag. Terminal will stay
    open and can show you new blocks as they are being generated (see the output in
    Figure [3-7](#Fig7)).> cd step4/db/[our peer Id]> tail –f 000003.log![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，您创建一个 storeBlock 方法来存储新块。let storeBlock = (newBlock) => {    db.put(newBlock.index,
    JSON.stringify(newBlock), function (err) {        if (err) return console.log(''Ooops!'',
    err) // 某种 I/O 错误        console.log(''--- Inserting block index: '' + newBlock.index);    })}当您使用
    generateNextBlock 方法生成新块时，您现在可以将块存储在 LevelDB 数据库中。storeBlock(newBlock);您还将添加一个方法，以便能够从
    LevelDB 数据库检索区块。let getDbBlock = (index, res) => {    db.get(index, function (err,
    value) {        if (err) return res.send(JSON.stringify(err));        return(res.send(value));    });}确保您公开
    createDb 和 getDbBlock 方法。if (typeof exports != ''undefined'' ) {    exports.createDb
    = createDb;    exports.getDbBlock = getDbBlock;}最后，在您的 P2P 网络代码中，您需要做的是在启动代码时创建一个数据库。chain.createDb(myPeerId.toString(''hex''));要看到代码的实际运行，运行
    P2P 网络的一个实例。> node p2p.js您可以使用带有 -f 标志的 tail 命令监控 db 文件夹中的数据库数据。终端将保持打开状态，并可以显示新块在生成时的输出（参见图
    [3-7](#Fig7) 的输出）。> cd step4/db/[我们的 peer Id]> tail –f 000003.log![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig7_HTML.jpg)'
- en: Figure 3-7
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7
- en: tail command with the LevelDB database showing new blocks being generated
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LevelDB 数据库的 tail 命令显示新块正在生成
- en: 'In this exercise, you created a LevelDB database. You are storing your blocks
    so you will be able to retrieve them instead of relying on your cache memory.
    I am keeping things simple; if this were a real working blockchain, you would
    implement the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个 LevelDB 数据库。您正在存储您的区块，这样您就可以检索它们，而不是依赖您的缓存内存。我让事情变得简单；如果这是一个真实运行的区块链，您将实现以下步骤：
- en: '1.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Mitigate all the possible security risks.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减轻所有可能的安全风险。
- en: '2.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Store and retrieve your blocks from the LevelDB database.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 LevelDB 数据库存储和检索您的区块。
- en: '3.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Create a method to restore LevelDB’s entries.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个方法来恢复 LevelDB 的条目。
- en: '4.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Clean old databases because new ones are created on every init.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为每次初始化都会创建新的数据库，所以清理旧的数据库。
- en: Creating a Blockchain Wallet
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建区块链钱包
- en: In cryptocurrency, a wallet is necessary in order to reward miners for generating
    blocks as well as to be able to create transactions and send transactions. In
    this section, you will create a wallet. You need to create a combination of public
    and private keys not just to authenticate a user but so you can store and retrieve
    data that the user owns. You will create a wallet with public and private keys.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密货币中，一个钱包是必要的，以便奖励矿工生成区块，同时也能创建交易和发送交易。在本节中，您将创建一个钱包。您需要创建公钥和私钥的组合，不仅是为了验证用户，而且是为了能够存储和检索用户拥有的数据。您将创建带有公钥和私钥的钱包。
- en: In bitcoin, the wallet’s original software is the bitcoin core protocol you
    downloaded in Chapter [2](475651_1_En_2_Chapter.xhtml); it needs the entire ledger
    of all transactions since 2009, which is more than 150 GB at the time of writing.
    For that reason, most wallets in use are “light” wallets or what’s called *simplified
    payment verification* (SPV)  wallets that sync to bitcoin core. In blockchain,
    there are many different wallets available, from online all the way to a paper
    wallet where you write your private key on a piece of paper.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，钱包的原始软件是你在第二章[2](475651_1_En_2_Chapter.xhtml)下载的比特币核心协议；它需要自2009年以来所有交易的完整账本，截至撰写本文时，超过150
    GB。因此，大多数正在使用中的钱包是“轻量级”钱包或所谓的*简化支付验证*（SPV）钱包，它们与比特币核心同步。在区块链中，有多种不同的钱包可供选择，从在线钱包到将私钥写在纸上的纸钱包。
- en: Before proceeding, let’s take a quick look at how you can communicate with a
    bitcoin wallet. As you recall, in Chapter [2](475651_1_En_2_Chapter.xhtml) you
    were able to get the balance of a certain bitcoin wallet. To better understand
    wallets, you can create a bitcoin wallet using the bitcoin core.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们快速了解一下如何与比特币钱包进行通信。正如你所回忆的，在第二章[2](475651_1_En_2_Chapter.xhtml)中，你能够获取某个比特币钱包的余额。为了更好地了解钱包，你可以使用比特币核心创建一个比特币钱包。
- en: First, you need to run the bitcoin daemon.> bitcoind –printtoconsoleNext, you
    can request an address.> bitcoin-cli help getnewaddressThen, you are able to dump
    your private keys into a text file.> bitcoin-cli dumpwallet ~/mywallet.txtYou
    can get the location of your private key and view the key.> vim /Users/[location]/mywallet.txtFor
    reference, check the C++ bitcoin core wallet code here:> vim /[Bitcoin Core Location]/bitcoin/src/wallet/init.cpp
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要运行比特币守护进程。> bitcoind –printtoconsole接下来，你可以请求一个地址。> bitcoin-cli help getnewaddress然后，你可以将你的私钥导出到一个文本文件中。>
    bitcoin-cli dumpwallet ~/mywallet.txt你可以获取私钥的位置并查看密钥。> vim /Users/[location]/mywallet.txt仅供参考，请查看C++比特币核心钱包代码：>
    vim /[Bitcoin Core Location]/bitcoin/src/wallet/init.cpp
- en: 'Step 5: Wallet Exercise'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五步：钱包练习
- en: '**Create a Blockchain Wallet**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建区块链钱包**'
- en: In this exercise, you will generate public-private keys to be used for your
    wallet. You can download the complete exercise from [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain)
    and run the npm install command. Additionally, create a folder named wallet.>
    npm install> mkdir wallet
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将生成用于你的钱包的公私钥。你可以从[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step5/blockchain)下载完整的练习并运行npm
    install命令。另外，创建一个名为wallet的文件夹。> npm install> mkdir wallet
- en: You will be using the elliptic-curve cryptography library implementation to
    generate private-public key combos. Note that the elliptic-curve library uses
    secp256k1 as the ECDSA curve algorithm.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用椭圆曲线密码学库实现来生成公私钥组合。请注意，椭圆曲线库使用secp256k1作为ECDSA曲线算法。
- en: '**Note** *Elliptical curve cryptography* (ECC) is the public key encryption
    technique used by bitcoin. It’s based on elliptic curve theory to generate the
    cryptographic keys. Secp256k1 is the graph elliptic curve ECDSA algorithm.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *椭圆曲线密码学*（ECC）是比特币使用的公钥加密技术。它基于椭圆曲线理论生成密码学密钥。Secp256k1是图形椭圆曲线ECDSA算法。'
- en: To install the library, run the following command:> npm install elliptic --save
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装库，运行以下命令：> npm install elliptic --save
- en: Next, add a file and name it wallet.js. Take a look at the complete code in
    Listing [3-8](#PC54).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为wallet.js的文件。查看列表[3-8](#PC54)中的完整代码。
- en: '*Listing 3-8. wallet.js*let EC = require(''elliptic'').ec,    fs = require(''fs'');const
    ec = new EC(''secp256k1''),    privateKeyLocation = __dirname + ''/wallet/private_key'';exports.initWallet
    = () => {    let privateKey;    if (fs.existsSync(privateKeyLocation)) {        const
    buffer = fs.readFileSync(privateKeyLocation, ''utf8'');        privateKey = buffer.toString();    }
    else {        privateKey = generatePrivateKey();        fs.writeFileSync(privateKeyLocation,
    privateKey);    }    const key = ec.keyFromPrivate(privateKey, ''hex'');    const
    publicKey = key.getPublic().encode(''hex'');    return({''privateKeyLocation'':
    privateKeyLocation, ''publicKey'': publicKey});};const generatePrivateKey = ()
    => {    const keyPair = ec.genKeyPair();    const privateKey = keyPair.getPrivate();    return
    privateKey.toString(16);};In the wallet file, you create and initialize the EC
    context.const ec = new EC(''secp256k1''),You then store the location of your wallet’s
    private key, privateKeyLocation.privateKeyLocation = __dirname + ''/wallet/private_key'';Next,
    you are able to create a method exports.initWallet to generate the actual public-private
    key, generatePrivateKey.    const keyPair = ec.genKeyPair();    const privateKey
    = keyPair.getPrivate();Notice that you will be generating a new wallet only if
    one doesn’t exist.if (fs.existsSync(privateKeyLocation))'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-8. wallet.js*let EC = require(''elliptic'').ec,    fs = require(''fs'');const
    ec = new EC(''secp256k1''),    privateKeyLocation = __dirname + ''/wallet/private_key'';exports.initWallet
    = () => {        let privateKey;        if (fs.existsSync(privateKeyLocation))
    {            const buffer = fs.readFileSync(privateKeyLocation, ''utf8'');            privateKey
    = buffer.toString();        } else {            privateKey = generatePrivateKey();            fs.writeFileSync(privateKeyLocation,
    privateKey);        }        const key = ec.keyFromPrivate(privateKey, ''hex'');        const
    publicKey = key.getPublic().encode(''hex'');        return({''privateKeyLocation'':
    privateKeyLocation, ''publicKey'': publicKey});};const generatePrivateKey = ()
    => {        const keyPair = ec.genKeyPair();        const privateKey = keyPair.getPrivate();        return
    privateKey.toString(16);};在钱包文件中，您创建并初始化 EC 上下文。const ec = new EC(''secp256k1''),然后存储您的钱包私钥的位置，privateKeyLocation。privateKeyLocation
    = __dirname + ''/wallet/private_key'';接下来，您可以创建一个方法exports.initWallet来生成实际的公钥-私钥，generatePrivateKey。    const
    keyPair = ec.genKeyPair();    const privateKey = keyPair.getPrivate();注意，只有在没有钱包的情况下，您才会生成一个新的钱包。if
    (fs.existsSync(privateKeyLocation))'
- en: In this exercise, you create a wallet.js file utilizing the Elliptic Curve Cryptography
    library to generate your private-public key combo.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您利用椭圆曲线加密库创建一个 wallet.js 文件，以生成您的私钥-公钥组合。
- en: To see the code working, add the following code temporarily at the end of the
    wallet.js file  . The script will create the public and private keys.let wallet
    = this;let retVal = wallet.initWallet();console.log(JSON.stringify(retVal));Next,
    create a wallet directory to store the private key and run the script. The code
    will initialize the script and create your public key.> mkdir wallet> node wallet.js>
    cat wallet/private_keyWhen you run the node wallet.js command, you can see the
    public key. See Figure [3-8](#Fig8) for the output.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到代码运行，暂时在 wallet.js 文件的末尾添加以下代码。脚本将创建公钥和私钥。let wallet = this;let retVal =
    wallet.initWallet();console.log(JSON.stringify(retVal));接下来，创建一个钱包目录以存储私钥并运行脚本。代码将初始化脚本并创建您的公钥。>
    mkdir wallet> node wallet.js> cat wallet/private_key当你运行 node wallet.js 命令时，你可以看到公钥。见图
    [3-8](#Fig8) 的输出。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig8_HTML.jpg)
- en: Figure 3-8
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8
- en: Generating a wallet’s private-public key
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成钱包的私钥-公钥
- en: Remember to comment out these lines because in the next exercise, you will create
    an API to be able to create your keys via the browser.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记得注释掉这些行，因为在下一个练习中，您将创建一个 API，以便通过浏览器创建您的密钥。
- en: Creating an API
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 API
- en: The next step is creating an application program interface (API) to be able
    to access the code you write. This is an important part of a blockchain, as you
    want to access your blocks and wallet or any other P2P network operation using
    an HTTP service. In this section, you will be using the express library, as it’s
    easy to run, and you will be able to create your API easily.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个应用程序接口（API），以便能够访问您编写的代码。这是区块链的一个重要部分，因为您希望使用 HTTP 服务来访问您的区块、钱包或任何其他
    P2P 网络操作。在本节中，您将使用 express 库，因为它易于运行，您可以轻松创建您的 API。
- en: 'Step 6: API P2P Blockchain Exercise'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：API P2P 区块链练习
- en: '**Creating API**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建 API**'
- en: 'In this exercise, you will create an API to interact with your P2P blockchain
    network. You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain)
    .'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个API来与你对等式区块链网络进行交互。你可以从这里下载完整的练习：[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step6/blockchain)
    。
- en: 'You will be creating the following services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建以下服务：
- en: '***blocks***: Retrieves all the blocks in the blockchain'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***blocks***: 获取区块链中的所有区块'
- en: '***getBlock***: Retrieves a specific block by index'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***getBlock***: 通过索引获取特定区块'
- en: '***getDBBlock***: Retrieves a block from the database'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***getDBBlock***: 从数据库中获取区块'
- en: '***getWallet***: Creates a new wallet by generating a public-private key'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***getWallet***: 通过生成公私钥创建新钱包'
- en: 'You will install express and body-parser. These libraries will allow you to
    create a server and display pages in the browser.> npm install express body-parser
    --saveYou also need to import the wallet.js file you created.let express = require("express"),    bodyParser
    = require(''body-parser''),    wallet = require(''./wallet'');Next, you create
    a method called initHttpServer that will initiate the server and create the services.
    As you utilize different instances of the P2P network and run instances on the
    same computer, you want to utilize different port numbers. It’s common to use
    port 80 or 8081 for HTTP services but not required. What you will do is pass the
    random port number you are using and utilize the slice method to get the last
    two digits of the port number.let initHttpServer = (port) => {    let http_port
    = ''80'' + port.toString().slice(-2);    let app = express();    app.use(bodyParser.json());The
    Blocks service will be retrieving all of your blocks.    app.get(''/blocks'',
    (req, res) => res.send(JSON.stringify( chain.blockchain )));The getBlock service
    will be retrieving one block based on an index.    app.get(''/getBlock'', (req,
    res) => {        let blockIndex = req.query.index;        res.send(chain.blockchain[blockIndex]);    });The
    getDBBlock service  will be retrieving a LevelDB database entry based on an index.    app.get(''/getDBBlock'',
    (req, res) => {        let blockIndex = req.query.index;        chain.getDbBlock(blockIndex,
    res);    });The getWallet service  will be utilizing the wallet.js file you created
    in the previous step and generate your public-private key pair.    app.get(''/getWallet'',
    (req, res) => {        res.send(wallet.initWallet());    });Lastly, you will utilize
    the Express listen method.    app.listen(http_port, () => console.log(''Listening
    http on port: '' + http_port));};You will call the initHttpServer method you created
    after you start the P2P network and a random port was selected.(async () => {     const
    port = await getPort();     initHttpServer(port);}To call your services, run the
    P2P network, and then you can open a browser and call the API.http://localhost:80[port]/getWallethttp://localhost:80[port]/blockshttp://localhost:80[port]/getBlock?index=0http://localhost:80[port]/
    getDBBlock?index=0See Figure [3-9](#Fig9), for instance, as you retrieve all the
    blocks in your blockchain.![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '你会安装 express 和 body-parser。这些库将允许你创建一个服务器并在浏览器中显示页面。> npm install express body-parser
    --save你还需要导入你创建的 wallet.js 文件。let express = require("express"), bodyParser = require(''body-parser''),
    wallet = require(''./wallet'');接下来，你创建一个名为 initHttpServer 的方法，该方法将初始化服务器并创建服务。当你在同一台计算机上运行不同实例的
    P2P 网络时，你希望使用不同的端口号。通常用于 HTTP 服务的端口是 80 或 8081，但这不是强制的。你要做的是传递你正在使用的随机端口号，并使用切片方法获取端口号的最后两位数字。let
    initHttpServer = (port) => { let http_port = ''80'' + port.toString().slice(-2);
    let app = express(); app.use(bodyParser.json()); 区块服务将获取你的所有区块。app.get(''/blocks'',
    (req, res) => res.send(JSON.stringify( chain.blockchain )));获取区块服务将根据索引获取一个区块。app.get(''/getBlock'',
    (req, res) => { let blockIndex = req.query.index; res.send(chain.blockchain[blockIndex]);
    });获取数据库区块服务将根据索引获取 LevelDB 数据库条目。app.get(''/getDBBlock'', (req, res) => { let
    blockIndex = req.query.index; chain.getDbBlock(blockIndex, res); });获取钱包服务将使用你在上一步创建的
    wallet.js 文件生成你的公私钥对。app.get(''/getWallet'', (req, res) => { res.send(wallet.initWallet());
    });最后，你将使用 Express 监听方法。app.listen(http_port, () => console.log(''Listening http
    on port: '' + http_port)); };你将在启动 P2P 网络并选择随机端口号后调用你创建的 initHttpServer 方法。(async
    () => { const port = await getPort(); initHttpServer(port);}要调用你的服务，启动 P2P 网络，然后你可以打开浏览器并调用
    API。http://localhost:80[port]/getWallethttp://localhost:80[port]/blockshttp://localhost:80[port]/getBlock?index=0http://localhost:80[port]/getDBBlock?index=0例如，查看图
    [3-9](#Fig9)，你会获取你的区块链中的所有区块。![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig9_HTML.jpg)'
- en: Figure 3-9
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9
- en: Retrieving all the blocks in your blockchain
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 获取区块链中的所有区块
- en: In this exercise, you created API services, and you can now interact with your
    P2P network. You created your services so you will be able to create multiple
    instances of the P2P networks on the same machine; however, in reality, every
    machine will be holding only one peer. In the next exercise, you will create a
    command-line interface (CLI) to easily call these services.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建 API 服务，现在你可以与你的 P2P 网络进行交互。你创建了自己的服务，这样你就可以在同一台机器上创建 P2P 网络的多个实例；然而，实际上，每台机器只会持有一个对等体。在下一个练习中，你将创建一个命令行界面（CLI）来轻松调用这些服务。
- en: Creating a Command-Line Interface
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令行界面
- en: For the last step in this chapter, you will be creating a command-line interface
    (CLI  ). The CLI is needed to be able to easily access the services you created.
    I won’t get into the entire internal process of the CLI script, as it’s beyond
    the scope of this chapter; however, you can download the whole example and review
    it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一步，你将创建一个命令行界面（CLI）。CLI是用来轻松访问你创建的服务所必需的。我不会深入讲解CLI脚本的整个内部过程，因为它超出了本章节的范围；然而，你可以下载整个示例并查看。
- en: 'Step 7: CLI Exercise'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步：CLI练习
- en: '**Block Command**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块命令**'
- en: 'In this exercise, you will create a CLI to interact with and access your P2P
    blockchain network. You can download the complete exercise from here: [https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain)
    .'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个CLI来与你的P2P区块链网络进行交互和访问。你可以从这里下载完整的练习：[https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain](https://github.com/Apress/the-blockchain-developer/tree/master/chapter3/step7/blockchain)。
- en: 'Next, install the libraries you will be utilizing to run promises, run the
    async function, add colors to the console, and store cookies.> npm babel-polyfill
    async update-notifier handlebars colors nopt --saveIn the block.js command, you
    will be setting two commands: get and all. Take a look at the entire code in Listing
    [3-9](#PC72).let logger = require(''../logger'');function Block(options) {    this.options
    = options;}Block.DETAILS = {    alias: ''b'',    description: ''block'',    commands:
    [''get'', ''all''],    options: {        create: Boolean    },    shorthands:
    {        s: [''--get''],        a: [''--all'']    },    payload: function(payload,
    options) {        options.start = true;    },};Block.prototype.run = function()
    {    let instance = this,        options = instance.options;    if (options.get)
    {        instance.runCmd(''curl http://localhost:'' + options.argv.original[2]
    + ''/getBlock?index='' + options.argv.original[3]);    }    if (options.all) {        instance.runCmd(''curl
    http://localhost:'' + options.argv.original[2] + ''/blocks'');    }};Block.prototype.runCmd
    = function(cmd) {    const { exec } = require(''child_process'');    logger.log(cmd);    exec(cmd,
    (err, stdout, stderr) => {        if (err) {            logger.log(`err: ${err}`);            return;        }        logger.log(`stdout:
    ${stdout}`);    });};exports.Impl = Block;Listing 3-9'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装你将用于运行承诺、运行异步函数、为控制台添加颜色以及存储cookies的库。`npm babel-polyfill async update-notifier
    handlebars colors nopt --save`在block.js命令中，你将设置两个命令：get和all。查看整个代码，如列表[3-9](#PC72)中所示。
- en: Block Command Code
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 区块命令代码
- en: As you can see, the wallet.js command will include the get and all methods to
    point to a curl command to run the HTTP service call.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，wallet.js命令将包括get和all方法，指向一个curl命令来运行HTTP服务调用。
- en: '**Wallet Command**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**钱包命令**'
- en: 'Similarly, the block.js command will include a create method and a curl command
    to run the HTTP service call. See Listing [3-10](#PC73).let logger = require(''../logger'');function
    Wallet(options) {    this.options = options;}Wallet.DETAILS = {    alias: ''w'',    description:
    ''wallet'',    commands: [''create''],    options: {        create: Boolean    },    shorthands:
    {        c: [''--create'']    },    payload: function(payload, options) {        options.start
    = true;    },};Wallet.prototype.run = function() {    let instance = this,        options
    = instance.options;    if (options.create) {        instance.runCmd(''curl http://localhost:''
    + options.argv.original[2] + ''/getWallet'');    }};Wallet.prototype.runCmd =
    function(cmd) {    const { exec } = require(''child_process'');    logger.log(cmd);    exec(cmd,
    (err, stdout, stderr) => {        if (err) {            logger.log(`err: ${err}`);            return;        }        logger.log(`stdout:
    ${stdout}`);    });};exports.Impl = Wallet;Listing 3-10'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，block.js命令将包括一个create方法和一个curl命令来运行HTTP服务调用。参见列表[3-10](#PC73)。
- en: Wallet Command Code
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包命令代码
- en: 'Now that you have your commands set up, you can add your CLI to the bash_profile
    as an alias to be able to run the CLI from any path location.> vim ~/.bash_profilealias
    cli=''node /[project location]/step7/bin/bin/cli.jsSave and run bash_profile to
    apply these changes.> . ~/.bash_profileYou can call the CLI once you run the P2P
    and know the ports you are using.> cli block --get [port] 1 #port #index> cli
    block –all [port] #port> cli wallet --create [port]For instance, run an instance
    of the P2P network in Terminal.> node p2p.jsNext, open a new window terminal and
    run the CLI command to retrieve the first generated block.> cli block --get [port]
    1You can see the output in Figures [3-10](#Fig10) and [3-11](#Fig11).![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig10_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig10_HTML.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了你的命令，你可以在bash_profile中为你的CLI添加别名，以便能够从任何路径位置运行CLI。
- en: Figure 3-10
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-10
- en: Running the P2P blockchain network on port 8057
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口8057上运行P2P区块链网络。
- en: '![../images/475651_1_En_3_Chapter/475651_1_En_3_Fig11_HTML.jpg](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig11_HTML.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图3-10](../images/475651_1_En_3_Chapter/475651_1_En_3_Fig10_HTML.jpg)'
- en: Figure 3-11
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-11
- en: Retrieving blocks on port 8057
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口8057上检索区块。
- en: In this exercise, you created two commands for getting blocks and creating your
    wallet. This is a starting point for your CLI, and you will be able to continue
    to add commands as needed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你为获取区块和创建你的钱包创建了两个命令。这是你的CLI的起点，你可以根据需要继续添加命令。
- en: Where to Go from Here
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从这里出发去哪里。
- en: I already mentioned that the code in this chapter does not take into account
    many use cases and has no security to keep it simple. There are many things you
    can do to improve the code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到，本章中的代码没有考虑很多用例，也没有安全性措施以保持简单。你可以做很多事情来改进代码。
- en: '*Confirmations*: Each miner sends a message with a block. You can create a
    confirmation system to ensure the integrity of the data.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认（Confirmations）**：每个矿工都会发送一个带有区块的消息。你可以创建一个确认系统来确保数据的完整性。'
- en: '*Transactions/data*: You could implement transactions or data objects to address
    double spending, transaction validation, and coinbase transactions.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易/数据**：你可以实现交易或数据对象来解决双重支付、交易验证和coinbase交易问题。'
- en: '*levelDB*: Once the P2P is initialized, you can create a script to retrieve
    and write all the blocks into the LevelDB database, validate them, and clean the
    database as needed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**levelDB**：一旦P2P初始化，你可以创建一个脚本来检索并写入所有区块到LevelDB数据库，验证它们，并在需要时清理数据库。'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered how to create your very own basic P2P blockchain network;
    you were able to send and receive messages and include blocks in these messages.
    You were able to register and unregister miners and implement a simple PoS consensus
    mechanism. You created new blocks and sent them between the peers. You also set
    up a name-value LevelDB database to store blocks. You continued and created a
    wallet that consists of private-public key pairs. Lastly, you created ways to
    communicate with your P2P network via API services and the CLI. In the next chapter,
    you will be diving deep into understanding bitcoin wallets and transactions by
    interacting with the bitcoin core API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何创建你自己的基础对等区块链网络；你能够发送和接收消息并在这些消息中包含区块。你能够注册和注销矿工并实现一个简单的权益证明（PoS）共识机制。你创建了新的区块并将它们在
    peer 之间发送。你还设置了一个名称-值 LevelDB 数据库来存储区块。你继续并创建了一个包含私钥-公钥对的钱包。最后，你创建了通过 API 服务和命令行界面（CLI）与你的
    P2P 网络通信的方法。在下一章中，将通过与比特币核心 API 交互来深入理解比特币钱包和交易。
