- en: 'Part III: Ethereum in Depth'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：深入以太坊
- en: In the previous part, I introduced you to the concepts and tools for Ethereum
    smart contract and dapp development. In the next several chapters, we will dive
    deeper into Ethereum. We will look into how smart contract data and states are
    stored in the Ethereum blockchain and how smart contract developers could make
    use of such data. We will also look into best practices to secure smart contracts,
    which is a major issue the community faces today. Finally, we will review the
    Ethereum road map on what’s coming for developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我向你介绍了以太坊智能合约和DApp开发的的概念和工具。在接下来的几章中，我们将更深入地了解以太坊。我们将探讨智能合约数据和状态是如何存储在以太坊区块链中的，以及智能合约开发者如何利用这些数据。我们还将探讨保障智能合约安全的最佳实践，这是社区今天面临的一个主要问题。最后，我们将回顾以太坊路线图，了解开发人员即将面临的内容。
- en: 9. Inside Ethereum
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9. 以太坊内部
- en: By Tim McCallum
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Tim McCallum
- en: In the previous chapters, you learned how to interact with the Ethereum blockchain
    from the outside as a client. The chapters covered topics such as executing transactions,
    developing and deploying smart contracts, and developing dapps using tools like
    the web3 library. However, to truly understand how Ethereum works and perhaps
    modify its behavior for your own purposes, we will need to look deeper beneath
    the external interface of the blockchain platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经学习了如何作为客户端从外部与以太坊区块链进行交互。这些章节涵盖了执行交易、开发和部署智能合约以及使用web3库等工具开发去中心化应用（DApps）等内容。然而，为了真正理解以太坊的工作原理，或许为了你自己的目的而修改其行为，我们需要更深入地研究区块链平台的对外接口之下。
- en: In this chapter, I deconstruct Ethereum to provide you with an understanding
    of its data storage layer, and I introduce the concept of blockchain state. Also,
    I cover the theory behind the Patricia trie data structure and demonstrate Ethereum’s
    concrete implementation of tries using Google’s LevelDB database. From this point,
    you will be able to execute transactions and explore how Ethereum’s state responds
    to activities such as transactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解构了以太坊，为您提供了对其数据存储层的理解，并介绍了区块链状态的概念。此外，我涵盖了帕特里夏（Patricia）字典树数据结构的理论，并展示了以太坊使用谷歌的LevelDB数据库实现字典树的具体方式。从这一点开始，您将能够执行交易并探索以太坊状态如何响应交易等活动。
- en: What Is Blockchain State?
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链状态是什么？
- en: Bitcoin’s *state* is represented by its global collection of unspent transaction
    outputs (UTXOs). The transfer of value in Bitcoin is actioned through transactions.
    More specifically, a Bitcoin user can spend one or more UTXOs by creating a transaction
    and adding one or more UTXOs as the transaction’s input.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的状态由其全球未花费交易输出（UTXO）集合表示。比特币中的价值转移是通过交易进行的。更具体地说，比特币用户可以通过创建交易并添加一个或多个UTXO作为交易的输入，来花费一个或多个UTXO。
- en: A full explanation of UTXOs is beyond the scope of this chapter. However, I
    mention UTXOs in the following paragraphs to point out a fundamental difference
    between Bitcoin and Ethereum. Specifically, the following two Bitcoin examples
    will provide contrast between Bitcoin’s UTXO model and Ethereum’s world state.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对未花费交易输出（UTXO）的完整解释超出了范围。然而，我在下面的段落中提到UTXO，以指出比特币和以太坊之间的根本区别。具体来说，下面的两个比特币示例将提供比特币的UTXO模型与以太坊的世界状态之间的对比。
- en: First, Bitcoin UTXOs cannot be partially spent. If a Bitcoin user spends 0.5
    Bitcoin (using her only UTXO, which is worth 1 Bitcoin), the user has to deliberately
    self-address (send herself ) 0.5 Bitcoins (BTC) in return change ([Figure 9.1](ch09.xhtml#ch09fig1)).
    If the user doesn’t send change, she will lose the 0.5 Bitcoin change to the Bitcoin
    miner who mines her transaction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，比特币的UTXO不能部分花费。如果一个比特币用户花费了0.5比特币（使用她唯一的UTXO，价值1比特币），用户必须故意自我地址（发送给自己）0.5比特币（BTC）作为回报([图9.1](ch09.xhtml#ch09fig1))。如果用户不发送回报，她将把0.5比特币的回报损失给挖出她交易的比特币矿工。
- en: '![image](Images/yuan_f09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_01.jpg)'
- en: '**Figure 9.1** Sending a partial Bitcoin'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.1** 发送部分比特币'
- en: Second, at the most fundamental level, Bitcoin does not maintain user account
    balances. With Bitcoin, a user simply holds the private keys to one or more UTXOs
    at any given point in time ([Figure 9.2](ch09.xhtml#ch09fig2)). Digital wallets
    make it seem like the Bitcoin blockchain automatically stores and organizes user
    account balances and so forth. This is not the case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在最深层次上，比特币不维护用户账户余额。在比特币中，用户只需在任意给定时间持有一个或多个UTXO的私钥([图9.2](ch09.xhtml#ch09fig2))。数字钱包使得看起来比特币区块链会自动存储和组织用户账户余额等等。并非如此。
- en: '![image](Images/yuan_f09_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_02.jpg)'
- en: '**Figure 9.2** Computing account balance for Bitcoin'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.2** 计算比特币账户余额'
- en: A user account balance in Bitcoin is an abstract notion. Realistically, a user’s
    account balance is the sum total of each individual UTXO (for which that user
    holds the corresponding private key), as shown in [Figure 9.3](ch09.xhtml#ch09fig3).
    The key that a user holds can be used to individually sign/spend each of the UTXOs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的用户账户余额是一个抽象概念。实际上，用户账户的余额是每个单独UTXO（用户持有相应的私钥）的总和，如图 9.3 所示。[图 9.3](ch09.xhtml#ch09fig3)
    中用户持有的密钥可用于单独签名/花费每个UTXO。
- en: '![image](Images/yuan_f09_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_03.jpg)'
- en: '**Figure 9.3** A Bitcoin wallet aggregates UTXOs to show account balances.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.3** 比特币钱包合并未使用的交易输出（UTXO）以显示账户余额。'
- en: 'The UTXO system in Bitcoin works well, in part, because digital wallets are
    able to facilitate most of the tasks associated with transactions. This includes
    but is not limited to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的UTXO系统运作良好，部分原因是因为数字钱包能够处理与交易相关的多数任务。这包括但不限于以下内容：
- en: Handling UTXOs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未使用的交易输出（UTXO）
- en: Storing keys
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储密钥
- en: Setting transaction fees
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置交易费用
- en: Providing return change addresses
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供返回找零地址
- en: Aggregating UTXOs (to show available, pending, and total balances)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并UTXO（以显示可用的、挂起的和总余额）
- en: Interestingly, a backup of a nondeterministic wallet (like the Bitcoin core
    wallet pictured in [Figure 9.3](ch09.xhtml#ch09fig3)) provides only a snapshot
    of the UTXOs (at that point in time). If a user performs any transactions (sending
    or receiving), the original backup that the user made will be out-of-date.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，非确定性钱包（如比特币核心钱包，如图 9.3 所示）的备份仅提供了UTXO的快照（在那一刻）。如果用户进行任何交易（发送或接收），用户最初所做的备份将会过时。
- en: 'To summarize, you now know the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你现在知道以下内容：
- en: The Bitcoin blockchain does not hold account balances.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币区块链不保存账户余额。
- en: Bitcoin wallets hold keys to UTXOs.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币钱包持有UTXO的密钥。
- en: If included in a transaction, an entire UTXO is spent (in some cases partially
    received as change in the form of a new UTXO).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个UTXO包含在交易中，那么整个UTXO将被花费（在某些情况下作为找零以新UTXO的形式部分接收）。
- en: Next, let’s look into the Ethereum blockchain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看以太坊区块链。
- en: Ethereum State
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ethereum 状态
- en: In contrast to the previous information, the Ethereum world state is able to
    manage account balances and more. The state of Ethereum is not an abstract concept.
    It is part of Ethereum’s base protocol layer. Ethereum is a transaction-based
    state machine; in other words, it’s a technology on which all transaction-based
    state machine concepts can be built.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的信息相比，以太坊世界状态能够管理账户余额等更多内容。以太坊的状态不是一个抽象概念。它是以太坊基础协议层的一部分。以太坊是一个基于交易的态机；换言之，它是所有基于交易的态机概念可以建立的技术。
- en: Storing state data on each Ethereum node allows for light clients that do not
    necessarily need to download the entire blockchain to function. Light clients
    just need access to the state database on a node to get the current state of the
    entire system and send in transactions to alter the state. That enables a whole
    range of applications to be developed on the Ethereum blockchain efficiently.
    Without stored data on nodes and light clients, most smart contracts or dapp use
    cases would be impossible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个以太坊节点上存储状态数据使得轻量级客户端能够不下载整个区块链的情况下正常工作。轻量级客户端只需访问节点上的状态数据库，就能获取整个系统的当前状态并发送交易以更改状态。这使得可以在以太坊区块链上高效地开发出一系列应用程序。如果没有在节点和轻量级客户端上保存数据，大多数智能合约或去中心化应用（DApp）的使用场景将无法实现。
- en: For example, an interesting idea mentioned in the Ethereum white paper is the
    notion of a savings account. In this scenario, two users (perhaps a husband and
    wife, or business partners) can each withdraw 1 percent of the account’s total
    balance per day. This idea is mentioned in the “Further Applications” section
    of the white paper, but it’s interesting because it, in theory, could be implemented
    as part of Ethereum’s base protocol layer (as opposed to having to be written
    as part of a second-layer solution or third-party wallet). You may recall the
    discussion about Bitcoin UTXOs earlier in this chapter. UTXOs are blind to blockchain
    data, and as discussed, the Bitcoin blockchain does not actually store a user’s
    account balance. For this reason, the base protocol layer of Bitcoin is far less
    likely (or perhaps unable) to implement any sort of daily spend limits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以太坊白皮书中有个有趣的想法，就是储蓄账户的概念。在这种情况下，两个用户（可能是丈夫和妻子，或商业伙伴）可以每天各自提取账户总余额的1%。这个想法在白皮书的“进一步应用”部分提到，但它有趣之处在于，理论上，这可以作为以太坊基础协议层的一部分来实现（而不是必须作为第二层解决方案或第三方钱包的一部分来编写）。你可能还记得本章早些时候关于比特币UTXO的讨论。UTXO对区块链数据是盲目的，正如讨论的那样，比特币区块链实际上并不存储用户的账户余额。正因为如此，比特币的基础协议层不太可能（或者可能无法）实现任何类型的每日支出限制。
- en: Next, let’s look into the actual structure of the Ethereum state data store.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解以太坊状态数据存储的实际结构。
- en: Data Structure
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据结构
- en: Let’s start at the beginning. As with all other blockchains, the Ethereum blockchain
    begins life at its own genesis block. From this point (genesis state at block
    0) onward, activities such as transactions, contracts, and mining will continually
    change the state of the Ethereum blockchain. In Ethereum, an example of this is
    an account balance (stored in the state trie, as shown in [Figure 9.4](ch09.xhtml#ch09fig4)),
    which changes every time a transaction, in relation to that account, takes place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始的地方说起。与所有其他区块链一样，以太坊区块链从它的创世区块开始。从这一点（区块0的状态）开始，诸如交易、合约和挖矿等活动将不断改变以太坊区块链的状态。在以太坊中，一个例子就是账户余额（存储在状态梅克尔树中，如图
    9.4 所示），每当与该账户相关的交易发生时，该余额就会发生变化。
- en: '![image](Images/yuan_f09_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_04.jpg)'
- en: '**Figure 9.4** The internal structure of data storage in an Ethereum node'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.4** 以太坊节点数据存储的内部结构'
- en: Importantly, data such as account balances is not stored directly in the blocks
    of the Ethereum blockchain. Only the root node hashes of the transaction trie,
    state trie, and receipts trie are stored directly in the blockchain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，诸如账户余额之类的数据并不是直接存储在以太坊区块链的区块中。只有交易梅克尔树、状态梅克尔树和收据梅克尔树的根节点哈希值是直接存储在区块链中的。
- en: You will also notice, from [Figure 9.4](ch09.xhtml#ch09fig4), that the root
    node hash of the storage trie (where all of the smart contract data is kept) actually
    points to the state trie, which in turn points to the blockchain. I will zoom
    in and cover all of this in more detail soon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，从[图 9.4](ch09.xhtml#ch09fig4)中，存储梅克尔树的根节点哈希（保存所有智能合约数据的地方）实际上指向状态梅克尔树，而状态梅克尔树又指向区块链。我将会放大并详细讲解所有这些内容。
- en: 'There are two vastly different types of data in Ethereum: permanent data and
    ephemeral data. An example of permanent data is a transaction. Once a transaction
    has been fully confirmed, it is recorded in the transaction trie and never altered.
    An example of ephemeral data is the balance of a particular Ethereum account address.
    The balance of an account address is stored in the state trie and is altered whenever
    transactions against that particular account occur. It makes sense that permanent
    data, such as mined transactions, and ephemeral data, such as account balances,
    should be stored separately. Ethereum uses trie data structures (as broadly outlined
    earlier) to manage data. The next section will take a detour and provide a quick
    overview on tries.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中有两种截然不同的数据类型：永久数据和短暂数据。永久数据的一个例子是交易。一旦交易被完全确认，它就会记录在交易梅克尔树中，并且永远不会被更改。一个短暂数据的例子是特定以太坊账户地址的余额。账户地址的余额存储在状态梅克尔树中，每当针对该特定账户的交易发生时，该余额就会被更改。永久数据（如挖出的交易）和短暂数据（如账户余额）应该分别存储是合理的。以太坊使用梅克尔树数据结构（如前面广泛概述的）来管理数据。下一节将暂时偏离主题，并提供关于梅克尔树的快速概述。
- en: Trie (or Tree)
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梅克尔树（或树）
- en: A *trie* (or tree) is a well-known data structure that is used for storing sequences
    of characters. Ethereum exclusively uses what is known as the “practical algorithm
    to retrieve information coded in alphanumeric” (Patricia) trie. The main advantage
    of the Patricia trie is its compact storage. We will now analyze the inner workings
    of the standard (more traditional) trie versus the Patricia trie.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树（或树）是一种众所周知的数据结构，用于存储字符序列。以太坊专门使用所谓的“以字母数字编码的信息的实际检索算法”（Patricia）字典树。Patricia
    trie 的主要优点是其紧凑的存储。现在我们将分析标准（更传统）trie 与 Patricia trie 的内部工作原理。
- en: Standard Trie
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准 Trie
- en: '[Figure 9.5](ch09.xhtml#ch09fig5) shows the structure of a standard trie that
    stores words. Each character in the word is a node in the tree, and each word
    is terminated by a special null pointer.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.5** 显示了存储单词的标准 trie 的结构。单词中的每个字符都是树的一个节点，每个单词都以一个特殊的空指针终止。'
- en: '![image](Images/yuan_f09_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_05.jpg)'
- en: '**Figure 9.5** A standard trie storing two words. The special character \0
    represents the null pointer.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.5** 标准字典树存储两个单词。特殊字符 \0 表示空指针。'
- en: Rules for Adding a Word to the Trie
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向 trie 添加单词的规则
- en: We follow the search path for the word we are adding. If we encounter a null
    pointer, we create a new node. When we have finished adding our word, we create
    a null pointer (terminator). When adding a (shorter) word that is contained in
    another (longer) word, we just exhaust all of the characters and then add a null
    pointer (terminator).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照要添加的单词的搜索路径进行操作。如果我们遇到一个空指针，我们就创建一个新的节点。当我们完成单词的添加后，我们创建一个空指针（终止符）。当添加一个（更短）的单词，而它包含在另一个（更长）的单词中时，我们只需耗尽所有字符，然后添加一个空指针（终止符）。
- en: Rules for Deleting a Word from the Trie
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从 trie 中删除单词的规则
- en: We search for a leaf (the end of a branch) on the trie that represents the string
    (which we want to delete). We then start deleting all nodes from the leaf back
    to the root of the trie—unless we hit a node with more than one child; in this
    case, we stop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们搜索代表我们要删除的字符串的 trie 上的叶子（分支的末端）。然后我们从叶子开始删除从叶子到 trie 根的所有节点，除非我们遇到一个有多个子节点的节点；在这种情况下，我们停止删除。
- en: Rules for Searching for a Word in the Trie
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 trie 中搜索单词的规则
- en: We examine each of the characters in the string for which we are searching and
    follow the trie for as long as it provides our path (in the right sequence). If
    we encounter a null pointer before exhausting all the characters in the string
    (which we are searching for), then we can conclude that the string is not stored
    in the trie. On the contrary, if we reach a leaf (the end of a branch) and that
    path (from the leaf back to the root of the trie) represents our string, we conclude
    that the string is stored in the trie.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查要搜索的字符串中的每个字符，并按照 trie 提供我们的路径（正确的顺序）进行操作。如果我们在我们耗尽字符串中的所有字符之前遇到一个空指针，那么我们可以得出这个字符串不在
    trie 中的结论。相反，如果我们到达一个叶子（分支的末端）并且从叶子回到 trie 根的路径代表我们的字符串，我们得出这个字符串存储在 trie 中的结论。
- en: Patricia Trie
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Patricia Trie
- en: '[Figure 9.6](ch09.xhtml#ch09fig6) shows the structure of a Patricia trie that
    stores words. The storage is more compact than the standard trie. Each word is
    terminated by a special null pointer.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.6**（ch09.xhtml#ch09fig6）显示了存储单词的 Patricia trie 的结构。与标准 trie 相比，存储更为紧凑。每个单词都以一个特殊的空指针终止。'
- en: '![image](Images/yuan_f09_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_06.jpg)'
- en: '**Figure 9.6** A Patricia trie storing two words'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.6** 存储两个单词的 Patricia trie'
- en: Rules for Adding a Word to the Patricia Trie
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向 Patricia Trie 添加单词的规则
- en: Patricia tries group all common characters into a single branch. Any unusual
    characters will constitute a new branch in the path. When adding a word to a Patricia
    trie, we exhaust all the characters and then add the null pointer (terminator),
    as shown in [Figure 9.7](ch09.xhtml#ch09fig7).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Patricia tries 将所有常见字符组合到一个单一分支中。任何不寻常的字符将构成路径中的新分支。当向 Patricia trie 添加一个单词时，我们耗尽所有字符，然后添加空指针（终止符），如图
    9.7 所示。
- en: '![image](Images/yuan_f09_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_07.jpg)'
- en: '**Figure 9.7** Adding a word (`*wooden*`) to the Patricia trie'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.7** 将单词（`*wooden*`）添加到 Patricia trie'
- en: Rules for Deleting a Word from the Patricia Trie
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从 Patricia Trie 中删除单词的规则
- en: This is the same as with a traditional trie, except for when deleting nodes
    (from the leaf back to the root), we must ensure that all parent nodes must be
    in possession of at least two child nodes. It is okay for a single child node
    to just have characters and a null pointer (this occurs in [Figure 9.7](ch09.xhtml#ch09fig7),
    at the end of every word). It is also okay for a single node to just have a null
    pointer (this occurs if a shorter word is contained in a longer word). See [Figure
    9.7](ch09.xhtml#ch09fig7), which illustrates how *wood* and *wooden* coexist in
    the same trie.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统字典树相同，除非是在删除节点（从叶子节点回溯到根节点）时，我们必须确保所有父节点至少拥有两个子节点。一个单独的子节点可以只包含字符和一个空指针（这种情况出现在[图9.7](ch09.xhtml#ch09fig7)的每个单词末尾），一个单独的节点也可以只有一个空指针（如果一个较短的单词包含在一个较长的单词中）。参见[图9.7](ch09.xhtml#ch09fig7)，它展示了*wood*和*wooden*如何在同一个字典树中共存。
- en: Importantly, when deleting from a trie, a path cannot be left with a parent
    node that connects to just a single child node. If this occurs (when deleting,
    we need to concatenate the appropriate characters to resolve this). This is illustrated
    in [Figure 9.8](ch09.xhtml#ch09fig8) (where we delete the word from the trie).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当从字典树中删除时，不能留下一个路径，其父节点只连接到一个子节点。如果发生这种情况（在删除时，我们需要连接适当的字符来解决此问题）。这在[图9.8](ch09.xhtml#ch09fig8)中说明（我们在字典树中删除单词）。
- en: '![image](Images/yuan_f09_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_08.jpg)'
- en: '**Figure 9.8** Deleting a word (*word*) from the Patricia trie and reorganizing
    it'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.8** 从帕特里夏字典树中删除单词(*word*)并重新组织它'
- en: Rules for Searching for a Word in the Patricia Trie
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在帕特里夏字典树中搜索单词的规则
- en: The rules for searching the Patricia trie are the same as for searching the
    standard trie.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索帕特里夏字典树的规则与搜索标准字典树的规则相同。
- en: Similarities between the Trie and Patricia Trie
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典树与帕特里夏字典树的相似之处
- en: The runtime “O” for adding is O(mN), where “m” is the length of the string we
    are adding and “N” is the size of the available alphabet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的运行时间“O”是O(mN)，其中“m”是我们正在添加的字符串的长度，“N”是可用的字母表的大小。
- en: The runtime for deleting is O(mN), where “m” is the length of the string we
    want to delete and “N” is again the size of the available alphabet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 删除的运行时间是O(mN)，其中“m”是我们想要删除的字符串的长度，“N”是可用的字母表的大小。
- en: The runtime for searching is O(m), where “m” is the length of the string we
    are searching for.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的运行时间是O(m)，其中“m”是我们正在搜索的字符串的长度。
- en: Main Difference between the Trie and Patricia Trie
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典树与帕特里夏字典树的主要区别
- en: The main advantage of using the Patricia trie is in relation to storage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用帕特里夏字典树的主要优点是与存储有关。
- en: The storage requirement “O” for the standard trie is O(MN), where “M” is the
    total length of all strings in the trie and “N” is the size of the available alphabet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标准字典树的存储需求“O”是O(MN)，其中“M”是字典树中所有字符串的总长度，“N”是可用的字母表的大小。
- en: The storage requirement “O” for the Patricia trie is O(nN+M), where “n” is the
    number of strings stored in the Patricia trie, “N” is the size of the available
    alphabet, and “M” is the total length of all strings in the trie.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 帕特里夏字典树的存储需求“O”是O(nN+M)，其中“n”是存储在帕特里夏字典树中的字符串数，“N”是可用的字母表的大小，“M”是字典树中所有字符串的总长度。
- en: In short, you will have noticed a marked difference in the depth of the tries.
    The Patricia trie is less deep (shallower). This is because of the Patricia trie’s
    ability to group common characters (and concatenate null pointers to leaves).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你将会注意到字典树的深度有明显的不同。帕特里夏字典树（Patricia trie）较浅。这是因为帕特里夏字典树能够将常见字符分组（并将空指针连接到叶子节点）。
- en: Modified Merkle Patricia Trie
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改后的Merkle Patricia字典树
- en: In the Ethereum state database, the data is stored in a modified Merkle Patricia
    trie, which means the root node of the trie is a hash of the data in its leaves.
    This design makes the state database on each node resistant to tampering, just
    like the blockchain itself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊状态数据库中，数据存储在一个修改后的Merkle Patricia字典树中，这意味着字典树的根节点是叶子中数据的哈希。这种设计使得每个节点上的状态数据库抵抗篡改，就像区块链本身一样。
- en: Every function (put, update, and delete) performed on a trie in Ethereum utilizes
    a deterministic cryptographic hash. Further, the unique cryptographic hash of
    a trie’s root node can be used as evidence that the trie has not been tampered
    with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，对字典树（trie）进行的每项功能（插入、更新和删除）都使用一个确定性的加密哈希。此外，字典树根节点的唯一加密哈希可以用作证据，证明字典树没有被篡改过。
- en: For example, any changes to a trie’s data, at any level (such as increasing
    an account’s balance), will completely change the root hash. This cryptographic
    feature provides an opportunity for light clients (devices that do not store the
    entire blockchain) to quickly and reliably query the blockchain; in other words,
    does account 0x…4857 have enough funds to complete this purchase at block height
    5044866?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对树中任何层次的数据（如增加账户余额）的任何更改都会完全改变根哈希。这一加密特性为轻客户端（不存储整个区块链的设备）提供了快速可靠地查询区块链的机会；换句话说，账户0x…4857是否有足够的资金在区块高度5044866完成这笔购买？
- en: Trie Structure in Ethereum
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊中的树结构
- en: Let’s look at the state, storage, and transaction tries in a bit more depth.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下状态树、存储树和交易树。
- en: 'State Trie : The One and Only'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态树：独一无二的一个
- en: There is one, and one only, global state trie in Ethereum. This global state
    trie is constantly updated. The state trie contains a key-value pair for every
    account that exists on the Ethereum network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中只有一个全局状态树。这个全局状态树是在不断地更新。状态树包含以太坊网络上存在的每个账户的一个键值对。
- en: The *key* is a single 160-bit identifier (the address of an Ethereum account).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键**是一个160位的唯一标识符（以太坊账户的地址）。'
- en: 'The *value* in the global state trie is created by encoding the following account
    details of an Ethereum account (using the recursive-length prefix [RLP] encoding
    method): nonce, balance, storageRoot, codeHash.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局状态树中的**值**是通过使用递归长度前缀（RLP）编码方法编码以下以太坊账户详情生成的：nonce、余额、存储根、代码哈希。
- en: The state trie’s root node (a hash of the entire state trie at a given point
    in time) is used as a secure and unique identifier for the state trie; the state
    trie’s root node is cryptographically dependent on all internal state trie data.
    The state trie’s root node is stored in the Ethereum block header corresponding
    to the time when the state trie was updated (see [Figure 9.9](ch09.xhtml#ch09fig9))
    and can be queried from the block ([Figure 9.10](ch09.xhtml#ch09fig10)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树的根节点（给定时间点整个状态树的哈希）是状态树的安全且唯一的标识符；状态树的根节点与所有内部状态树数据在密码学上有关。状态树的根节点存储在状态树更新的以太坊区块头部（见[图9.9](ch09.xhtml#ch09fig9)）并且可以从区块中查询（[图9.10](ch09.xhtml#ch09fig10)）。
- en: '![image](Images/yuan_f09_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_09.jpg)'
- en: '**Figure 9.9** Relationship between the state trie (LevelDB implementation
    of a Merkle Patricia trie) and an Ethereum block'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.9** 状态树（LevelDB实现的Merkle Patricia树）与以太坊区块之间的关系'
- en: '![image](Images/yuan_f09_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_10.jpg)'
- en: '**Figure 9.10** Showing the trie roots'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.10** 展示树根'
- en: 'Storage Trie : Where the Contract Data Lives'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储树：智能合约数据存放之处
- en: A storage trie is where all the contract data lives. Each Ethereum account has
    its own storage trie. A Keccak 256-bit hash of the storage trie’s root node is
    stored as the storageRoot value in the global state trie ([Figure 9.11](ch09.xhtml#ch09fig11)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储树是所有合约数据存放的地方。每个以太坊账户都有自己的存储树。存储树的根节点的Keccak 256位哈希作为全局状态树的存储根值存储（[图9.11](ch09.xhtml#ch09fig11)）。
- en: '![image](Images/yuan_f09_11.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_11.jpg)'
- en: '**Figure 9.11** State trie — Keccak 256-bit hash of the state trie’s root node
    stored as the stateRoot value in a given block'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.11** 状态树——状态树的根节点的Keccak 256位哈希作为给定区块的状态根值存储'
- en: 'Transaction Trie : One per Block'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易树：每个区块一个
- en: Each Ethereum block has its own separate transaction trie. A block contains
    many transactions. The order of the transactions in a block is of course decided
    by the miner who assembles the block. The path to a specific transaction in the
    transaction trie is via the RLP encoding of the index of where the transaction
    sits in the block. Mined blocks are never updated; the position of the transaction
    in a block never changes. This means that once you locate a transaction in a block’s
    transaction trie, you can return to the same path over and over to retrieve the
    same result. [Figure 9.12](ch09.xhtml#ch09fig12) shows how the transaction trie’s
    root hash is stored in an Ethereum block header.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以太坊区块都有自己的独立交易树。一个区块包含许多交易。当然，区块中交易的顺序是由组装区块的矿工决定的。在交易树中找到特定交易的路径是通过该交易在区块中的位置的RLP编码。挖出的区块永远不会被更新；交易在区块中的位置永远不会改变。这意味着一旦你在区块的交易树中找到一个交易，你可以反复回到相同的路径来获取相同的结果。**图9.12**显示了交易树的根哈希如何存储在以太坊区块头部。[图9.11](ch09.xhtml#ch09fig11)
    展示了状态树的Keccak 256位哈希作为给定区块的状态根值存储。
- en: '![image](Images/yuan_f09_12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_12.jpg)'
- en: '**Figure 9.12** The transaction trie stores data about each transaction in
    a block.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.12** 交易字典树存储了关于每个区块中交易的 data。'
- en: Concrete Examples of Tries in Ethereum
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊中字典树的具体示例
- en: The main Ethereum clients use two different database software solutions to store
    their tries. Ethereum’s Rust client, Parity, uses RocksDB. Ethereum’s Go, C++,
    and Python clients all use LevelDB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的以太坊客户端使用两种不同的数据库软件解决方案来存储它们的字典树。以太坊的Rust客户端Parity使用RocksDB。以太坊的Go、C++和Python客户端都使用LevelDB。
- en: RocksDB is out of scope for this book. Let’s explore how three out of the four
    major Ethereum clients utilize LevelDB.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: RocksDB超出了本书的范围。让我们探索三个四大以太坊客户端如何使用LevelDB。
- en: LevelDB is an open source Google key-value storage library that provides, among
    other things, forward and backward iterations over data, ordered mapping from
    string keys to string values, custom comparison functions, and automatic compression.
    The data is automatically compressed using Snappy, an open source Google compression/decompression
    library. While Snappy does not aim for maximum compression, it aims for very high
    speeds. LevelDB is an important storage and retrieval mechanism that manages the
    state of the Ethereum network. As such, LevelDB is a dependency for the most popular
    Ethereum clients (nodes) such as go-ethereum, cpp-ethereum, and pyethereum.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB是一个开源的Google键值存储库，提供诸如正向和反向迭代数据、按字符串键到字符串值的有序映射、自定义比较函数和自动压缩等功能。数据使用Snappy，一个开源的Google压缩/解压缩库自动压缩。虽然Snappy不追求最大压缩率，但它追求非常高的速度。LevelDB是管理以太坊网络状态的重要存储和检索机制。因此，LevelDB是最受欢迎的以太坊客户端（节点）如go-ethereum、cpp-ethereum和pyethereum的依赖。
- en: '**Note**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: While the implementation of the trie data structure can be done on disk (using
    database software such as LevelDB), it is important to note that there is a difference
    between traversing a trie and simply looking at the flat key-value database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在磁盘上实现字典树数据结构（使用如LevelDB的数据库软件），但重要的是要注意遍历字典树和简单查看扁平键值数据库之间是有区别的。
- en: To learn more, we have to access the data in LevelDB using the appropriate Patricia
    trie libraries. To do this, we will need an Ethereum installation (see [Chapter
    5](ch05.xhtml#ch05)). Once you have set up your Ethereum private network, you
    will be able to execute transactions and explore how Ethereum’s state responds
    to network activities such as transactions, contracts, and mining. In the next
    section, I will provide code examples and screen captures from an Ethereum private
    network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多内容，我们需要使用适当的Patricia字典树库来访问LevelDB中的数据。为此，我们需要一个以太坊安装（参见[第5章](ch05.xhtml#ch05)）。一旦你设置好了你的以太坊私有网络，你将能够执行交易并探索以太坊状态如何响应网络活动，如交易、合约和挖矿。在下一节中，我将提供来自以太坊私有网络的代码示例和屏幕截图。
- en: Analyzing the Ethereum Database
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析以太坊数据库
- en: 'As mentioned previously, there are many Merkle Patricia tries (referenced in
    each block) within the Ethereum blockchain: state trie, storage trie, transaction
    trie, and receipts trie.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，以太坊区块链中有许多Merkle Patricia字典树（在每个块中都有引用）：状态字典树、存储字典树、交易字典树和收据字典树。
- en: 'To reference a particular Merkle Patricia trie in a particular block, we need
    to obtain its root hash as a reference. The following commands allow us to obtain
    the root hashes of the state, transaction, and receipt tries in the genesis block:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用特定块中的特定Merkle Patricia字典树，我们需要获取其根哈希作为引用。以下命令允许我们获取创世区块中状态、交易和收据字典树的根哈希：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_1)'
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want the root hashes of the latest block (instead of the genesis block),
    please use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要最新块的根哈希（而不是创世块），请使用以下命令：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_2)'
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be using a combination of the `nodejs`, `level`, and `ethereumjs` commands
    (which implements Ethereum’s VM in JavaScript) to inspect the LevelDB database.
    The following commands will further prepare our environment (in Ubuntu Linux):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nodejs`、`level`和`ethereumjs`命令（其中实现了以太坊的虚拟机JS）来检查LevelDB数据库。以下命令将进一步准备我们的环境（在Ubuntu
    Linux中）：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_3)'
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Get the Data
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取数据
- en: From this point, running the following code will print a list of the Ethereum
    account keys (which are stored in the state root of your Ethereum private network).
    The code connects to Ethereum’s LevelDB database, enters Ethereum’s world state
    (using a stateRoot value from a block in the blockchain), and then accesses the
    keys to all accounts on the Ethereum private network ([Figure 9.13](ch09.xhtml#ch09fig13)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，运行以下代码将会打印出以太坊账户密钥的列表（这些密钥存储在以太坊私有网络的状态根中）。该代码连接到以太坊的LevelDB数据库，进入以太坊的世界状态（使用区块链中区块的状态根值），然后访问以太坊私有网络中所有账户的密钥（[图9.13](ch09.xhtml#ch09fig13)）。
- en: '![image](Images/yuan_f09_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_13.jpg)'
- en: '**Figure 9.13** Raw data read from the trie in LevelDB'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.13** 从LevelDB中读取的三叉状态数据'
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_4)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_4)'
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Note**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Interestingly, accounts in Ethereum are added to the state trie only once a
    transaction has taken place (in relation to that specific account). For example,
    just creating a new account using `geth account new` will not include that account
    in the state trie, even after many blocks have been mined. However, if a successful
    transaction (one that costs gas and is included in a mined block) is recorded
    against that account, then and only then will that account appear in the state
    trie. This is clever logic that protects against malicious attackers continuously
    creating new accounts and bloating the state trie.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，以太坊账户仅在发生交易时（与特定账户有关）才会添加到状态树中。例如，仅仅使用`geth account new`创建新账户并不会将该账户包含在状态树中，即使已经挖出了很多区块。然而，只有在针对该账户记录了成功的交易（消耗了燃料并且被包含在挖出的区块中）时，该账户才会出现在状态树中。这是一种巧妙的逻辑，可以防止恶意攻击者持续创建新账户并膨胀状态树。
- en: Decoding the Data
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解码数据
- en: You will have noticed that querying LevelDB returns encoded results. This is
    because Ethereum uses its own specially modified Merkle Patricia trie implementation
    when interacting with LevelDB. The Ethereum wiki provides information about the
    design and implementation of both Ethereum’s modified Merkle Patricia trie and
    RLP encoding. In short, Ethereum has extended the trie data structures described
    earlier. For example, the modified Merkle Patricia trie contains a method that
    can shortcut the descent (down the trie) through the use of an extension node.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，查询LevelDB返回的是编码结果。这是因为以太坊在与LevelDB交互时使用了其自己的特殊修改Merkle Patricia尝试实现。以太坊维基提供了关于以太坊修改Merkle
    Patricia尝试和RLP编码的设计和实现的信息。简而言之，以太坊扩展了之前描述的尝试数据结构。例如，修改后的Merkle Patricia尝试包含一个可以通过扩展节点缩短（在尝试中下降）的方法。
- en: 'In Ethereum, a single modified Merkle Patricia trie node is one of the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，单个修改后的Merkle Patricia尝试节点是以下之一：
- en: An empty string (referred to as NULL)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串（称为NULL）
- en: An array that contains 17 items (referred to as a *branch*)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含17个项目的数组（称为*分支*）
- en: An array that contains two items (referred to as a *leaf* )
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个项目的数组（称为*叶节点*）
- en: An array that contains two items (referred to as an *extension*)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个项目的数组（称为*扩展节点*）
- en: 'As Ethereum’s tries are designed and constructed with rigid rules, the best
    way to inspect them is through the use of computer code. The following example
    uses ethereum.js. The following code (when provided with a particular block’s
    stateRoot as well as an Ethereum account address) will return that account’s correct
    balance in a human-readable form ([Figure 9.14](ch09.xhtml#ch09fig14)):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊的尝试树是按照严格的规则设计和构建的，检查它们的最佳方式是使用计算机代码。以下示例使用ethereum.js。以下代码（在提供特定块的状态根以及以太坊账户地址时）将以人类可读的形式返回该账户的正确余额：[图9.14](ch09.xhtml#ch09fig14)：
- en: '![image](Images/yuan_f09_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_14.jpg)'
- en: '**Figure 9.14** The decoded results'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.14** 解码结果'
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_5)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_5)'
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Read and Write the State LevelDB
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**读写状态层级的LevelDB**'
- en: 'So far, I have shown how to access the Ethereum state’s LevelDB database using
    JavaScript on a local node. If you are familiar with GO and can work with Ethereum
    source code, there is an easier way. You could just import the go-ethereum source
    code in GO and call its functions to read and even modify the LevelDB database.
    The write function will not only change the values in the nodes but also update
    the root hash to reflect the changes. Specifically, the functions are in the following
    source code file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了如何使用本地节点上的JavaScript访问以太坊状态的LevelDB数据库。如果你熟悉GO并且能够处理以太坊源代码，还有更简单的方法。你可以直接导入GO中的go-ethereum源代码，并调用其函数来读取甚至修改LevelDB数据库。写入函数不仅会更改节点中的值，还会更新根哈希以反映变化。具体来说，这些函数在以下源代码文件中：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_6)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_6)'
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It contains methods such as `GetBalance`, `AddBalance`, `SubBalance`, and `SetBalance`
    to operate on the account balances. However, changing the state LevelDB in this
    way will change the data on only one node and will likely cause this node to go
    out of sync with the rest of the nodes on the network. The right way to change
    the state is to follow how go-ethereum processes a transaction and records it
    on the blockchain. That is out of scope for this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含诸如`GetBalance`、`AddBalance`、`SubBalance`和`SetBalance`的方法来操作账户余额。然而，以这种方式更改状态LevelDB只会改变一个节点的数据，并且很可能导致这个节点与网络上其他节点脱节。更改状态的正确方法是遵循go-ethereum处理交易并将其记录在区块链上的方式。这超出了本书的范围。
- en: Conclusion
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I demonstrated that Ethereum has the ability to manage its
    state. This clever up-front design has many advantages, allowing for light clients
    and many different kinds of dapps that do not need to run the entire blockchain.
    It is important to understand the inner workings of Ethereum to write great smart
    contracts and applications on the Ethereum platform.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了以太坊能够管理其状态。这种巧妙的预先设计有许多优点，允许轻量级客户端和许多不同类型的不需要运行整个区块链的DApps。理解以太坊的内部工作对于在以太坊平台上编写优秀的智能合约和应用非常重要。
- en: 10. Blockchain Data Services
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10. 区块链数据服务
- en: The previous chapter explained how the blockchain stores state data in block-based
    databases. The data is organized into a tree structure, and each block has a timestamp.
    This structure makes it easy to add new data (new blocks) and almost impossible
    to delete or change anything in old blocks, hence securing the blockchain data.
    However, while you can easily list each block’s content (i.e., transactions),
    it is hard to get longitudinal or aggregated views of the blockchain state. As
    a result, it is hard to search the blockchain data based on an address or specific
    actions performed by an address. Yet, many blockchain applications require the
    capability to search and analyze blockchain data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章解释了区块链如何将状态数据存储在基于块的数据库中。数据被组织成树状结构，每个块都有一个时间戳。这种结构使得添加新数据（新块）变得容易，几乎不可能删除或更改旧块中的任何内容，从而保障了区块链数据的安全。然而，虽然你可以轻松列出每个块的内容（即，交易），但要获取区块链状态的纵向或聚合视图却很困难。因此，根据地址或地址执行的特定动作来搜索区块链数据变得困难。然而，许多区块链应用需要能够搜索和分析区块链数据的能力。
- en: A common design pattern for dapps is to call `view` functions in smart contracts
    to query data stored in the contract. However, such an approach is hard to scale
    since you need a full blockchain node to execute every `view` request, and the
    data query is limited by the data structure supported by the smart contract (i.e.,
    no SQL or JSON queries). By harvesting smart contract data into a data warehouse
    and enabling rich queries on the data warehouse, we could potentially build much
    more complex and scalable dapps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的去中心化应用（DApps）设计模式是调用智能合约中的`view`函数来查询存储在合约中的数据。然而，这种方法难以扩展，因为你需要一个完整的区块链节点来执行每一个`view`请求，而且数据查询受限于智能合约支持的数据结构（即，不支持SQL或JSON查询）。通过将智能合约数据收割至数据仓库，并使数据仓库支持丰富的查询，我们可能构建出更加复杂和可扩展的DApps。
- en: In this chapter, I discuss how to build normalized databases for blockchain
    data so that they can be easily searched, analyzed, and browsed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了如何为区块链数据构建规范化数据库，以便它们可以被轻松搜索、分析和浏览。
- en: Blockchain Explorers
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链浏览器
- en: Almost every blockchain requires a data explorer so that users can search and
    browse transactions and account addresses on the blockchain. The blockchain explorers
    and the data services they provide are now part of standard infrastructure for
    every blockchain project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个区块链都需要一个数据浏览器，这样用户就可以在区块链上搜索和浏览交易和账户地址。区块链浏览器及其提供的数据服务现在已经成为了每个区块链项目标准的基础设施。
- en: For Bitcoin and compatible Bitcoin Cash (BCH) blockchains, there are many, including
    [https://explorer.bitcoin.com/btc](https://explorer.bitcoin.com/btc) and [https://btc.com/](https://btc.com/).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于比特币和兼容的比特币现金 (BCH) 区块链，还有很多，包括 [https://explorer.bitcoin.com/btc](https://explorer.bitcoin.com/btc)
    和 [https://btc.com/](https://btc.com/)。
- en: For the Ethereum blockchain, the most well-known one is [https://etherscan.io/](https://etherscan.io/).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于以太坊区块链，最知名的是 [https://etherscan.io/](https://etherscan.io/)。
- en: For the EOS blockchain, there are [https://bloks.io/](https://bloks.io/) and
    [https://eospark.com/](https://eospark.com/), among others.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 EOS 区块链，还有 [https://bloks.io/](https://bloks.io/) 和 [https://eospark.com/](https://eospark.com/)
    等。
- en: For the CyberMiles blockchain, there is [https://www.cmttracking.io/](https://www.cmttracking.io/).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于千米iles 区块链，有一个 [https://www.cmttracking.io/](https://www.cmttracking.io/)。
- en: Each blockchain explorer provides information that is specific to its blockchain.
    For example, explorers for proof-of-work (PoW) blockchains like Bitcoin and Ethereum
    provide information such as hash rate and mining awards. Explorers for delegated
    proof-of-stake (PoS) blockchains like EOS and CyberMiles provide information such
    as block producer/validator nodes, voting power, and inflation awards. Explorers
    for smart contract platforms such as Ethereum, EOS, and CyberMiles provide information
    about smart contracts as well as assets held or issued by those smart contracts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块链浏览器都提供与其区块链相关的特定信息。例如，比特币和以太坊等 PoW 区块链的浏览器提供诸如哈希率和挖矿奖励等信息。EOS 和千米iles 等委派
    PoS 区块链的浏览器提供诸如区块生产者/验证节点、投票权和通胀奖励等信息。以太坊、EOS 和千米iles 等智能合约平台的浏览器也提供智能合约以及那些智能合约持有或发行的资产的信息。
- en: '[Figure 10.1](ch10.xhtml#ch10fig1), [Figure 10.2](ch10.xhtml#ch10fig2), and
    [Figure 10.3](ch10.xhtml#ch10fig3) show screenshots from Etherscan. They provide
    insights into the global state, transactions, and smart contracts on the Ethereum
    blockchain. [Figures 10.4](ch10.xhtml#ch10fig4) and [10.5](ch10.xhtml#ch10fig5)
    illustrate how the CMTTracking web site provides delegated PoS information for
    the CyberMiles blockchain in real time. Such information is not applicable for
    the Ethereum blockchain, as Ethereum uses PoW mining for consensus.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1([Figure 10.1](ch10.xhtml#ch10fig1)), 图 10.2([Figure 10.2](ch10.xhtml#ch10fig2)),
    和 图 10.3([Figure 10.3](ch10.xhtml#ch10fig3)) 展示了以太坊浏览器的截图。它们提供了关于以太坊区块链上的全局状态、交易和智能合约的洞察。图
    10.4([Figures 10.4](ch10.xhtml#ch10fig4)) 和 10.5([10.5](ch10.xhtml#ch10fig5))
    说明了 CMTTracking 网站如何实时为千米iles 区块链提供委派 PoS 信息。这些信息对于以太坊区块链不适用，因为以太坊使用 PoW 挖矿进行共识。
- en: '![image](Images/yuan_f10_01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_01.jpg)'
- en: '**Figure 10.1** Etherscan front page with pricing information, mining information,
    and recent blocks'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.1** 以太坊浏览器首页，带有定价信息、挖矿信息以及最近区块'
- en: '![image](Images/yuan_f10_02.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_02.jpg)'
- en: '**Figure 10.2** Etherscan page for an account and its transactions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.2** 以太坊浏览器中一个账户及其交易页面'
- en: '![image](Images/yuan_f10_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_03.jpg)'
- en: '**Figure 10.3** Etherscan page for a smart contract that issues an ERC20 asset'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.3** 以太坊浏览器中一个发行 ERC20 资产的智能合约页面'
- en: '![image](Images/yuan_f10_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_04.jpg)'
- en: '**Figure 10.4** CMTTracking page for CyberMiles validator nodes, their status,
    voting power, and compensation rate for people who stake in them'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.4** CMTTracking 页面，用于千米iles 验证节点，其状态、投票权以及人们投注它们的补偿率'
- en: '![image](Images/yuan_f10_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_05.jpg)'
- en: '**Figure 10.5** CMTTracking page showing validator information, stakes, and
    awards'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.5** CMTTracking 页面，展示验证者信息、投注以及奖励'
- en: The explorer can also provide off-chain information related to the crypto assets
    on the blockchain. For example, it could provide the current pricing, trading
    volume, and market cap for the crypto assets. It could associate blockchain accounts
    and smart contracts with identities in the real world. It could monitor accounts
    belonging to key ecosystem players, such as exchanges and super nodes to detect
    and report trading signals. Those data services are of broad interest from users,
    traders, investors, and government regulators.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器还可以提供与区块链上的加密资产相关的链下信息。例如，它可以提供加密资产的当前定价、交易量和市值。它可以将区块链账户和智能合约与现实世界中的身份关联。它可以监控属于关键生态系统参与者的账户，如交易所和超级节点，以检测和报告交易信号。这些数据服务对用户、交易员、投资者和政府监管机构具有广泛的兴趣。
- en: Those explorers, especially open source explorers, are also decentralized applications.
    Everyone with the source code can deploy their own explorer service. All the data
    is from the blockchain and other distributed sources, such as pricing aggregators.
    There is no single point of failure to shut down the explorer software.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些浏览器，尤其是开源浏览器，也是去中心化应用程序。拥有源代码的每个人都可以部署自己的浏览器服务。所有数据都来自区块链和其他分布式来源，如定价聚合器。没有单一的失败点来关闭浏览器软件。
- en: '[Figure 10.6](ch10.xhtml#ch10fig6) illustrates the overall architecture of
    a typical blockchain explorer. It consists of a harvester and a query interface.
    The harvester retrieves data from the blockchain, normalizes it, associates individual
    records with off-chain sources, and then saves the data in a database. The query
    interface provides a search engine and visualization tools to chart the data.
    It could also support API services for automated queries.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.6](ch10.xhtml#ch10fig6) 展示了典型区块链浏览器整体架构。它包括一个收割器和一个查询接口。收割器从区块链检索数据，对其进行标准化，将个别记录与链下来源关联，然后将数据保存到数据库中。查询接口提供搜索引擎和可视化工具来绘制数据。它还可以支持
    API 服务以实现自动化查询。'
- en: '![image](Images/yuan_f10_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_06.jpg)'
- en: '**Figure 10.6** The blockchain data explorer architecture view'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.6** 区块链数据浏览器架构视图'
- en: In the next sections, I will go into the technology stacks of the blockchain
    explorer software and discuss how you might improve existing explorers and develop
    specialized data services for your own applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将深入探讨区块链浏览器软件的技术堆栈，并讨论你如何可能改进现有的浏览器并为你自己的应用程序开发专业的数据服务。
- en: Harvesting Data
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收割数据
- en: The harvester application must have access to a full blockchain node. This is
    a node that contains the entire blockchain history data from the genesis block
    to the current head, not just the current account states. The node runs continuously
    and stays in sync with the blockchain’s current head block. I recommend you run
    and sync a full node yourself just for the harvester to use since the harvester’s
    data quality depends on the availability of the node. With your own node, the
    harvester could also potentially access the databases inside the blockchain software
    to directly extract data as opposed to going through the blockchain’s Remote Procedure
    Call (RPC) service interface. [Figure 10.7](ch10.xhtml#ch10fig7) illustrates the
    architecture of the harvester.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器应用程序必须能够访问一个完整的区块链节点。这是一个包含从创世区块到当前区块的全部区块链历史数据的节点，而不仅仅是当前账户状态。该节点持续运行并与区块链当前的头部区块保持同步。我建议你自己运行并同步一个完整的节点，仅为收割器使用，因为收割器的数据质量取决于节点的可用性。有了你自己的节点，收割器还可以潜在地访问区块链软件内的数据库，直接提取数据，而不是通过区块链的远程过程调用（RPC）服务接口。
    [图 10.7](ch10.xhtml#ch10fig7) 展示了收割器的架构。
- en: '![image](Images/yuan_f10_07.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_07.jpg)'
- en: '**Figure 10.7** The blockchain data harvester'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.7** 区块链数据收割器'
- en: The key component in the harvester is a scheduler. It runs every few seconds
    to retrieve information from the blockchain node. The scheduler’s running time
    interval should be shorter than the block time to make sure that it always gets
    the latest block information. There are a variety of technology choices for the
    scheduler.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器的关键组件是一个调度器。它每隔几秒钟运行一次，从区块链节点检索信息。调度器的运行时间间隔应短于区块时间，以确保它总是获取最新的区块信息。调度器有多种技术选择。
- en: For Linux-based systems, you can use cron jobs to run the harvester application
    in fixed intervals.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于 Linux 的系统，你可以使用 cron 作业以固定的间隔运行收割器应用程序。
- en: If the harvester is a Java application, you can use the Quartz Scheduler to
    run worker jobs at fixed intervals ([www.quartz-scheduler.org/](http://www.quartz-scheduler.org/)).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收割机是一个Java应用程序，你可以使用Quartz调度程序以固定间隔运行工作作业(['www.quartz-scheduler.org/'](http://www.quartz-scheduler.org/))。
- en: If the harvester is a node.js JavaScript application, you can use the egg.js
    framework for scheduled workloads ([https://eggjs.org/](https://eggjs.org/)).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收割机是一个node.js JavaScript应用程序，你可以使用egg.js框架来进行计划任务(['https://eggjs.org/'](https://eggjs.org/))。
- en: The scheduler runs a workload to retrieve data through the following means.
    You could build each of them into a connector that plugs into the harvester.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序通过以下方式运行工作负载以检索数据。你可以将每个功能构建成一个连接器，使其能够插入到收割机中。
- en: '*RPC connector to the node*: For Ethereum-compatible blockchains (e.g., CyberMiles),
    this is the RPC service available via port 8545\. This connector is typically
    done through a web3-compatible library.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到节点的RPC连接器**：对于与以太坊兼容的区块链（例如，CyberMiles），这是通过端口8545提供的RPC服务。此连接器通常是通过一个与web3兼容的库来完成的。'
- en: '*Database connector to LevelDB*: This is used to directly access the databases
    on the node to read data that is potentially not available (or too cumbersome)
    from the RPC connector.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到LevelDB的数据库连接器**：此功能用于直接访问节点上的数据库，以读取通过RPC连接器无法获取（或太繁琐）的数据。'
- en: '*Web services connectors*: This is used to access external services such as
    pricing and market intelligence data from the CoinMarketCap API ([https://coinmarketcap.com/api/](https://coinmarketcap.com/api/)).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务连接器**：此功能用于访问来自CoinMarketCap API（[''https://coinmarketcap.com/api/''](https://coinmarketcap.com/api/)）等外部服务如定价和市场情报数据。'
- en: '*Local database connectors*: This is used to access potentially proprietary
    data stored on the harvester’s local servers. Examples include proprietary databases
    that associate blockchain accounts with names, entities, and exchanges, including
    known criminals.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地数据库连接器**：此功能用于访问收割机本地服务器上存储的可能具有专利性质的数据。例如，包括将区块链账户与名称、实体和交易所关联的专利数据库，其中包括已知的罪犯。'
- en: Once the data for each block is retrieved from the connectors, the harvester
    runs a data warehouse operation to combine, clean, and normalize the data. The
    data is organized into a set of logical schema and saved.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从连接器中检索出每个块的数据，收割机就会运行数据仓库操作来组合、清洗和规范化数据。数据被组织成一套逻辑模式并保存。
- en: Structured results such as blocks, accounts, and transactions can be saved into
    a relational database with well-defined schema to ensure data integrity and query
    efficiency.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有区块、账户和交易等结构化结果可以保存在具有明确模式的关系型数据库中，以确保数据完整性和查询效率。
- en: Unstructured data such as events generated from smart contracts or bytecodes
    and hashes can be saved on NoSQL document stores such as MongoDB and Cassandra.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如来自智能合约或字节码和散列的无结构数据可以保存在MongoDB和Cassandra等NoSQL文档存储上。
- en: '**Note**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Google Blockchain ETL is a fully integrated blockchain data warehousing
    solution. It uses the Google Cloud Composer to orchestrate the harvesting process.
    It starts by making RPC requests to export blockchain data into comma-separated
    value (CSV) files and then loads the CSV files into the Google BigQuery table.
    The data can then be queried from BigQuery. The drawback, however, is that it
    is not a real-time solution. The data is harvested and ingested every 24 hours.
    And it relies on the Google Cloud infrastructure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌区块链ETL是一个完全集成的区块链数据仓库解决方案。它使用Google Cloud Composer来编排收割过程。它首先通过发起RPC请求将区块链数据导出为逗号分隔值（CSV）文件，然后将CSV文件加载到Google
    BigQuery表中。然后可以从BigQuery查询数据。然而，它的缺点不是实时解决方案。数据每24小时收割和摄入一次。并且依赖于Google Cloud基础设施。
- en: In the rest of this section, we look into various data types the harvester can
    collect and normalize for later queries.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文节的剩余部分，我们探讨了收割机可以收集和规范化的各种数据类型，以供以后查询。
- en: Transactions and Accounts
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易和账户
- en: Most blockchain platforms provide standard RPC interfaces to get a list of transactions
    by block height. From there, the harvester can get details from each transaction,
    including the from/to accounts, transfer amount, gas amount, success status, and
    data associated with the transaction, such as smart contract function calls.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数区块链平台提供标准RPC接口，通过区块高度获取交易列表。从那里，收割机可以获取每个交易的详细信息，包括发件人/收件人账户、转账金额、燃料金额、成功状态以及与交易相关的信息，例如智能合约函数调用。
- en: All those data elements are highly structured. They can be normalized into a
    relational database with account addresses acting as keys. For example, we could
    query all transactions from and to a specific account. The harvester application
    could perform internal data integrity checks by adding up all the transactions
    for each account and compare them with the account balances reported by the blockchain
    RPC.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据元素都高度结构化。它们可以被规范化到以账户地址作为键的关系数据库中。例如，我们可以查询特定账户的所有交易。收割应用程序可以通过将每个账户的所有交易相加，并与区块链RPC报告的账户余额进行比较，执行内部数据完整性检查。
- en: Awards
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 奖项
- en: Most blockchains also “create” crypto tokens over time to award entities that
    run computer servers to secure the blockchain network. That is called *block awards*.
    For (PoW) blockchains, miners compete for the right to create the next block.
    The winner is awarded certain amounts of tokens. For various PoS blockchains,
    including delegated proof-of-stake (DPoS) blockchains, the validators or block
    producers were assigned duties to produce the next block while all other nodes
    validate and agree on the block’s content. The block award goes to the block producer
    or is divided according to stake or voting power.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数区块链还“创建”加密货币代币，以奖励运行计算机服务器以确保区块链网络安全的实体。这称为*区块奖励*。对于（PoW）区块链，矿工争夺创建下一个区块的权利。胜者获得一定数量的代币。对于各种PoS区块链，包括委托权益证明（DPoS）区块链，验证人或区块生产者被分配产生下一个区块的任务，而所有其他节点验证并同意区块内容。区块奖励归区块生产者所有，或根据股份或投票权进行分配。
- en: The harvester needs to understand the algorithm to distribute block awards and
    creates database entries for such events indexed by account addresses. This data
    is also highly structural and relational. The harvester can verify its computed
    block awards distribution against account balances from the blockchain itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器需要理解分配区块奖励的算法，并为这些事件创建数据库条目，这些事件按账户地址索引。这些数据也是高度结构化和相关的。收割器可以将其计算的区块奖励分布与区块链本身报告的账户余额进行验证。
- en: Off-Chain Identities
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链下身份
- en: A key use case of the blockchain data service is to understand the flow and
    exchange of digital assets. It is often important to associate a blockchain address
    with real-world entities that hold its private key. Since blockchain transactions
    are transparent, once you know the real identity of an address, it is often possible
    to figure out the identity of any addresses that ever transferred in and out of
    the known address.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据服务的一个关键用例是理解数字资产的流动和交换。通常，将区块链地址与持有其私钥的实体经济体关联是非常重要的。由于区块链交易是透明的，一旦你知道了一个地址的真实身份，通常可能推断出与已知地址有过交易的任何地址的身份。
- en: '**Note**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The only “anonymous” addresses on blockchain are miner accounts from PoW blockchains.
    However, once a miner starts to spend or exchange tokens with known addresses,
    the miner’s identity could be revealed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链上唯一的“匿名”地址是来自PoW区块链的矿工账户。然而，一旦矿工开始与已知地址花费或交换代币，矿工的身份可能会被揭露。
- en: The association between off-chain entities and blockchain addresses can come
    from multiple sources.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链地址与链下实体之间的关联可以来自多个来源。
- en: '*Data sharing agreement with crypto exchanges*: Most crypto exchanges require
    know your customer (KYC) checks for all their users. They have broad reach and
    knowledge of blockchain account address ownership as users deposit and withdraw
    tokens from or into their own addresses.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与加密货币交易所的*数据共享协议*：大多数加密货币交易所要求对其所有用户进行了解你的客户（KYC）检查。他们广泛接触并了解区块链账户地址的所有权，因为用户将代币存入或从他们自己的地址中提取。
- en: '*Data sharing agreement with initial coin offering (ICO) projects*: Many ICO
    projects conduct KYC checks for all their initial contributors. They have knowledge
    of each contributor’s source and deposit addresses.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与初始代币发行（ICO）项目的*数据共享协议*：许多ICO项目对其所有初始贡献者进行KYC检查。他们知道每位贡献者的来源和存款地址。
- en: '*Data sharing agreement with crypto payment processors and e-commerce merchants*:
    When users use crypto tokens to pay for goods and services in the real world,
    they leave a trail that we can follow (e.g., shipping address) to determine the
    identity of the accounts related to the real-world transaction.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与加密货币支付处理器和电子商务商家的*数据共享协议*：当用户在现实生活中使用加密货币代币支付商品和服务时，他们留下了我们可以追踪的线索（例如，送货地址），以确定与现实世界交易相关的账户身份。
- en: '*Data mining from social media*: When crypto projects run marketing campaigns,
    it often provides airdrops to followers on social media. Such airdrops require
    users’ addresses.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社交媒体数据挖掘*：当加密项目运行市场营销活动时，通常会在社交媒体上向关注者提供空投。这样的空投需要用户的地址。'
- en: While the association between blockchain addresses and their off-chain owners’
    identities is structured and relational, the transactions linking one blockchain
    address to the next are not relational. The harvester could put the known address
    associations into a relational database and put connected transactions into a
    graph database, such as Neo4j, for further analysis and queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区块链地址与链下所有者身份之间是结构化和有关系的，但连接一个区块链地址到下一个地址的交易并不是有关系的。收割者可以将已知的地址关联放入关系数据库中，将相关的交易放入图数据库，如Neo4j，进行进一步分析和查询。
- en: '**Note**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Monitoring known exchange addresses and large token holders’ addresses can help
    you predict market movements. For example, if a large account holder withdraws
    his stake at a DPoS block producer/validator and moves the tokens to an exchange
    account, you can anticipate increased selling pressure in the near future.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 监控已知的交易所地址和大代币持有者的地址可以帮助你预测市场动向。例如，如果一个大账户持有者在DPoS区块生产者/验证者处提取他的股份，并将代币转移到交易所账户，你可以预测未来不久将会有增加的卖压。
- en: Inside Smart Contracts
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 智能合约内部
- en: Ethereum-compatible blockchains are foremost smart contract platforms. The smart
    contract bytecode and their data structure can be arbitrary. Hence, smart contract
    data is unstructured, and it has been difficult to track the function execution
    and state changes in the blockchain.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊兼容的区块链主要是智能合约平台。智能合约的字节码和数据结构可以是任意的。因此，智能合约数据是无结构的，并且一直难以追踪区块链中的函数执行和状态变化。
- en: '**Note**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Etherscan and other Ethereum-compatible blockchain explorers have long provided
    the ability to verify user/community-submitted smart contract source code against
    its bytecode on the blockchain. That helps the community verify that the source
    code and behavior of such contracts are indeed as advertised. But, this method
    provides no insights into the execution of functions and data inside the smart
    contracts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊兼容的区块链浏览器，如Etherscan，长期以来一直提供了一种能力，即验证用户/社区提交的智能合约源代码与其在区块链上的字节码是否一致。这帮助社区确认智能合约的源代码和行为确实如宣传所言。但是，这种方法并没有提供关于智能合约内部函数执行和数据情况的洞察。
- en: A smart contract can write permanent data to the blockchain by declaring and
    then emitting an event. Emitted event log data will remain intact indefinitely,
    even if that particular smart contract and its global state have been completely
    removed using the previously mentioned opcode `0xff`, known as *self-destruct*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以通过声明并发射一个事件，将永久数据写入区块链。发射的事件日志数据将永久保持，即使那个特定的智能合约及其全局状态已经被完全移除，使用前面提到的操作码`0xff`，也就是*自毁*。
- en: '**Note**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The cost of writing to event logs is comparatively cheaper than writing to the
    blockchain’s global state. For example, it costs around 40,000 gas to write a
    single address and a single uint to the blockchain’s state. Alternatively, it
    costs only about 1,000 gas to write that same single address and uint to the blockchain’s
    event logs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 写入事件日志的成本相对于写入区块链全局状态的成本要低得多。例如，将一个地址和一个uint写入区块链状态的成本大约为40,000个气（Gas）。或者，将同样的地址和uint写入区块链事件日志的成本仅约为1,000个气。
- en: 'The following example in Solidity (and Lity) shows how to define an event in
    your smart contract:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Solidity（和Lity）中的示例，展示了如何在您的智能合约中定义一个事件：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_1)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_1)'
- en: '[PRE6]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, to declare the event, we simply type the word `event` followed
    by the name of the event. Then we pass in some data types and data names (in this
    case, the data types of `address` and `uint256`, which relate to the data names
    `endUser` and `amount`, respectively).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，要声明事件，我们只需输入单词`event`，后跟事件的名称。然后我们传递一些数据类型和数据名称（在这个例子中，`address`和`uint256`的数据类型，分别与`endUser`和`amount`的数据名称相关）。
- en: You will notice that we have deliberately specified, in this declaration, that
    the `endUser` data be indexed. Essentially, indexing a parameter allows for efficient
    searching later. Up to three parameters per event declaration can be indexed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在这个声明中故意指定了`endUser`数据要被索引。本质上，索引参数允许以后进行有效搜索。每个事件声明最多可以索引三个参数。
- en: 'It is wise to index data, such as account addresses, because it’s likely that
    you will be searching for information based on a particular account address. It
    is not a great idea to index other types of data, such as arbitrary amounts (i.e.,
    integers such as 1 or 10). It is completely unnecessary to include (in your event
    logs) any information that can be easily retrieved using predefined global variables
    or functions (e.g., `block.number`). Variables like `block.number` are included
    in standard transaction receipts by default. Let’s now emit the event declared
    earlier, as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为诸如账户地址之类的数据建立索引是明智的，因为你很可能需要根据特定的账户地址搜索信息。索引其他类型的数据（例如任意数量，即整数如1或10）并不是一个好主意。在事件日志中包含任何可以通过预定义的全局变量或函数（例如`block.number`）轻松检索的信息是完全不必要的。像`block.number`这样的变量默认包含在标准交易收据中。现在让我们发出之前声明的事件，如下所示：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_2)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_2)'
- en: '[PRE7]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from the previous code, to emit an event, you simply type `emit`
    followed by the name of the event (which was declared in the previous code snippet).
    The data to be included in the event log is passed in during a function’s execution.
    The order in which data is passed into the `emit` command must match the order
    of the data, as shown in the event declaration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码中，你可以看到，要发出一个事件，你只需输入`emit`，后面跟着事件的名称（这个名称在之前的代码片段中声明）。事件日志中要包含的数据在函数执行期间传递。传递到`emit`命令中的数据的顺序必须与事件声明中的数据顺序一致。
- en: 'The following code shows the entire smart contract, thereby providing context
    for the previous snippets:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了整个智能合约，从而为之前的片段提供了上下文：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_3)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_3)'
- en: '[PRE8]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, every time a user calls the `addPoints()` function on this contract, the
    `pointBalanceUpdated` event is emitted. The event is recorded in transaction receipts
    when you query a transaction via RPC. In fact, the web3 library provides an even
    easier way to query past events, as shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户调用这个合约上的`addPoints()`函数时，就会触发`pointBalanceUpdated`事件。当你通过RPC查询交易时，事件会被记录在交易收据中。实际上，web3库提供了查询过去事件的一种更为简便的方式，如下所示：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_4)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_4)'
- en: '[PRE9]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The harvester receives JSON objects in the `events` array in the previous code.
    Each event JSON object looks like the following. Please note that I’m showing
    a more complex event from the Uniswap exchange deployed on the CyberMiles blockchain
    here, as opposed to the simple event described earlier.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器接收的是`events`数组中的JSON对象，如之前的代码所示。每个事件JSON对象看起来如下。请注意，我这里展示的是一个比之前描述的简单事件更为复杂的Uniswap交易所事件，该事件部署在CyberMiles区块链上。
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_5)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_5)'
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The JavaScript Object Notation (JSON) object can be deconstructed and saved
    into a relational database. Or, it can be saved directly into a JSON-aware document
    store for future queries. In this way, we can now harvest data directly from inside
    smart contract function calls.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象表示法（JSON）对象可以被解构并保存到关系数据库中。或者，它可以直接保存到支持JSON的文档存储中以供将来查询。这样，我们就可以现在从智能合约函数调用中直接收割数据。
- en: In this next chapter, I will discuss how to directly harvest and track public
    data from smart contracts using a search engine approach.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讨论如何使用搜索引擎方法直接从智能合约中收割和跟踪公共数据。
- en: Query Interface
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询接口
- en: With the harvester in place, it is now possible to query the databases and provide
    data services to end users. A web-based UI can be built with any modern JavaScript
    user interface (UI) framework in front of those back-end data query services.
    The UI simply makes asynchronous data requests to the query interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了收割器之后，现在可以查询数据库并向终端用户提供数据服务。可以使用任何现代JavaScript用户界面（UI）框架在那些后端数据查询服务前构建一个基于网页的用户界面。用户界面只需向查询接口发起异步数据请求即可。
- en: But more interestingly, the query interface can be used as web services for
    all applications, not just for the blockchain explorer. For example, a dapp could
    query blockchain and generate charts or maps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，查询接口可以作为所有应用程序的Web服务使用，而不仅仅是区块链浏览器。例如，一个去中心化应用（dapp）可以查询区块链并生成图表或地图。
- en: SQL Query
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL查询
- en: You can use SQL to query data from the relational databases the harvester builds.
    For example, it is now easy to find transactions that originate from a specific
    address, transactions that call a specific smart contract function, or transactions
    that block awards from a certain period of time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 SQL 从收割者构建的关系型数据库中查询数据。例如，现在很容易找到来自特定地址的交易、调用特定智能合约函数的交易或来自某个时间段内的区块奖励交易。
- en: JSON Query
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON 查询
- en: 'Perhaps more interestingly, you can query JSON objects directly from tools
    like Elasticsearch. Here is an example query for Uniswap exchange events in the
    smart contract event log:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更有趣的是，你可以直接从像 Elasticsearch 这样的工具查询 JSON 对象。以下是 Uniswap 交易所事件在智能合约事件日志中的一个查询示例：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_6)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_6)'
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result would look something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能看起来像这样：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_7)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_7)'
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Elasticsearch framework is a powerful search engine framework. We have found
    that it works well with blockchain data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 框架是一个强大的搜索引擎框架。我们发现它与区块链数据配合得很好。
- en: GraphQL
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GraphQL
- en: Another promising query interface for blockchain data is GraphQL, an open source
    query language and execution engine that originally was developed by Facebook.
    Leading implementations of GraphQL for blockchain data include TheGraph ([https://thegraph.com/](https://thegraph.com/))
    and Arcblock’s OCAP. In this section, let’s look into how TheGraph handles GraphQL
    queries. You could simply use its hosted service to query data from the public
    Ethereum blockchain or build your own using its open source software ([https://github.com/graphprotocol](https://github.com/graphprotocol)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据的另一个有前景的查询接口是 GraphQL，这是一个由 Facebook 最初开发的开放源代码查询语言和执行引擎。GraphQL 的主要区块链数据实现包括
    TheGraph（[https://thegraph.com/](https://thegraph.com/)）和 Arcblock 的 OCAP。在本节中，让我们深入了解
    TheGraph 是如何处理 GraphQL 查询的。你可以简单地使用其托管服务从公共以太坊区块链查询数据，或者使用其开源软件（[https://github.com/graphprotocol](https://github.com/graphprotocol)）构建你自己的。
- en: 'TheGraph provides, among many other things, a mechanism for a dapp to directly
    fetch and consume only the exact amount of data that the dapp actually requires,
    at any given time. Here is an example of a GraphQL query for TheGraph:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: TheGraph 提供了许多其他功能，其中包括一种机制，允许 dapp 直接获取和消费 dapp 实际需要的确切数据量，无论在任何特定时间。以下是 TheGraph
    的一个 GraphQL 查询示例：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_8)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_8)'
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Right off the bat, we can see that TheGraph is different from a traditional
    RESTful web service, in that this GraphQL query is not written in valid JSON.
    In fact, this GraphQL syntax is more lightweight than JSON because it does not
    have to specify whole `key:value` pairs, such as `{"event": true},` and so forth.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '从一开始，我们就可以看出 TheGraph 与传统的 RESTful web 服务不同，因为这个 GraphQL 查询不是用有效的 JSON 编写的。实际上，这个
    GraphQL 语法比 JSON 更轻量，因为它不需要指定整个 `key:value` 对，例如 `{"event": true}` 等。'
- en: 'As examples, let’s use TheGraph to query Uniswap exchange smart contracts deployed
    on the Ethereum blockchain. To echo the earlier discussion in this chapter, TheGraph
    has already harvested event logs from Ethereum smart contracts and is making this
    data available for GraphQL queries. The previous GraphQL query translates to “Considering
    all of the Uniswap transactions to date, please give me only the name of the first
    event log that was ever emitted.” The response is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们使用 TheGraph 查询部署在以太坊区块链上的 Uniswap 交易所智能合约。为了呼应本章前面讨论的内容，TheGraph 已经从以太坊智能合约中收获事件日志，并使这些数据可供
    GraphQL 查询使用。之前的 GraphQL 查询翻译为“考虑到 Uniswap 迄今为止的所有交易，请只给我第一个事件日志的名称。” 响应如下：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_9)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_9)'
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The response is, in fact, valid JSON. You also will notice that this data is
    minimalistic. We can build on this first query by expanding the query to ask for
    not only the event but also the block number.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个响应是有效的 JSON。你还会注意到，这个数据非常简洁。我们可以在此基础上扩展查询，不仅要查询事件，还要查询区块号码。
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_10)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_10)'
- en: '[PRE15]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following result shows that the event was mined into block 6629139:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果显示该事件被挖掘到区块 6629139 中：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_11)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_11)'
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Another way that we can achieve/confirm this is to return all the event logs,
    ordered by block number in ascending order.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现/确认这一点的另一种方法是返回所有事件日志，按区块号升序排列。
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_12)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_12)'
- en: '[PRE17]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The query returns the following result:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回以下结果：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_13)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_13)'
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As TheGraph demonstrates, GraphQL could be an important tool for providing blockchain
    data to end-user applications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如TheGraph所展示的，GraphQL可能是向最终用户应用程序提供区块链数据的重要工具。
- en: Google BigQuery
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谷歌BigQuery
- en: As discussed earlier in this chapter, the Google Blockchain ETL project is a
    fully integrated data warehouse solution to ingest data from multiple blockchains
    into Google BigQuery tables. The data schema is designed to be unified across
    multiple blockchains. On all its blockchain data sets, the Google Blockchain ETL
    project supports the “double entry book” view that lists cryptocurrency transactions
    in traditional accounting formats.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面讨论的，谷歌区块链ETL项目是一个完全集成的数据仓库解决方案，用于将来自多个区块链的数据导入谷歌BigQuery表中。数据架构设计为跨多个区块链统一。在所有区块链数据集上，谷歌区块链ETL项目支持“复式记账”视图，以传统会计格式列出加密货币交易。
- en: 'You can then make queries against the data set using any query language that
    BigQuery supports, including SQL-like queries. For example, the following query
    verifies an account balance is indeed the sum of its transactions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用BigQuery支持的任何查询语言对数据集进行查询，包括类似SQL的查询。例如，以下查询验证账户余额确实是其交易的总和：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_14)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_14)'
- en: '[PRE19]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following query shows the frequency of different transaction fees on the
    Bitcoin blockchain:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询显示了比特币区块链上不同交易费用的频率：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_15)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_15)'
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Google Blockchain ETL project provides a SQL-like cloud-based data warehousing
    solution for blockchain data. You can customize it to fit your own needs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌区块链ETL项目为区块链数据提供了一个类似SQL的基于云的数据仓库解决方案。您可以根据自己的需求进行定制。
- en: What’s Next?
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: From a design perspective, let’s briefly think back to the days of the Simple
    Object Access Protocol (SOAP). While SOAP facilitated communication between disparate
    machines, it also relied on a set of predefined application data types that were
    essentially a permanent structure. Any changes (for example, updates to the software
    application or changes to the static configuration) would disrupt or render the
    previously working interoperability inoperable. Simply put, SOAP is a rigid protocol.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，让我们简要回顾一下简单对象访问协议（SOAP）的时代。虽然SOAP促进了不同机器之间的通信，但它也依赖于一套预定义的应用数据类型，这些类型实际上是一种永久的结构。任何更改（例如，软件应用程序的更新或静态配置的更改）都会破坏或使之前工作的互操作性无法操作。简单地说，SOAP是一个僵化的协议。
- en: Representational State Transfer (REST), on the other hand, introduced essentially
    an architectural style. Systems that conformed to all six architectural constraints
    were considered RESTful. Further, web services that adhered to the architectural
    constraints were considered RESTful APIs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，代表性状态转移（REST）实际上引入了一种架构风格。符合所有六个架构约束的系统被认为是RESTful。此外，遵循架构约束的Web服务被认为是RESTful
    API。
- en: Still, in design mode, while it is tempting to explore ways in which we can,
    say, improve JSON compression (between the data provider and the dapp) and so
    forth, thinking like this takes us down the path of a protocol — a protocol that
    enforces that both sides have to agree on a predefined set of rules and that forces
    the client side (in this case the dapp) to perform additional work (unzipping,
    decoding, etc.).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在设计模式下，虽然探索如何改进JSON压缩（例如，在数据提供者和dapp之间）等方法很诱人，但这样的思考方式让我们走上了协议的道路——一个强制双方同意预定义的一套规则，并迫使客户端（在这个例子中是dapp）执行额外工作（解压缩，解码等）的协议。
- en: Taking more of an architectural design viewpoint, would it be more effective,
    in terms of flexibility and interoperability, to focus on conventions as opposed
    to static configuration? We must remember that smart contract developers can create
    their own custom event logs that can emit one to many variables of various data
    types. Do we want to be setting up static configuration for each contract that
    is deployed in the blockchain network? Is human-driven static configuration sustainable?
    Can it be avoided altogether through the use of strong conventions and machine
    automation?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构设计角度来看，是专注于约定而不是静态配置，以实现更有效的灵活性和互操作性吗？我们必须记住，智能合约开发者可以创建自己的自定义事件日志，可以发出一个到多个不同数据类型的变量。我们希望为区块链网络上部署的每个合约设置静态配置吗？人类驱动的静态配置是可持续的吗？能否完全通过使用强约定和机器自动化来避免？
- en: 'The next wave of blockchain architecture is rising, and right now there are
    big opportunities. I believe that upcoming blockchain data providers and explorer
    projects should do the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链架构的下一波正在兴起，现在有巨大的机会。我相信即将到来的区块链数据提供商和浏览器项目应该做以下事情：
- en: Provide a mechanism to autonomously harvest a smart contract’s event log data
    based purely on an application binary interface (ABI) file and a smart contract’s
    address
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种机制，根据纯粹的应用二进制接口（ABI）文件和智能合约地址自动收集智能合约的事件日志数据
- en: Automatically assign correct data field types (based solely on the smart contract’s
    ABI)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动为正确数据字段类型分配（仅基于智能合约的ABI）
- en: Require only a minimal amount of configuration and automated schema generation
    as per the previous point
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅需要最少的配置和自动化模式生成，如前所述
- en: Provide sufficient internal querying, filtering, and logic to produce the most
    succinct responses
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供足够的内部查询、筛选和逻辑，以产生最简洁的响应
- en: Automatically/dynamically offer autocomplete syntax to the calling software
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动/动态地为调用软件提供自动完成语法
- en: Provide a variety of default visual front-end display portals
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供各种默认的前端显示门户
- en: Provide a library of built-in analytics (not only to explore trends, correlations,
    and so forth, but also to generate data sets for machine learning)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个内置分析库（不仅用于探索趋势、相关性等，还用于为机器学习生成数据集）
- en: Provide a mechanism to interoperate with ubiquitous business software, file
    formats, and content management and software development applications
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供与通用商业软件、文件格式以及内容管理和软件开发应用程序互操作的机制
- en: This is an exciting time. We have an unprecedented amount of information, documentation,
    and software available, as well as the appropriate decentralized infrastructure
    to test and deploy your projects on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人激动的时期。我们拥有前所未有的信息、文档和软件资源，以及适当的去中心化基础设施来测试和部署您的项目。
- en: Conclusion
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed how to build a blockchain data service. The blockchain
    explorers are pioneers in this space, but there is much more that can be done
    both on the harvesting side and on the query side. I believe that advanced off-chain
    storage and querying of blockchain data, especially smart contract execution data,
    is going to be a key component in the dapp ecosystem as well. In the next chapter,
    I will cover a new data service that provides real-time updates to public states
    of smart contracts. The data service is provided over a JavaScript library that
    complements web3.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了如何构建区块链数据服务。区块链浏览器是这个领域的先驱，但在收割和查询方面还有更多可以做的事情。我相信高级离线存储和查询区块链数据，尤其是智能合约执行数据，将是去中心化应用生态系统中的关键组成部分。在下一章，我将介绍一个新的数据服务，该服务为智能合约的公共状态提供实时更新。这个数据服务是通过一个与web3互补的JavaScript库提供的。
- en: 11. Smart Contract Search Engine
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11. 智能合约搜索引擎
- en: The first-generation blockchain data browsers were focused primarily on providing
    snapshots of transaction details. For example, in the case of Bitcoin, they displayed
    verbatim records of structured data, as well as the results of valid transactions
    executed at the rigid base protocol layer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代区块链数据浏览器主要关注提供交易细节的快照。例如，在比特币的情况下，它们显示结构化数据的逐字记录，以及在僵化的基本协议层执行的有效交易的成果。
- en: The unprecedented rise of smart contracts, with customized data fields and unique
    internal programmable logic, has brought about the need for a new mechanism, one
    that can provide an easy way to search and visualize this new rich, unstructured
    blockchain data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的空前崛起，其具有自定义数据字段和独特的内部可编程逻辑，带来了对新的机制的需求，这种机制可以提供一种简单的方式来搜索和可视化这种新的丰富、无结构的区块链数据。
- en: This mechanism is analogous to the rise of search engines while the Web grew
    in the 1990s. However, blockchain networks are unique in that they record all
    data in a time series of transactions. Smart contract data needs to be indexed
    and made available to both end users and machines in real time. Traditional web
    search engine technology is seldom used in the blockchain world because the World
    Wide Web and blockchain networks are fundamentally different. In this chapter,
    I will introduce an open source smart contract search engine. I will then discuss
    how to leverage it to power new types of dapps.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制类似于20世纪90年代网络增长时的搜索引擎崛起。然而，区块链网络的独特之处在于它们以交易的时间序列记录所有数据。智能合约数据需要被索引，并实时地提供给终端用户和机器。传统网络搜索引擎技术在区块链世界中很少使用，因为万维网和区块链网络在本质上就不同。在本书中，我将介绍一个开源的智能合约搜索引擎。然后，我将讨论如何利用它为新的去中心化应用（DApps）提供动力。
- en: Introduction to the Smart Contract Search Engine
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能合约搜索引擎简介
- en: There are many ways to build a search engine for blockchain data. In this chapter,
    we focus on the open source search engine built by Second State. It works with
    all Ethereum-compatible blockchains and is production ready. Most important, it
    serves as an example for the coding and implementation patterns associated with
    smart contract search engines.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 构建区块链数据搜索引擎有很多方法。在本章中，我们重点介绍由Second State开发的开源搜索引擎。它与所有以太坊兼容的区块链协同工作，并且已经准备好投入生产。最重要的是，它作为智能合约搜索引擎的编码和实现模式的示例。
- en: The Second State smart contract search engine has the components illustrated
    in [Figure 11.1](ch11.xhtml#ch11fig1). You can get its complete source code and
    instructions from [https://github.com/second-state/smart-contract-search-engine](https://github.com/second-state/smart-contract-search-engine).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Second State的智能合约搜索引擎具有如图11.1所示的组件。[图11.1](ch11.xhtml#ch11fig1)你可以从[https://github.com/second-state/smart-contract-search-engine](https://github.com/second-state/smart-contract-search-engine)获取其完整的源代码和说明。
- en: '![image](Images/yuan_f11_01.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_01.jpg)'
- en: '**Figure 11.1** The software components of a smart contract search engine'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.1** 智能合约搜索引擎的软件组件'
- en: An Elasticsearch instance that indexes application binary interfaces (ABIs)
    and public data fields from contracts against contract addresses
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Elasticsearch实例，用于索引合约的应用二进制接口（ABIs）和公共数据字段，针对合约地址。
- en: A full blockchain node that provides contract-related data as a standard JavaScript
    Object Notation–Remote Procedure Call (JSON-RPC) service
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的区块链节点，作为标准JavaScript对象表示法–远程过程调用（JSON-RPC）服务，提供与合约相关的数据。
- en: A Python-based harvester script that extracts data from a blockchain node and
    then indexes and stores the data in Elasticsearch
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Python的收割脚本，从区块链节点提取数据，然后将其在Elasticsearch中索引和存储。
- en: A Python-based web service that supports submitting contracts to index and Elasticsearch-like
    queries for real-time smart contract data
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Python的Web服务，支持将合约提交到索引以及类似Elasticsearch的查询，用于实时智能合约数据。
- en: A JavaScript library, es-ss.js, that enables client applications to interact
    with the web services
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JavaScript库，es-ss.js，允许客户端应用程序与Web服务进行交互。
- en: It is easy to start a new smart contract search engine using Docker, but it
    requires a few hours to fully index a production blockchain and then keep all
    the indexed contracts updated with each new block. To make it easier for developers
    to get started, Second State and the community run a few search engine instances
    for public use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker启动一个新的智能合约搜索引擎很简单，但要完全索引一个生产区块链需要几小时，然后还要将所有索引的合约随着每个新区块的产生而更新。为了使开发者更容易上手，Second
    State和社区运行了一些供公共使用的搜索引擎实例。
- en: '*Ethereum mainnet*: [https://eth.search.secondstate.io/](https://eth.search.secondstate.io/)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以太坊主网*：[https://eth.search.secondstate.io/](https://eth.search.secondstate.io/)'
- en: '*Ethereum Classic (ETC) mainnet*: [https://etc.search.secondstate.io/](https://etc.search.secondstate.io/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以太坊经典（ETC）主网*：[https://etc.search.secondstate.io/](https://etc.search.secondstate.io/)'
- en: '*CyberMiles mainnet*: [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CyberMiles主网*：[https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/)'
- en: '*Second State DevChain*: [https://devchain.ss.search.secondstate.io/](https://devchain.ss.search.secondstate.io/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二状态DevChain**: [https://devchain.ss.search.secondstate.io/](https://devchain.ss.search.secondstate.io/)'
- en: You can load these URLs in a browser to see the current status of each of the
    public search engines. From there, you can search contract addresses that conform
    to specified contract interfaces (i.e., the ABI code) and then get up-to-date
    values in public fields for a contract address. For example, you could search
    all ERC20-compliant token contracts and see the symbol, supply, and values for
    each. You could also upload new ABIs to be indexed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些URL在浏览器中加载，以查看每个公共搜索引擎的当前状态。从那里，你可以搜索符合特定合约接口（即ABI代码）的合约地址，然后获取合约地址的公共字段中的最新值。例如，你可以搜索所有符合ERC20标准的代币合约，并查看每个合约的符号、供应量值等。你还可以上传新的ABI以进行索引。
- en: However, the most interesting use of a smart contract search engine is to serve
    as a data aggregator for new types of dapps. You can access the search engine
    functions programmatically from the es-ss.js library from your JavaScript application
    or web page. In the next section, we will look into a dapp that utilizes the search
    engine to interact with multiple smart contracts at the same time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能合约搜索引擎最有趣的使用是作为新类型dapp的数据聚合器。你可以从你的JavaScript应用程序或网页中以编程方式访问搜索引擎功能，使用来自es-ss.js库的函数。在下一节中，我们将探讨一个利用搜索引擎同时与多个智能合约交互的dapp。
- en: Getting Started with a Smart Contract Search Engine
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用智能合约搜索引擎入门
- en: The best way to get hands-on experience with a smart contract search engine
    and the es-ss.js library is through the BUIDL integrated development environment
    (IDE). See [Chapter 3](ch03.xhtml#ch03) for more on the BUIDL IDE tool. The simple
    dapp I will showcase here displays a number of AccountBalanceDemo contracts deployed
    on the blockchain. Each of these contracts stores a number that can be changed
    by the user. The search engine tracks and displays the tally of those numbers
    inside the contracts in real time. [Figure 11.2](ch11.xhtml#ch11fig2) shows the
    dapp in action in a web browser.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 获得智能合约搜索引擎和es-ss.js库的实战经验的最佳方式是通过BUIDL集成开发环境（IDE）。有关BUIDL IDE工具的更多信息，请参见[第3章](ch03.xhtml#ch03)。在这里展示的简单dapp中，显示了部署在区块链上的多个AccountBalanceDemo合约的数量。每个这些合约都存储了一个可以被用户改变的数字。搜索引擎实时跟踪并显示合约内的这些数字的汇总。
    [图11.2](ch11.xhtml#ch11fig2) 显示了在网络浏览器中运行的dapp。
- en: '![image](Images/yuan_f11_02.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_02.jpg)'
- en: '**Figure 11.2** The AccountBalanceDemo dapp'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.2** AccountBalanceDemo dapp'
- en: The following code listing shows the smart contract. The contract simply stores
    a number that can be updated by the `setAccountBalance()` function call. You can
    copy and paste it into BUIDL’s contract editor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码清单显示了智能合约。该合约简单地存储了一个可以通过`setAccountBalance()`函数调用更新的数字。你可以复制并粘贴到BUIDL的合约编辑器中。
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_1)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击此处查看代码图片**([Images/ch11_images.xhtml#pro11_1](Images/ch11_images.xhtml#pro11_1))'
- en: '[PRE21]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and deploy the smart contract by clicking the **Compile** and **Deploy
    to the chain** buttons. Make sure you give the account a name in the `_accountName`
    field before you click the **Deploy to the chain** button (see [Figure 11.3](ch11.xhtml#ch11fig3)).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**编译**和**部署到链上**按钮来编译并部署智能合约。确保在点击**部署到链上**按钮之前，在`_accountName`字段中给账户一个名字（参见
    [图11.3](ch11.xhtml#ch11fig3)）。
- en: '![image](Images/yuan_f11_03.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_03.jpg)'
- en: '**Figure 11.3** Deploying a new contract to be managed by the search-based
    dapp'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.3** 将新合约部署到由基于搜索的dapp管理的链上'
- en: Next, the following code listing shows the HTML code for the dapp. You can copy
    and paste it into BUIDL’s dapp/HTML editor. It shows multiple AccountBalanceDemo
    contracts in a table and then the tally of their account balances in another table.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，下面的代码清单显示了dapp的HTML代码。你可以复制并粘贴到BUIDL的dapp/HTML编辑器中。它显示了一个包含多个AccountBalanceDemo合约的表格，然后是另一个表格中它们的账户余额汇总。
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_2)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击此处查看代码图片**([Images/ch11_images.xhtml#pro11_2](Images/ch11_images.xhtml#pro11_2))'
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The HTML tables are rendered by JavaScript. As discussed earlier, the JavaScript
    application can use the web3.js library to communicate with a blockchain node.
    It could also use the es-ss.js library to communicate with the search engine.
    Both web3.js and es-ss.js are initialized and made available in the JavaScript
    by BUIDL. The following code listing shows the JavaScript application. You should
    copy and paste it into BUIDL’s dapp/JavaScript editor. You should put the code
    outside of the `/* Don't modify */` section.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表格通过JavaScript渲染。如前所述，JavaScript应用程序可以使用web3.js库与区块链节点通信。它还可以使用es-ss.js库与搜索引擎通信。web3.js和es-ss.js都在BUIDL的JavaScript中初始化并可用。下面的代码列表显示了JavaScript应用程序。你应该将其复制并粘贴到BUIDL的dapp/JavaScript编辑器中。你应该将代码放在`/*
    Don't modify */`部分之外。
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_3)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 【点击此处查看代码图片](Images/ch11_images.xhtml#pro11_3)
- en: '[PRE23]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the page loads, the `reload()` JavaScript function calls the Elasticsearch
    es-ss.js API to get all contracts with the AccountBalanceDemo type from the blockchain.
    It then computes the tally in the total variable. Notice that the current state,
    in other words, the account name and balance, of each contract is contained in
    the search result. We can simply display this information without having to interact
    with the slower blockchain nodes. The `reload()` function constructs HTML Document
    Object Model (DOM) elements to display those contract public data fields.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载时，`reload()` JavaScript函数调用Elasticsearch es-ss.js API，从区块链获取所有`AccountBalanceDemo`类型的合约。然后，它在total变量中计算总计。请注意，每个合约的当前状态，换句话说，合约名称和余额，都包含在搜索结果中。我们可以简单地显示这些信息，而无需与较慢的区块链节点交互。`reload()`函数构建HTML文档对象模型（DOM）元素来显示那些合约公共数据字段。
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_4)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 【点击此处查看代码图片](Images/ch11_images.xhtml#pro11_4)
- en: '[PRE24]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Update balance buttons in the table trigger the `setNumber()` JavaScript
    function, which in turn calls the contract’s `setAccountBalance()` function via
    web3\. The JavaScript then calls the `esss.updateStateOfContractAddress()` function
    to explicitly inform the search engine that this contract has changed and calls
    the `reload()` function to refresh data from the search engine.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的“更新余额”按钮会触发`setNumber()` JavaScript函数，该函数进而通过web3调用合约的`setAccountBalance()`函数。随后，JavaScript调用`esss.updateStateOfContractAddress()`函数，明确告知搜索引擎合约已更改，并调用`reload()`函数从搜索引擎刷新数据。
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_5)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 【点击此处查看代码图片](Images/ch11_images.xhtml#pro11_5)
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Note**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Strictly speaking, the `updateStateOfContractAddress()` function call is not
    necessary, as the search engine works in near real time, and it automatically
    picks up the changes you just made in the `setAccountBalance()` function call
    via web3\. But, as a best practice for improved stability, we recommend you explicitly
    inform the search engine of changes you make whenever you can.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`updateStateOfContractAddress()`函数调用并非必需，因为搜索引擎的运行几乎是实时的，它会自动获取你在`setAccountBalance()`函数调用通过web3所做的更改。但是，为了提高稳定性，我们建议您在可能的情况下明确告知搜索引擎您所做的更改。
- en: Finally, you can hit the **Run** button to run the dapp in BUIDL and use the
    Publish button to publish it on a public web site (see [Figure 11.2](ch11.xhtml#ch11fig2)).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以点击**运行**按钮在BUIDL中运行dapp，并使用发布按钮将其发布到公共网站（见[图11.2](ch11.xhtml#ch11fig2)）。
- en: The FairPlay Dapp Example
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公平玩Dapp示例
- en: FairPlay uses smart contracts to conduct automated prize draws that are fair
    and transparent. It allows anyone to create and participate in product giveaways
    and e-commerce marketing campaigns. It is a dapp running on the CyberMiles public
    blockchain, an Ethereum-compatible blockchain that features low-cost and fast
    consensus (learn more in [Chapter 14](ch14.xhtml#ch14)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 公平玩使用智能合约进行公平透明的自动化抽奖。它允许任何人创建和参与产品赠品和电子商务营销活动。这是一个在CyberMiles公共区块链上运行的dapp，这是一个与以太坊兼容的区块链，具有低成本和快速共识的特点（了解更多请参见[第14章](ch14.xhtml#ch14)）。
- en: The FairPlay dapp can be accessed from any web browser. The dapp runs web3.js
    and es-ss.js to fetch data from public blockchain nodes and search engine Elasticsearch
    nodes. The user does not need any special software (i.e., a crypto wallet) to
    view active and past giveaways. The FairPlay web app is simply a collection of
    HTML and JavaScript files (see [Figure 11.4](ch11.xhtml#ch11fig4)). Any user can
    start a web server on a computer and serve those files locally or publically.
    Hence, FairPlay is decentralized and resistant to censorship.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 费尔普雷分布式应用（DApp）可以通过任何网络浏览器访问。该DApp运行web3.js和es-ss.js，以从公共区块链节点和搜索引擎Elasticsearch节点获取数据。用户无需任何特殊软件（例如，加密货币钱包）即可查看正在进行和过去的赠品。费尔普雷网页应用只不过是HTML和JavaScript文件的集合（见[图11.4](ch11.xhtml#ch11fig4)）。任何用户都可以在计算机上启动一个网络服务器，并本地或公开地提供这些文件。因此，费尔普雷是去中心化的，并且抵抗审查。
- en: '![image](Images/yuan_f11_04.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_04.jpg)'
- en: '**Figure 11.4** FairPlay is a web app that can be hosted by anyone and accessed
    on any web browser.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.4** 费尔普雷是一个可以通过任何网络浏览器托管并由任何人访问的网页应用。'
- en: When the user needs to make a smart contract transaction, such as creating a
    new giveaway or participating in an existing giveaway, the web page directs the
    user to open the CyberMiles app to digitally sign and complete the operation (see
    [Figure 11.5](ch11.xhtml#ch11fig5)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要进行智能合约交易时，例如创建一个新的赠品或参与一个现有的赠品，网页将指导用户打开CyberMiles应用以数字签名并完成操作（见[图11.5](ch11.xhtml#ch11fig5)）。
- en: '![image](Images/yuan_f11_05.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_05.jpg)'
- en: '**Figure 11.5** The FairPlay web app opens the CyberMiles app to send smart
    contract transactions.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.5** FairPlay网页应用打开CyberMiles应用发送智能合约交易。'
- en: FairPlay is a dapp in front of blockchain smart contracts. Under the hood, FairPlay
    has a modular architecture that is easy to develop and maintain. Key to this architecture
    is the smart contract search engine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 费尔普雷是在区块链智能合约之上的DApp。在幕后，FairPlay有一个易于开发和维护的模块化架构。这个架构的关键是智能合约搜索引擎。
- en: A Modular Architecture
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块化架构
- en: Most of today’s dapps rely on a single monolithic smart contract to serve as
    the “back end.” The smart contract manages all application users and states. Even
    for systems that consist of multiple contracts, there is typically a registry
    or manager contract that provides aggregated information about the system.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当今大多数DApp都依赖于一个单一的巨石式智能合约来作为“后端”。该智能合约管理所有应用程序用户和状态。即使对于由多个合约组成的系统，通常也有一个注册表或管理合约，提供关于系统的聚合信息。
- en: However, a large smart contract is difficult to write and maintain. It tends
    to be error-prone and nearly impossible to fix when an error or issue is discovered,
    exacerbating the security problems that have plagued dapps today. The registry
    contract is also constrained by the limitations of today’s smart contract programming
    languages and virtual machines. It cannot support complex data query operations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大型智能合约难以编写和维护。它往往容易出错，而且在发现错误或问题时几乎无法修复，加剧了今天DApp所面临的安全问题。注册表合约也受到当今智能合约编程语言和虚拟机限制的影响。它不能支持复杂的数据查询操作。
- en: The FairPlay dapp took a different approach. The dapp consists of many giveaway
    events, but each event is its own smart contract. When we create a new giveaway,
    we deploy a new instance of the FairPlay smart contract. When an event ends, its
    smart contract instance is discarded. That allows us to continuously improve the
    FairPlay contract to add features and fix bugs, as each future giveaway event
    uses a new smart contract. However, a key challenge in this approach is how the
    dapp organizes all those smart contracts created by different addresses at different
    times and makes the information inside all those contracts available in a unified
    UI. Enter the search engine.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 费尔普雷DApp采取了不同的方法。该应用包含许多赠品活动，但每个活动都是其自己的智能合约。当我们创建一个新的赠品时，我们部署了FairPlay智能合约的新实例。当一个活动结束时，其智能合约实例将被丢弃。这使我们能够不断改进FairPlay合约以添加功能和修复错误，因为每个未来的赠品活动都将使用一个新的智能合约。然而，这种方法的一个关键挑战是如何组织由不同地址在不同的时间创建的所有这些智能合约，并使所有这些合约中的信息在统一的用户界面中可用。于是引入了搜索引擎。
- en: Using the Smart Contract Search Engine
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用智能合约搜索引擎
- en: The FairPlay dapp home screen displays results from the search engine (see [Figure
    11.6](ch11.xhtml#ch11fig6)). It allows users to find giveaways containing specific
    keywords or tags, as well as giveaways the user previously participated in. The
    search engine indexes information from all FairPlay contracts deployed on the
    blockchain.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 公平玩dapp首页显示搜索引擎的结果（见[图11.6](ch11.xhtml#ch11fig6)）。它允许用户找到包含特定关键词或标签的赠品，以及用户之前参与过的赠品。搜索引擎索引来自区块链上部署的所有公平玩合同的信息。
- en: '![image](Images/yuan_f11_06.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_06.jpg)'
- en: '**Figure 11.6** The FairPlay dapp home page is based on search engine results.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.6** 公平玩dapp首页基于搜索引擎结果。'
- en: The smart contract search engine is also decentralized—anyone can create a search
    engine-based dapp in front of all FairPlay smart contracts. Each search engine-based
    dapp could use different algorithms and queries to surface and promote FairPlay
    giveaways tailored to its users and audience. This architecture is illustrated
    in [Figure 11.7](ch11.xhtml#ch11fig7).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约搜索引擎也是去中心化的——任何人都可以在所有公平玩智能合约前创建一个基于搜索引擎的dapp。每个基于搜索引擎的dapp可以使用不同的算法和查询来突出展示和推广针对其用户和受众定制的公平玩赠品。这一架构在[图11.7](ch11.xhtml#ch11fig7)中有所说明。
- en: '![image](Images/yuan_f11_07.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f11_07.jpg)'
- en: '**Figure 11.7** The decentralized FairPlay dapp'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.7** 去中心化的公平玩dapp'
- en: Each smart contract in the FairPlay dapp completes a limited set of specific
    business transactions. Smart contracts are small pieces of autonomous code that
    are designed to enforce simple business rules on the blockchain. All related smart
    contracts are aggregated in the search engine to provide a useful UI to users.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 公平玩（FairPlay）dapp中的每个智能合约完成一组有限的具体业务交易。智能合约是设计用于在区块链上执行简单业务规则的自主代码的小块。所有相关的智能合约都聚集在搜索引擎中，为用户提供一个有用的用户界面。
- en: Use Cases
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例
- en: The FairPlay dapp is an example of how the smart contract engine supports data-intensive
    e-commerce dapps. The following sections present some more use cases.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 公平玩dapp是智能合约引擎支持数据密集型电商dapp的一个例子。接下来的部分将介绍一些更多的用例。
- en: Crypto Assets
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加密货币资产
- en: Crypto assets are represented by a large number of standard contracts such as
    ERC20, ERC721, and even ERC1400\. A search engine could provide an aggregated
    view of all account balances and transactions across those contracts.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币资产由大量标准合同如ERC20、ERC721甚至ERC1400等代表。搜索引擎可以为所有这些合同提供一个聚合视图，显示所有账户余额和交易。
- en: Essentially, every ERC smart contract standard could benefit from a search engine
    that aggregates and displays information across all contracts of the same type.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，每个ERC智能合约标准都能从聚合并显示同类型所有合同信息的搜索引擎中受益。
- en: DeFi
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DeFi（去中心化金融）
- en: Decentralized crypto exchanges often have multiple asset pools each represented
    by a smart contract. A search engine can provide deep insights into the history
    and current state of those pools.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化加密货币交易所通常有多个代表不同智能合约的资产池。搜索引擎可以深入洞察这些池的历史和当前状态。
- en: In general, decentralized finance (DeFi) solutions, such as algorithmic stable
    coins, crypto loans, and staking pools, all have asset pools held by smart contracts.
    A search engine could provide deep insights into those pools.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，去中心化金融（DeFi）解决方案，如算法稳定币、加密货币贷款和质押池，都有由智能合约持有的资产池。搜索引擎可以深入洞察这些池。
- en: Gaming
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 游戏
- en: Blockchains allow participants from anywhere in the world to play games against
    each other without the need for a central operator or a trusted setup. A decentralized
    game is run entirely in accordance with a smart contract’s logic. The smart contract
    will not allow a player to perform an invalid move or participate out of turn.
    The smart contract ensures correctness and fairness, right from the initial rules
    of engagement through to the final payout or reward.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链允许来自世界各地的参与者相互玩游戏，无需中心运营商或可信设置。去中心化游戏完全根据智能合约的逻辑运行。智能合约不会允许玩家进行无效动作或违规参与。智能合约确保从参与开始到最终支付或奖励的正确性和公平性。
- en: Dapps, which constitute the front end (a visually stimulating component of the
    game), obtain the real-time state of the game, programmatically, via the smart
    contract search engine API.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Dapps，作为游戏的前端（游戏的视觉刺激部分），通过智能合约搜索引擎API程序化地获取游戏的实时状态。
- en: 'The entire ecosystem is safe and reliable. The following steps are repeated
    until a satisfactory outcome is achieved:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 整个生态系统都是安全和可靠的。以下步骤会一直重复，直到达到满意的结果：
- en: The dapp visually displays the current state of the game to the end users.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: dapp为终端用户提供当前游戏状态的视觉显示。
- en: If it is their turn, each end user makes a choice by touching or swiping the
    screen.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当轮到他们时，每个终端用户通过触摸或滑动屏幕来做出选择。
- en: The dapp submits that choice to the smart contract.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: dapp将那个选择提交给智能合约。
- en: The smart contract validates the instruction set that the dapp sent.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能合约验证dapp发送的指令集。
- en: The smart contract executes the instruction set if valid.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有效，智能合约执行指令集。
- en: The smart contract’s state is/isn’t updated accordingly.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能合约的状态相应地更新。
- en: The dapp redisplays the current state of the game (via the API) to the end users.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: dapp通过API将当前游戏状态重新显示给终端用户。
- en: Conclusion
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed how the smart contract search engine can provide
    rich and up-to-date blockchain data to enable complex dapps. For application developers,
    the search engine services (i.e., the es-ss.js library) can supplement web3 and
    support a modular architecture for dapps.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了智能合约搜索引擎如何提供丰富且最新的区块链数据，以支持复杂的dapps。对于应用程序开发者来说，搜索引擎服务（即es-ss.js库）可以补充web3，并支持dapps的模块化架构。
- en: 12. Smart Contract Security and Best Practices
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12. 智能合约安全与最佳实践
- en: By Victor Fang, PhD[*](ch12.xhtml#ch12fn1)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 维克多·方博士著[*](ch12.xhtml#ch12fn1)
- en: '[*](ch12.xhtml#rch12fn1) Victor Fang, PhD, is founder and CEO of AnChain.ai.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch12.xhtml#rch12fn1) 维克多·方博士是AnChain.ai的创始人兼首席执行官。'
- en: A smart contract, coined by American computer scientist Nick Szabo, is the revolutionary
    feature that defines blockchain 2.0, compared to the peer-to-peer decentralized
    transactions in the blockchain 1.0 era such as Bitcoin, Ripple, and so on.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 美国计算机科学家尼克·萨博提出的智能合约，是定义区块链2.0时代的革命性特征，与区块链1.0时代的 peer-to-peer 去中心化交易（如比特币、Ripple等）相比。
- en: As of 2019, Ethereum is the most widely adopted smart contract-enabled blockchain.
    An Ethereum smart contract is decentralized software that can be executed and
    verified on the Ethereum public blockchain.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2019年，以太坊是最广泛采用的智能合约区块链。以太坊智能合约是可以在以太坊公共区块链上执行和验证的去中心化软件。
- en: 'Ethereum smart contracts are programmed in Solidity, a JavaScript-like programming
    language (ECMAScript syntax), and they run in the Ethereum Virtual Machine (EVM).
    You can learn more about Ethereum smart contracts in [Chapter 6](ch06.xhtml#ch06).
    Since Ethereum’s launch in 2015, developers have witnessed a plethora of successful
    applications, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊智能合约是用类似于JavaScript的编程语言Solidity编写的，并在以太坊虚拟机（EVM）中运行。您可以在[第6章](ch06.xhtml#ch06)了解更多关于以太坊智能合约的信息。自2015年以太坊推出以来，开发者见证了众多成功应用，如下所述：
- en: Tokens, such as initial coin offerings (ICOs), security token offerings (STOs),
    and stable coins
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代币，如首次代币发行（ICO）、证券代币发行（STO）和稳定币
- en: Dapps, such as FOMO3D and CryptoKitties
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dapp，如FOMO3D和CryptoKitties
- en: Decentralized exchanges, such as the Decentralized Ethereum Asset Exchange (IDEX)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化交易所，如去中心化以太坊资产交易所（IDEX）
- en: However, developers have also experienced major security vulnerabilities that
    caused billions of dollars in losses and concerns among the blockchain communities.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发者也经历了导致数十亿美元损失并在区块链社区引起担忧的重大安全漏洞。
- en: 'In this chapter, I will focus on the Ethereum smart contract and discuss the
    following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将重点讨论以太坊智能合约，并讨论以下内容：
- en: Major Ethereum smart contract hacks and vulnerabilities in history
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史上以太坊智能合约的主要黑客攻击和漏洞
- en: Best practices to secure smart contracts
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保障智能合约安全的最佳实践
- en: Major Ethereum Smart Contract Hacks and Vulnerabilities
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史上以太坊智能合约的主要黑客攻击和漏洞
- en: Since the launch of Ethereum, the community witnessed major hacks that took
    over the headlines. In this chapter, I will review a few major hacks and illustrate
    the vulnerabilities behind those exploitations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 自以太坊推出以来，社区见证了主导新闻头条的重大黑客攻击。在本章中，我将回顾几个重大黑客攻击，并说明这些攻击背后的漏洞。
- en: Decentralized Autonomous Organization Hack
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 去中心化自治组织（DAO）黑客攻击
- en: The decentralized autonomous organization (DAO) hack is probably the most notorious
    hack in Ethereum history. A DAO is a decentralized autonomous organization. Its
    goal is to codify the rules and decision-making apparatus of an organization,
    eliminating the need for documents and people in governing and creating a structure
    with decentralized control.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化自治组织（DAO）黑客攻击可能是以太坊历史上最臭名昭著的黑客攻击。DAO是一个去中心化自治组织。它的目标是编码一个组织的规则和决策机制，消除治理和创建结构中需要文件和人，实现去中心化控制。
- en: In June 2016, an attacker drained 3.5 million ETH (about $50 million) from the
    DAO smart contract, after the ICO token sale had ended. It led to a hard fork
    of Ethereum. The technique the attackers used was reentrancy.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年 6 月，在 DAO 智能合约的 ICO 代币销售结束后，一名攻击者从 DAO 智能合约中提取了 350 万 ETH（约 5000 万美元）。这导致了以太坊的分叉。攻击者使用的技术是重入性。
- en: '*Reentrancy* is also known as *recursive call vulnerability*. It occurs when
    external contract calls are allowed to make new calls to the calling contract
    before the initial execution is complete. For a function, this means that the
    contract state may change in the middle of its execution as a result of a call
    to an untrusted contract or the use of a low-level function with an external address.
    The minimal example for reentrancy is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 重入性也被称为*递归调用漏洞*。当外部合约调用被允许在新调用调用合约之前，完成初始执行之前，就会发生这种情况。对于一个函数，这意味着合约状态可能会因为对不可信合约的调用或使用具有外部地址的低级函数而在执行过程中发生变化。重入性的最小示例如下：
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_1)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch12_images.xhtml#pro12_1)'
- en: '[PRE26]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this code example, `msg.sender.call.value` can be exploited by hackers. An
    attack contract could recursively call it until all gas is consumed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`msg.sender.call.value` 可以被黑客利用。一个攻击合约可以递归调用它，直到所有燃料耗尽。
- en: In fact, reentrancy is quite common. In October 2018, SpankChain, a cryptocurrency
    project focused on the adult industry, suffered a breach that saw almost $40,000
    in ETH stolen.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，重入性（Reentrancy）相当常见。2018 年 10 月，专注于成人行业的加密货币项目 SpankChain 遭受了攻击，导致近 4 万美元的
    ETH 被盗。
- en: The AnChain.ai threat research team illustrated the recursive nature of reentrancy
    when SpankChain was attacked, as shown in [Figure 12.1](ch12.xhtml#ch12fig1).
    Note that the hacker launched the attack contract that would cause SpankChain
    to recursively send ETH to the hacker’s address, until all gas was consumed. Each
    `call_0`, `call_1_0`, and `call_1_1_0_0` is an EVM internal transaction indicating
    an external smart contract call. In this case, each internal call stole 0.5 ETH
    from the SpankChain smart contract!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: AnChain.ai 威胁研究团队在 SpankChain 被攻击时展示了重入性的递归特性，如图 12.1 所示。注意，黑客启动了攻击合约，该合约将导致
    SpankChain 递归地将 ETH 发送到黑客的地址，直到所有燃料耗尽。每个 `call_0`、`call_1_0` 和 `call_1_1_0_0`
    都是 EVM 内部交易，表示外部智能合约调用。在这种情况下，每个内部调用从 SpankChain 智能合约中窃取了 0.5 ETH！
- en: '![image](Images/yuan_f12_01.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f12_01.jpg)'
- en: '**Figure 12.1** The recursive nature of the reentrancy when the SpankChain
    smart contract was attacked'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.1** 在 SpankChain 智能合约被攻击时的递归特性'
- en: BEC Token Hack
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BEC 代币黑客攻击
- en: The Beauty Chain (BEC) token is particularly interesting because it shows how
    smart contract-based crypto assets can have a massive impact on a centralized
    crypto exchange (OK Exchange) in a subtle way, causing billions of dollars in
    losses.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Beauty Chain (BEC) 代币非常有趣，因为它展示了基于智能合约的加密货币资产如何以微妙的方式对中心化加密货币交易所（OK Exchange）产生巨大影响，造成数十亿美元的损失。
- en: BEC was a high-profile cryptocurrency in China, and its stated goal was to be
    “a truly decentralized and beauty-themed ecosystem.”
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: BEC 是中国知名度较高的加密货币，其目标是建立“一个真正去中心化和以美为主题的生态系统”。
- en: It started trading on OKEX on February 23, 2018\. From its peak market cap of
    around $70 billion, it gradually came down to around $2 billion USD as of April
    22, when its trading value suddenly dropped to zero. OKEX subsequently suspended
    trading of BECs.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 它于 2018 年 2 月 23 日在 OKEX 开始交易。从约 700 亿美元的峰值市值逐渐下降到 2019 年 4 月 22 日左右 20 亿美元的市值，当时其交易价值突然跌至零。随后
    OKEX 暂停了 BEC 的交易。
- en: The BEC token hack was because of an *integer overflow* vulnerability in its
    ERC20 smart contract. The annotated code line in the following listing multiplies
    two uint256 numbers and assigns the result to another uint256 variable, `amount`.
    Unfortunately, there is no overflow checking on that line. When a hacker passes
    a legitimate but large uint256 variable, it can cause the product to overflow.
    [Figure 12.2](ch12.xhtml#ch12fig2) shows the transaction that exploits the integer
    overflow vulnerability.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: BEC 代币黑客攻击是由于其 ERC20 智能合约中的*整数溢出*漏洞。下面的列表中的注释代码行将两个 uint256 数字相乘，并将结果分配给另一个
    uint256 变量 `amount`。不幸的是，该行没有溢出检查。当黑客传递一个合法但很大的 uint256 变量时，它可能会导致乘积溢出。 [图 12.2](ch12.xhtml#ch12fig2)
    显示了利用整数溢出漏洞的交易。
- en: '![image](Images/yuan_f12_02.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f12_02.jpg)'
- en: '**Figure 12.2** The exploited overflow vulnerability transaction of the BEC
    smart contract'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.2** BEC 智能合约被利用的溢出漏洞交易'
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_2)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch12_images.xhtml#pro12_2)'
- en: '[PRE27]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The way to prevent this hack is to use SafeMath for all arithmetic. In fact,
    this smart contract used SafeMath in all except this particular function, and
    it caused catastrophic damage not only to BEC but also to all exchanges that traded
    it.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种黑客攻击的方法是的所有算术运算都使用 SafeMath。实际上，这个智能合约在除这个特定函数之外的所有地方都使用了 SafeMath，它不仅给
    BEC 带来了灾难性的损失，也给所有交易它的交易所带来了损失。
- en: '**Note**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: There are ways to prevent integer overflows in smart contracts. The Lity language
    and virtual machine extensions to Ethereum check for integer overflow at compile
    time and then detect and abort the smart contract when there are integer overflows
    at runtime. See [Chapter 14](ch14.xhtml#ch14) for more.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以防止智能合约中的整数溢出。Lity 语言和以太坊的虚拟机扩展在编译时检查整数溢出，然后在运行时检测并在整数溢出时终止智能合约。更多内容请参见[第
    14 章](ch14.xhtml#ch14)。
- en: The Parity Wallet Hack
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Parity 钱包黑客攻击
- en: 'The *Parity multisig bug* vulnerability showcases another way that a cryptographic
    smart contract design bug can damage part of the ecosystem: the wallet. The impacted
    Parity wallet is one popular wallet for Ethereum and tokens.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parity 多签漏洞** 展示了加密智能合约设计缺陷如何损害生态系统的另一个部分：钱包。受影响的 Parity 钱包是 Ethereum 和代币的流行钱包之一。'
- en: In fact, this bug is one of the common bugs in the top-ten list from Open Web
    Application Security Project (OWASP), categorized under access control. These
    issues are common in all programs, not just smart contracts.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个错误是 Open Web Application Security Project（OWASP）发布的 top-ten 常见错误列表中的一个，归类为访问控制。这些问题在所有程序中都很常见，而不仅仅是智能合约。
- en: The Parity multisig bug impacted all users with assets in a multisig wallet
    created in Parity wallet that was deployed after July 20, 2017, worth $155 million
    USD. This bug was patched immediately after the hack.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Parity 多签漏洞影响了在 2017 年 7 月 20 日之后部署的 Parity 钱包中拥有资产的所有用户，共计 1.55 亿美元。这个漏洞在黑客攻击后被立即修复。
- en: The attacker sent two transactions to each of the affected contracts.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者向每个受影响的合同发送了两个交易。
- en: 'Step 1: Obtain Exclusive Ownership of the Multisig'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤 1：获得多签的独家所有权
- en: In the wallet contract, the `payable()` function contains a bug that causes
    all public functions from the library to be callable by anyone, including `initWallet`,
    which can change the contract’s owners.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在钱包合约中，`payable()` 函数包含一个导致所有公共函数（包括 `initWallet`）可以被任何人调用的错误，这可以改变合约的所有者。
- en: Unfortunately, `initWallet` has no checks to prevent an attacker from calling
    it after the contract was initialized. The attacker exploited this and simply
    changed the contract’s owner state variable to the hacker’s addresses. This modified
    the access control and persisted in the immutable Ethereum blockchain.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`initWallet` 函数没有检查来防止攻击者在合同初始化之后调用它。攻击者利用这一点，简单地将合同的所有者状态变量更改为黑客的地址。这改变了访问控制，并永久保存在不可变的以太坊区块链上。
- en: 'Step 2: Move All of Its Funds'
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤 2：转移其所有资金
- en: After the hacker took over the ownership, it was just a matter of invoking the
    execute function to send all the funds to the hacker’s account! This execution
    was automatically authorized since the attacker was then the only owner of the
    multisig, effectively draining the contract of all its funds.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑客接管所有权之后，只需调用执行函数，将所有资金发送到黑客的账户就足够了！由于此时攻击者是多签的唯一所有者，该执行过程是自动授权的，有效地将合同中的所有资金都转移出去。
- en: FOMO3D and LastWinner Dapp Hack
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FOMO3D 和 LastWinner dapp 黑客攻击
- en: Dapps are a dominant trend enabled by smart contracts. As of March 2019, there
    were 2,667 dapps running on public blockchains, and the number will likely grow
    tremendously. Please see [Chapter 7](ch07.xhtml#ch07) for more on Ethereum dapp
    development.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 基于智能合约的 dapp 是一个主导趋势。截至 2019 年 3 月，共有 2667 个 dapp 在公共区块链上运行，并且这个数字可能会大幅增长。更多关于以太坊
    dapp 开发的内容，请参见[第 7 章](ch07.xhtml#ch07)。
- en: 'FOMO3D is a gambling dapp ([Figure 12.3](ch12.xhtml#ch12fig3)) that was so
    popular in July/August 2018 that it even congested the Ethereum blockchain. The
    FOMO3D game rules are simple and as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: FOMO3D 是一个博彩 dapp ([图 12.3](ch12.xhtml#ch12fig3))，在 2018 年 7/8 月如此流行，以至于它甚至拥堵了以太坊区块链。FOMO3D
    的游戏规则简单如下：
- en: '![image](Images/yuan_f12_03.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f12_03.jpg)'
- en: '**Figure 12.3** FOMO3D dapp, played by Victor Fang in July 2018'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.3** 2018 年 7 月 Victor Fang 玩的 FOMO3D dapp'
- en: A user buys a key, in other words, a lottery ticket, to participate.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户购买一个密钥，换句话说，就是一张彩票，来参与游戏。
- en: When anyone buys a key, the countdown clock adds a few seconds, with 24 hours
    being the maximum.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何人购买一个钥匙时，倒计时钟会增加几秒钟，最多24小时。
- en: The final buyer when the clock hits 0 wins the jackpot!
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计时器归零时，最后的买家将赢得大奖！
- en: Each key buyer receives random airdrop bonuses.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每位钥匙购买者都会收到随机的空投奖励。
- en: 'In fact, FOMO3D is a typical Ponzi scheme that theoretically should never stop,
    because it is driven by human nature: greed.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，FOMO3D是一个典型的庞氏骗局，理论上应该永远不会停止，因为它是由人性驱动的：贪婪。
- en: Unfortunately, FOMO3D, and its copycat LastWinner, were both hacked in August
    2018\. Those hacks led to the discovery of *blockchain advanced persistent threats*
    (BAPTs). *Advanced persistent threat* (APT) is defined as stealthy and continuous
    computer hacking processes, often orchestrated by people targeting a specific
    entity. So, BAPTs are APTs applied to blockchains.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，FOMO3D和其山寨版LastWinner都在2018年8月遭到了黑客攻击。这些攻击导致了*区块链高级持续性威胁*（BAPTs）的发现。"高级持续性威胁"（APT）被定义为悄无声息且持续的计算机黑客行为，通常是由针对特定实体的人组织的。因此，BAPTs是应用于区块链的APT。
- en: '**Note**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: According to *MIT Technology Review*, “In August 2018, AnChain.ai identified
    five Ethereum addresses behind an extremely sophisticated attack that exploited
    a contract flaw in a popular gambling game to steal $4 million.” In response,
    the creators of FOMO3D, commented that everything worked as intended. “No rules
    we set in place were broken. Our experiments strive to find exploits where human
    nature and blockchain interact. We design our projects around fighting such threats,
    We were not a bank that was robbed. The very goal of our project was for someone
    to win it and run away with everything!”
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*MIT技术评论*，“2018年8月，AnChain.ai识别出五个以太坊地址，这些地址背后进行了一次极其复杂的攻击，利用了一个流行赌博游戏中的合约漏洞，窃取了400万美元。”作为回应，FOMO3D的创造者表示一切按计划进行。“我们制定的任何规则都没有被打破。我们的实验努力寻找人类本性和区块链互动的漏洞。我们围绕抗击此类威胁设计我们的项目。我们不是一个被抢劫的银行。我们项目本身的目的是有人赢得它并带着一切逃跑！”
- en: Random number generation (RNG) is commonly used in dapps, just like all online
    Internet games. Think about an online poker game. The house will generate the
    hand based on a random number generator for every play.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成（RNG）在dapp中很常见，就像所有在线互联网游戏一样。想想一个在线扑克游戏。庄家将为每局游戏基于随机数生成器生成一手牌。
- en: 'A perfect random number should mathematically have high entropy and cannot
    be predicted. However, on-blockchain RNG turns out to be quite challenging because
    of the nature of the blockchain: immutable, decentralized, transparent.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的随机数应该在数学上具有高熵，并且无法预测。然而，区块链上的RNG最终证明是非常具有挑战性的，因为区块链的性质：不可篡改、去中心化、透明。
- en: Once the dapp has “bad randomness,” it will be exploited by hackers who can
    predict the game play.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦dapp出现“不良随机性”，它就会被黑客利用，预测游戏玩法。
- en: '**Note**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Lity language and virtual machine extend the Ethereum protocol to provide
    highly secure random number seeds for smart contracts when the underlying blockchain
    consensus is delegated proof of stake (DPoS). Please see [Chapter 14](ch14.xhtml#ch14)
    for more details.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Lity语言和虚拟机扩展了以太坊协议，当底层区块链共识委托证明权益（DPoS）时，为智能合约提供高度安全的随机数种子。更多详细信息请参见[第14章](ch14.xhtml#ch14)。
- en: The following is the code snippet of the FOMO3D `airdrop()` function that will
    generate a random number based on various sources such as `timestamp`, `block
    coinbase`, `sender`, and so on, yielding the result if the participant is the
    winner or not.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从FOMO3D`airdrop()`函数的代码片段，该函数将根据各种来源（如`timestamp`、`block coinbase`、`sender`等）生成随机数，如果参与者是赢家则产生结果。
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_3)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch12_images.xhtml#pro12_3)。
- en: '[PRE28]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Technically, this `airdrop()` function is bug-free. However, in the context
    of a blockchain-based smart contract, this code is vulnerable, as explained here:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个`airdrop()`函数是没有缺陷的。然而，在基于区块链的智能合约的背景下，这段代码是有漏洞的，原因如下：
- en: The Ethereum blockchain takes seconds to reach the consensus.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊区块链在几秒钟内达到共识。
- en: This code can be executed in milliseconds in a typical computer, which is 1,000
    times faster than on the blockchain.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码在典型计算机上可以在毫秒级执行，比在区块链上快了1000倍。
- en: This smart contract source code is transparent to everyone on the blockchain.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个智能合约的源代码对区块链上的每个人都是透明的。
- en: All the random number seeds used are transparent to everyone on the blockchain;
    in other words, there’s a lack of entropy.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有使用的随机数种子对区块链上的每个人都是透明的；换句话说，缺乏熵。
- en: Based on these facts, it is feasible for a hacker to design a malicious smart
    contract to exploit this bad randomness, by precomputing the `airdrop()` result,
    and participating in FOMO3D only when the result is known to be winning! Brilliant
    idea!
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些事实，黑客完全可能设计出一个恶意的智能合约，通过预计算`airdrop()`的结果，只有在知道结果是赢的情况下才参与FOMO3D！这个想法太棒了！
- en: '[Figure 12.4](ch12.xhtml#ch12fig4) visualizes the entire hacking campaign.
    There were 2 million transactions involved over the course of 2 weeks, and there
    were 22,000+ Ethereum addresses involved. Most of them were malicious attack smart
    contracts, launched by the five wallet addresses!'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4（[Figure 12.4](ch12.xhtml#ch12fig4)）展示了整个黑客活动。在两周的时间里，涉及了两百万笔交易，还有超过22,000个以太坊地址参与其中。其中大多数都是五钱包地址发起的恶意攻击智能合约！
- en: '![image](Images/yuan_f12_04.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f12_04.jpg)'
- en: '**Figure 12.4** Visualization of the BAPT-LW hacker group (more than five ETH
    wallet addresses) attacking LastWinner, a FOMO3D copycat dapp, in August 2018'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.4** BAPT-LW黑客小组（拥有超过五个ETH钱包地址）在2018年8月攻击LastWinner，一个FOMO3D的山寨dapp。'
- en: Unknowns and Beyond
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未知与超越
- en: Note that these reported vulnerabilities may be only the tip of the iceberg.
    There were more than 1 million smart contracts deployed on Ethereum at the end
    of 2018, while only 50,000 of them contained publicly accessible source code.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些报告的漏洞可能只是冰山一角。到2018年底，以太坊上有超过100万个智能合约部署，而其中只有50,000个包含了公开可访问的源代码。
- en: Based on research powered by the AnChain.ai smart contract auditing sandbox,
    more than 0.6 percent of the 50,000 mainnet-deployed smart contract source code
    is vulnerable to a reentrancy attack. There are 57,911 known vulnerabilities among
    all of them.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 基于AnChain.ai智能合约审计沙箱的研究表明，超过0.6%的50,000个主网上部署的智能合约源代码容易受到重入攻击。其中已知有57,911个漏洞。
- en: Even a known vulnerability can repeat history. On January 16, 2019, the Constantinople
    protocol upgrade was delayed, at the last minute, because of a security vulnerability
    enabled by EIP 1283\. This vulnerability led to the possibility of a new reentrancy
    vector making previously known secure withdrawal patterns (`.send()` and `.transfer()`)
    unsafe in specific situations, where the attacker could hijack the control flow
    and use the remaining gas enabled by EIP 1283\. The upgrade was hence delayed.
    Otherwise, another Ethereum catastrophe would happen.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至一个已知的漏洞也可能重蹈覆辙。2019年1月16日，由于EIP 1283启用的安全漏洞，Constantinople协议升级在最后一刻被推迟。这个漏洞导致了一种新的重入向量，使得在特定情况下，攻击者可以劫持控制流并利用EIP
    1283剩余的燃料，使得之前已知的安全提现模式（`.send()`和`.transfer()`）变得不安全。因此，升级被推迟。否则，将会发生另一场以太坊灾难。
- en: On the other hand, there may be unknown vulnerabilities that already exist but
    have not yet been discovered, like zero-day bugs in the cybersecurity industry.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可能存在未知的安全漏洞，就像网络安全行业中的零日漏洞一样，它们已经存在但尚未被发现。
- en: 'I will conclude this section with the Decentralized Application Security Project
    (DASP) top-ten vulnerabilities of 2018:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用Decentralized Application Security Project (DASP) 2018年的十大漏洞来结束本节：
- en: Reentrancy
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重入
- en: Access control
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Arithmetic
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术
- en: Unchecked low-level calls
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未检查的低级调用
- en: Denial of service
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务拒绝
- en: Bad randomness
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不良随机性
- en: Front running
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端运行
- en: Time manipulation
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间操纵
- en: Short addresses
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短地址
- en: Unknown unknowns
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知未知
- en: Best Practices for Securing Smart Contracts
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保障智能合约安全的最佳实践
- en: As you can see from the previously mentioned major smart contract hacks, developing
    secure smart contracts can be quite challenging.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的那些重大的智能合约黑客攻击事件所示，开发安全的智能合约可能非常具有挑战性。
- en: 'In fact, Steve McConnell’s “Code Complete” shows the following statistics for
    the number of bugs per line of code:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Steve McConnell的《代码完成》（Code Complete）展示了每行代码的缺陷数量如下统计数据：
- en: '*Industry average*: About 15 to 50 errors per 1,000 lines of delivered code'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行业平均水平**：交付的每1,000行代码约有15到50个错误。'
- en: '*Microsoft applications*: About 10 to 20 defects per 1,000 lines of code during
    in-house testing and 0.5 defect per 1,000 lines of code in released products'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微软应用程序**：在内部测试期间，每1,000行代码约有10到20个缺陷，而在发布的产品中，每1,000行代码约有0.5个缺陷。'
- en: Another challenge for the Ethereum blockchain is that it’s hard to change the
    smart contract code once it’s deployed. Think about Microsoft Windows patches
    that arrive weekly to fix known vulnerabilities. There is no such mechanism on
    the blockchain. It’s “code is law.”
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以太坊区块链来说，另一个挑战是一旦智能合约代码部署后很难更改。想想每周都会发布的 Microsoft Windows 补丁，用以修复已知的漏洞。区块链上没有这样的机制。这是“代码即法律”。
- en: '**Note**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Lity project provides a mechanism to upgrade Ethereum-compatible smart contracts
    on Lity-based blockchains. The idea is to declare the contract interface at the
    contract address and then provide proxy implementations of all the functions.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Lity 项目提供了一种在 Lity 基础区块链上升级以太坊兼容智能合约的机制。想法是在合约地址声明合约接口，然后提供所有函数的代理实现。
- en: Hence, it is critical to write secure code in the upcoming smart contract era.
    Fortunately, there are various projects and startups that aim to help developers
    secure their smart contracts by performing auditing to identify vulnerabilities.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在即将到来的智能合约时代，编写安全的代码至关重要。幸运的是，有各种项目和初创公司旨在通过执行审计以识别漏洞，帮助开发者保护他们的智能合约。
- en: The following are a few best practices.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最佳实践。
- en: Expert Manual Auditing
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 专家手动审计
- en: The widely adopted way to audit smart contracts, especially the ICO tokens,
    is called *expert manual auditing*. Solidity is new programing language and lacks
    security tools compared to the commercial tools in the well-established cybersecurity
    industry such as Coverity for enterprise C++/Java source code auditing. The experts
    are mostly computer language experts with experience to identify vulnerabilities
    manually.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛采用的审计智能合约的方法，尤其是 ICO 代币，被称为*专家手动审计*。Solidity 是一种新的编程语言，与拥有成熟网络安全行业的商业工具，如针对企业
    C++/Java 源代码审计的 Coverity 相比，缺乏安全工具。专家大多是计算机语言专家，有经验能手动识别漏洞。
- en: Formal Verification
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 形式验证
- en: '*Formal verification* (FV) is one of the promising fields for smart contract
    auditing that aims to mathematically prove the source code correctness. According
    to an EE Times article by Alok Sanghavi, “Formal verification is the act of proving
    or disproving the correctness of intended algorithms underlying a system with
    respect to a certain formal specification or property, using formal methods of
    mathematics.” In fact, the formal method dates back 40 years ago, and there are
    various applications such as Windows leveraging formal verification to prove some
    of the critical kernel modules’ source code correctness.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**形式验证**（Formal Verification，FV）是智能合约审计中一个充满前景的领域，其目标是数学地证明源代码的正确性。根据 Alok
    Sanghavi 在 EE Times 文章中的说法，“形式验证是使用数学的形式方法证明或反驳系统下某个特定形式规范或属性所预期的算法的正确性。”实际上，形式方法可以追溯到40年前，有许多应用，例如
    Windows 利用形式验证来证明一些关键内核模块的源代码的正确性。'
- en: Sandbox
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[沙盒](https://en.wikipedia.org/wiki/Sandboxing)'
- en: A *sandbox*, simply put, is a specially designed virtual machine that can automatically
    execute the opcode instructions in a restricted environment. It’s a proven technology
    in cybersecurity; companies like FireEye and Palo Alto Network develop malware
    sandbox products that can detect the most sophisticated malware like APT32, and
    so on.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*沙盒*，简单来说，是一个特别设计的虚拟机，可以在受限环境中自动执行操作码指令。在网络安全中，这是经过验证的技术；像 FireEye 和 Palo
    Alto Networks 这样的公司开发了可以检测到像 APT32 这样的最复杂恶意软件的恶意软件沙盒产品等等。
- en: For example, modern advanced malware is polymorphic, which means it will modify
    its own bytes, while most antivirus (AV) software still relies on signature-based
    detection, which is a hash of the payload bytes. Hence, this polymorphic malware
    can bypass the AV detection since they have different hashes, even though they
    function similarly. Alternatively, the sandbox will analyze the code execution
    behaviors and look for suspicious patterns in a fully automated fashion.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现代高级恶意软件是多态的，这意味着它会修改自己的字节，而大多数防病毒（AV）软件仍然依赖于基于签名的检测，即有效负载字节的哈希。因此，这种多态恶意软件可以绕过
    AV 检测，因为它们的哈希不同，即使它们的功能相似。另外，沙盒将以完全自动化的方式分析代码执行行为，寻找可疑模式。
- en: Inspired by the proven success of the malware sandbox, AnChain.ai developed
    the world’s first smart contract auditing sandbox and launched in February 2019\.
    A good sandbox product should have built-in features such as static analysis,
    dynamic execution, statistical analysis, code similarity, and so on.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 受到恶意软件沙盒成功证明的启发，AnChain.ai开发了世界上第一个智能合约审计沙盒，并于2019年2月推出。一个好的沙盒产品应该具备静态分析、动态执行、统计分析、代码相似性等内置功能。
- en: Tools
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工具
- en: 'Based on these best practices, the following are popular open source tools
    that can get you started with secure smart contracts:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些最佳实践，以下是一些流行的开源工具，可以帮助您开始安全智能合约的编写：
- en: '*Mythril Classic*: This is an open source EVM bytecode security analysis tool.
    See [https://github.com/ConsenSys/mythril-classic](https://github.com/ConsenSys/mythril-classic).'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mythril Classic**：这是一个开源的EVM字节码安全分析工具。参见[https://github.com/ConsenSys/mythril-classic](https://github.com/ConsenSys/mythril-classic)。'
- en: '*Oyente*: This is an alternative for static smart contract security analysis.
    See [https://github.com/melonproject/oyente](https://github.com/melonproject/oyente).'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oyente**：这是静态智能合约安全分析的一个替代方案。参见[https://github.com/melonproject/oyente](https://github.com/melonproject/oyente)。'
- en: '*Slither*: This is a Solidity static analysis framework. See [https://github.com/crytic/slither](https://github.com/crytic/slither).'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Slither**：这是一个Solidity静态分析框架。参见[https://github.com/crytic/slither](https://github.com/crytic/slither)。'
- en: '*Adelaide*: This is the SECBIT static analysis extension to the Solidity compiler.
    See [https://github.com/sec-bit/Adelaide](https://github.com/sec-bit/Adelaide).'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Adelaide**：这是SECBIT对Solidity编译器的静态分析扩展。参见[https://github.com/sec-bit/Adelaide](https://github.com/sec-bit/Adelaide)。'
- en: '**Note**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Lity project (see [https://www.litylang.org](https://www.litylang.org))
    provides Ethereum-compatible tools to perform static analysis at compile time,
    using tools like Oyente and ERC Checker. See [Chapter 15](ch15.xhtml#ch15) for
    more details.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Lity项目（参见[https://www.litylang.org](https://www.litylang.org)）提供了与以太坊兼容的工具，在编译时执行静态分析，使用Oyente和ERC
    Checker等工具。更多详细信息请参见第15章。
- en: Conclusion
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I covered the major Ethereum smart contract hacks and vulnerabilities
    in its short history and discussed best practices for securing smart contracts.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我涵盖了以太坊智能合约在其短暂历史中的主要黑客攻击和漏洞，并讨论了保护智能合约的最佳实践。
- en: Ethereum is still in its infancy. I consider it to be like 1990’s Internet,
    slow and vulnerable. But it will soon become as mature as 2019’s Internet. However,
    with data breaches and APT hacks occasionally making headlines, even Internet
    security still has a long way to go. Security is a collaborative effort that involves
    many specialized experts, teams, and tools. Are you ready to secure your smart
    contracts?
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊仍处于婴儿期。我认为它就像20世纪90年代的互联网，发展缓慢且脆弱。但是，它很快就会像2019年的互联网一样成熟。然而，由于数据泄露和APT攻击时不时上头条，即使是互联网安全还有很长的路要走。安全是一个需要许多专业专家、团队和工具共同合作的努力。您准备好保护您的智能合约了吗？
- en: 13. The Future of Ethereum
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13. 以太坊的未来
- en: By Tim McCallum
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Tim McCallum
- en: The creator of Ethereum, Vitalik Buterin, defines *blockchain* as a decentralized
    system that contains shared memory, and as such, a good blockchain application
    is one that needs both a decentralized architecture and shared memory capabilities
    across the network’s architecture. Ethereum’s focus, to date, has been on decentralization
    (philosophically, decentralizing the Internet). The Internet, while possessing
    the design characteristics to be decentralized, has since its inception become
    increasingly centralized. The Ethereum network provides guaranteed decentralized
    computation on a global scale. In addition to this, the Ethereum network holds
    shared memory within the entire network, known as the *state*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的创造者，Vitalik Buterin，将*区块链*定义为包含共享内存的去中心化系统，因此，一个好的区块链应用程序需要具有去中心化架构和网络架构中的共享内存能力。到目前为止，以太坊的关注点在于去中心化（从哲学上讲，是去中心化互联网）。尽管互联网拥有设计上的去中心化特征，但从其诞生之初，就变得越来越中心化。以太坊网络在全球范围内提供保证的去中心化计算。此外，以太坊网络在整个网络中持有共享内存，称为*状态*。
- en: These attributes, in a technical sense, make Ethereum a “world computer.” It
    has already proven that it can support next-generation decentralized applications
    (dapps) that facilitate customized online payments, authentication mechanisms,
    decentralized storage solutions (swarm), digital currencies, and much more.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些属性使以太坊成为了一台“世界电脑”。它已经证明，它能够支持下一代去中心化应用程序（dapps），这些应用程序可以促进定制的在线支付、认证机制、去中心化存储解决方案（swarm）、数字货币等等。
- en: In this chapter, I begin by covering the 2018 development of Ethereum. I will
    discuss how the Ethereum foundation’s researchers and Ethereum developers are
    solving present-day challenges. I then step into the future by uncovering developments
    that are at the fringe; these are developments that could materialize as proof
    of concepts for early adoption around 2020\. Before concluding the future of Ethereum,
    I look well into the future at the “hard-to-implement” paradigm shifts that, if
    realized, could propel Ethereum forward, beyond what is even imaginable today
    in terms of privacy, scalability, and security.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我从2018年以太坊的发展开始讲解。我将讨论以太坊基金会的研究人员和以太坊开发者如何解决当今的挑战。然后我揭示了一些处于边缘的发展，这些发展可能会在2020年左右作为早期采用的证明概念实现。在结束以太坊未来的讨论之前，我深入探讨了一些“难以实施”的范式转变，如果实现，可能会推动以太坊前进，甚至超出今天在隐私、可扩展性和安全性方面所能想象的。
- en: '**Note**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Potential improvements to the Ethereum network go through the Ethereum Improvement
    Proposal (EIP) process before being implemented. The stages for EIPs are draft,
    accepted, final, and differed. Finalized EIPs are proposals that have been adopted.
    For a proposal to succeed, the issuer is required to provide detailed information
    including the motivation, specifications, rationale, and backward compatibility.
    The proposal may also provide code examples.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的对以太坊网络的改进需要通过以太坊改进提案（EIP）流程才能实施。EIP的阶段包括草稿、接受、最终和延迟。已最终确定的EIP是已被采纳的提案。为了让提案成功，发布者需要提供详细信息，包括动机、规格、理由和向后兼容性。提案也可能提供代码示例。
- en: One of the most famous EIPs is EIP20, which defines the smart contracts for
    issuing ERC20 tokens on the Ethereum blockchain. You can read the EIP20 standard
    at `https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md`. You can review
    all EIPs at `https://github.com/ethereum/EIPs`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的EIP之一是EIP20，它定义了在以太坊区块链上发行ERC20代币的智慧合约。你可以通过`https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md`阅读EIP20标准。你可以在`https://github.com/ethereum/EIPs`查看所有EIP。
- en: Ethereum 1.0
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊1.0
- en: There were three main categories of challenges on the table for Ethereum in
    2018\. These are privacy, consensus, and scalability. The Ethereum Foundation’s
    researchers and Ethereum developers have already made inroads into solving these
    problematic areas. As you will read shortly, Ethereum has already released its
    hybrid proof-of-work (PoW)/proof-of-stake (PoS) consensus mechanism known as Casper
    the Friendly Finality Gadget (FFG). The future Ethereum road map is very exciting
    and full of activity. To kick things off, let’s take a look at the problems and
    solutions around privacy, consensus, and scalability in a bit more depth.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，以太坊面临的三个主要挑战是隐私、共识和可扩展性。以太坊基金会的研究人员和以太坊开发者已经在解决这些问题方面取得了进展。正如你即将读到的，以太坊已经发布了其混合工作量证明（PoW）/权益证明（PoS）共识机制，名为Casper
    the Friendly Finality Gadget (FFG)。未来的以太坊路线图非常令人兴奋，充满了活动。为了开始，让我们更深入地了解一下隐私、共识和可扩展性方面的问题和解决方案。
- en: Privacy
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隐私
- en: The privacy paradox is such that while lots of nodes are verifying your data
    on the public ledger (providing security through collaborative consensus), having
    your data on the public ledger, in fact, compromises your privacy. Here is an
    example. If somebody knew the date, time, and amount particulars of a transaction
    that you sent or received, that person could inspect the public ledger and identify
    your account’s address (public key). This issue is common to most public distributed
    ledgers (blockchains), not just Ethereum. What is important is, from that moment,
    that person could track your account balance, income, and spending via the public
    ledger. This is an invasion of your privacy. Inroads have been made into resolving
    the privacy problem at the base protocol level. The Byzantium fork released by
    Ethereum in October 2017 introduced new cryptographic algorithms (zero-knowledge
    proofs and ring signatures). These cryptographic tools and other enhancements
    to the Ethereum network such as the introduction of state channels are all going
    to help developers resolve these and other privacy problems.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私悖论在于，尽管有很多节点在公共账本上验证您的数据（通过协作共识提供安全性），但您的数据实际上在公共账本上会泄露您的隐私。以下是一个例子。如果有人知道您发送或接收的交易的具体日期、时间和金额，那个人可以检查公共账本并识别出您的账户地址（公钥）。这个问题不仅出现在以太坊上，还出现在大多数公共分布式账本（区块链）上。重要的是，从那一刻起，那个人可以通过公共账本跟踪您的账户余额、收入和支出。这是对您隐私的侵犯。已经在基础协议级别上取得了进展，以解决隐私问题。以太坊在2017年10月发布的拜占庭分叉引入了新的加密算法（零知识证明和环签名）。这些加密工具以及以太坊网络的其他改进，如状态通道的引入，都将在帮助开发者解决这些问题和其他隐私问题方面发挥作用。
- en: Consensus
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共识
- en: '[Chapter 2](ch02.xhtml#ch02) discussed the PoW and PoS consensus mechanisms
    of blockchains. Ethereum, since its inception, has always been a PoW blockchain.
    However, with the next-generation Ethereum, it is moving toward PoS. The switch
    from PoW to PoS is perhaps the greatest challenge and opportunity facing the Ethereum
    community today.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章[讨论了区块链的PoW和PoS共识机制](ch02.xhtml#ch02)。自成立以来，以太坊一直是一个PoW区块链。然而，随着下一代以太坊的到来，它正朝着PoS迈进。从PoW到PoS的转变可能是以太坊社区今天面临的最大挑战和机遇。
- en: 'The advent of the PoW protocol introduced one of the most revered blockchain
    attributes: immutability. More specifically, it is computationally impractical
    to reverse past transactions while computers (nodes on the peer-to-peer blockchain
    network) are competing to expend their computational energy, creating new blocks
    (mining the blockchain). Ethereum currently also uses the PoW consensus protocol,
    and just like with Bitcoin, the PoW consensus process on the Ethereum network
    thrives as computers all compete on the network, expending their computational
    energy, to create new blocks on top of the blockchain.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（PoW）协议的诞生带来了一种最受尊敬的区块链属性：不可变性。更具体地说，在计算机（点对点区块链网络中的节点）竞争消耗其计算能量创建新块（挖掘区块链）时，逆转过去的交易在计算上是不切实际的，从而创建新的区块。以太坊目前也使用PoW共识协议，就像比特币一样，以太坊网络上的PoW共识过程随着所有计算机在网络上竞争，消耗其计算能量，在区块链上创建新的区块而蓬勃发展。
- en: While PoW has many strengths, it is also criticized in relation to energy efficiency
    and potential centralization of the PoW mining process.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PoW有许多优点，但也有人对其能源效率和PoW挖矿过程潜在的集中化问题提出批评。
- en: Proof of Stake
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权益证明（Proof of Stake，PoS）
- en: In October 2017, Ethereum’s Vitalik Buterin and colleague Virgil Griffith released
    a publication called Casper the Friendly Finality Gadget. Casper FFG is a partial
    consensus mechanism that combines PoS algorithm research and Byzantine fault-tolerant
    consensus theory. Importantly, for implementation, Casper FFG was designed to
    overlay an existing operational PoW blockchain. Hence, Casper FFG is a hybrid
    PoW/PoS consensus solution. While a formal move to PoS will only happen on Ethereum
    2.0, the PoS experimentation has already started on Ethereum 1.0.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年10月，以太坊的维塔利克·布特林（Vitalik Buterin）和同事维吉尔·格里夫斯（Virgil Griffith）发布了一篇名为《友好的最终性装置Casper》的论文。Casper
    FFG是一种部分共识机制，结合了PoS算法研究和拜占庭容错共识理论。重要的是，为了实施，Casper FFG被设计为在现有的操作PoW区块链之上叠加。因此，Casper
    FFG是一种混合PoW/PoS共识解决方案。虽然正式的PoS迁移只会在以太坊2.0上发生，但PoS实验已经在以太坊1.0上开始。
- en: There are more than three Ethereum testnets. These Ethereum testnets are sandboxes,
    used to simulate the Ethereum network and the Ethereum Virtual Machine (EVM).
    Ethereum’s hybrid PoW/PoS implementation, Casper FFG, was launched in its own
    testnet (not in production) in January 2018\. The following discussion is an early
    overview of the Casper FFG PoW/PoS hybrid consensus solution.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过三个以太坊测试网络。这些以太坊测试网络是沙盒，用于模拟以太坊网络和以太坊虚拟机（EVM）。以太坊的混合PoW/PoS实现Casper FFG于2018年1月在自身的测试网络（非生产网络）中启动。以下讨论是对Casper
    FFG PoW/PoS混合共识解决方案的早期概述。
- en: 'In PoW mining, a miner is given a challenge: finding a nonce. Finding the nonce
    is done by brute force and involves randomly guessing repeatedly until the nonce
    is discovered. This process is miners’ proof that they have worked. That’s why
    it’s called *proof of work*. In PoS, the blocks are created by validators. Validators
    are allowed to participate in creating blocks only if they put skin in the game.
    This involves staking a large deposit (at this early stage believed to be around
    1,500 ETH). That’s why it’s called *proof of stake*.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在PoW挖矿中，矿工被给予一个挑战：寻找一个nonce。通过暴力破解，通过反复随机猜测直到发现nonce。这个过程是矿工的工作证明。这就是为什么它被称为*工作量证明*。在PoS中，区块由验证者创建。只有当验证者投入资金时，他们才被允许参与区块的创建。这涉及到投入一大笔存款（在现阶段被认为是大约1500
    ETH）。这就是为什么它被称为*权益证明*。
- en: PoS validation is unlike PoW mining from a hardware perspective as there is
    no specialized competing hardware required. The validators are all virtual (software).
    The process of joining and leaving the role of being a validator in PoS is known
    as *bonding* and *unbonding*, respectively. So, how is the bonding and unbonding
    recorded? Casper FFG saves the bonding and unbonding activity in the blockchain
    state (along with account balances and so forth). Anyone can join the set of validators
    by sending an Ethereum transaction to the Casper contract (along with some parameters
    such as a withdrawal address and of course ETH for gas).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件角度来看，PoS验证与PoW挖矿不同，因为不需要专门的竞争硬件。验证者都是虚拟的（软件）。在PoS中成为验证者的加入和离职过程分别称为* bonding*和*
    unbonding*。那么，绑定和解绑是如何记录的？Casper FFG将绑定和解绑活动保存到区块链状态中（包括账户余额等）。任何人都可以通过向Casper合约发送以太坊交易来加入验证者集合（附带一些参数，如提现地址和当然的ETH作为燃料费）。
- en: The basic premise behind PoS validation involves economic incentives. For example,
    a bonded validator who exerts clearly bad behavior (like creating two blocks at
    the same height) will be penalized economically. On the other hand, a bonded validator
    that does not deliberately attack the network will receive returns, or interest,
    on the deposit that they have staked. In the Casper FFG PoS implementation, the
    number of opportunities where manipulation is more profitable than the costs associated
    with performing the manipulation is small. Ideally, there would be close to zero
    (no) opportunities to manipulate (attack) the network without encountering a severe
    economic penalty. In a given PoW blockchain implementation (where all nodes are
    running the same PoW consensus mechanism), the chain with the most blocks (the
    longest chain) wins (see [Figure 13.1](ch13.xhtml#ch13fig1)). This is because
    it exhibits the most proof of work.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 权益证明（PoS）验证的基本前提涉及经济激励。例如，一个表现明显不良行为（如在同一高度创建两个区块）的质押验证者将受到经济惩罚。另一方面，一个没有故意攻击网络的质押验证者将获得他们投入的存款的回报，或者说是利息。在Casper
    FFG PoS实现中，操纵比执行操纵所花费的成本更有利的机会很少。理想情况下，操纵（攻击）网络而不遭受严重经济惩罚的机会接近于零（没有）。在给定的工作量证明（PoW）区块链实现中（所有节点都在运行相同的PoW共识机制），拥有最多区块（最长链）的链获胜（参见[图13.1](ch13.xhtml#ch13fig1)）。这是因为它展示了最多的工作量证明。
- en: '![image](Images/yuan_f13_01.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f13_01.jpg)'
- en: '**Figure 13.1** The PoW algorithm identifies the longest chain as the authoritative
    one.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.1** PoW算法将最长的链识别为权威链。'
- en: In Casper FFG PoS, the chain with the most value at risk (VaR) supporting it
    wins. The general principle is that if you support a block that does not make
    it into the main chain, instead of being rewarded you get penalized. You lose
    an amount of ETH that is equal to the block reward. In practice, let’s propose
    that there are two blocks available to support. The block on chain A has a 90
    percent chance of succeeding. The block on chain B has a 10 percent chance of
    succeeding. If you support chain A, you will be rewarded. If you support chain
    B, you will be penalized. A potential economic conundrum comes into play if you
    start thinking that you could support both A and B for profit. Ethereum has a
    clever way of making this unappealing. In this case, where you have split your
    bet two ways, you will only be allowed to receive 50 percent of the reward from
    chain A (if it succeeds) and 50 percent of the reward from chain B (if it succeeds).
    This betting on both sides will always net a lesser result than just supporting
    chain A. This economic incentive results in convergence, and this is the desired
    path to ensure a single honest chain via PoS consensus. The following is a simple,
    albeit concrete, example for demonstration purposes.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在Casper FFG PoS中，风险价值（VaR）支持最高的链胜出。其基本原则是，如果你支持的区块没有进入主链，你不但不会得到奖励，反而会受到惩罚。你会失去与区块奖励相等的ETH。实践中，我们假设有两块区块可供支持。链A上的区块有90%的成功率。链B上的区块有10%的成功率。如果你支持链A，你会得到奖励。如果你支持链B，你会受到惩罚。如果你开始认为你可以同时支持A和B来获利，那么一个潜在的经济难题就会产生。以太坊有一种巧妙的方式使这变得不具吸引力。在这种情况下，你把赌注分成了两部分，你只能从链A（如果它成功）获得50%的奖励，从链B（如果它成功）获得50%的奖励。这种两边下注的方式总是比仅仅支持链A得到的结果要差。这种经济激励导致了趋同，这是通过PoS共识确保单一诚实链的期望路径。以下是一个简单但具体的示例，用于说明目的。
- en: Suppose the block reward is 10 ETH. Suppose you, as a validator, support a block
    on chain A and a block on chain B. In a scenario where chain A succeeds, you would
    receive 5 ETH (only 50 percent of the block reward) from your efforts on chain
    A, and you would lose 10 ETH (the entire block reward) for supporting a block
    on chain B. The net result for this scenario would be negative 5 ETH for your
    efforts.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 假设区块奖励是10 ETH。假设你作为一个验证者，在链A上支持一个区块，在链B上也支持一个区块。假设链A成功的情况下，你从链A的努力中会收到5 ETH（区块奖励的50%），而因为支持链B的区块，你会失去10
    ETH（整个区块奖励）。这种情况下，你的努力净结果会是负5 ETH。
- en: In PoS, the validator needs to authenticate. It has been proposed that, instead
    of simply using a private key, a validator code function be created. This modular
    design would mean that the validator could choose alternative signatures when
    authenticating. For example, the validator could choose to use a Lamport signature
    as these are believed to be secure against quantum computer threats.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在权益证明（PoS）中，验证者需要进行身份验证。已经有人提议，不如仅仅使用私钥，而应该创建一个验证者代码函数。这种模块化设计意味着验证者在进行身份验证时可以选择其他的签名方式。例如，验证者可以选择使用Lamport签名，因为人们认为它能够抵御量子计算机的威胁。
- en: Scalability
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Blockchain systems trade off against decentralization, scalability, and security.
    It is reasonably easy to solve any two out of these three issues at any one time.
    Vitalik Buterin quips that this is a blockchain “trillema,” whereby you can easily
    solve two issues at the cost of the third, but you can’t easily solve all three.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链系统在去中心化、可扩展性和安全性之间进行权衡。在任意一时间点，很容易同时解决其中的任意两个问题。Vitalik Buterin戏称这是区块链的“三难”，即你可以轻松解决两个问题，但代价是第三个问题，但你不能轻松解决所有三个问题。
- en: Plasma
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Plasma
- en: Plasma is just one of the strategies that could address blockchain scalability.
    Plasma is different from sharding (covered later in the chapter). A successful
    plasma implementation would send transactions off-chain to improve scalability.
    In this regard, plasma is what is known as a second-layer solution. Second-layer
    solutions are implemented through code that is written outside of the base protocol
    layer (or, commonly known as the layer 1 protocol). More specifically, second-layer
    solutions have no effect on the base protocol layer’s consensus mechanism. Just
    to clarify, plasma differs from sharding in that a successful sharding solution
    would be coded into the base protocol layer. Plasma is designed to be compatible
    with on-chain scaling solutions such as sharding and therefore not only can coexist
    but can even be complementary. In fact, on-chain scalability improvements will
    just further increase the scalability of the second-layer solution.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: Plasma 只是可能解决区块链可扩展性问题的众多策略之一。Plasma 与分片（在本书稍后部分讨论）不同。成功的 Plasma 实施将把交易移至链下，以提高可扩展性。在这方面，Plasma
    被称为第二层解决方案。第二层解决方案是通过编写在基础协议层之外（或者说，通常被称为第 1 层协议）的代码实现的。更具体地说，第二层解决方案对基础协议层的共识机制没有影响。为了澄清，Plasma
    与分片的区别在于，成功的分片解决方案将被编写到基础协议层中。Plasma 旨在与链上扩展解决方案（如分片）兼容，因此不仅可以共存，甚至可以相互补充。实际上，链上可扩展性的改进将进一步增加第二层解决方案的可扩展性。
- en: Plasma is a set of nested blockchains. These plasma blockchains are created
    using smart contracts on the main Ethereum network. Uploading your smart contract
    onto the public Ethereum blockchain allows you to launch your own specific applications.
    Applications can include decentralized exchanges, social networks, payment networks,
    and even your own private Ethereum blockchain implementation. These plasma blockchains
    (your applications) are all accountable to the public Ethereum blockchain.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: Plasma 是一组嵌套的区块链。这些 Plasma 区块链是使用以太坊主网络上的智能合约创建的。将你的智能合约上传到公共以太坊区块链上，使你能够启动你自己的特定应用程序。这些应用程序可以包括去中心化交易所、社交网络、支付网络，甚至是你自己的私有以太坊区块链实现。这些
    Plasma 区块链（你的应用程序）都受到公共以太坊区块链的监督。
- en: The scalability is brought about by the fact that while processing an extremely
    high volume of transactions, the plasma blockchains do not submit their entire
    transaction volume to the public Ethereum blockchain. Instead, the plasma blockchains
    send only a small amount of data (block header hashes) about the plasma blockchains
    state. Plasma works on the premise that data being submitted to the main chain
    is free from fraudulent activity, while the public Ethereum blockchain is not
    required to perform computation in general. If anyone can publish a proof that
    fraudulent activity took place (a dispute), the public Ethereum blockchain performs
    computation, resolving the dispute and punishing the offending participant.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是由这样的事实带来的，即在处理极其大量的交易时，Plasma 区块链不会将其全部交易量提交给公共以太坊区块链。相反，Plasma 区块链只发送有关
    Plasma 区块链状态的一小部分数据（块头哈希）。Plasma 的工作前提是提交给主链的数据不受欺诈活动的影响，而公共以太坊区块链通常不需要执行计算。如果任何人能够发布一个证明欺诈活动发生（争议）的证明，公共以太坊区块链将执行计算，解决争议并惩罚违规参与者。
- en: State Channels
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态通道
- en: State channels are a mechanism that allow two participants to sign promises,
    at given points in time. These time-based off-chain signed promises provide proof
    of activity. State channels provide an opportunity for decentralized applications
    to interact with other parties (customers) off-chain. This provides a cheap and
    fast user experience, which would not be possible on-chain. State channels are
    smart contracts. State channels are also a second-layer solution to the Ethereum
    scalability problem. From a usability perspective (dapp development), having a
    high volume of off-chain activity means low to negligible gas fees. As such, dapps
    that employ state channels as part of their solution not only offer near real-time
    activity but also the ability for customers to send and receive micro-payments.
    A use case for this could be a gambling application that allows a high volume
    of micro-betting, in real time, for entertainment purposes.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道是一种允许两个参与者签署承诺的机制，在给定的时间点。这些基于时间的链下签署承诺提供了活动证明。状态通道为去中心化应用程序提供了一个与链下其他方（客户）互动的机会。这提供了一个便宜且快速的客户体验，这在链上是不可能的。状态通道是智能合约。状态通道也是以太坊可扩展性问题的一种第二层解决方案。从可用性角度来看（dapp开发），大量的链下活动意味着低到可以忽略的燃气费。因此，采用状态通道作为解决方案的dapp不仅提供了近乎实时的活动，还使客户能够发送和接收微支付。这个用例可能是一个允许大量微赌注的赌博应用，用于娱乐目的。
- en: Raiden
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Raiden
- en: The Raiden network leverages off-chain state channels. The Raiden network offers
    micro payments of ERC20-compliant tokens while taking negligible fees and providing
    responses to transactions in near real time. The difference between state channels
    and the Raiden network is that rather than creating a new state channel for every
    new interaction between two parties, Raiden creates a network of channels whereby
    all participants are transitively connected via a web of ERC20 token–complaint
    payment channels, making use of natural network topology architecture.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Raiden网络利用了链下状态通道。Raiden网络提供微支付，同时收取微不足道的费用，近乎实时地提供交易响应。状态通道与Raiden网络之间的区别在于，Raiden并不是为两个方之间的每次新交互创建一个新的状态通道，而是创建一个通道网络，所有参与者通过一个由符合ERC20代币标准的支付通道组成的网络间接连接，利用自然的网络拓扑结构。
- en: Token Improvements
  id: totrans-547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Token Improvements
- en: The ERC20 tokens have proven to be a great success. ERC20 has found one of the
    first killer applications for Ethereum, as an initial coin offering (ICO) token
    sale platform. The Ethereum community is working on further improving tokens issued
    from the Ethereum smart contracts.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ERC20代币已经被证明是非常成功的。ERC20找到了以太坊的第一个杀手级应用，作为首次代币发行（ICO）的代币销售平台。以太坊社区正在努力改进通过以太坊智能合约发行的代币。
- en: One of the more interesting ideas is nonfungible tokens (NFTs). A key characteristic
    of money is fungible, meaning that a dollar bill is completely interchangeable
    with another dollar bill. That is the case for blockchain tokens as well. While
    you can trace the use of each token in the ledger, no two tokens are different.
    But with NFTs, a token is truly unique. The famous Ethereum game CryptoKitties
    is a good example of how NFTs can be applied, as each “cat” is completely unique.
    The ERC721 proposes an NFT standard that is compatible with ERC20\. Such NFTs
    could enable many token applications ranging from collectibles trading to real
    estate transactions. To participate in this EIP, please refer to [https://github.com/ethereum/eips/issues/721](https://github.com/ethereum/eips/issues/721).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的想法之一是非同质化代币（NFTs）。货币的一个关键特征是同质性，这意味着一张美元钞票与另一张完全可互换。这对于区块链代币也是如此。虽然你可以在账本中追踪每个代币的使用情况，但两个代币并没有什么不同。但有了NFTs，一个代币确实是独一无二的。著名的以太坊游戏CryptoKitties就是NFTs可以应用的一个很好的例子，因为每只“猫”都是完全独特的。ERC721提出了一个与ERC20兼容的NFT标准。这样的NFT可以启用许多代币应用，从收藏品交易到房地产交易。要参与这个EIP，请参考[https://github.com/ethereum/eips/issues/721](https://github.com/ethereum/eips/issues/721)。
- en: Beyond Ethereum 1.0
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越以太坊1.0
- en: Ethereum has had plans for some time to create a blockchain to surpass the current
    second-layer solutions on offer. The overall vision has primarily been to create
    a blockchain solution that is capable of scaling to thousands of on-chain transactions
    per second, with the most promising of the proposed solutions being sharding.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊有一段时间的计划要创建一个超越目前第二层解决方案的区块链。总体愿景主要是创建一个能够扩展到每秒数千个链上交易的区块链解决方案，最有前途的拟议解决方案是分片技术。
- en: Sharding
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分片技术
- en: The original idea for sharding was that the main Ethereum blockchain would publish
    what is known as a *validator manager contract*. In this scenario, the validator
    manager contract would simply be a single smart contract on the Ethereum 1.0 blockchain.
    It was decided (in July 2017) shortly after disparate development processes in
    the areas of both Casper (PoS) and sharding that this architecture would change.
    The most significant change to the original idea was to make the core component
    of the sharding system not just a smart contract but instead a complete PoS chain.
    This shift from a PoW smart contract to a self-sufficient PoS chain would remove
    the need for gas, reduce transaction times, and reduce dependency on the underlying
    EVM.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 分片原始想法是，以太坊主链将发布所谓的*验证者管理合约*。在这种情况下，验证者管理合约只是一个单一的智能合约，位于以太坊1.0区块链上。在Casper（权益证明）和分片领域的不同开发过程之后不久（2017年7月），决定改变这个架构。对原始想法的最重大改变是将分片系统的核心组件从智能合约变为完整的权益证明链。从工作量证明智能合约到自给自足的权益证明链的转变将消除燃料费，减少交易时间，并减少对底层EVM的依赖。
- en: The “Ethereum 2.0” section explains this new sharding architecture, namely,
    the introduction of the beacon chain.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: “以太坊2.0”部分解释了这种新的分片架构，即引入了信标链。
- en: Zero-Knowledge Proofs
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 零知识证明
- en: This section explains the basic premise of the zero-knowledge proofs. In a given
    binary situation (where there are only two outcomes available, either yes or no),
    a “prover” with the secret weapon to discern a binary statement from the situation
    must convince a skeptical “verifier” that the binary statement is correct, while
    not revealing the secret. In 2003 a Weizmann Institute of Science faculty member,
    Oded Goldreich, introduced a novel zero-knowledge proof involving a color-blind
    validator. In this scenario, the validator possessed two cards, one red and the
    other green. To the color-blind validator, the cards looked the same, other than
    the fact that the word *red* was written on the back of the red card, and the
    word *green* was written on the back of the other. Let’s play out this scenario
    and assume that the validator is skeptical about the prover’s claim to be able
    to discern the cards without seeing the words on the back. To move this experiment
    forward, the validator would repeatedly show the prover the front side of each
    card, in a random fashion. Each time, the validator would ask the prover what
    color he sees. After some time, the verifier would eventually be convinced that
    the prover is capable of discerning the colors of the two individual cards. This
    is mostly because the verifier performed this over many rounds and the validator
    randomly switched the cards behind his back during each round.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了零知识证明的基本前提。在给定的二进制情况下（只有两种可能的结果，要么是是，要么是否），一个拥有秘密武器来从情况中区分二进制陈述的“证明者”必须说服一个怀疑的“验证者”，二进制陈述是正确的，同时不泄露秘密。2003年，魏兹曼科学研究所的教师成员奥ded·戈德雷赫提出了一种涉及色盲验证者的创新零知识证明。在这种情况下，验证者有两张卡片，一张红色的和一张绿色的。对于色盲验证者来说，除了红色卡片背面写着“红色”，绿色卡片背面写着“绿色”之外，这两张卡片看起来是一样的。让我们来展开这个场景，假设验证者对证明者能够不看背面文字就能区分卡片这一说法表示怀疑。为了进行这个实验，验证者会随机地每次向证明者展示每张卡片的正面。每次，验证者都会问证明者他看到了什么颜色。经过一段时间，验证者最终会确信证明者能够区分两张单独卡片的颜色。这主要是因为验证者在许多轮中进行了这个实验，并且验证者在每轮中随机交换了背后的卡片。
- en: 'The following are the three properties that a zero-knowledge proof must satisfy:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个零知识证明必须满足的三个属性：
- en: '*Completeness*: This is when the honest verifier is convinced that the honest
    prover returned the correct answer in the binary statement.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完备性*：当诚实的验证者被诚实的证明者说服，在二进制陈述中返回了正确的答案时。'
- en: '*Zero knowledge*: This is where the verifier has no knowledge of how the prover
    came up with the binary statement and learns nothing from the process other than
    that the binary statement provided by the prover is correct.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*零知识*：在这种情况下，验证者不知道证明者是如何得出二进制陈述的，并且从过程中除了验证者提供的二进制陈述是正确的外，没有学到任何东西。'
- en: '*Soundness*: This is where a prover (even a dishonest one who is just guessing
    the answer of the binary statement) is able to convince an honest verifier that
    the answer is correct.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全性*：这是一个证明者（即使是一个不诚实的，只是在猜测二进制陈述的答案）能够说服一个诚实的验证者，答案是正确的情况。'
- en: While the first two properties can be quite easily satisfied during one round
    of an interactive zero-knowledge proof exercise, there is statistically only a
    50 percent chance of achieving soundness. Put simply, a dishonest prover could
    just take a 50/50 guess to the binary situation and get it right 50 percent of
    the time.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前两个属性可以在交互式零知识证明的一次轮次中很容易满足，但统计上只有50%的机会达到健全性。简单来说，一个不诚实的证明者只需对二进制情况进行50/50猜测，有50%的时间会猜对。
- en: With this in mind, it is important to remember that zero-knowledge proofs are
    probabilistic. They are not deterministic. They rely on randomness to succeed.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这一点时，重要的是要记住零知识证明是概率性的。它们不是确定性的。它们依赖于随机性来成功。
- en: This information describes a specific type of zero-knowledge protocol known
    as *interactive*. In an interactive zero-knowledge protocol, the verifier and
    the prover must repeat each round until the verifier is convinced, without any
    reasonable doubt, that the prover knows the secret.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 本信息描述了一种特定的零知识协议，称为*交互式*。在交互式零知识协议中，验证者和证明者必须重复每一轮，直到验证者确信无合理怀疑地证明者知道秘密。
- en: A noninteractive zero-knowledge protocol is different because it requires only
    a single round. A noninteractive zero-knowledge proof, however, requires a “trusted
    setup.” One advantage of the noninteractive zero-knowledge protocol is that it
    allows many verifiers to all independently query the ability of the prover. Think
    of this as a one-to-many relationship between the prover and verifier entities,
    as opposed to the interactive zero-knowledge protocol’s one-to-one relationship.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非交互式零知识协议之所以不同，是因为它只需要一个回合。然而，非交互式零知识证明需要一个“可信设置”。非交互式零知识协议的一个优点是，它允许许多验证者独立地查询证明者的能力。可以把这看作是证明者和验证者实体之间一对一关系与交互式零知识协议之间一对多关系的区别。
- en: ZK-SNARKs
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ZK-SNARKs
- en: Zero-Knowledge Succinct Non-interactive ARguments of Knowledge (ZK-SNARKs) are
    able to be satisfied through computer code, and as such zero-knowledge proof implementations
    have tremendous potential in the online space. Just one example of ZK-SNARKs’
    potential is the creation of a decentralized, anonymous, sealed-bid auction. In
    this case, while the logic of determining the winner would execute successfully,
    the winner’s identity and the winning bid amount could both remain confidential.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识简洁非交互式知识证明（ZK-SNARKs）可以通过计算机代码来实现，因此零知识证明的实现在线空间中有巨大的潜力。ZK-SNARKs潜力的一个例子就是创建一个去中心化、匿名、密封报价拍卖。在这种情况下，虽然确定胜者的逻辑将成功执行，但胜者的身份和获胜出价金额都可以保持私密。
- en: You can think of ZK-SNARKs in the following way. ZK-SNARKs are for arbitrary
    computations, just as hashing algorithms are for arbitrary data. Put simply, you
    can turn an arbitrary computation into a ZK-SNARK, and since verifying arbitrary
    computations is at the core of the Ethereum blockchain, ZK-SNARKs are of course
    relevant to Ethereum. If implemented in Ethereum, ZK-SNARKs would not be limited
    to a single computational problem. Enabling ZK-SNARKs for Ethereum would, among
    other things, reduce the gas costs for certain pairing functions and elliptic
    curve operations. Overall, the biggest payoff for enabling ZK-SNARKs would be
    improved (guaranteed) performance of the EVM. Unfortunately, an implementation
    of this magnitude would be extremely difficult to complete and as such might take
    many years to move from proof of concept to early adoption. This may be something
    that will be implemented in the future of Ethereum. Let’s now compare ZK-STARKs.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样考虑ZK-SNARKs。ZK-SNARKs是为任意计算设计的，正如哈希算法是为任意数据设计的。简单来说，你可以把任意计算转换成ZK-SNARKs，由于验证任意计算是以太坊区块链的核心，所以ZK-SNARKs当然与以太坊有关。如果实现在以太坊上，ZK-SNARKs将不会局限于一个单一的计算问题。为以太坊启用ZK-SNARKs，
    among other things, 将减少某些配对函数和椭圆曲线操作的gas成本。总的来说，启用ZK-SNARKs最大的回报将是EVM的性能改进（保证）。不幸的是，这样的实现将非常困难，可能需要很多年才能从概念验证阶段过渡到早期采用阶段。这可能是以太坊未来会实现的东西。现在让我们比较一下ZK-STARKs。
- en: ZK-STARKs
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ZK-STARKs
- en: 'The confidentiality of a zero-knowledge proof is already being used to enhance
    privacy in cryptocurrencies. For example, Zcash already uses the ZK-SNARKs protocol.
    I just mentioned the possibility of an Ethereum implementation of ZK-SNARKs and
    the associated advantages. However, a shinier new cousin, Zero Knowledge Succinct
    Transparent ARguments of Knowledge (ZK-STARKs), looks to resolve one of the primary
    weaknesses of ZK-SNARKs: the reliance on a trusted setup. Interestingly, ZK-STARKs
    have also arrived with much simpler cryptographic assumptions. You may recall
    that ZK-SNARKs were promising advantages in relation to pairing functions and
    elliptical curve operations. Well, ZK-STARKs avoid the need for elliptic curves,
    pairings, and the knowledge-of-exponent assumption; instead, ZK-STARKs rely purely
    on hashes and information theory.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识证明的机密性已经用来增强加密货币的隐私。例如，Zcash已经使用了ZK-SNARKs协议。我刚刚提到了以太坊实现ZK-SNARKs的可能性和相关优势。然而，一个更闪亮的新表亲，零知识简洁透明知识证明（ZK-STARKs），有望解决ZK-SNARKs的主要弱点：依赖可信设置。有趣的是，ZK-STARKs也伴随着更简单的密码学假设到来。你可能还记得ZK-SNARKs在配对函数和椭圆曲线运算方面承诺优势。好吧，ZK-STARKs避免了椭圆曲线、配对和指数知识假设的需要；相反，ZK-STARKs完全依赖于哈希和信息论。
- en: This means that while ZK-STARKs bring about efficiency gains and more, they
    are also secure against attackers with quantum computers. Looking toward the future,
    ZK-STARKs could replace ZK-SNARKs, providing superior scalability and privacy,
    specifically to decentralized public ledgers like Ethereum. It is also important
    to note that these advantages all come at a cost. In other words, the size of
    a proof goes up from 288 bytes to a few hundred kilobytes. Further research is
    required in relation to shortening proof length or the aggregation and compression
    of several ZK-STARK proofs.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然ZK-STARKs带来了效率提升和其他优势，但它们也能抵御拥有量子计算机的攻击者。展望未来，ZK-STARKs可能会取代ZK-SNARKs，为去中心化公共账本如以太坊提供卓越的可扩展性和隐私性。需要注意的是，这些优势都伴随着成本。换句话说，证明的大小从288字节增加到几百千字节。还需要进一步研究关于缩短证明长度或者多个ZK-STARK证明的聚合和压缩。
- en: In the context of public blockchain applications, there is a high need for trust
    minimization, possibilities that elliptic curves could break, and a seemingly
    real possibility of quantum computers coming around. Given all of these points,
    implementing ZK-STARKs in decentralized public ledgers seems worth it, even if
    there are costs involved.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共区块链应用的背景下，减少信任的需求、椭圆曲线可能会被破解的可能性，以及量子计算机出现的似乎真实可能性非常高。考虑到所有这些因素，即使在有成本的情况下，在去中心化公共账本中实现ZK-STARKs似乎是值得的。
- en: Ethereum 2.0
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ethereum 2.0
- en: Ethereum 2.0 comprises many separate components. Casper PoS, sharding, and Ethereum-flavored
    WebAssembly (eWASM) have been on the minds of Ethereum developers for quite some
    time. For example, Vitalik Buterin has been writing about PoS implementation ideas
    since as far back as 2014\. This blend of technologies somehow resulted in Ethereum
    2.0 adopting the unfortunate name of Shasper, a combination of sharding and Casper
    PoW. Thankfully, most of the time nowadays you will see it referred to as either
    Serenity or simply Ethereum 2.0.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊2.0包括许多独立的组件。Casper PoS、分片以及以太坊特色的WebAssembly（eWASM）已经以太坊开发者脑海中很长时间了。例如，Vitalik
    Buterin自2014年以来一直在撰写关于PoS实现想法。这种技术的结合不知怎么就导致了以太坊2.0采用了不幸的名称Shasper，这是分片和Casper
    PoW的组合。幸运的是，现在大部分时间你看到的要么是Serenity或者简单地以太坊2.0。
- en: After years of research and development, these Ethereum 2.0 ideas are making
    their way into the code repositories of many Ethereum developers throughout the
    community. For example, there are many individual implementations of the Ethereum
    2.0 specification, such as a Rust implementation of the Ethereum 2.0 beacon chain
    and a Java implementation of the Ethereum 2.0 beacon chain. The official Ethereum
    reference implementation, which these other repositories are modeling, is a Python
    implementation of the Ethereum 2.0 beacon chain.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的研究和开发，这些以太坊2.0的想法正在进入以太坊社区许多开发者的代码仓库。例如，有许多个人实现以太坊2.0规范的版本，比如用Rust实现的以太坊2.0信标链和用Java实现的以太坊2.0信标链。官方以太坊参考实现，这些其他仓库都在模仿的是用Python实现的以太坊2.0信标链。
- en: The Ethereum 2.0 specification documents indicate that Ethereum 2.0 can initially
    be implemented without any consensus changes to Ethereum 1.0\. This means that
    at this early stage, the Ethereum 1.0 base layer will not undergo a fork or chain
    split while moving these exciting ideas forward into production. As I will discuss
    shortly, a contract (the gateway to the Ethereum 2.0) will be added to Ethereum
    1.0, and deposits into this contract will allow users to become validators on
    the Ethereum 2.0 beacon chain.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊2.0规范文档表明，以太坊2.0最初可以不对以太坊1.0做任何共识更改就实现。这意味着在这个早期阶段，以太坊1.0基础层在将这些激动人心的想法推进到生产过程中，不会发生分叉或链分裂。正如我即将讨论的，一个合约（通往以太坊2.0的网关）将被添加到以太坊1.0中，向这个合约存款将允许用户成为以太坊2.0信标链上的验证人。
- en: The Beacon Chain
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 信标链
- en: One of the core components, mentioned in the Ethereum 2.0 specifications, is
    the beacon chain. The *beacon chain* is the central PoS chain that underpins the
    sharding system. The beacon chain stores and maintains a registry of validators.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊2.0规范中提到的核心组件之一是信标链。*信标链*是支持分片系统的中心PoS链。信标链存储和维护验证人的注册表。
- en: Validators
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证人
- en: The beacon chain invites new validators to join Ethereum 2.0\. As previously
    mentioned, validators join the beacon chain by simply depositing ether into the
    appropriate Ethereum 1.0 contract. An actively participating validator is able
    to propose blocks on the beacon chain. A validator who creates an Ethereum 2.0
    beacon chain block is also known as a *proposer*. In addition to proposing blocks,
    validators are also able to sign off on beacon chain blocks. However, to do so,
    the validator has to be part of a committee. Validators cannot self-select to
    be part of a committee. Instead, committees of independent validators are assembled
    in a random fashion. Randomness is generated by the beacon chain itself. A validator
    can exit the beacon chain voluntarily or be forced to exit in the event that the
    validator attacks the chain.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 信标链邀请新的验证人加入以太坊2.0。如前所述，验证人通过简单地向适当的以太坊1.0合约存入以太币加入信标链。一个积极参与的验证人能够在信标链上提出区块。创建以太坊2.0信标链区块的验证人也被称为*提议者*。除了提出区块外，验证人还能够在信标链区块上签字。然而，要这样做，验证人必须是委员会的一部分。验证人不能自行选择成为委员会的一部分。相反，独立的验证人委员会是以随机方式组装的。随机性是由信标链本身生成的。验证人可以自愿退出信标链，或者在验证人攻击链的情况下被迫退出。
- en: Shard Chain
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分片链
- en: There are many shard chains. Shard chains are where end-user transactions take
    place and where transaction information is stored. When signing off (attesting
    to) a block, the committee of validators create what is known as a *crosslink*.
    A crosslink is essentially a set of validator signatures, attesting to a block
    in a shard chain that is then confirmed into the beacon chain. A crosslink allows
    updates in a shard chain to be communicated with the beacon chain; in other words,
    crosslinks are used to determine the finality of shards.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多分片链。分片链是终端用户交易发生的地方，也是交易信息存储的地方。在签署（证明）一个区块时，验证人委员会创建所谓的*交叉链接*。交叉链接本质上是一组验证人的签名，证明一个分片链中的区块然后被确认到信标链中。交叉链接允许分片链的更新与信标链进行沟通；换句话说，交叉链接用于确定分片的最终性。
- en: '**Note**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A very interesting implication of sharding is that today’s Ethereum-compatible
    blockchains such as Ethereum Classic and CyberMiles can now interoperate within
    the new Ethereum 2.0 ecosystem. For example, Ethereum Classic and its established
    miner community will stay as a PoW chain within the ecosystem. Its native cryptocurrency,
    the ETC, will become the PoW store-of-value coin in the ecosystem.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 分片的一个非常有趣的含义是，今天的与以太坊兼容的区块链，如以太坊经典和CyberMiles，现在可以在新的以太坊2.0生态系统内进行互操作。例如，以太坊经典及其建立的矿工社区将在生态系统内保持为一个PoW链。其原生加密货币ETC将成为生态系统中的PoW价值储存币。
- en: One of the design goals of Ethereum 2.0 is to allow for a typical consumer laptop
    to process (validate) shards, including any system-level validation such as the
    beacon chain. This is made possible because the sharding architecture now uses
    its own PoS chain as opposed to the original idea, mentioned earlier, where the
    old sharding architecture used to consist of a single smart contract on the PoW
    chain.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊2.0的设计目标之一是允许典型的消费者笔记本电脑处理（验证）分片，包括任何系统级别的验证，如信标链。这之所以可能，是因为分片架构现在使用自己的PoS链，而不是之前提到的原始想法，即旧的分片架构曾经由PoW链上的一个智能合约组成。
- en: You may have already realized by now that Ethereum 2.0/Serenity is a new blockchain,
    albeit it’s one that links to the existing Ethereum 1.0 PoW chain (i.e., the new
    PoS chain is aware of the block hashes of the PoW chain, and so forth). The goal
    for this architecture will allow ether to be moved between the original PoW chain
    and the PoS chain. In addition, the long-term vision would be to allow applications
    from the current blockchain to be redeployed on a shard of the Ethereum 2.0 system.
    This would be implemented via a new EVM interpreter written in eWASM.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，以太坊 2.0/Serenity 是一个新的区块链，尽管它是一个链接到现有以太坊 1.0 PoW 链（即新的 PoS 链知道 PoW
    链的区块哈希，等等）的新区块链。这种架构的目标将允许以太币在原始 PoW 链和 PoS 链之间移动。此外，长期愿景将是允许将当前区块链上的应用程序重新部署到以太坊
    2.0 系统的分片上。这将通过编写为 eWASM 的新的 EVM 解释器来实现。
- en: eWASM
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: eWASM
- en: Currently there are separate compilers for each of the smart contract programming
    languages. You can build and install either the Solidity or Vyper compiler software
    and run it on local disk. Alternatively, you can use the free online code editors
    for both Solidity and Vyper.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有分别为每种智能合约编程语言的编译器。你可以构建并安装 Solidity 或 Vyper 编译器软件并在本地磁盘上运行它。或者，你可以使用免费的在线代码编辑器来编写
    Solidity 和 Vyper。
- en: The job of a compiler is to convert your high-level smart contract code into
    bytecode and application binary interface (ABI). Once your code is compiled, it
    can be executed by the EVM.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的任务是将你的高级智能合约代码转换成字节码和应用程序二进制接口（ABI）。一旦你的代码被编译，它就可以由 EVM 执行。
- en: eWASM is Ethereum’s own implementation of WebAssembly. WebAssembly is currently
    being designed as an open standard by a W3C Community Group.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: eWASM 是以太坊自己的 WebAssembly 实现。WebAssembly 目前正在由一个 W3C 社区小组作为一个开放标准进行设计。
- en: eWASM is being developed to replace the EVM. Once eWASM is implemented, developers
    will be able to write smart contracts in other languages such as Rust and C/C++
    as opposed to just Solidity and Vyper. It is important to note that eWASM will
    be completely backward compatible with the current EVM. This means smart contracts
    that are currently written in Solidity or Vyper will still be able to execute
    in the new environment.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: eWASM 正在开发中以取代 EVM。一旦 eWASM 得到实施，开发者将能够用其他语言（如 Rust 和 C/C++）编写智能合约，而不仅仅是 Solidity
    和 Vyper。重要的是要注意，eWASM 将与当前 EVM 完全向后兼容。这意味着目前用 Solidity 或 Vyper 编写的智能合约仍然能够在新的环境中执行。
- en: Delivery Phases of Ethereum 2.0
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ethereum 2.0 的交付阶段
- en: The delivery phases of Ethereum 2.0 should run something like the following.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 2.0 的交付阶段应该像以下这样运行。
- en: Phase 0
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阶段 0
- en: Ethereum 2.0 is expected to be implemented as follows. Phase 0, which I have
    briefly covered, involves the introduction of the beacon chain, so essentially
    Phase 0 is the beginning of the new PoS chain. More specifically, it’s a PoS beacon
    chain without shards.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊 2.0 预计将按照如下方式实施。我已经简要介绍过的阶段 0 涉及引入信标链，所以本质上阶段 0 是新 PoS 链的开始。更具体地说，它是一个没有分片的
    PoS 信标链。
- en: Phase 1
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阶段 1
- en: The next phase, Phase 1, will implement shards as data chains. Phase 1 will
    provide the foundations to create decentralized data applications; however, to
    fully implement any of these types of applications, the benefits of Phase 2 will
    be required. Put simply, Phase 1 is implementing basic sharding without an EVM.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段，阶段 1，将实现作为数据链的分片。阶段 1 将提供创建去中心化数据应用程序的基础；然而，为了完全实现这些类型的应用程序，将需要阶段 2 的好处。简单地说，阶段
    1 正在实施没有 EVM 的基本分片。
- en: Phase 2
  id: totrans-597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阶段 2
- en: EVM state transition functionality will be introduced in Phase 2\. Phase 2 will
    introduce functionality to create and manage accounts and contracts as well as
    transfer funds between shards and so forth.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段 2 将引入 EVM 状态转换功能。阶段 2 将引入创建和管理账户及合约的功能，以及在不同分片之间转移资金等功能。
- en: 'The subsequent phases 3, 4, 5, and 6 have plans to introduce the following:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的阶段 3、4、5 和 6 计划引入以下内容：
- en: A light-client state protocol
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻客户端状态协议
- en: Cross-shard transactions
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨分片交易
- en: Tight coupling with main chain security
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主链安全紧密耦合
- en: Super-quadratic or exponential sharding
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超平方或指数分片
- en: It is hoped that state transition changes and transaction executions will improve
    significantly because of the implementation of eWASM. There is a comprehensive
    Ethereum 2.0 road map that details each proposed phase. Please keep in mind that
    these specifications do change frequently and that the proof-of-concept algorithms
    and code repositories are under heavy construction.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 希望由于eWASM的实施，状态转换变化和交易执行将得到显著改善。有一个全面的以太坊2.0路线图，详细说明了每个提议的阶段。请记住，这些规范经常会发生变化，而且原型算法和代码仓库都处于紧张的建设中。
- en: Post–Ethereum 2.0 Innovation
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊2.0之后的创新
- en: I mentioned ZK-STARKs previously in this chapter. The main difference between
    SNARKs and STARKs is transparency. More specifically, there is no “trusted setup”
    in ZK-STARKs (no secrets in the setup of the system). This is an interesting area
    of research, and there is a chance that Ethereum will eventually upgrade to the
    use of STARKs to perform tasks such as data availability checks, state execution
    correctness checks, and improved base-layer cross-shard transactions, to name
    a few.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我之前提到了ZK-STARKs。SNARKs和STARKs之间的主要区别是透明度。更具体地说，ZK-STARKs中没有“可信设置”（系统设置中没有秘密）。这是一个有趣的研究领域，有可能会有一天以太坊升级至使用STARKs来执行诸如数据可用性检查、状态执行正确性检查以及改进的基础层跨分片交易等任务。
- en: Conclusion
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed the future direction of the Ethereum blockchain.
    Ethereum is not only a decentralized blockchain but also a decentralized developer
    community. It has a robust and democratic upgrade process known as the EIP. We
    are optimistic that Ethereum will remain one of the most widely used and technically
    advanced blockchains in the future.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了以太坊区块链的未来方向。以太坊不仅仅是一个去中心化的区块链，还是一个去中心化的开发者社区。它有一个强大且民主的升级过程，称为EIP。我们乐观地认为，以太坊将仍然是未来最广泛使用和技术最先进的区块链之一。
