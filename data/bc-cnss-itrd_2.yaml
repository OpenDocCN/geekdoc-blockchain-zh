- en: is not sufficient, and we need to use some mechanism that can send messages
    to
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 不足够，我们需要使用一些能够发送消息给
- en: multiple nodes or a group of nodes simultaneously. In such situations, we use
    broadcast
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多个节点或一组节点同时。在这种情况下，我们使用广播
- en: protocols.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。
- en: '113'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '113'
- en: © Imran Bashir 2022
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: © 伊姆兰·巴希尔 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_3](https://doi.org/10.1007/978-1-4842-8179-6_3#DOI)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 伊姆兰·巴希尔, *区块链共识*，[https://doi.org/10.1007/978-1-4842-8179-6_3](https://doi.org/10.1007/978-1-4842-8179-6_3#DOI)
- en: '![](index-133_1.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](index-133_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式一致性
- en: Broadcast protocols allow a process to send a message simultaneously to all
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 广播协议允许进程同时向所有进程发送消息
- en: processes in a distributed system, including itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的进程，包括它自己。
- en: In this section, we will look at broadcast abstractions. There can be multiple
    senders
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将看一下广播抽象。可能会有多个发送者
- en: and receivers involved. Broadcast abstractions ensure that the processes agree
    on the
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 和接收者参与。广播抽象确保进程就
- en: messages that they deliver.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 他们传递的消息。
- en: Broadcast abstractions can be explained with a visualization in Figur[e 3-1\.](#p133)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过图 3-1\.](#p133)的可视化来解释广播抽象
- en: '***Figure 3-1\.** A node broadcasting a message m and all three nodes delivering
    it*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-1\.** 一个节点广播消息 m 和三个节点都接收它*'
- en: Note that there is a difference between sending and receiving and broadcasting
    and
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，发送和接收以及广播和之间存在区别
- en: delivering. Sending and receiving are used in the context of point-to-point
    links, and
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 传递。发送和接收是在点对点链路的上下文中使用的，而
- en: broadcast and delivery are used in broadcast abstractions where a message is
    broadcast
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 广播和传递在广播抽象中使用，其中消息被广播
- en: to multiple/all nodes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 给多个/所有节点。
- en: Point-to-point links discussed in Chapt[er 1](https://doi.org/10.1007/978-1-4842-8179-6_1)
    are associated with send and receive primitives where a node sends a message,
    and the recipient node receives them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章讨论的点对点链路与发送和接收原语相关，其中一个节点发送消息，接收节点接收它
- en: Broadcast abstractions with broadcast and deliver primitives depict a situation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用广播和传递原语的广播抽象描述了一种情况
- en: where a node sends a message to multiple/all nodes in the network and nodes
    receive
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点向网络中的多个/所有节点发送消息，节点接收
- en: them, but, here, the broadcast algorithm can store and buffer the message after
    receiving it and deliver it to the process later. It depends on the broadcast
    algorithm (also called middleware). For example, in total order broadcast, the
    message may be received by
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它们，但是，在这里，广播算法可以在接收后存储和缓冲消息，然后将消息传递给后续进程。这取决于广播算法（也称为中间件）。例如，在总体顺序广播中，消息可能被接收
- en: broadcast algorithms running on each process but can be buffered until the conditions
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个进程上运行广播算法，但可以在满足条件的情况下被缓冲
- en: meet to deliver the message to the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 见面来将消息传递给应用程序。
- en: The diagram in Figur[e 3-2 sho](#p134)ws this concept visually.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2 阐](#p134)明了这个概念。
- en: '114'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '114'
- en: '![](index-134_1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](index-134_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式一致性
- en: '***Figure 3-2\.** Send and receive and broadcast and delivery*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-2\.** 发送和接收以及广播和传递*'
- en: The communication occurs within a group of nodes where the number of nodes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通信发生在一个节点组内，其中节点数量
- en: might be static or dynamic. One process sends it, and all nodes in the group
    agree on
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是静态的或动态的。 一个进程发送它，组中的所有节点都同意
- en: it and deliver it. If a single processor or some processors become faulty, the
    remaining
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其传递。如果单个处理器或部分处理器出现故障，其余
- en: nodes carry on working. Broadcast messages are targeted to all processes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 节点继续工作。广播消息面向所有进程。
- en: Broadcast abstractions allow for the development of fault-tolerant applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 广播抽象允许开发容错应用程序。
- en: There are several types which I describe as follows.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我描述的几种类型。
- en: '**Best-Effort Broadcast**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽力而为广播**'
- en: In this abstraction, reliability is guaranteed only if the sender process does
    not fail. This is the weakest form of reliable broadcast. There are three properties
    that best-effort
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个抽象中，只有在发送方进程不失败的情况下才能保证可靠性。这是最弱的可靠广播形式。最好的尽力而为有三个属性
- en: broadcast has.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 广播有。
- en: '**Validity**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效性**'
- en: If a message m is broadcast by a correct process p, then message m is eventually
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息 m 由正确的进程 p 广播，则消息 m 最终
- en: delivered by every correct process. This is a liveness property.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个正确处理过程都传递。这是一种活力性质。
- en: '**No Duplication**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**无重复**'
- en: Every message is delivered only once.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息只传递一次。
- en: '115'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '115'
- en: '![](index-135_1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](index-135_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '**No Creation**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有创建**'
- en: If a process delivers a message m with a sender process p, then m was previously
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程传递了一个来自发送者进程 p 的消息 m，则 m 之前已经
- en: broadcast by sender process p. In other words, messages are not created out
    of thin air.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 发送进程 p 的广播。换句话说，消息不会凭空产生。
- en: Figur[e 3-3 depicts an ex](#p135)ecution of best-effort broadcast.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图[ 3-3 描述了一个示](#p135)例最佳努力广播的执行。
- en: '***Figure 3-3\.** Best-effort broadcast – an example scenario*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-3\.** 尽力广播–一个示例场景*'
- en: In Figur[e 3-3, notice th](#p135)at process p has broadcast the message but
    then crashed, and as per system properties, message delivery is not guaranteed
    in this case. Notice
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[ 3-3 中，注意](#p135)到进程 p 已经广播了消息，但然后崩溃了，根据系统属性，此时消息传递不被保证。请注意
- en: that process q did not deliver the message because our process p is no longer
    correct.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 q 未能传递消息，因为我们的过程 p 不再正确。
- en: However, process R delivered it. There is no delivery guarantee in this abstraction
    if the sender fails, as shown in Figure [3-3](#p135). In case some processes may
    deliver the messages, and some don’t, it results in disagreement. As you can imagine,
    this abstraction may not
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，进程 R 传递了。如果发送者失败，该抽象中没有传递保证，如 [图 3-3](#p135) 所示。如果一些进程可能传递消息，而一些不传递，就会导致不一致。可以想象，该抽象可能不会
- en: be quite useful in some stricter scenarios. We need some more robust protocol
    than this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些更严格的情况下可能会很有用。我们需要比这更健壮的协议。
- en: To address such limitations, a reliable broadcast abstraction is used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些限制，使用了可靠的广播抽象。
- en: '**Reliable Broadcast**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠的广播**'
- en: A reliable broadcast abstraction introduces an additional liveness property
    called
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的广播抽象引入了一个名为
- en: agreement. **No duplication** and **no creation** properties remain the same
    as the best-effort broadcast abstraction. The **validity** property is slightly
    weakened. Formally, validity and agreement properties can be stated as follows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 协议达成。 **没有复制** 和 **没有创建** 的属性与尽力广播抽象保持一致。 **有效性** 属性略有削弱。形式上，有效性和协议达成属性可以如下表述。
- en: '**Validity**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效性**'
- en: If a message m is broadcast by a correct process p, then p itself eventually
    delivers m.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确的进程 p 广播了一个消息 m，那么 p 最终会传递 m。
- en: '116'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '116'
- en: Chapter 3 DistributeD Consensus
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '**Agreement**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议达成**'
- en: If a message m is delivered by a correct process, then every correct process
    delivers m.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个消息 m 被正确的进程传递，那么每个正确的进程都传递 m。
- en: '**Remarks**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: In case the sender process crashes while broadcasting and has not been able
    to send to
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送进程在广播时崩溃并且无法发送到
- en: all processes, the agreement property ensures that no process delivers it. It
    is possible that some processes may have received the message, but reliable broadcast
    ensures that
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有进程，协议达成属性确保没有一个进程传递它。可能某些进程已经收到了消息，但是可靠的广播确保
- en: no process will deliver it unless there’s an agreement on the delivery. In other
    words, if the sender process crashes, the reliable broadcast ensures that either
    all correct nodes
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行协议达成，没有一个进程会传递它。换句话说，如果发送进程崩溃，可靠的广播确保所有正确的节点要么
- en: eventually deliver the message or no nodes deliver the message at all.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终传递消息或都不传递消息。
- en: If the sender process fails, this property ensures that all correct nodes get
    the
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送进程失败，此属性确保所有正确的节点都会收到
- en: message or none of the correct nodes receives the message. This property is
    achieved
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 消息，或者没有一个正确的节点收到消息。这个属性通过
- en: by correct processes retransmitting any dropped messages, which result in the
    eventual
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确的进程重新传输任何丢失的消息，从而最终
- en: delivery of the message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 传递消息。
- en: This solution seems reasonable enough, but there might be situations in which
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案似乎足够合理，但在某些情况下可能存在
- en: the broadcaster process may have been able to deliver to itself but then crashed
    before
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 广播进程可能已经能够将消息传递给自身，但是在
- en: it could send to other processes. This means that all correct processes will
    agree not
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会发送给其他进程。这意味着所有正确的进程将同意不会
- en: to deliver the message because they have not received it, but the original broadcaster
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以便传递消息，因为它们没有收到消息，但是原始的广播者
- en: delivers it. Such situations can cause safety issues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传递它。这种情况可能会导致安全问题。
- en: To address this limitation, uniform reliable broadcast, which provides a stronger
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个限制，引入了统一可靠的广播，提供了更强大的
- en: guarantee, is used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 保证，被使用。
- en: '**Uniform Reliable Broadcast**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致可靠广播**'
- en: In uniform reliable broadcast, while all other properties such as validity,
    no duplication, and no creation remain the same as best-effort broadcast, there’s
    a stronger notion of the agreement property that we saw in the reliable broadcast
    abstraction. It is introduced to ensure that agreement is achieved even in the
    scenarios where the sender process might
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在统一可靠广播中，虽然所有其他属性（如有效性，无重复，无创建）与尽力广播保持一致，但在我们在可靠广播抽象中看到的一致性属性下，引入了一个更强的一致性概念。它被引入是为了确保即使在发送进程可能会失败的情景中，也能确保一致性。这被称为一致性协议。
- en: fail. This property is called the uniform agreement property.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 失败。该属性称为统一协议属性。
- en: '**Uniform Agreement**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致协议**'
- en: If a message m is delivered by a process p, every correct process eventually
    delivers m. p can be either a correct or a failed process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个消息m由一个进程p传递，那么每个正确的进程最终都会传递m。 p可以是一个正确的或一个失败的进程。
- en: '117'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '117'
- en: Chapter 3 DistributeD Consensus
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: In all the preceding discussed abstractions, there’s a crucial element missing
    which
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论的所有抽象中，有一个关键的元素缺失
- en: is required in many distributed services. For example, imagine a scenario of
    an online
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多分布式服务中需要。例如，想象一个在线
- en: chat app. If a user sends a message saying “England has won the cricket match,”
    and
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序。如果用户发送了一条消息说“英格兰赢得了板球比赛”，而
- en: another user replies “congratulations,” and a third user says “But I wanted
    Ireland to
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用户回复“祝贺”，第三个用户说“但我想让爱尔兰获胜”
- en: win,” the expected sequence in which the messages are supposed to appear in
    the
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 赢得，消息应出现的期望序列
- en: chat app is
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序是
- en: '• **User 1**: England has won the cricket match'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户1**：英格兰赢得了板球比赛
- en: '• **User 2**: congratulations'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户2**：祝贺
- en: '• **User 3**: But I wanted Ireland to win'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户3**：但我想让爱尔兰赢
- en: However, if there is no order imposed on the message delivery, it might appear
    that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果消息传递没有设置顺序，它可能会出现
- en: 'even if User 1’s message was sent first, it may turn out that in the app (to
    the end user) the messages might appear like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户1的信息先发送，但在应用程序（对终端用户）中，消息可能会出现这样：
- en: '• **User 2**: congratulations'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户2**：祝贺
- en: '• **User 3**: But I wanted Ireland to win'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户3**：但我想让爱尔兰赢
- en: '• **User 1**: England has won the cricket match'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • **用户1**：英格兰赢得了板球比赛
- en: Now this is not the expected order; the “congratulations” message without the
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这不是期望的顺序；没带有“祝贺”的信息
- en: context of winning the match would appear confusing. This is the problem that
    is solved
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用于赢球录像会令人困惑。这是在分布式一致性中解决的问题。
- en: by imposing an order guarantee on the broadcast abstractions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对广播抽象施加顺序保证。
- en: '**Note** We discussed causality and happens-before relationships in Cha[pter
    1; if](https://doi.org/10.1007/978-1-4842-8179-6_1)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 我们在第1章讨论了因果关系和发生前关系；如果需要，可以查看该章节。'
- en: you need a refresher, refer to that chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要提醒，可以参考该章节。
- en: Now we will discuss four abstractions that deliver messages with an order guarantee
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论四种保证按顺序传送消息的抽象
- en: 'with varying degrees of strictness: FIFO reliable broadcast, causal reliable
    broadcast,'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同程度的严格性：FIFO可靠广播，因果可靠广播，
- en: total order reliable broadcast, and FIFO total order broadcast.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 全顺序可靠广播和FIFO全顺序广播。
- en: '**FIFO Reliable Broadcast**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIFO可靠广播**'
- en: This abstraction imposes a first-in, first-out (FIFO) delivery order on reliable
    broadcast.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象在可靠广播上强加了先进先出（FIFO）传递顺序。
- en: This means that messages broadcast are delivered in the same that they were
    sent by the
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着广播的消息以发送时的相同方式传送
- en: sender process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 发送进程。
- en: '118'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '118'
- en: Chapter 3 DistributeD Consensus
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: In this abstraction, all properties remain the same as reliable broadcast; however,
    a
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个抽象中，所有属性与可靠广播保持一致；然而
- en: new property for FIFO delivery is introduced.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为FIFO传递引入了一个新属性。
- en: '**FIFO Delivery**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIFO传递**'
- en: If a process has broadcast two messages m1 and m2, respectively, then any correct
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程已经分别广播了两条消息m1和m2，那么任何正确的
- en: process does not deliver m2 before m1\. In other words, if m1 is broadcast before
    m2 by
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 进程在m1之前没有传递m2。换句话说，如果m1是由
- en: the same process, then no correct process delivers m2 unless it has delivered
    m1 first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的过程，那么除非它先传递了m1，否则没有正确的过程会传递m2。
- en: This guarantee is however only in the case when m1 and m2 are broadcast by the
    same
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保证只有在m1和m2由同一个广播的进程传递
- en: process; if two different processes have broadcast messages, then there is no
    guarantee
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 进程；如果两个不同的进程广播了消息，那么就没有保证
- en: in which order they will be delivered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将被传递。
- en: In practice, TCP is an example of FIFO delivery. If you need FIFO delivery in
    your use
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，TCP是FIFO传递的一个例子。如果你需要在你的使用中使用FIFO传递
- en: case, you can simply use TCP.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以简单地使用TCP。
- en: '**Causal Reliable Broadcast**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**因果可靠广播**'
- en: This abstraction imposes a causal delivery order on reliable broadcast. This
    means that if a message broadcast happens before broadcast of another message,
    then every process
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象对可靠广播施加了因果传递顺序。这意味着，如果一个消息广播比另一个消息的广播早发生，那么每个进程
- en: delivers these two messages in the same order. In scenarios where two messages
    might
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 传递这两个消息的顺序相同。在可能发生两个消息的情况下
- en: have been broadcast concurrently, then a process can deliver them in any order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时广播，那么一个进程可以以任意顺序传递它们。
- en: '**Total Order Reliable Broadcast or Atomic**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**总序可靠广播或原子**'
- en: '**Reliable Broadcast**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠广播**'
- en: This abstraction is usually just called **total order broadcast** or **atomic
    broadcast**. There are four properties that total order broadcast has, which are
    described as follows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象通常被称为**总序广播**或**原子广播**。总序广播具有四个属性，如下所述。
- en: '**Validity**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效性**'
- en: If a correct process p broadcasts a message m, then some correct process eventually
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个正确的进程p广播了一个消息m，那么一些正确的进程最终
- en: delivers m.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 传递m。
- en: '**Agreement**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**'
- en: If a message m is delivered by a correct process p, then all correct processes
    eventually deliver m.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个消息m被正确的进程p传递，则所有正确的进程最终都会传递m。
- en: '119'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '119'
- en: Chapter 3 DistributeD Consensus
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: '**Integrity**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性**'
- en: For any message m, each process delivers m at most once and only if m was previously
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何消息m，每个进程最多传递一次，只有当m先前是
- en: 'broadcast. In literature, this property is sometimes divided into two separate
    properties: **no duplication** where no message is delivered more than once and
    **no creation** which states that a delivered message must be broadcast by the
    sender process. In other words,'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 广播。在文献中，这种性质有时被分为两个独立的性质：**无重复**，即没有消息被传递超过一次， **无创建**，它规定传递的消息必须由发送者进程广播。换句话说，
- en: no messages are created out of thin air.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有消息是凭空创建的。
- en: '**Total Order**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**总序**'
- en: In this property, if a message m1 is delivered before m2 in a process, then
    m1 is delivered before m2 in all processes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个属性中，如果消息m1在一个进程中在消息m2之前被传递，那么在所有进程中消息m1在消息m2之前被传递。
- en: '**FIFO Total Order Broadcast**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIFO总序广播**'
- en: This abstraction combines both FIFO broadcast and total order broadcast.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象结合了FIFO广播和总序广播。
- en: The total order can be achieved using a single leader known as the sequencer
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个称为顺序器的单个领导者实现总序。
- en: approach and using Lamport clocks, but none of these are fault-tolerant approaches.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和使用Lamport时钟，但这些都不是容错方法。
- en: What if the leader goes down then there is no sequencing and in case of Lamport
    clocks
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果领导者崩溃了，那么就没有序列了，在Lamport时钟的情况下
- en: if any of the nodes fail then the total order cannot be guaranteed? Introducing
    fault
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何节点故障，则无法保证完全顺序？引入故障
- en: tolerance in total order broadcast to automatically choose a new leader is the
    problem
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 容错性在自动选择新领导者的总序广播中的问题就是
- en: that is studied and addressed using consensus protocols. A consensus protocol,
    at a
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一致性协议进行研究和解决的。一致性协议，在a
- en: fundamental level, addresses the problem of choosing a new leader in case of
    failure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 基本层面上，解决在故障发生时选择新领导者的问题。
- en: This is the key motivation behind consensus protocols. We will see more about
    this and
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一致性协议背后的关键动机。我们将更多地了解这一点，
- en: details on total order broadcast and its relationship with state machine replication,
    fault tolerance, and consensus protocols later in this chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以后在本章中将详细说明总序广播及其与状态机复制、容错性和共识协议的关系。
- en: So far, the abstractions that we have discussed can work with a smaller set
    of
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论过的抽象可以与更小的一组一起工作
- en: processes. Imagine a distributed system is spread across multiple continents
    and
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。想象一个分布式系统分布在多个大陆上并且
- en: there are 1000s of nodes participating in it. Can the abstractions presented
    so far be
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有1000多个节点参与。迄今为止，所述的抽象是否可以
- en: efficient enough to withstand the communication complexity that arises with
    1000s of
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 足够高效以承受与1000多个相关的通信复杂性
- en: heterogenous and dispersed nodes in a distributed system? The answer is no,
    and in
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中异构和分散节点？答案是否定的，并且在
- en: order to address such requirements, probabilistic protocols are developed. Also,
    imagine
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这种要求，发展了概率协议。另外，想象一下
- en: a scenario where a single node is responsible for sending messages to 1000 nodes.
    Even
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点 responsible for sending messages to 1000个节点的情景。即使
- en: if we manage to send a message to 1000 nodes with some hardware support or some
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设法利用一些硬件支持或一些
- en: other method, the problem becomes complex to handle when that single sender
    node
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，当单个发送方节点
- en: receives the acknowledgements from 1000 nodes. This problem is called **ack
    implosion**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 收到来自1000个节点的确认。这个问题被称为**确认膨胀**。
- en: The question is how we can avoid such issues.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们如何避免这样的问题。
- en: '120'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '120'
- en: '![](index-140_1.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](index-140_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: Imagine another situation where using reliable links a node has sent a message
    to all
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想象另一种情况，使用可靠的链接一个节点已经向所有节点发送了消息
- en: nodes individually, but while in transit to some nodes, some messages were dropped.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 个别节点，但在传输到一些节点时，一些消息被丢弃。
- en: At this point, the sender process fails and consequently no retransmission occurred.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，发送过程失败，因此没有进行重新传输。
- en: As a result, those nodes that did not receive messages will now never receive
    messages
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，那些未收到消息的节点现在永远不会收到消息
- en: because the sender process has crashed. How can we improve reliability in this
    scenario?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为发送方进程已经崩溃。在这种情况下，我们如何提高可靠性？
- en: We can devise a scheme where if one node receives a message for the first time,
    it
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一种方案，如果一个节点首次接收到消息，则它
- en: broadcasts it again to other nodes through reliable channels. This way, all
    correct nodes will receive all the messages, even if some nodes crash. This is
    called **eager reliable** **broadcast**. Eager reliable broadcast is reliable;
    however, it can incur *O*( *n*) steps and *O*( *n*)2 messages for n number of
    nodes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可靠渠道再次将其广播到其他节点。这样，即使一些节点崩溃，所有正确的节点也将收到所有消息。这被称为**急切可靠** **广播**。急切可靠广播是可靠的；然而，对于n个节点，可能会产生
    *O*(*n*)步和 *O*(*n*)2条消息。
- en: Figur[e 3-4 vis](#p140)ualizes the eager reliable protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3-4展示](#p140)了急切可靠协议。
- en: '***Figure 3-4\.** Eager reliable broadcast*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-4\.** 急切可靠广播*'
- en: There are also other algorithms which we can call *nature-inspired* algorithms.
    For example, consider how an infectious disease might spread or a rumor might
    spread. One
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也有其他算法，我们可以称之为*受自然启发*的算法。例如，考虑传染病如何传播或者谣言如何传播。一
- en: person infects a few others, and then those others infect others, and quickly
    the infection rate increases. Now imagine if a broadcast protocol is designed
    on such principle, then
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 人传染了一些其他人，然后那些人传染了其他人，并且迅速传染率增加。现在想象一下，如果一个广播协议是根据这样的原则设计的，那么
- en: it can be very effective at disseminating information (messages) throughout
    the network
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以非常有效地在整个网络中传播信息（消息）
- en: quickly. As these protocols are basically randomized protocols, they do not
    guarantee
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 很快。由于这些协议基本上是随机化的协议，它们不能保证
- en: that all nodes will receive a message, but there is usually a very high probability
    that
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都会收到一条消息，但通常有很高的概率
- en: all nodes eventually get all messages. Probabilistic protocols or gossip protocols
    are
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点最终都会收到所有消息。概率协议或八卦协议是
- en: commonly used in peer-to-peer networks. There are many protocols that have been
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等网络中通常使用。已经有许多协议
- en: designed based on this type of dissemination.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种传播的设计。
- en: Figur[e 3-5 illus](#p141)trates how a gossip protocol works. The idea here is
    that when a node receives a message for the first time, it forwards it to some
    randomly chosen other nodes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3-5展示](#p141)了八卦协议的工作原理。这里的想法是，当一个节点首次接收到消息时，它会将其转发给一些随机选择的其他节点。
- en: This technique is useful for broadcasting messages to many nodes, and the message
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对向许多节点广播消息很有用，消息
- en: eventually reaches all nodes with high probability.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最终以很高的概率到达所有节点。
- en: '121'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '121'
- en: '![](index-141_1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](index-141_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: '***Figure 3-5\.** Gossip protocol*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-5\.** 八卦协议*'
- en: A probabilistic broadcast abstraction can be defined as an abstraction which
    has two
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个概率广播抽象作为具有两个抽象之一
- en: properties.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 属性。
- en: '**Probabilistic Validity**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**概率有效性**'
- en: If a correct process p broadcasts a message m, then every correct process eventually
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确的进程p广播了消息m，那么每个正确的进程最终
- en: delivers it with probability 1\.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以1的概率交付。
- en: '**Integrity**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**诚信**'
- en: Any message is delivered at most once, and the message delivered has been previously
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消息最多被传递一次，并且传递的消息之前已经被送达
- en: broadcast by a process – in other words, no duplicate message and no message
    creation
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 进程广播 - 换句话说，没有重复消息，没有消息创建
- en: out of thin air.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 出现无中生有。
- en: '**Relationship Between Broadcasts and Consensus**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播与共识之间的关系**'
- en: Best-effort broadcast is the weakest broadcast model. By adding additional properties
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽力广播是最弱的广播模型。通过添加其他属性
- en: and requirements, we can achieve stronger broadcast models, as shown in Figure
    [3-6](#p142).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 和要求，我们可以实现更强大的广播模型，如图所示[3-6](#p142)。
- en: '122'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '122'
- en: '![](index-142_1.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](index-142_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '***Figure 3-6\.** Broadcast relationship – from weakest to strongest – and
    consensus* *equivalency*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-6.** 广播关系 - 从最弱到最强 - 和共识* *等价性*'
- en: With this, we complete our discussion on broadcast protocols. Let’s now move
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了广播协议的讨论。现在让我们继续
- en: on to the agreement abstraction, which is one of the most fundamental problems
    in
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到一致性抽象，这是最基本的问题之一
- en: distributed computing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算。
- en: First, I’ll explain what an agreement is, and then we’ll build upon this fundamental
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将解释什么是一致，然后我们将基于这个基本的
- en: idea and present the consensus problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想法并提出共识问题。
- en: '**Agreement**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**'
- en: In a distributed system, the agreement between the processes is a fundamental
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，进程之间的一致性是一个基本的
- en: requirement. There are many scenarios where processes need to agree for the
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要求。有许多情况下，进程需要就
- en: distributed system to achieve its goals. For example, in broadcast abstractions,
    an
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统实现其目标。例如，在广播抽象中
- en: agreement is needed between processes for the delivery of messages.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 进程之间需要就消息的传递达成一致。
- en: There are various agreement problems, and we will cover the most prominent of
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的一致性问题，我们将涵盖最突出的
- en: them in the following and then focus more on consensus.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在一致性上更加关注。
- en: We have already covered reliable broadcast and total order broadcast. In this
    section,
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了可靠广播和全序广播。在这一部分中
- en: I will explain some additional points briefly on reliable broadcast and total
    order
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简要解释一些可靠广播和全序
- en: broadcast; then, we’ll explore the Byzantine agreement and consensus.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 广播；然后，我们将探讨拜占庭协议和共识。
- en: '**Reliable Broadcast**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠广播**'
- en: The reliable broadcast assures reliability even if the sender process fails.
    In other words, reliability is guaranteed whether the sender is correct or not.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠广播确保了即使发件进程失败也能保证可靠性。换句话说，无论发件者是否正确，可靠性都得到了保证。
- en: '123'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: Chapter 3 DistributeD Consensus
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '**Total Order Broadcast**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**全序广播**'
- en: The total order broadcast guarantees reliability and the same order of delivery
    at all
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 全序广播保证可靠性和所有传递的相同顺序
- en: nodes. Total order broadcast can be achieved using a single leader approach
    where one
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 节点。使用单一领导者方法可以实现全序广播
- en: node is designated as a leader. All messages go through this leader which establishes
    a
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点被指定为领导者。所有消息都经过这个领导者进行
- en: common order for the messages. The messages are sent to the leader first, which
    then
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 信息的公共顺序。消息首先发送给领导者，然后
- en: broadcasts them using the FIFO broadcast mechanism. However, in this case, the
    issue
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FIFO广播机制广播它们。但是，在这种情况下，问题
- en: is that if the leader crashes, then no messages can be delivered. The question
    then
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 是，如果领导者崩溃，就无法传递任何消息。然后的问题
- en: becomes how we can change the failed leader while ensuring the safety of the
    algorithm.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在确保算法的安全性的同时更换失败的领导者。
- en: If the elected leader that establishes the common delivery order fails, the
    nodes
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果建立公共传递顺序的选举领导者失败，节点
- en: must elect a new leader. The problem now becomes to choose a new honest leader
    and
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 必须选择新领导者。现在的问题变成了选择一个新的诚实的领导者，并且
- en: agree on the new leader’s choice. Again, now nodes must achieve an agreement,
    and the
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同意新领导者的选择。再次，现在节点必须达成一致，并且
- en: problem now becomes an agreement on a new leader instead of an agreement on
    the
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 问题现在成为选择新领导者而不是关于
- en: delivery order. In either case, nodes must run some agreement protocol.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 传递顺序。在任何一种情况下，节点都必须运行一些协议达成一致。
- en: Also, earlier, we discovered that Lamport clocks, using the software event counter
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，早些时候，我们发现拉姆波特时钟，使用软件事件计数器
- en: and the process identifier, can achieve a total order. Combined with FIFO links
    and
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 和进程标识符，可以实现一个总顺序。结合FIFO链接和
- en: timestamps in a total order, Lamport clocks to achieve a total order make intuitive
    sense, but this can be challenging in practical terms. For example, if a node
    goes down, then the entire protocol halts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳在总顺序中的使用，Lamport时钟实现总顺序具有直观意义，但在实际操作中可能具有挑战性。例如，如果某个节点宕机，则整个协议都会停止。
- en: Both single leader (sequencer/orderer approach and Lamport clocks) are not
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 单一领导者（顺序管理/有序者方法和Lamport时钟）都不是
- en: fault tolerant. We will shortly see what we can do about this. Total order broadcast
    and
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 容错。我们很快将看到我们可以做些什么。总顺序广播和
- en: consensus are different problems but are related to each other. If you solve
    consensus,
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 共识是不同的问题，但彼此相关。如果你解决共识问题，
- en: then you can solve the total order and vice versa.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你就能解决总顺序，反之亦然。
- en: Total order broadcast is also called atomic broadcast because it ensures that
    either
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 总顺序广播也被称为原子广播，因为它确保要么
- en: the messages are delivered to all processes or not at all. This atomicity (all
    or nothing) of total order broadcast is what makes it an atomic broadcast protocol,
    hence the name
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 消息会被发送到所有进程，或者根本不被发送。总顺序广播的原子性（一切或者什么都不）是使其成为原子广播协议的关键，因此得名
- en: atomic broadcast.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 原子广播。
- en: '**The Byzantine Agreement Problem**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭协议问题**'
- en: 'The Byzantine agreement problem can be defined in three different ways: the
    Byzantine'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭协议问题可以以三种不同方式定义：拜占庭
- en: generals problem, the interactive consistency problem, and the consensus problem.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将军问题、交互一致性问题和共识问题。
- en: '124'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '124'
- en: Chapter 3 DistributeD Consensus
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: '**The Basic Byzantine Generals Problem or BGP**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本的拜占庭将军问题或BGP**'
- en: There is a designated process called the source process with an initial value.
    The goal of the problem is to reach an agreement with other processes about the
    initial value of the
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个指定的进程称为源进程，其有一个初始值。问题的目标是与其他进程就源进程的初始值达成共识
- en: 'source process. There are three conditions that need to be met:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 源进程。需要满足三个条件：
- en: '• **Agreement**: All honest processes agree on the same value.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: • **一致性**：所有诚实的进程就同一个值达成一致。
- en: '• **Validity**: If the source process is honest, the decided (agreed-upon)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: • **有效性**：如果源进程是诚实的，那么决定（协商一致的）
- en: value by all honest processes is the same value as the initial value of
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实过程产生的价值与发送方进程的初始值相同
- en: the source process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 源进程。
- en: '• **Termination**: Each honest process must eventually decide on'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: • **终止**：每个诚实的进程最终都必须做出决定。
- en: a value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值。
- en: This problem is fundamentally a broadcast primitive in which the designated
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题本质上是一个广播原语，在其中指定的
- en: process starts with an initial value (input), and other processes do not have
    an input
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以一个初始值（输入）开始，而其他进程则没有输入
- en: (initial value). When the algorithm terminates, all processes agree on (output)
    the
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: （初始值）。当算法终止时，所有进程都就（输出）相同的值达成一致。
- en: same value. The crux of the solution for the Byzantine generals problem (BGP)
    is that
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题（BGP）的解决方案的关键是
- en: the sender process reliably sends its input to all processes so that all processes
    output (decide) the same value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方进程可靠地将其输入发送到所有进程，以便所有进程输出（决定）相同的值。
- en: '**The Interactive Consistency Problem**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互一致性问题**'
- en: In this interactive consistency problem, each process has an initial value,
    and all correct processes must agree on a set of values (vector) where each process
    has a corresponding
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交互一致性问题中，每个进程都有一个初始值，而所有正确的进程必须就一组值（向量）达成共识，其中每个进程都有一个相应的
- en: 'value. The requirements are listed as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 值。要求列在下面：
- en: '• **Agreement**: All honest processes agree on the same array of values'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: • **一致性**：所有诚实的进程就同一个值数组达成一致
- en: (vector).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: （向量）。
- en: '• **Validity**: If a correct process decides on a vector V and a process'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: • **有效性**：如果一个正确的进程决定一个向量V和一个进程
- en: P1 is correct and takes as input a value V1 from the vector, then V1
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: P1是正确的，并且从向量中取得值V1，然后V1
- en: corresponds to P1 in the vector V.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于向量V中的P1。
- en: '• **Termination**: Every correct process eventually decides.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: • **终止**：每个正确的进程最终都会做出决定。
- en: '**The Consensus Problem**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**共识问题**'
- en: In the consensus problem, each process has an initial value, and all correct
    processes
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在共识问题中，每个进程都有一个初始值，而且所有正确的进程
- en: 'agree on a single value:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 就同一个值达成一致：
- en: '125'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '125'
- en: '![](index-145_1.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](index-145_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: '• **Agreement**: All processes agree on the same value; no two processes'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '• **协议**: 所有进程均同意相同的值；没有两个进程'
- en: decide on different values.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 决定不同的值。
- en: '• **Validity**: A decided value must be a proposed value of a process.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '• **有效性**: 决定的值必须是进程提出的值。'
- en: • **Integrity:** A process decides at most only once.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: • **完整性:** 进程最多只能决定一次。
- en: '• **Termination**: Every honest process eventually decides on a value.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '• **终止**: 每个诚实的进程最终都会决定一个值。'
- en: Validity and agreement are safety properties, whereas termination is a liveness
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有效性和一致性是安全性属性，而终止是活性
- en: property.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 属性。
- en: Figur[e 3-7 sho](#p145)ws how consensus looks like visually. There is not much
    in the diagram, but it depicts visually and helps to build a mental model of how
    consensus
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3-7 股](#p145)示了共识在视觉上的外观。在图中并没有太多内容，但它能在视觉上展示，并有助于建立共识的心智模型
- en: looks like.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 外观。
- en: '***Figure 3-7\.** Consensus – how it looks visually*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-7。** 共识 – 在视觉上的外观*'
- en: There are many variations of the consensus problem depending upon the system
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统的不同，共识问题存在许多变种
- en: model and failure models.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和故障模型。
- en: The abovementioned consensus problem is called uniform consensus where the
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 上述共识问题称为统一共识，其中
- en: agreement property is strict and does not allow a crashed process to decide
    differently.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 协议属性是严格的，不允许崩溃的进程做出不同的决策。
- en: '126'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '126'
- en: Chapter 3 DistributeD Consensus
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: Another variant of consensus is **non-uniform consensus**. In non-uniform
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 共识的另一个变体是**非统一共识**。在非统一
- en: consensus, the agreement property is *weakened* to allow a crashed process to
    decide on a different value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 共识，协议的一致性属性被*削弱*，以允许崩溃的进程决定不同的值。
- en: We can write the *agreement* property of **uniform consensus** as
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**统一共识**的*一致性*属性写为
- en: '• **Agreement**: No two honest processes decide on different values.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '• **协议**: 没有两个诚实的进程决定不同的值。'
- en: Now if we make the validity property *stronger* in addition to weakening the
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在弱化
- en: agreement property, we achieve **Byzantine-tolerant consensus**. In this case,
    the validity property becomes
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，我们实现了**拜占庭容错共识**。在这种情况下，有效性属性变得
- en: '• **Validity**: A decided value of an honest process must be a proposed'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '• **有效性**: 诚实进程的决定值必须是提议的'
- en: value of an honest process.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实进程的价值。
- en: The first variation where the validity property is weak and the agreement is
    also weak
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种变体，其中有效性属性较弱，协议也较弱
- en: can be categorized as **crash fault–tolerant consensus**.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可归类为**崩溃容错共识**。
- en: An algorithm that satisfies all these safety and liveness properties is called
    a correct
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 满足所有这些安全性和活性属性的算法称为正确的
- en: algorithm. Solving a consensus problem is not difficult in failure-free synchronous
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 算法。在无故障同步共识中解决共识问题并不难，
- en: systems; however, the problem becomes difficult in systems that are failure-prone.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 系统；然而，在容易发生故障的系统中，问题变得更加困难。
- en: Failures and asynchrony make solving consensus a complex problem.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 失效和异步使解决共识成为一个复杂的问题。
- en: '**Binary consensus** is a simple type of consensus where the input is restricted,
    and'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制共识**是一种简单的共识类型，其中输入受限，并且'
- en: as a result, the decision value is restricted to a single bit, either zero or
    one. **Multivalued** **consensus** is a type of consensus where the objective
    is to agree on multiple values, that is, a series of values over time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，决策值受限于单个位，即零或一。**多值** **共识**是一种共识类型，其目标是就多个值达成一致，即随时间变化的一系列值。
- en: While binary consensus may not seem like a very useful construct in the first
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管二进制共识在第一
- en: instance, a solution to a binary consensus problem leads to a solution for multivalued
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 实例，二进制共识问题的解决方案导致了多值共识的解决方案。
- en: consensus; hence, it is an important area for research.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 共识；因此，这是一个重要的研究领域。
- en: The definitions of properties of consensus may change slightly depending on
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 共识属性的定义可能会稍有不同，取决于
- en: the application. For example, usually in blockchain consensus protocols the
    validity
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中。例如，在区块链共识协议中，通常验证
- en: property is defined differently from established definitions and may settle
    for a weaker
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的定义与已建立的定义不同，并且可能会接受较弱的解决
- en: variant. For example, in Tendermint consensus the validity property simply states,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 变体。例如，在 Tendermint 共识中，有效性属性仅陈述，根据协议
- en: '*“a decided value is valid i.e. it satisfies the predefined predicate denoted
    valid( )”* . This can be an application-specific condition. For example, in blockchain
    context it could'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*“决定值是有效的，即满足预定义的谓词denoted valid( )”*。这可能是一个特定的应用条件。例如，在区块链环境中，它可能'
- en: be required that a new block added to the Bitcoin blockchain must have a valid
    block
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要求添加到比特币区块链的新块必须具有有效的块
- en: header that passes node validation checks. In other variations, the valid( )
    predicate
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过节点验证检查传递的头。在其他变化中，valid( )谓词
- en: requirement and the condition “if all honest processes propose the same value,
    then all
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要求和条件“如果所有诚实的进程提出相同的值，那么所有的
- en: decide on that same value” can be combined. This is a combination of validity
    predicate
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 决定相同的值”可以结合起来。这是有效性谓词的组合
- en: and traditional validity condition. There are variations and different definitions.
    Some
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 和传统的有效条件。有许多变种和不同的定义。有的
- en: '127'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '127'
- en: Chapter 3 DistributeD Consensus
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分散式共识
- en: are strict, and some are not so strict, depending on the application. We will
    cover
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的，有的不是那么严格，这取决于应用程序。我们将涵盖
- en: blockchain consensus and relevant consensus protocols throughout this book and
    will
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链共识和相关共识协议，并将在本书中贯穿始终
- en: define and redefine these requirements in the context of the consensus algorithm
    and
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在共识算法和重新定义这些要求的背景下
- en: fault models being discussed.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论中的故障模型。
- en: A consensus protocol is **crash fault tolerant (CFT)** if it can tolerate benign
    faults up to a certain threshold. A consensus protocol is **Byzantine fault tolerant
    (BFT)** if it can tolerate arbitrary faults. In order to achieve crash fault tolerance,
    the underlying
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个共识协议能够容忍恶性故障，那么它就是 **崩溃容错（CFT）** 的。如果一个共识协议能够容忍任意故障，则它是 **拜占庭容错（BFT）** 的。为了实现崩溃容忍，其底层
- en: distributed network must satisfy the condition N >= 2F+1, where N is the number
    of
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式网络必须满足条件 N >= 2F+1，其中 N 是节点的数量
- en: nodes in the network, and F is the number of faulty nodes. If the network satisfies
    this
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的节点，F 是有故障的节点的数量。如果网络满足此
- en: condition, only then it will be able to continue to work correctly and achieve
    consensus.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 条件，那么它才能继续正确工作并实现共识。
- en: If Byzantine faults are required to be tolerated, then the condition becomes
    N>=3F+1\.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要容忍拜占庭故障，则条件变为 N>=3F+1\.
- en: We will cover this more formally when we discuss impossibility results later
    in this
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面讨论不可能性结果时更正式地介绍这个问题。
- en: chapter. But remember these conditions as lower tight bounds.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 章。但请将这些条件记住作为较低的严格下限。
- en: A consensus problem applies to other problems in distributed computing too.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 共识问题也适用于分布式计算中的其他问题。
- en: Problems like total order broadcast, leader election problem, and terminating
    reliable
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于总排序广播，领导者选举问题和可终止的可靠
- en: broadcast require an agreement on a common value. These problems can be considered
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 广播需要就共同值达成一致。这些问题可以被认为是
- en: consensus variants.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 共识变体。
- en: '**System Models**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统模型**'
- en: To study consensus and agreement problems and develop solutions, there are some
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究共识和协议问题，并制定解决方案，有一些
- en: underlying assumptions that we make about the behavior of the distributed system.
    We
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对分布式系统行为的基本假设。我们
- en: learned many of these abstractions regarding node and network behavior in Chapter
    [1](https://doi.org/10.1007/978-1-4842-8179-6_1).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [1](https://doi.org/10.1007/978-1-4842-8179-6_1) 章，我们学到了许多关于节点和网络行为的抽象。
- en: Here, we summarize those assumptions and move on to discuss the consensus
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们总结了这些假设，并继续讨论共识
- en: 'problem in more detail. The reason for describing system models here is twofold:
    first,'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地描述系统模型的原因有两个：首先
- en: to summarize what we learned in the chapter regarding the behavior of the nodes
    and
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们在本章中学到的有关节点和行为的知识
- en: networks and, second, to put this knowledge in the context of studying consensus
    and
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，并且将此知识放入研究共识和
- en: agreement problems. For a detailed study, you can refer to Chapter [1\.](https://doi.org/10.1007/978-1-4842-8179-6_1)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 协议问题。详细研究，可以参考第 [1\.](https://doi.org/10.1007/978-1-4842-8179-6_1) 章
- en: '**Distributed System**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式系统**'
- en: A distributed system is a set of processes that communicate using message passing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统是一组使用消息传递进行通信的进程。
- en: Consensus algorithms are designed based on assumptions made about timing and
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法是基于对定时和假设所进行的
- en: synchrony behavior of the distributed system. These assumptions are captured
    under
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的同步行为。这些假设包括
- en: the timing model or synchrony assumptions, which we describe next.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 计时模型或同步假设，我们将在下一节中描述。
- en: '128'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '128'
- en: Chapter 3 DistributeD Consensus
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[3章分布式一致性](https://doi.org/10.1007/978-1-4842-8179-6_5)'
- en: '**Timing Model/Synchrony**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时模型/同步**'
- en: Synchrony assumptions capture the timing assumption about a distributed system.
    The
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 同步假设捕捉了有关分布式系统的时间假设。
- en: relative speed of processors and communication is also taken into consideration.
    There
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器和通信的相对速度也会考虑进来。那里
- en: 'are several synchrony models. We briefly describe those as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种同步模型。我们简要描述如下：
- en: • Synchronous systems where there is a known upper bound on the
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: • 同步系统，在其中对发送消息的时间有一个已知的上限
- en: processor and communication delay which always holds.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器和通信延迟总是成立。
- en: • Asynchronous systems where there are assumptions made about
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: • 异步系统，其中对
- en: timing. There is no bound on the processor or communication
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 时间没有限制处理器或通信
- en: delay. This is a useful notion because protocols designed with this
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟。这是一个有用的概念，因为用这种
- en: assumption are also automatically resilient in synchronous and
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 假设也自动具有同步和
- en: other models, which are more favorable. In other words, a program
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 其他更有利的模型。换句话说，一个程序
- en: proven correct in an asynchronous model is automatically correct in
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步模型中证明是正确的，就会自动正确
- en: a synchronous model.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个同步模型。
- en: '• Partial synchrony which can be defined in several ways:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: • 部分同步可以用几种方式定义：
- en: • There is an unknown upper bound which always holds.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: • 存在一个未知的上限，总是成立。
- en: • There is a known upper bound that eventually holds after
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: • 存在一个已知的上限，终究在
- en: some GST.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GST之后。
- en: • There are guaranteed periods of synchrony, which are long
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: • 有保证的同步期，长达
- en: enough that a decision can be made, and an algorithm can
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的，以便能够做出决策，以及一个算法能够
- en: terminate.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 终止。
- en: • There is an unknown upper bound which eventually holds after
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: • 存在一个未知的上限，最终在
- en: some GST.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GST之后。
- en: • Weak synchrony introduced with practical Byzantine fault
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: • 弱同步引入了实用拜占庭错误
- en: tolerance (PBFT) assumes that the network latency doesn’t grow
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 容错（PBFT）假设网络延迟不会增加
- en: infinitely more than the timeout.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 无限地比超时时间长。
- en: • A system can be asynchronous initially but is synchronous
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个系统最初可以是异步的，但是同步
- en: after GST.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在GST之后。
- en: Usually, in practice a partially synchronous assumption is made regarding the
    timing
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在实践中，关于时序的部分同步假设是必需的
- en: behavior of the distributed system. This choice is especially true in blockchain
    protocols, where most consensus protocols are designed for eventually synchronous/partially
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的行为。这个选择在区块链协议中尤为重要，因为大多数共识协议都是为最终同步/部分同步设计的
- en: synchronous models, for example, PBFT for blockchain. Of course, some are designed
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 同步模型，例如，区块链的PBFT。当然，一些是设计
- en: '129'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '129'
- en: Chapter 3 DistributeD Consensus
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[3章分布式一致性](https://doi.org/10.1007/978-1-4842-8179-6_5)'
- en: for the asynchronous model, such as HoneyBadger. We will cover blockchain consensus
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步模型，比如HoneyBadger。我们将涵盖区块链共识
- en: in Chapter [5](https://doi.org/10.1007/978-1-4842-8179-6_5) and then throughout
    this book. For now, I will focus on the distributed consensus problem in general
    and from a traditional point of view.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[5章](https://doi.org/10.1007/978-1-4842-8179-6_5)中，并贯穿本书始终。现在，我将专注于一般分布式一致性问题以及传统观点。
- en: Also, note that an asynchronous message-passing model with Byzantine faults
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，与拜占庭错误的异步消息传递模型
- en: expresses conditions of a typical distributed system based on the Internet today.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '根据今天基于互联网的典型分布式系统的情况。 '
- en: Especially, this is quite true in public blockchain platforms such as Bitcoin
    or Ethereum.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '尤其是在比特币或以太坊等公共区块链平台上。 '
- en: '**Process Failures**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理器故障**'
- en: Failure models allow us to make assumptions about which failures can occur and
    how
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 故障模型使我们能够做出关于哪些故障可能发生以及如何
- en: we can address them. Failure models describe the conditions under which the
    failure
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够应对它们。故障模型描述了在何种条件下会发生故障
- en: may or may not occur. There are various classes, such as crash failures, where
    processes
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 可能发生也可能不发生。有各种类别，比如崩溃故障，其中进程
- en: can crash-stop or crash-fail, or omission failures where a processor can omit
    sending or
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 可以发生崩溃停止或崩溃失败，或忽略故障，在其中处理器可以不发送或
- en: receiving a message.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 接收一条消息。
- en: Another type of omission fault is called the dynamic omission fault. In this
    model, a
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种忽略故障类型称为动态忽略故障。在这个模型中，一个
- en: system can lose a maximum number of messages in each round. However, the channels
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在每轮中可能会丢失最大数量的消息。但是，通道
- en: on which the message losses occur may change from round to round.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 丢失的消息可能会从一轮到另一轮发生变化。
- en: Timing failures are those where processes do not comply with the synchrony
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 定时失败是那些进程不遵循同步性的情况
- en: assumptions. The processes may exhibit Byzantine behavior where the processes
    can
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。进程可能表现出拜占庭行为，其中进程可以
- en: behave arbitrarily or maliciously. In the Byzantine model, the corrupted processor
    can
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 表现任意或恶意。在拜占庭模型中，已损坏的处理器可能会
- en: duplicate, drop a message, and actively try to sabotage the entire system. We
    also define an adversary model here where we make some assumptions about an adversary
    who can
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 会略过消息，尝试主动破坏整个系统。我们在此定义了一个敌手模型，做了一些关于敌手的假设，敌手可以
- en: adversely affect the distributed system and corrupt the processors.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对分布式系统产生不良影响并损坏处理器。
- en: In authenticated Byzantine failures, it is possible to identify the source of
    the
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过身份验证的拜占庭失败中，可以确定
- en: message via identification and detect the forged messages, usually via digital
    signatures.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标识消息并检测伪造消息，通常通过数字签名。
- en: Failures that occur under this assumption are called authenticated Byzantine
    failures.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设下发生的故障被称为经过身份验证的拜占庭故障。
- en: Messages can be authenticated or non-authenticated. Authenticated messages
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以经过身份验证或非经过身份验证。经过身份验证的消息
- en: usually use digital signatures to allow forgery detection and message tampering.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用数字签名来允许检测伪造和消息篡改。
- en: The agreement problem becomes comparatively easier to solve with authenticated
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 与经过身份验证的比较容易解决一致性问题
- en: messages because recipients can detect the message forgery and reject the unsigned
    or
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者可以检测消息伪造并拒绝未签名的消息或重复消息。
- en: incorrectly signed messages or messages coming from unauthenticated processes.
    On
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确签名的消息或来自未经身份验证的进程的消息。对
- en: the other hand, distributed systems with non-authenticated messages are difficult
    to
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，处理非经过身份验证的消息的分布式系统很困难
- en: deal with as there is no way to verify the authenticity of the messages. Non-authenticated
    messages are also called oral messages or unsigned messages. Even though it is
    difficult, 130
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 处理，因为无法验证消息的真实性。非经过身份验证的消息也称为口头消息或未签名的消息。尽管困难，130
- en: Chapter 3 DistributeD Consensus
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: it is indeed a common assumption about solving consensus or agreement problems.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一致性或协议问题的常见假设。
- en: However, digital signatures are ubiquitous in blockchain systems, and the model
    under
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数字签名在区块链系统中是无处不在的，而模型是在
- en: which blockchain consensus works is almost always authenticated Byzantine.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链共识工作的方式几乎总是经过身份验证的拜占庭。
- en: '**Channel Reliability**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道可靠性**'
- en: It is often assumed that the channel is reliable. Reliable channels guarantee
    that if a
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 常常假定通道是可靠的。可靠通道保证如果
- en: correct process p has sent a message m to a correct process q, then q will eventually
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的进程p向正确的进程q发送了消息m，那么q最终将
- en: receive m. In practice, this is usually the TCP/IP protocol that provides reliability.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 收到m。实际上，通常是提供可靠性的TCP/IP协议。
- en: Lossy channels are another assumption that captures the notion of channels where
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 丢失通道是捕捉通道概念的另一种假设，通道中
- en: messages can be lost. This can happen due to poor network conditions, delays,
    denial-of-
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可能会丢失。这可能是由于网络条件差，延迟，否认-
- en: service attacks, hacking attacks in general, slow network, a misconfiguration
    in the network configuration, noise, buffer overflows, network congestion, and
    physical disconnections.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：服务攻击，一般的黑客攻击，网络缓慢，网络配置错误，噪音，缓冲区溢出，网络拥堵和物理断开连接。
- en: There might be many other reasons, but I just described the most common ones.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 也许还有许多其他原因，但我只描述了最常见的原因。
- en: There are two variations of fair-loss channels. There is an upper bound k on
    the
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 公平丢失通道有两种变体。有一个上限值k
- en: number of lost messages in one variation, and in another, known as fair-loss
    channels,
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一种是在一种变体中确定丢失的消息数量，另一种是公平丢失通道，
- en: there is no such upper bound. The first variation is easier to handle where
    the algorithm can retransmit the message k+1 times, ensuring that at least one
    copy is received. In
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的上限。第一种变体更容易处理，算法可以重新传输消息k+1次，确保至少接收一份副本。在
- en: the latter variation, the fair-loss channels, if the sender keeps resending
    a message,
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种变体——公平丢失通道，如果发送者不断重新发送消息，
- en: eventually it is delivered, provided that both the sender and the receiver are
    correct. We discussed this in greater detail in Chapt[er 1](https://doi.org/10.1007/978-1-4842-8179-6_1).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最终它被交付，前提是发送方和接收方都是正确的。我们在第[1](https://doi.org/10.1007/978-1-4842-8179-6_1)章中对此进行了更详细的讨论。
- en: '**History**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史**'
- en: Consensus problems have been studied for decades in distributed computing. Achieving
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，在分布式计算中一直在研究共识问题。实现
- en: 'consensus under faults was first proposed by Lamport et al. in their paper
    “SIFT: Design'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次由Lamport等人在他们的论文“SIFT:设计
- en: and analysis of a fault-tolerant computer for aircraft control.”
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 以及飞机控制的容错计算机的分析。”
- en: Later, a Byzantine fault–tolerant protocol under a synchronous setting was first
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 首次提出了同步设置下的拜占庭容错协议
- en: proposed by Lamport et al. in their seminal paper “Reaching Agreement in the
    Presence
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 由Lamport等人在他们的重要论文“在存在的条件下达成一致”中首次提出
- en: of Faults.”
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 故障。”
- en: The impossibility of reaching an agreement even if a single process crash-fails
    was
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有单个进程崩溃失败也不可能达成协议的不可能性
- en: proven by Fischer, Lynch, and Paterson. This discovery is infamously known as
    the FLP
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Fischer, Lynch和Paterson证明的。这一发现臭名昭著，被称为FLP
- en: impossibility result.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能的结果。
- en: Ben-Or proposed asynchronous Byzantine fault tolerance using randomization to
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Ben-Or提出了使用随机化的异步拜占庭容错。
- en: circumvent FLP. In addition, partial synchrony was presented in DLS 88 for BFT.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 规避FLP。此外，DLS 88提出了关于BFT的部分同步性。
- en: '131'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '131'
- en: Chapter 3 DistributeD Consensus
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '**Two Generals’ Problem**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**两将军问题**'
- en: The Two Generals’ Paradox or Two Generals’ Problem was formulated by Gray et
    al. in
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 两位将军悖论或两位将军问题是由格雷等人在
- en: 1978\. In this thought experiment, two generals are sharing a common goal to
    capture
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 1978年。在这个思想实验中，两位将军共同目标是夺取
- en: a hill. The condition is that if both of those generals act simultaneously and
    attack the hill together at the same time, then success is guaranteed. If either
    one of the generals attacks alone, they will lose the battle. It is also assumed
    that both generals are camped some distance apart, and they can communicate only
    via messengers (runners).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一座山。条件是，如果这两位将军同时行动，同时攻击山丘，那么成功是有保证的。如果其中一位将军单独进攻，那么他们将输掉这场战斗。还假设这两位将军分别扎营于一定距离之外，他们只能通过信使（奔跑者）进行交流。
- en: However, these messengers are not reliable and can get lost or captured. If
    one general
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些信使并不可靠，可能会丢失或被抓。如果一个将军
- en: sends a message to another general to attack, for example, “Attack at 0400 hours,”
    then
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息给另一位将军以发起攻击，例如，“在0400小时攻击”，然后
- en: it is possible that the message doesn’t reach the other general. Suppose the
    message
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 可能这条消息没有传递到另一位将军手中。假设这条消息
- en: doesn’t reach the second general. In that case, it is impossible to differentiate
    whether the first general sent a message or not or the messenger got captured
    on its way to the
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这封信没有送到第二将军手中。在这种情况下，无法区分第一将军是发送了一封信还是信使在去找第二将军的路上被抓了
- en: second general. The general who has sent the message cannot assume that his
    message
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 第二位将军。发送消息的将军不能假设他的消息
- en: got through because unless he receives an explicit acknowledgment from the second
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有从第二个接收到明确的确认，他就无法通过。
- en: general, he cannot be sure. Now the question is what protocol we can come up
    with
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，他无法确定。现在的问题是我们能想出什么协议
- en: to reach an agreement on a plan to attack. The situation is tricky because there
    is no
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 达成一致意见计划进攻。这种情况很棘手，因为没有
- en: common knowledge between the generals, and the only way to know is via messengers,
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 将军之间没有共同的知识，唯一的了解方式是通过信使，
- en: which are unreliable.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 它是不可靠的。
- en: Both generals have two options. Either they can go ahead regardless of any
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 两位将军都有两个选择。他们可以无视任何
- en: acknowledgment received from the other general, or they don’t and wait until
    a response
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一位将军那里收到确认, 或者等到收到回应
- en: is received (acknowledgment) from the other general. In the first case, the
    risk is that the general goes ahead without a response from the other general
    and might end up alone
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 来自另一位将军的确认中收到（确认）。在第一种情况下，风险是将军在没有得到对方的回应的情况下前进，可能最终独自一人
- en: in the attack and gets defeated. In the latter case, the general will not act
    until a response is received. In this case, the first general waiting for an acknowledgment
    is safe because he will only attack if the response is received. So now it becomes
    the second general’s
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击中被击败。在后一种情况下，将军在收到响应之前不会行动。在这种情况下，等待回应的第一将军是安全的，因为只有在收到回应时才会发起攻击。所以现在变成了第二位将军的
- en: responsibility to decide whether to attack and be alone or wait for an acknowledgment
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 责任来决定是否攻击并且独自一人或者等待一个确认
- en: from the first general that he has received the acknowledgment. One solution
    that comes
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一将军那里接到了确认。其中一个解决方案是如果将军们发送了很多消息，那么至少有一种可能性会到达，但也有可能会
- en: to mind is that perhaps if generals send a lot of messengers, then there is
    a probability that at least one might get through, but there is also a chance
    that all messengers are
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，也许如果将军们发送很多信使，那么至少有一种可能性会到达，但也有可能会
- en: captured, and no message goes through. For example, if general 1 sends many
    messages
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有军队单位同时攻击，那么所有部队可能都会
- en: to general 2 and all messengers are lost, then general 2 doesn’t know about
    the attack,
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 被捕获，没有消息穿过。例如，如果将军1发送很多消息
- en: and if general 1 goes ahead and attacks, then the battle is lost.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭将军问题**'
- en: The Two Generals’ Problem is depicted in Figure [3-8\.](#p152)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 双将军问题被描述在图 [3-8\.](#p152)
- en: '132'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题是由Lamport在1982年提出的。在这个思想
- en: '![](index-152_1.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](index-152_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: '***Figure 3-8\.** Two Generals’ Problem*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-8\.** 双将军问题*'
- en: In Figur[e 3-8, t](#p152)wo generals must agree on the time to attack; otherwise,
    no win.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在Figur[e 3-8, t](#p152)wo将军必须就攻击时间达成一致意见；否则，不会赢。
- en: The issue is that no general can ever be sure about the commitment from the
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是没有一个将军能确定另一个的承诺
- en: other general. If general 1 always attacks even if no acknowledgment is received
    from
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 其他将军。如果将军1即使没有收到被确认也攻击
- en: general 2, then general 1 risks being alone in the attack if all messengers
    are lost. This is the case because general 2 knows nothing about the attack. If
    general 1 attacks
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 将军2，那么将军1如果所有信使都丢失，就冒着独自攻击的风险。这是因为将军2对攻击一无所知。如果将军1发起攻击
- en: only if a positive acknowledgment is received from general 2, then general 1
    is safe.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 将军是否收到他们的消息，因此产生了悖论！
- en: General 2 is in the same situation as general 1 because now he is waiting for
    general 1’s acknowledgment. General 2 might consider himself safe as he knows
    that general 1 will
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '![](index-153_1.png)'
- en: only attack if general 2’s response is received by general 1\. General 2 is
    now waiting for the acknowledgment from general 1\. They are both thinking about
    whether the other
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在从将军2那里收到积极的确认时，将军1才是安全的。
- en: general received their message or not, hence the paradox!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 将军2面临着与将军1相同的境地，因为现在他正在等待将军1的确认。将军2可能认为自己是安全的，因为他知道将军1会
- en: From a distributed system perspective, this experiment depicts a situation where
    two
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '132'
- en: processes have no common knowledge, and the only way they can find out about
    the
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 互的状态是通过消息。
- en: state of each other is via messages.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 互的状态都是通过消息传递的。
- en: '**Byzantine Generals Problem**'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 从分布式系统的角度看，这个实验描绘了一个情景，即两个
- en: The Byzantine generals problem was proposed by Lamport in 1982\. In this thought
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 对将军2，所有信使都丢失，那么将军2不知道有关攻击，
- en: experiment, an imaginary scenario is presented in which three or more army units
    are
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 实验中，描绘了一个设想的场景，其中三个或更多个军队单位是
- en: camped around a city, and the collective aim of the units is to capture the
    city. Each
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 驻扎在城市周围，部队的集体目标是占领城市。每一个
- en: army unit is led by a general, and they communicate via messengers. The city
    can only
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 由将军领导，并且它们通过信使进行通信。这个城市只能
- en: be captured if all army units attack simultaneously.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 进程没有共同知识，唯一的方式是他们可以找到关于的
- en: The requirement here is to reach an agreement to attack so that all armies can
    attack
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要求是达成一致协议攻击，以便所有军队可以攻击
- en: at the same time and as a result capture the city.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 同时攻击并且结果占领这座城市。
- en: '133'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '133'
- en: '![](index-153_1.png)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: 如果将军1继续进行攻击，那么战斗就失败了。
- en: Chapter 3 DistributeD Consensus
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: The problems this setting can face are
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置可能面临的问题
- en: • Messages can be lost, that is, messengers can be captured or lost.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: • 消息可能会丢失，也就是说，信使可能会被捕获或丢失。
- en: • Any general can be a traitor who can send misleading messages to
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: • 任何将军都可能是叛徒，可以发送误导性的消息给
- en: other generals, can withhold the messages, may not send messages to
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 其他将军，可以扣留消息，也可以不发送消息
- en: all generals, may tamper with the messages before relaying them to
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 所有将军，可以在将消息传递给之前篡改消息
- en: other generals, or can send contradictory messages, all with an aim to
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 其他将军，或者发送矛盾的消息，都是为了
- en: subvert the agreement process between the generals.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 风清水静的过程之间达成一致。
- en: • The honest generals also don’t know who the traitors are, but traitors
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '-   忠诚的将军也不知道谁是叛徒，但叛徒'
- en: can collude together.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 可以勾结在一起。
- en: The challenge here is whether in this situation an agreement can be reached
    and
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下是否可以达成一致。
- en: what protocol can solve this problem, if any. Figure [3-9](#p153) shows this
    problem.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 什么协议可以解决这个问题，如果有的话。图 [3-9](#p153) 显示了这个问题。
- en: '***Figure 3-9\.** Byzantine generals problem – showing each army unit receiving*'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-9\.** 拜占庭将军问题 - 显示每个军队单位收到*'
- en: '*misleading, correct, or no messages at all*'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*误导，正确，或者根本没有消息*'
- en: '134'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '134'
- en: Chapter 3 DistributeD Consensus
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: It turns out that this problem is impossible to solve. It has been proven that
    this
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明这个问题是不可能解决的。已经证明了这个问题
- en: problem can be solved only if fewer than one-third of generals are traitors.
    For example, if there are 3t + 1 generals, only up to t can be malicious. This
    is a proven lower bound on the Byzantine fault tolerance. We will see this more
    formally under the section
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在少于三分之一的将军是叛徒时才能解决这个问题。例如，如果有3t + 1个将军，最多只有t个可以恶意。这是拜占庭容错的已经证明的下限。我们将在本节稍后更正式地看到这一点
- en: “Impossibility Results” where we discuss FLP, CFT lower bounds, and BFT lower
    bounds.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: “不可能结果”中我们将讨论FLP，CFT下界和BFT下界。
- en: In distributed systems, we can have an analog where generals represent processes
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，我们可以有一个类似的情况，将军代表进程
- en: (nodes), traitors represent Byzantine processes, honest generals represent correct
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: （节点），叛徒代表拜占庭过程，忠诚的将军代表正确的
- en: processes, messengers represent communication links, loss of a message is a
    captured
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 过程，使者代表通信链路，丢失消息是被捕捉
- en: messenger, and no time limit on the messenger to reach generals represents asynchrony.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 使者，并且使者抵达将军的时间没限制代表异步性。
- en: I think you get the picture now!
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你现在明白了！
- en: '**Replication**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**'
- en: In this section, we will discuss replication. Replication is used to maintain
    an exact copy of the data in multiple nodes. This technique has several advantages.
    One key advantage
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论复制。复制用于在多个节点中保持数据的完全副本。这种技术有几个优点。一个关键的优势
- en: is fault tolerance. One example of the simplest replication is RAID in storage
    systems.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 是容错。存储系统中最简单的复制之一就是RAID。
- en: For example, in RAID-1, there are two disks, and they are exact replicas (mirror)
    of each other. If one is unavailable, the copy is available, resulting in fault
    tolerance and high availability. In distributed systems, replication is used for
    various reasons and, unlike RAID, is between multiple nodes instead of just between
    two disks within a server.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在RAID-1中，有两个磁盘，它们是彼此的精确副本（镜像）。如果一个不可用，那么副本可用，从而实现了容错和高可用性。在分布式系统中，复制被用于各种原因，与RAID不同的是，它不仅仅在服务器内的两个磁盘之间，而是在多个节点之间。
- en: Also, if data remains unchanged, then replication is easy. You can just make
    a one-off
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果数据保持不变，那么复制就很容易。您只需进行一次性
- en: copy of the data and store it on another disk or node. The challenging part
    is how to keep replication consistent when the data is subject to constant change.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据复制一份并存储在另一个磁盘或节点上。挑战在于数据不断变化时如何保持复制一致性。
- en: 'There are several advantages:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优点：
- en: • High availability due to fault tolerance, for example, if one replica
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '-   由于容错性而具有高可用性，例如，如果一个副本'
- en: goes down, another is available to serve clients.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 下降时，另一个可用于为客户提供服务的。
- en: • Load distribution due to each replica node being an independent
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '-   由于每个副本节点都是独立的'
- en: node, and clients can send requests to different nodes (or can be
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，并且客户可以发送请求到不同的节点（或者可以是
- en: managed via load balancers to route requests to less busy replicas –
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 通过负载均衡器来管理路由请求到繁忙程度较低的副本 –
- en: load balancing). The load can be distributed among different replicas
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 负载平衡）。负载可以分布在不同的副本之间
- en: to achieve higher performance.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 以实现更高的性能。
- en: • Data consistency means that the same copy of data is available across
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '-   数据一致性意味着相同的数据副本可以在各处使用'
- en: all nodes, which helps with the integrity of the overall system.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点，这有助于整个系统的完整性。
- en: '135'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '135'
- en: Chapter 3 DistributeD Consensus
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: • Better performance, which is achieved via load balancing, where
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: • 较好的性能，通过负载平衡实现，其中
- en: nodes that are less busy can take up the requests in case other nodes
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 较不繁忙的节点可以处理请求，以防其他节点
- en: are near or full capacity. There are several techniques for this, which
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 接近或容量已满。有几种技术可以实现这一点
- en: are beyond the scope of this book; however, usually load balancers
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 超出了本书的范围；然而，通常会使用负载均衡器
- en: are used which route requests from clients usually in a round-robin
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于将来自客户端的请求路由，通常是轮询
- en: fashion to replicas. This way, the load is distributed across multiple
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 与副本相同的方式。这样，负载就分散到多个
- en: replicas instead of one node getting all the hits and as a result
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 代之以单一节点承受所有请求，因此
- en: becoming less responsive due to CPU load.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CPU 负载而变得不太响应。
- en: • Data locality, where, especially in a geographically distributed
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: • 数据局部性，在地理上分布的情况下
- en: network, the nodes that are local to a client can serve the requests
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，对于一个客户端本地的节点可以为请求提供服务
- en: instead of scenarios where there might be only one node in some
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是只有一种情景下可能只有一个节点
- en: remote data center and all clients either geographically close or
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 远程数据中心和所有客户端要么地理位置接近，要么
- en: far make requests to only that single server. The clients that are
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 远程向单个服务器发送请求的客户端。那些
- en: physically nearer to the server will get their response quicker as
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 物理位置更接近的服务器将更快地收到它们的响应，因为
- en: compared to clients that are physically located cities or continents
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 与位于城市或大陆的客户端相比
- en: apart. For example, in file download services, a mirror that is, for
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 分开。例如，在文件下载服务中，一个镜像，例如
- en: example, available in Ireland will be able to serve the download
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 例，位于爱尔兰的可提供下载服务
- en: requests much faster than a server that might be in Australia.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 比可能在澳大利亚的服务器更快地处理请求。
- en: The network latency alone makes such setting vulnerable to
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅网络延迟就使得这样的设置容易受到
- en: performance hit.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 性能损失。
- en: 'There are some shortcomings as well:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在一些缺点：
- en: • High cost, due to multiple replica nodes required, the setup might be
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: • 高成本，需要多个副本节点，设置可能会
- en: expensive.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 昂贵。
- en: • Maintaining data consistency among replicas is hard.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: • 在副本之间维持数据一致性很困难。
- en: Replication can be achieved by using two methods. One is the state transfer,
    where
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 复制可以通过两种方法实现。一种是状态传输，其中
- en: a state is sent from one node to another replica. The other approach is state
    machine
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态从一个节点发送到另一个副本。另一种方法是状态机
- en: replication. Each replica is a state machine that runs commands deterministically
    in the
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 复制。每个副本都是以确定性方式运行命令的状态机
- en: same sequence as other replicas, resulting in a consistent state across replicas.
    Usually, in this case, a primary server receives the commands, which then broadcasts
    them to
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他副本相同的顺序，使得副本之间的状态保持一致。通常，在这种情况下，主服务器接收命令，然后将其广播到
- en: other replicas that apply those commands.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用这些命令的副本。
- en: There are two common techniques for achieving replication. We define them as
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 实现复制的两种常见技术。我们将它们定义为
- en: follows.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示。
- en: '136'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '136'
- en: Chapter 3 DistributeD Consensus
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '**Active Replication**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**主动复制**'
- en: In this scheme, the client commands are ordered via an ordering protocol and
    forwarded
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方案中，客户端命令通过一个排序协议进行排序，并转发
- en: to replicas that execute those commands deterministically. The intuition here
    is that if all commands are applied in the same order at all replicas, then each
    replica will produce
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以确定性方式执行这些命令的副本。这里的直觉是，如果所有命令在所有副本上以相同的顺序应用，那么每个副本将产生
- en: the same state update. This way, all replicas can be kept consistent with each
    other. The key challenge here is to develop a scheme for ordering the commands
    and that all nodes
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的状态更新。这样，所有副本都会保持一致。这里的关键挑战是开发一种命令排序方案，并确保所有节点
- en: execute the same commands in the same order. Also, each replica starts in the
    same
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的顺序执行相同的命令。另外，每个副本起始于相同的
- en: state and is a copy of the original state machine. Active replication is also
    known as **state** **machine replication**.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 状态，是原始状态机的副本。主动复制也被称为**状态** **机复制**。
- en: '**Passive Replication**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**被动复制**'
- en: In the passive replication approach, there is one replica that is designated
    as primary.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在被动复制方法中，有一个副本被指定为主要副本。
- en: This primary replica is responsible for executing the commands and sending (broadcast)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 此主要副本负责执行命令并发送（广播）
- en: the updates to each replica, including itself. All replicas then apply the state
    update
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 更新到每个副本，包括它自己。然后所有副本都应用状态更新。
- en: in the order received. Unlike active replication, the processing is not required
    to be
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 按接收顺序。与主动复制不同，处理不需要
- en: deterministic, and any anomalies are usually resolved by the designated primary
    replica
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性的，并且任何异常情况通常由指定的主副本解决
- en: and produce deterministic state updates. This approach is also called **primary
    backup**
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 并产生确定性的状态更新。这种方法也被称为**主备份**
- en: '**replication**. In short, there is only a single copy of the state machine
    in the system kept by the primary replica, and the rest of the replicas only maintain
    the state.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**。简而言之，在系统中只有状态机的一个副本由主副本保留，其余的副本只维护状态。'
- en: '**Pros and Cons**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**优缺点**'
- en: There are pros and cons of both approaches. Active replication can result in
    wastage of
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这两种方法都有利有弊。主动复制可能会导致浪费
- en: resources if the operations are intensive. In the case of passive replication,
    large updates can consume a large amount of network bandwidth. Furthermore, in
    passive replication,
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作量比较大，这也会耗费大量的网络带宽。此外，在被动复制中，
- en: as there is one primary replica, if it fails, the performance and availability
    of the system are impacted.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有一个主副本，如果它出现故障，系统的性能和可用性会受到影响。
- en: In the passive approach, client write requests are preprocessed by the primary
    and
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在被动方法中，客户端的写入请求由主服务器预处理并
- en: transformed into state update commands, which apply to all replicas in the same
    order.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为状态更新命令，并以相同顺序应用于所有副本。
- en: Each replica is a copy of the state machine in active replication, whereas,
    in passive
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本都是主动复制中状态机的副本，而被动复制
- en: replication, only the primary is a single copy of the state machine.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 复制，只有主副本是状态机的单一副本。
- en: '137'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '137'
- en: Chapter 3 DistributeD Consensus
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: Note that even though there is a distinction between active and passive replication
    at
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在主动和被动复制之间有区别，在
- en: a fundamental level, they both are generic approaches to making a state machine
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，它们两者都是使状态机
- en: fault-tolerant.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 容错。
- en: Let’s now see how primary backup replication works. I am assuming a fail-stop
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下主备份复制是如何工作的。我假设有一个故障停止
- en: model here.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 模型。
- en: '**Primary Backup Replication**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**主备份复制**'
- en: Primary backup replication is the most common type of replication scheme. There
    is
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 主备份复制是最常见的复制方案。有
- en: one replica that is designated primary, and the rest of the nodes are backups.
    A correct
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被指定为主服务器的正确副本
- en: process bearing the lowest identifier is designated as a primary replica. A
    client sends
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最低标识符的进程被指定为主副本。客户端发送
- en: requests to the designated primary, which forwards the request(s) to all backups.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 请求转发到指定的主服务器，主服务器将请求转发到所有备份服务器。
- en: The primary replies to the client only after it has received responses from
    the backups.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 主服务器只在收到所有备份的响应后才向客户端回复。
- en: When the client makes a write request, the primary sends the request to all
    replicas, and after receiving the response from the backups, it makes the update
    to itself (deliver to
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发出写入请求时，主服务器将请求发送到所有副本，并在收到来自备份的响应后，将更新提交给自己（交付给
- en: itself).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 本身）。
- en: 'The algorithm works as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的工作原理如下：
- en: 1\. The client sends a write request to the primary.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 客户端向主服务器发送写入请求。
- en: 2\. The primary broadcasts it to the backup replicas.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 主服务器将请求广播到备份副本。
- en: 3\. Backup replicas send an acknowledgment (response) to the
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 备份副本向主服务器发送确认（响应）。
- en: primary replica.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 主副本。
- en: 4\. The primary waits until it has received all responses from backup
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 主服务器等待收到所有备份的响应
- en: replicas.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 副本。
- en: 5\. Once it has received all responses, it delivers the request to itself.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 一旦收到所有响应，它将请求提交给自己。
- en: This is called the commit point.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为提交点。
- en: 6\. After this, the primary sends the response back to the client.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 然后，主服务器将响应发送回客户端。
- en: In the case of read operation
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在读操作的情况下
- en: 1\. The client sends a request to the primary.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 客户端发送请求到主服务器。
- en: 2\. The primary responds.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 主服务器回复。
- en: Figur[e 3-10 illus](#p158)trates this concept.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-10描绘](#p158)述了这个概念。
- en: '138'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '138'
- en: '![](index-158_1.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![](index-158_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: '***Figure 3-10\.** Primary backup replication*'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-10\.** 主备份复制*'
- en: How are failures handled? If the primary fails, one of the backups will take
    over.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 故障是如何处理的？如果主服务器出现故障，其中一个备份服务器将接管。
- en: Now, this looks like a suitable protocol for achieving fault tolerance, but
    what if the
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来像一个适合实现容错的协议，但如果
- en: primary fails? Primary failure can lead to downtime as recovery can take time.
    Also,
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 主服务器失败？主服务器故障可能导致停机，因为恢复可能需要时间。另外，
- en: reading from the primary can produce incorrect results because, in scenarios
    where
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 从主服务器读取可能会产生不正确的结果，因为在一些情况下
- en: the client makes a read request to the primary before the commit point, the
    primary
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在提交点之前向主服务器进行读取请求，主服务器
- en: will not produce the result, even though all replicas have that update delivered
    to them.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 将不会产生结果，即使所有副本都已经传递了更新。
- en: One solution might be to deal with reads as updates, but this technique is relatively
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案可能是将读取视作更新来处理，但这种技术相对
- en: inefficient. Also, the primary is doing all the work, that is, sending to other
    replicas, receiving responses, committing, and then replying to the client. Also,
    the primary must
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 低效。此外，主服务器正在做所有的工作，即发送到其他副本，接收响应，提交，然后回复给客户端。此外，主服务器必须
- en: wait until all responses are received from the replicas for it to be able to
    respond to the client. A better solution, as compared to the primary backup replica
    solution, is chain
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 等待直到所有副本都接收到响应才能回复给客户端。与主备份副本解决方案相比，更好的解决方案是链式
- en: replication. Here, the core idea is that one of the backup servers will reply
    to read the requests, and another will process the update commands.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 复制。这里的核心思想是备份服务器之一将回复读取请求，而另一个将处理更新命令。
- en: '**Chain Replication**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**链式复制**'
- en: Chain replication organizes replicas in a chain with a head and a tail. The
    head is the
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 链式复制将副本组织成一个带有头部和尾部的链。头部是
- en: server with the maximum number, whereas the tail is the one with the lowest
    number.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器编号最大，而尾部是编号最低的。
- en: Write requests or update commands are sent to the head, which sends the request
    using
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 写请求或更新命令被发送到头部，头部使用
- en: reliable FIFO links to the next replica on the chain, and the next replica then
    forwards it to the next until the update reaches the last (tail) server. The tail
    server then responds to the client. The head replica orders the requests coming
    in from the clients.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的FIFO链路到链上下一个副本，然后下一个副本将其转发到下一个，直到更新到达最后一个（尾部）服务器。尾部服务器然后响应给客户端。头部副本对来自客户端的请求进行排序。
- en: '139'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '139'
- en: '![](index-159_1.png)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![](index-159_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: For a read request (query), the client sends it directly to the tail, and the
    tail replies.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取请求（查询），客户端将其直接发送到尾部，并由尾部回复。
- en: It is easy to recover when the tail fails by just reselecting the predecessor
    as the new tail.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 当尾部失败时，只需重新选择前一个副本作为新的尾部，就可以轻松恢复。
- en: If the head fails, its successor becomes the new head and clients are notified.
    Figure [3-11](#p159)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果头部失败，则其后继者成为新的头部，并通知客户端。图[3-11](#p159)
- en: shows how chain replication works.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 显示链式复制的工作原理。
- en: '***Figure 3-11\.** Chain replication*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-11\.** 链式复制*'
- en: Chain replication provides high availability, high throughput, and strong
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 链式复制提供高可用性、高吞吐量和强大的
- en: consistency. It can tolerate up to *n* – 1 failures.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。它可以容忍高达*n* – 1的故障。
- en: '**State Machine Replication**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机复制**'
- en: The state machine methodology was introduced by Leslie Lamport in his seminal
    paper
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机方法是由Leslie Lamport在他的开创性论文中提出的
- en: “Time, Clocks, and the Ordering of Events in a Distributed System” in 1978\.
    It is a de
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: “时间、时钟和分布式系统中事件排序”1978年的文章。这是一个de
- en: facto standard for achieving fault tolerance in distributed systems.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中实现容错的事实标准。
- en: Let’s first define what a state machine is. A state machine executes a sequence
    of
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义什么是状态机。状态机执行一系列
- en: commands. It stores the state of the system. This stored state transitions to
    the next
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 命令。它存储系统的状态。这个存储状态会转移到下一个
- en: state through a state transition function as a result of executing commands.
    Commands
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 通过状态转换功能的状态。命令执行结果的状态和输出仅由输入确定
- en: are deterministic, and the resultant state and output are only determined by
    the input
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 是确定性的，结果状态和输出仅由输入决定
- en: commands which the machine has executed.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 机器执行的命令之一。
- en: The simple algorithm in Listing [3-1 des](#p160)cribes a state machine node.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 列表[3-1 des](#p160)中的简单算法描述了状态机节点。
- en: '140'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '140'
- en: '![](index-160_1.png)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](index-160_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: '***Listing 3-1\.*** State machine'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '***列表3-1\.*** 状态机'
- en: state := initial
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 := 初始
- en: log := lastcommand
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 日志 := 最后的命令
- en: while (true) {
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 当（真）{
- en: on event receivecommand()
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到命令的事件上
- en: '{'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: appendtolog(command)
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到日志(command)
- en: output := statetransition(command, state)
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：= statetransition（命令，状态）
- en: sendtoclient(output)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 给客户发送输出
- en: '}'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: In this pseudocode, the state machine starts with an initial state. When a command
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个伪代码中，状态机从初始状态开始。当一个命令
- en: is received from the client, it appends that to the log. After that, it executes
    the command through the transition function and updates the state and produces
    an output. This
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 当从客户端接收到命令时，将其附加到日志中。之后，它通过转换函数执行该命令并更新状态并产生输出。这
- en: output is sent to the client as a response.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 输出作为响应发送给客户端。
- en: Figur[e 3-12 illus](#p160)trates this concept.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3-12说明](#p160)了这个概念
- en: '***Figure 3-12\.** State machine replica*'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '*** 图3-12. **状态机副本*'
- en: The key idea behind state machine replication is that if the system is modelled
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机复制的关键思想是，如果系统建模为
- en: as a state machine, then replica consistency can be achieved by simply achieving
    an
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 作为状态机，那么只需实现一个操作的一致
- en: agreement on the order of operations. If the same commands are applied to all
    nodes in
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 对操作的顺序达成一致。如果相同的命令应用于所有节点
- en: '141'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '141'
- en: Chapter 3 DistributeD Consensus
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: the same order, then a general approach to keep all replicas consistent with
    each other is achieved. However, the challenge here is to figure out how to achieve
    a common global
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的顺序，那么将所有副本保持一致的一般方法是实现一个共同的全局
- en: order of the commands.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的顺序。
- en: In order to achieve an agreement on the order of operations, we can use agreement
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在操作的顺序上达成一致，我们可以使用协议
- en: protocols such as Byzantine agreement protocols or reliable broadcast protocols.
    We
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如拜占庭协议或可靠广播协议。我们
- en: discussed the total order broadcast abstraction earlier in this chapter. We
    can also
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面我们讨论了总序广播抽象。我们也可以
- en: use consensus algorithms such as Paxos or PBFT to achieve this. Remember that
    in
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如Paxos或PBFT等共识算法来实现这一点。请记住，在
- en: total order broadcast, each process delivers the same message in the same order.
    This
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 总序传播，每个进程以相同的顺序传递相同的消息。这
- en: property immediately solves our problem of achieving an agreement on the order
    of
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 属性立即解决了我们在操作顺序上达成一致的问题
- en: operations, which is the core insight behind state machine replication. Total
    order
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，这是状态机复制的核心见解。总序
- en: broadcast ensures that commands from different clients are delivered in the
    same order.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 广播确保来自不同客户端的命令以相同的顺序传递。
- en: If commands are delivered in the same order, they will be executed in the same
    order
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令以相同的顺序交付，它们将以相同的顺序被执行
- en: and as state machine is deterministic, all replicas will end up in the same
    state.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 和作为状态机是确定性的，所有副本最终将处于相同的状态。
- en: Each replica is a state machine which transitions its state to the next
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本都是一个状态机，它将其状态转换为下一个
- en: deterministically as a result of executing the input command. The state on each
    replica
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行输入命令的结果。每个副本上的状态
- en: is maintained as a set of (key, value) pairs. The output of commands is transitioned
    from the current state to the next. Determinism is important because this ensures
    that each
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 以(key, value)对的形式维护。命令的输出从当前状态转移到下一个状态。确定性非常重要，因为这确保了每个
- en: command execution produces the same output. Each replica starts in the same
    initial
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行产生相同的输出。每个副本都从相同的初始状态开始
- en: state. Total order broadcast delivers the same command to each replica in the
    global
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 状态。总序广播在全局中将相同的命令传递给每个副本
- en: order, which results in each replica executing the same sequence of commands
    and
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序，这导致每个副本执行相同的命令序列和
- en: transitioning to the same state. This achieves the same state at each replica.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 转移到相同的状态。这在每个副本中实现了相同的状态。
- en: This principle is also used in blockchains where a total order is achieved on
    the
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原理也用在区块链中，通过某些共识机制实现了总序
- en: sequence of transactions and blocks via some consensus mechanism, and each node
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 事务和块的顺序，并且每个节点
- en: executes and stores those transactions in the same sequence as other replicas
    and as
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 执行并以与其他副本相同的顺序存储这些事务
- en: proposed by proof of work winner, leader. We will explore this in detail in
    Chapt[er 5](https://doi.org/10.1007/978-1-4842-8179-6_5).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 由工作证明获胜者，领导者提出。我们将在第[5章](https://doi.org/10.1007/978-1-4842-8179-6_5)中详细探讨这一点。
- en: Traditional protocols such as Practical Byzantine Fault Tolerance (PBFT) and
    RAFT are
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 传统协议，如实用拜占庭容错（PBFT）和RAFT协议
- en: state machine replication protocols.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机复制协议。
- en: SMR is usually used to achieve increased system performance and fault tolerance.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于实现提高系统性能和容错性。
- en: System performance can increase because multiple replicas host copies of data,
    and
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 系统性能可以提高，因为多个副本托管数据副本，并且
- en: more resources are available due to multiple replicas. Fault tolerance increases
    due to
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多个副本而增加了可用资源。由于多个副本，容错性提高。
- en: the simple fact that as data is replicated on each replica, even if some replicas
    are not available, the system will continue to operate and respond to client queries
    and updates.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使有些副本不可用，数据在每个副本上都被复制，系统仍将继续运行并响应客户端的查询和更新。
- en: Now let’s look at SMR properties formally.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们正式看一下SMR的属性。
- en: '142'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '142'
- en: Chapter 3 DistributeD Consensus
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: '**Same Initial State**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**相同的初始状态**'
- en: The replicas always start in the same initial state. It could just be an empty
    database.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 复制品始终从相同的初始状态开始。可能只是一个空数据库。
- en: '**Deterministic Operations**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定性操作**'
- en: All correct replicas deterministically produce the same output and state for
    the same
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正确的复制品对相同的输出和状态进行确定性处理
- en: input and state.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和状态。
- en: '**Coordination**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**协调性**'
- en: All correct replicas process the same commands in the same order.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正确的复制品以相同的顺序处理相同的命令。
- en: The coordination property requires the use of agreement protocols such as total
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 协调性质要求使用类似于total的协议
- en: order broadcast or some consensus algorithms.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: order broadcast or some consensus algorithms.
- en: There are also two *safety* and *liveness* properties which we describe as follows.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个安全性和活跃性属性，我们将其描述如下。
- en: '**Safety**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: All correct replicas execute the same commands. This is the **agreement** property.
    There are two general approaches to achieve an agreement. We can use either a
    total order
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正确的复制品执行相同的命令。这是**协议**的属性。实现一致是有两种通用方法的。我们可以使用total
- en: broadcast or a consensus protocol. A total order broadcast protocol needs to
    run only
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 广播或共识协议。总序广播协议只需运行一次
- en: once per state machine replication, whereas a consensus mechanism is instantiated
    for
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态机复制一次，而共识机制实例化为
- en: each period of the sequence of commands.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 命令序列的每个时间段。
- en: '**Liveness**'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**活跃性**'
- en: All correct commands are eventually executed by correct replicas. This is also
    called the **completion** property.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正确的命令最终由正确的副本执行。这也被称为**完成**属性。
- en: Safety ensures consistency, whereas liveness ensures availability and progress.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性确保一致性，而活跃性确保可用性和进度。
- en: Figur[e 3-13 demons](#p163)trates how SMR generally works.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3-13 demons](#p163)将演示SMR通常的工作方式。
- en: '143'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '143'
- en: '![](index-163_1.png)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](index-163_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: '***Figure 3-13\.** State machine replication*'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-13。** 状态机复制*'
- en: 'In Figur[e 3-13](#p163), we can see how the process works:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[3-13](#p163)中，我们可以看到流程如何工作：
- en: 1\. The client submits the command x = 5 to replica 1\.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 1.客户端将命令x = 5提交给副本1。
- en: 2\. Replica 1 sends this command to replica 2 and replica 3\.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 2.副本1将此命令发送给副本2和副本3。
- en: 3\. All replicas append the command to their logs.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 3.所有副本将命令追加到它们的日志中。
- en: 4\. Each state machine on all replicas executes the command.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 4.所有副本上的状态机执行命令。
- en: 5\. Replica 1 responds back to the client with the reply/result.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 5.副本1将回复/结果返回给客户端。
- en: The replicated log on the replicas ensures that commands are executed by the
    state
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 副本的复制日志确保状态机命令按照确定的全局顺序执行
- en: machine in the same order on each replica. The consensus mechanism (in the top-left
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 每个复制品的同一顺序中执行。一致性机制（在左上角
- en: corner of the image) ensures that an agreement is achieved on the order of commands
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的角落）确保命令顺序达成一致
- en: and as a result written into the log as such. This involves reaching an agreement
    on the
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其作为这样的记录写入日志。这涉及就命令序列达成一致意见。如果有其他复制体，
- en: sequence of commands with other replicas. This replicated system will make progress
    if
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 命令序列。如果有其他复制品的命令序列达成一致意见。如果这种复制系统
- en: majority of the replicas are up.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数副本是正常的。
- en: Consensus and state machine replication are related in the sense that distributed
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 共识和状态机复制在某种意义上相关，即分布式
- en: consensus establishes the global common order of state machine commands, whereas
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 共识建立状态机命令的全局公共顺序，而
- en: the state machine executes these commands according to the global order determined
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机根据确定的全局顺序执行这些命令
- en: by the consensus (agreement) algorithm, and thus each node (state machine) reaches
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共识（协议）算法来决定，因此每个节点（状态机）都达到了
- en: the same state.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的状态。
- en: '144'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '144'
- en: Chapter 3 DistributeD Consensus
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: A crash fault–tolerant SMR requires at least 2f+1 replicas, whereas a BFT SMR
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 一个崩溃容错的状态机复制至少需要2f+1个副本，而一个BFT SMR
- en: requires 3f+1 replicas, where f is the number of failed replicas.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 需要3f+1个副本，其中f是失败的副本数量。
- en: State machine replication achieves consistency among replicas. There are various
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机复制实现了副本之间的一致性。有各种各样的
- en: replica consistency models. We’ll briefly explore them here.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 副本一致性模型。我们将在这里简要探讨它们。
- en: '**Linearizability**'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性一致性**'
- en: Another stronger property that a state machine replication protocol may implement
    is
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态机复制协议可以实现的另一个更强的属性
- en: called linearizability. Linearizability is also called atomic consistency, and
    it means that command execution appears as if executed on a single copy of the
    state machine, even
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 称为线性一致性。线性一致性也称为原子一致性，它意味着命令执行看起来就像在状态机的单个副本上执行一样，即使
- en: if there are multiple replicas. The critical requirement of linearizability
    is that the state read is always up to date, and no stale data is ever read.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个副本。线性一致性的关键要求是读取的状态始终是最新的，永远不会读取过时的数据。
- en: Consistency models allow developers to understand the behavior of the replicated
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性模型可以让开发人员了解复制的行为
- en: storage system. When interacting with a replicated system, the application developers
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 存储系统。与复制系统交互时，应用程序开发人员
- en: experience the same behavior as interacting with a single system. Such transparency
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 体验与与单一系统交互相同的行为。这种透明度
- en: allows developers to use the same single server convention of writing application
    logic. If a replicated system possesses such transparency, then it is said to
    be linearizable.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 允许开发人员使用相同的单一服务器约定来编写应用程序逻辑。如果一个复制系统具有这种透明度，那么它被称为是线性的。
- en: In literature, linearizability is also called strong consistency, atomic consistency,
    or
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，线性一致性也被称为强一致性、原子一致性或
- en: immediate consistency.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 立即一致性。
- en: '**Sequential Consistency**'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序一致性**'
- en: In this type of consistency, all nodes see the same order of commands as other
    nodes.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种一致性类型中，所有节点看到的命令顺序与其他节点相同。
- en: Linearizability and sequential consistency are two classes of **strong consistency**.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 线性一致性和顺序一致性是**强一致性**的两种类别。
- en: '**Eventual Consistency**'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终一致性**'
- en: Under the eventual consistency model, there is an eventual guarantee that each
    replica
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终一致性模型下，最终保证每个副本
- en: will be in the same state if there are no more updates. However, this implies
    that there
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的更新，那么最终会处于相同的状态。然而，这意味着
- en: is no timing guarantee because updates may never stop. Therefore, this is not
    quite a
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 没有时间保证，因为更新可能永远不会停止。因此，这并不完全是一个
- en: reliable model. Another stronger scheme is called strong eventual consistency
    which
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的模型。另一个更强的方案称为强最终一致性
- en: has two properties. Firstly, updates applied to one honest replica are eventually
    applied to every nonfaulty replica. Secondly, regardless of the order in which
    the updates have
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 具有两个属性。首先，应用于一个诚实副本的更新最终应用于每个非故障的副本。其次，无论更新的顺序如何
- en: been processed, if two replicas have processed the same set of updates, they
    end up
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 已经处理，如果两个副本处理了相同的更新集，它们最终会
- en: in the same state. The first property is called eventual delivery, whereas the
    second
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的状态。第一个属性称为最终交付，而第二个
- en: property is named convergence.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 属性被命名为收敛。
- en: '145'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '145'
- en: Chapter 3 DistributeD Consensus
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: There are several advantages of this approach. It allows replicas to progress
    without
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优点。它允许副本无需
- en: network connectivity until the connectivity is restored, and eventually replicas
    converge to the same state. Eventual consistency can work with weaker models of
    broadcast,
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 网络连接，直到恢复连接，并最终副本收敛到相同状态。最终一致性可以使用更弱的广播模型，
- en: instead of total order broadcast.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是总体顺序广播。
- en: Eventual consistency has several categories such as last write wins. The technique
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性有几种类别，比如最后写入获胜。这种技术
- en: here is to apply updates with the most recent timestamp and discard any other
    updates
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是要应用具有最近时间戳的更新，并且丢弃任何其他更新
- en: writing to the same key (updating the same data) with lower timestamps. This
    means
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较低的时间戳向相同的键（更新相同的数据）写入。这意味着
- en: that we accept some data loss in favor of eventually converging state at all
    replicas.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受一些数据丢失，以换取所有副本最终收敛到相同状态的。
- en: '**SMR Using Weaker Broadcast Abstractions**'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用较弱的广播抽象的状态机复制**'
- en: SMR makes use of total order broadcast for achieving a global order of commands
    in
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: SMR利用总顺序广播来实现全局命令顺序
- en: the system. Here, the question arises whether we can use weaker types of broadcast
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。在这里，问题是我们是否可以使用更弱的广播类型
- en: abstractions to build state machine replication. The answer is yes; however,
    a property
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建状态机复制的抽象。答案是肯定的；但是，一种特性
- en: called “commutativity” is required along with some other properties. Updates
    are
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做“可交换性”，还需要满足其他一些特性。更新是
- en: commutative if the order of two updates does not matter, for example, in arithmetic,
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个更新的顺序不重要，那么是可交换的，比如在算术中
- en: A + B = B + A, the order of A and B doesn’t matter; it will achieve the same
    result.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: A + B = B + A, A和B的顺序不重要；它将得到相同的结果。
- en: Similarly, we say that commands x and y commute, if in every state *s* of the
    state machine executing x before y or y executing before x results in the same
    state update and x and y returns the same response when executed. In this, we
    say x and y commute.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们说命令x和y是可交换的，如果在状态机的每个状态*s*中，执行x然后执行y或先执行y再执行x都导致相同的状态更新，并且x和y在执行时返回相同的响应。在这里，我们说x和y是可交换的。
- en: The key insight here is that if replica state updates are commutative, then
    replicas
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键见解是，如果复制状态更新是可交换的，那么复制品
- en: can process the commands in any order and still would end up in the same state.
    Of
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以任何顺序处理命令，但最终达到相同状态。而
- en: course, you must build commutative mechanics into the protocol. Table [3-1](#p166)
    shows different broadcasts and relevant properties along with assumptions regarding
    a state
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你必须在协议中构建可交换的机制。表[3-1](#p166)展示了不同广播和相关特性以及对状态的假设
- en: update[.1](#p165)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 更新[.1](#p165)
- en: 1 This table has been adapted from wonderful lectures on distributed computing
    by Dr. Martin Kleppmann.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 1该表格取自Martin Kleppmann博士的分布式计算的精彩演讲。
- en: '146'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '146'
- en: Chapter 3 DistributeD Consensus
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '***Table 3-1\.** Broadcasts and requirements to build replication*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '***表3-1**。广播和构建复制的要求*'
- en: '**Type of**'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: '**Key Property**'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键特性**'
- en: '**State Update Requirement**'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态更新要求**'
- en: '**Broadcast**'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播**'
- en: total order
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 总顺序
- en: all messages delivered in the same order at Deterministic
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息以相同的顺序传递在确定性
- en: all replicas
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 所有复制品
- en: Causal
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 因果性
- en: Delivers messages in causal order, but
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 按照循序传递消息，但
- en: Deterministic, concurrent updates
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 决定性，并发更新
- en: broadcast
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 广播
- en: concurrent messages could be delivered in commutativity
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 同时的消息可能以可交换性传递
- en: any order
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 任何顺序
- en: reliable
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的
- en: no ordering guarantee with no duplicate
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 没有顺序保证没有重复的
- en: Deterministic, all updates
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 决定性，所有更新
- en: broadcast
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 广播
- en: messages
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 消息
- en: commutativity
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 可交换性
- en: best-effort
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 最大努力
- en: best effort, no delivery guarantee
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 尽力而为，没有交付保证
- en: Deterministic, commutative,
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性的，可交换的，
- en: broadcast
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 广播
- en: idempotent, and tolerates message
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等，并容忍信息
- en: loss
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 丢失
- en: Now let’s explore some fundamental results in distributed computing which
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探讨一些分布式计算中的基本结果
- en: underpins distributed protocols and algorithms.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 支撑分布式协议和算法的基础。
- en: '**Fundamental Results**'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本结果**'
- en: In distributed computing, there are many fundamental results that have been
    reported
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算中，有许多基本结果已经报道
- en: by researchers. These fundamental results provide the foundation on which the
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 由研究人员。这些基本结果为
- en: distributed computing paradigm stands. Most interesting of these are impossibility
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算范例立足的地方。其中最有趣的是不可能性
- en: results.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 结果。
- en: '**Impossibility Results**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可能性结果**'
- en: Impossibility results provide us an understanding of whether a problem is solvable
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能性结果为我们提供了问题是否可解的理解
- en: or not and the minimum resources required to do so. If a problem is unsolvable,
    then
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 或者最小的资源来做到这一点。如果一个问题是解不出来的，那么
- en: these results provide a clear understanding why a specific problem is unsolvable.
    If
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果清楚地说明了为什么特定问题是不可能解决的。如果
- en: an impossibility result is proven, then no further research is necessary on
    that, and
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 如果证明了不可能性结果，那么对此不需要进一步的研究，而
- en: researchers can focus their attention on other problems or to circumvent these
    results
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员可以将注意力集中在其他问题上或规避这些结果
- en: somehow. These results show us that certain problems are unsolvable unless sufficient
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上。这些结果向我们展示了除非满足条件，否则某些问题是不可解的
- en: resources are provided. In other words, they show that certain problems cannot
    be
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的资源。换句话说，它们表明某些问题无法
- en: computed if resources are insufficient. There are problems that are outright
    unsolvable,
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源不足，则计算可能并且也可以。有些问题是根本无法解决的
- en: '147'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '147'
- en: Chapter 3 DistributeD Consensus
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: and some are solvable only if given enough resources. The requirement of minimum
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 有的问题只有在给定足够的资源时才能解决。最低
- en: available resources to solve a problem is known as **lower bound results**.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题所需的可用资源被称为**下限结果**。
- en: In order to prove that some problems cannot be solved, it is essential to define
    a
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明有些问题无法解决，定义一个
- en: system model and the class of allowable algorithms. Some problems are solvable
    under
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 系统模型和允许算法的类。一些问题在下面是可解的
- en: one model but not in others. For example, consensus is unsolvable under asynchronous
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型中但在其他模型中不会。例如，在异步条件下共识是无法解决的
- en: network assumptions but is solvable under synchronous and in partially synchronous
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 网络假设但在同步和部分同步中是可以解决的
- en: networks.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。
- en: One of the most fundamental results in distributed computing is how many nodes/
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布计算中最基本的问题之一是有多少节点/
- en: processes are required to tolerate crash only and Byzantine faults.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的过程只是为了容忍崩溃和拜占庭故障。
- en: '**Minimum Number of Processes**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小进程数**'
- en: It has been proven that a certain minimum number of processes is required to
    solve
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 已经证明解决问题需要一定数量的最小过程
- en: consensus. If there is no failure, then consensus (agreement) is achievable
    in both
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。如果没有故障，那么一致性（协议）在两方面都可以实现
- en: synchronous and asynchronous models. Consensus is not possible in asynchronous
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 同步和异步模型。共识在异步中是不可能的
- en: systems, but in synchronous systems under a crash failure model and Byzantine
    failure
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 系统，但在崩溃故障模型下的同步系统和拜占庭故障
- en: model, consensus can be achieved. However, there is a lower bound on the ratio
    of fault
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 模型，可以实现共识。然而，故障率有一个下限
- en: processes. Consensus can only be achieved if less than one-third of the processors
    are
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 过程。只有少于处理器三分之一的情况下才能得到共识
- en: Byzantine.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭。
- en: Lamport showed that when faulty nodes do not exceed one-third, then honest nodes
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport表明，当故障节点不超过三分之一时，那么诚实节点
- en: can always reach consensus.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可以达成共识。
- en: '**Crash Failure**'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '**崩溃故障**'
- en: To achieve crash fault tolerance, the tight lower bound is N => 2F + 1, where
    F is the number of failed nodes. This means that a minimum of three processes
    are required, if
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现崩溃容错，紧密的下限是N => 2F + 1，其中F是故障节点的数量。这意味着如果
- en: one crash-fails to achieve crash fault tolerance. Consensus is impossible to
    solve if n <=
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个崩溃故障以实现崩溃容错。如果n <=
- en: 2f in crash fault–tolerant settings.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障容忍设置中的2f。
- en: '**Byzantine Failure**'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭故障**'
- en: To achieve Byzantine fault tolerance, the tight lower bound is N >= 3F + 1,
    where F is the number of failed nodes. This means that a minimum of four nodes
    are required, if one
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现拜占庭容错，紧密的下限是N >= 3F + 1，其中F是故障节点的数量。这意味着如果有一个最小的四个节点是必需的
- en: fails arbitrarily to achieve Byzantine fault tolerance.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 随意发生崩溃以实现拜占庭容错。
- en: No algorithm can solve a consensus problem if n<=3f, where n are nodes and f
    are
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n<=3f，那么没有算法可以解决共识问题，其中n是节点，f是
- en: Byzantine nodes. There is a proven tight lower bound of 3F+1 on the number of
    faulty
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭节点。有一个对故障个数的严格下限为3F+1
- en: processors.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器。
- en: '148'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '148'
- en: Chapter 3 DistributeD Consensus
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: '**Minimum Connectivity**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小连接性**'
- en: The minimum network connectivity to tolerate failures is at least 2f+1\.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍失败的最小网络连接至少为2f+1。
- en: '**Minimum Rounds**'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小轮数**'
- en: The minimum number of rounds required is f+1, where f can fail. This is because
    one
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的最小轮数是f+1，其中f可能会失败。这是因为一个
- en: round more than the number of failures ought to have one round failure-free,
    thus
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 轮次多于故障数量应该有一个无故障轮次，因此
- en: allowing consensus.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 允许共识。
- en: '**FLP Impossibility**'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**FLP不可能性**'
- en: The FLP impossibility result states that it is impossible to solve consensus
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: FLP不可能性结果表明，解决共识是不可能的
- en: deterministically in a message-passing asynchronous system in which at most
    one
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 在最多一个模型中以确定性地消息传递异步系统中没有算法可以解决共识。要么会有
- en: process may fail by crashing. In other words, in a system comprising n nodes
    with
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可能以崩溃的方式失败。换句话说，在一个包含n个节点的系统中，
- en: unbounded delays there is no algorithm that can solve consensus. Either there
    will be
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 无限的延迟，没有算法可以解决共识。要么会有
- en: executions in which no agreement is achieved or there will be an execution which
    does
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 执行中未达成一致或将有一个执行不会
- en: not terminate (infinite execution).
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 不会终止（无限执行）。
- en: The key issue on which the FLP impossibility result is based is that in an
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: FLP不可能性结果的关键问题是，在一个
- en: asynchronous system, it is impossible to differentiate between a crashed process
    and a
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 异步系统中，无法区分崩溃的进程和
- en: process that is simply slow or has sent a message on a slow link, and it’s just
    taking time to reach the recipient.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 进程仅仅是慢或者在一个慢速链接上发送了消息，只是需要一些时间才能到达接收者。
- en: FLP is one of the most fundamental unsolvability results in distributed computing.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: FLP 是分布式计算中最基本的不可解结果之一。
- en: FLP is named after the authors MICHAEL J. FISCHER, NANCY A. LYNCH AND
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: FLP 是以作者迈克尔·J·费舍尔、南希·A·林奇和
- en: MICHAEL S. PATERSON who reported this result in 1982 in their paper “Impossibility
    of
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·S·帕特森在 1982 年在他们的论文“分布式计算的不可能性”中报告了这个结果。
- en: Distributed Consensus with One Faulty Process.”
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个故障进程的分布式一致性。
- en: A configuration of global state C is univalent if all executions starting from
    C output
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果全局状态 C 的配置是单一值状态，那么从 C 开始的所有执行结果都是输出
- en: the same value, that is, there is only one possible output. The configuration
    is 0-valent if it results in deciding 0 and 1-valent if it results in deciding
    1\. A configuration of global state C is bivalent if there are two executions
    starting from C that output different values.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的值，也就是说，只有一个可能的输出。如果配置为 0-valent，那么决策结果为 0，如果配置为 1-valent，那么决策结果为 1。全局状态 C
    的配置如果有两个从 C 开始的执行结果输出不同的值，那么 C 是双值状态。
- en: We can visualize this in Figur[e 3-14\.](#p169)
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图[ 3-14.](#p169)中可视化这一点
- en: '149'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '149'
- en: '![](index-169_1.png)'
  id: totrans-921
  prefs: []
  type: TYPE_IMG
  zh: '![](index-169_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '***Figure 3-14\.** Univalent and bivalent configuration*'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-14.** 单一值状态和双值状态的配置*'
- en: The key idea behind FLP is that a bivalent configuration can always transition
    to
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: FLP 的关键思想是双向配置总是可以过渡到一个
- en: some bivalent configuration. As there is an initial bivalent configuration,
    it follows that there is a nonterminating execution, leading to only bivalent
    configurations.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 一些双值状态的配置。因为存在一个初始的双值状态配置，所以可以得出有一个不终止的执行，导致只有双值状态的配置。
- en: We can understand this through a scenario. Suppose you have two different sets
    of
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 对此可以通过一个场景来理解。假设你有两组不同的
- en: nodes, say set A and set B, each with five nodes. In a five-node network with
    no failures, the majority (i.e., three out of five) in each set will lead to the
    consensus. Suppose that in set A the five nodes have a proposed value of 1 {11111},
    then we know that in an
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，例如集合 A 和集合 B，每个集合都有五个节点。在没有故障的五节点网络中，每个集合中的大多数（即五分之三）都将导致一致性。假设在集合 A 中五个节点有一个建议值为
    1 {11111}，那么我们知道在一个
- en: honest environment the decision will be value 1 by all nodes. Similarly in set
    B, if the
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在诚实的环境中所有节点的决策将是值 1。同样在 B 集合中，如果
- en: initial value is 0 at all nodes {00000}, then all nodes will agree to the value
    0 in a fault-free environment. We can say the configuration, that is, global state,
    is 1-valent and 0-valent in set A and set B, respectively. However, now imagine
    a situation where not all nodes
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值是在所有节点上均为 0 {00000}，那么在无故障的环境中所有节点都将同意值 0。我们可以说在 A 集合和 B 集合中，配置即全局状态分别是 1-valent
    和 0-valent。然而，想象一下现在不是所有节点
- en: are 0 or 1, but some are 0 and some have a value of 1\. Imagine in set A, three
    nodes
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 是 0 或 1，但是一些是 0，另一些有值为 1。想象一下，在 A 集合中，三个节点
- en: are 1, and two have a value of 0, that is, {11100}. Similarly in set B, two
    nodes are 1 and three nodes are holding value 0, that is, {11000}. Note that these
    sets now only have one difference of a single node with value 1 in set A and value
    0 in set B, that is, the middle node (third element) in the set. Consensus of
    1 is reached in set A due to three out of five majority, whereas consensus 0 is
    reached in set B due to three out of five majority. Let’s call these two sets,
    configurations or global states. So now we have two configurations,
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 是 1，另外两个值为 0，即 {11100}。同样在 B 集合中，两个节点是 1，另外三个节点持有值为 0，即 {11000}。请注意，这些集合现在只有一个节点的不同值，A
    集合中为值 1，B 集合中为值 0，即两个集合中间的中间节点（第三个元素）。由于五个节点中三个节点表示的大多数，所以在 A 集合中已经达成了 1 的决议，而在
    B 集合中由于同样的大多数达成了 0 的决议。我们称这两个集合为配置或者全局状态。所以现在我们有两个配置，
- en: one reaching consensus of 1 and the other 0\. So far so good, but imagine now
    that one
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个达成了 1 的一致性，另一个达成了 0 的一致性。到目前为止一切顺利，但是现在想象一下，如果一个
- en: node fails, and it is that middle node which is the only difference between
    these two sets.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 节点出现故障，而且正是这个中间节点是这两个集合的唯一区别。
- en: If the middle node is failed from both sets A and B, they become {1100} each,
    which
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中间节点同时从 A 和 B 集合中失败，它们各自变为 {1100}，其中
- en: means that both sets are now indistinguishable from each other implying that
    they both
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着这两个集合现在无法从彼此中辨别，暗示着它们两者都
- en: can reach the same consensus of either 0 or 1 depending on the availability
    of the third
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于第三个节点的可用性，可以达成相同的0或1的共识
- en: element (middle node). This also means that one of these sets can reach both
    consensus
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 元素（中间节点）。这也意味着这些集合中的一个可以达成共识
- en: decisions, 0 or 1, depending on the availability of node 3\.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 决定，0或1，取决于第3个节点的可用性。
- en: '150'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '150'
- en: Chapter 3 DistributeD Consensus
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: Now imagine that the default value of all nodes is 0, and now with a failed
    (removed)
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，所有节点的默认值都是0，现在通过一个失败的（被移除的）
- en: node, set A {11100} will end up reaching consensus of 0 if the middle node is
    failed,
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 节点，集合A {11100}如果中间节点出现故障，则最终达成0的共识，
- en: and it will have consensus of 1 if no node fails. This is an ambiguous situation,
    called a bivalent configuration where consensus 0 is reached if the middle node
    holding value 1
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有节点故障，它将达成1的共识。这是一个模棱两可的情况，称为双价配置，其中如果中间节点持有值1，则达成共识0
- en: is unavailable but will reach consensus of 1 if no node fails. The situation
    is now that sets (nodes) can reach consensus of either 0 or 1 and the outcome
    is unpredictable.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 是不可用的，但如果没有节点故障，它将达成1的共识。现在的情况是集合（节点）可以达成0或1的共识，结果是不可预测的。
- en: It is proven that this ambiguous situation of bivalent initial configuration
    can
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 证明了这种双价初始配置的模棱两可情况可以
- en: always exist in case of even a single failure, and secondly it can always lead
    to another ambiguous situation. In other words, an initial bivalent configuration
    can always
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有单个故障，始终存在，并且其次总是可能导致另一种模棱两可的情况。换句话说，在任何情况下都可以始终存在一个初始双价配置
- en: transition to another bivalent configuration, hence the impossibility of consensus
    as no
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 转换到另一个双价配置，因此在异步情况下不可能达成一致。
- en: convergence on a univalent (either 0-valent or 1-valent) is possible.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛到单价（0价或1价）是可能的。
- en: There are two observations which lead to FLP impossibility results. First, there
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个观察结果导致FLP的不可能性。首先，有
- en: always exists at least one bivalent initial configuration in any consensus algorithm
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一致性算法中始终存在至少一个双价初始配置
- en: working in the presence of faults. Second, a bivalent configuration can always
    transition to another bivalent configuration.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障存在的情况下工作。其次，双价配置总是能够转换到另一个双价配置。
- en: The FLP result concludes that in asynchronous systems, first there is a global
    state
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: FLP结果得出结论，在异步系统中，首先存在一个全局状态
- en: (configuration) where the algorithm cannot decide, and there always will be
    a scenario
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: （配置）在算法无法决定的地方，并且总会有一个场景
- en: where the system is inconclusive. In other words, there is always an admissible
    run
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统无法得出结论的情况下。换句话说，总是有一个可接受的运行
- en: which always remains in an indecisive state under asynchrony.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在不确定状态下保持不太可能达成共识。
- en: State machine replication under asynchrony is also prone to FLP impossibility
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 异步状态机复制也容易出现FLP不可能性
- en: limitation. Blockchain networks are also subject to FLP impossibility results.
    Bitcoin,
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 限制。区块链网络也受到FLP不可能性的影响。比特币，
- en: Ethereum, and other blockchain networks would have not been possible to build
    if FLP
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊，以及其他区块链网络如果没有引入一定程度的同步就不可能构建
- en: impossibility wasn’t circumvented by introducing some level of synchrony.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 引入同步的某种程度来规避FLP的不可能性。
- en: Many efforts have been proposed to somehow circumvent the FLP impossibility.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了许多努力来绕过FLP的不可能性。
- en: This circumvention revolves around the use of oracles. The idea is to make an
    oracle
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规避围绕着使用oracle。这个想法是使一个oracle
- en: available to the distributed system to help solve a problem. An **oracle** can
    be defined as a service or a black box that processes (nodes) can query to get
    some information
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于分布式系统以帮助解决问题。**Oracle**可以定义为处理（节点）可以查询以获取一些信息的服务或黑匣子
- en: to help them decide a course of action. In the following, we introduce some
    common
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助它们决定行动的。接下来，我们介绍一些常见的
- en: oracles that provide enough information to distributed algorithms to solve a
    problem,
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 提供足够信息给分布式算法以解决问题的oracle，
- en: which might be unsolvable otherwise. We can use oracles to facilitate solving
    consensus
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 否则可能无法解决的限制问题。我们可以使用oracle来促进解决共识
- en: problems in distributed systems.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的问题。
- en: The key ideas behind the circumvention of FLP impossibility are based around
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕FLP不可能性的规避的关键思想基于
- en: sacrificing asynchrony and determinism. Of course, as we have learned, deterministic
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 牺牲了异步和确定性。当然，正如我们所学到的，确定性
- en: consensus is not possible under asynchrony even if one process crash-fails;
    therefore,
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 协议不可能在异步性下即使一个进程崩溃; 因此
- en: the trick is to slightly sacrifice either asynchrony or determinism, just enough
    to get to a point to reach a decision and terminate.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是略微牺牲异步性或确定性，刚好足够达到达成决定并终止的地步。
- en: '151'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '151'
- en: Chapter 3 DistributeD Consensus
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: 'Now we discuss some techniques:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们讨论一些技术：
- en: • Random oracles
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: • 随机神谕
- en: • Failure detectors
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: • 失败探测器
- en: • Synchrony assumptions
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: • 同步假设
- en: • Hybrid models
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: • 混合模型
- en: '**Synchrony Assumptions**'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步假设**'
- en: Under the synchrony assumption, assumptions about timing are introduced in the
    model.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步假设下，在模型中引入了关于时间的假设。
- en: Remember, we discussed partial synchrony earlier in this chapter and the first
    chapter.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在本章和第一章中我们讨论了部分同步。
- en: Partial synchrony is a technique that allows solving consensus by circumventing
    FLP
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步是一种通过规避FLP进行共识解决的技术
- en: impossibility. Under the partial synchrony model, asynchrony is somewhat forfeited
    to
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能性。在部分同步模型下，异步性在一定程度上被牺牲以
- en: introduce some timing assumptions that allow for solving the consensus problem.
    Similarly, under the eventual synchrony model, assumptions are made that the system
    is eventually
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 引入一些时间假设，允许解决共识问题。同样，在最终同步模型下，假设系统最终
- en: synchronous after an unknown time called global stabilization time (GST). Another
    timing
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 全局稳定时间（GST）之后同步。另一个时间
- en: assumption is the weak synchrony which assumes that the delays remain under
    a certain
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是弱同步性，假设延迟保持在某个特定值以下
- en: threshold and do not grow forever. Such timing assumptions allow a consensus
    algorithm to decide and terminate by assuming some notion of time (synchrony).
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值并且不会永远增长。这种时间假设允许共识算法通过假设某种时间概念（同步）来决定和终止。
- en: '**Random Oracles**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机神谕**'
- en: Random oracles allow for the development of randomized algorithms. This is where
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 随机神谕允许开发随机算法。这就是
- en: determinism is somewhat sacrificed in favor of reaching an agreement probabilistically.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性在一定程度上为了以概率的方式达成一致而牺牲。
- en: The advantage of this approach is that there are no assumptions made about timing,
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于对时间没有任何假设，
- en: but the downside is that randomized algorithms are not very efficient. In randomized
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 但是缺点是随机算法效率不太高。在随机化
- en: consensus algorithms, one of the safety or liveness properties is changed to
    a
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法，其中安全性或存活性属性被改变为
- en: nondeterministic probabilistic version. For example, the liveness property becomes
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性概率版本。例如，存活性属性变为
- en: '• **Liveness**: Each correct process eventually decides with high'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: • **存活性**：每个正确的进程最终都会做出决策的概率很高
- en: probability.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 概率。
- en: This addresses FLP impossibility in the sense that FLP impossibility means in
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了FLP不可能性，FLP不可能性意味着
- en: practice that there are executions in the consensus that do not terminate. If
    the
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在共识中存在一些不终止的执行。如果
- en: 'termination is made probabilistic, it can “circumvent” the impossibility of
    consensus:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 终止被赋予概率，可以“规避”共识的不可能性：
- en: '• **Agreement**: All correct processes eventually agree on a value with'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: • **协议**：所有正确的进程最终会就一个值达成一致
- en: probability 1\.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 概率1。
- en: '152'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '152'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: Usually, however, the liveness property is made probabilistic instead of safety
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存活性属性是以概率的形式而不是安全性的形势进行
- en: properties of agreement, validity, and integrity. Sacrificing a safety property
    in favor of a liveness (termination) property is usually not advisable.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，有效性和完整性的属性。通常不建议为了存活性（终止）属性而牺牲安全性属性。
- en: The core technique in randomized algorithms is something known as “coin flip.”
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 随机算法中的核心技术是所谓的“硬币翻转”。
- en: Coin tossing or coin flips can be divided into two types.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 投币或硬币翻转可以分为两种类型。
- en: A local coin is where the state of the processor advances from the current state
    to the
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 本地硬币是指处理器状态从当前状态向前推进到
- en: next, which is chosen as per the probability distribution of the algorithm.
    This is usually implemented as a random bit generator, which returns zero or one
    (head or tail) with
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据算法的概率分布选择，这通常实现为一个随机位生成器，它以0或1（正面或反面）的形式返回
- en: equal probability.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的概率。
- en: Shared coin or global coin algorithms make use of these local coins to build
    a global
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 共享硬币或全局硬币算法利用这些本地硬币来构建全局
- en: coin. The requirement here is to provide the same coin value to all honest processes
    and
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币。这里的要求是为所有诚实的进程提供相同的硬币价值，并且
- en: achieve an agreement.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 达成一致。
- en: Local coin algorithms terminate in an exponential number of communication steps,
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 本地硬币算法在指数数量的通信步骤中终止，
- en: whereas shared coin algorithms terminate in a constant number of steps.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 而共享硬币算法在恒定数量的步骤中终止。
- en: There are pros and cons of sacrificing determinism and employing randomization.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 牺牲确定性和使用随机化有利有弊。
- en: One of the key advantages is that there are no timing assumptions required.
    However,
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 关键优势之一是不需要时间假设。然而，
- en: the downside is that the number of rounds is considerably higher, and cryptography
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 不利的一面是回合数明显较高，并且密码学
- en: required to introduce randomization could be computationally expensive.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 引入随机化可能需要计算代价很高。
- en: Randomized algorithms for Byzantine consensus first appeared in Ben-Or and
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭共识的随机算法最早出现在本-奥尔和
- en: Rabin’s work in 1983, which we will discuss along with some others in Chapt[er
    6](https://doi.org/10.1007/978-1-4842-8179-6_6).
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 拉宾在1983年的作品中首次出现，我们将在第[6](https://doi.org/10.1007/978-1-4842-8179-6_6)章讨论。
- en: '**Hybrid Models**'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合模型**'
- en: In a hybrid model approach to circumvent FLP impossibility, a combination of
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 在绕过FLP不可能性的混合模型方法中，引入了一种组合
- en: randomization and failure detectors is used.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化和故障检测器的使用。
- en: Wormholes are extensions in a system model with stronger properties as compared
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 虫洞是在比较强的属性下的系统模型中的扩展
- en: to other parts of the system. Usually, it is a secure, tamper-proof, and fail-silent
    trusted hardware which provides a way for processes to correctly execute some
    crucial steps
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 到系统的其他部分。通常，这是一种安全的、防篡改的、失败静默的受信任硬件，它为进程提供了正确执行一些关键步骤的方式
- en: of the protocol. Various wormholes have been introduced in the literature such
    as
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。文献中已经介绍了各种虫洞，如
- en: attested append-only memory, which forces replicas to commit to a verifiable
    sequence
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 证明追加式只读存储器，迫使副本承诺对可验证的序列
- en: of operations. The trusted timely computing base (TTCB) was the first wormhole
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 的操作。受信任的及时计算基地（TTCB）是第一个虫洞
- en: introduced for consensus supported by wormholes.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 用于通过虫洞支持共识。
- en: '153'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '153'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式一致性
- en: '**Failure Detectors**'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障检测器**'
- en: This intuition behind failure detectors is that if somehow we can get a hint
    about the
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器背后的这种直觉是，如果我们可以得到一些关于
- en: failure of a process, then we can circumvent FLP impossibility. Remember the
    FLP
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程的失败，那么我们可以绕过FLP不可能性。记住FLP
- en: impossibility result suggests that it is impossible to distinguish between a
    crashed
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能性结果表明，不可能区分已崩溃的
- en: process and simply a very slow one. There is no way to find out, so if somehow
    we can
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 过程和一个非常缓慢的过程。没有办法找出来，所以如果我们可以
- en: get an indication that some process has failed, then it would be easier to handle
    the
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 得到一个提示，有些进程已经失败了，那么处理将更容易
- en: situation. In this setting, asynchrony is somewhat sacrificed because failure
    detectors
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 情况。在这种情况下，非同步性在某种程度上受到牺牲，因为故障检测器
- en: work based on heartbeats and timeout assumptions. Failure detectors are added
    as an
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 基于心跳和超时假设的工作。故障检测器被添加为一个
- en: extension to the asynchronous systems.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 到异步系统的扩展。
- en: A failure detector can be defined as a distributed oracle at each process that
    gives
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义故障检测器为每个进程的分布式神谕，给予
- en: hints about (suspects) whether a process is alive or has crashed. In a way,
    failure
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 关于（嫌疑）一个进程是否存活或已崩溃的提示。在某种程度上，故障
- en: detectors encapsulate timeout and partial synchrony assumptions as a separate
    module.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器封装了超时和部分同步假设作为一个独立模块。
- en: 'There are two categories of properties that define failure detectors:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 定义故障检测器的两类属性：
- en: • **Completeness** implies that a failure detector will eventually detect
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: • **完整性**意味着故障检测器最终会检测到
- en: faulty processes. This is a liveness property.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 有缺陷的过程。这是一个活力性质。
- en: • **Accuracy** implies that a failure detector will never suspect a correct
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: • **准确性**意味着故障检测器不会怀疑正确
- en: process as failed. This is a safety property.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 过程失败了。这是一个安全性质。
- en: Based on the preceding two properties, eight classes of failure detectors have
    been
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前两个属性，已经有了八种故障检测器类别。
- en: proposed by Chandra and Toueg in their seminal paper “Unreliable Failure Detectors
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 切拉和托耶格在他们开创性的论文“不可靠故障检测器”中提出了
- en: for Reliable Distributed Systems.” It is also possible to solve consensus by
    introducing a weak unreliable failure detector. This work was also proposed by
    Chandra and Toueg.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 用于可靠分布式系统。”也可以通过引入一个弱不可靠的故障检测器来解决共识问题。这项工作也是由Chandra和Toueg提出的。
- en: The ability of a failure detector to accurately suspect failure or liveness
    depends
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器准确怀疑故障或活动性的能力取决于
- en: on the system model. A failure detector is usually implemented using a heartbeat
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统模型实现故障检测器通常使用心跳
- en: mechanism where heartbeat messages are exchanged between processes, and if
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 通过心跳消息在进程之间交换，并且如果
- en: these messages are not received by some processes for some time, then failure
    can be
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息有一段时间没有被一些进程接收，那么故障可能会被
- en: suspected. Another method is to implement a timeout mechanism which is based
    on
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 被怀疑。另一种方法是实现基于
- en: worst-case message round-trip time. If a message is not received by a process
    in the
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况下的消息往返时间。如果一个进程没有收到
- en: expected timeframe, then timeout occurs, and the process is suspected failed.
    After this, if a message is received from the suspected process, then the timeout
    value is increased, and the process is no longer suspected failed. A failure detector
    using a heartbeat
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期的时间范围内，如果超时发生，则进程被怀疑失败。在此之后，如果从被怀疑的进程接收到消息，则超时值会增加，进程就不再被怀疑失败。一种使用心跳的故障检测器
- en: mechanism is shown in Figure [3-15\.](#p174)
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 机制显示在图[3-15\.](#p174)
- en: '154'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '154'
- en: '![](index-174_1.png)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![](index-174_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章分布式共识
- en: '***Figure 3-15\.** Failure detector using heartbeats*'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '***图3-15\.** 使用心跳的故障检测器*'
- en: In Figur[e 3-15](#p174), process P1 sends a regular heartbeat message “Alive”
    to process P2\.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-15](#p174)中，进程P1向进程P2发送常规的心跳消息“Alive”。
- en: 'There are two parameters in the failure detector: a heartbeat interval H and
    a timeout'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器中有两个参数：心跳间隔H和超时
- en: value T. Process P1 is suspected if P2 does not receive any heartbeat messages
    from
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 值T的超时机制。如果P2没有从P1接收到任何心跳消息，则怀疑P1进程。
- en: P1 for a time period longer than T. In the diagram, message 4 did not arrive
    within the
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: P1超过T的时间段。在图中，消息4没有在
- en: timeout value T; therefore, P2 now suspects P1 of failure, due to timeout. If
    P2 starts to receive any message (either heartbeat or any other protocol, application
    message) from
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 超时值T；因此，P2现在怀疑P1发生故障，超时了。如果P2开始收到任何消息（无论是心跳还是任何其他协议、应用消息）来自
- en: P1, then P2 no longer suspects process P1\. This is shown from message 5 onward
    in the
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: P1，然后P2就不再怀疑P1进程。这在第5条消息之后的信息中表示在
- en: diagram. Timer T starts again (resets) as soon as P2 receives a message from
    P1\.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 图表。当P2接收到来自P1的消息时，计时器T会重新开始（重置）。
- en: Failure detectors are practical only under synchronous and partially synchronous
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器只在同步和部分同步情况下才实用
- en: system models. In asynchronous systems, failure detectors cannot achieve completeness
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 系统模型中。在异步系统中，故障检测器无法实现完整性
- en: and accuracy at the same time. However, we may achieve completeness independently
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 并同时准确。但是，我们也可以单独实现完整性
- en: by immediately (and naively) suspecting all processes have crashed. After that,
    if some
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 立即（并幼稚地）怀疑所有进程都已崩溃。之后，如果有一些
- en: process fails, then the suspicion will be true, fulfilling the completeness
    property.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 进程失败，然后怀疑将为真，满足完整性属性。
- en: Similarly, accuracy can be achieved by just not suspecting any processes, which
    of
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过不怀疑任何进程而实现准确性
- en: course is quite useless, but presumably achieves accuracy. In other words, perfect
    failure detectors are possible in synchronous systems, whereas no perfect failure
    detector is
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 当然是相当无用的，但可能达到准确性。换句话说，在同步系统中可能存在完美的故障检测器，而在异步系统中没有完美的故障检测器
- en: possible in asynchronous systems. In a way, we encapsulate partial synchrony
    and
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步系统中是不可能的。在某种程度上，我们包含了部分同步和
- en: timeouts in failure detectors to achieve failure detection capability in our
    system.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器中的超时以实现系统中的故障检测能力。
- en: Another advantage of failure detectors is that all the timeout mechanics are
    localized
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器的另一个优点是所有的超时机制都是本地化的
- en: within the failure detector module, and the program is free to perform other
    tasks. In the case where no failure detector module is present, the program ends
    up waiting infinitely
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障检测器模块内部，并且程序可以自由执行其他任务。在没有故障检测器模块的情况下，程序最终会无限等待
- en: long for an expected incoming message from a crashed process. We can understand
    this
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间等待来自崩溃进程的预期传入消息。我们可以理解这一点
- en: with a comparison. For example, a blocking receive operation “*Wait for message
    m from*
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 进行对比。例如，阻塞接收操作“*等待来自消息 m 的*”
- en: '155'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '155'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '*process p”* becomes *(wait for message m from process p) or (suspect p of
    failure)*. Now you can see the blocking program becomes nonblocking, and there
    is now no infinite'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程 p”* 变为 *(等待来自进程 p 的消息) 或 (怀疑 p 发生故障)*。现在您可以看到阻塞程序变成了非阻塞程序，并且现在没有无限'
- en: waiting; if the p is suspected, then it’s added to the suspected list, and the
    program
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 等待；如果怀疑 p，则将其添加到怀疑列表，并且程序
- en: continues its operation, whatever that might be.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 持续其操作，无论是什么。
- en: Now let’s look at the properties of strong and weak completeness and accuracy.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看强和弱完备性以及准确性的属性。
- en: '**Strong Completeness**'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '**强完备性**'
- en: This property requires that eventually every crashed process is permanently
    suspected
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性要求最终每个崩溃的进程都将被永久怀疑
- en: by every correct process.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 由每个正确的进程。
- en: '**Weak Completeness**'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱完备性**'
- en: The property requires that eventually each crashed process is permanently suspected
    by
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性要求最终每个崩溃的进程都将被永久怀疑
- en: some correct process.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 一些正确的进程。
- en: '**Strong Accuracy**'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '**强准确性**'
- en: This property denotes that a process is never suspected until it crashes (before
    it crashes) by any correct process.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性表示一个进程在任何正确的进程之前都不会被怀疑，直到它崩溃（在崩溃之前）。
- en: '**Weak Accuracy**'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱准确性**'
- en: This property describes that some correct process is never suspected by any
    correct
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性描述没有一个正确的进程会被任何正确的进程怀疑
- en: process.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。
- en: '**Eventual Strong Accuracy**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终强准确性**'
- en: This property suggests that after some time, correct processes do not suspect
    any correct processes any longer.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性表明经过一段时间，正确的进程不再怀疑任何正确的进程。
- en: '**Eventual Weak Accuracy**'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终弱准确性**'
- en: This property implies that after some time, some correct process is not suspected
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性意味着经过一段时间，不会再怀疑任何一个正确的进程
- en: anymore by any correct process.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正确的进程。
- en: '156'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '156'
- en: '![](index-176_1.png)'
  id: totrans-1107
  prefs: []
  type: TYPE_IMG
  zh: '![](index-176_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: We can visualize strong and weak completeness in the diagram shown in Figur[e
    3-16\.](#p176)
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图 3-16\.[（#p176）](#p176)中显示的图表中可视化强和弱完备性。
- en: '***Figure 3-16\.** Strong completeness vs. weak completeness*'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-16\.* 强完备性 vs 弱完备性*'
- en: Now we discuss eight classes of failure detectors. There are four classes of
    failure
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们讨论八种故障检测器类。有四种故障
- en: detectors which provide strong completeness. The first two failure detectors
    work under
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 提供强完备性的检测器。前两个故障检测器在
- en: synchronous systems, namely, perfect detector P and strong detector S. The other
    two work under partially synchronous models, namely, eventually perfect detector
    (diamond P) and
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 同步系统，即，完美检测器 P 和强检测器 S。其余两个在部分同步模型下工作，即，最终完美检测器（钻石 P）和
- en: eventually strong detector (diamond S).
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终强检测器（钻石 S）。
- en: We describe these classes now, first with strong completeness.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们描述这些类，首先是强完备性。
- en: '**Perfect Failure Detector P**'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**完美故障检测器 P**'
- en: This type of failure detector satisfies strong completeness and strong accuracy
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的故障检测器满足强完备性和强准确性
- en: properties. P cannot be implemented in asynchronous systems. This is because
    strong
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 属性。P 不能在异步系统中实现。这是因为强
- en: completeness and accuracy cannot be achieved for P in asynchronous systems.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步系统中无法为 P 实现完整性和准确性。
- en: '**Strong Failure Detector S**'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '**强故障检测器 S**'
- en: This failure detector has weak accuracy and strong completeness.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 此故障检测器具有弱准确性和强完备性。
- en: '**Eventually Perfect Failure Detector – Diamond P**'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终完美故障检测器 - 钻石 P**'
- en: This class of FDs satisfies strong completeness and eventual strong accuracy.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这类 FDs 满足强完备性和最终强准确性。
- en: '157'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '157'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '**Eventually Strong Failure Detector – Diamond S**'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终强故障检测器 - 钻石 S**'
- en: This class of FDs satisfies strong completeness and eventual weak accuracy.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 这类 FDs 满足强完备性和最终弱准确性。
- en: There are also four classes of failure detectors which provide weak completeness.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有四类故障检测器提供弱完备性。
- en: Detector Q and weak detector W work under synchronous models. Two other detectors,
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器 Q 和弱检测器 W 在同步模型下工作。另外两个检测器，
- en: eventually detector Q (diamond Q) and eventually weak detector (diamond W),
    work
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 最终检测器 Q（钻石 Q）和最终弱检测器（钻石 W）工作
- en: under partial synchrony assumptions.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分同步假设下。
- en: We describe these as follows.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在描述如下。
- en: '**Weak Failure Detector W**'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱故障检测器 W**'
- en: This type satisfies weak completeness and weak accuracy properties.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型满足弱完备性和弱准确性属性。
- en: '**Eventually Weak Failure Detector (Diamond W)**'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终弱故障检测器（钻石 W）**'
- en: This type satisfies weak completeness and eventual weak accuracy properties.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型满足弱完备性和最终弱准确性属性。
- en: '**Detector Q or V**'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测器 Q 或 V**'
- en: This type satisfies weak completeness and strong accuracy.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型满足弱完备性和强准确性。
- en: '**Eventually Detector Q (Diamond Q) or Diamond V**'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终检测器 Q（钻石 Q）或钻石 V**'
- en: This type satisfies weak completeness and eventual strong accuracy.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型满足弱完备性和最终强准确性。
- en: Figur[e 3-17 sho](#p178)ws all this in summary.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17 显示了这一切的摘要。
- en: '158'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '158'
- en: '![](index-178_1.png)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
  zh: '![](index-178_1.png)'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: '***Figure 3-17\.** Failure detector classes*'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 3-17.** 故障检测器类*'
- en: The properties of failure detectors fundamentally revolve around the idea of
    how
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测器的属性基本上围绕着如何的想法
- en: fast and correctly a failure detector detects faults while avoiding false positives.
    A perfect failure detector will always correctly detect failed processes, whereas
    a weak failure
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 快速正确地故障检测器检测到故障，同时避免错误的阳性。完美的故障检测器将始终正确地检测到失败的进程，而弱故障
- en: detector may only be able to detect very few or almost no faults accurately.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器可能只能准确地检测到很少或几乎没有故障。
- en: '**Leader Elector Failure Detector**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者选举故障检测器**'
- en: Sometimes, we are not interested in finding out if processes have failed but
    just that if a single process is correct. In this approach of failure detection,
    instead of suspecting other processes a single process is considered a leader.
    This failure detector can be seen as a leader election algorithm called the Omega
    *Ω* failure detector. Initially, the leader elector can be unreliable and may
    elect a faulty process or can cause different processes to trust different leaders.
    We can define this FD as a failure detector where eventually every
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不关心进程是否已失败，而只是一个单个进程是否正确。在这种故障检测方法中，不是怀疑其他进程，而是认为一个单个进程是领导者。该故障检测器可以看作是一种称为
    Omega *Ω* 故障检测器的领导者选举算法。最初，领导者选举者可能是不可靠的，并可能选举出一个故障进程或导致不同的进程信任不同的领导者。我们可以将此 FD
    定义为最终每个
- en: nonfaulty process elects the same nonfaulty leader process.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 非故障进程选出相同的非故障领导进程。
- en: '159'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '159'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式一致性
- en: As we saw earlier, in other failure detectors there is a component called *suspect*
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在其他故障检测器中有一个称为 *suspect*
- en: which contains a set of process IDs that the failure detector has suspected
    as faulty;
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一组故障检测器怀疑为故障的进程 ID；
- en: however, in leader elector *Ω*, there is a component called *trust* which contains
    a single process ID of the elected leader.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在领导者选举 *Ω* 中，有一个包含选定领导者的单个进程 ID 的 *trust* 组件。
- en: '**Solving Consensus Using Failure Detectors**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用故障检测器解决共识**'
- en: If we have a perfect failure detector, we can easily solve consensus in both
    synchronous
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有完美的故障检测器，我们可以轻松解决同步和
- en: and asynchronous models. However, in asynchronous systems, P cannot be
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 和异步模型。但在异步系统中，P 不能
- en: implemented due to too strong accuracy and completeness requirements for this
    model.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对该模型的准确性和完整性要求太强，无法实现。
- en: If somehow we can implement a P in an asynchronous system to solve consensus,
    that
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在异步系统中实现 P 来解决共识问题
- en: would violate the FLP impossibility. Therefore, we know that no such perfect
    FD exists
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将违反 FLP 不可能性。因此，我们知道不存在这样的完美 FD
- en: which can solve consensus in a purely asynchronous system. We must sacrifice
    a little
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解决纯异步系统中的共识。我们必须牺牲一点
- en: bit asynchrony and look for weaker failure detector classes which can solve
    consensus
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 比特异步，并寻找可以解决共识问题的更弱的故障检测器类。
- en: under asynchrony.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步情况下。
- en: 'Also, at this point a question arises: What is the weakest failure detector
    to solve'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 此时也会产生一个问题：什么是最弱的故障检测器可以解决
- en: consensus? The ⋄ *W* (eventually weak) is the weakest failure detector sufficient
    to solve consensus under asynchrony with a majority of correct processes.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性？*W*（最终弱）是最弱的故障检测器，足以在异步情况下以大多数正确进程解决共识问题。
- en: '**Quorums**'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '**仲裁**'
- en: A quorum can be defined as any set of majority of processes. The concept is
    related
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 仲裁可以被定义为大多数进程的任何集合。该概念与
- en: to voting among a set of objects. Quorum systems are important to ensuring the
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 对一组对象进行投票。仲裁系统对确保
- en: consistency, availability, efficiency, and fault tolerance in replicated systems.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性、可用性、效率和容错性在复制系统中。
- en: A quorum can also be thought of as a set of minimum number of processes (votes)
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个决议也可以被视为一组最小数量的进程（投票）
- en: required to decide about an operation in a distributed system. A quorum-based
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中决定一个操作需要一个基于“决议”的少数正确进程。
- en: methodology ensures consistency in a distributed system. We just learned under
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 方法确保在分布式系统中的一致性。我们刚学到在
- en: the “Replication” section that replication allows to build a fault-tolerant
    consistent
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 在“复制”部分中，复制允许构建容错一致性
- en: distributed system. Here, the question arises about how many replicas are required
    to
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统。在这里，我们关心的问题是需要多少复本
- en: decide to finally commit an update or abort.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终决定提交更新或中止。
- en: 'Mathematically, a quorum is defined as follows:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，决议规定了以下定义：
- en: A quorum is a non-empty subset of *π* = {1, 2, 3, . . . *n* }.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个决议是 *π* = {1, 2, 3，. . . *n* } 的非空子集。
- en: '160'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '160'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: 'A quorum system is defined as a set *Q* of non-empty subsets of *π* which satisfies
    the following property:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 决议系统被定义为一组 *Q* 的非空子集合 *π*，其满足以下属性：
- en: '**Quorum intersection**: ∀ *A*, *B* ∈ *Q* : *A* ∩ *B* ≠ *ϕ*'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '**决议交集**：∀ *A*，*B* ∈ *Q*：*A* ∩ *B* ≠ *ϕ*'
- en: This means that any two quorums must intersect at one or more processes. This
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任意两个决议必须在一个或多个进程处相交。这
- en: is also known as the pigeonhole principle. Moreover, this is called the **consistency**
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为抽屉原理。此外，这也被称为**一致性**
- en: property.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 属性。
- en: There must always be at least one quorum available that is not failed. This
    is the
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 必须始终有至少一个未失败的决议可用。这是
- en: '**quorum availability** property.'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**决议可用性** 属性。'
- en: Quorum systems are usually used in scenarios where a process, after broadcasting
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 决议系统通常用于进程，在广播之后
- en: its request, awaits until it has received a response from all processes that
    belong to a
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 等待它收到来自所有属于一个
- en: quorum. This way, we can address the consistency requirements of a problem.
    Quorums
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 决议。通过这种方式，我们可以解决一个问题的一致性要求。决议
- en: are usually used to achieve crash and Byzantine fault tolerance. In consensus
    algorithms, for example, a certain size of a quorum is needed to guarantee safety
    and liveness. In
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于实现崩溃和拜占庭容错。在共识算法中，例如，需要一定大小的决议来保证安全性和活跃性。在
- en: other words, algorithms based on quorums satisfy safety and liveness only if
    a quorum of
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他话语中，基于决议的算法仅在拥有决议的情况下才能满足安全性和活跃性，只有如果一个决议是
- en: correct processes can be established.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以确保有足够的正确进程。
- en: '**Crash Fault–Tolerant Quorums**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**崩溃容错决议**'
- en: To achieve crash fault tolerance in N number of crash-stop processes, Quorum
    Q is set
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 N 个 crash-stop 进程中实现崩溃容错，设置了决议 Q
- en:  *n* 
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh:  *n* 
- en: with at least
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 至少
- en: '1'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en:  2  + processes.  
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh:  2  + 进程。 
- en: For example, if n = 7, then 7
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 n = 7，则 7
- en: '1'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en:  2 + = ⌊3.5⌋ + 1 = 3 + 1 = 4
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh:  2 + = ⌊3.5⌋ + 1 = 3 + 1 = 4
- en: This means that in a network of seven nodes, at least four nodes (a quorum of
    four
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在一个有七个节点的网络中，至少要有四个节点（四个决议
- en: nodes) should be nonfaulty and available to achieve crash fault tolerance.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 节点）必须非故障且可用以实现崩溃容错。
- en: For example, if you have n replicas, out of which f may crash-stop, what Quorum
    Q
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有 n 个复本，其中 f 可能是 crash-stop，哪个决议 Q
- en: size is required to achieve liveness?
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多大的尺寸才能实现活跃性？
- en: For liveness, there must be a nonfaulty Quorum Q available where Q <= n – f.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了活跃性，必须有一个非故障的决议 Q 可用，其中 Q <= n – f。
- en: For safety, there must be any two quorums that must intersect at one or more
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，必须有任意两个决议至少相交于一个或多个
- en: processes.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。
- en: Lamport used quorums under the name of amoeba in 1978\.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport 在 1978 年使用了分布式系统的“阿米巴”名义下的决议。
- en: '161'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '161'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章 分布式共识
- en: '**Byzantine Quorums**'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭决议**'
- en: Byzantine failures are difficult to handle. Imagine if there are N nodes, out
    of which
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭失败难以处理。想象一下如果有 N 个节点，其中
- en: f number of nodes turn Byzantine. Now these f nodes can behave arbitrarily,
    and there
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: f 个节点变为拜占庭。现在这些 f 个节点可以任意行事，而且
- en: can be a case where they can vote in favor of a value and against it. They can
    make
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现他们可以赞成一个值并反对它。他们能够制造
- en: different statements to different nodes on purpose. Such a situation can cause
    even
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 有目的地向不同的节点传递不同的状态。这种情况可能导致
- en: correct nodes to have divergent states and can also lead to dead locks.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 正确节点的发散状态并且也可能导致死锁。
- en: A Byzantine quorum that can tolerate f faults has more than ( *n* + *f*)/2 processes.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以容忍 f 个错误的拜占庭决议有超过（ *n* + *f*）/2 进程。
- en: There is always an intersection of at least one correct process between two
    Byzantine
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 两个拜占庭人数中总是至少有一个正确进程的交集
- en: fault–tolerating quorums. The progress is guaranteed in Byzantine settings if
    *N* > 3 *f*. In other words, Byzantine fault tolerance requires that *f* < *n*/3\.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 故障-容忍法定人数。如果 *N* > 3 *f*，那么在拜占庭设置中保证进度。换句话说，拜占庭容错需要 *f* < *n*/3。
- en: 'For example:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '例如:'
- en: '*n* = 7, *f* =1'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* = 7，*f* =1'
- en: ( *n* + *f* )
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: ( *n* + *f* )
- en: / 2
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: / 2
- en: ( + ) / =
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: ( + ) / =
- en: 7 1 2 4
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 7 1 2 4
- en: '*ceiling* ( + + / ) ='
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '*上限* ( + + / ) ='
- en: 7 1 1 2
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 7 1 1 2
- en: '4'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Each Byzantine quorum contains more than *n* − *f*/2 honest processes. 7 − 1/2
    = > 3, so there is at least one correct process in the intersection of two Byzantine
    quorums.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 每个拜占庭法定人数包含大于 *n* − *f*/2 个诚实流程。 7 − 1/2 = > 3，所以至少有一个正确的流程在两个拜占庭法定人数的交集中。
- en: '**Read and Write Quorums**'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '**读和写法定人数**'
- en: Quorum-based protocols fundamentally rely on voting to determine whether a read
    or
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 基于法定人数的协议基本上依赖于投票来确定读取或
- en: write operation can be performed or not. There are read quorums and write quorums.
    A
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 写操作可以执行或不能执行。有读法定人数和写法定人数。A
- en: read quorum is the minimum number of replicas required to achieve an agreement
    on a
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 读法定人数是在读操作上达成一致所需的最小副本数量
- en: read operation. Similarly, a write quorum is the minimum number of replicas
    required
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 读操作。类似地，写法定人数是需要的最小副本数量
- en: to achieve an agreement on a write operation.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 实现对写操作的协议。
- en: '**Where Are We Now**'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们现在在哪里**'
- en: Based on the last more than 40 years of research in classical distributed consensus
    and
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于超过40年的研究，关于经典分布式共识和
- en: modern blockchain era protocols, we can divide consensus into two broad families.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 现代区块链时代的协议，我们可以把共识分为两大家族。
- en: '162'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '162'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: '**Classical Consensus**'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '**经典共识**'
- en: Classical consensus or traditional distributed consensus has been a topic of
    research
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 经典共识或传统的分布式共识一直是研究的课题
- en: for around 40 years now. Starting with the SIFT project and Lamport’s and many
    other
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经超过40年的时间。从SIFT项目和Lamport的以及许多其他
- en: researchers’ contributions, we now have a large body of work that deals with
    the classical distributed consensus. Protocols such as Paxos, PBFT, and RAFT are
    now a norm for
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员的贡献，现在我们有了一大堆应对经典分布式共识的作品。像Paxos、PBFT和RAFT这样的协议现在成为了一种规范。
- en: implementation in various practical systems.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种实际系统中的实施。
- en: '**Nakamoto and Post-Nakamoto Consensus**'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '**中本聪和后中本聪共识**'
- en: On the other hand, we have a family of protocols which we can call the Nakamoto
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有一类协议，我们可以称之为中本聪
- en: consensus family as this family was introduced for the first time by Satoshi
    Nakamoto,
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 共识家族，因为这个家族是由中本聪首次引入的，
- en: with Bitcoin.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币。
- en: From a blockchain perspective, both traditional and Nakamoto-style protocols
    are in
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 从区块链的角度来看，传统的和中本聪风格的协议都是
- en: use. Almost all the permissioned blockchains use variants of PBFT classical
    algorithms.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用。几乎所有的有许可的区块链都使用PBFT经典算法的变种。
- en: On the other hand, permissionless public blockchains like Ethereum and Bitcoin
    make
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，像以太坊和比特币这样的无许可公共区块链使
- en: use of Nakamoto-style (PoW) consensus algorithms. There are other classes such
    as
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 采用中本聪风格（PoW）共识算法。还有其他类别，如
- en: proof of stake and other variants, but they all were introduced after the introduction
    of Bitcoin’s proof of work in 2008\.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 证明权益证明和其他变种，但它们都是在2008年比特币工作量证明引入之后引入的。
- en: We will cover Nakamoto and post-Nakamoto-style algorithms in detail in Chapter
    [4](https://doi.org/10.1007/978-1-4842-8179-6_4).
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第[4](https://doi.org/10.1007/978-1-4842-8179-6_4)章中详细介绍中本聪和后中本聪风格的算法。
- en: '**Summary**'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered the main concepts of agreement, broadcast, replication,
    and
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了协议，广播，复制和
- en: 'consensus:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 共识：
- en: • Consensus is a fundamental problem in distributed computing.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: • 共识是分布式计算中的基本问题。
- en: • Consensus and atomic broadcast are equivalent problems. If you
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: • 共识和原子广播是等价的问题。如果你
- en: solve one, the other is solved too.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一个就解决了另一个。
- en: • There are several broadcast primitives such as best-effort broadcast,
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: • 有几种广播原语，如尽力广播，
- en: reliable broadcast, eager reliable broadcast, and total order broadcast
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠广播，热切的可靠广播和完全顺序广播
- en: with varying degrees of strictness regarding the delivery guarantees.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供保证的交货具有不同程度的严格性。
- en: • There are also probabilistic broadcast protocols that deliver messages
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: • 还有概率广播协议，它传递消息
- en: with some high probability inspired by dissemination of gossip
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 以一定的概率受到受欢迎的启发，来自传播八卦
- en: among the public.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共之间。
- en: '163'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '163'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: • Replication and state machine replication are techniques to provide
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: • 复制和状态机复制是提供的技术
- en: fault tolerance in distributed systems.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的容错性。
- en: • Quorum systems are important for ensuring the consistency,
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: • 团体系统对于确保一致性很重要，
- en: availability, efficiency, and fault tolerance in replicated systems.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 复制系统中的可用性、效率和容错性。
- en: • The last half century of research has produced two main classes of
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: • 过去半个世纪的研究产生了两种主要类别的
- en: consensus, that is, classical permissioned consensus and Nakamoto
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 共识，即，经典的许可共识和中本聪
- en: nonpermissioned consensus.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 非许可共识。
- en: • Various impossibility results have been proven in the last many
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: • 在最近的许多不可能结果中已经被证明了
- en: decades of research by researchers. Results such as FLP impossibility,
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员数十年的研究。诸如FLP不可能性等结果，
- en: requirement of a minimum number of processes, and network links
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 最少数量的进程和网络链接
- en: have been proposed and proven. These fundamental results allow
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 已被提出和证明。这些基础性结果允许
- en: researchers to focus on other problems because if something has
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员可以专注于其他问题，因为如果某事有
- en: been proven impossible, there is no value in spending time and effort
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 已被证明不可能，花时间和精力是没有价值的
- en: on trying to solve it.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 继续努力解决它。
- en: • Other research includes failure detectors which provide a means to
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: • 其他研究包括提供手段的故障检测器
- en: detect failures in a distributed system and allow processes to respond
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 检测分布式系统中的故障，并允许进程做出响应
- en: accordingly to make progress. Augmenting a distributed system
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 从而取得进展。增强分布式系统
- en: with oracles such as failure detectors, synchrony assumptions,
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如故障检测器、同步假设等
- en: randomized protocols, and hybrid protocols is a means to circumvent
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 随机协议和混合协议是规避的手段
- en: the FLP impossibility result.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: FLP不可能性结果。
- en: In the next chapter, we will cover blockchain and describe what it is and how
    we can
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍区块链，并描述其是什么以及我们如何
- en: see it in the light of what we have learned so far in this book.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 看到它是在我们迄今在这本书中学到的知识中。
- en: '**Bibliography**'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: 1\. Chandra, T.D. and Toueg, S., 1996\. Unreliable failure detectors for
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. Chandra, T.D.和Toueg, S., 1996. 用于不可靠故障检测器的
- en: reliable distributed systems. Journal of the ACM (JACM), 43(2),
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的分布式系统。ACM杂志(JACM)，43(2)，
- en: pp. 225–267\.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 页码225-267\.
- en: 2\. Ordering of events first introduced in “The Implementation of
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 事件排序首次引入于“实现
- en: Reliable Distributed Multiprocess Systems” – Lamport, L., 1978\.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的分布式多处理系统” - Lamport, L., 1978\.
- en: The implementation of reliable distributed multiprocess systems.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的分布式多处理系统的实现。
- en: '*Computer Networks (1976)*, *2*(2), pp. 95–114\.'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机网络(1976)*, *2*(2)，页码95-114\.'
- en: '164'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '164'
- en: Chapter 3 DistributeD Consensus
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章 分布式共识
- en: 3\. Pease, M., Shostak, R., and Lamport, L., 1980\. Reaching agreement
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. Pease, M., Shostak, R.和Lamport, L., 1980. 达成协议
- en: in the presence of faults. Journal of the ACM (JACM), 27(2),
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在故障的情况下。ACM杂志(JACM)，27(2)，
- en: pp. 228–234\.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 页码228-234\.
- en: '4\. Kshemkalyani, A.D. and Singhal, M., 2011\. Distributed computing:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. Kshemkalyani, A.D.和Singhal, M., 2011. 分布式计算：
- en: principles, algorithms, and systems. Cambridge University Press.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 原则、算法和系统。剑桥大学出版社。
- en: 5\. What is the weakest failure detector to solve consensus? This
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 解决共识所需的最弱故障检测器是什么？这
- en: question was answered in Chandra, T.D., Hadzilacos, V.,
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在Chandra, T.D., Hadzilacos, V.中得到了回答，
- en: and Toueg, S., 1996\. The weakest failure detector for solving
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 和Toueg, S., 1996. 解决的最弱故障检测器
- en: consensus. Journal of the ACM (JACM), 43(4), pp. 685–722\.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 共识。ACM杂志(JACM)，43(4)，页码685-722\.
- en: 6\. Wormholes were introduced in Neves, N.F., Correia, M., and
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. Wormhole是由Neves, N.F., Correia, M.和引入的
- en: Verissimo, P., 2005\. Solving vector consensus with a wormhole.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: Verissimo, P., 2005. 使用虫洞解决矢量共识。
- en: IEEE Transactions on Parallel and Distributed Systems, 16(12),
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE并行与分布式系统交易，16(12)，
- en: pp. 1120–1131\.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 页码1120-1131\.
- en: 7\. An excellent survey is Correia, M., Veronese, G.S., Neves, N.F.,
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 一个优秀的调查是Correia, M., Veronese, G.S., Neves, N.F.,
- en: and Verissimo, P., 2011\. Byzantine consensus in asynchronous
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 和Verissimo, P., 2011. 非同步的拜占庭共识
- en: 'message-passing systems: a survey. International Journal of'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 传递消息系统：一项调查。国际杂志
- en: Critical Computer-Based Systems, 2(2), pp. 141–161\.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 临界计算机系统，2(2)，页码141-161\.
- en: '165'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '165'
- en: '**CHAPTER 4**'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '**第四章**'
- en: '**Blockchain**'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链**'
- en: In this chapter, we’ll learn what a blockchain is and its various elements and
    see the
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习什么是区块链及其各个元素，并了解
- en: blockchain through the lens of distributed computing. Also, we will present
    formal
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分布式计算的视角来解释区块链。此外，我们将提出正式的
- en: definitions and properties of the blockchain. In addition, we will also introduce
    Bitcoin and Ethereum. Finally, I will introduce some blockchain use cases.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的定义和属性。此外，我们还将介绍比特币和以太坊。最后，我将介绍一些区块链的使用案例。
- en: Blockchains are fascinating because they touch many disciplines, including
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链之所以令人着迷，是因为它涉及许多学科，包括
- en: distributed computing, networking, cryptography, economics, game theory,
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算、网络、密码学、经济学、博弈论等。
- en: programming languages, and computer science.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言和计算机科学。
- en: Blockchains are appealing to people from so many different areas, including
    but not
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链对许多不同领域的人都很有吸引力，包括但不限于
- en: limited to the subjects mentioned earlier. With use cases in almost every walk
    of life,
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 仅限于前面提到的主题。几乎每个领域都有使用案例，
- en: blockchains have captured the public’s imagination and, indeed, many academics
    and
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链已经吸引了公众的想象力，事实上，许多学者和
- en: industry professionals.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 行业专业人士。
- en: The blockchain emerged in 2008 with Bitcoin, a peer-to-peer, decentralized,
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链于2008年随着比特币的出现而兴起，这是一个点对点的去中心化的
- en: electronic cash scheme that does not need any trusted third party to provide
    trust
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 电子现金方案，不需要任何可信任的第三方提供信任
- en: guarantees associated with money.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 与货币相关的担保。
- en: '**What Is Blockchain**'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是区块链**'
- en: There are many definitions of a blockchain on the Internet and many different
    books.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有很多关于区块链的定义，还有许多不同的书籍。
- en: While all those definitions are correct, and some are excellent, I will try
    to define the blockchain in my own words.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些定义都是正确的，有些是很不错的，但我会试图用自己的话来定义区块链。
- en: First, we’ll define it from a layman’s perspective and then from a purely technical
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从外行的角度定义它，然后从纯技术的角度
- en: standpoint.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 立场。
- en: '**Layman’s Definition**'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '**外行的定义**'
- en: A blockchain is a shared record-keeping system where each participant keeps
    a copy
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个共享的记录保留系统，每个参与者都保留一份副本
- en: of the chronologically ordered records. Participants can add new records only
    if they
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 按时间顺序记录。只有参与者
- en: collectively agree to do so.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 集体同意这样做时才能添加新的记录。
- en: '167'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '167'
- en: © Imran Bashir 2022
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: © Imran Bashir 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_4](https://doi.org/10.1007/978-1-4842-8179-6_4#DOI)
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: I. Bashir，*区块链共识*，[https://doi.org/10.1007/978-1-4842-8179-6_4](https://doi.org/10.1007/978-1-4842-8179-6_4#DOI)
- en: Chapter 4 BloCkChain
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章 区块链
- en: '**Technical Definition**'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术定义**'
- en: A blockchain is a peer-to-peer, cryptographically secure, append-only, immutable,
    and
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个点对点的、密码学安全的、只追加的、不可变的
- en: tamper-resistant shared distributed ledger composed of temporally ordered and
    publicly
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 防篡改、共享的分布式分类账，由按时间顺序排列和公开
- en: verifiable transactions. Users can only add new records (transactions and blocks)
    in a
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 可验证的交易。用户只能在
- en: blockchain through consensus among peers on the network.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络上的对等方达成共识来管理区块链。
- en: '**Background**'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景**'
- en: The origins of the blockchain can be found in early systems developed for the
    digital
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的起源可以追溯到早期为数字
- en: timestamping of documents. Also, the long-standing problem of creating secure
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的时间戳。此外，长期存在的问题是创建安全的
- en: electronic cash with desirable features such as anonymity and accountability
    has
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 具有匿名性和追责制的电子现金已经
- en: inspired blockchain development.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 激发了区块链的发展。
- en: Some of the key ideas that contributed to the development of the blockchain
    are
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 一些为区块链发展做出贡献的关键想法是
- en: discussed as follows.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所描述。
- en: 'Two fundamental issues need to be dealt with to create practical digital cash:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建实用的数字现金，需要解决两个根本性问题：
- en: • Accountability to prevent double-spends
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: • 追责制以防止双重支付
- en: • Anonymity to provide privacy to the users
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: • 匿名性以保护用户的隐私
- en: The question is how to resolve accountability and double-spend issues. The schemes
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何解决追责和双重支付问题。这些方案
- en: described in the following tried to address these issues and managed to achieve
    these
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所描述的试图解决这些问题，并设法实现这些
- en: properties; however, the usability was difficult, and they relied on trusted
    third parties.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 属性；然而，可用性很难，而且他们依赖于可信任的第三方。
- en: '**Digital Cash Creation Attempts**'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字现金创建尝试**'
- en: There are several attempts to create digital cash in the past. For example,
    David Chaum
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去有几次尝试创建数字现金。例如，大卫·乔姆
- en: invented blind signatures and used secret sharing mechanisms to create digital
    cash.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 发明了盲签名并使用秘密共享机制来创建数字现金。
- en: Blind signatures enabled signing without revealing what is being signed, which
    provided
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 盲签名使签名不会透露正在签名的内容，这提供了
- en: anonymity, and secret sharing allowed detection of double-spending.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名性和秘密共享允许检测双重支付。
- en: B-money is another electronic cash scheme that was invented in 1998 by Wei Dai.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: B-money是另一种电子现金方案，由魏戴于1998年发明。
- en: This original idea mentions many ideas that can be considered direct precursors
    to
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原始的想法提及了许多被认为是直接先驱的想法。
- en: Bitcoin. It was a novel idea; however, it required trusted servers. It also
    introduced
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币。这是一个新颖的想法；然而，它需要可信的服务器。它也引入
- en: possible solutions to cooperate between untraceable pseudonymous entities with
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法追踪的匿名实体之间合作可以考虑的可能解决方案
- en: a medium of exchange and a method to enforce contracts. The idea of each server
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 一种交换媒介和执行合同的方法。每个服务器的想法
- en: depositing a certain amount in a special account and using this for penalties
    and
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 存入特殊帐户的一定数量并将其用于惩罚和
- en: '168'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '168'
- en: '![](index-187_1.png)'
  id: totrans-1381
  prefs: []
  type: TYPE_IMG
  zh: '![](index-187_1.png)'
- en: Chapter 4 BloCkChain
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章区块链
- en: rewards is very close to the concept that we know as proof of stake today. Similarly,
    the idea of solving a previously unsolved computational problem is what we know
    today as
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励与今天我们所知的股权证明概念非常接近。同样，通过解决以前未解决的计算问题的想法就是我们今天所知的
- en: proof of work.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明。
- en: Another electronic cash proposal is **BitGold**, introduced by Nick Szabo. Bitgold
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个电子现金提议是**BitGold**，由尼克·萨博提出。比特金
- en: can be seen as a direct precursor of Bitcoin. The Bitgold proposal emphasized
    no
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 可视为比特币的直接前身。Bitgold提议强调没有
- en: dependence on trusted third parties and proof of work by solving a “challenge
    string.”
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于可信第三方和通过解决“挑战字符串”来进行工作证明。
- en: On the other hand, progress and development in cryptography and computer
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，密码学和计算机的进步和发展
- en: technology generally resulted in several advances and innovative applications.
    Some of
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 技术通常导致了几项进步和创新应用。其中一些
- en: these advances related to the blockchain are digital timestamping of documents,
    email
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链相关的这些进步是数字文档的时间戳、电子邮件
- en: spam protection, and reusable proof of work.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾邮件保护和可重复使用的工作证明。
- en: The work on timestamping of digital documents to create an ordered chain of
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳数字文档以创建有序链的工作技术
- en: documents (hashes) by using a timestamping service was first proposed by Haber
    and
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 通过时间戳服务对文档（哈希）进行了首次提议，由哈伯提出
- en: Stornetta. This idea is closely related to the chain of blocks in a blockchain.
    However, the timestamping service is centralized and needs to be trusted.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: Stornetta。这个想法与区块链中的块链有密切关系。然而，时间戳服务是集中的，需要受信任。
- en: The origins of proof of work based on hash functions used in Bitcoin can be
    found
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 源于比特币中使用的基于哈希函数的工作证明的起源可以在此找到
- en: in previous work by Dwork and Naor to use proof of work to thwart email spam.
    Adam
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dwork和Naor之前的工作中，使用工作证明阻止电子邮件垃圾邮件。亚当
- en: Back invented the Hashcash proof of work scheme for email spam control. Moreover,
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 后发明了用于电子邮件垃圾邮件控制的Hashcash工作证明方案。此外，
- en: Hal Finney introduced reusable proof of work for token money, which used Hashcash
    to
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: Hal Finney推出了可重复使用的令牌货币的工作证明，使用Hashcash
- en: mint a new PoW token.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 铸造新的PoW代币。
- en: Another technology that contributed to the development of Bitcoin is cryptography.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 为比特币的发展做出贡献的另一项技术是密码学。
- en: Cryptographic primitives and tools like hash functions, Merkle trees, and public
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 密码原语和工具，例如哈希函数、默克尔树和公共
- en: key cryptography all played a vital role in the development of Bitcoin. We covered
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥密码学在比特币的发展中发挥了至关重要的作用。我们涵盖了
- en: cryptography in Chapt[er 2 in detail.](https://doi.org/10.1007/978-1-4842-8179-6_2)
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章中详述密码学。](https://doi.org/10.1007/978-1-4842-8179-6_2)
- en: Figur[e 4-1 illus](#p187)trates this fusion of different techniques.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4-1说明](#p187)了不同技术的融合。
- en: '***Figure 4-1\.** Technologies leading to Bitcoin*'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '***图4-1：** 导致比特币的技术*'
- en: '169'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '169'
- en: Chapter 4 BloCkChain
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章区块链
- en: '**The First Blockchain?**'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个区块链？**'
- en: When Bitcoin was revealed, the blockchain was introduced as a base operating
    layer
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币被推出时，区块链被引入为基本操作层
- en: for Bitcoin cryptocurrency. Still operational today, this is the first public
    blockchain.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 用于比特币加密货币。至今仍在运作，这是第一个公共区块链。
- en: Soon after, the innovation started, and many different blockchains emerged –
    some for a
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，创新开始，许多不同的区块链出现—一些是为了
- en: specific purpose, some for cryptocurrencies, and quite a few for enterprise
    use cases. In the next section, we will look at different types of blockchain.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 具体用途，一些用于加密货币，还有一些用于企业用例。在下一节中，我们将看到不同类型的区块链。
- en: '**Benefits of Blockchain**'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链的益处**'
- en: Multiple benefits of blockchain technology are envisaged, and a lot has been
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 预见到区块链技术的多种益处，并且已经进行了
- en: accomplished since the invention of Bitcoin. Especially with the advent of Ethereum,
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 自比特币发明以来，已经完成了许多成就。特别是随着以太坊的出现，
- en: a programmable platform is available where smart contracts can implement any
    logic,
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可编程平台可用于实施任何逻辑的智能合同，
- en: which resulted in increased utility and paved the path for further adoption.
    Today, one
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了提高的效用，并为进一步采纳铺平了道路。今天，一个
- en: of the most talked-about applications of the blockchain, decentralized finance,
    or DeFi
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 最受关注的区块链应用之一，去中心化金融，或DeFi
- en: for short, is seen as a significant disruptor of the current financial system.
    Non-fungible tokens (NFTs) are another application that has gained explosive popularity.
    NFTs on the
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 简称，被视为当前金融系统的重大颠覆者。非同质化代币（NFT）是另一个获得了爆炸性流行的应用。NFTs 上
- en: blockchain enable tokenization of assets. Currently, there is almost 60 billion
    USD worth of value locked in the DeFi ecosystem. This huge investment is a testament
    that the
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链使资产代币化成为可能。目前，DeFi 生态系统的价值已经锁定了近600亿美元。这巨大的投资证明了
- en: blockchain has now become part of our economy. You can track this metric at
    [https://](https://defipulse.com/)
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链现在已经成为我们经济的一部分。您可以在[https://](https://defipulse.com/)
- en: '[defipulse.com/.](https://defipulse.com/)'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '[defipulse.com/.](https://defipulse.com/)'
- en: 'Now I list some of the most prominent benefits of the blockchain:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我列出区块链的一些最显着的优势：
- en: • Cost saving
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: • 成本节约
- en: • Due to streamlining of processes, transparency, and single data
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于流程简化、透明度和单一数据
- en: sharing platform which comes with security guarantees, the
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 共享平台，具有安全保证，这
- en: blockchain can result in cost saving. Also, there is no need to
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链可以造成成本节约。此外，也没有必要
- en: create separate secure infrastructure; users can use an already
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单独的安全基础设施；用户可以使用已经
- en: existing secure blockchain network with an entry-level computer
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的安全区块链网络带有入门级计算机
- en: running the blockchain software client.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 运行区块链软件客户端。
- en: • Transparency
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: • 透明度
- en: • As all transactions are public and anyone can verify the
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于所有交易都是公开的，任何人都可以验证
- en: transactions, the blockchain introduces transparency.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 交易，区块链引入了透明度。
- en: '170'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '170'
- en: Chapter 4 BloCkChain
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章 区块链
- en: • Auditability
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: • 可审计性
- en: • Due to immutable history of records, blockchains provide a
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于记录的不可变历史，区块链提供了
- en: natural platform for auditing purposes.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 审计目的的自然平台。
- en: • Speed and efficiency
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: • 速度和效率
- en: • As all parties involved in a transaction are part of the same
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: • 由于参与交易的所有各方都是同一方的一部分
- en: network, the speed of transaction dealing between multiple
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，多方之间的交易处理速度
- en: parties is increased. However, note that the transactions per
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 各方增加。不过，请注意，每笔交易
- en: second in a public blockchain are quite low, for example, three to
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共区块链上的交易速度相当低，例如，三到
- en: seven in Bitcoin; however, in consortium blockchains, it’s much
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中是七次；但是，在联合企业区块链中，它要多得多
- en: better, and with parties directly interacting with each other, it
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 更好，并且与各方直接交互，它
- en: increases the overall efficiency of the transaction.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 提高了交易的总体效率。
- en: • Security
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: • 安全
- en: • Blockchains are based on cryptographic protocols which ensure
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块链基于确保的加密协议
- en: integrity and authenticity of the blockchain, thus providing a
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的完整性和真实性，从而提供了
- en: secure platform for transactions.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的交易平台。
- en: 'There are many use cases in different industries:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 不同行业有许多用例：
- en: • Supply chain
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: • 供应链
- en: • Government
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: • 政府
- en: • Medicine/health
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: • 医药/健康
- en: • Finance
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: • 金融
- en: • IoT – Internet of Things
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: • 物联网-物联网
- en: • Trading
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: • 交易
- en: • Identity
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: • 身份
- en: • Insurance
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: • 保险
- en: Next, we discuss the different types of blockchain.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论不同类型的区块链。
- en: '171'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '171'
- en: Chapter 4 BloCkChain
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章 区块链
- en: '**Types of Blockchain**'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链的类型**'
- en: There are several types of blockchains. The original blockchain introduced with
    Bitcoin
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的区块链。最初随比特币引入的原始区块链
- en: 'is a public blockchain:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 是公共区块链：
- en: • Public blockchain or permissionless blockchain
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: • 公共或无许可区块链
- en: • Permissioned blockchain
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: • 有权限的区块链
- en: • Private blockchain
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: • 私有区块链
- en: • Consortium or enterprise blockchain
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: • 联合或企业区块链
- en: • Application-specific blockchain
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: • 特定应用区块链
- en: • Heterogeneous multichain
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: • 异构多链
- en: A **public blockchain**, as the name suggests, is a **permissionless blockchain**.
    There is no restriction on participating in the network. All that is required
    is to download
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**公共区块链**，顾名思义，是一种**无许可区块链**。参与网络没有限制。唯一需要的是下载
- en: a software client and run it to become part of the network. Usually, these types
    of
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件客户端并运行它以成为网络的一部分。通常，这些类型
- en: blockchains are used for cryptocurrencies, such as Bitcoin and Ethereum.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链用于加密货币，比如比特币和以太坊
- en: There are two types of **permissioned blockchains**. **Private blockchains**
    are in control of only one organization and are usually run within an organization.
    On the
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种**许可区块链**。**私有区块链**只由一个组织控制，通常在组织内部运行。而
- en: other hand, **consortium blockchains** or **enterprise blockchains** are permissioned
    blockchains where multiple organizations participate in the blockchain’s governance.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**财团区块链**或**企业区块链**是多个组织参与区块链治理的许可区块链
- en: Enterprises commonly use consortium chains for specific enterprise use cases.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 企业通常为特定企业用例使用财团链
- en: We can also further classify chains that stakeholders may have only developed
    for
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以进一步对利益相关者可能已经为之开发的链进行分类
- en: a single purpose. We can call them **application-specific blockchains**. For
    example, a blockchain developed only for a single type of cryptocurrency. In a
    way, Bitcoin is an
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 单一用途。我们可以称其为**特定应用区块链**。例如，一种专门用于单一加密货币的区块链。在某种程度上，比特币就是
- en: application-specific blockchain, with only one application, Bitcoin cryptocurrency.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 特定应用区块链，只有一个应用，比特币加密货币
- en: Similarly, suppose an organization runs a private blockchain for a specific
    purpose,
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，假设一个组织为特定目的运行了一个私有区块链
- en: such as an audit function. In that case, it can also be classified as an application-specific
    blockchain, as it has only been developed for a single specific purpose.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 例如审计功能。在这种情况下，它也可以被归类为特定应用区块链，因为它只用于单一特定目的
- en: However, in practice, blockchains serve as a generic platform that guarantees
    a
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，区块链作为一个通用平台，保证
- en: consistent, secure, tamper-resistant, and ordered ledger of records, making
    it suitable for a wide variety of applications. Also, depending on the design,
    multiple applications can
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 一致、安全、防篡改且有序的记录账本，使其适用于各种各样的应用。此外，根据设计，多个应用程序可以
- en: run on a single blockchain. For example, Ethereum can run different programs
    called
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个区块链上运行。例如，以太坊可以运行称为
- en: smart contracts on it, making it a general-purpose blockchain platform. A blockchain
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 在其上运行智能合约，使其成为一种通用区块链平台。区块链
- en: that has been developed for a specific single use case can be called application-specific
    blockchain, or ASBC for short.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 已为特定单一用例开发的区块链可称为特定应用区块链，或简称ASBC。
- en: '172'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '172'
- en: Chapter 4 BloCkChain
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章 区块链
- en: Blockchains are also shared data platforms where multiple organizations can
    share
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链也是多个组织可以共享数据的平台
- en: data in a tamper-resistant manner, ensuring data integrity. However, this sharing
    can
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 以防数据的完整性。然而，这种共享可以
- en: be achieved if there is only one standard blockchain, but many different blockchains
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 只有有一个标准的区块链，但有很多不同的区块链
- en: have emerged since the advent of Ethereum. This variety has resulted in a problem
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 自以太坊出现以来，不断出现了新类型的区块链。这种多样性导致了一个问题
- en: where one blockchain runs a different protocol and cannot share its data with
    another
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个区块链运行不同协议，无法与另一个区块链共享其数据
- en: blockchain. This disconnect creates a situation where each blockchain is a silo.
    To
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。这种脱节造成了每个区块链都是一个孤立的情况。为了
- en: solve this issue, the organization that wants to join a consortium network must
    either
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题，想要加入财团网络的组织必须要么
- en: use the software client specific to that blockchain or somehow devise a complex
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门针对该区块链的软件客户端或者想出一个复杂的
- en: interoperability mechanism. This problem is well understood, and a lot of work
    is
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性机制。这个问题已经得到了很好的理解，并且已经做了很多工作
- en: underway regarding novel interoperability protocols. Also, new types of blockchains,
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 新的互操作性协议正在进行中。此外，还出现了新类型的区块链
- en: such as **heterogeneous multichains** and sharding-based approaches, are emerging.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 如**异构多链**和基于分片的方法，也在不断出现
- en: One prime example is Polkadot, a replicated sharded state machine where heterogenous
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要例子是波卡，一个复制的分片状态机，其中异构的
- en: chains can talk to each other through a so-called relay chain. Another effort
    is Ethereum 2.0, where sharded chains serve as a mechanism to provide scalability
    and cross-shard
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 链之间可以通过所谓的中继链进行通信。另一个努力是以太坊2.0，其中分片链作为提供可扩展性和跨片
- en: interoperability. Cardano is another blockchain that is on course to provide
    scalability
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性。Cardano是另一个正在提供可扩展性的区块链
- en: and interoperability between chains. With all these platforms and the pace of
    the work
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 不同区块链之间的互操作性。有了所有这些平台和工作进度
- en: in progress to realize these ideas, we can envisage that in the next eight to
    ten years,
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些想法的过程中，我们可以设想在接下来的八到十年内，
- en: these blockchains and others will be running just like we have the Internet
    today with
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区块链和其他区块链将像今天的互联网一样运行
- en: seamless data sharing between different chains. The chains that facilitate such
    a level of natural interoperability, giving rise to an ecosystem of multiple interoperating,
    general-purpose enterprise chains and ASBCs, are called **heterogeneous multichains**.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 不同链之间无缝数据共享。促成这种级别的自然互操作性的链，催生了多个互操作的通用企业链和ASBCs的生态系统，被称为**异构多链**。
- en: Now let’s clarify an ambiguity. You might have heard the term “distributed ledger,”
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们澄清一个模糊之处。你可能听过“分布式分类帐”这个术语
- en: which is sometimes used to represent a blockchain. While both terms, blockchain
    and
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用于表示区块链。虽然两个术语，区块链和
- en: distributed ledger, are used interchangeably, there’s a difference. The distributed
    ledger is an overarching term describing a ledger with distributed properties.
    Blockchains fall
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式分类帐可以互换使用，但存在差异。分布式分类帐是一个概括性术语，描述具有分布式特性的分类帐。区块链属于
- en: under this umbrella. A blockchain is a distributed ledger, but not all distributed
    ledgers are a blockchain. For example, some distributed ledgers do not use blocks
    composed
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别下。区块链是一个分布式分类帐，但并非所有分布式分类帐都是区块链。例如，一些分布式分类帐不使用由块组成
- en: of transactions in their blockchain construction. Instead, they treat transaction
    records individually and store them as such. Usually, however, in most distributed
    ledgers,
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们的区块链构建中的交易。相反，他们单独处理交易记录并以此方式存储。然而，通常在大多数分布式分类帐中，
- en: blocks are used as containers for a batch of transactions and several other
    elements such as block header, which also contains several components. Such use
    of blocks to bundle
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 块被用作承载一批交易和其他几个元素的容器，例如区块头，其中也包含几个组件。这样使用块来捆绑
- en: transactions makes them a blockchain.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交易使它们成为区块链。
- en: '173'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '173'
- en: Chapter 4 BloCkChain
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章 区块链
- en: '**Blockchain Is a Distributed System**'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链是一个分布式系统**'
- en: A blockchain is a distributed system. As such, it should be defined and reasoned
    about in the light of distributed computing. Furthermore, this formal description
    allows for better reasoning.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个分布式系统。因此，它应该在分布式计算的光环中进行定义和推理。此外，这种正式描述可以更好地推理。
- en: We discussed the CAP theorem in Chapter [1](https://doi.org/10.1007/978-1-4842-8179-6_1).
    Therefore, we can analyze the blockchain through the CAP theorem to ascertain
    what type of system it is.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[1](https://doi.org/10.1007/978-1-4842-8179-6_1)章讨论了CAP定理。因此，我们可以通过CAP定理分析区块链，以确定它是什么类型的系统。
- en: '**CAP and Permissionless Blockchain**'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP和无许可区块链**'
- en: Permissionless blockchains are AP (availability and partition tolerance) blockchains
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 无许可区块链是AP（可用性和分区容忍）区块链
- en: because consistency is somewhat sacrificed in favor of availability. We could
    argue that
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一致性在一定程度上为可用性而牺牲。我们可以争辩说
- en: eventual consistency is achieved, but as consistency (agreement) is sacrificed
    in favor
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性得以实现，但一致性（协议）为了可用性而牺牲
- en: of availability, we can say that permissionless or public blockchains are AP
    systems.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性，我们可以说无许可或公共区块链是AP系统。
- en: For example, Ethereum and Bitcoin are AP systems. This is the case due to the
    proof of
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以太坊和比特币都是AP系统。这是由于共识证明
- en: work (PoW) type of probabilistic consensus.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 工作（PoW）类型的概率共识。
- en: '**CAP and Permissioned Blockchain**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP和许可区块链**'
- en: Permissioned blockchains are CP (consistency and partition tolerance) systems
    because
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 许可区块链是CP（一致性和分区容忍）系统，因为
- en: availability is sacrificed in favor of consistency. This is the case because
    almost all
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性被用来牺牲一致性。这是因为几乎所有
- en: permissioned blockchains use traditional BFT protocols, where if a threshold
    of nodes
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 许可区块链使用传统的BFT协议，如果一定数量的节点达到阈值
- en: is faulty, then the whole system stalls until the faults are resolved, and then
    the system continues to operate. For example, in a five-node network, if three
    nodes go down, the
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 是有问题的，那么整个系统就会停滞，直到故障得到解决，然后系统才会继续运行。例如，在一个五节点网络中，如果有三个节点宕机，那么
- en: system doesn’t progress unless the other nodes come back online. Similarly,
    in the
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 除非其他节点恢复在线，否则系统不会进展。同样，在
- en: case of partitioning between subsets of two and three nodes, the system doesn’t
    make
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 在将节点划分为两个和三个子集的情况下，系统不会产生
- en: progress unless the partition heals. This is the case due to the use of traditional
    BFT
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 进展，除非分区得到修复。这是由于传统BFT的使用
- en: algorithms, such as PBFT. The requests coming from the clients are processed
    only if
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 算法，例如PBFT。来自客户端的请求只有在
- en: there’s a majority of honest nodes. In other words, if the system falls below
    3f+1 in the case of Byzantine fault tolerance, the system immediately degrades
    to nonfunctional.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有大多数诚实的节点。换句话说，如果在拜占庭容错的情况下，系统降到低于3f+1以下，系统立即退化为非功能性。
- en: We can visualize both these concepts in Figure [4-2](#p193).
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图[4-2](#p193)中将这两个概念可视化。
- en: '174'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '174'
- en: '![](index-193_1.png)'
  id: totrans-1539
  prefs: []
  type: TYPE_IMG
  zh: '![](index-193_1.png)'
- en: Chapter 4 BloCkChain
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章 区块链
- en: '***Figure 4-2\.** CAP theorem and blockchain*'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 4-2\.** CAP定理与区块链*'
- en: Next, we describe blockchain ledger abstraction which is an abstract view of
    a
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述区块链分类账抽象，这是区块链的一个抽象视图
- en: blockchain.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: '**Blockchain Ledger Abstraction**'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链分类账抽象**'
- en: Blockchain abstraction or sometimes called ledger abstraction can be defined
    with the
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链抽象，有时被称为分类账抽象，可以用下列方式来定义
- en: help of operations it can perform and several properties.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助它执行的操作以及几个属性。
- en: There are at a high level three operations that processes in a blockchain network
    can
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，区块链网络中的进程可以执行三种操作
- en: 'perform:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 执行：
- en: Get(), append(), verify()
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: Get(), append(), verify()
- en: When get() is invoked, it returns a copy of the current canonical state of the
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 调用get()时，它返回当前规范状态的一个副本
- en: blockchain (ledger).
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链（分类账）。
- en: When append() is invoked, it creates and appends a new record *r* to the blockchain.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用append()时，它创建并附加一个新的记录*r*到区块链。
- en: When verify() is invoked, it verifies and returns the validity status of the
    record *r* or blockchain *b*.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 调用verify()时，它验证并返回记录*r*或区块链*b*的有效状态。
- en: '175'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '175'
- en: Chapter 4 BloCkChain
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章 区块链
- en: '**Properties**'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**'
- en: There are several properties associated with a blockchain, which are described
    as
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 与区块链相关的有几个属性，这些属性被描述为
- en: follows.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示。
- en: '**Consistency**'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性**'
- en: • All replicas hold the same up-to-date copy of the data. In the case of
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: • 所有副本都持有相同的最新数据副本。在
- en: public blockchains, it is usually eventual consistency, and in the case
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 公共区块链，通常是最终一致性，在
- en: of permissioned blockchains, it is strong consistency.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 在许可制区块链中，它是强一致性。
- en: • Formally, if a record r is seen first by a process p before another
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: • 形式上，如果记录*r*在另一个进程*p*之前首先被看到
- en: record r2, then every honest process sees r before r2\.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 记录*r2*，然后每个诚实的进程在*r2*之前看到了*r*。
- en: '**Fault Tolerant**'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '**容错**'
- en: • Blockchains are fault-tolerant distributed systems. A blockchain
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: • 区块链是容错的分布式系统。区块链
- en: network can withstand Byzantine or crash faults up to a threshold.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可以经受拜占庭或崩溃故障，直到达到一个阈值。
- en: • In BFT-based blockchains (usually with a PBFT variant implemented
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: • 在BFT-based区块链中（通常是通过PBFT变体实现
- en: in blockchains), the lower bound is 3F + 1, where F is the number
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链中) ，下限为3F + 1，其中F是数字
- en: of faults.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 的故障。
- en: • In CFT-based blockchains (usually with RAFT implementation in
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: • 在基于CFT的区块链中（通常使用RAFT实现
