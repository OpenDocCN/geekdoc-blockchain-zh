- en: '11   Deploying the Sample Application: Blockchain and Betting'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11   部署示例应用：区块链与投注
- en: Deploying Full Contract
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署完整合约
- en: In [Chapter 10](ch10.xhtml#ch10), we introduced the development steps for writing
    a smart contract. Now that the contract is fully written, let’s deploy it to our
    test chain, and interact with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.xhtml#ch10)中，我们介绍了编写智能合约的开发步骤。现在合约已经完全编写完毕，让我们将其部署到我们的测试链上，并与之交互。
- en: '`node deploy.js ethereum && node debug.js ethereum`'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`node deploy.js ethereum && node debug.js ethereum`'
- en: Fix any errors that pop up during compilation, then run the deployment again
    if necessary. If everything worked properly, you should see the interactive prompt
    pop up. Let’s run a couple of test functions to make sure our contract is working.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中修复出现的任何错误，如有必要，再次运行部署。如果一切正常，你应该看到交互式提示框弹出。让我们运行几个测试函数来确保我们的合约能正常工作。
- en: '![Images](p0265-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0265-01.jpg)'
- en: The first line creates a UNIX timestamp 1 hour (3600s) in the future. The JavaScript
    Date type uses milliseconds after the UNIX epoch instead of seconds after the
    UNIX epoch like most other languages, so a conversion is required. The third parameter
    is the category, with 1 referring to NBA for our purposes. Executing the `createGame`
    function will return a transaction id that can be used to check whether the transaction
    has been mined.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个UNIX时间戳，比现在时间晚1小时（3600秒）。JavaScript日期类型使用的是自UNIX纪元以来的毫秒数，而不是像大多数其他语言那样使用自UNIX纪元以来的秒数，因此需要进行转换。第三参数是类别，对于我们来说，1指的是NBA。执行`createGame`函数将返回一个交易ID，该交易ID可用于检查交易是否已被矿工打包。
- en: 'At any point, you can run:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在任何时候，你可以运行:'
- en: '`web3.eth.getTransactionReceipt(tx);`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.eth.getTransactionReceipt(tx);`'
- en: to see if the transaction has been mined. If it hasn’t, it will return null.
    If it has, it will return a receipt object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以查看交易是否已被矿工打包。如果没有，它将返回null。如果有，它将返回一个收据对象。
- en: Once the transaction has cleared, you should be able to read the newly created
    game from the contract.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 交易确认后，你应该能够从合约中读取到新创建的游戏信息。
- en: '![Images](p0266-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0266-01.jpg)'
- en: You should be able to view a single game in the output of both those statements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够从这两个语句的输出中看到单个游戏的信息。
- en: Deploying to the Mainnet
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主网部署
- en: Deploying to the mainnet is very similar to deploying to our private chain.
    Repeat all the exact steps above with two exceptions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 主网部署与部署到我们的私有链非常相似。重复上面所有确切的步骤，有两个例外。
- en: 'First, exit the geth process running our private chain by navigating to that
    tab and typing CTRL-C. Then run the Ethereum mainnet with the command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过导航到运行我们私有链的geth进程标签并输入CTRL-C来退出私有链的geth进程。然后使用以下命令运行以太坊主网：
- en: '`| geth --rpc --rpcapi web3,eth,net,personal`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`| geth --rpc --rpcapi web3,eth,net,personal`'
- en: If you haven’t synced a full geth node in the past, this process will take up
    to a day. If you have, it should only take a few minutes to sync up fully. In
    order to deploy to the mainnet, you will have to create a wallet address and obtain
    ether from an exchange. This process is covered in earlier chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前还没有同步过一个完整的geth节点，这个过程可能需要长达一天的时间。如果你已经同步过了，完全同步应该只需要几分钟。为了将应用部署到主网，你必须创建一个钱包地址并从交易所获取以太币。这个流程在早前的章节中有覆盖。
- en: Once the node is synced and caught up to the main chain, run the `deploy` command
    from the previous section. You should see confirmation of your deployment in the
    output. You can now run the test scripts from the previous section to confirm
    that the contract deployed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 节点同步并追赶上主链之后，运行前文提到的`deploy`命令。你应该在输出中看到你的部署确认信息。现在你可以运行前文提到的测试脚本来确认合约是否已成功部署。
- en: Seeding Data
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 种子数据
- en: Manually seeding our contract with data every time we deploy is a tedious and
    slow process, so we’re going to write a script to seed data for us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署时手动为我们合约种子数据是一个既繁琐又耗时的过程，所以我们将编写一个脚本来为我们种子数据。
- en: 'Here’s what our seeds.js file is going to look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`seeds.js`文件将看起来像这样：
- en: '![Images](p0266-02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0266-02.jpg)'
- en: '![Images](p0267-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0267-01.jpg)'
- en: 'Let’s break this down by section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按部分拆分这个流程：
- en: '![Images](p0267-02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0267-02.jpg)'
- en: These are the standard includes and provider setup logic we’ve seen before.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们之前见过的标准包含和提供者设置逻辑。
- en: '![Images](p0268-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0268-01.jpg)'
- en: We load the ABI and contract address from their appropriate files and use it
    to create a contract object. We then access our default wallet and unlock it with
    our wallet password, which will be passed into the script as the first command
    line argument.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从各自的文件中加载ABI和合约地址，并使用它们创建一个合约对象。然后我们访问默认的钱包，并使用钱包密码解锁，该密码将作为脚本的第一命令行参数传递。
- en: '![Images](p0268-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0268-02.jpg)'
- en: To mix it up, we define four different locktimes to use in our games logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了混合一下，我们在游戏逻辑中定义了四个不同的锁时间。
- en: '![Images](p0268-03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0268-03.jpg)'
- en: We create six games here by defining an array of game property arrays, looping
    through the array, then using the JavaScript spread operator, `...`, to pass the
    parameters into the `createGame` contract function. This should create six National
    Basketball Association (NBA) games (category = 1) with different locktimes and
    teams.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里通过定义一个游戏属性数组，遍历数组，然后使用JavaScript展开操作符`...`，将参数传递到`createGame`合约函数中，从而创建六个游戏。这应该会创建六个国家篮球协会（NBA）比赛（类别=1），具有不同的锁时间和球队。
- en: '![Images](p0268-04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0268-04.jpg)'
- en: Run a loop 100 times and seed 100 bids into the contract. Each bid will go to
    a random game, with a random amount, at a random line, to a random side of the
    bet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行100次循环，并向合约中播种100个出价。每个出价都将随机分配到一个随机游戏、随机金额、随机行、随机下注的一方。
- en: 'Save this file to seeds.js, then run our full deploy-seed-debug dev flow with:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为seeds.js，然后用以下命令运行我们的完整部署-种子-调试开发流程：
- en: '`node deploy.js [password] && node debug.js [password] node seeds.js [password]`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`node deploy.js [password] && node debug.js [password] node seeds.js [password]`'
- en: As always, replace `[password]` with your wallet password. Wait about 1 minute
    for all the transactions to clear. You can monitor the status of the transactions
    in the terminal tab running the private chain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，用你的钱包密码替换`[password]`。等待大约1分钟，让所有的交易都结算。你可以在运行私有链的终端标签中监控交易的状态。
- en: 'In the debug console, examine the order book for a game:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试控制台中，检查一个游戏的市场订单：
- en: '`contract.getOpenBids(2)`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract.getOpenBids(2)`'
- en: 'Since `getOpenBids` is a constant function, it should return immediately with
    a hex string that looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getOpenBids`是一个常量函数，它应该立即返回一个看起来像这样的十六进制字符串：
- en: '![Images](p0269-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0269-01.jpg)'
- en: 'This is the unparsed byte array created for us by the contract function. To
    view the book, we have to parse the byte array back into a bid array. Exit the
    debugger, then include these functions in debug.js:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合约函数为我们创建的未解析的字节数组。要查看市场，我们必须将字节数组解析回出价数组。退出调试器，然后在debug.js中包含这些函数：
- en: '![Images](p0269-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0269-02.jpg)'
- en: The `parseBid` function takes a 114-character hex string and converts it into
    a bid object using the data dictionary we defined earlier in the chapter. The
    `parseBids` function strips away the leading `0x`, splits the long hex into 114-character
    hex strings, and turns the parsed bids into an array. Why 114 (57 * 2) characters
    instead of 57, which is the length of the bid representation in bytes? Because
    it takes two hex characters to encode a byte, so twice the number of characters
    are required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseBid`函数接收一个114个字符的十六进制字符串，并使用我们在本章早期定义的数据字典将其转换为出价对象。`parseBids`函数去掉了开头的`0x`，将长十六进制字符串分割成114个字符的十六进制字符串，并将解析出的出价转换为数组。为什么是114（57
    * 2）个字符，而不是57，后者是出价表示的字节长度？因为每个字节需要两个十六进制字符来编码，所以需要两倍的字符数。'
- en: 'Enter back into the debugger:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重新进入调试器：
- en: '![Images](p0270-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0270-01.jpg)'
- en: 'Now your parsed result should look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的解析结果应该看起来像这样：
- en: '![Images](p0270-02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0270-02.jpg)'
- en: '![Images](p0271-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0271-01.jpg)'
- en: The over bids show up first, with the highest line at the bottom, then the under
    bids are at the bottom half, with the lowest line at the bottom. The amounts for
    some of the bids will be 0, indicating that they have been matched but have not
    yet been overwritten by a new bid.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先出现的是超额出价，最高的行在底部，然后是低于出价的一半，最低的行在底部。一些出价的金额为0，表示它们已经被匹配，但尚未被新的出价覆盖。
- en: There should be placed bets as well. We can check for those by searching the
    logs for `BetPlaced` events in the debug console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该有下注。我们可以通过在调试控制台中搜索`BetPlaced`事件来检查那些下注。
- en: '`contract.BetPlaced({}, { fromBlock: 1 }).get(console.log)`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract.BetPlaced({}, { fromBlock: 1 }).get(console.log)`'
- en: Front-End User Interface
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端用户界面
- en: All public contract functions expose an ABI that can be accessed through the
    web3.js library. If you wish to run a betting server without a user interface,
    your work is complete, and the contract is ready to use. However, most sites will
    require a front-end interface, so we will build out a simple one for our betting
    contract.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有公共合约函数都暴露出一个ABI，可以通过web3.js库进行访问。如果您希望运行一个没有用户界面的投注服务器，您的任务就完成了，合约就可以使用了。然而，大多数网站将需要一个前端界面，因此我们将为我们的投注合约构建一个简单的界面。
- en: Since the focus of this book is on blockchains and not web interfaces, we will
    not be building a full-fledged web UI. It is assumed that the reader has a basic
    understanding of HTML, JavaScript, and jQuery, but no CSS or styling will be used.
    The purpose of our front end will be to demonstrate how to use the web3.js library
    with an Ethereum contract, and we will not build out further functionality beyond
    that. With that, let’s get started!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点是区块链，而不是Web界面，所以我们不会构建一个完整的Web UI。假设读者已经具备了HTML、JavaScript和jQuery的基本理解，但不会使用CSS或样式。我们前端的目的将是展示如何使用web3.js库与以太坊合约配合使用，并且我们不会构建除了那之外的功能。那么，让我们开始吧！
- en: Pages in the User Interface
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户界面中的页面
- en: 'Our front end is going to have three pages with the following functionality:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前端将包含三个具有以下功能的页面：
- en: •   View list of games (index.html)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: •   查看游戏列表（index.html）
- en: •   View book for a single game (bet.html)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: •   查看单个游戏的书本（bet.html）
- en: •   Withdraw winnings (withdraw.html)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: •   提取奖金（withdraw.html）
- en: Displaying Games
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示游戏
- en: 'Our home page, index.html, is going to display a table with all of our active
    games. In addition there is a link to the withdraw page we will be building later.
    Here’s the HTML for the page:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主页index.html将显示一个包含我们所有活跃游戏的表格。此外，还有一个链接到我们稍后要构建的提现页面。以下是页面的HTML：
- en: '![Images](p0271-02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0271-02.jpg)'
- en: '![Images](p0272-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0272-01.jpg)'
- en: As you can see, there’s a link to the withdraw page above the header, followed
    by the header and games table. The games table contains a series of descriptive
    columns about each game. The column with no title is where the links to the game’s
    betting page will go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在头部上方有一个链接到提现页面的按钮，然后是头部和游戏表格。游戏表格包含了一系列关于每款游戏的描述性列。没有标题的列是放置游戏投注页面链接的地方。
- en: 'There are two JavaScript files included on the page: the jQuery CDN and our
    main.js file. The jQuery CDN and the MetaMask Chrome extension (which injects
    the web3.js library) are the only dependencies for the front end.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上有两个JavaScript文件：jQuery CDN和我们的主.js文件。jQuery CDN和MetaMask Chrome扩展（它注入了web3.js库）是前端唯一的依赖。
- en: Let’s take a look at the custom JavaScript required in the main.js file piece
    by piece. We will be using the main.js file for all three of our HTML pages, so
    there will be some overlapping code that will be explained as we go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看主.js文件中所需的自定义JavaScript。我们将使用主.js文件来处理我们三个HTML页面，所以会有一些重复的代码，这些代码将在我们进行的过程中进行解释。
- en: This first batch of code loads up some file dependencies and prepares the page
    for execution. It is common to all three of our pages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一批代码首先加载了一些文件依赖项，并为页面执行做准备。它是我们三个页面中都共有的。
- en: '![Images](p0272-02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0272-02.jpg)'
- en: '![Images](p0273-01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0273-01.jpg)'
- en: The first two lines use jQuery’s AJAX functionality to load up the two pieces
    of data we will need to create our web3 `Contract` object, the ABI and contract
    address, and defining promises for both AJAX calls.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行使用jQuery的AJAX功能来加载我们将需要创建web3 `Contract` 对象的两种数据，即ABI和合约地址，并为这两个AJAX调用定义了承诺。
- en: For those unfamiliar with the concept, promises are a construct that allows
    for asynchronous code execution. Similar to threads, promises begin execution
    of a function, then return without waiting for the block of code to finish executing.
    Instead, the promise resolves when the code is finished executing, and bindings
    are provided that allow code to execute after a promise resolves instead of immediately
    when the function returns. Promises are outside the scope of this book but are
    an integral part of writing good front-end JavaScript code, so please familiarize
    yourself with the concept before attempting to build a front end for your contract.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉这个概念的人来说，承诺是一种允许异步代码执行的构造。与线程类似，承诺开始执行一个函数，然后在不等待代码块执行完成的情况下返回。相反，当代码执行完成后，承诺解析，提供绑定，使代码在承诺解析而不是函数立即返回时执行。承诺超出了本书的范围，但它是编写优秀前端JavaScript代码的重要组成部分，因此在尝试为您的合约构建前端之前，请熟悉这个概念。
- en: As we mentioned earlier, the MetaMask Chrome extension and Chrome browser are
    requirements for the application. The MetaMask extension injects the web3.js library
    into our application, so we don’t have to require it ourselves. However, the injection
    occurs asynchronously, so any code that uses the library (in our case, the entire
    application) must wait until the injection completes in order to execute. The
    second block of code handles the asynchronous behavior, by defining a promise
    that resolves when web3 has been injected. It does so by checking for the existence
    of the library every 50ms until the library is found.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，MetaMask Chrome扩展程序和Chrome浏览器是应用程序的要求。MetaMask扩展程序将web3.js库注入到我们的应用程序中，所以我们不必自己引入。然而，注入是异步的，所以任何使用该库的代码（在我们的情况下，整个应用程序）必须等待注入完成才能执行。代码的第二部分处理异步行为，通过定义一个在web3注入时解决的承诺。它通过每50毫秒检查库是否存在来做到这一点。
- en: '![Images](p0273-02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0273-02.jpg)'
- en: Once web3 is available and the required files have loaded, we can create the
    `Contract` object. `$.when` is similar to the built-in `Promise.all` function,
    and allows us to wait for a series of promises to return before executing a block
    of code. Once we have a `Contract` object, our code branches into three different
    tracks using a `switch` statement, one for each of the three pages. The default
    track is the games page, which is the track we will be exploring in this section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦web3可用且所需文件已加载，我们可以创建`Contract`对象。`$.when`与内置的`Promise.all`函数类似，允许我们等待一系列承诺返回后执行一段代码。一旦我们有了`Contract`对象，我们的代码通过一个`switch`语句分成三个不同的轨道，每个轨道对应三个页面中的一个。默认轨道是游戏页面，这是我们将在本节中探索的轨道。
- en: '![Images](p0274-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0274-01.jpg)'
- en: The games page gets a list of games and adds them to the games table. Both of
    those functionalities are handled in helper functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏页面获取游戏列表并将它们添加到游戏表格中。这两个功能都由助手函数处理。
- en: 'Let’s take a look at the `getGames` helper:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`getGames`助手：
- en: '![Images](p0274-02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0274-02.jpg)'
- en: '![Images](p0275-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0275-01.jpg)'
- en: The first block runs a call to the `getActiveGames` function, which returns
    an array of game ids. Those game ids are then resolved through a promise, so they
    can be available asynchronously to the remainder of the function. Those game ids
    are then used to access two separate event logs, the GameCreated event and the
    GameScored event. This occurs in the second and third logs. The results of both
    those log accesses are resolved through individual promises, then the two are
    combined in the final block. The game scores are merged with the game information
    object and the combined object is resolved through the returned promise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块运行了对`getActiveGames`函数的调用，该函数返回一个游戏id数组。然后通过一个承诺解析这些游戏id，以便它们可以异步地供函数的其余部分使用。然后使用这些游戏id来访问两个不同的事件日志，分别是GameCreated事件和GameScored事件。这在第二和第三日志中发生。这两个日志访问的结果通过各自的承诺解析，然后在最后的块中组合在一起。游戏得分与游戏信息对象合并，然后通过返回的承诺解析合并对象。
- en: If the scores are not defined because the game has not yet been scored, the
    home and away scores will be represented by a single `’-’`. This way, when we
    display the scores later with a `’-’` separating the home and away scores, an
    unscored game will show `’---’`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为游戏尚未得分而未定义分数，主队和客队的得分将由单个`’-’`表示。这样，当我们用`’-’`分隔主队和客队得分显示分数时，未得分的比赛将显示`’---’`。
- en: 'Once we have the games, we add them to our table through another helper function,
    `addGameToTable`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了游戏，我们就通过另一个辅助函数`addGameToTable`将其添加到我们的表格中：
- en: '![Images](p0275-02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0275-02.jpg)'
- en: This function is very simple. It takes the game object, turns it into an HTML
    table row, then inserts it into the table.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。它接收游戏对象，将其转换为HTML表格行，然后将其插入到表格中。
- en: 'That’s all the code for the games page. The simplest way to run the server
    is in the command line for the folder:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏页面的所有代码。运行服务器的最简单方法是在该文件夹的命令行中：
- en: '`python2 -m SimpleHTTPServer`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`python2 -m SimpleHTTPServer`'
- en: Python 2 is preinstalled on OS X and Linux, but on Windows you may have to download
    the package from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2已预装在OS X和Linux上，但在Windows上，您可能需要从[https://www.python.org/downloads/](https://www.python.org/downloads/)下载该包。
- en: Make sure your geth private net is running in a terminal tab. Then set your
    MetaMask extension to connect to the private net by clicking the fox icon in the
    upper-left corner. Select the item in the drop-down labeled Localhost 8545 (see
    [Figure 11-1](ch11.xhtml#ch11fig1)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的geth私有网络在终端标签中运行。然后，通过点击左上角的狐狸图标，将您的MetaMask扩展程序连接到私有网络。选择下拉列表中标注为Localhost
    8545的项目（见[图11-1](ch11.xhtml#ch11fig1)）。
- en: '![Images](fig11-1.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig11-1.jpg)'
- en: '**FIGURE 11-1   MetaMask**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11-1   MetaMask**'
- en: If everything has been set up properly, you should see a page that looks like
    [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您应该看到一个看起来像[图11-2](ch11.xhtml#ch11fig2)的页面。
- en: '![Images](fig11-2.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig11-2.jpg)'
- en: '**FIGURE 11-2   Betting application page 1**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11-2   投注应用页面1**'
- en: Congratulations, you’ve got yourself an ugly but functional games page!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经拥有了一个丑陋但功能齐全的游戏页面！
- en: Bet Page Markup
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 投注页面标记
- en: We’re going to be creating a separate page to display the order book and place
    bets. We saw earlier that our main thread split into three different tracks, one
    for each page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个单独的页面来显示订单簿和下注。我们之前看到，我们的主线程分成了三个不同的轨道，每个轨道对应一个页面。
- en: '![Images](p0277-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0277-01.jpg)'
- en: We will now be pursuing the betting track and explaining the markup and code
    associated with the page. To start, here’s the basic HTML outline we will be following.
    There will be other functionalities available on this page as well, and we will
    add them to this HTML base as we go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将追求投注轨道，并解释与该页面相关的标记和代码。首先，这里是我们将遵循的基本HTML大纲。此页面上还将提供其他功能，我们将在此HTML基础上逐步添加它们。
- en: '![Images](p0277-02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0277-02.jpg)'
- en: 'This is the same frame as for the games page. From here, we will add bet page–specific
    functionality. First, we want to display some basic game information:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与游戏页面相同。从这里，我们将添加投注页面特定的功能。首先，我们希望显示一些基本比赛信息：
- en: '![Images](p0277-03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0277-03.jpg)'
- en: There are display locations for the home team, away team, game time, and score.
    These will be filled in by our JavaScript on page load. As before, we will not
    be styling the page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有显示主队、客队、比赛时间和得分的位置。这些将在页面加载时由我们的JavaScript填充。与以前一样，我们不会对页面进行样式设计。
- en: Next, we need sections for placing our over and under bets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要放置我们的超额和不足投注的部分。
- en: '![Images](p0278-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0278-01.jpg)'
- en: This displays two identical sections, one for placing an over bet and one for
    placing an under bet. Each section has two inputs, one for the line and one for
    the bet amount, and a button for placing the bet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两个相同的部分，一个用于放置超额投注，一个用于放置不足投注。每个部分都有两个输入框，一个用于投注线，一个用于投注金额，还有一个下注按钮。
- en: In addition to bet placement, this page will display the order book and a section
    for setting the game score. Let’s first look at the HTML for displaying open bids.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了下注之外，这个页面还将显示订单簿和设置比赛得分的部分。首先，让我们看看用于显示开放出价的HTML。
- en: '![Images](p0278-02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0278-02.jpg)'
- en: '![Images](p0279-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0279-01.jpg)'
- en: This sets up two tables, one for over bids and one for under bids. Both tables
    contain columns for the bet line and the bet amount. The table body and table
    header are given separate sections because later on we will be inserting rows
    directly into the body without touching the header. The `<hr>` tag separates the
    section with a horizontal divider.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了两个表格，一个用于超额出价，一个用于不足出价。两个表格都包含投注线和投注金额的列。将表格正文和表格标题分开是因为后来我们直接向正文中插入行，而不接触标题。`<hr>`标签用水平分隔符分隔部分。
- en: We will also be displaying bets that have already been matched and placed into
    the book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将显示已经匹配并放入订单簿的投注。
- en: '![Images](p0279-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0279-02.jpg)'
- en: This table is very similar to the bids table and contains the same columns.
    The only difference will be in the data we add to the table.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格与出价表格非常相似，包含相同的列。我们添加到表格中的数据唯一的区别。
- en: Finally, we want a small form that we can use to score the game when betting
    has closed and the game is complete.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要一个小的表单，我们可以在投注关闭且游戏完成后使用它来评分。
- en: '![Images](p0279-03.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0279-03.jpg)'
- en: The form has inputs for the home and away scores, and a button that can be used
    to submit the score.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表单内有主队和客队的得分输入，还有一个可以用来提交得分的按钮。
- en: That will be all for the HTML. The actual displayed data will come from web3,
    and we will use JavaScript to print the data onto the page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是HTML的全部内容。实际显示的数据将来自web3，我们将使用JavaScript将数据打印到页面上。
- en: Displaying Game Information
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示游戏信息
- en: 'To display information about a single game, we will be reusing the `getGames`
    function we defined earlier, and defining a new helper function to grab the game
    we want:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示单个游戏的详细信息，我们将重新使用我们之前定义的`getGames`函数，并定义一个新的助手函数来获取我们想要的游戏：
- en: '![Images](p0280-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0280-01.jpg)'
- en: This function gets the list of the games then finds the desired game. Returning
    an item within a `.then` callback will cause that promise to resolve with the
    returned value. So this function returns a promise that resolves with the desired
    game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取游戏的列表，然后找到所需的游戏。在`.then`回调中返回一个项目会导致该承诺用返回的值解决。因此，这个函数返回一个用所需游戏解决的承诺。
- en: 'Using this function, we can display the game information on our page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，我们可以在我们的页面上显示游戏信息：
- en: '![Images](p0280-02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0280-02.jpg)'
- en: The home and away team names are displayed from the game object. Then the locktime
    is converted from a UNIX timestamp to a JavaScript Date and displayed. The scores
    will not be defined if the game has not been scored yet. In this case, the score
    will display `’---’` because the home and away scores will both be set to a single
    `’-’` by the `getGames` helper.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主场和客场队伍名称从游戏对象中显示。然后将锁时间从UNIX时间戳转换为JavaScript日期并显示。如果游戏还没有得分，得分将不会被定义。在这种情况下，得分将显示`’---’`，因为`getGames`助手将主队和客场得分都设置为单个`’-’`。
- en: Displaying Open Bids
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示开放出价
- en: Earlier, we defined `parseBids` and `parseBid` helper functions in our debug.js
    file to parse the byte array returned by the contract’s `getOpenBids` ABI function.
    We will be reusing those functions here. The code is reproduced below without
    explanation. Please refer to the “Seeding Data” section earlier in the chapter
    for the code explanation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们在我们的debug.js文件中定义了`parseBids`和`parseBid`助手函数，以解析合约的`getOpenBids` ABI函数返回的字节数组。我们将在这里重用这些函数。下面的代码没有解释。请参阅章节前面的“播种数据”部分，以获取代码解释。
- en: '![Images](p0281-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0281-01.jpg)'
- en: In addition, we will define a `getOpenBids` helper function to make the web3
    call to the contract, parse the returned byte array, and resolve it all through
    a promise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将定义一个`getOpenBids`助手函数，以使web3调用合约，解析返回的字节数组，并通过承诺解决所有问题。
- en: '![Images](p0281-02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0281-02.jpg)'
- en: The `getOpenBids` contract ABI function is a constant function, so web3 executes
    a call that returns immediately. As always, the first argument in the callback
    is the error (null if no error) and the returned byte array is the second argument
    in the form of a hex string (`“0xf43...”`). The hex string is parsed into a byte
    array, empty bids with an amount of 0 are removed, and the bid amount is converted
    from wei to ether. The resulting array is then resolved through the returned promise.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOpenBids`合约ABI函数是一个常量函数，所以web3执行一个立即返回的调用。像往常一样，回调中的第一个参数是错误（如果没有错误就是null），返回的字节数组是回调中的第二个参数，以十六进制字符串（`“0xf43...”`）的形式出现。将十六进制字符串解析为字节数组，移除金额为0的空出价，并将出价金额从wei转换为ether。然后通过返回的承诺解决结果数组。'
- en: 'Finally, we will define a helper function that adds the bids to the table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义一个助手函数，用于将出价添加到表格中：
- en: '![Images](p0282-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0282-01.jpg)'
- en: This function takes a table selector (e.g., `“#over-bids-table”`) and adds a
    row to the body of the table with the given bid’s information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个表格选择器（例如，`“#over-bids-table”`），并在表格的正文中添加一个包含给定出价信息的行。
- en: 'Putting these helper functions together, we can retrieve bids and display them
    on our page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 把这些助手函数放在一起，我们可以检索出价并在我们的页面上显示它们：
- en: '![Images](p0282-02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0282-02.jpg)'
- en: The bids are filtered twice, once to get the over bids and display them on the
    over bids table, and then again to get the under bids and display them on the
    under bids table.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下注信息被过滤两次，一次是为了获取超过的下注并在超过的下注表格中显示它们，然后再次过滤以获取低于的下注并在低于的下注表格中显示它们。
- en: Displaying Bets
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示投注
- en: We would like to display existing matched bets in addition to the open bids.
    In order to do so, we will define a couple more helper functions to get the bets
    and add them to the bets table.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够显示现有的匹配下注以及开放出价。为此，我们将定义几个更多的助手函数来获取下注并将它们添加到下注表中。
- en: First, let’s define the helper to retrieve bets from the blockchain logs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个助手来从区块链日志中检索下注。
- en: '![Images](p0282-03.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0282-03.jpg)'
- en: The bets are stored in the logs with an index on the game_id field. We can take
    advantage of that and parse the logs only for bets with our game id. The first
    object passed to a web3 contract event getter is an object of index-value pairs
    for the search. The second object is a config object. As stated earlier, the only
    config we need to specify is the `fromBlock` field. The other default values will
    suffice. Once we get the logs, we extract just the event data from them through
    the `args` property and resolve the data through the returned promise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下注存储在带有 game_id 字段的索引的日志中。我们可以利用这一点，仅解析带有我们的 game id 的日志。传递给 web3 合约事件获取器的第一个对象是索引值对的搜索对象。第二个对象是一个配置对象。如前所述，我们只需要指定的唯一配置是
    `fromBlock` 字段。其他的默认值就足够了。一旦我们得到日志，我们就通过 `args` 属性从中提取事件数据，并通过返回的承诺解决数据。
- en: We will also require a simple helper to add our bet information to the bets
    table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将需要一个简单的助手来将我们的下注信息添加到下注表格中。
- en: '![Images](p0283-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0283-01.jpg)'
- en: This function takes the bet information, creates a table row with it, then adds
    the row to the bets table body.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数取下注信息，创建一个带有它的表格行，然后将行添加到下注表格的主体中。
- en: Using these helpers, we can now retrieve bets and display them on our page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些助手，我们现在可以从区块链中检索下注并在我们的页面上显示它们。
- en: '![Images](p0283-02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0283-02.jpg)'
- en: For every two-sided bet that occurs in the contract, two separate logs are produced,
    one for the over side and one for the under side. If we displayed all of the bet
    logs, each bet would be displayed twice, so we filter out just the over bets and
    display those. The side chosen is irrelevant; we could just as well filter out
    the under bets and display those. The result would be the same.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在合约中发生的每一个两面下注，都会产生两个分开的日志，一个是超过方面的，一个是低于方面的。如果我们显示所有的下注日志，每个下注都会显示两次，所以我们就过滤出只是超过的下注并显示那些。选择哪一方无关紧要；我们也可以同样过滤出低于的下注并显示那些。结果会是一样的。
- en: Placing Bids/Bets
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下注/投注
- en: When placing a bet, the user will fill in the line and amount for their chosen
    side and click the corresponding Place Bet button. Our JavaScript code will be
    responsible for translating that click into a real bid placement on our deployed
    contract.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下注时，用户将填写他们选择的一方的行和金额，然后点击相应的下注按钮。我们的 JavaScript 代码将负责将点击转换为我们部署的合约上的真实出价。
- en: We will have to define a helper function that gets the current user’s wallet
    address in order to do this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不定义一个助手函数，以获取当前用户的钱包地址以进行此操作。
- en: '![Images](p0283-03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0283-03.jpg)'
- en: '![Images](p0284-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0284-01.jpg)'
- en: Getting the user’s wallet address is different based on whether we are using
    MetaMask or the Mist browser. While we haven’t been testing our dapp with the
    Mist browser up to this point, this function is the only one that has different
    implementations for the different browsers, so we will include it in the interest
    of interoperability.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户的钱包地址取决于我们是否使用 MetaMask 还是 Mist 浏览器。虽然到目前为止我们还没有用 Mist 浏览器测试我们的 dapp，这个功能是唯一一个在不同浏览器上有不同实现的功能，所以为了可互操作性，我们将包括它。
- en: MetaMask exposes the wallet addresses as an array at web3.eth.accounts. The
    first address will be the one that user has currently selected for use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 将钱包地址作为一个数组暴露在 web3.eth.accounts 中。第一个地址将是用户当前选择的用于的地址。
- en: The Mist browser requires you to request account permission before unlocking
    the address. A pop-up, shown in [Figure 11-3](ch11.xhtml#ch11fig3), will be presented
    to the user asking them to authorize the application before the address can be
    used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Mist 浏览器要求您在解锁地址之前请求账户权限。一个弹出窗口，如 [图 11-3](ch11.xhtml#ch11fig3) 所示，将呈现给用户，要求他们在地址可以使用之前授权应用程序。
- en: '![Images](fig11-3.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig11-3.jpg)'
- en: '**FIGURE 11-3   Mist browser request for account permission**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 11-3   Mist 浏览器请求账户权限**'
- en: This function abstracts away the browser-level differences and returns a promise
    that resolves with the wallet address regardless of which browser is being used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数抽象了浏览器级别的差异，并返回一个承诺，无论使用哪个浏览器，都会解析为钱包地址。
- en: '![Images](p0285-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0285-01.jpg)'
- en: Within the `betPage` function, we will register an event listener that listens
    for both the over and under bet placement simultaneously. The listener first retrieves
    the wallet address asynchronously. It then uses the id of the event target (the
    clicked button) to determine whether the over or under button was clicked and
    grabs the corresponding line and amount from the inputs. The user enters their
    bet amount in ether, but the contract expects the bet amount to be in wei, so
    we multiply by 1e18 to convert the ether amount to wei.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`betPage`函数中，我们将注册一个事件监听器，同时监听“超过”和“不足”的投注放置。监听器首先异步获取钱包地址。然后使用事件目标（被点击的按钮）的id来确定是点击了“超过”还是“不足”按钮，并从输入框中获取相应的行和金额。用户以以太币为单位输入他们的投注金额，但合约期望投注金额以wei为单位，因此我们将以太币金额乘以1e18以将以太币金额转换为wei。
- en: Once all the bid parameters are parsed and determined, we call the contract’s
    bid ABI function with the parameters. The callback is left empty, but any postprocessing
    code (such as UI adjustments) could go there.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有出价参数都被解析和确定，我们就用参数调用合约的出价ABI函数。回调留空，但任何后处理代码（如UI调整）都可以放在那里。
- en: Let’s test this functionality by attempting to place a bet with Chrome and MetaMask.
    You should at this point be looking at a page that looks like [Figure 11-4](ch11.xhtml#ch11fig4).
    You may have to wait a few seconds after the page loads for the game information
    to populate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过尝试使用Chrome和MetaMask下注来测试此功能。此时你应该正在查看一个类似于[图11-4](ch11.xhtml#ch11fig4)的页面。你可能需要在页面加载后等待几秒钟，以便游戏信息填充。
- en: '![Images](fig11-4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig11-4.jpg)'
- en: '**FIGURE 11-4   Placing a bet**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11-4   下注**'
- en: Enter a line of 200 and a bet amount of 0.1 into the over inputs and place your
    bet. MetaMask should display a confirmation pop-up asking you to verify the transaction;
    see [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在“超过”输入框中输入200行，在“投注金额”输入框中输入0.1，然后下注。MetaMask应该会弹出一个确认窗口，要求您验证交易；见[图11-5](ch11.xhtml#ch11fig5)。
- en: '![Images](fig11-5.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig11-5.jpg)'
- en: '**FIGURE 11-5   MetaMask confirmation pop-up**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11-5   MetaMask确认弹窗**'
- en: 'If the gas field is empty, enter in a value of 20 Gwei. This is the default
    gas price on Ethereum. Click Accept, then open up your geth tab. You should see
    a log output similar to this indicating the transaction was sent:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果燃气字段为空，输入20 Gwei的值。这是以太坊的默认燃气价格。点击接受，然后打开你的geth标签页。你应该会看到一个类似于此的交易发送日志输出：
- en: '![Images](p0285-02.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0285-02.jpg)'
- en: Wait a minute or so to ensure that the transaction gets mined. Now reload the
    page. You should see your bet in the bets section if it was matched, or in the
    open bids section if it wasn’t.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一分钟左右，以确保交易被挖掘。现在重新加载页面。如果匹配成功，你应该会在投注部分看到你的投注，如果没有匹配，就会在开放出价部分看到。
- en: Scoring Games
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计分游戏
- en: 'When a game is complete, we want to be able to score it and pay out bets to
    the winners. To do so, we have already created a form for score inputs. The JavaScript
    to handle the score submission looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏完成后，我们希望能够对其进行计分并支付给赢家的投注。为此，我们已经创建了一个用于计分输入的表单。处理得分提交的JavaScript看起来像这样：
- en: '![Images](p0287-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0287-01.jpg)'
- en: We get the home and away scores from the inputs, use the id from the parent
    function, get the wallet address, and send a transaction to the contract’s `setGameResult`
    ABI function. The callback is again left blank, but can be filled in with code
    in the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从输入框中获取主队和客队的得分，使用父函数的id，获取钱包地址，并向合约的`setGameResult` ABI函数发送交易。回调再次留空，但将来可以填写代码。
- en: To test game scoring, go back to the games page, then navigate over to a game
    that has passed its locktime. Remember, scoring a game before it has locked will
    throw an error and no state changes will occur. The Cleveland-Indiana game will
    be a good one since it was set to lock 30 seconds after the contract was deployed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试游戏计分，回到游戏页面，然后导航到一个已经过了锁定时间的游戏。记住，在游戏锁定之前计分会导致错误，并且不会发生任何状态变化。克利夫兰-印第安纳游戏将是一个很好的选择，因为它是部署合约后30秒内锁定的。
- en: Enter home and away scores into the inputs (e.g., 100 and 98), then submit the
    score. A MetaMask pop-up should appear again. Set the gas price if necessary,
    then click Accept. Wait again for a minute, then reload the page. At the top,
    the final score should now be updated to the score you entered.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输入主队和客队的得分（例如，100和98），然后提交得分。MetaMask弹出窗口应该再次出现。如有必要，设置gas价格，然后点击接受。再次等待一分钟，然后重新加载页面。在顶部，最终得分现在应该更新为您输入的得分。
- en: Withdrawing Money
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提款资金
- en: The winning side of the bet needs some way of accessing the money that belongs
    to them in the contract. The withdrawal ABI function allows a user to withdraw
    the balance of their account.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 投注获胜方需要某种方式来访问他们在合约中应得的钱。提款ABI函数允许用户提取其账户的余额。
- en: 'We will be building a withdraw page to allow users to withdraw their ether.
    Here is the basic HTML:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个提款页面，以便用户可以提取他们的以太币。以下是基本的HTML代码：
- en: '![Images](p0288-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0288-01.jpg)'
- en: Outside of the standard html, body, and script tags, there is a link to the
    games page, a table with rows for a user’s address and balance, and a button to
    allow a user to withdraw their money. The address and balance will be injected
    via JavaScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的html、body和script标签之外，有一个指向游戏页面的链接，一个包含用户地址和余额的表格，以及一个允许用户提款的按钮。地址和余额将通过JavaScript注入。
- en: 'This time we will be following the `withdraw` track in our `switch` statement:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将遵循`withdraw`路径在我们的`switch`语句中：
- en: '![Images](p0289-01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0289-01.jpg)'
- en: Our `withdrawPage` function starts by querying for the user’s balance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`withdrawPage`函数首先通过查询获取用户的余额。
- en: '![Images](p0289-02.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0289-02.jpg)'
- en: We get the wallet address, display it on the page, then use it to call the `balances`
    ABI function. The `balances` function isn’t explicitly stated in the contract,
    but Solidity automatically creates getters for public state variables so it’s
    available. Because it’s a mapping, the default getter requires the key to be passed
    in. We pass in the wallet address as the key, get the balance of the user back,
    and display it on the page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取钱包地址，在页面上显示它，然后使用它来调用`balances` ABI函数。`balances`函数在合约中没有明确声明，但Solidity会自动为公共状态变量创建getter，因此它是可用的。因为这是一个映射，默认的getter需要传递键。我们传递钱包地址作为键，获取用户余额返回，并在页面上显示它。
- en: 'If the user has a non-zero balance, they can withdraw it by clicking the Withdraw
    button. Here’s the event listener code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户有非零余额，他们可以通过点击提款按钮提取。以下是事件监听器的代码：
- en: '![Images](p0289-03.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0289-03.jpg)'
- en: When the user clicks the Withdraw button, we get their wallet address, then
    use the `withdraw` ABI function to withdraw the user’s balance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击提款按钮时，我们获取他们的钱包地址，然后使用`withdraw` ABI函数提取用户的余额。
- en: You can test this out by redeploying the contract, placing multiple bets on
    one of the games that expires in three minutes, then scoring the game once it
    locks. Once you score the game you should see a non-zero balance on the withdraw
    page. Withdraw your money (accept the MetaMask pop-up when it appears), and check
    your balance on MetaMask. If everything works, it should go up!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重新部署合约，在三分钟内到某个游戏中投注多次，然后锁定游戏后计分来测试这个功能。一旦您计分游戏，您应该在提款页面上看到非零余额。提款您的资金（当出现MetaMask弹出窗口时接受它），然后在MetaMask上检查您的余额。如果一切正常，它应该会上升！
- en: Deploying to AWS
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署到AWS
- en: In order for your application to be available publicly on the Internet, you
    will have to deploy the application to a server. For our purposes, we will be
    using Amazon S3 static website hosting to host our front end.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的应用程序在互联网上公开可用，您必须将应用程序部署到服务器上。出于我们的目的，我们将使用Amazon S3静态网站托管服务来托管我们的前端。
- en: For the full application to work, you must first deploy your smart contract
    to the Ethereum Main Net using the steps outlined in “Deploying to the Mainnet”
    earlier in the chapter. If you deployed the contract earlier, then replace the
    contents of the `contract_address` file with the address of the mainnet contract.
    Otherwise, the front end will attempt to access the address of the latest test
    contract deployed instead of the mainnet contract that you want to access.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让整个应用程序运行，您必须首先使用本章前面“部署到主网”步骤中概述的步骤，将您的智能合约部署到以太坊主网。如果您之前已经部署了合约，那么将`contract_address`文件的内容替换为主网合约的地址。否则，前端将尝试访问最新部署的测试合约的地址，而不是您想要访问的主网合约地址。
- en: First, if you don’t have an account with AWS, you will have to create one at
    [https://aws.amazon.com](https://aws.amazon.com). Once you have created an account,
    navigate over to the S3 console. S3 is a cheap storage service for static files.
    We will be using its static web server functionality.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您没有 AWS 账户，您将必须在 [https://aws.amazon.com](https://aws.amazon.com) 创建一个。创建账户后，转到
    S3 控制台。S3 是一种用于静态文件的低成本存储服务。我们将使用其静态网页服务器功能。
- en: Create a new bucket in the console, and give it a name. In the setup dialog,
    in the Set Permissions > Manage Public Permissions section, select the “Grant
    public read access to this bucket” option. This will allow the outside world to
    access our files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中创建一个新桶，并给它一个名字。在设置对话框中，在“设置权限 > 管理公共权限”部分，选择“向这个桶授予公共读取访问权限”选项。这将允许外部世界访问我们的文件。
- en: 'Once you’ve created the bucket, click on the bucket in the main S3 console
    and upload the following files to the bucket:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了桶，请在主 S3 控制台中点击该桶并上传以下文件到该桶：
- en: •   bin/peerbet.sol:PeerBet.abi
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: •   bin/peerbet.sol:PeerBet.abi
- en: •   contract_address
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: •   contract_address
- en: •   index.html
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: •   index.html
- en: •   withdraw.html
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: •   withdraw.html
- en: •   bet.html
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: •   bet.html
- en: •   main.js
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: •   main.js
- en: These are the files that are required to run just the front end of our site.
    The back-end smart contract should already be deployed to the Ethereum Main Net,
    so the back-end and test files will not be required on the static host.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是运行我们网站前端所必需的。后端智能合约应该已经部署到了以太坊主网，因此静态主机上不需要后端和测试文件。
- en: Next, go to the Properties section and click on Static Website Hosting and enable
    it by selecting “Use this bucket to host a website.” Use index.html for the Index
    Page, then save the settings. Your static website is now enabled.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，前往“属性”部分，点击“静态网站托管”并选择“使用此桶托管网站”来启用它。将 index.html 设为首页，然后保存设置。您的静态网站现在已启用。
- en: To view the site, click back on the Static Website Hosting section and go to
    the URL provided in the settings. For the site to work, MetaMask must be connected
    to the main network, so go to the MetaMask network settings and select the Ethereum
    Main Net. Once you have done so, the website should be visible and connected.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看网站，请返回至“静态网站托管”部分，然后访问设置中提供的URL。为了让网站运行，MetaMask 必须连接到主网络，因此请前往 MetaMask
    网络设置并选择以太坊主网。一旦完成，网站应该可以看见并且已经连接。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: If you have read, understood, and tried some of the code in this chapter you
    can now write new scripts to deploy and test your own contracts. You can create
    a contract, and you can create a front end to interact with the contract.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读、理解并尝试了本章中的部分代码，现在您可以编写新脚本来部署和测试您自己的合约。您可以创建一个合约，您还可以创建一个前端来与合约交互。
