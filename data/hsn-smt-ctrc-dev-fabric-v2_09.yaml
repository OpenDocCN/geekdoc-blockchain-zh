- en: Chapter 6\. Testing and Maintenance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。测试与维护
- en: Welcome to the final chapter in [Part III](part03.xhtml#developing_smart_contracts_with_hyperle).
    The life cycle for smart contracts is the same as for other software. Once the
    software is developed, tested, and deployed, our attention transitions to maintenance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第 III 部分](part03.xhtml#developing_smart_contracts_with_hyperle)的最后一章。智能合约的生命周期与其他软件相同。一旦软件开发、测试和部署完成，我们的注意力就转移到维护上。
- en: 'Many activities are performed to test and maintain software throughout its
    life cycle. These activities are grouped into two broad categories: technical
    and nontechnical. Our concern is with the technical activities that modify the
    software. Under maintenance, the modifications are generally either fixing something
    or adding something new. When bugs are discovered, they need to be corrected,
    so a maintenance task is created to fix the bug. When new features or capabilities
    are demanded, a maintenance task is created to add one or more new features to
    the software. Sometimes significant modifications can result in a release of a
    new version of software. This applies also to the clients of smart contracts.
    These activities continue until the software is retired. The majority of the software
    life cycle is consumed by maintenance. When fixing bugs or adding new features,
    testing is critical to success.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多活动都是为了测试和维护软件的整个生命周期。这些活动分为两大类：技术和非技术。我们关注的是修改软件的技术活动。在维护期间，修改通常是修复问题或添加新内容。当发现错误时，需要纠正它们，因此会创建一个维护任务来修复错误。当要求新功能或能力时，会创建一个维护任务来向软件添加一个或多个新功能。有时，重大修改可能会导致发布新版本的软件。这也适用于智能合约的客户。这些活动会持续到软件被淘汰。大部分软件生命周期都被维护消耗掉。在修复错误或添加新功能时，测试对于成功至关重要。
- en: Throughout the entire life cycle, including both development and maintenance,
    the activity of testing is relied upon to ensure that the software is working
    as expected and meets the functional and nonfunctional requirements. Testing can
    be executed in many ways, and several schools of thought exist on how to approach
    and implement testing. Whichever school you adhere to will work well for smart
    contract development and maintenance. Testing can be formal, not formal, or a
    combination of both. The choice is yours.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个生命周期中，包括开发和维护阶段，测试活动被依赖于以确保软件按预期工作并满足功能和非功能要求。测试可以以许多方式执行，关于如何进行测试有几种不同的学派存在。无论你遵循哪种学派，都会对智能合约的开发和维护产生良好的效果。测试可以是正式的、非正式的，或者两者的结合。选择权在你手中。
- en: This chapter is divided into four distinct sections. The first section presents
    a smart contract maintenance task, which adds a web UI to the Fabcar smart contract.
    We provide the code, which gives you a working example of a web UI client application.
    The *fabric-samples* and SDKs do not offer any web UI samples. Instead, command-line
    clients are provided. We provide you with a web UI smart contract client to jumpstart
    your smart contract client development and serve as an example of a smart contract
    maintenance task. With a web UI client, you can perform end-to-end testing of
    your smart contract. Most smart contracts you develop will require one or more
    web UI clients. You test smart contract web UI clients just as you would any other
    web UI client. Testing smart contracts can be slow and difficult, using *test-network*.
    When testing smart contracts, especially prior to system or integration testing,
    you will want a way to iterate quickly as you build out your smart contract API,
    represented by your smart contract functions or transactions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为四个不同的部分。第一部分介绍了一个智能合约维护任务，该任务将一个 Web UI 添加到 Fabcar 智能合约中。我们提供了代码，为您提供了一个可工作的
    Web UI 客户端应用程序示例。*fabric-samples* 和 SDKs 并没有提供任何 Web UI 示例。相反，提供了命令行客户端。我们为您提供了一个
    Web UI 智能合约客户端，以启动您的智能合约客户端开发，并作为智能合约维护任务的示例。使用 Web UI 客户端，您可以对智能合约进行端到端测试。您开发的大多数智能合约都需要一个或多个
    Web UI 客户端。您可以像测试其他 Web UI 客户端一样测试智能合约 Web UI 客户端。使用 *test-network* 测试智能合约可能会很慢，很困难。特别是在系统或集成测试之前，您希望有一种快速迭代的方式来构建智能合约
    API，该 API 由您的智能合约功能或交易表示。
- en: The second section walks you through a setup for rapidly testing smart contracts.
    This setup has a lot of steps, but delivers a way to rapidly and iteratively test
    smart contracts without the need to launch the test network and go through the
    time-consuming stop-deploy-start development cycle. With the method you will learn
    in this section, testing your smart contract functions is fast and easy. However,
    other system components (such as the peers, orderers, and databases) support your
    smart contract functions, and testing these components can be problematic. You
    will need to access these components’ log files to view and understand their output
    while you test your smart contract functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分将指导您设置快速测试智能合约的环境。这个设置有很多步骤，但提供了一种快速迭代测试智能合约的方式，而不需要启动测试网络并经历耗时的停止-部署-启动开发周期。通过本节将学到的方法，测试智能合约功能快速简单。然而，其他系统组件（如对等方、排序器和数据库）支持您的智能合约功能，测试这些组件可能会有问题。在测试智能合约功能时，您需要访问这些组件的日志文件以查看和理解它们的输出。
- en: In the third section, you’ll learn about the available logs provided by the
    various components. You can use these logs, provided by Hyperledger Fabric, to
    help support your development, maintenance, and testing activities. In the fourth
    and final section, you’ll learn about unit testing, which is essential for maintaining
    code quality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三节中，您将了解各种组件提供的可用日志。您可以使用Hyperledger Fabric提供的这些日志来帮助支持您的开发、维护和测试活动。在第四个和最后一个部分中，您将了解单元测试，这对于维护代码质量至关重要。
- en: 'This chapter will help you achieve the following practical goals:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您实现以下实际目标：
- en: Handling errors and processing responses in Fabric applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fabric应用程序中处理错误和处理响应
- en: Testing and debugging a Fabric smart contract
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试Fabric智能合约
- en: Running unit tests on Fabric smart contracts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fabric智能合约上运行单元测试
- en: Following best practices for identifying and reviewing logs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循识别和审查日志的最佳实践
- en: Creating a Fabcar UI Client
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Fabcar UI客户端
- en: The Fabcar smart contract has no web UI client, so for an example maintenance
    exercise, we added one. We have already created the client for you by consolidating
    the Fabcar command-line executables into a web UI application client. You can
    download the client code from [*https://myhsts.org/hyperledger-fabric-book/*](https://myhsts.org/hyperledger-fabric-book/).
    Then follow along as we go through the code in this section to show you how easy
    it is to add a web client to a smart contract. Before we dive into the code, let’s
    discuss handling error responses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar智能合约没有Web UI客户端，因此，在一个示例维护练习中，我们添加了一个。我们已经通过将Fabcar命令行可执行文件合并到Web UI应用程序客户端中为您创建了客户端。您可以从[*https://myhsts.org/hyperledger-fabric-book/*](https://myhsts.org/hyperledger-fabric-book/)下载客户端代码。然后，跟随我们在本节中的代码进行，以向您展示如何轻松地将Web客户端添加到智能合约中。在我们深入代码之前，让我们讨论一下处理错误响应。
- en: Error Response Handling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误响应处理
- en: Fabric can be deployed on premises or to the cloud, or in a hybrid architecture.
    Where Fabric is deployed should not change the expected error or success responses.
    If misconfigurations exist, error responses will be received. We will see some
    error and success responses later in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric可以部署在本地或云端，或者采用混合架构。Fabric的部署位置不应更改预期的错误或成功响应。如果存在配置错误，则会收到错误响应。我们将在本节的后面看到一些错误和成功的响应。
- en: The same best practices for handling error and success responses in web and
    software development should be practiced. Catch your errors, augment them with
    additional information if available, and present the error or response to the
    user in a readable and understandable format. Errors should be logged for analysis
    and correction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应该采用与Web和软件开发中处理错误和成功响应相同的最佳实践。捕获您的错误，如果有额外信息可用，则增加它们，并以可读和可理解的格式向用户呈现错误或响应。错误应记录以进行分析和更正。
- en: Most of the error handling for smart contracts is transparent and encapsulated
    in the SDKs and middleware that together form a cohesive distributed network and
    application architecture. This distributed architecture can be constructed with
    virtual technology like Docker, which provides flexibility in designing, operating,
    and managing the application and the way the responses behave. Fabric provides
    a virtualized architecture and operating environment suitable for developing smart
    contracts on a single laptop, cloud environment, or custom environment. The approach
    you choose and the tools you decide to use will vary with your personal preferences
    and provided resources, but the expected responses should be consistent across
    all environments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数智能合约的错误处理是透明的，并封装在一起形成一个连贯的分布式网络和应用架构的 SDK 和中间件中。这种分布式架构可以使用诸如 Docker 等虚拟技术构建，该技术在设计、操作和管理应用程序以及响应行为方面提供了灵活性。Fabric
    提供了一个适用于在单个笔记本电脑、云环境或自定义环境上开发智能合约的虚拟化架构和操作环境。您选择的方法和工具将取决于个人偏好和提供的资源，但预期的响应应在所有环境中保持一致。
- en: We used JavaScript and Node.js to implement the web UI application, which we
    named *fabcar-ui*. Regardless of the client framework, responses will be the same
    across SDKs. The language selected for the smart contract development is independent
    from the language selected for the smart contract client and should not change
    the responses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 JavaScript 和 Node.js 实现了 Web UI 应用程序，我们将其命名为 *fabcar-ui*。无论客户端框架如何，SDK
    的响应都将相同。用于智能合约开发的语言与用于智能合约客户端的语言无关，并且不应更改响应。
- en: By designing enterprise application APIs, we can establish contract interfaces
    between our smart contracts and clients, providing a blueprint for what responses
    should look like and how to handle error responses. We can even extend this effort
    to the design of smart contract–specific APIs packaged into application libraries
    to be used by new and existing enterprise applications defining the expected error
    and success responses. This makes maintenance and testing much easier, consistent,
    and repeatable. This type of standardization supports the ability to extend the
    smart contract response to existing applications as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计企业应用程序 API，我们可以在我们的智能合约和客户端之间建立合同接口，为响应的外观和错误响应处理提供蓝图。我们甚至可以将这一工作延伸到设计特定于智能合约的
    API，打包成应用程序库，供新的和现有的企业应用程序使用，定义期望的错误和成功响应。这使得维护和测试变得更加容易、一致和可重复。这种标准化支持将智能合约响应扩展到现有应用程序的能力。
- en: Fabcar UI Web Pages
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabcar UI 网页
- en: The interface of the Fabcar UI is focused on simplicity. It takes the Fabcar
    smart contract client application executables and wraps them in a web GUI. We
    did not want to change any of the functional code and wanted to keep the separation
    of the executable’s function. We wanted to end up with a simple web app that you
    can extend, experiment with, and potentially use as a test harness, as well as
    provide you with an example of a simple smart contract web application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar UI 的界面着重于简洁。它将 Fabcar 智能合约客户端应用程序可执行文件包装在 Web GUI 中。我们不想改变任何功能代码，并且希望保持可执行文件功能的分离。我们希望最终得到一个简单的
    Web 应用程序，您可以扩展、实验，并且可能用作测试工具，同时也为您提供一个简单的智能合约 Web 应用程序示例。
- en: With Node.js as our client platform, we selected the popular and easy-to-use
    Express framework. Express makes it easy to create small web applications. For
    a production application, frameworks like Angular, React, or Vue.js will work
    too. Applications can leverage the smart contract service via an enterprise published
    API. This allows for controlled maintenance and testing to ensure quality control.
    Let’s take a look at the Fabcar UI web pages. [Figure 6-1](#fabcar_ui_main_page)
    shows the main page.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的客户端平台的 Node.js，我们选择了流行且易于使用的 Express 框架。Express 使创建小型 Web 应用程序变得简单。对于生产应用程序，像
    Angular、React 或 Vue.js 这样的框架也可以使用。应用程序可以通过企业发布的 API 利用智能合约服务。这允许进行受控维护和测试，以确保质量控制。让我们来看看
    Fabcar UI 的 Web 页面。[图 6-1](#fabcar_ui_main_page) 显示了主页。
- en: '![Fabcar UI main page](Images/HLF_0601.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar UI 主页](Images/HLF_0601.png)'
- en: Figure 6-1\. Fabcar UI main page
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. Fabcar UI 主页
- en: This simple web page displays the application menu and instructions for using
    the Fabcar UI. Looking at the menu bar, you can see a menu item for each of the
    Fabcar smart contract command-line applications we explored in [Chapter 5](ch05.xhtml#smart_contract_invocation).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的网页显示了应用菜单和使用 Fabcar UI 的说明。查看菜单栏，您可以看到我们在 [第五章](ch05.xhtml#smart_contract_invocation)
    中探讨的每个 Fabcar 智能合约命令行应用程序的菜单项。
- en: On the far right is a menu item labeled API. We called it API to be generic,
    because it loads a page for calling our new smart contract function, `callApi`.
    We will implement this new function in a bit, but before we do, we will use the
    Fabcar UI to call the nonexistent function and see the error response returned.
    Then we will implement it and see the successful response.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最右侧有一个标记为 API 的菜单项。我们称之为 API 是为了通用性，因为它加载一个用于调用我们的新智能合约函数 `callApi` 的页面。我们稍后会实现这个新函数，但在实现之前，我们将使用
    Fabcar UI 调用不存在的函数，并查看返回的错误响应。然后我们将实现它并看到成功的响应。
- en: Reading the instructions displayed on the main page, you can see that the Fabcar
    smart contract sequence of execution is retained and mandatory, as it was in the
    command-line version. The goal of the Fabcar UI web app is to mirror the command-line
    app, but with a web UI, and keep it simple, so the separation between the web
    application code and the code specific to the Fabcar smart contract is clean.
    This design facilitates the ability to quickly iterate and add new functions and
    features, potentially becoming a test harness.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读主页面显示的说明，您可以看到 Fabcar 智能合约执行顺序与命令行版本中保持一致且是强制性的。Fabcar UI Web 应用的目标是镜像命令行应用，但具有
    Web UI，并保持简单，以使 Web 应用代码与 Fabcar 智能合约特定代码之间的分离清晰。这种设计有助于快速迭代和添加新功能和特性，潜在地成为测试工具。
- en: 'The UI interface of *fabcar-ui* is responsive and will work on any device capable
    of running a modern browser. All of the web pages are designed with the same layout:
    a menu, a button, and text display for instructions and responses. The responses
    are displayed in text without any formatting. Let’s review each page, starting
    with Enroll Admin. We will not display all the pages because they are similar.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*fabcar-ui* 的用户界面响应灵敏，可在任何能够运行现代浏览器的设备上运行。所有网页都采用相同的布局设计：一个菜单，一个按钮，以及用于指导和响应的文本显示。响应以文本形式显示，没有任何格式。让我们逐个审查每个页面，从注册管理员开始。我们不会展示所有页面，因为它们都是类似的。'
- en: Enroll Admin
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册管理员
- en: We add the Enroll Admin page to our *fabcar-ui*. Clicking the Enroll Admin button
    will execute the `enroll` transaction request. The other pages—Register User,
    Invoke, Query, and API—look and function similar to the Enroll Admin page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册管理员页面添加到我们的*fabcar-ui*中。单击注册管理员按钮将执行`enroll`事务请求。其他页面——注册用户、调用、查询和API——看起来和功能类似于注册管理员页面。
- en: Register User
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册用户
- en: 'The Register User page functions like the Enroll Admin page. Clicking the Register
    User button executes the `register` function, which uses `Admin` to register the
    user. This is why we need to execute the Enroll Admin page first. Here is the
    successful response displayed after clicking the button:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注册用户页面的功能类似于注册管理员页面。单击注册用户按钮将执行`register`函数，该函数使用`Admin`来注册用户。这就是我们为什么需要首先执行注册管理员页面的原因。单击按钮后显示的成功响应如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Invoke
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用
- en: Now with the `Admin` and `User` identities in the `wallet`, we can execute the
    `invoke` and `query` functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`wallet`中具有`Admin`和`User`身份，我们可以执行`invoke`和`query`函数。
- en: 'When we click the Invoke button, we execute the `invoke` request. This request
    will call the Fabcar smart contract `invoke` transaction. This transaction adds
    a record to the ledger. Here is the successful response displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单击调用按钮时，我们执行`invoke`请求。此请求将调用 Fabcar 智能合约的`invoke`事务。此事务将记录添加到账本中。以下是成功响应显示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `invoke` function can be executed multiple times.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke`函数可以被多次执行。'
- en: Query
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: The Query page will display the records from the ledger, which contain the records
    added by `invoke`. Clicking the Query button will display the records.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查询页面将显示账本中的记录，其中包含由 `invoke` 添加的记录。单击查询按钮将显示记录。
- en: The `invoke` function on the client side generates a random number and appends
    it to the string `CAR0.`, so we can exercise the `invoke` transaction multiple
    times and see a unique response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的 `invoke` 函数生成一个随机数并将其附加到字符串 `CAR0.`，这样我们就可以多次执行 `invoke` 交易并看到一个唯一的响应。
- en: API
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API
- en: The final page is the API page. It too has a button and displays a text response.
    When the button is clicked, the `callApi` request is executed, which calls the
    `callApi` smart contract transaction. We have not added the `callApi` transaction
    to the Fabcar smart contract, so we will get an error response when we click the
    API button.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最终页面是 API 页面。它也有一个按钮并显示一个文本响应。当点击按钮时，将执行 `callApi` 请求，该请求调用 `callApi` 智能合约交易。我们尚未将
    `callApi` 交易添加到 Fabcar 智能合约中，因此当我们点击 API 按钮时，我们将收到一个错误响应。
- en: Now that we have looked at the web pages of the Fabcar UI web application, let’s
    review the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了 Fabcar UI web 应用程序的网页，让我们来审查一下代码。
- en: Fabcar UI Code
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabcar UI 代码
- en: We won’t review all the code in detail because we covered the smart contract–related
    code in [Chapter 5](ch05.xhtml#smart_contract_invocation). What we want to focus
    on is the new code, so you can modify or extend it to learn or for your own purpose.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细查看所有代码，因为我们在[第五章](ch05.xhtml#smart_contract_invocation)中已经涵盖了与智能合约相关的代码。我们想要关注的是新代码，这样你就可以修改或扩展它以学习或为自己的目的使用。
- en: 'We developed the Fabcar UI web application with Node.js, Express, and Jade,
    a templating tool. The main file is *app.js*, which is executed with Node.js like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Node.js、Express 和 Jade（一种模板工具）开发了 Fabcar UI web 应用程序。主文件是 *app.js*，可以像这样使用
    Node.js 执行：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This starts up a web server and listens on localhost and port 3000\. Once it’s
    started, you can open a browser and go to *http://localhost:3000* to display the
    Fabcar UI main page. The main file, *app.js*, contains the Express setup, the
    application `views`, which are the pages we reviewed, and the `actions`, which
    are executed by the buttons. The buttons call the `actions`, and the `actions`
    map to `handlers` that execute the smart contract client code. Let’s take a look
    at *app.js*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这会启动一个 web 服务器并监听 localhost 和端口 3000。一旦启动，你可以打开浏览器并访问 *http://localhost:3000*
    来显示 Fabcar UI 的主页面。主文件 *app.js* 包含 Express 设置，应用程序的 `views`（我们查看的页面），以及 `actions`（由按钮执行）。按钮调用
    `actions`，而 `actions` 映射到执行智能合约客户端代码的 `handlers`。让我们来看看 *app.js*。
- en: 'The code begins by importing the `handlers—`one for each function. Each function
    is the code from the Fabcar client command-line version. Following the imports,
    we set up Express to point to our `views` that represent our pages and to our
    public directory that contains public resources like Bootstrap and CSS files.
    Here is the code that loads the `handlers` and sets up Express:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始时导入了`handlers`——每个函数一个。每个函数都是来自Fabcar客户端命令行版本的代码。在导入之后，我们设置Express指向我们的`views`，表示我们的页面，以及包含公共资源（如Bootstrap和CSS文件）的公共目录。以下是加载`handlers`并设置Express的代码：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next we have the `views`. With Express, one easy way to handle requests is
    to map them to a `view` and then render the `view` when the request is received.
    We implemented our `views` in a templating language called Jade. It’s a simple
    text-based markup language to simplify and reduce the verbosity of HTML. The page
    is responsive and uses Bootstrap with CSS to facilitate our visual style and menu.
    Here is the code that maps a request to a view that is rendered as a web page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`views`。使用Express，处理请求的一种简单方法是将它们映射到一个`view`，然后在收到请求时呈现该`view`。我们使用了一个名为Jade的模板语言来实现我们的`views`。这是一种简单的基于文本的标记语言，用于简化和减少HTML的冗长。页面具有响应式设计，并使用Bootstrap与CSS来促进我们的视觉风格和菜单。以下是将请求映射到作为网页呈现的视图的代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `views`, we mapped the `actions` by using the same simple design
    pattern. The `actions` call the `handlers`, which encapsulate the code from the
    command-line Fabcar smart contract client. These `actions` carry out an asynchronous
    design pattern. The request is received from the `view` when a user clicks a view
    button and then calls the smart contract and renders the response from the smart
    contract. Here is the code implementing the actions, which call the smart contract
    and render the response:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views`之后，我们使用相同的简单设计模式映射了`actions`。`actions`调用`handlers`，这些`handlers`封装了来自命令行Fabcar智能合约客户端的代码。这些`actions`执行异步设计模式。当用户点击一个视图按钮时，会从`view`接收请求，然后调用智能合约并呈现智能合约的响应。以下是实现`actions`的代码，它调用智能合约并呈现响应：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The *app.js* code ends by setting the port for the server to listen on, printing
    a message to the console, and exiting:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*app.js*代码最后设置服务器监听的端口，将消息打印到控制台，然后退出：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `view` file is displayed when a page request is received. The view is rendered,
    and when a button is clicked, a request for an `action` is sent by the page and
    received by *app.js*, where it is processed by one of the `handler` files. The
    `handler` files encapsulate the code from the command-line Fabcar smart contract
    client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到页面请求时，会显示一个`view`文件。视图被呈现，当按钮被点击时，页面会发送一个`action`的请求，并被*app.js*接收，然后由其中的一个`handler`文件进行处理。`handler`文件封装了来自命令行Fabcar智能合约客户端的代码。
- en: 'All the `view` files use the same code template as shown here but vary their
    data where appropriate (for example, in `h1` or `href`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`view`文件都使用与此处显示的相同的代码模板，但根据需要变化其数据（例如，在`h1`或`href`中）：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When a `view` button is clicked, the `action` is called. The link is mapped
    in the *app.js* file to a `handler` that implements the `action`, which is one
    of the functions the command-line Fabcar smart contract client executed. Each
    executable has been taken from the Fabcar smart contract command-line client and
    refactored to a Node.js module, which can be imported and provides functions to
    call.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`view`按钮时，将调用`action`。链接在*app.js*文件中映射到一个`handler`，该`handler`实现了`action`，这是命令行Fabcar智能合约客户端执行的函数之一。每个可执行文件都是从Fabcar智能合约命令行客户端中提取并重构为Node.js模块，可以被引入并提供调用函数。
- en: The same techniques were used for each handler. The main function was replaced
    and refactored to a module. This provides the module name as a reference to this
    function, which is called in *app.js* when the request is received as a result
    of clicking the button in the view. A variable was added, called `result`, to
    hold the response returned to the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个`handler`都使用了相同的技术。`main`函数被替换并重构为一个模块。这提供了模块名作为对此函数的引用，在*app.js*中接收到点击按钮请求的时候调用该函数。添加了一个变量，叫做`result`，用于保存返回给客户端的响应。
- en: We set the `result` variable with the success response we will return to the
    client. We commented out `process.exit(1)`, because we don’t want to exit the
    process, which is our web server. Then we set an error response to return to the
    client when an error occurs. Lastly, we replace the `main` function with the return
    `result`. Now the executable is a Node.js module that we can import to call the
    function. We performed these tasks for all executables, turning each into a module.
    This was easy because the executables were self-contained and independent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用成功的响应信息设置了`result`变量，将返回给客户端。我们注释掉了`process.exit(1)`，因为我们不想退出进程，这就是我们的Web服务器。然后我们设置了出现错误时返回给客户端的错误响应。最后，我们用`result`替换了`main`函数。现在可执行文件是一个Node.js模块，我们可以引入来调用该函数。我们为所有可执行文件执行了这些任务，将每个都转换为一个模块。这很容易，因为这些可执行文件是相互独立且自包含的。
- en: 'This completes the code review portion. The separation of functions is clean.
    The handlers are where the smart contract–related code is implemented. These could
    be mocked and developed independently of the smart contract. As with the command-line
    Fabcar smart contract client, the *package.json* file contains the two Fabric
    SDK dependencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了代码审查部分。函数的分离是清晰的。`handlers`是实现智能合约相关代码的地方。这些可以独立于智能合约进行模拟和开发。与命令行Fabcar智能合约客户端一样，*package.json*文件包含了两个Fabric
    SDK依赖项：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The *wallet* subdirectory works the same as it does in the command-line Fabcar
    smart contract client. When you execute `Enroll Admin,` an `Admin` identity is
    created and placed in the *wallet* subdirectory. When you execute `Register User`,
    an `appUser` identity is created and placed in the *wallet* subdirectory. Each
    time you start the test network, you must ensure that these identities are removed
    from the *wallet* subdirectory. If either identity is found, the client will print
    an error response to the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*wallet* 子目录的工作方式与命令行 Fabcar 智能合约客户端相同。当你执行`Enroll Admin`时，会创建一个`Admin`身份并放置在
    *wallet* 子目录中。当你执行`Register User`时，会创建一个`appUser`身份并放置在 *wallet* 子目录中。每次启动测试网络时，你必须确保这些身份已从
    *wallet* 子目录中删除。如果发现任何一个身份，客户端将在控制台打印错误响应：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This completes our coverage of Fabcar UI web pages and code. Now let’s execute
    *fabcar-ui* and look at responses we can receive.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 Fabcar UI 网页和代码的覆盖。现在让我们执行 *fabcar-ui* 并查看我们可以收到的响应。
- en: Fabcar UI Execution
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabcar UI 执行
- en: 'If you have a test network up, we want to shut it down for this task. To shut
    down the test network, execute *`networkDown.sh`* located in the *fabcar* subdirectory.
    Keep the terminal open, because we will start the test network after looking at
    the error responses we will receive when it’s shut down. Open another terminal,
    go to the *fabcar-ui* subdirectory, and execute this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个测试网络在运行，我们想要关闭它以完成此任务。要关闭测试网络，请在 *fabcar* 子目录中执行 *`networkDown.sh`*。保持终端打开，因为我们将在查看关闭测试网络时收到的错误响应后重新启动测试网络。打开另一个终端，进入
    *fabcar-ui* 子目录，并执行以下操作：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When this finishes, execute the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当这完成时，执行以下操作：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now open your browser and go to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的浏览器并转到以下位置：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should see the Fabcar UI main page. Click the API menu item and then click
    the API button. You should see the failed response shown in [Figure 6-2](#fabcar_ui_callapi_error_response_page).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 Fabcar UI 主页。点击 API 菜单项，然后点击 API 按钮。你应该看到如下所示的失败响应，参见[图 6-2](#fabcar_ui_callapi_error_response_page)。
- en: '![Fabcar UI callApi error response page](Images/HLF_0602.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar UI 调用 API 错误响应页面](Images/HLF_0602.png)'
- en: Figure 6-2\. Fabcar UI `callApi` error response page
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. Fabcar UI `callApi` 错误响应页面
- en: 'In the console, you should see the following result:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，你应该看到以下结果：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is an indication the test network is not up. Now in the terminal where
    you shut down *test-network*, make sure you are in the *fabcar* client subdirectory
    and start the test network by executing the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明测试网络没有启动。现在在你关闭 *test-network* 的终端中，确保你在 *fabcar* 客户端子目录中，并执行以下操作启动测试网络：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the test network is up and running, let’s perform the same test: click
    the API menu item and then the API button. [Figure 6-3](#fabcar_ui_failed_enroll_admin_page)
    shows the result.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试网络启动并运行，让我们执行相同的测试：点击 API 菜单项，然后点击 API 按钮。[图 6-3](#fabcar_ui_failed_enroll_admin_page)显示了结果。
- en: '![Fabcar UI failed enroll admin page](Images/HLF_0603.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar UI 失败的注册管理员页面](Images/HLF_0603.png)'
- en: Figure 6-3\. Fabcar UI failed `enroll admin` page
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. Fabcar UI 失败的`enroll admin`页面
- en: 'You should see this in your console:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的控制台中看到这个：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This indicates a problem with the admin identity. We receive this because we
    started a test network that removes all prior artifacts, so the identities we
    have in our client wallet are not valid. Delete the two identities in the Fabcar
    UI *wallet* subdirectory and then execute the Enroll Admin and Register User requests.
    Then try the API request again. [Figure 6-4](#fabcar_ui_page_indicating_callapi_funct)
    shows the response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示管理员身份存在问题。我们收到这个消息是因为我们启动了一个测试网络，删除了所有先前的工件，所以我们在客户钱包中拥有的身份是无效的。在 Fabcar
    UI 的*钱包*子目录中删除两个身份，然后执行注册管理员和注册用户请求。然后再尝试 API 请求。[图 6-4](#fabcar_ui_page_indicating_callapi_funct)显示了响应。
- en: '![Fabcar UI page indicating callApi function does not exist](Images/HLF_0604.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar UI 页面指示 callApi 函数不存在](Images/HLF_0604.png)'
- en: Figure 6-4\. Fabcar UI page indicating `callApi` function does not exist
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. Fabcar UI 页面指示`callApi`函数不存在
- en: 'In your console, you should see the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的控制台中，您应该看到以下内容：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This response indicates that the Fabcar smart contract has no function by the
    name `callApi`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应表示 Fabcar 智能合约中没有名为`callApi`的函数。
- en: We need to implement it in the Fabcar smart contract. This is the type of error
    response you will receive when a client calls a transaction that does not exist.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Fabcar 智能合约中实现它。当客户端调用不存在的交易时，您将收到此类型的错误响应。
- en: Since we are going to extend the Fabcar smart contract with a new function named
    `callApi`, it would be great if we had a way to quickly test the new function
    without requiring the test network to be stopped and started with each iteration,
    or the need to go through the deployment process discussed in earlier chapters.
    Well, there is a way, and it will allow quick iteration. Several setup steps are
    required, but in the end it is well worth the effort. Let’s get started.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在 Fabcar 智能合约中扩展一个名为`callApi`的新功能，所以如果我们有一种方法可以快速测试新功能而不需要在每次迭代时停止和启动测试网络，或者需要经过前几章讨论的部署过程，那将是很好的。好吧，有一种方法，它将允许快速迭代。需要进行几个设置步骤，但最终努力值得。让我们开始吧。
- en: Performing Rapid Smart Contract Testing
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行快速智能合约测试
- en: Hyperledger Fabric v2 provides the test network. It includes all of the basic
    required components—for example, all Docker files, organization-related configuration,
    and scripts to install and deploy smart contracts. Developers can create applications
    and test smart contracts by using the test network, but using it can be slow.
    In this section, you’ll learn how to create an alternative development environment
    for rapidly testing the smart contract.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric v2 提供了测试网络。它包括所有基本所需的组件——例如，所有 Docker 文件、与组织相关的配置和安装和部署智能合约的脚本。开发人员可以使用测试网络创建应用程序并测试智能合约，但使用它可能会很慢。在本节中，您将学习如何为快速测试智能合约创建替代开发环境。
- en: Setting Up
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: First, shut down the test network because we will get port conflicts if we do
    not. Remember, you use *`networkdown.sh`* in the *fabcar* client subdirectory
    to shut down the test network. Once it is shut down, create a new directory in
    *fabric-samples* called *fabcar-debug* and change to that directory. Then download
    Fabric version 2.3 (or the version you are working with) from [*https://github.com/hyperledger/fabric*](https://github.com/hyperledger/fabric),
    and unzip it and copy it to *fabcar-debug*. All of our commands will be executed
    from this subdirectory, so keep this in mind as we progress through the several
    steps required to set up our smart contract testing and debugging environment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关闭测试网络，否则会出现端口冲突。记住，在 *fabcar* 客户端子目录中使用 *`networkdown.sh`* 命令关闭测试网络。一旦关闭，创建一个名为
    *fabcar-debug* 的新目录，并切换到该目录。然后从 [*https://github.com/hyperledger/fabric*](https://github.com/hyperledger/fabric)
    下载 Fabric 版本 2.3（或你正在使用的版本），解压并复制到 *fabcar-debug* 目录中。所有命令都将在这个子目录中执行，请在设置智能合约测试和调试环境所需的几个步骤时牢记这一点。
- en: Start the orderer
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 orderer
- en: 'From the subdirectory in *fabcar-debug* that contains the downloaded Fabric
    code, execute the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含下载的 Fabric 代码的 *fabcar-debug* 子目录中，执行以下操作：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When this command completes, there will be a new *build/bin* subdirectory.
    It contains the binaries we just built. We want to place this subdirectory on
    our path, so execute this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当该命令完成后，将会有一个新的 *build/bin* 子目录。其中包含我们刚刚构建的二进制文件。我们希望将此子目录添加到我们的路径中，请执行以下操作：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A sample configuration is provided that we can leverage, so we want to set
    an environment variable so the tools can locate that configuration. Execute this
    command to set the environment variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个示例配置，可以利用它，因此我们要设置一个环境变量，以便工具可以找到该配置。执行以下命令设置环境变量：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we need to generate a genesis block. It will be used by the orderer we
    will start next. To generate the genesis block, execute this command, all on one
    line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要生成一个创世区块。它将被我们接下来要启动的 orderer 使用。要生成创世区块，请执行以下命令，确保所有内容在一行上：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see this at the end of the output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾，你应该看到这个内容：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we are almost ready to start the orderer. But first, we need to create
    the *hyperledger* subdirectory in the *var* subdirectory. This is a location Fabric
    uses. To create the *hyperledger* subdirectory, execute these commands, replacing
    the question marks with your username:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好启动 orderer 了。但首先，我们需要在 *var* 子目录下创建 *hyperledger* 子目录。这是 Fabric 使用的一个位置。要创建
    *hyperledger* 子目录，请执行以下命令，并用你的用户名替换问号：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can start the orderer:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动 orderer 了：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you get port conflicts, you can execute this command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现端口冲突，可以执行以下命令：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will list the TCP ports in use. The two ports you may have conflicts with
    are 8443 and 9443\. If you do, just change the port in conflict to 19443 or 18443
    in the *orderer.yaml* file located in the *sampleconfig* subdirectory. Look for
    `ListenAddress` in the `Operations` and `Admin` sections of the file to find the
    port. With the orderer running, it’s time to start our peer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出正在使用的TCP端口。 您可能与冲突的两个端口是8443和9443。 如果是这样，只需在*sampleconfig*子目录中的*orderer.yaml*文件中将冲突的端口更改为19443或18443。
    查找文件中的`Operations`和`Admin`部分以找到端口。 订单者运行后，是时候启动我们的同伴了。
- en: Start the peer
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动同伴
- en: 'We need to start our peer in another terminal. Open another terminal and change
    to the Fabric subdirectory we are working in. Just as with the orderer, we need
    to set up our environment, so execute the commands to set the `PATH` and `FABRIC_CFG_PATH`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在另一个终端中启动我们的同伴。 打开另一个终端并切换到我们正在工作的Fabric子目录。 就像订购者一样，我们需要设置我们的环境，因此执行命令来设置`PATH`和`FABRIC_CFG_PATH`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now start the peer by executing, on one line, the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过执行以下命令的一行来启动同伴：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You may get this error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到这个错误：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can fix it by changing the port to 19443 in the *core.yaml* file located
    in the *sampleconfig* subdirectory. Look for the `Operations` section and `ListenAddress`
    to find the port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在位于*sampleconfig*子目录中的*core.yaml*文件中将端口更改为19443来修复它。查找`Operations`部分和`ListenAddress`以找到端口。
- en: 'When the peer is started, you should see this message near the end of the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当同伴启动时，你应该会在输出的末尾看到这条消息：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a channel and join the peer
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个通道并加入同伴
- en: 'With the orderer and peer running, we need to open a third terminal and execute
    some deployment commands. So open a third terminal, change to the Fabric subdirectory
    we are working in, and set our two environment variables:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着订购方和同伴运行，我们需要打开第三个终端并执行一些部署命令。 因此，打开第三个终端，切换到我们正在工作的Fabric子目录，并设置我们的两个环境变量：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we can execute the next step, which is to create our channel and join
    the peer. Execute this command, all on one line, which generates the create channel
    transaction:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以执行下一步，即创建我们的通道并加入同伴。 执行此命令，全部在一行上，生成创建通道事务：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see this at the end of the output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾你应该会看到这个：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then execute this command, which will create the channel:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行此命令，它将创建通道：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see this at the end of the output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾你应该会看到这个：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we join the peer by executing this command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过执行此命令加入同伴：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see at the end of the output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾你应该会看到这个：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The peer is now a member of the channel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同伴现在是通道的成员。
- en: Build and run the chaincode
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建并运行链码
- en: At this point, we can build our chaincode, start it, approve it, and commit
    it. Once we execute these final steps, we can stop and start a smart contract,
    and invoke its transactions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以构建我们的链码，启动它，批准它并提交它。 一旦我们执行了这些最后的步骤，我们就可以停止和启动智能合约，并调用其事务。
- en: 'To build the chaincode used to make this setup work, execute this command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建用于使此设置工作的链码，请执行以下命令：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the command finishes, start the chaincode by executing this command, all
    on one line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令完成时，通过执行以下命令，全部写在一行上，启动链码：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Approve and commit the chaincode
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批准并提交链码
- en: 'Leave the chaincode running and open a fourth terminal that we will use to
    approve, commit, and execute the chaincode. In the fourth terminal, set our two
    environment variables:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让链码保持运行状态，打开第四个终端，我们将在其中批准、提交和执行链码。在第四个终端中，设置我们的两个环境变量：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now execute the three following commands, each on one line, that will approve,
    check the commit readiness of, and commit the chaincode:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下三个命令，每个都写在一行上，它们将批准、检查链码的提交准备情况，并提交链码：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All of these steps need to be executed only once. We can now execute transactions,
    stop and start smart contracts, and stop and start the orderer and peer. We can
    close and open new terminals. But for each new terminal, we need to set the `PATH`
    and `FABRIC_CFG_PATH` environment variables to point to the *build/bin* directory
    and the *sampleconfig* configuration directory. Using absolute paths and setting
    these in your shell configuration eliminates the need to set these each time a
    terminal is opened for use in this task. The directory used to set this up contains
    the created artifacts that let you reuse this setup when you need to.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤只需执行一次。现在我们可以执行交易，停止和启动智能合约，停止和启动排序者和对等体。我们可以关闭并打开新的终端。但对于每个新的终端，我们需要设置`PATH`和`FABRIC_CFG_PATH`环境变量，将其指向*build/bin*目录和*sampleconfig*配置目录。使用绝对路径并将其设置在您的shell配置中，可消除每次打开终端用于此任务时都需要设置这些环境变量的需要。用于设置此项的目录包含了创建的工件，使您能够在需要时重用此设置。
- en: This configuration and setup will let us start and stop any smart contract and
    let us debug it, but don’t expect advanced APIs to function correctly. There is
    no security, and the configuration is limited, but for fast debugging and experimentation,
    this is a good setup that’s much faster than executing the deployment steps (which
    take time and do not work well when needing to iterate quickly on a smart contract).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置和设置将让我们启动和停止任何智能合约，并让我们调试它，但不要指望高级API能够正常工作。这里没有安全性，并且配置受限，但对于快速调试和实验，这是一个比执行部署步骤（需要时间且在需要快速迭代智能合约时效果不佳）要快得多的好设置。
- en: Test the deployed chaincode
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试部署的链码
- en: 'We can run and debug only one smart contract at a time with this setup. Before
    we stop the running chaincode we started in the third terminal, let’s make sure
    everything is working. This smart contract needs to be initialized, so in this
    fourth terminal, execute this command, all on one line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种设置一次只运行和调试一个智能合约。在我们停止第三个终端中启动的运行链码之前，让我们确保一切正常。这个智能合约需要初始化，所以在第四个终端中，执行以下命令，全部写在一行上：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see output like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that the contract is initialized, we can invoke a transaction that moves
    10 units from A to B by using this command, entered on one line:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 合约初始化完成后，我们可以使用以下命令调用一笔交易，将 10 单位从 A 移动到 B，输入以下一行命令：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see a successful response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到成功的响应：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And finally, we can query to see whether `a` has the value `90`, as expected,
    with this command, entered on one line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以查询看看`a`是否如预期地具有值`90`，使用以下命令，输入以下一行命令：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And you should see the response we expect:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到我们期望的响应：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our smart contract debugging setup is complete and working. We can now stop
    the running smart contract in the third terminal we opened and close the third
    terminal. We will use the current terminal we are in, the fourth terminal, to
    invoke transactions on the Fabcar smart contract after we prepare it for this
    local testing and debug setup.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的智能合约调试设置已完成并正常工作。我们现在可以停止在第三个打开的终端中运行的智能合约，并关闭第三个终端。我们将使用当前所在的终端，第四个终端，在为此本地测试和调试设置准备好
    Fabcar 智能合约后，调用 Fabcar 智能合约上的交易。
- en: Preparing the Fabcar Smart Contract for Testing and Debugging
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Fabcar 智能合约进行测试和调试
- en: Now open a fifth terminal and change to the *fabric-samples/chaincode/fabcar/javascript*
    subdirectory. Before we can start the Fabcar smart contract or any other Node.js
    JavaScript smart contract, we need to install the dependencies and modify the
    start command in the *package.json* file. When we deploy to a network like *test-network*,
    we don’t need to install the dependencies. The runtime will perform this for us
    in the deployed container before executing the app with Node.js. In a production
    environment, this may be an issue because npm will access the internet to pull
    down the dependencies, and this may be a security risk.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开第五个终端并切换到*fabric-samples/chaincode/fabcar/javascript*子目录。在我们启动 Fabcar 智能合约或任何其他
    Node.js JavaScript 智能合约之前，我们需要安装依赖项并修改*package.json*文件中的启动命令。当我们部署到像*test-network*这样的网络时，我们不需要安装依赖项。运行时将在执行应用程序之前在部署的容器中为我们执行此操作。在生产环境中，这可能是一个问题，因为
    npm 将访问互联网以下载依赖项，这可能是一个安全风险。
- en: 'To install the dependencies, execute the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装依赖项，请执行以下操作：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This command creates a new subdirectory called *node_modules*. It contains
    our dependencies. Now we need to edit *package.json* and modify the start command,
    so open *package.json* in your editor. Change the start command to this single-line
    command and save the file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为*node_modules*的新子目录，其中包含我们的依赖项。现在我们需要编辑*package.json*并修改启动命令，因此在编辑器中打开*package.json*。将启动命令更改为以下单行命令并保存文件：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now back in the fifth terminal where we just executed the `npm install` command,
    execute this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到刚刚执行了`npm install`命令的第五个终端，在此执行以下命令：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should see this at the end of the output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输出的最后看到此内容：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Fabcar smart contract is now running, and we can invoke it from terminal
    4.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar 智能合约现已运行，我们可以从第四个终端调用它。
- en: 'We have gone through a lot of terminals to get to this point. So let’s review
    what we have running:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经历了很多终端才到了这一步。因此，让我们回顾一下我们正在运行的内容：
- en: Terminal 1 with orderer running.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端 1 正在运行 orderer。
- en: Terminal 2 with peer running.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端 2 正在运行 peer。
- en: We closed the third terminal—we used it to run a sample Go smart contract to
    test that the setup is working.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们关闭了第三个终端 —— 我们用它来运行一个示例 Go 智能合约来测试设置是否工作。
- en: Terminal 4, which we use to submit requests to test our smart contracts.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端 4，我们用来提交请求来测试我们的智能合约。
- en: Terminal 5,with the Fabcar smart contract running.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端 5，正在运行 Fabcar 智能合约。
- en: 'Now from the fourth terminal, enter this command, all on one line, to initialize
    the Fabcar smart contract:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从第四个终端，输入这个命令，全部在一行中，来初始化 Fabcar 智能合约：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下内容：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now enter this command, all on one line, to query all cars:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入这个命令，全部在一行中，来查询所有汽车：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see this output response:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个输出响应：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Great! We can now run Fabcar in our smart contract testing and debugging setup.
    This means we can rapidly test and debug it and any other smart contract too.
    Using this setup, let’s add a new transaction to the Fabcar smart contract and
    then test and debug it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在可以在我们的智能合约测试和调试设置中运行 Fabcar。这意味着我们可以快速测试和调试它和任何其他智能合约。利用这个设置，让我们向 Fabcar
    智能合约添加一个新的交易，然后测试和调试它。
- en: Performing Fabcar Testing and Debugging
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Fabcar 测试和调试
- en: First, we need to stop the running Fabcar smart contract in terminal 5 by pressing
    Ctrl-C. Then we need to load the Fabcar project into our editor or IDE.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要按下 Ctrl-C 停止在终端 5 中运行的 Fabcar 智能合约。然后我们需要将 Fabcar 项目加载到我们的编辑器或 IDE 中。
- en: 'With the chaincode Fabcar JavaScript project loaded in your editor or IDE,
    let’s add the following `callApi` function right after the `changeCarOwner` function
    at the bottom of the *fabcar.js* file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器或 IDE 中加载链代码 Fabcar JavaScript 项目，然后在 *fabcar.js* 文件底部的 `changeCarOwner`
    函数后面添加以下 `callApi` 函数：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the file and start Fabcar. You can start it through your IDE or from the
    command line in terminal 5 as we did in the prior step. Then in terminal 4, use
    this command to test the new transaction by invoking the `callApi` transaction
    via the `peer` command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并启动 Fabcar。你可以通过你的 IDE 或者从终端 5 中的命令行启动它，就像我们在上一步中所做的那样。然后在终端 4 中，使用这个命令来通过
    `peer` 命令调用 `callApi` 交易来测试新的交易：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should see the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The error response is telling us we need to supply an argument. This is an
    example of the help the middleware provides for testing and debugging. Let’s correct
    this by executing this command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应告诉我们我们需要提供一个参数。这是中间件为测试和调试提供的帮助示例。让我们通过执行这个命令来更正这个问题：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We loaded the smart contract code in an editor, modified it, ran it, and tested
    it. This was a fast iteration. Using this procedure for development is robust
    even if we do not have the tooling to load the code in an IDE and debug it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编辑器中加载了智能合约代码，进行了修改，运行了它，并对其进行了测试。这是一个快速的迭代。即使我们没有工具加载代码到集成开发环境并对其进行调试，使用这个过程进行开发也是稳健的。
- en: 'Let’s take a quick look at debugging. Remember, this setup we just went through
    is awesome because with it you can treat Fabric smart contracts just like regular
    Node.js JavaScript. With the setup up and running, we can almost forget about
    it. When we use the special `start` command to start our smart contracts, they
    run as a node process but are known to the peer, orderer, and channel—so we get
    the basic chaincode functionality we need to develop smart contracts, but without
    all the network overhead and chaincode deployment requirements. This `start` command
    can be reused and applied to any chaincode smart contract we want to run and test
    or debug:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下调试。请记住，我们刚刚介绍的这个设置非常棒，因为通过它，你可以像处理普通的Node.js JavaScript一样处理Fabric智能合约。设置好并运行后，我们几乎可以忘记它。当我们使用特殊的`start`命令启动我们的智能合约时，它们作为一个节点进程运行，但被认可为对等方、排序方和通道——因此我们得到了开发智能合约所需的基本链码功能，但不需要所有的网络开销和链码部署要求。这个`start`命令可以重复使用，并应用于我们想要运行、测试或调试的任何链码智能合约：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With this setup, you easily run the sample smart contracts in *fabric-samples*
    without the need to go through the deployment process. Just load the project in
    your IDE, install the dependencies, modify the `start` command, and then start
    or debug the smart contract. It will load and run, enabling you to submit requests
    by using the `peer` command, as we have demonstrated throughout this section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，你可以轻松地在*fabric-samples*中运行示例智能合约，无需经过部署流程。只需在你的集成开发环境中加载项目，安装依赖项，修改`start`命令，然后启动或调试智能合约。它将被加载和运行，使你能够通过使用`peer`命令提交请求，就像我们在本节中展示的那样。
- en: This quick look at debugging uses WebStorm. After loading the chaincode Fabcar
    smart contract in WebStorm, all we need to do is click the start command in the
    *package.json* file and select the debug option.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速查看调试使用了WebStorm。在WebStorm中加载链码Fabcar智能合约后，我们需要做的就是点击*package.json*文件中的start命令，并选择调试选项。
- en: 'Then WebStorm starts the app and attaches a debugger, as shown here :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，WebStorm启动应用程序并附加调试器，如下所示：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now we can set breakpoints in the Fabcar code or even dive into *node_modules*
    and set breakpoints on the Fabric SDK modules, which let us step through and learn
    how they operate and which functions are called as a result of our code. This
    can be a wonderful way to learn how the smart contracts function and figure out
    how to use more advanced functions available in the SDKs. We can step through
    our smart contract and examine variables, logic flow, called functions, the stack,
    and more.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 Fabcar 代码中设置断点，甚至深入到*node_modules*并在 Fabric SDK 模块上设置断点，这样我们就可以逐步学习它们的操作方式以及我们的代码导致哪些函数被调用。这可以是学习智能合约如何运作并找出如何使用SDK中可用的更高级功能的绝佳方法。我们可以逐步执行我们的智能合约并检查变量、逻辑流程、被调用的函数、堆栈等等。
- en: Using the IDE method of development, we cannot test the smart contract via our
    web client because we have no security, and the full network is not operating.
    But from what we have learned, this is not necessary, because we can invoke all
    of the smart contract transactions from the command line by using the `peer` command,
    allowing us to focus on the development of smart contract transactions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 开发方法时，我们无法通过我们的 Web 客户端测试智能合约，因为我们没有安全性，而且完整的网络没有运行。但根据我们所学的知识，这并不是必要的，因为我们可以通过使用`peer`命令从命令行调用所有智能合约交易，从而使我们专注于智能合约交易的开发。
- en: Smart contracts can start and stop, which allows quick iteration during development.
    This is important, because it eliminates the redeployment steps that slow down
    the development cycle. We can use our editor to write code, the command line to
    start and stop the smart contract, and the `peer` command to test it. If a test
    fails, we can set a breakpoint and execute code to hit the breakpoint and then
    debug it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以启动和停止，这允许在开发过程中快速迭代。这很重要，因为它消除了减慢开发周期的重新部署步骤。我们可以使用我们的编辑器编写代码，使用命令行启动和停止智能合约，并使用`peer`命令进行测试。如果测试失败，我们可以设置断点并执行代码以触发断点，然后进行调试。
- en: The debugger lets us see and analyze the runtime data, state, structures, stack,
    and more. Once we locate the problem, we make the edits and test again. This development
    cycle is repeated until we finish our initial implementation of the transactions.
    Once we complete this cycle of development, we can package and deploy our smart
    contract to the test network and test it in a systems environment, where security
    and multiple peers are involved in the execution of our new smart contract transactions.
    This is similar to the typical development process in practice today, where developers
    create and test code in a local controlled environment and promote it to systems
    or integration testing, then to a staging environment that mirrors production,
    and eventually to production. Using the setup we just went through is perfect
    for rapid local development of smart contracts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器让我们能够查看和分析运行时数据、状态、结构、堆栈等。一旦我们找到问题，我们就进行编辑和再次测试。这个开发周期重复进行，直到我们完成了事务的初始实现。一旦我们完成了这个开发周期，我们就可以将智能合约打包部署到测试网络，并在系统环境中进行测试，在这个环境中，安全性和多个对等方参与了我们新智能合约事务的执行。这与当今的典型开发流程类似，开发人员在本地受控环境中创建和测试代码，然后将其推广到系统或集成测试，然后到与生产环境相同的暂存环境，最终到生产环境。使用我们刚刚经历的设置非常适合快速本地开发智能合约。
- en: Identifying and Reviewing Logs
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辨认和审查日志
- en: Log files are a primary source of information for smart contract developers.
    Knowing how to access logs is an important task for developers to gather information
    on the performance and functioning of their code. In this section, we will identify
    available logs and show how to review them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是智能合约开发人员获取信息的主要来源。知道如何访问日志是开发人员收集有关其代码性能和功能的信息的重要任务。在本节中，我们将确定可用的日志并展示如何审查它们。
- en: This first log is the developer’s *console log*. In the previous section, where
    we set up a development environment for rapid testing and debugging, we started
    an orderer and peer. Both had console output that we can review and learn from
    as we invoke our smart contract transactions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个日志是开发者的*控制台日志*。在前一节中，我们为了快速测试和调试设置了开发环境，启动了排序器和对等方。两者都有控制台输出，我们可以在调用智能合约事务时进行审查和学习。
- en: 'Here is an example of the log output from the orderer we started:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们启动的排序器的日志输出示例：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And here is a sample of log output from the peer we started:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们启动的对等方的日志输出示例：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When we launch a test network, the first log of interest is the log output from
    the script that launches the network and deploys the Fabcar smart contract.. Reviewing
    this log offers a lot of knowledge about the commands used and the parameters
    supplied to those commands. Of interest to smart contract developers are the log
    entries that detail the several commands required to deploy a smart contract.
    The log entries are near the end of the log.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动测试网络时，首先感兴趣的日志是启动网络并部署 Fabcar 智能合约的脚本的日志输出。审查此日志可以了解到使用的命令和提供给这些命令的参数。对智能合约开发人员感兴趣的是详细说明部署智能合约所需的几个命令的日志条目。这些日志条目位于日志的末尾附近。
- en: 'When the test network finishes launching, we can run a Docker command to display
    the containers started:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网络完成启动后，我们可以运行 Docker 命令来显示启动的容器：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This command will display a listing of the 11 Docker containers started along
    with port information, status, date created, command, image, and container ID:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将显示启动的 11 个 Docker 容器的列表，以及端口信息、状态、创建日期、命令、镜像和容器 ID：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It is possible to use the container ID to review any container’s log output.
    We can even tail the log output with this command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用容器 ID 来查看任何容器的日志输出。我们甚至可以使用以下命令来追踪日志输出：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can aggregate the log output of all these containers by using Logspout.
    The *monitordocker.sh* script, which will launch Logspout for us, is located at
    the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Logspout 来聚合所有这些容器的日志输出。*monitordocker.sh* 脚本，将为我们启动 Logspout，位于以下位置：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To aggregate all of the container logs after launching the test network, just
    open a terminal and execute the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动测试网络后，要聚合所有容器的日志，只需打开终端并执行以下操作：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now when you invoke smart contract transactions, the terminal will display the
    aggregated logs’ output. If you want to review specific log output from a particular
    container, we can use Docker.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您调用智能合约交易时，终端将显示聚合日志的输出。如果您想要查看特定容器的特定日志输出，我们可以使用 Docker。
- en: Creating Unit Test Contracts
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试合约
- en: In the rapid smart contract testing session, we discussed how to test Fabcar.
    In large projects, many smart contracts will be frequently updated by team members.
    In today’s complex software development environment, unit tests are essential
    in the development life cycle, as they ensure that your specific module works
    under all expected conditions. A *unit test* isolates a function, class, or method
    and tests only that piece of code. It helps to debug code and improve code quality,
    which eventually results in more reliable code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速智能合约测试会话中，我们讨论了如何测试 Fabcar。在大型项目中，许多智能合约将经常被团队成员更新。在当今复杂的软件开发环境中，单元测试在开发生命周期中至关重要，因为它们确保您的特定模块在所有预期条件下都能正常工作。*单元测试*
    隔离一个函数、类或方法，并仅测试该代码片段。它有助于调试代码和提高代码质量，最终导致更可靠的代码。
- en: 'As you learned in previous chapters, the Hyperledger Fabric smart contract
    supports code based on Go, Java, and Node.js. Each language has plenty of mock
    test frameworks we can use. For example, in this book, we use Node.js as our smart
    contract language, and instead of using Hyperledger Fabric directly to test in
    the sample network, we can use Mocha and Chai mock test frameworks to mock those
    Fabric SDK interfaces and directly test the smart contract logic. You can include
    the following node dependency in the *package.json* node project for doing unit
    tests:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前几章中学到的那样，Hyperledger Fabric 智能合约支持基于 Go、Java 和 Node.js 的代码。每种语言都有大量的模拟测试框架可供使用。例如，在本书中，我们使用
    Node.js 作为我们的智能合约语言，而不是直接在示例网络中使用 Hyperledger Fabric 进行测试，我们可以使用 Mocha 和 Chai
    模拟测试框架来模拟那些 Fabric SDK 接口并直接测试智能合约逻辑。您可以在 *package.json* 节点项目中包含以下节点依赖项来进行单元测试：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Chai is a behavior-driven development/test-driven development (BDD/TDD) assertion
    library, and Mocha and Sinon.JS are popular standalone test frameworks. Sinon–Chai
    provides a set of custom assertions for using the Sinon.JS and Chai assertion
    libraries.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个行为驱动的开发/测试驱动的断言库，而 Mocha 和 Sinon.JS 是流行的独立测试框架。Sinon–Chai 为使用 Sinon.JS
    和 Chai 断言库提供了一组自定义断言。
- en: 'Further, the following is an example to show how we can use the JS test framework
    to test smart contracts:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一个示例，展示了如何使用 JS 测试框架来测试智能合约：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We first import the node library in the test class. Then, create a `Context`
    class to mock `ChaincodeStub` and `ClientIdentity`. With the mock `Context` defined,
    we can then start to instantiate a smart contract by creating a `SomeContract`
    instance, and then get the instantiated result. Similarly, we can invoke smart
    contract transactions by calling `contract.txn(ctx, 'success')` to verify the
    result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在测试类中导入节点库。然后，创建一个 `Context` 类来模拟 `ChaincodeStub` 和 `ClientIdentity`。有了模拟的
    `Context` 定义，我们就可以开始实例化一个智能合约，通过创建一个 `SomeContract` 实例来获取实例化的结果。类似地，我们可以调用 `contract.txn(ctx,
    'success')` 来调用智能合约交易以验证结果。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you gained four vital skills for developing Hyperledger Fabric
    smart contracts: creating a smart contract web app, performing rapid smart contract
    testing, monitoring logs, and creating unit test contracts. The first vital skill
    was creating a UI client for Fabric smart contracts. We did this as a maintenance
    task that added a web UI client to the Fabcar smart contract. A great benefit
    from this is we can now use the Fabcar UI web client as a template and quick start
    for our next smart contract.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了开发Hyperledger Fabric智能合约的四项重要技能：创建智能合约 Web 应用程序、进行快速智能合约测试、监视日志和创建单元测试合约。第一个重要技能是为
    Fabric 智能合约创建 UI 客户端。我们将其作为维护任务来完成，为 Fabcar 智能合约添加了一个 Web UI 客户端。这样做的一个巨大好处是，我们现在可以将
    Fabcar UI Web 客户端作为下一个智能合约的模板和快速启动。
- en: The second vital skill is all about testing smart contracts. We set up a testing
    environment that allows us to rapidly test smart contracts. Using this setup,
    you learned we can debug our smart contracts as they execute. The benefit of rapidly
    testing smart contracts is that it facilitates quick iteration for smart contract
    development and exploring the operation of other smart contracts. Without the
    setup, you learned we could use *test-network*. But that is slow, and debugging
    difficult. This setup skill alone is probably the most important skill you can
    possess for fast smart contract development, testing, and debugging.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项重要技能是关于测试智能合约的。我们建立了一个测试环境，可以快速测试智能合约。利用这个设置，您学会了我们可以在执行时调试我们的智能合约。快速测试智能合约的好处在于，它促进了智能合约开发的快速迭代和探索其他智能合约的运行。如果没有这个设置，您学会了我们可以使用*测试网络*。但那太慢了，而且调试困难。这个设置技能本身可能是您拥有的最重要的技能，用于快速智能合约开发、测试和调试。
- en: In addition. you learned how to monitor logs and execute unit tests—two important
    skills for monitoring code execution and maintaining code quality.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还学会了如何监视日志并执行单元测试——这是两项重要的技能，用于监视代码执行和维护代码质量。
- en: 'You are now ready to take the knowledge and skills you have gained to [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl),
    which covers the most popular use case for Hyperledger Fabric: supply chains.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好将您获得的知识和技能带到[第7章](ch07.xhtml#building_supply_chain_dapps_with_hyperl)中，该章节涵盖了
    Hyperledger Fabric 最流行的用例：供应链。
