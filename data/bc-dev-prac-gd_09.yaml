- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_9](https://doi.org/10.1007/978-1-4842-4847-8_9)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Elad Elrom 2019 Elad Elrom 区块链开发者 [https://doi.org/10.1007/978-1-4842-4847-8_9](https://doi.org/10.1007/978-1-4842-4847-8_9)
- en: '9. Build Dapps with Angular: Part I'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 使用Angular构建dapp：第一部分
- en: Elad Elrom^([1](#Aff2) )(1)New York, NY, USA
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Elad Elrom^([1](#Aff2) )(1)纽约，纽约，美国
- en: 'In previous chapters, I covered different blockchains, and you learned how
    to create smart contracts that can interact with a blockchain. You created smart
    contracts in Ethereum, NEO, EOS, and Hyperledger. In Chapter [1](475651_1_En_1_Chapter.xhtml),
    I broke down the process into five layers: consensus layer, miner or booking layer,
    propagation layer, semantic layer, and application layer. Smart contracts are
    part of the application layer in the development cycle; however, the application
    layer is incomplete without having a front-end interface that enables an end user
    to interact with the blockchain.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我介绍了不同的区块链，并学习了如何创建可以与区块链交互的智能合约。你在以太坊、NEO、EOS和Hyperledger上创建了智能合约。在第[1](475651_1_En_1_Chapter.xhtml)章中，我将过程分解为五层：共识层、矿工或预定层、传播层、语义层和应用层。智能合约是开发周期中应用层的一部分；然而，如果没有前端界面，使得最终用户能够与区块链交互，那么应用层是不完整的。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Many times you will hear decentralized applications (dapps) referred to as smart
    contracts. Smart contracts are self-executing contracts. Dapps use smart contracts
    but run on a P2P network and not on a single system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，你会听到去中心化应用（dapps）被称为智能合约。智能合约是自执行的合同。dapps使用智能合约，但运行在P2P网络中，而不是单一系统上。
- en: Developers and more savvy users can interact with the smart contracts you created
    via the command-line interface and tools mentioned in previous chapters, but developing
    a front-end application that is able to interact with a blockchain is essential
    for all other users. You do this by creating a decentralized application (dapp  ).
    In this chapter and the next, you will be creating a decentralized application
    with the help of Angular so that users can interact with a smart contract using
    a friendly and intuitive user interface (UI). I broke down the process into two
    parts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者和更熟练的用户可以通过前几章中提到的命令行界面和工具与您创建的智能合约交互，但是为所有其他用户开发能够与区块链交互的前端应用程序是必不可少的。您通过创建去中心化应用程序（dapp）来实现这一点。在本章和下一章中，您将使用Angular创建一个去中心化应用程序，以便用户可以使用友好且直观的用户界面（UI）与智能合约交互。我将过程分为两部分。
- en: 'Part I, covered in this chapter, contains the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，在本章中，包含以下主题：
- en: Developing the dapp, including its benefits and classification
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发去中心化应用（dapp），包括其益处和分类
- en: Using Angular, including its architecture, benefits, prerequisites, and creating
    an Angular skeleton app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular，包括其架构、益处、先决条件和创建Angular骨架应用
- en: Creating and styling Angular custom components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和样式化Angular自定义组件
- en: 'Part II, covered in Chapter [10](475651_1_En_10_Chapter.xhtml), contains the
    following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分，在第[10](475651_1_En_10_Chapter.xhtml)章中，包含以下主题：
- en: Creating the dapp’s smart contract with Truffle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Truffle创建dapp的智能合约
- en: Integrating the smart contract with the dapp
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能合约集成到dapp
- en: Linking and connecting your dapp to the Ethereum network
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的dapp连接到以太坊网络
- en: Let’s get started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: What Is a Dapp?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是dapp？
- en: A *decentralized application* (shortened as ÐApp, dapp, Dapp, dApp, or DApp
    and pronounced as “dee-app”) is a web application that is able to interact with
    a smart contract. Dapps run on the blockchain and utilize the distributed ledger.
    The Ethereum blockchain is currently the most popular platform to run dapps; however,
    other distributed ledger technologies (DLTs) you have seen also provide the ability
    to create dapps. I covered NEO, EOS, and Hyperledger in previous chapters; others
    include ICON, Cardano, and Hashgraph (Hedera).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*去中心化应用*（缩写为ÐApp、dapp、Dapp、dApp或DApp，发音为“dee-app”）是一个能够与智能合约交互的网页应用。dapps在区块链上运行并利用分布式账本。目前，以太坊区块链是运行dapps最受欢迎的平台；然而，您在前几章中看到的其他分布式账本技术（DLTs）也提供了创建dapps的能力。我介绍了NEO、EOS和Hyperledger；其他包括ICON、Cardano和Hedera（Hbar）。'
- en: '*“Everything that can be decentralized will be decentralized.”*'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一切可以去中心化的事物都将去中心化。”
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —David Johnston, CEO of the DApp Fund [https://github.com/DavidJohnstonCEO/DecentralizedApplications](https://github.com/DavidJohnstonCEO/DecentralizedApplications)
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —David Johnston，DApp Fund的CEO [https://github.com/DavidJohnstonCEO/DecentralizedApplications](https://github.com/DavidJohnstonCEO/DecentralizedApplications)
- en: If you have ever developed a standard desktop, web, or mobile application, you
    will find that dapps are similar but also very different.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经开发过一个标准的桌面、网络或移动应用，你会发现dapp与它们相似，但也有很大不同。
- en: 'A dapp is built using the same tools and languages you use to build any other
    app, but for an app to be categorized as a dapp, it needs to meet the following
    criteria:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个去中心化应用（dapp）是使用与构建其他任何应用相同的工具和语言构建的，但要想将一个应用归类为dapp，它需要满足以下标准：
- en: '*Open source*: Its code is published as open source and should not be governed
    by one entity (centralized). Keep in mind that the application may adapt its own
    protocol in response to proposed improvements and market feedback; however, the
    consensus of its users drives all changes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源：其代码作为开源发布，不应由一个实体（中心化）管理。请记住，应用程序可能会根据提出的改进和市场反馈适应其自己的协议；然而，是其用户共识推动所有变化。
- en: '*Decentralized*: Dapps utilize a blockchain or a P2P network.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化：dapp利用区块链或P2P网络。
- en: '*Incentive*: Dapps use digital assets for funding.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激励型：dapp使用数字资产进行资金筹集。
- en: '*Algorithm/protocol*: Dapps often generate tokens and include a consensus mechanism
    such as PoW, PoS, or even their own.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法/协议：dapp通常生成代币，并包括一种共识机制，如PoW、PoS，甚至有自己的。
- en: These criteria ensure dapps don’t have downtime like other apps you download
    from marketplaces such as iTunes or Google Play; dapps also give control to a
    community instead of one entity. These criteria can be significant. For instance,
    Apple and Google often reject apps for not meeting their arbitrary or monetary-based
    policies. These policies do not always make sense and are not always in the best
    interest of the end user; they often are there to block usage of a competitor
    or for monetary gain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准确保了dapp不会像你从iTunes或Google Play等市场下载的其他应用那样出现宕机；dapp还将控制权交给了一个社区，而不是一个实体。这些标准可能是重要的。例如，苹果和谷歌经常因为应用不符合它们任意或基于货币的政策而拒绝这些应用。这些政策并不总是合乎逻辑，也不总是符合最终用户的最佳利益；它们经常是为了阻止使用竞争对手的应用或为了获得货币收益而存在。
- en: Dapps that are based on open source code implemented on decentralized blockchains
    and funded by tokens generated using a specific consensus mechanism are believed
    by many to be the future of all businesses. Only time will tell.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基于开源代码、在去中心化区块链上实现、并通过特定共识机制生成的代币进行资金筹集的dapp，被许多人认为将是所有商业的未来。时间会告诉我们答案。
- en: Additionally, open source software is an advantage because it allows users to
    view the source code and potentially contribute. Decentralizing using a blockchain
    harnesses the advantages of blockchain as DLT and serves as a replacement to the
    traditional one-server database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开源软件的一个优点是它允许用户查看源代码，并可能进行贡献。使用区块链进行去中心化利用了区块链作为分布式账本技术的优势，并取代了传统的单服务器数据库。
- en: Finally, adding records/transactions to ledgers is usually done utilizing tokens,
    and the consensus mechanism of a token is also an agreement between all the users
    of the dapp.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向账本添加记录/交易通常是通过使用代币来完成的，而代币的共识机制也是dapp所有用户之间的一个协议。
- en: Dapp Classification
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dapp分类
- en: 'In addition to the previous criteria, dapps can be categorized. The classification
    is based on the infrastructure the dapp is utilizing and can be broken down to
    these three categories:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述标准之外，dapp还可以进行分类。这种分类是基于dapp所利用的基础设施，可以细分为这三个类别：
- en: '*Dedicated blockchain dapps*: These are dapps that use a dedicated blockchain
    directly; examples are bitcoin, Ethereum, EOS, and NEO.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用区块链dapp：这些是直接使用专用区块链的dapp，例如比特币、以太坊、EOS和NEO。
- en: '*Dapps relying on another blockchain*: For instance, the Omni Layer Protocol
    (formerly called Mastercoin) is a digital currency and communications protocol
    that is built on top of the bitcoin blockchain.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖另一个区块链的dapp：例如，Omni Layer Protocol（曾称为Mastercoin）是一个建立在对比特币区块链之上的数字货币和通信协议。
- en: '*Dapps relying on another protocol that built on top of another blockchain*:
    These dapps use a protocol that is built on top of another blockchain. An example
    is the safe network using the Omni Layer Protocol.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖另一个建立在另一个区块链之上的协议的dapp：这些dapp使用的是建立在一个区块链之上的协议。一个例子是使用Omni Layer Protocol的safe
    network。
- en: 'A good example to help understand the classification concept is the USDT (Tether)
    token. This token was issued twice based on two blockchains: bitcoin and Ethereum.
    In this case, there are two types of USDT. The original, which is based on bitcoin,
    is done by using the Omni Layer Protocol to generate the token, and the Ethereum-based
    USDT is compatible with the Ethereum’s ERC20 standard. Take a look at Figure [9-1](#Fig1).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig1_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig1_HTML.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解分类概念的一个好例子是USDT（泰达币）代币。这个代币基于两个区块链：比特币和以太坊发行了两次。在这种情况下，有两种USDT类型。基于比特币的原始版本是通过使用Omni
    Layer协议生成代币，而基于以太坊的USDT与以太坊的ERC20标准兼容。请查看图[9-1](#Fig1) ![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig1_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig1_HTML.jpg)
- en: Figure 9-1
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1
- en: Representation of clasisification for USDT
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: USDT的分类表示
- en: Dapp Projects
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dapp项目
- en: Most dapps are built directly on top of the Ethereum blockchain or use a blockchain
    for their tokens. However, there are some dapps that even build their own dedicated
    blockchain. Take a look at Table [9-1](#Tab1) for a sample of different dapps
    and their classifications.Table 9-1
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数dapp直接建立在以太坊区块链之上，或者使用区块链作为其代币。然而，有些dapp甚至构建自己的专用区块链。请查看表[9-1](#Tab1) 一个不同dapp及其分类的示例。表9-1
- en: Example of Dapps and Classifications
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Dapps及其分类示例
- en: '| **Dapp** | **Description** | **Classification** | **Token** | **Blockchain**
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **Dapp** | **描述** | **分类** | **代币** | **区块链** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Ethlance | Marketplace for job postings and hiring freelancers. 0 percent
    fees. | Uses Ethereum directly | No token | Ethereum blockchain |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Ethlance | 发布职位和雇佣自由职业者的市场。0%的费用。 | 直接使用以太坊 | 无代币 | 以太坊区块链 |'
- en: '| Golem | Global market for idle computer power. | Token based on Ethereum
    | GNT | Ethereum blockchain |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Golem | 全球闲置计算机能力的市场。 | 基于以太坊的代币 | GNT | 以太坊区块链 |'
- en: '| The SAFE Network | Data storage and communications network. | Implementation
    relying on another protocol (Omni protocol) that is built on top of another blockchain
    (bitcoin) | SFE | Bitcoin |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 安全网络 | 数据存储和通信网络。 | 依赖于另一种协议（Omni协议）的实现，该协议建立在另一种区块链（比特币）之上 | SFE | 比特币 |'
- en: 'In addition to the information in Table [9-1](#Tab1), there are many resources
    to find more dapps; these two web sites provide a list of dapps that you can check:
    [https://dapps.ethercasts.com/](https://dapps.ethercasts.com/) and [https://coinsutra.com](https://coinsutra.com)
    .'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表[9-1](#Tab1)中的信息外，还有许多资源可以找到更多的dapp；这两个网站提供了可以检查的dapp列表：[https://dapps.ethercasts.com/](https://dapps.ethercasts.com/)
    和 [https://coinsutra.com](https://coinsutra.com) 。
- en: How Do You Create Your Own Dapp?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何创建自己的Dapp？
- en: 'The success of bitcoin and blockchain have brought an explosion of dapps. Developers
    and business owners have created a basic process to follow for developing dapps.
    You don’t need to follow this exactly, and it may change by the time of writing;
    however, many of the published dapps out there have followed this process. The
    process consists of these five steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币和区块链的成功带来了dapp的爆炸式增长。开发者和企业主们创建了一个基本的开发dapp的流程。你不必完全遵循这一点，并且随着时间的推移，它可能会有所变化；然而，许多已发布的dapp都是遵循这个流程的。这个过程包括以下五个步骤：
- en: '1.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Write a white paper.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写白皮书。
- en: '2.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Launch an initial coin offering (ICO).
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进行首次代币发行（ICO）。
- en: '3.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Develop the dapp.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开发Dapp。
- en: '4.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Launch your dapp.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动你的Dapp。
- en: '5.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Market your dapp.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推广你的Dapp。
- en: Let’s review these steps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾这些步骤。
- en: Write a White Paper
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写白皮书
- en: The white paper is similar to a company’s business plan aimed at investors.
    However, it targets more than just investors; it’s the technical blueprint. The
    white paper is the technical document as well as the business plan and should
    explain the problem being solved and the concept, features, and technical aspects
    of the dapp.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 白皮书类似于公司面向投资者的商业计划。然而，它针对的不仅仅是投资者；它是技术蓝图。白皮书是技术文档以及商业计划，应解释所解决的问题以及Dapp的概念、特点和技术方面。
- en: Just like in a business plan, it’s a good idea to include your unique selling
    proposition (USP), road map, members’ résumés, capabilities, and history to help
    establish credibility.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与商业计划一样，包含你的独特卖点（USP）、路线图、成员简历、能力和历史，以帮助建立信誉。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The unique selling proposition (USP) is the problem your dapp is aiming to solve.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 独特卖点（USP）是你的dapp旨在解决的问题。
- en: Once the white paper is published, it is good to get feedback from peers and
    the community in the early stages and prior to development. Social media, forms,
    and publications are often used to promote dapps and help create credibility.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦白皮书发布，在早期阶段和开发之前，从同行和社区获取反馈意见是个好主意。社交媒体、论坛和出版物通常用于推广dapp，并帮助建立信誉。
- en: Launch an Initial Coin Offering
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进行首次代币发行（ICO）
- en: Once the white paper is published, the next step is to launch an ICO and sell
    coins  or tokens to fund and support your dapp. The coin should have a reason
    for existence, rather than be the same as another coin/token out there, so you
    should explain how and why your dapp needs its own token or coin.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦白皮书发布，下一步就是启动ICO，并通过销售代币或硬币来筹集资金支持你的dapp。代币应该有存在的理由，而不是与其他代币/硬币相同，因此你应该解释你的dapp为什么需要自己的代币或硬币。
- en: 'You also need to decide on the type of classification for your dapp, which
    will determine whether you will need any or all of the following: 1) issue token
    2) set usage fees. 3) have a dedicated blockchain. 4) have a mining mechanism
    5) set the allocation of fees 6) rewards investors 7) allocate fees to pay for
    different departments of your business: support, development, marketing, and business.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要决定你的dapp的分类类型，这将决定你是否需要以下所有或部分内容：1)发行代币；2)设置使用费用；3)拥有专用区块链；4)拥有挖矿机制；5)设置费用分配；6)奖励投资者；7)将费用分配给你的业务的不同部门：支持、开发、营销和商业。
- en: Develop the Dapp
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开发dapp
- en: Development should be open source, and GitHub is usually used for repos for
    the development effort. On every release, it’s a good idea to let investors and
    others know of a release to build users and a developer community around your
    project. Many dapps have tried to get funds and delivered no usable products;
    set yourself apart and avoid potential problems with regulators. (I will cover
    regulators in Chapter [11](475651_1_En_11_Chapter.xhtml).)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应该是开源的，通常使用GitHub来管理开发过程中的代码仓库。在每次发布时，告知投资者和其他人关于发布的消息是个不错的主意，这样可以围绕你的项目建立用户和开发者社区。许多dapp试图筹集资金但未能提供实用的产品；你需要与监管机构区分开来，避免潜在的问题。（我将在第[11](475651_1_En_11_Chapter.xhtml)章中讨论监管机构。）
- en: Launch Your Dapp
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发布你的dapp
- en: Launch your dapp and include your release notes, documentation, road map, and
    maintenance plan. It’s crucial to meet the promised launch date.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 发布你的dapp，并附上你的发布说明、文档、路线图和维护计划。如期满足发布日期至关重要。
- en: Market Your Dapp
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 推广你的dapp
- en: The last step is marketing. In addition to traditional marketing, dapps often
    hire or work with prompters during early phases or after release to get the word
    out. Another unique marketing aspect for a dapp is to get the coin/token listed
    on exchanges. This is the final stamp of recognition. Some exchanges have a voting
    system put in place to select the next coin/token to be listed. Some exchanges
    have been abusing this process and charging hefty fees to list a token or coin.
    For instance, a utility token listing on Binance exchange can cost from $0.5 million
    to $3 million.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是市场营销。除了传统营销外，在dapp的早期阶段或发布后，通常会聘请或与推广者合作，以便让更多人了解。对于dapp来说，独特的一点是将代币/硬币列入交易所。这是认可的最终标志。一些交易所设有投票系统，用以挑选下一个待上市的代币或硬币。一些交易所滥用这一流程，对上市代币或硬币收取高额费用。例如，在Binance交易所上市一个实用代币可能需要花费从50万美元到300万美元不等。
- en: Many early investors including dapp owners have been able to “cash out” if a
    token is listed on major exchanges as its price often goes up high because of
    the listing; however, it has become more and more difficult for a dapp to be listed,
    and it needs to provide real value. Fraudsters are often exposed, and coins/tokens
    get de-listed as quickly as they are listed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 许多早期投资者，包括dapp的所有者，如果代币能被主要交易所上市，通常能够“套现”，因为上市往往会使代币价格上涨；然而，dapp上市变得越来越困难，它需要提供真正的价值。骗子经常被曝光，代币/硬币上市后很快就会被取消上市。
- en: Why Angular?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择Angular？
- en: With dapps, just like with any traditional app, you can write your application
    natively to the device you publish your app to (in the supported language of your
    device such as Xcode for iOS); however, it has been proven that using a framework
    can speed up development. For instance, if you want to utilize the same code and
    deploy your application on multiple devices with different screen sizes, that
    can become a challenge for a small team. Angular helps you build cross-platform
    modern applications for web, mobile, and desktop at the same time. The Angular
    CLI and Component Dev Kit (CDK) can help accelerate the development of apps.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 dapps 时，就像使用任何传统应用一样，你可以将应用程序原生编写为发布到的设备的应用程序（例如使用设备支持的语言如 Xcode 的 iOS）；然而，已经证明使用框架可以加快开发速度。例如，如果你想要利用相同的代码并在具有不同屏幕尺寸的多台设备上部署应用程序，对于小团队来说可能是一个挑战。Angular
    能帮助你同时为 Web、移动端和桌面构建跨平台的现代应用程序。Angular CLI 和组件开发套件（CDK）可以帮助加速应用程序的开发。
- en: 'Using Angular can be beneficial because of the following factors:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 可以是很有益的，原因如下：
- en: Large community support
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量社区支持
- en: Enterprise architecture and scaling
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业架构和扩展
- en: Cross-platform support
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台支持
- en: Documentation
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Angular is a structural framework and enables you to create front-end client-side
    applications. The pieces are loosely coupled and structured in a modular fashion,
    resulting in less code to write, added flexibility, easier-to-read code, and quicker
    development time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular** 是一个结构框架，能让你创建前端客户端应用程序。它的各个部分松散耦合，以模块化的方式构建，这意味着编写更少的代码，增加灵活性，代码更易读，开发时间更短。'
- en: Angular allows the developer to put together a toolset for building a framework
    that will fit your exact application’s needs. You can use HTML as your template
    language and extend HTML’s syntax so the application’s components can be read
    easily. Other than HTML, the coding is done with TypeScript, which turns JavaScript
    into an object-oriented programming language and gives you an enterprise-level
    environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 允许开发者构建一个工具集，以满足你的应用程序的确切需求。你可以使用 HTML 作为模板语言，并扩展 HTML 的语法，以便应用程序的组件易于阅读。除了
    HTML，编码是用 TypeScript 完成的，它将 JavaScript 转换成面向对象的编程语言，并为你提供企业级环境。
- en: Additionally, Angular is well structured and built to be fully accessible, in
    accordance with accessible rich Internet applications (ARIAs), so your app or
    site can be built correctly for people with disabilities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular 结构良好，完全符合可访问丰富的互联网应用（ARIAs）的标准，因此你的应用或网站可以正确地为残疾人构建。
- en: Angular also gets along well with other JavaScript libraries so you can install
    libraries such as the Ethereum JavaScript API web3.js with npm manager. Lastly,
    Angular’s features can be easily modified or replaced to fit your exact needs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 也与其他 JavaScript 库相处得很好，所以你可以使用 npm 管理器安装像以太坊 JavaScript API web3.js
    这样的库。最后，Angular 的功能可以轻松修改或替换，以满足你的确切需求。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The word *angular* means having multiple angles or measured by an angle. Angular
    is a structural framework and enables you to create front-end client-side applications
    for the Web, mobile, and desktop. It is an open source, front-end framework for
    dynamic app development.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 *angular* 意味着具有多个角度或通过角度来测量。Angular 是一个结构框架，能让你为 Web、移动端和桌面创建前端客户端应用程序。它是一个用于动态应用开发的开放源代码前端框架。
- en: Angular’s most significant features are data binding and dependency injection.
    These can help decrease code. Also, Angular has been around for years; it’s on
    its seventh release.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的主要功能是数据绑定和依赖注入。这些可以帮助减少代码量。此外，Angular 已经存在多年，现在是第七个版本。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dependency injection is a design pattern technique. As the name suggests, it
    means using one object as a dependency to another object by injecting the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种设计模式技术。正如其名，这意味着通过注入代码，使用一个对象作为另一个对象的依赖。
- en: Angular 2 was a complete rewrite of AngularJS and offered a major change; however,
    there are no major differences between Angular 2 up to version 8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 是 AngularJS 的完全重写，并带来了一次重大变革；然而，从 Angular 2 到版本 8 之间并没有重大差异。
- en: 'The latest release version of Angular at the time of writing is 7.3.1, and
    in this version, a few features were added such as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本的 Angular 是 7.3.1，在这一版本中，添加了以下几个功能：
- en: '*Dependencies*: The dependencies were upgraded, and support for Typescript
    3.1, RxJS 6.3, and Node 10 was added.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：依赖项得到了升级，并添加了对 TypeScript 3.1、RxJS 6.3 和 Node 10 的支持。'
- en: '*Bundle budget*: You can set a warning for the size of the application to ensure
    you don’t exceed the limit (the default is 2 MB).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捆绑预算*：你可以为应用程序的大小设置一个警告，以确保你不超过限制（默认是2 MB）。'
- en: '*Angular CLI* : By running the CLI wizard, you can add components such as routing
    and decide on the format of the CSS.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular CLI*：通过运行CLI向导，你可以添加如路由等组件，并决定CSS的格式。'
- en: '*Component Dev Kit (CDK)* *of Angular Material*: Add new features such as out-of-the-box
    virtual scrolling, drag and drop, and “mat-form-field” support for native select
    fields. (I’ll cover Material later in this chapter.)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular Material的组件开发工具包（CDK）*：添加新的特性，如开箱即用的虚拟滚动、拖放功能以及对原生选择字段的支持。（我将在本章后面介绍Material。）'
- en: Angular 8 is at release candidate 2 (rc.2), and the features expected are mostly
    to improve performance. It will include an improved view engine called Angular
    Ivy, improved upload of JavaScript for modern browsers that support ES2015+, support
    for web workers to use hardware for heavy lifting, support for TypeScript, a benchmarks
    tool, and more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 8处于发布候选2（rc.2）阶段，预期的新特性主要是提高性能。它将包括一个改进的视图引擎，名为Angular Ivy，改进的针对支持ES2015+的现代浏览器的JavaScript上传支持，支持使用硬件进行重负载操作的web
    workers，支持TypeScript，一个基准测试工具，以及更多内容。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I selected Angular, but Angular is not the only framework that can help expedite
    development. You can use other frameworks such as React ( [https://reactjs.org](https://reactjs.org)
    ) and achieve similar benefits. This decision is really a matter of personal taste
    and your team’s skill set. You could easily convert this project to a React project
    mostly by copying your project’s files over to the React project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了Angular，但Angular并不是唯一可以加快开发速度的框架。你可以使用其他框架，比如React（[https://reactjs.org](https://reactjs.org)），以获得类似的好处。这个决定真的取决于个人喜好和你的团队技能。你可以通过将你的项目的文件复制到React项目中，很容易地将这个项目转换为React项目。
- en: Creating an Angular Dapp
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Angular Dapp
- en: In this section, you will be creating an actual dapp that will connect to the
    Ethereum network  and transfer funds from one account to another. This is often
    the core feature of any dapp out there. For instance, you can build a dapp that
    sells products, provides services, or pays users to take quizzes, and all these
    types would need to have a mechanism in place to transfer coins/tokens. In this
    section of this chapter, you will be creating a dapp utilizing Angular.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个实际的dapp，它将连接到以太坊网络，并从一个账户向另一个账户转账资金。这是任何dapp的核心功能。例如，你可以构建一个销售产品、提供服务或支付用户做测验的dapp，所有这些类型的dapp都需要有一个机制来转账币/代币。在本章的这一部分，你将利用Angular创建一个dapp。
- en: In terms of environment and deployment, you will be using the Truffle web framework
    you used in Chapter [5](475651_1_En_5_Chapter.xhtml), as it offers benefits for
    quickly creating a smart contract. Truffle is able to do more than just help compile
    your smart contract; it does everything you need to inject your smart contract
    into a web app and can run the test suite. You are also going to utilize MetaMask
    again to get a secure blockchain account in the browser. Lastly, you will use
    and run Ganache to create a local blockchain RPC server to test and develop against.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境和部署方面，你将使用在第5章中使用的Truffle网络框架，因为它有助于快速创建智能合约。Truffle不仅能帮助编译你的智能合约，还能为你做一切你需要的事情，将智能合约注入到网页应用中，并可以运行测试套件。你还将再次使用MetaMask来在浏览器中获取安全的区块链账户。最后，你将使用和运行Ganache来创建一个本地区块链RPC服务器，以进行测试和开发。
- en: Prerequisites
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 先决条件
- en: Most of what you need is already installed. Angular needs Node and npm manager  ,
    which you have installed previously. Confirm the correct version is installed
    by running the libraries with the v flag, just as you have done in previous chapters.>
    node -v> npm -vIn case you do not have npm and node, just run the following command:>
    brew install nodeGive npm ownership for your user so you won’t need to use sudo
    to install libraries.> sudo chown -R $USER:$GROUP ~/.npm> sudo chown -R $USER:$GROUP
    ~/.configIt’s recommended that you upgrade npm to ensure you are using the latest
    version; at the time of writing, it’s 6.9.0.> [sudo] npm install -g npm+npm@6.9.0
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分你需要的都已经安装好了。Angular需要Node和npm管理器，你之前已经安装过了。通过运行带有v标志的库来确认正确版本是否已安装，就像你在之前的章节中做的那样。`node
    -v` `npm -v`如果你没有npm和node，只需运行以下命令：`brew install node`给你的用户拥有npm的所有权，这样你就不需要使用sudo来安装库了。`sudo
    chown -R $USER:$GROUP ~/.npm` `sudo chown -R $USER:$GROUP ~/.config`建议你升级npm，以确保你使用的是最新版本；截止到撰写本文时，版本为6.9.0。`[sudo]
    npm install -g npm@6.9.0`
- en: Angular CLI
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular CLI
- en: Next, you need to install the Angular command-line interface (CLI). For Angular
    CLI, it’s recommended (but not required) to install Angular CLI with sudo and
    allow-root and ensure Angular CLI will have the correct privileges. You will be
    installing version 7.3.9, which is the latest stable release version of Angular.>
    sudo npm install -g @angular/cli@7.3.9 --unsafe-perm=true --allow-root+ @angular/cli@7.3.9added
    363 packages from 197 contributors in 13.691sYou could also install the latest
    version of Angular but your example code may break, with newer versions of Angular.>
    sudo npm install -g @angular/cli --unsafe-perm=true --allow-rootTo verify installation
    went well, run the version flag, and you should see version 7.3.9; Figure [9-2](#Fig2)
    shows the expected output.> ng version![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig2_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig2_HTML.jpg)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要安装Angular命令行接口（CLI）。对于Angular CLI，建议（但不是必须）使用sudo和allow-root安装Angular
    CLI，并确保Angular CLI具有正确的权限。你将安装版本7.3.9，这是Angular的最新稳定版本。> sudo npm install -g @angular/cli@7.3.9
    --unsafe-perm=true --allow-root+ @angular/cli@7.3.9added 363 packages from 197
    contributors in 13.691s你也可以安装Angular的最新版本，但你的示例代码可能会在新版本的Angular中损坏。> sudo npm
    install -g @angular/cli --unsafe-perm=true --allow-root为验证安装是否成功，运行版本标志，你应该看到版本7.3.9；图[9-2](#Fig2)显示了预期的输出。>
    ng version![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig2_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig2_HTML.jpg)
- en: Figure 9-2
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2
- en: Angular CLI installation verification
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI安装验证
- en: Create an Angular Project
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个Angular项目
- en: Now that you have the main tools  and libraries installed, you can proceed and
    create your project from scratch by downloading other needed libraries, test libraries,
    and build scripts, as well as make your own folder structure; however, to expedite
    this process, you can use the Angular seed project that includes a skeleton project
    to quickly bootstrap your project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了主要工具和库，你可以从头开始创建你的项目，通过下载其他需要的库、测试库和构建脚本，以及创建自己的文件夹结构；然而，为了加快这个过程，你可以使用包含骨架项目的Angular种子项目来快速引导你的项目。
- en: Using the Angular seed project can help you start development quickly and efficiently,
    following Angular's best practices. There are pros and cons of using boilerplate
    skeleton code. You can decide on your own if you want to use this skeleton for
    future projects, but for this demo app, it is ideal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular种子项目可以帮助你快速、高效地开始开发，遵循Angular的最佳实践。使用模板骨架代码有其优点和缺点。你可以自己决定是否为未来的项目使用这个骨架，但对于这个演示应用来说，它是理想的。
- en: 'There are many ways you can create your project using the Angular seed skeleton.
    I will be showing you two options here: using the Angular CLI and using WebStorm.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以使用Angular种子骨架来创建你的项目。在这里我会向你展示两个选项：使用Angular CLI和WebStorm。
- en: The ng new command  will run a script that will create your app. You can run
    the CLI new command and give the name ethdapp as your app name.> cd ~/desktop>
    ng new ethdappWould you like to add Angular routing? (y/N) yWhich stylesheet format
    would you like to use? CSS
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng new`命令将运行一个脚本来创建你的应用。你可以运行CLI新命令并将应用名称设为ethdapp。> 切换到~/桌面> ng new ethdapp你想添加Angular路由吗？（y/N）y你想使用哪种样式表格式？（CSS）'
- en: Notice that I added routing here and decided to use CSS for styles. I will get
    more into these later in the chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我在这里添加了路由，并决定使用CSS进行样式设计。我会在本章后面详细介绍这些内容。
- en: Once installation is complete, it will output all the files that are created.CREATE
    ethdapp/README.md (1024 bytes)CREATE ethdapp/angular.json (3557 bytes)CREATE ethdapp/package.json
    (1313 bytes)...Change directories to the newly created folder and confirm you
    have the initial files and directories.> cd ethdappRunning the following command
    will analyze your package.json config file with recommendations:> ng updateYou
    can run the following command to follow the recommendations:> ng update --allNext,
    install Bower globally. Bower is a package manager that is used often with Angular.
    At the time of writing, it’s at version 1.8.8.> npm install -g bower> bower -v1.8.8Let’s
    do a walk-through of what was created in a workspace and the starter project files
    (see Figure [9-3](#Fig3)).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig3_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig3_HTML.jpg)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，它会输出所有创建的文件。CREATE ethdapp/README.md (1024字节)CREATE ethdapp/angular.json
    (3557字节)CREATE ethdapp/package.json (1313字节)...切换到新创建的文件夹并确认你有初始的文件和目录。> cd ethdapp运行以下命令将分析你的package.json配置文件并提出建议：>
    ng update你可以运行以下命令来遵循建议：> ng update --all接下来，全局安装Bower。Bower是一个经常与Angular一起使用的包管理器。在撰写本文时，它处于版本1.8.8。>
    npm install -g bower> bower -v1.8.8让我们回顾一下在工作区和启动项目文件中创建了什么（见图[9-3](#Fig3)）。![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig3_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig3_HTML.jpg)
- en: Figure 9-3
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3
- en: Ethdapp files created by Angular CLI
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由Angular CLI创建的Ethdapp文件
- en: '*A new workspace*: This is the root folder named ethdapp.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的工作区：这是名为ethdapp的根文件夹。
- en: '*e2e folder*: This contains an end-to-end test project, located here: ethdapp/e2e.
    The testing folder includes the Jasmin library’s JSON configuration file.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e2e文件夹：这里包含一个端到端测试项目，位于此处：ethdapp/e2e。测试文件夹包括Jasmin库的JSON配置文件。
- en: '*src folder*: This is your project folder, which includes all the files of
    your project.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件夹：这是你的项目文件夹，包括你项目的所有文件。
- en: 'An initial skeleton app project, located here: ethdapp/src/app'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始的骨架应用项目，位于此处：ethdapp/src/app
- en: The assets folder with the entry file index.html
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含入口文件index.html的资产文件夹
- en: Other configuration files
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他配置文件
- en: '*.gitignore*: Here you list any files and folders that you would like to ignore
    when you upload your project to Git.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .gitignore：在这里列出你希望在将项目上传到Git时忽略的文件和文件夹。
- en: '*angular.json*: This is your project configuration file and includes information
    about your project.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: angular.json：这是你的项目配置文件，包括有关你的项目的信息。
- en: '*package.json*: This is the npm manager configuration file and includes all
    the libraries you will be using in your project.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: package.json：这是npm管理器的配置文件，包括你将在项目中使用的所有库。
- en: '*README.MD*: This is documentation about your project; this will be the “home
    page” document of your project and the first file developers will read to get
    instructions on how to get the project running.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: README.MD：这是关于你的项目的文档；这将是你的项目“主页”文档，也是开发者首先阅读以获取如何运行项目的指导的文件。
- en: '*tsconfig.json*: This is the TypeScript config file.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tsconfig.json：这是TypeScript配置文件。
- en: '*tslint.json*: This is the Lint config file used to set your best-practice
    formatting, spacing, and the like.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tslint.json：这是用于设置最佳实践格式化、间距等内容的Lint配置文件。
- en: Serve the Application
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务于应用程序
- en: 'To see your actual dapps, you will be using the ng serve command  , which builds
    the app, starts the development server, watches the source files, and rebuilds
    the app as you make changes to those files. The --open flag opens the app in a
    browser on port 4200 here: http://localhost:4200/. Run the ng serve command with
    the open flag.> ng serve --openYou should see the dapp running in your browser,
    as shown in Figure [9-4](#Fig4).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig4_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig4_HTML.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的实际dapp，你将使用ng serve命令，该命令会构建应用、启动开发服务器、监视源文件，并在你更改这些文件时重新构建应用。使用--open标志会在本地端口4200上打开应用：http://localhost:4200/。运行带有open标志的ng
    serve命令。> ng serve --open你应该能在浏览器中看到运行的dapp，如图[9-4](#Fig4)所示。![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig4_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig4_HTML.jpg)
- en: Figure 9-4
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4
- en: Angular seed app running in the browser
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的Angular种子应用
- en: The skeleton app includes links to a tour, documentation, and an Angular blog.
    By going through the “Tour of Heroes” and the CLI documentation, you can get a
    good understanding of how Angular works, and bookmarking the Angular blog can
    give you updates on future releases and announcements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架应用包含了通往教程、文档和一个Angular博客的链接。通过浏览“英雄之旅”和CLI文档，你可以很好地理解Angular是如何工作的，收藏Angular博客可以让你了解未来的版本更新和公告。
- en: To stop the application from serving, press Command+C in Terminal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在终端中停止应用程序的运行，请按Command+C。
- en: Angular Project with WebStorm
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在WebStorm中的Angular项目
- en: Another option for firing up the Angular seed project is utilizing the WebStorm
    IDE, which you have been using in previous chapters. WebStorm allows you to either
    import the seed project you created or create a new seed project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Angular种子项目的另一个选项是使用WebStorm IDE，你已经在之前的章节中使用过了。WebStorm允许你导入用Angular CLI创建的种子项目，或者创建一个新的种子项目。
- en: To import the ethdapp project you created with the Angular CLI ng new command,
    open WebStorm, select File ➤ Open, and navigate to the ethdapp directory. That’s
    it; WebStorm will automatically import the project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入使用Angular CLI的ng new命令创建的ethdapp项目，请打开WebStorm，选择文件➤打开，然后导航到ethdapp目录。就这样；WebStorm将自动导入该项目。
- en: Alternatively, to start a new Angular seed project in WebStorm, select File
    ➤ New ➤ Project from the top menu. Next, select Angular CLI and name your project
    **ethdapp**. Use the drop-down menu to select the version of the Angular CLI,
    as shown in Figure [9-5](#Fig5).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig5_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig5_HTML.jpg)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要在WebStorm中启动新的Angular种子项目，请从顶部菜单选择文件➤新建➤项目。接下来，选择Angular CLI并命名你的项目**ethdapp**。使用下拉菜单选择Angular
    CLI的版本，如图[9-5](#Fig5)所示。![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig5_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig5_HTML.jpg)
- en: Figure 9-5
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5
- en: Generating the Angular seed project in WebStorm
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebStorm中生成Angular种子项目
- en: Now that the project is created, you can run the same command, utilizing the
    Terminal tab in the bottom menu of WebStorm, as shown in Figure [9-6](#Fig6).>
    ng serve –open![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig6_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig6_HTML.jpg)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，你可以运行同样的命令，利用WebStorm底部菜单中的终端标签页，如图[9-6](#Fig6)所示。> ng serve –open![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig6_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig6_HTML.jpg)
- en: Figure 9-6
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6
- en: Serving ethdapp in WebStorm’s Terminal
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebStorm的终端中运行ethdapp
- en: 'You can download the skeleton application from the book repository: [https://github.com/Apress/the-blockchain-developer/chapter9/step1.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    .'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从书籍仓库下载骨架应用程序：[https://github.com/Apress/the-blockchain-developer/chapter9/step1.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    。
- en: When you download your steps, make sure you run npm install because I stripped
    out the node module to decrease the size of the project.> npm install
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你下载你的步骤时，确保你运行了npm install，因为我去掉了node模块来减小项目的大小。> npm install
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I excluded node_modules, which holds all the project’s dependencies, from the
    project. It’s common not to include it with a project because of its size; you
    can install it with the npm install command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我排除了包含项目所有依赖的node_modules目录。由于其大小，通常不将其包含在项目中；你可以使用npm install命令来安装它。
- en: Ensure No Mismatch with Angular CLI Version
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确保Angular CLI版本无冲突
- en: You can create your Angular seed project either with WebStorm or through the
    ng command, and you need to check that there is no mismatch of the global Angular
    CLI with the local project Angular CLI. This can happen when setting files pointing
    to a previous version, or you may have used Angular in the past with an older
    version. What happens is that your local project Angular shows an older version
    than the global Angular installed on your computer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用WebStorm或通过ng命令来创建你的Angular种子项目，你需要检查全局Angular CLI与本地项目Angular CLI是否有冲突。这可能发生在设置指向以前版本的文件时，或者你可能以前用过较老版本的Angular。发生的情况是，你的本地项目Angular显示的版本比计算机上安装的全局Angular
    CLI要老。
- en: 'To ensure this is not the case, run any ng command, and if this issue exists,
    you will see the following error message:> ngYour global Angular CLI version (7.3.9)
    is greater than your localversion (6.2.9). The local Angular CLI version is used.If
    you continue with these settings, you will be running version 6.x instead of 7.x.
    To fix this, what you need to do is uninstall the Angular CLI from your dev environment
    and then install version 7.x.> npm uninstall --save-dev angular-cli> npm install
    --save-dev @angular/cli@7.3.9Notice that you use the --save-dev flag so the new
    version will be saved in your package.json project file. Now if you run the version
    command again, you should see the correct version with no warning messages.> ng
    --versionAngular CLI: 7.3.2'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保这不是情况，运行任何ng命令，如果存在这个问题，您将看到以下错误消息：> ng您的全局Angular CLI版本（7.3.9）大于您的本地版本（6.2.9）。使用本地Angular
    CLI版本。如果您继续使用这些设置，您将运行6.x版本而不是7.x版本。要解决这个问题，您需要做的是从您的开发环境中卸载Angular CLI，然后安装7.x版本。>
    npm uninstall --save-dev angular-cli> npm install --save-dev @angular/cli@7.3.9注意您使用--save-dev标志，以便新版本将保存在您的package.json项目文件中。现在如果您再次运行版本命令，您应该看到没有警告消息的正确版本。>
    ng --versionAngular CLI: 7.3.2'
- en: Now that you have ensured you are running the correct version of Angular CLI,
    you are ready to continue development and make changes to the seed starter app.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经确保您正在运行正确的Angular CLI版本，您可以继续开发并修改种子启动应用。
- en: Angular Components
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular组件
- en: An Angular best practice is to use a Model View Controller (MVC)–style architecture.
    Angular supports coding with a separation of concerns just like any other mature
    framework.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular的最佳实践是使用模型-视图-控制器（MVC）风格的架构。Angular像其他任何成熟的框架一样，支持用关注点分离的方式编写代码。
- en: 'The Angular MVC includes the following three elements:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Angular MVC包括以下三个元素：
- en: '*Model*: This contains the application’s data and Angular data binding, which
    allows reflection of data.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模型*：这包含应用程序的数据和Angular数据绑定，允许数据的反射。'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: reflection in relation to data binding, elements bound to a data and any data
    change is automatically reflected. For instance, you bind price change to multiple
    view elements and once the price change data is updated all the view elements
    are updated automatically.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据绑定相关的反射，绑定到数据的元素和任何数据变化都会自动反映。例如，您将价格变化绑定到多个视图元素，一旦价格变化数据被更新，所有视图元素都会自动更新。
- en: '*View*: This contains the HTML or a template and directives.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图*：这包含HTML或模板和指令。'
- en: '*Controller*: This is the glue holding the model and the view together. The
    controller takes the data, applies business logic, and sends the results to the
    view.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制器*：这是将模型和视图粘合在一起的胶水。控制器获取数据，应用业务逻辑，并将结果发送给视图。'
- en: As you probably recall, Angular’s welcome page opened when you were running
    the serve command. The welcome component is the application shell. The shell is
    controlled by an Angular component named AppComponent.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能回忆到的，当您运行serve命令时，Angular的欢迎页面打开了。欢迎组件是应用的外壳。这个外壳是由一个名为AppComponent的Angular组件控制的。
- en: Components are the fundamental building blocks of an Angular application. They
    display data on the screen, listen for user input, and take action based on that
    input.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Angular应用的基本构建块。它们在屏幕上显示数据，监听用户输入，并根据这些输入采取行动。
- en: You will be creating a component called transfer that you will be using to transfer
    coins to another address. To create the transfer component, run the ng generate
    component command.> ng g c components/transfer
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个名为transfer的组件，用于将硬币转移到另一个地址。要创建transfer组件，请运行ng generate component命令。>
    ng g c components/transfer
- en: Notice that you used the shortcuts g and c that stand for “generate” and “component,”
    respectively, but you can also use the full name instead of the abbreviation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您使用了代表“生成”和“组件”的快捷键g和c，但您也可以使用缩写的全名。
- en: 'The ng command generated the four following files for you:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ng命令为您生成了以下四个文件：
- en: 'transfer.component.css: Component’s specific CSS styles'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: transfer.component.css：组件特定的CSS样式
- en: 'transfer.component.html: Component template, written in HTML'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: transfer.component.html：用HTML编写的组件模板
- en: 'transfer.component.spec.ts: Testing file'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: transfer.component.spec.ts：测试文件
- en: 'transfer.component.ts: Component class code, written in TypeScript'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: transfer.component.ts：用TypeScript编写的组件类代码。
- en: These four files together act as the implementation of the transfer component.
    You can see the folder structure in Figure [9-7](#Fig7).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig7_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig7_HTML.jpg)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个文件共同构成了传输组件的实现。你可以查看图[9-7](#Fig7)中的文件结构！[../images/475651_1_En_9_Chapter/475651_1_En_9_Fig7_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig7_HTML.jpg)
- en: Figure 9-7
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7
- en: Transfer component file structure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 传输组件文件结构
- en: An application’s structure is usually created with a header, a footer, and a
    navigation menu so you can navigate to different partial views.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用的结构通常由头部、底部和导航菜单组成，这样你就可以导航到不同的部分视图。
- en: Using this architecture of header and footer components can help you create
    different views and split the page view into separate files. Think of each piece
    as a stand-alone reusable UI module. Angular Seed promotes this type of architecture
    and comes with the welcome component already created. Let’s create a start component,
    a header, and footer components.> ng g c components/start> ng g c components/header>
    ng g c components/footerYou can see in the output that each component generated
    the following files:CREATE src/app/components/[component-name]/[component-name].component.cssCREATE
    src/app/components/[component-name]/[component-name].component.htmlCREATE src/app/components/[component-name]/[component-name].component.spec.tsCREATE
    src/app/components/[component-name]/[component-name].component.ts
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种头部和底部组件架构可以帮助你创建不同的视图，并将页面视图分割成单独的文件。把每一部分看作是一个独立的、可重复使用的UI模块。Angular Seed提倡这种架构，并且已经包含了欢迎组件。让我们创建一个开始组件、一个头部和一个底部组件。>
    ng g c components/start> ng g c components/header> ng g c components/footer你可以在输出中看到，每个组件生成了以下文件：CREATE
    src/app/components/[component-name]/[component-name].component.cssCREATE src/app/components/[component-name]/[component-name].component.htmlCREATE
    src/app/components/[component-name]/[component-name].component.spec.tsCREATE src/app/components/[component-name]/[component-name].component.ts
- en: In addition to these files, you can open ethdapp/src/app/app.module.ts and notice
    that the app.module.ts file was modified every time you created a component. The
    app.module.ts file is one of the most important files in Angular; it’s the app
    controller written in TypeScript. The controller is a global file that will tie
    your components together, so every component you want to use in your app needs
    to be defined in that file. If you did not use the ng script, you will need to
    modify app.module.ts yourself to link to the new component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些文件，你可以打开ethdapp/src/app/app.module.ts，并注意每次创建一个组件时app.module.ts文件都被修改了。app.module.ts文件是Angular中最重要的文件之一；它是用TypeScript编写的应用控制器。控制器是一个全局文件，将你的组件联系在一起，所以你的每个应用中想要使用的组件都需要在文件中定义。如果你没有使用ng脚本，你需要自己修改app.module.ts以链接到新的组件。
- en: Since you used the CLI, these imports are included automatically for you:*import*
    { TransferComponent } *from* './components/transfer/transfer.component';*import*
    { StartComponent } *from* './components/start/start.component';*import* { HeaderComponent
    } *from* './components/header/header.component';*import* { FooterComponent } *from*
    './components/footer/footer.component';
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了命令行界面（CLI），这些导入自动为你包含：*import* { TransferComponent } *from* './components/transfer/transfer.component';*import*
    { StartComponent } *from* './components/start/start.component';*import* { HeaderComponent
    } *from* './components/header/header.component';*import* { FooterComponent } *from*
    './components/footer/footer.component';
- en: Routing Module
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由模块
- en: Another important file and a good practice to create is an app-routing module.
    This file acts as a controller to instruct Angular how to navigate to different
    views in your app.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的文件，以及一个良好的创建实践，是创建一个app-routing模块。这个文件作为控制器，指导Angular如何导航到应用中的不同视图。
- en: Normally to generate a route for your app, you do not need to manually do so,
    since during the creation of your app, you decided to create the routing file
    called app-routing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了为你的应用生成路由，你不需要手动操作，因为在创建你的应用时，你已经决定创建一个名为app-routing的路由文件。
- en: If you need to create the app-routing file, you can run the following the module
    command:> ng generate module app-routing --flat --module=appCREATE src/app/app-routing.module.tsUPDATE
    src/app/app.module.ts
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建app-routing文件，你可以运行以下模块命令：> ng generate module app-routing --flat --module=appCREATE
    src/app/app-routing.module.tsUPDATE src/app/app.module.ts
- en: Notice that this time in your command you are using the full name generate module
    instead of just the first letters of g and m. Both options work the same way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次在你的命令中，你使用的是生成模块的全名，而不是只是g和m的首字母。这两个选项工作方式相同。
- en: 'The generate module command creates the initial code shown in Listing [9-1](#PC24)
    for src/app/app-routing.module.ts.*import* { NgModule } *from* ''@angular/core'';*import*
    { Routes, RouterModule } *from* ''@angular/router'';*const* routes: Routes = [];@NgModule({  imports:
    [RouterModule.forRoot(routes)],  exports: [RouterModule]})*export class* AppRoutingModule
    { }Listing 9-1'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate module`命令为`src/app/app-routing.module.ts`创建了初始代码，如列表[9-1](#PC24)所示。`import`
    { NgModule } `from` ''@angular/core'';`import` { Routes, RouterModule } `from`
    ''@angular/router'';`const` routes: Routes = [];@NgModule({  declarations: [],  imports:
    [RouterModule.forRoot(routes)],  exports: [RouterModule]})`export class` AppRoutingModule
    `{ }`列表[9-1]。'
- en: app-routing Initial Startup Code
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`app-routing`的初始启动代码。'
- en: 'The initial code includes an import statement  to Angular code and module tag.
    Next, replace the pre-populated code of app-routing.module.ts file with the code
    in Listing [9-2](#PC25).import { NgModule } from ''@angular/core'';import { CommonModule
    } from ''@angular/common'';import { RouterModule, Routes } from ''@angular/router'';import
    { StartComponent } from ''./components/start/start.component'';import { TransferComponent
    } from ''./components/transfer/transfer.component'';const routes: Routes = [  {
    path: '''', redirectTo: ''/start'', pathMatch: ''full'' },  { path: ''start'',
    component: StartComponent },  { path: ''transfer'', component: TransferComponent
    }];@NgModule({  declarations: [],  imports: [ RouterModule.forRoot(routes), CommonModule
    ],  exports: [ RouterModule ]})export class AppRoutingModule { }Listing 9-2'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '初始代码包括一个导入Angular代码和模块标签的`import`语句。接下来，用列表[9-2](#PC25)中的代码替换`app-routing.module.ts`文件中的预填充代码。`import`
    { NgModule } `from` ''@angular/core'';`import` { CommonModule } `from` ''@angular/common'';`import`
    { RouterModule, Routes } `from` ''@angular/router'';`import` { StartComponent
    } `from` ''./components/start/start.component'';`import` { TransferComponent }
    `from` ''./components/transfer/transfer.component'';const routes: Routes = [  {
    path: '''', redirectTo: ''/start'', pathMatch: ''full'' },  { path: ''start'',
    component: StartComponent },  { path: ''transfer'', component: TransferComponent
    }];@NgModule({  declarations: [],  imports: [ RouterModule.forRoot(routes), CommonModule
    ],  exports: [ RouterModule ]})`export class` AppRoutingModule `{ }`列表[9-2]。'
- en: app-routing Code to Route Views
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`app-routing`路由视图的代码。'
- en: In Listing [9-2](#PC24), you imported the view components you will be using;
    these are start and transfer. They will act as web pages on a web site or partial
    views on a mobile app. The route tells your app what view to match with what keyword,
    and lastly you set import statements to tell Angular who can access this module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表[9-2](#PC24)中，你导入了你将要使用的视图组件；这些是`start`和`transfer`。它们将作为网站上的网页或移动应用上的部分视图。路由告诉你的应用如何将视图与关键词匹配，最后你设置导入语句以告诉Angular谁可以访问这个模块。
- en: 'Now that the routing is set, you can get the footer, header, and body of the
    page to display. All you have to do is open src/app/app.component.html and update
    from the welcome page’s HTML code to the following three lines:<app-header></app-header><router-outlet></router-outlet><app-footer></app-footer>To
    test the changes you made to your application, you don’t need to publish your
    app again or run any scripts; just save the files and run the same serve command  you
    ran before in Terminal.> ng serve⌈wdm⌋: Compiled successfully.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '现在路由设置完成了，你可以让页面的页脚、页头和主体显示出来。你只需要打开`src/app/app.component.html`文件，从欢迎页面的HTML代码更新到以下三行：`<app-header></app-header><router-outlet></router-outlet><app-footer></app-footer>`。为了测试你对应用程序所做的更改，你不需要再次发布你的应用或运行任何脚本；只需保存文件并运行你在终端中之前运行过的相同的`serve`命令。`ng
    serve`命令成功编译后，会显示`wdm: Compiled successfully.`。'
- en: The serve script includes scripts to watch for changes in files and update your
    app automatically, so all you have to do when you make a change to your files
    is go back to the browser. Most of the time you won’t even need to refresh your
    web page; the changes will be there automatically. Navigate to http://localhost:4200
    to see the changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve`脚本包括监控文件变化并自动更新你的应用的脚本，所以当你对你的文件做出更改时，你只需要回到浏览器。大多数时候你甚至不需要刷新你的网页；更改会自动出现。访问`http://localhost:4200`以查看更改。'
- en: 'If you would like to go directly to the transfer page, all you have to do is
    add the keyword you selected at the end of the URL as you set up the routing mechanism:
    http://localhost:4200/transfer. See Figure [9-8](#Fig8).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig8_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig8_HTML.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接转到转账页面，你只需要在设置路由机制时在URL末尾添加你选择的关键词：`http://localhost:4200/transfer`。见图[9-8](#Fig8)。![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig8_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig8_HTML.jpg)。
- en: Figure 9-8
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8。
- en: Ethdapp header, footer, and transfer page
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊应用的页脚、页头和转账页面。
- en: 'You can download this step here: [https://github.com/Apress/the-blockchain-developer/chapter9/step2.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    .'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载这个步骤：[https://github.com/Apress/the-blockchain-developer/chapter9/step2.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    。
- en: Styling an Angular App
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Angular应用程序设置样式
- en: Your app at this point is not styled and only shows text with a header, the
    page, and a footer; however, before you start styling, it’s helpful to understand
    the Angular style architecture to ensure you don’t end up with a Cascading Style
    Sheets (CSS) file that is too big to manage. You can style your app on a global
    level with styles that you need across your entire app as well as a specific style
    unique to only one component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的应用程序没有样式，只显示带有标题、页面和页脚的文本；然而，在你开始样式设计之前，了解Angular样式架构是有帮助的，以确保你不会最终创建一个太大而难以管理的Cascading
    Style Sheets (CSS)文件。你可以为整个应用程序设置全局样式，以及只适用于一个组件的独特样式。
- en: Additionally, it would be neat to sprint from zero to a styled app quickly.
    This can be done with Angular Material. Angular Material gives you a shortcut
    to get a consistent “look” to your app without all the hassle of thinking about
    cross-browser, cross-device programming. Let’s take a look.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，快速从零开始构建一个有样式的应用程序会很有趣。这可以通过Angular Material实现。Angular Material为你提供了一个捷径，让你无需考虑跨浏览器、跨设备编程的所有麻烦，就能为你的应用程序带来一致的“外观”。让我们来看看。
- en: Angular-Style Architecture
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular样式架构
- en: Angular  is set up to have a global CSS file. That CSS file is called style.css,
    and you can find it in the root of the project. src/style.css holds the styles
    that you want to use for your entire app, such as fonts, themes, styles for all
    the components, and so on.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 设置了一个全局CSS文件。这个CSS文件叫做style.css，你可以在项目的根目录中找到它。src/style.css 文件包含了你想要为整个应用程序使用的样式，例如字体、主题、所有组件的样式等。
- en: As you have seen, each component also includes a private CSS file. The specific
    component CSS file is where you put styles that are unique and used only for that
    component.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每个组件还包括一个私有的CSS文件。特定组件的CSS文件是你放置只用于该组件的独特样式的地方。
- en: For instance, /src/app/components/footer/footer.component.css holds the styles
    specific for the footer component.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，/src/app/components/footer/footer.component.css 文件包含了特定于页脚组件的样式。
- en: Angular Material
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular Material
- en: Right now, your starter application is fast because it includes minimal code;
    however, there is a potential performance issue as you add more and more components,
    assets, and style to your app. You can get your app bloated easily, and every
    millisecond dealy counts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的起始应用程序很快，因为它包含了最少的代码；然而，随着你添加越来越多的组件、资产和样式，你的应用程序可能会存在潜在的性能问题。你的应用程序很容易变得庞大，每一毫秒的延迟都很重要。
- en: The other potential issue is testing. All the different browsers, versions of
    browsers, screen sizes, and devices need to be tested, and creating your pages
    from scratch will require rigid testing and a quality assurance (QA) team to ensure
    it works consistency across devices.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的问题是测试。所有不同的浏览器、浏览器的不同版本、屏幕尺寸和设备都需要进行测试，从头开始创建你的页面将需要严格的测试和质量保证（QA）团队，以确保它在一系列设备上都能保持一致性工作。
- en: Angular Material solves all these issues plus provides accessibility and internationalization.
    That is because Angular Material is optimized for Angular and built by the Angular
    team, so it integrates seamlessly with Angular. It has already passed all these
    compatibility tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material解决了所有这些问题，并提供可访问性和国际化功能。这是因为Angular Material针对Angular进行了优化，由Angular团队构建，因此它与Angular无缝集成。它已经通过了所有这些兼容性测试。
- en: 'For more information, check the Angular Material getting started page: [https://material.angular.io/guide/getting-started](https://material.angular.io/guide/getting-started)
    .'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看Angular Material入门页面：[https://material.angular.io/guide/getting-started](https://material.angular.io/guide/getting-started)
    。
- en: Install Angular Material
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装Angular Material
- en: 'There are a few ways to install Material. Because you have installed the Angular
    DevKit, you are able to just run the ng add command to get the Angular Material
    library. You need to first install cdk because it’s a dependency.> ng add @angular/cdkNext,
    install Material.> ng add @angular/materialNotice that the output asks you which
    theme color you would like with links. I will cover themes in the next section
    of this chapter, but for now, select the first or any color you prefer.? Choose
    a prebuilt theme name, or "custom" for a custom theme: (Use arrow keys)□ Indigo/Pink       [
    Preview: https://material.angular.io?theme=indigo-pink ]  Deep Purple/Amber  [
    Preview: https://material.angular.io?theme=deeppurple-amber ]  Pink/Blue Grey     [
    Preview: https://material.angular.io?theme=pink-bluegrey ]  Purple/Green       [
    Preview: https://material.angular.io?theme=purple-green ]You can also set up gesture
    recognitions and animations.? Set up HammerJS for gesture recognition? Yes? Set
    up browser animations for Angular Material? YesThe expected output should be showing
    the files that were updated:UPDATE package.jsonUPDATE angular.jsonUPDATE src/app/app.module.tsUPDATE
    src/index.htmlUPDATE src/styles.css'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Material有几种方法。因为你已经安装了Angular DevKit，所以你可以运行ng add命令来获取Angular Material库。你需要先安装cdk，因为它是一个依赖。>
    ng add @angular/cdkNext，安装Material。> ng add @angular/material注意输出会询问你想要哪种主题颜色以及相应的链接。我将在本章的下一节中介绍主题，但现在，选择第一个或你喜欢的任何颜色。?
    选择一个预设的主题名，或者"custom"用于自定义主题：（使用箭头键）□ Indigo/Pink [预览：https://material.angular.io?theme=indigo-pink]  Deep
    Purple/Amber [预览：https://material.angular.io?theme=deeppurple-amber]  Pink/Blue
    Grey [预览：https://material.angular.io?theme=pink-bluegrey]  Purple/Green [预览：https://material.angular.io?theme=purple-green]你还可以设置手势识别和动画。?
    为手势识别设置HammerJS？ 是? 为Angular Material设置浏览器动画？ 是预期的输出应该显示被更新的文件：UPDATE package.jsonUPDATE
    angular.jsonUPDATE src/app/app.module.tsUPDATE src/index.htmlUPDATE src/styles.css
- en: Import Angular Material Modules
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入Angular Material模块
- en: Next, you want to modify your app to have Angular Material include animations,
    Material icons, gesture support, and component modules.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你希望修改你的应用，使其包含Angular Material的动画、Material图标、手势支持和组件模块。
- en: 'In your project, you will only be using component modules and not all the features
    that Angular Material has to offer; what you need to do is import NgModule for
    each component you want to use. Open src/app/app.module.ts and add the import
    statements.import {  MatButtonModule,  MatCheckboxModule,  MatInputModule,  MatSelectModule,  MatDatepickerModule,  MatNativeDateModule}
    from ''@angular/material'';Next, update the import statements of @NgModule to
    include the Material modules you imported.imports: [    BrowserModule,    AppRoutingModule,    BrowserAnimationsModule,    MatButtonModule,    MatInputModule,    MatDatepickerModule,    MatNativeDateModule,    MatCheckboxModule,    MatSelectModule  ]'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '在你的项目中，你将只使用组件模块，并不会使用Angular Material提供的所有功能；你需要做的是为每个你想使用的组件导入NgModule。打开src/app/app.module.ts，并添加导入语句。import
    {  MatButtonModule,  MatCheckboxModule,  MatInputModule,  MatSelectModule,  MatDatepickerModule,  MatNativeDateModule}
    from ''@angular/material'';接下来，更新@NgModule的导入语句，包含你导入的Material模块。imports: [    BrowserModule,    AppRoutingModule,    BrowserAnimationsModule,    MatButtonModule,    MatInputModule,    MatDatepickerModule,    MatNativeDateModule,    MatCheckboxModule,    MatSelectModule  ]'
- en: That’s it. You can now have access to the Angular Material components you included.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在你可以访问你包含的Angular Material组件了。
- en: Theme Your Angular Material App
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题你的Angular Material应用
- en: Now that you have access to the Angular Material components, you can use themes
    to style them. A *theme* is a set of colors that will be used on your Angular
    Material components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经可以访问Angular Material组件了，你可以使用主题来为它们设置样式。*主题*是一组颜色，将用于你的Angular Material组件。
- en: In Angular Material, a theme is created by creating multiple palettes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular Material中，通过创建多个调色板来创建一个主题。
- en: '*Primary palette*: These are the colors most used across all screens and components.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主调色板*：这些颜色在所有屏幕和组件中最常使用。'
- en: '*Accent palette*: These are the colors used for the button and interactive
    elements.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强调调色板*：这些颜色用于按钮和交互元素。'
- en: '*Warn palette*: These are the colors for errors.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*警告调色板*：这些颜色用于错误。'
- en: '*Foreground palette*: These are the colors for text and icons.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前景调色板*：这些颜色用于文本和图标。'
- en: '*Background palette*: These are the colors for an element’s backgrounds.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*背景调色板*：这些颜色用于元素的背景。'
- en: In Angular Material, all theme styles are generated statically at build time
    to avoid slowing the app on startup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular Material中，所有主题样式在构建时静态生成，以避免在应用启动时减慢应用速度。
- en: Angular Material comes prepackaged with several prebuilt theme CSS files. As
    you probably recall, you had an option of selecting a theme to use when you installed
    Material.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material随附了几个预构建的主题CSS文件。正如你可能记得的，当你安装Material时，你有一个选择主题的机会。
- en: These theme files also include all of the styles for the core (styles common
    to all components), so you have to include only a single CSS file for Angular
    Material in your app. You can include a theme file directly into your application
    from @angular/material/prebuilt-themes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题文件包含了所有核心样式（所有组件共有的样式），因此你只需在你的应用程序中包含一个Angular Material的CSS文件。你可以直接从@angular/material/prebuilt-themes中把主题文件引入到你的应用程序中。
- en: 'These are the available prebuilt themes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用的预构建主题：
- en: deeppurple-amber.css
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: deeppurple-amber.css
- en: indigo-pink.css
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: indigo-pink.css
- en: pink-bluegrey.css
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pink-bluegrey.css
- en: purple-green.css
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: purple-green.css
- en: You are using Angular CLI here, so you can simply include the style you want
    in the global src/styles.css file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里使用的是Angular CLI，所以你只需在全球src/styles.css文件中包含你想要的样式。
- en: 'Originally it has this initial precode:html, body { height: 100%; }body { margin:
    0; font-family: ''Roboto'', sans-serif; }Add the following import statement at
    the top of the document:@import "~@angular/material/prebuilt-themes/indigo-pink.css";While
    you have the src/style.css file open, you can also create a style for a container,
    a paragraph, and a button that you can use across your app for your pages.p {  padding-left:
    20px;  font-size: 12px;}.container {  margin-right: auto;  margin-left: auto;  padding:
    20px 15px 30px;  width: 750px;}button {  color: #ffffff;  background-color: #611BBD;  border-color:
    #130269;  display: inline-block;  margin-bottom: 0;  font-weight: normal;  text-align:
    center;  vertical-align: middle;  touch-action: manipulation;  cursor: pointer;  white-space:
    nowrap;  padding: 6px 12px;  font-size: 12px;  line-height: 1.42857143;  border-radius:
    4px;  -webkit-user-select: none;  -moz-user-select: none;  -ms-user-select: none;  user-select:
    none;}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '原始的初始预代码是这样的：html, body { height: 100%; }body { margin: 0; font-family: ''Roboto'',
    sans-serif; }在文档顶部添加以下导入语句：@import "~@angular/material/prebuilt-themes/indigo-pink.css";在你打开src/style.css文件的同时，你还可以为容器、段落和按钮创建一个样式，这样你就可以在整个应用程序中为你的页面使用这些样式。p
    {  padding-left: 20px;  font-size: 12px;}.container {  margin-right: auto;  margin-left:
    auto;  padding: 20px 15px 30px;  width: 750px;}.button {  color: #ffffff;  background-color:
    #611BBD;  border-color: #130269;  display: inline-block;  margin-bottom: 0;  font-weight:
    normal;  text-align: center;  vertical-align: middle;  touch-action: manipulation;  cursor:
    pointer;  white-space: nowrap;  padding: 6px 12px;  font-size: 12px;  line-height:
    1.42857143;  border-radius: 4px;  -webkit-user-select: none;  -moz-user-select:
    none;  -ms-user-select: none;  user-select: none;}.'
- en: 'You can compare your files with mine: [https://github.com/Apress/the-blockchain-developer/chapter9/step3.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    .'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以和你我的文件进行比较：[https://github.com/Apress/the-blockchain-developer/chapter9/step3.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    。
- en: Creating Content
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建内容
- en: At this point, you have a skeleton app with a header, body, and footer. The
    body can be switched between your start page and transfer page by changing the
    URL in the browser. You also imported and injected Material modules and set up
    global styles for your app. The next step is to create actual content to replace
    the temporary text message you placed in your header, footer, and start components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你已经有一个带有头部、身体和脚部的骨架应用程序。通过在浏览器中更改URL，身体可以在起始页面和转移页面之间切换。你还导入了并注入了Material模块，为你的应用程序设置了全局样式。下一步是创建实际内容来替换你放在头部、脚部和起始组件中的临时文本消息。
- en: Footer Component
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 页脚组件
- en: 'For the footer component, you will just replace the message for your company
    copyright. To do so, all you need to do is open src/app/components/footer/footer.component.html
    and replace the default code.<p>  footer works!</p>Replace the code by creating
    a div container with the style you added to the global CSS file.<div class="ng-scope">  <div
    class="container">    <p>Copyright (c) 2019 Company Name. All Rights Reserved.</p>  </div></div>You
    are also going to create a specific style for the footer component, so every time
    you use the p tag, your font will be size 12px with no padding on the left. Open
    src/app/components/footer/footer.component.css and insert the following:p {  padding-left:
    0;  font-size: 11px;}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '对于页脚组件，你只需替换你公司版权的信息。为此，你只需要打开src/app/components/footer/footer.component.html文件，并替换默认代码。<p>  footer
    works!</p>用你在全局CSS文件中添加的样式创建一个div容器替换代码。<div class="ng-scope">  <div class="container">    <p>Copyright
    (c) 2019 公司名称。保留所有权利。</p>  </div></div>你还将为页脚组件创建一个特定的样式，所以每次你使用p标签时，你的字体大小将是12px，并且左边没有内边距。打开src/app/components/footer/footer.component.css并插入以下内容：p
    {  padding-left: 0;  font-size: 11px;}.'
- en: Notice that you defined the <p> tag twice, once in the global CSS file and one
    at the component level. What’s going to happen is that the global <p> tag will
    be overwritten by the component <p>, so you can use the <p> tag for your footer
    and a different <p> tag  for other components such as the start and transfer pages
    while keeping your HTML code free of CSS code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您在全局CSS文件和组件级别定义了两次`<p>`标签。发生的情况是全局`<p>`标签将被组件`<p>`覆盖，因此您可以在页脚中使用`<p>`标签，为开始和转账页面等其他组件使用不同的`<p>`标签，同时保持HTML代码中不包含CSS代码。
- en: Header Component
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 头部组件
- en: 'For the header component, you will create a navigation menu to be able to switch
    between the start page and the transfer page. For styles specific to the header
    component, open src/app/components/header/header.component.css and add the nav
    list styles..nav {  margin-bottom: 0;  padding-left: 0;  list-style: none;}li
    {  display: block;  float: left;  width: 100px;  height: 25px;  padding: 5px;}.nav>li>a
    {  margin-bottom: 0;  padding-left: 0;  font-weight: 500;  font-size: 12px;  text-transform:
    uppercase;  position: relative;}For src/app/components/header/header.component.html,
    you create a container and a list of the two links to the pages start and transfer.
    To do so replace the initial code:<p>  header works!</p>with the following;<div
    class="ng-scope">  <div class="container">    <ul class="nav">      <li>        <a
    routerLink=''/start''>home</a>      </li>      <li>        <a routerLink=''/transfer''>transfer</a>      </li>    </ul>  </div></div>The
    working dapp now includes basic styling and functional navigation, as shown in
    Figure [9-9](#Fig9).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig9_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig9_HTML.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '对于头部组件，您将创建一个导航菜单，以便能够在开始页面和转账页面之间进行切换。对于头部组件特定的样式，请打开`src/app/components/header/header.component.css`，并添加导航列表样式。.nav
    {  margin-bottom: 0;  padding-left: 0;  list-style: none;}li {  display: block;  float:
    left;  width: 100px;  height: 25px;  padding: 5px;}.nav>li>a {  margin-bottom:
    0;  padding-left: 0;  font-weight: 500;  font-size: 12px;  text-transform: uppercase;  position:
    relative;}对于`src/app/components/header/header.component.html`，您创建一个容器和一个到页面开始和转账的链接列表。为此，将初始代码：<p>  header
    works!</p>替换为以下内容：<div class="ng-scope">  <div class="container">    <ul class="nav">      <li>        <a
    routerLink=''/start''>home</a>      </li>      <li>        <a routerLink=''/transfer''>transfer</a>      </li>    </ul>  </div></div>现在，运行中的dapp包括了基本的样式和功能导航，如图[9-9](#Fig9)所示！[../images/475651_1_En_9_Chapter/475651_1_En_9_Fig9_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig9_HTML.jpg)'
- en: Figure 9-9
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9
- en: Ethdapp with basic styling and working navigation
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 具有基本样式和导航功能的Ethdapp
- en: 'You can download this step here: [https://github.com/Apress/the-blockchain-developer/chapter9/step4.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)
    .'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载此步骤：[https://github.com/Apress/the-blockchain-developer/chapter9/step4.zip](https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html)。
- en: Transfer Component
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转账组件
- en: The transfer component  will hold a form that you will submit to transfer Ethereum
    coins from one account address to another. You will be using the forms module
    to expedite creating your form. To do so, you need to include the Material FormsModule
    and ReactiveFormsModule form modules in app.module.ts just as you did with other
    Material modules.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 转账组件将包含一个表单，您将提交该表单以将以太坊硬币从一个账户地址转移到另一个。您将使用表单模块来加速创建您的表单。为此，您需要在`app.module.ts`中包含Material
    FormsModule和ReactiveFormsModule表单模块，就像您对其他Material模块所做的那样。
- en: 'Open src/app/app.module.ts and add the following import statement:import {
    FormsModule, ReactiveFormsModule } from ''@angular/forms'';You also want to update
    the import statement  .  imports: [    FormsModule,    ReactiveFormsModule,    ..]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '打开`src/app/app.module.ts`并添加以下导入语句：import { FormsModule, ReactiveFormsModule
    } from ''@angular/forms'';您还需要更新导入语句。  imports: [    FormsModule,    ReactiveFormsModule,    ..]'
- en: You will be using the <mat-form-field> tag, which represents a component that
    wraps several Angular Material components together and applies common text field
    styles such as the underline, floating label, and hint messages. This will expedite
    development as you won’t need to implement all of these and test them on multiple
    devices/browsers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`<mat-form-field>`标签，该标签代表一个包装多个Angular Material组件并应用常见文本字段样式的组件，如下划线、浮动标签和提示信息。这将加快开发速度，因为您不需要实现所有这些并测试它们在多种设备/浏览器上。
- en: The form field is the wrapper component named <mat-form-field>. You can use
    any of the form field controls (such as input, textarea, list, etc.).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段是名为`<mat-form-field>`的包装组件。您可以使用任何表单字段控件（如输入、文本区域、列表等）。
- en: 'You can find information about mat-forms here: [https://material.angular.io/components/form-field/overview](https://material.angular.io/components/form-field/overview)
    .'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到关于mat-forms的信息：[https://material.angular.io/components/form-field/overview](https://material.angular.io/components/form-field/overview)
    。
- en: 'For src/app/components/transfer/transfer.component.ts, you will update the
    initial code. First you need to import the components you will be using; in this
    case, you need to initialize the class and use form, form control, and validators.import
    {FormBuilder, FormControl, FormGroup, Validators} from ''@angular/forms'';Then
    you need to update the component definition to implement the OnInit method  .export
    class TransferComponent implements OnInit {You will be using a flag to indicate
    whether the form was submitted and to create an instance of a form group, as well
    as an object called user, to hold the user’s information.  formSubmitted: Boolean
    = false;  userForm: FormGroup;  user: any;To validate your form, you will define
    the messages in case the form is not filled in correctly. Each form control needs
    to be defined with the required fields and messages.  account_validation_messages
    = {    ''transferAddress'': [      { type: ''required'', message: ''Transfer Address
    is required'' },      { type: ''minLength'', message: ''Transfer Address must
    be 42 characters long'' },      { type: ''maxLength'', message: ''Transfer Address
    must be 42 characters long'' }    ],    ''amount'': [      { type: ''required'',
    message: ''Amount is required'' },      { type: ''pattern'', message: ''Amount
    must be a positive number'' }    ],    ''remarks'': [      { type: ''required'',
    message: ''Remarks are required'' }    ]  };When you create the constructor, you
    need to include the FormBuilder component  to be able to generate the form.  constructor(private
    fb: FormBuilder) { }When your component gets init, you will set the formSubmitted
    flag to false and set default values for the user’s information. You then will
    call a method to go fetch the user’s account and balance, which you will implement
    later. Lastly, you will call the createForms method that will generate the form.  ngOnInit()
    {    this.formSubmitted = false;    this.user = {address: '''', transferAddress:
    '''', balance: '''', amount: '''', remarks: ''''};    this.getAccountAndBalance();    this.createForms();  }The
    createForms method will generate the form controls by passing the validators and
    data.  createForms() {    this.userForm = this.fb.group({      transferAddress:
    new FormControl(this.user.transferAddress, Validators.compose([        Validators.required,        Validators.minLength(42),        Validators.maxLength(42)      ])),      amount:
    new FormControl(this.user.amount, Validators.compose([        Validators.required,        Validators.pattern(''^[+]?([.]\\d+|\\d+[.]?\\d*)$'')      ])),      remarks:
    new FormControl(this.user.remarks, Validators.compose([        Validators.required      ]))    });  }The
    getAccountAndBalance method  will set the user account’s address and balance;
    for now you are using dummy data, but you will implement the actual service later
    in this chapter.  getAccountAndBalance = () => {    const that = this;    that.user.address
    = ''0xd8d0101f83e79fb4e8d21134f5325e64816bd6a0'';    that.user.balance = 0;    //
    TODO: fetch data  }Lastly, once you submit your form, you need a method to handle
    the data and call the service. submitForm will be used by checking whether the
    form is valid, and then later you will call the service component you will create.  submitForm()
    {    if (this.userForm.invalid) {      alert(''transfer.components :: submitForm
    :: Form invalid'');      return;    } else {      console.log(''transfer.components
    :: submitForm :: this.userForm.value'');      console.log(this.userForm.value);      //
    TODO: service call    }  }}For transfer.component.html, you will set the form
    tag to call the submitForm method once the form is submitted.<form [formGroup]="userForm"
    (ngSubmit)="submitForm()"      novalidate autocomplete="off">Next, you will create
    the wrapping divs and use data binding to display the user’s account address and
    balance.  <div class="container">    <div class="transfer-container">      <div>        Address:
    {{user.address}} <br/>        Balance: {{user.balance}} Eth      </div>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`src/app/components/transfer/transfer.component.ts`，你需要更新初始代码。首先，你需要导入你将要使用的组件；在这个案例中，你需要初始化类并使用表单、表单控制和验证器。```typescript
- en: Notice that you have used the transfer-container style  , which you have not
    yet defined; you will define it in your CSS file, and it will be used to format
    your form.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意你已经使用了`transfer-container`样式，你还没有定义它；你将在你的 CSS 文件中定义它，并用来格式化你的表单。
- en: 'For form controls, you need input boxes for the account you are transferring
    the funds to, the amount, and a message. You also need to set up your validations.      <mat-form-field>        <input
    matInput placeholder="Transfer Address" name="transferAddress" formControlName="transferAddress"               maxlength="42"
    minlength="42" required>        <mat-error *ngFor="let validation of account_validation_messages.transferAddress">          <mat-error
    *ngIf="userForm.get(''transferAddress'').hasError(validation.type) && (userForm.get(''transferAddress'').dirty
    || userForm.get(''transferAddress'').touched)">{{validation.message}}</mat-error>        </mat-error>      </mat-form-field>      <mat-form-field>        <input
    matInput placeholder="Amount" name="amount" formControlName="amount" required>        <mat-error
    *ngFor="let validation of account_validation_messages.amount">          <mat-error
    *ngIf="userForm.get(''amount'').hasError(validation.type) && (userForm.get(''amount'').dirty
    || userForm.get(''amount'').touched)">{{validation.message}}</mat-error>        </mat-error>      </mat-form-field>      <mat-form-field>        <input
    matInput placeholder="Remarks" name="remarks" formControlName="remarks"               maxlength="42"
    required>        <mat-error *ngFor="let validation of account_validation_messages.remarks">          <mat-error
    *ngIf="userForm.get(''remarks'').hasError(validation.type) && (userForm.get(''remarks'').dirty
    || userForm.get(''remarks'').touched)">{{validation.message}}</mat-error>        </mat-error>      </mat-form-field>Lastly,
    remember to close the divs and form, as well as include a submit button.      <div
    style="width: 100px">        <button type="submit">Transfer Ether</button>      </div>    </div>  </div></form>For
    transfer.component.css, you will be using the transfer-container div to format
    your form horizontally..transfer-container {  display: flex;  flex-direction:
    column;}.transfer-container > * {  width: 100%;}That’s it. Now you can check your
    dapp in the browser, and you should be able to see the user’s default data, test
    the form, validate it, and submit the form. See Figure [9-10](#Fig10).![../images/475651_1_En_9_Chapter/475651_1_En_9_Fig10_HTML.jpg](../images/475651_1_En_9_Chapter/475651_1_En_9_Fig10_HTML.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表单控件，你需要为你要转账的账户、金额和一个消息输入框，你还需要设置你的验证。
- en: Figure 9-10
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10。
- en: Ethdapp transfer page including user’s info, validators, and submit button
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用户信息、验证器和提交按钮的 Ethereum DApp 转账页面。
- en: 'You can download this step here: [https://github.com/Apress/the-blockchain-developer/chapter9/step5.zip](https://github.com/Apress/the-blockchain-developer/chapter9/step5.zip)
    .'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里下载这个步骤：[https://github.com/Apress/the-blockchain-developer/chapter9/step5.zip](https://github.com/Apress/the-blockchain-developer/chapter9/step5.zip)。
- en: Angular Directives
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular 指令。
- en: Creating directives in Angular gives you the ability to create your own custom
    HTML tags with just a few lines of code, just as you saw in the Material form.
    You were able to include custom tags that wrap many components. At a high level,
    directives are markers on a DOM element.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中创建指令为你提供了通过几行代码创建你自己的自定义HTML标签的能力，正如你在Material表单中看到的那样。你能够包含许多组件的自定义标签。在高级层面上，指令是DOM元素上的标记。
- en: These markers can point to any DOM component, from an attribute to an element
    name or even a comment or CSS class. These markers then tell the AngularJS's HTML
    compiler to attach a specified behavior or to transform the entire DOM element
    and its children based on specific logic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标记可以指向任何DOM组件，从属性到元素名称，甚至是注释或CSS类。这些标记然后告诉AngularJS的HTML编译器附加一个指定的行为，或者根据特定逻辑将整个DOM元素及其子元素转换。
- en: Angular comes with many of these directives built-in. However, during development,
    it’s a good chance you will be creating your own directives. Your dapp is simple
    now, so you don’t need to create any directive, and it’s beyond the scope of this
    chapter to explain this. When you do need to generate a skeleton directive, use
    the Angular CLI just as you generated other components.> ng generate directive
    {directive-name}
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自带了许多这些指令。然而，在开发过程中，你很可能会创建你自己的指令。你的dapp现在很简单，所以你不需要创建任何指令，而且这超出了本章节的解释范围。当你需要生成一个骨架指令时，就像你生成其他组件一样使用Angular
    CLI。> ng generate directive {directive-name}
- en: Although you are not creating a directive in your app, I wanted to introduce
    you to the concept as it’s an integral part of creating an Angular project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在你的应用中没有创建指令，但我还是想向你介绍这个概念，因为它是创建Angular项目的一个组成部分。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you took a deep dive into what a dapp is and looked at dapp
    classifications and projects. You learned how to start your own dapp project by
    breaking the process into five steps: writing a white paper, launching an ICO,
    developing the dapp, launching it, and marketing your dapp.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节，你深入了解了什么是dapp，并查看了dapp的分类和项目。你学习了如何通过五个步骤开始你自己的dapp项目：编写白皮书，启动ICO，开发dapp，启动它，以及推广你的dapp。
- en: You then looked at why to use Angular. Next, you created an Angular dapp, first
    ensuring the prerequisites were installed and installing the Angular CLI. Then
    you created an Angular project and served the application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你了解了为什么使用Angular。接下来，你创建了一个Angular dapp，首先确保预先安装了必备条件并安装了Angular CLI。然后你创建了一个Angular项目并服务了应用程序。
- en: Next, you learned how to import your Angular project to WebStorm or create a
    new project. You looked at the pieces that make Angular such as components, modules,
    and directives. You also learned how to style the dapp by understanding Angular-style
    architecture and working with Angular Material.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何将你的Angular项目导入WebStorm或创建一个新的项目。你查看了使Angular成为可能的部分，比如组件、模块和指令。你还学会了如何通过理解Angular风格架构和与Angular
    Material一起工作来样式化dapp。
- en: You started building components and created content; you split your app into
    a footer, header, and body and created a custom component called transfer that
    includes a form to be able to later transfer tokens.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始构建组件并创建内容；你将你的应用分为页脚、页头和主体，并创建了一个名为transfer的自定义组件，其中包含了一个表单，以便后来转移代币。
- en: In the next chapter, you will create a transfer smart contract and a Truffle
    development project as well as connect to the Ganache development network. You
    will learn how to work with the Ethereum network via Truffle and test your smart
    contract. You also will link your dapp with the Ethereum Network’s web3 library
    and connect via MetaMask.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节，你将创建一个转移智能合约和一个Truffle开发项目，以及连接到Ganache开发网络。你将学习如何通过Truffle与以太坊网络交互，并测试你的智能合约。你还将把你的dapp与以太坊网络的web3库链接起来，并通过MetaMask进行连接。
