- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[Part III](contents.xhtml#rpart3)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第三部分](contents.xhtml#rpart3)'
- en: '[Probabilistic Data Structures: An Overview](contents.xhtml#rpart3)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[概率数据结构概述](contents.xhtml#rpart3)'
- en: </hgroup>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: <hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[9](contents.xhtml#rchapter9)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[9](contents.xhtml#rchapter9)'
- en: '[Introduction to Probabilistic Data Structures](contents.xhtml#rchapter9)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[概率数据结构简介](contents.xhtml#rchapter9)'
- en: </hgroup>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[9.1 Need of Probabilistic Data Structures](contents.xhtml#rsec9_1)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[9.1 概率数据结构的需求](contents.xhtml#rsec9_1)'
- en: There is an exponential increase in the generation of data since last few years.
    This heavy data growth poses a challenge for industry and academia for storage
    and query processing. While analyzing logs for huge data sets, it is required
    to perform different query operations, such as counting unique items, computing
    frequency of a data item, searching any item in a set, etc. Additionally, we need
    to probe more complex datasets, such as images, videos, web pages, etc. Clearly,
    in order to process such query operations on data, it is essential to store data
    in computer memory. Tapes, hard disk, solid state drives are different types of
    memory available for a computing system. However, these different types of memory
    have different characteristics as presented in [Fig. 9.1](12chap_09.xhtml#fig9_1).
    For example, hard disks are mechanical devices and they are slow to access as
    compared to main memory integrated on a semiconductor chip which makes querying
    from database in hard disk time consuming. Hence, for a query, a processor has
    to every time access the hard disk for the data it requires which clearly would
    be a slow operation. Also, disk access proves costly as compared to the main memory
    (that's why a GB of main memory is much costlier than a GB of hard drive).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来数据生成呈指数增长。这种庞大的数据增长给工业和学术界的存储和查询处理带来了挑战。在分析大型数据集的日志时，需要执行不同的查询操作，例如计算唯一项的数量，计算数据项的频率，搜索集合中的任何项等。此外，我们还需要探究更复杂的数据集，例如图像、视频、网页等。显然，为了在数据上执行这些查询操作，必须将数据存储在计算机内存中。磁带、硬盘、固态硬盘是计算系统可用的不同类型的内存。然而，这些不同类型的内存具有不同的特性，如[图
    9.1](12chap_09.xhtml#fig9_1)所示。例如，硬盘是机械设备，与集成在半导体芯片上的主存储器相比，它们的访问速度较慢，这使得从硬盘中的数据库查询耗时。因此，对于一个查询，处理器每次都必须访问硬盘以获取所需的数据，这显然是一个缓慢的操作。而且，与主存储器相比，磁盘访问的成本较高（这就是为什么1GB的主存储器比1GB的硬盘要贵得多）。
- en: '![Figure 9.1](../images/fig9_1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1](../images/fig9_1.jpg)'
- en: '**FIGURE 9.1**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.1**'
- en: Computer memory hierarchy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存层次结构。
- en: Besides, a process needs to be in the main memory in order to get executed so,
    it has to get swapped in from secondary memory to main memory as depicted in [Fig.
    9.2](#fig9_2). Simultaneously, for a developer, main memory is easy to use as
    creating an array, linked list, or set in main memory is easy as compared to writing
    files in or out by using a Hadoop database or Apache Solr in secondary storage.
    These upcoming big data technologies are oftenly used in providing accurate analysis
    and decision making. These technologies provide distributed data storage and parallel
    processing. Although the distributed database Hadoop with a heavy processing engine
    (Spark, MapReduce) is good with batch processing framework where the aim is to
    improve job throughput rather than handling speed of access issue. Notably, the
    batch processing of data doesn't impose any time constraints so, it can be stored
    on disk and queries can be processed in batches. Additionally, the popular approach
    of using SQL for processing queries on database in secondary storage results in
    high space complexity. For instance, Powerdrill is a column oriented data storage
    approach that faces the challenge of high memory and computational overhead for
    large datasets. However, streaming data requires real-time processing with a minimal
    delay which is possible with improved speed of access. Moreover, streaming data
    requires processing in a single pass. So, it is always better to work more in
    main memory for real-time processing of streaming data along with processing data
    in a single pass. Subsequently, the growing size of databases and applications
    dataset demands a compact data structure in order to get managed and handled properly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了执行一个进程，它需要在主存中，因此必须从辅助存储器交换到主存中，如[图 9.2](#fig9_2)所示。同时，对于开发人员来说，主存易于使用，因为在主存中创建数组、链表或集合比使用Hadoop数据库或Apache
    Solr在辅助存储器中读取或写入文件要容易得多。这些即将到来的大数据技术通常用于提供准确的分析和决策。这些技术提供了分布式数据存储和并行处理。虽然分布式数据库Hadoop与重型处理引擎（Spark、MapReduce）在批处理框架方面表现良好，其目标是提高作业吞吐量而不是处理速度问题。值得注意的是，数据的批处理不会施加任何时间约束，因此可以存储在磁盘上，并且可以以批量方式处理查询。此外，在辅助存储器中使用SQL处理查询的流行方法会导致高空间复杂性。例如，Powerdrill是一种列向数据存储方法，面临着对大型数据集的高内存和计算开销的挑战。然而，流数据需要实时处理，最小延迟是可能的，这是通过提高访问速度实现的。此外，流数据需要在单次通过中处理。因此，最好更多地在主存中工作，以实时处理流数据以及在单次通过中处理数据。随着数据库和应用程序数据集的不断增长，需要一种紧凑的数据结构来正确管理和处理数据。
- en: '![Figure 9.2](../images/fig9_2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2](../images/fig9_2.jpg)'
- en: '**FIGURE 9.2**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.2**'
- en: Memory management via swapping.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交换进行内存管理。
- en: The current scenario of data generation has resulted in the release of new applications
    that need to deal with a huge volume of data. Conventional algorithms assumption
    of fitting data in main memory fails when dealing with such a huge amount of data.
    In this context, streaming algorithms (that process data in one or a few passes
    while consuming a limited amount of storage and time) are getting popular among
    researchers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前数据生成的情景导致了需要处理大量数据的新应用程序的发布。传统算法假设将数据适应主存储器，但在处理如此大量的数据时会失败。在这种情况下，流式算法（在消耗有限的存储和时间的同时以一次或几次传递处理数据）在研究人员中变得流行起来。
- en: Unfortunately, in order to fix above mentioned issue, deterministic data structures,
    such as hash tables, array, binary search tree fail to deal with large data sets
    as it is difficult to accommodate large streaming data into memory at once. The
    conventional data structures can't go on the further side of linear processing.
    Moreover, for large dataset, a polynomial running time complexity served by deterministic
    data structures is not beneficial. Also, 3 V's (volume, variety, and velocity)
    of data demands real-time analysis and processing. Additionally, complexity of
    data and noise in data is not defined. As size of data is not known in prior,
    one can't predict the memory requirements for storing data. Therefore, there is
    a need for an effective data structure that can support quick response time and
    efficient storage space in the main memory. To address these challenges, probabilistic
    data structures (PDS) are used recently by many researchers and programmers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，为了解决上述问题，确定性数据结构，如哈希表、数组、二叉搜索树无法处理大型数据集，因为一次性将大量流式数据放入内存中是困难的。传统数据结构无法超越线性处理的进一步方面。此外，对于大型数据集，确定性数据结构提供的多项式运行时间复杂性并不有利。此外，数据的
    3V 特性（容量、多样性和速度）要求实时分析和处理。此外，数据的复杂性和数据中的噪声没有定义。由于事先不知道数据的大小，因此无法预测存储数据所需的内存需求。因此，需要一种能够支持快速响应时间和有效存储空间的有效数据结构来解决这些挑战。为了解决这些挑战，最近许多研究人员和程序员开始使用概率数据结构（PDS）。
- en: 'PDS allows performing basic query operation on data in the main memory itself.
    The use case of PDS is to process big data that does not fit inside the main memory.
    PDS are used for query operations, such as membership check, frequency check,
    similarity check, and cardinality check. Low memory requirements and good processing
    speed are the two unique properties of PDS. Nevertheless, the working of PDS is
    highly dependent on cryptographic hashing functions that enable randomness and
    flexibility in inserting data. Hash functions when applied on large data sets
    summarize it in a compact form which dramatically reduces storage requirements
    and its behavior is hard to predict. Here, also cryptographic hash functions have
    to satisfy three main requirements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PDS允许在主内存中对数据执行基本查询操作。PDS的用例是处理不适合主内存的大数据。PDS用于查询操作，如成员检查、频率检查、相似性检查和基数检查。低内存需求和良好的处理速度是PDS的两个独特属性。然而，PDS的工作高度依赖于密码哈希函数，这些函数能够在插入数据时提供随机性和灵活性。当哈希函数应用于大数据集时，它以紧凑的形式总结数据，极大地减少了存储需求，并且其行为难以预测。在这里，密码哈希函数还必须满足三个主要要求：
- en: 'Work factor: In order to defend brute force, hash function should be computationally
    expensive.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作因子：为了抵御暴力破解，哈希函数应该具有计算上的昂贵性。
- en: 'Sticky state: It is impossible to create a state with a plausible input pattern.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粘性状态：无法创建具有合理输入模式的状态。
- en: 'Diffusion: The associated output bit of hash function should be complex function
    of each input bit.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩散：哈希函数的相关输出位应该是每个输入位的复杂函数。
- en: Cryptographic hash functions are further categorized into keyed hash functions
    and unkeyed hash functions. A keyed hash function involves a secret key whereas,
    for a unkeyed hash function, the key is known to everyone. A keyed hash function
    is used for message authentication code (MAC).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数进一步分为有密钥哈希函数和无密钥哈希函数两类。有密钥哈希函数涉及一个秘密密钥，而对于无密钥哈希函数，密钥为所有人所知。有密钥哈希函数用于消息认证码（MAC）。
- en: Notably, PDS's are based on unkeyed hash function. With this insight, the nature
    of this data structure is randomized because of randomly selected hash functions.
    Also, in most cases, it is not important to know which item from the set has been
    matched, sometimes it is necessary to know only whether a match has bee made or
    not. Hence, only signatures of the items can be stored instead of the value. Over
    and above, PDS does not result in same structure every time for the same series
    of operations. Hence, PDS are also known as sketching data structures [[116](bib.xhtml#ch00-bib-116)].
    Notably, inaccuracy with a specific structure is expected with PDS. However, they
    have a constant query processing time and can be easily parallelized (as hashes
    have independent property) to be used for real-time data processing for a quick
    response. The coming sections will discuss the membership query, cardinality estimation,
    similarity search, and frequency estimation PDS in detail along with their Python
    implementation. Refer to [Fig. 9.3](#fig9_3) for taxonomy of PDS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是，PDS（概率数据结构）基于无键哈希函数。有了这一认识，这种数据结构的性质因随机选择的哈希函数而随机化。而且，在大多数情况下，并不重要知道集合中的哪个项已经匹配，有时只需要知道是否已经进行了匹配。因此，只需存储项的签名而不是值。此外，PDS不会在相同的操作序列下每次都产生相同的结构。因此，PDS也被称为草图数据结构。值得注意的是，PDS会出现与特定结构不一致的情况是预期的。然而，它们具有恒定的查询处理时间，并且可以轻松并行化（因为哈希具有独立属性），用于实时数据处理以获得快速响应。接下来的章节将详细讨论成员查询、基数估计、相似度搜索和频率估计
    PDS，以及它们的 Python 实现。有关 PDS 分类，请参阅[图 9.3](#fig9_3)。
- en: '![Figure 9.3](../images/fig9_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3](../images/fig9_3.jpg)'
- en: '**FIGURE 9.3**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.3**'
- en: Taxonomy of PDS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PDS 的分类。
- en: Due to minimized memory requirements PDS are useful for big data and streaming
    data applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存需求的最小化，PDS 对大数据和流数据应用非常有用。
- en: '[9.2 Deterministic Data Structures vs. Probabilistic Data Structures](contents.xhtml#rsec9_2)'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[9.2 确定性数据结构与概率性数据结构](contents.xhtml#rsec9_2)'
- en: IT professionals came across different deterministic data structures, for example,
    Array, hash tables, etc. However, with these in-memory conventional data structures
    operations such as insert, search, delete are performed with specific key value.
    These data structures results in deterministic (accurate) results. In contrast
    to this, results of operation in case of PDS could be probabilistic which implies
    results are approximate and not always definite. Notably, a conventional data
    structure can perform all set of operations that a PDS can do but only for small
    data sets. However, if data set is too large to fit into memory, conventional
    data structure fails for that case. Additionally, for streaming applications which
    demands data processing in one go, it is difficult to handle with conventional
    data structures. [Table 9.1](#tab9_1) presents difference between deterministic
    data structures and probabilistic data structures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IT专业人员遇到不同的确定性数据结构，例如数组、哈希表等。然而，使用这些内存中的传统数据结构，如插入、搜索、删除等操作是以特定键值执行的。这些数据结构产生确定性（准确）的结果。与此相反，在PDS的情况下，操作的结果可能是概率性的，这意味着结果是近似的，而不总是确定的。值得注意的是，传统数据结构可以执行PDS可以执行的所有操作，但仅适用于小数据集。然而，如果数据集太大而无法放入内存，传统数据结构在该情况下失败。此外，对于需要一次处理数据的流式应用，使用传统数据结构很难处理。[表9.1](#tab9_1)显示了确定性数据结构和概率性数据结构之间的区别。
- en: '**TABLE 9.1**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 9.1**'
- en: Difference between deterministic and probabilistic data structures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性数据结构和概率性数据结构的区别。
- en: '| Deterministic data structures | Probabilistic data structures |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 确定性数据结构 | 概率性数据结构 |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| No false positives are generated | False positives are generated while query
    processing |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 不会产生误报 | 在查询处理时会产生误报 |'
- en: '| Provides optimal path | Provides good path instead of optimal |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 提供最优路径 | 提供良好路径而不是最优路径 |'
- en: '| Not necessarily make use of hash functions | These data structures strictly
    uses hash function to process queries |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 不一定使用哈希函数 | 这些数据结构严格使用哈希函数来处理查询 |'
- en: '| Stores data in actual format | Stores signatures of data instead of actual
    data |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 将数据存储为实际格式 | 仅存储数据的签名而非实际数据 |'
- en: '| Uses more memory over PDS | Uses much less memory over traditional data structures
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 在PDS上使用更多内存 | 在传统数据结构上使用较少内存 |'
- en: '| Process queries in linear, sublinear, quadratic, factorial etc. time | Only
    process queries in constant time |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 在线性、次线性、二次、阶乘等时间内处理查询 | 仅在常数时间内处理查询 |'
- en: '| Error free results are generated | Error in results are expected. However,
    errors rates have sppecific structure |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 生成无误差结果 | 处理查询时会产生错误。然而，错误率具有特定的结构 |'
- en: '| Used when complete accuracy is required | Used when speed and low memory
    is required over exact accuracy |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 当需要完全准确性时使用 | 当需要速度和低内存而不是完全准确性时使用 |'
- en: '| Stores data in inact form | Transform non-uniform distributed data to uniformly
    distributed data |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 将数据存储为非活跃形式 | 将非均匀分布的数据转换为均匀分布的数据 |'
- en: '| Example: Array, linked list | Example: Bloom filter, HLL |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 示例：数组、链表 | 示例：Bloom过滤器、HLL |'
- en: '[9.3 Probabilistic Data Structures Applications](contents.xhtml#rsec9_3)'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[9.3 概率数据结构应用](contents.xhtml#rsec9_3)'
- en: To build effective applications, one practice is an efficient use of data structure.
    Infact choosing a good data structure is a sign of good programmer. Any application
    involving large scale business can make use of PDS. Analyzing big data set, statistical
    analysis, mining huge data set are some use-cases of PDS. For instance, to check
    whether a particular item on Amazon is available for order or not. However, applications
    of PDS are not only limited to computer science field but also used in various
    filed. For example, in classification of DNA sequences into novel or already known
    genome.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建有效的应用程序，一个做法是高效地使用数据结构。事实上，选择一个好的数据结构是一个优秀程序员的标志。任何涉及大规模业务的应用程序都可以利用PDS。分析大数据集、统计分析、挖掘庞大数据集是PDS的一些用例。例如，检查亚马逊上的特定商品是否可以订购。然而，PDS的应用不仅局限于计算机科学领域，还用于各个领域。例如，在将DNA序列分类为新的或已知的基因组方面。
- en: Duplication of data blocks is defined when more than one file share common data
    or when same data occurs at more than one place in a given file. Comparing each
    file with all other files involves heavy processing. PDS helps to solve this problem
    by storing fingerprint of data blocks rather than storing original data and matching
    hashes for finding duplicate files [[71](bib.xhtml#ch00-bib-71)].
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个文件共享相同数据或相同数据在给定文件中出现在多个位置时，定义为数据块的重复。将每个文件与所有其他文件进行比较涉及重量级处理。PDS通过存储数据块的指纹而不是存储原始数据，并匹配哈希来找到重复文件来解决此问题[[71](bib.xhtml#ch00-bib-71)]。
- en: DDoS attack is defined when a particular machine is flooded by an attacker so
    that it may not be accessed by user when required. This demand needs for monitoring
    network traffic. One solution is to analyze destination IP address of IP packet
    and if counter value of any IP address exceeds predefined threshold that address
    is considered as suspicious. PDS can help analyzing these packets with less memory
    and constant time.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当攻击者向特定机器发动洪水攻击，使其在用户需要时无法访问时，就定义了DDoS（分布式拒绝服务）攻击。这需要对网络流量进行监控。一种解决方案是分析IP数据包的目标IP地址，如果任何IP地址的计数器值超过预定义的阈值，则该地址被视为可疑。PDS可以帮助以较少的内存和恒定的时间分析这些数据包。
- en: Similarly, filtering of personal e-mail can be eased with PDS as spam detection
    system involves a big database having e-mail signatures [[216](bib.xhtml#ch00-bib-216)].
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，使用PDS（概率数据结构）可以简化个人电子邮件的过滤，因为垃圾邮件检测系统涉及一个包含电子邮件签名的大型数据库[[216](bib.xhtml#ch00-bib-216)]。
- en: Growth in network traffic demands the need for network monitoring and traffic
    engineering. To operate efficiently, data centers, and PDS sketches for tasks,
    such as heavy hitter detection, traffic matrix estimation, traffic pattern detection
    etc. PDS sketches have proved to minimize the computation cost for information
    collection in the network [[137](bib.xhtml#ch00-bib-137)].
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络流量的增长需要网络监控和流量工程的需求。为了有效运行，数据中心和PDS草图用于任务，如重型打击者检测、流量矩阵估计、流量模式检测等。PDS草图已被证明可以最小化网络中信息收集的计算成本[[137](bib.xhtml#ch00-bib-137)]。
- en: Cardinality estimation PDS is used to check how many unique IP addresses views
    an article on any particular site.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基数估计PDS用于检查在任何特定网站上查看文章的唯一IP地址有多少。
- en: PDS are also used for DNA sequences that involve categorization of sequence
    as novel or already existing genome. Sequencing implies calculating the right
    order of base pair in a DNA segment. Also, PDS are used for analyzing co-relation
    in DNA sequencing [[109](bib.xhtml#ch00-bib-109)].
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDS还用于涉及将序列分类为新颖或已存在基因组的DNA序列。测序意味着计算DNA片段中碱基对的正确顺序。此外，PDS还用于分析DNA测序中的相关性[[109](bib.xhtml#ch00-bib-109)]。
- en: A worth mentioning application of PDS is to find all elements in data set with
    a frequency greater than a predefined number. Such a characteristic of PDS is
    used to detect heavy hitter for a website.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDS值得一提的应用是查找数据集中频率大于预定义数字的所有元素。PDS的这种特性用于检测网站的重型打击者。
- en: Likewise, PDS can be used for an application of spell check having 350000 dictionary
    words in the memory.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，PDS可以用于具有350000个词典单词的拼写检查应用程序。
- en: '[9.4 Probabilistic Data Structure Challenges](contents.xhtml#rsec9_4)'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[9.4 概率数据结构挑战](contents.xhtml#rsec9_4)'
- en: PDS optimizes algorithm performance by using fixed or sublinear memory and by
    providing constant execution time. However, the biggest challenge faced by PDS
    is that they can't provide exact answers and shows some probability of error.
    However, this error can be controlled with a trade-off with resources of PDS.
    Hence, for cases where reduced accuracy is unacceptable (such as- bank account,
    military applications) use of PDS is not recommended. Nevertheless, for cases
    (such as- recommending a movie, counting unique visitors, preventing DDoS attack)
    where cost of relatively small mistakes is low, PDS can be recommended.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: PDS通过使用固定或亚线性内存以及提供恒定执行时间来优化算法性能。然而，PDS面临的最大挑战是它们无法提供精确答案并显示一定的错误概率。但是，可以通过与PDS资源的权衡来控制此错误。因此，对于精度降低不可接受的情况（如银行账户、军事应用），不建议使用PDS。然而，对于小错误成本的情况（如推荐电影、计算独立访问者、防止DDoS攻击），可以推荐使用PDS。
- en: Activity
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: Which of the following memory has slowest speed of access?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种存储器的访问速度最慢？
- en: Registers
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寄存器
- en: Main memory
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主存储器
- en: Hard disk
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬盘
- en: Tape storage
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁带存储
- en: What are the requirements for a cryptographic hash function?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码哈希函数的要求是什么？
- en: One-way
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单向
- en: Work factor
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作因子
- en: Diffusion
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩散
- en: All of the above
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述内容
- en: In keyed hash function, key is known to everyone.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在键控哈希函数中，密钥为所有人所知。
- en: 'True'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Which of the following memory has maximum ease of use?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种内存具有最大的易用性？
- en: Registers
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寄存器
- en: Main memory
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主存储器
- en: Hard disk
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬盘
- en: Tape storage
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁带存储
- en: Which of following statement about PDS is false?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于 PDS 的陈述哪个是错误的？
- en: PDS are also known as sketching data structure
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDS 也被称为草图数据结构
- en: PDS ae also know as deterministic data structure
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDS 也被称为确定性数据结构
- en: Results of PDS operations have some error
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDS 操作的结果会有一定的误差
- en: Bloom filter is an example of PDS
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布隆过滤器是 PDS 的一个例子
- en: Which of the following is an example of cardinality estimation PDS?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是基数估计 PDS 的一个例子？
- en: HyperLogLog
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HyperLogLog
- en: BF
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BF
- en: Skiplist
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳表
- en: Minhashing
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小哈希
- en: Which of the following is an example of membership query PDS?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是成员查询 PDS 的一个例子？
- en: Cuckoo filter
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布谷鸟过滤器
- en: Minhashing
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小哈希
- en: Simhashing
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Simhashing
- en: LogLog
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LogLog
- en: Which of the following is an example of frequency query PDS?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是频率查询 PDS 的一个例子？
- en: Cuckoo filter
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布谷鸟过滤器
- en: CMS
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMS
- en: Simhashing
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Simhashing
- en: LogLog
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LogLog
- en: PDS are useful for big data and streaming data applications
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDS 对大数据和流数据应用非常有用
- en: 'True'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Which of the following is an example of PDS?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是 PDS 的一个例子？
- en: Detecting DDoS attack
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测 DDoS 攻击
- en: Spell checker
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拼写检查器
- en: Monitoring IP traffic
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控 IP 流量
- en: All of the above
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述内容
- en: 1\. d  2\. d  3\. b  4\. a  5\. b  6\. a  7\. a  8\. b  9\. a  10\. d
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. d  2\. d  3\. b  4\. a  5\. b  6\. a  7\. a  8\. b  9\. a  10\. d
- en: <hgroup>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[10](contents.xhtml#rchapter10)'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[10](contents.xhtml#rchapter10)'
- en: '[Membership Query Probabilistic Data Structures](contents.xhtml#rchapter10)'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[成员查询概率数据结构](contents.xhtml#rchapter10)'
- en: </hgroup>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[10.1 Membership Query Probabilistic Data Structures](contents.xhtml#rsec10_1)'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[10.1 成员查询概率数据结构](contents.xhtml#rsec10_1)'
- en: Oftentimes while processing streaming IoT data, searching for a particular item
    is required with minimum latency and space. The aim of membership query probabilistic
    data structures (MSQ PDS) is to check the presence of an element *x* in a large
    set <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo
    stretchy="false">)</mo></mrow></math> of elements. The membership query operation
    using a linked list, array or a balanced binary tree requires a memory space linear
    to the size of set *S*. Hash table also has a larger size so, the memory it takes
    will also be larger. On the other hand, MSQ PDS are getting popular for handling
    queries of big data and streaming applications as these data structures consume
    less memory. Also, MSQ PDS provides constant query time. In order to provide optimized
    space efficiency, as opposed to storing the entire set of data, MSQ PDS stores
    summarized form of data using hashing. [Table 10.1](#tab10_1) represents a comparison
    in space and time complexity for membership query operation in different data
    structures. Insertion and deletion (for some specific MSQ PDS) are the operations
    that are supported by MSQ PDS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理流式物联网数据时，经常需要以最小的延迟和空间搜索特定项。成员查询概率数据结构（MSQ PDS）的目的是检查大型集合<math alttext=""
    display="inline"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math>中元素*x*的存在。使用链表、数组或平衡二叉树的成员查询操作需要与集合*S*大小线性的内存空间。哈希表也有更大的大小，因此它所占用的内存也更大。另一方面，MSQ
    PDS 在处理大数据和流式应用程序的查询方面越来越受欢迎，因为这些数据结构消耗的内存较少。此外，MSQ PDS 提供恒定的查询时间。为了提供优化的空间效率，与存储整个数据集相反，MSQ
    PDS 使用哈希存储数据的摘要形式。[表10.1](#tab10_1) 表示了不同数据结构中成员查询操作的空间和时间复杂度的比较。插入和删除（对于某些特定的
    MSQ PDS）是 MSQ PDS 支持的操作。
- en: '**TABLE 10.1**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10.1**'
- en: Space and time complexity for searching in different data structures
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不同数据结构中搜索的空间和时间复杂度
- en: '|  | Linear DS | Non-linear DS | Hashing DS | Probabilistic DS |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  | 线性数据结构 | 非线性数据结构 | 哈希数据结构 | 概率数据结构 |'
- en: '| Example: | Array, Linked list | Graph, BST | Hash Tables | BF, QF, Skiplist
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 示例： | 数组、链表 | 图、二叉搜索树 | 哈希表 | 布隆过滤器、快速过滤器、跳表 |'
- en: '| Space Complexity | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> | <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> | <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> | <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '| Search Time | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 搜索时间 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '*n*: data size, *m*: PDS size (*m* ¡ ¡ *n*), *k*: number of hash function,
    DS: Data structures, BST: Binary search trees'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*：数据大小，*m*：PDS 大小（*m* ¡ ¡ *n*），*k*：哈希函数的数量，DS：数据结构，BST：二叉搜索树'
- en: Nevertheless, a predictable error is expected while using MSQ PDS. However,
    here errors are managed under a predefined marginal threshold with a trade-off
    between accuracy and storage requirements. Bloom Filter, quotient filter, and
    skiplist are popularly used PDS under this category which will be discussed further
    in this chapter. Moreover, the popularity of Bloom filter resulted in its various
    variants with some extra capability which is not supported by standard Bloom filter.
    However, being a part of error prone approach, bloom filter, and quotient filter
    return results with false positive on membership query whereas skip list doesn't
    return any error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在使用 MSQ PDS 时预期会出现可预测的错误。但是，在此处，错误被管理在预定义的边际阈值下，以权衡准确性和存储需求。布隆过滤器、商过滤器和跳表是在此类别下广泛使用的
    PDS，本章将进一步讨论它们。此外，布隆过滤器的流行导致了其各种变体，具有一些标准布隆过滤器不支持的额外功能。然而，作为容错方法的一部分，布隆过滤器和商过滤器在成员查询中返回带有误报的结果，而跳表不会返回任何错误。
- en: False positive implies that even if an element is not present in the set, query
    result may output true whereas false negative implies that for the presence of
    an element query results in negative results. The difference between false positive
    and false negative has been represented in [Fig. 10.1](13chap_10.xhtml#fig10_1).
    Additionally, the precision and recall value for the model can be computed from
    Eqs. 10.1 and 10.2 respectively where precision describes how accurate the calculated
    results are out of total positive predictions and recall depicts the proportion
    of correctly identified actual positive. The next topic discusses the concept
    of Bloom filter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: False positive 表示即使元素不在集合中，查询结果可能会输出 true，而 false negative 意味着对于元素的存在，查询结果为否定。
    [图 10.1](13chap_10.xhtml#fig10_1) 中已经表示了 false positive 和 false negative 的区别。此外，模型的精确度和召回率值可以从
    Eqs. 10.1 和 10.2 分别计算出来，其中精确度描述了计算结果在总正预测中的准确性，而召回率描述了正确识别的实际正值的比例。下一个主题将讨论布隆过滤器的概念。
- en: '![Figure 10.1](../images/fig10_1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1](../images/fig10_1.jpg)'
- en: '**FIGURE 10.1.**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.1.**'
- en: False positive vs. false negative.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: False positive vs. false negative.
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>+</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.1)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>+</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.1)
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>+</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.2)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>+</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.2)
- en: '[10.2 Bloom Filter and its Variants](contents.xhtml#rsec10_2)'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[10.2 Bloom Filter 及其变体](contents.xhtml#rsec10_2)'
- en: The concept of BF was introduced by Burton H. Bloom back in 1970 [[46](bib.xhtml#ch00-bib-46)].
    BF resides inside the main memory and with BF its fast to check MSQ. Insertion
    and lookup are the two operations supported by standard BF. However, lookup operation
    of standard BF occasionally results in false positive but never in false negative.
    Apparently, BF should be used in cases where a bit of false positive can be accepted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: BF 的概念是由 Burton H. Bloom 在 1970 年提出的 [[46](bib.xhtml#ch00-bib-46)]。BF 位于主存储器内，使用
    BF 可以快速检查 MSQ。标准 BF 支持插入和查找两种操作。然而，标准 BF 的查找操作偶尔会出现误判，但永远不会出现漏判。显然，BF 应该在可以接受一定误判的情况下使用。
- en: '[10.2.1 Structure of Bloom filter](contents.xhtml#rsec10_2_1)'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.1 Bloom 过滤器的结构](contents.xhtml#rsec10_2_1)'
- en: 'BF is an array of *m* bits having index from 0 to m-1 as represented in [Fig.
    10.2](13chap_10.xhtml#fig10_2). A single bit is used to represent each entry in
    the filter, i.e., 0 or 1\. Along with this, BF employs *k* different independent
    and uniform hash functions. Instead of storing the data itself, BF utilizes hashing
    to store hashes of the data in a compact form. However, employed hash functions
    should have fast speed. The number of hash functions can be from 1 to *m*. The
    bits of BF are all initialized to zero. It first performs multiple times <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></math>
    hashing on each data item and then stores its hash value in the array of size
    *m*. Clearly, with an increase in the number of hash functions, the speed of BF
    gets slow. Notably, searching time complexity with BF is independent of the size
    of array and stored number of elements. For a fixed error rate, both insertion
    and lookup operations serve constant time complexity that is proportional to the
    number of hash functions used. Hence, by encoding information in a bit vector,
    BF can compactly represent a data and can be transmitted with a low bandwidth
    requirement. Despite proving quite beneficial, there are some disadvantages of
    BF which are listed as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: BF 是一个包含*m*个比特的数组，索引从0到m-1，如[图 10.2](13chap_10.xhtml#fig10_2)所示。每个条目在过滤器中用一个比特来表示，即0或1。除此之外，BF
    使用*k*个不同的独立和均匀的哈希函数。BF 不存储数据本身，而是利用哈希来以紧凑的形式存储数据的哈希值。然而，所使用的哈希函数应具有快速速度。哈希函数的数量可以从1到*m*。BF
    的比特都初始化为零。它首先对每个数据项执行多次哈希运算，然后将其哈希值存储在大小为*m*的数组中。显然，随着哈希函数数量的增加，BF 的速度会变慢。值得注意的是，BF
    的搜索时间复杂度与数组大小和存储元素数量无关。对于固定的错误率，插入和查找操作的时间复杂度都是与所使用的哈希函数数量成比例的常数时间复杂度。因此，通过在位向量中编码信息，BF
    可以紧凑地表示数据，并且可以以低带宽要求进行传输。尽管证明了相当有益，但BF 也有一些缺点，列举如下：
- en: Nevertheless, deletion is not supported by BF as resetting bits to 0 can introduce
    false negatives (the reseted bit might represent other element entry in the BF).
    However, the entire BF can be deleted once in a while with reset function. Although,
    there are various instances of BF which support deletion by keeping a record of
    variable count in memory, for example, Counting BF [[79](bib.xhtml#ch00-bib-79)],
    Deletable BF [[165](bib.xhtml#ch00-bib-165)] etc.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，BF 不支持删除，因为将比特重置为0可能会引入错误的否定（重置的比特可能代表BF 中的其他元素条目）。然而，可以通过重置函数偶尔删除整个BF。虽然，有各种BF
    的实例支持删除，例如，通过在内存中记录可变计数的计数 BF[[79](bib.xhtml#ch00-bib-79)]，可删除的 BF[[165](bib.xhtml#ch00-bib-165)]等。
- en: Poor scaling out of main memory as in secondary memory use of multiple hash
    functions requires many random access to the disk.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主存储器外扩展性差，因为在使用多个哈希函数的次级存储器上需要许多随机访问磁盘。
- en: BF can not be resized dynamically.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BF 无法动态调整大小。
- en: Inability to compute frequency count of each element. It can only check presence
    of any element.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法计算每个元素的频率计数。它只能检查任何元素的存在。
- en: '![Figure 10.2](../images/fig10_2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2](../images/fig10_2.jpg)'
- en: '**FIGURE 10.2.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.2.**'
- en: Representation of Bloom filter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Bloom过滤器的表示。
- en: 'Insertion and membership query operations of BF are described as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: BF的插入和成员查询操作描述如下：
- en: To insert an element *x*, first apply *k* hash functions to the element *x*
    and the position corresponding to <math alttext="" display="inline"><mrow><mi>h</mi><mi>i</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>...</mn><mo>,</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math> is set to 1 if already not set.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要插入一个元素*x*，首先对元素*x*和对应于<math alttext="" display="inline"><mrow><mi>h</mi><mi>i</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>...</mn><mo>,</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>位置应用*k*个哈希函数，如果尚未设置，则将对应的位置设置为1。
- en: To check membership of an element *x*, pass the element *x* through *k* hash
    functions to get *k* array positions. If any of the bit corresponding to these
    positions is zero, then the element is definitely not in the set otherwise, it
    might be present. Also, it is probable that even if all *k* corresponding positions
    are 1, element might not be present into the set (false positive). While designing
    BF, one of the aims of developers is to design filter with very less false positive
    rate. However, false negative never happens for BF.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查元素*x*的成员资格，将元素*x*通过*k*个哈希函数传递以获得*k*个数组位置。如果这些位置对应的位中有任何一个位为零，则元素肯定不在集合中，否则，它可能存在。此外，即使所有*k*个相应的位置都为1，元素可能也不在集合中（假阳性）。在设计BF时，开发者的一个目标是设计具有非常低的假阳性率的过滤器。然而，BF永远不会出现假阴性。
- en: For example, consider a case where BF is 10 bit long with three hash functions
    ( <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub></mrow></math>)
    where <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>4</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>.
    To insert an element 11, pass the key (*11*) through all hash functions which
    results in 3 indices, i.e, <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mn>4</mn></mrow></math>
    and set these three resulting positions to 1\. Similarly to insert element 3,
    positions 0, 3 will be set to 1 as represented in [Fig. 10.3](#fig10_3). However,
    membership query for key *5* returns definitely not in the set as positions corresponding
    to hash function <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow></math>
    is zero (See [Fig. 10.4](13chap_10.xhtml#fig10_4)). The lookup operation for element
    12 will result in false positive as 12 is not present in the set but position
    corresponding to all three hash functions, (i.e., 0, 0, 0) are set to 1 whereas
    for element 5, the scenario represents true positive. Simultaneously, [Fig. 10.5](13chap_10.xhtml#fig10_5)
    represents deletion and it could be observed that deletion of element 3 from the
    introduces false negative for element 11.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个情况，其中 BF 长度为 10 位，有三个哈希函数（<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub></mrow></math>），其中
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>4</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    和 <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>。要插入元素
    11，将键（*11*）通过所有哈希函数，得到 3 个索引，即，<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mn>4</mn></mrow></math>，并将这三个结果位置设置为
    1。类似地，要插入元素 3，位置 0、3 将被设置为 1，如 [图 10.3](#fig10_3) 所示。然而，对于键 *5* 的成员查询结果肯定不在集合中，因为对应哈希函数
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow></math>
    的位置为零（见 [图 10.4](13chap_10.xhtml#fig10_4)）。元素 12 的查找操作将产生误报，因为 12 不在集合中，但与所有三个哈希函数对应的位置（即
    0、0、0）都被设置为 1，而对于元素 5，则表示真正的命中。同时，[图 10.5](13chap_10.xhtml#fig10_5) 表示删除，可以观察到，从集合中删除元素
    3 会导致元素 11 的误删。
- en: '**Union and intersection of standard BF**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准 BF 的并集和交集**'
- en: 'BF also support operation of union and intersection algebraic operations. Suppose
    *BF(X)* and *BF(Y)* are two BFs that use same size of filter and hash functions.
    Then, intersection and union operation between *BF(X)* and *BF(Y)* is given by:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: BF 也支持并集和交集的代数运算。假设 *BF(X)* 和 *BF(Y)* 是两个使用相同大小的过滤器和哈希函数的 BF。那么 *BF(X)* 和 *BF(Y)*
    之间的交集和并集操作如下：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><mi>B</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo
    stretchy="false">)</mo><mo>∩</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(10.3)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><mi>B</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo
    stretchy="false">)</mo><mo>∩</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(10.3)
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo
    stretchy="false">)</mo><mo>∪</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(10.4)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo
    stretchy="false">)</mo><mo>∪</mo><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(10.4)
- en: '![Figure 10.3](../images/fig10_3.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3](../images/fig10_3.jpg)'
- en: '**FIGURE 10.3.**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.3.**'
- en: Insertion in BF.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BF 中进行插入。
- en: '![Figure 10.4](../images/fig10_4.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4](../images/fig10_4.jpg)'
- en: '**FIGURE 10.4.**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.4.**'
- en: Lookup in BF.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BF 中进行查找。
- en: '![Figure 10.5](../images/fig10_5.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5](../images/fig10_5.jpg)'
- en: '**FIGURE 10.5.**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.5.**'
- en: Deletion in BF.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BF 中进行删除。
- en: '**Applications of BF**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**BF 的应用**'
- en: Yahoo mail use BF to compactly represent users contact list so that it gets
    easily fitted in browser cache memory. The use of BF avoids round trip to back
    end server for checking whether e-mail address of the sender is already present
    in contact list or not.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yahoo 邮件使用 BF 来紧凑地表示用户的联系人列表，以便轻松地适配浏览器缓存内存。BF 的使用避免了回到后端服务器检查发件人的电子邮件地址是否已经存在于联系人列表中。
- en: BF is utilized by youtube to assure that recommended videos for a user doesnot
    match user's watch history.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YouTube 使用 BF 来确保向用户推荐的视频不与用户的观看历史匹配。
- en: URL shortener uses BF to ensure unique URLs are generated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 缩短器使用 BF 来确保生成唯一的 URL。
- en: Tinder deploys BF to filter out repeats for right swipes.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tinder 使用 BF 来过滤右滑重复的情况。
- en: Apache HBase, Postgress databases are using BF to check if a particular record
    exists or not and in case of positive results, records will be fetched from memory.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache HBase，Postgress数据库正在使用BF来检查特定记录是否存在，如果结果为正，则会从内存中获取记录。
- en: Facebook uses BF for one-hit-wonder. One-hit-wonder is used for the sites which
    get lots of traffic. It basically checks events that happen once and never again.
    So, BF can be used to probe if a particular web page has been visited before or
    not. If somebody visits the site only once, not much content and complicated computations
    will be served. In another case if somebody visits a website more often, more
    personalized content will be served. To realize this process, a BF is employed
    and visitors are checked against BF. In case of positive results, site will serve
    expensive content and for negative results, cached version is served.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook使用BF进行一次性奇观检查。一次性奇观用于那些流量很大的站点。它基本上检查仅发生一次且不再发生的事件。因此，BF可以用于探测特定网页是否已经被访问过。如果有人只访问该站点一次，则不会提供太多内容和复杂的计算。另一种情况是，如果有人经常访问网站，则会提供更多个性化的内容。为了实现这个过程，采用BF并对访问者进行检查。如果结果为正，站点将提供昂贵的内容；如果结果为负，则提供缓存版本。
- en: Quora the famous place to ask questions uses BF to filter out stories that users
    have seen before.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quora，一个著名的提问平台，使用BF来过滤用户之前看过的故事。
- en: BF supports spell checkers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BF支持拼写检查器。
- en: BF is widely used for forwarding and routing of packets among different nodes.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BF被广泛用于在不同节点之间转发和路由数据包。
- en: Bioinformatics [[108](bib.xhtml#ch00-bib-108)].
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生物信息学[[108](bib.xhtml#ch00-bib-108)]。
- en: Prevention of DDoS attack by inserting BF with entries of malicious IP addresses.
    [[161](bib.xhtml#ch00-bib-161)]
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插入具有恶意IP地址条目的BF来预防DDoS攻击。[[161](bib.xhtml#ch00-bib-161)]
- en: '**False Positive Probability in BF:**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**BF中的假阳性概率：**'
- en: Clearly, the false positive rate is dependent on the number of 1's in the filter
    and on the count of hash functions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，假阳性率取决于过滤器中的1的数量和哈希函数的计数。
- en: Probability of a element passed to hash function and setting of a bit is given
    by <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></math>
    and probability of not setting a bit (probability of getting false positive) is
    given by Eq. 10.5
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过哈希函数传递给元素并设置一个位的概率由<math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></math>给出，而不设置位（获取假阳性的概率）的概率由Eq.
    10.5给出。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.5)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.5)
- en: As an element is passed through *k* hash functions. So, probability that an
    arbitrary bit is not set after mapping an element to *k* corresponding positions.
    is given by Eq. 10.6
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素经过*k*个哈希函数时。因此，将元素映射到*k*个对应位置后，任意位未设置的概率由方程10.6给出。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.6)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.6)
- en: Now, for *n* insertions, probability that an arbitrary bit is not set after
    feeding through *k* hash functions is given by Eq. 10.7
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于*n*次插入，将元素通过*k*个哈希函数传递后，任意位未设置的概率由方程10.7给出。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(10.7)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(10.7)
- en: Nevertheless, false positive rate (FPR) happens when a bit is falsely set to
    high. Hence, the probability of an arbitrary bit being set is given by Eq. 10.8
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，当一个位被错误地设置为高时，会发生误判率（FPR）。因此，任意位被设置为高的概率由方程10.8给出。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mo>−</mo><msup><mrow><mfenced
    close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(10.8)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mo>−</mo><msup><mrow><mfenced
    close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(10.8)
- en: A new element is passed through *k* hash functions. Therefore, for *k* hash
    functions, Eq. 10.8 can be manipulated to give Eq. 10.9
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素经过*k*个哈希函数。因此，对于*k*个哈希函数，方程10.8可以改写为方程10.9
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo>−</mo><mi>k</mi><mi>n</mi></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.9)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '-   <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr
    columnalign="left"><mtd columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced
    close=")" open="("><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo>−</mo><mi>k</mi><mi>n</mi></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.9)'
- en: It is clear from Eq. 10.9 that FPR is a function of *k, m* and *n*. Incrementing
    the total number of elements and decrementing filter size, lead to increase in
    the FPR. However, by incrementing *k*, FPR gets reduced. Unfortunately, the computational
    complexity of system gets increased by increasing value of *k*. Also, if value
    of *m* is set as <math alttext="" display="inline"><mi>∞</mi></math>, error rate
    tends to 0 whereas if value of *m* is 1, in this case error rate tends to 0 which
    implies 100% chance of getting error. To achieve minimum FPR, for a constant value
    of *m* and *n* for the optimum value of *k* is computed as depicted in Eq. 10.10\.
    Hence, for a given *k, m* needs to be linearly increased with *n* to have a fixed
    FPR.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '-   从方程式 10.9 中可以清楚地看出，FPR 是 *k, m* 和 *n* 的函数。增加元素的总数并减少过滤器大小会导致 FPR 的增加。然而，通过增加
    *k*，可以减少 FPR。不幸的是，通过增加 *k* 的值，系统的计算复杂度也会增加。另外，如果 *m* 的值设置为 <math alttext="" display="inline"><mi>∞</mi></math>，错误率趋于
    0，而如果 *m* 的值为 1，则错误率趋于 0，这意味着出错的几率为 100%。为了实现最小的 FPR，在给定 *m* 和 *n* 的情况下，通过计算方程
    10.10 中描述的最优 *k* 的值来使 *k* 的值保持不变。'
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mn>0.7</mn><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.10)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '-   <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr
    columnalign="left"><mtd columnalign="left"><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mn>0.7</mn><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.10)'
- en: 'Moreover, by fixing a accepted target FPR *(p)* and utilizing optimal value
    of *k*, the size of filter *m* can be computed as:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '-   此外，通过设定接受的目标 FPR *(p)* 并利用 *k* 的最优值，可以计算出过滤器 *m* 的大小：'
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo
    stretchy="false">(</mo><mo>−</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><mi>n</mi></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mfenced></mrow><mrow><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(10.11)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close=")" open="("><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo
    stretchy="false">(</mo><mo>−</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><mi>n</mi></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mfenced></mrow><mrow><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>（10.11）
- en: which further results in
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步得到
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><msup><mrow><mo
    stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.12)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><msup><mrow><mo
    stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>（10.12）
- en: 'Thus, from Eq. 10.12, the optimal bits required per elements can be computed
    as:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据方程 10.12，可以计算出每个元素所需的最佳比特数为：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><mi>l</mi><mi>n</mi><mn>2</mn></mrow></mfrac><mo>≈</mo><mo>−</mo><mn>1.44</mn><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>p</mi></mrow></mtd></mtr></mtable></mrow></math>(10.13)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><mi>l</mi><mi>n</mi><mn>2</mn></mrow></mfrac><mo>≈</mo><mo>−</mo><mn>1.44</mn><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>p</mi></mrow></mtd></mtr></mtable></mrow></math>（10.13）
- en: The graph presented in [Fig. 10.6](13chap_10.xhtml#fig10_6) plots the change
    in FPR against filter size for 10M elements [[41](bib.xhtml#ch00-bib-41)]. It
    can be observed that rate of false positive decreases with an increase in filter
    size. For a single hash function to achieve *p* less than 0.01 size of filter
    needs to be 100 times size of total elements, whereas choosing *k = 5* can provide
    the same in 100M.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.6](13chap_10.xhtml#fig10_6)中呈现的图表显示了 FPR 随过滤器大小变化的变化情况，对于 1000 万个元素[[41](bib.xhtml#ch00-bib-41)]。
    可以观察到，随着过滤器大小的增加，误报率下降。 要使 *p* 小于 0.01 的单个哈希函数的情况下，过滤器的大小需要是总元素大小的 100 倍，而选择 *k
    = 5* 则可以在 100M 中提供相同的结果。'
- en: '![Figure 10.6](../images/fig10_6.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6](../images/fig10_6.jpg)'
- en: '**FIGURE 10.6.**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.6**'
- en: False positive rate vs. size of array [[41](bib.xhtml#ch00-bib-41)].
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 误报率 vs. 数组大小 [[41](bib.xhtml#ch00-bib-41)]。
- en: '[10.2.2 Implementation of BF in Python](contents.xhtml#rsec10_2_2)'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.2 BF 在 Python 中的实现](contents.xhtml#rsec10_2_2)'
- en: '![](../images/list10_1.jpg)![](../images/list10_2.jpg)![](../images/list10_3.jpg)![](../images/list10_4a.jpg)![](../images/list10_4b.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list10_1.jpg)![](../images/list10_2.jpg)![](../images/list10_3.jpg)![](../images/list10_4a.jpg)![](../images/list10_4b.jpg)'
- en: '[10.2.3 Variants of BF](contents.xhtml#rsec10_2_3)'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3 BF 的变种](contents.xhtml#rsec10_2_3)'
- en: Some popular variants of BF are discussed as follows and their comparison is
    presented in [Table 10.3](#tab10_3).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的 BF 变种如下所述，并且它们的比较显示在[表 10.3](#tab10_3)中。
- en: '**TABLE 10.2**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10.2**'
- en: Case when 8 bits per elements are used for compression.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个元素使用 8 位进行压缩时的情况。
- en: '| Array bits per element | <math alttext="" display="inline"><mrow><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></math>
    | 8 | 14 | 92 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 每个元素的数组位 | <math alttext="" display="inline"><mrow><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></math>
    | 8 | 14 | 92 |'
- en: '| Transmission bits per element | <math alttext="" display="inline"><mrow><mfrac><mi>z</mi><mi>n</mi></mfrac></mrow></math>
    | 8 | 7.293 | 7.293 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 每个元素的传输位 | <math alttext="" display="inline"><mrow><mfrac><mi>z</mi><mi>n</mi></mfrac></mrow></math>
    | 8 | 7.293 | 7.293 |'
- en: '| Hash function | k | 6 | 2 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 哈希函数 | k | 6 | 2 | 1 |'
- en: '| False positive rate | P | 0.0216 | 0.0177 | 0.0108 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 误报率 | P | 0.0216 | 0.0177 | 0.0108 |'
- en: '*n*: data size, *m*: BFsize *k*: number of hash function, *z*: desired compressed
    size'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*: 数据大小, *m*: BF 大小 *k*: 哈希函数数量, *z*: 期望压缩大小'
- en: '**TABLE 10.3**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10.3**'
- en: Comparison between different BF variants.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不同 BF 变种的比较。
- en: '![Table 10.3](../images/tab10_3.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![表 10.3](../images/tab10_3.jpg)'
- en: '[10.2.3.1 Counting BF](contents.xhtml#rsec10_2_3_1)'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[10.2.3.1 计数 BF](contents.xhtml#rsec10_2_3_1)'
- en: As discussed earlier, deletion in standard BF requires a bit to be reset from
    1 to 0 which may lead to the occurrence of false negative as a single arbitrary
    bit may represent multiple elements. As a solution to this problem, counting BF
    was designed by authors in [[79](bib.xhtml#ch00-bib-79)] for exchanging information
    related to web cache among various proxies over the Internet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，标准 BF 中的删除需要将一个位从 1 重置为 0，这可能导致出现假阴性，因为单个任意位可能表示多个元素。 作为这个问题的解决方案，作者们在[[79](bib.xhtml#ch00-bib-79)]中设计了计数
    BF，以在互联网上各种代理之间交换与 Web 缓存相关的信息。
- en: Notably, the increase in web usage has effected fetch latency in the network.
    In this context, distributed proxy server improves latency by maintaining a web
    cache memory of each other proxy server information which allows for access of
    desired page from neighbor cache nearer to client instead of accessing from original
    web source. Web cache sharing can be benefited a lot from BF as total message
    exchange are quadratic in the total number of proxies. The advantage of web caching
    is to lower down the unnecessary bandwidth consumption because of increasing Internet
    request. In this process, each proxy server is employed with a compact and summarized
    information of other proxies cached documents. Web proxy servers periodically
    construct BF with their current cache entries and broadcast it to the network.
    For a cache miss, proxy server probes BF for cache hit in other proxies. Queries
    are then sent to the proxies with positive results. The false positive probabilities
    are compensated by reduction in bandwidth consumption as BF refrains the transfer
    of full list of URL cache summaries. The concept of distributed web caching is
    represented in [Fig. 10.7](13chap_10.xhtml#fig10_7).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，网络使用量的增加影响了网络的获取延迟。在这种情况下，分布式代理服务器通过维护每个其他代理服务器信息的 Web 缓存内存来改善延迟，这允许从邻近客户端的缓存中访问所需页面，而不是从原始
    Web 源访问。Web 缓存共享可以从 BF 中获益，因为总的消息交换与代理服务器的总数成二次关系。Web 缓存的优点在于降低了因增加的 Internet
    请求而导致的不必要的带宽消耗。在这个过程中，每个代理服务器都使用其他代理服务器缓存文档的紧凑和总结信息。Web 代理服务器定期使用它们当前的缓存条目构建 BF，并将其广播到网络中。对于缓存未命中，代理服务器会在其他代理服务器的
    BF 中探测缓存命中。然后将查询发送到具有正面结果的代理服务器。误报概率通过减少带宽消耗来补偿，因为 BF 抑制了 URL 缓存摘要的完整列表的传输。分布式
    Web 缓存的概念在 [图 10.7](13chap_10.xhtml#fig10_7) 中表示。
- en: '![Figure 10.7](../images/fig10_7.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7](../images/fig10_7.jpg)'
- en: '**FIGURE 10.7.**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.7.**'
- en: Distributed web caching.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式 Web 缓存。
- en: Here, in counting BF, rather than using a single bit for representing each entry
    in the filter, a fixed size counter value is used to track the count of element
    hashed to that position. In order to avoid counter overflow, poison approximation
    suggests 4 bits per counter for majority of applications. Instead of just checking
    the presence of an element, counting BF is used to check the occurrence of elements
    for *θ* or more times where *θ* implies count threshold. For instance, if *θ*=2
    for one hit wonder case it implies one hit or two hits for a particular event.
    Similar to standard BF, counting BF also generates false positive. However, unlike
    standard BF, counting BF can lead to false negative if a never inserted element
    is tried to be removed from the filter. The parameters *m*, *n*, *k* are also
    defined same as in standard BF. However, counting BF results in wastage of space
    as reported in [[51](bib.xhtml#ch00-bib-51)].
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在计数 BF 中，与使用单个位来表示过滤器中的每个条目不同，而是使用固定大小的计数器值来跟踪哈希到该位置的元素的计数。 为了避免计数器溢出，毒素近似建议每个计数器使用
    4 位，适用于大多数应用程序。 计数 BF 不仅仅检查元素的存在，还用于检查元素出现*θ*次或更多次的情况，其中*θ*表示计数阈值。 例如，如果*θ*=2，对于一次命中奇迹的情况，这意味着特定事件的一次命中或两次命中。
    与标准 BF 类似，计数 BF 也会产生误报。 但是，与标准 BF 不同，如果尝试从过滤器中删除从未插入的元素，则计数 BF 可能导致假阴性。 参数*m*、*n*、*k*的定义与标准
    BF 相同。 然而，据报道，计数 BF 导致空间浪费[[51](bib.xhtml#ch00-bib-51)]。
- en: 'Initially, all bits in this filter are zero. Operations supported by couting
    BF are described as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，该过滤器中的所有位都是零。 计数 BF 支持的操作描述如下：
- en: 'Insertion: To insert an element, pass it through *k* hash functions and *k*
    counters corresponding to these hash functions are incremented by one. To explain
    this concept, consider a BF with 3 hash functions, i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub></mrow></math>)
    where <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    and *x* represents number to be inserted. The insertion of elements 9, 15, 8 are
    represented in [Fig. 10.8](13chap_10.xhtml#fig10_8). The hash index corresponding
    to each element is:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个元素，需要经过*k*个哈希函数，然后递增对应于这些哈希函数的*k*个计数器。为了解释这个概念，考虑一个具有 3 个哈希函数的 BF，即，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub></mrow></math>)
    其中 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>，而*x*代表要插入的数字。元素
    9、15、8 的插入操作见[图 10.8](13chap_10.xhtml#fig10_8)。每个元素对应的哈希索引为：
- en: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn></mrow></math>
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></math>
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn></mrow></math>
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn></mrow></math>
- en: '![Figure 10.8](../images/fig10_8.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.8](../images/fig10_8.jpg)'
- en: '**FIGURE 10.8.**'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.8.**'
- en: Insertion in Counting BF.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在计数 BF 中的插入操作。
- en: 'Lookup: While membership query for an element, feed the element to *k* hash
    functions. If any bit mapped to these corresponding locations is zero, it implies
    that element is definitely not in the set otherwise, it may be present. The membership
    query for element 9 and 15 results in true positive whereas for element 13 a false
    positive is reported as represented in [Fig. 10.9](13chap_10.xhtml#fig10_9) (
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn></mrow></math>).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询：对于一个元素的成员查询，将该元素输入到 *k* 个哈希函数中。如果任何一个位映射到这些对应的位置为零，则意味着该元素绝对不在集合中，否则，可能存在。对于元素
    9 和 15 的成员查询结果为真正，而对于元素 13 的成员查询报告为假正，如 [图 10.9](13chap_10.xhtml#fig10_9) 所示（<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn></mrow></math>）。
- en: '![Figure 10.9](../images/fig10_9.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.9](../images/fig10_9.jpg)'
- en: '**FIGURE 10.9.**'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.9.**'
- en: Lookup in Counting BF.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数 BF 中的查询。
- en: 'Deletion: To delete an element simply decrement the counter value of the corresponding
    location by one as represented in [Fig. 10.10](13chap_10.xhtml#fig10_10) for element
    8\. In addition to this, [Fig. 10.11](13chap_10.xhtml#fig10_11) represent case
    where element 13 which is never added to the filter is deleted and subsequently
    membership query for element 8 results in a false negative. Nevertheless, counting
    BF supports deletion but its space cannot be extended on demand [[92](bib.xhtml#ch00-bib-92)].'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：要删除一个元素，只需将相应位置的计数器值减一，如 [图 10.10](13chap_10.xhtml#fig10_10) 中表示的元素 8\. 此外，[图
    10.11](13chap_10.xhtml#fig10_11) 表示了一个情况，即从过滤器中从未添加过的元素 13 被删除，随后对元素 8 的成员查询结果为假负。尽管计数
    BF 支持删除，但其空间不能按需扩展 [[92](bib.xhtml#ch00-bib-92)]。
- en: '![Figure 10.10](../images/fig10_10.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.10](../images/fig10_10.jpg)'
- en: '**FIGURE 10.10.**'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.10.**'
- en: Deletion in Counting BF.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数 BF 中的删除。
- en: '![Figure 10.11](../images/fig10_11.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.11](../images/fig10_11.jpg)'
- en: '**FIGURE 10.11.**'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.11.**'
- en: Understanding false negative for Counting BF.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理解计数 BF 的假负。
- en: Counting overflow is however an disadvantage of counting BF. If an counter value
    reaches <math alttext="" display="inline"><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn></mrow></math>,
    (where w represents width of the counter), it cannot be incremented after this
    point. Counting BF also supports the same applications as described for standard
    BF. Differently, a Counting BF can be incorporated in place of BF to allow deletion
    of least recently used web information from web cache. A worth application of
    counting BF is to detect DDoS attacks by setting an approximate count on access
    of given webpage in a short timespan.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 计数溢出是计数 BF 的一个缺点。如果计数器值达到 <math alttext="" display="inline"><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn></mrow></math>（其中
    w 表示计数器的宽度），则在此点之后无法递增。计数 BF 也支持与标准 BF 描述的相同应用程序。不同之处在于，计数 BF 可以替换 BF 并允许从 Web
    缓存中删除最近未使用的 Web 信息。计数 BF 的一个值得注意的应用是在短时间内对给定网页的访问设置近似计数以检测 DDoS 攻击。
- en: '[10.2.3.2 Compressed BF](contents.xhtml#rsec10_2_3_2)'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[10.2.3.2 压缩 BF](contents.xhtml#rsec10_2_3_2)'
- en: The intension behind the introduction of compressed BF [[146](bib.xhtml#ch00-bib-146)]
    is to enable BF to be passed as a message among different network nodes. Compression
    is an effective technique to reduce transmission size and compressing a BF can
    improve network performance. Arithmetic coding is however recommended by authors
    for fast compression process. Clearly, here developers are concerned for optimizing
    transmission size in a network with heavy network traffic. Along with reducing
    bits to be broadcasted, false positive rate and lookup cost also get reduced.
    Unfortunately, compression and decompression increase processing costs. Here,
    hash function is not optimized for *m* and *n* rather for transmission size (which
    is not necessarily *m* but a compressed array). However, false positive probability
    is targeted to minimize after compression.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 引入压缩 BF [[146](bib.xhtml#ch00-bib-146)] 的目的是使 BF 可以在不同的网络节点之间作为消息传递。压缩是一种有效的技术，可以减小传输大小，而压缩
    BF 可以提高网络性能。作者建议使用算术编码进行快速压缩过程。显然，开发人员在关注网络流量大的网络中优化传输大小。除了减少广播比特位数之外，假阳性率和查找成本也会降低。不幸的是，压缩和解压缩会增加处理成本。在这里，哈希函数不是针对
    *m* 和 *n* 进行优化，而是针对传输大小（不一定是 *m*，而是一个压缩数组）。然而，压缩后的假阳性概率被目标最小化。
- en: In standard BF, the main concern of the developers is to minimize the probability
    of false positive by manipulating *k* for a fixed value of *m* and *n*. The standard
    BF is optimized for <math alttext="" display="inline"><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mn>0.7</mn><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></math>
    when each bit position has <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>
    probability of being set as 0 or 1\. Although, in compressed BF, *k* is selected
    so that the probability of each array entry being 1 if <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math>.
    Hence, resulting unbalanced filter will contain <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math>
    1's and <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow></math>
    0's so that it is easy to compress. This feature is leveraged to compress *m*
    bit array and to suppress its transmission size. To achieve this, reduced number
    of hash functions are employed for large filter size so that less bits than standard
    BF are transmitted in the network with low FPR. Specifically, with same number
    of bits to transfer, compressed BF achieves lower FPR over standard BF. Notably,
    the FPR is lower down to <math alttext="" display="inline"><mrow><msup><mrow><mn>0.5</mn></mrow><mrow><mo
    stretchy="false">(</mo><mi>z</mi><mo>/</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup></mrow></math>,
    where *z* is the array size after compression. Here, authors have concluded that
    with the increase in size of filter it is possible to minimize the use of hash
    functions. [Table 10.2](#tab10_2) shows the result when 8 bits per element are
    used for transmission, i.e., <math alttext="" display="inline"><mrow><mfrac><mi>z</mi><mi>n</mi></mfrac><mo>=</mo><mn>8</mn></mrow></math>
    Similar to standard BF, completely random hash functions are used and deletion
    of elements is not possible. Also, a large value of *w* can lead to space wastage
    due to number of unused zeros. Hence, deciding the right value of *w* is a complex
    trade-off that depends on type of application and distribution of data. Moreover,
    other variants of BF such as counting BF can be benefited from this compression.
    At the receiving node, BF is decompressed. Clearly, this filter still demands
    larger memory space at the endpoints. Specifically, compressed BF is utilized
    in P2P sharing among distributed nodes. However, lightweight nodes with few computing
    powers and memory resources may fail for this complicated algorithm.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 BF 中，开发者的主要关注点是通过调整 *k*（对于固定的 *m* 和 *n* 值）来尽量减少误报的概率。标准 BF 在 <math alttext=""
    display="inline"><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mn>0.7</mn><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow></math>
    时进行了优化，此时每个位位置的设置为 0 或 1 的概率为 <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>。尽管在压缩
    BF 中，选择 *k* 以使每个数组条目为 1 的概率为 <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math>，从而产生不平衡的过滤器，包含
    <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math>
    个 1 和 <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow></math>
    个 0，易于压缩。这一特性用于压缩 *m* 位数组并减少其传输大小。为了实现这一目标，对于较大的过滤器大小使用了较少的哈希函数，因此网络传输的比特数比标准
    BF 少，同时具有较低的误报率。具体来说，在相同的比特数传输的情况下，压缩 BF 实现了比标准 BF 更低的误报率。值得注意的是，误报率降低到 <math
    alttext="" display="inline"><mrow><msup><mrow><mn>0.5</mn></mrow><mrow><mo stretchy="false">(</mo><mi>z</mi><mo>/</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></msup></mrow></math>，其中 *z* 是压缩后的数组大小。在此，作者们得出结论，随着过滤器大小的增加，可以最小化哈希函数的使用。[表
    10.2](#tab10_2) 显示了在传输中每个元素使用 8 比特时的结果，即 <math alttext="" display="inline"><mrow><mfrac><mi>z</mi><mi>n</mi></mfrac><mo>=</mo><mn>8</mn></mrow></math>。与标准
    BF 类似，完全随机的哈希函数被使用，且元素的删除是不可能的。此外，较大的 *w* 值可能导致由于未使用的零的数量而产生空间浪费。因此，决定正确的 *w*
    值是一个复杂的权衡，取决于应用程序的类型和数据的分布。此外，BF 的其他变体，如计数 BF，可以从这种压缩中受益。在接收节点，BF 被解压缩。显然，这种过滤器在端点处仍然需要更大的内存空间。具体而言，压缩
    BF 被用于分布式节点之间的 P2P 共享。然而，具有少量计算能力和内存资源的轻量级节点可能无法处理这种复杂的算法。
- en: '[10.2.3.3 Spectral BF](contents.xhtml#rsec10_2_3_3)'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.3 光谱 BF](contents.xhtml#rsec10_2_3_3)'
- en: Unfortunately, standard BF doesn't support multiset, i.e., it doesn't allow
    query for multiplicities of an element if an element is repeating more than once
    in a set. In 2003, spectral BF [[65](bib.xhtml#ch00-bib-65)] was designed specifically
    to support multiset and preferred to be used for streaming data. In fact spectral
    BF is an optimized extension of counting BF. The term spectral signifies that
    the multiplicities of element are supported within a requested spectrum. Improved
    lookup, enhanced accuracy and support of deletion are the reasons for adopting
    spectral BF over standard BF. Similar to counting BF, a *m* counter array is used
    rather than a bit vector. All the counters are initialized to zero. However, the
    usage of counter instead of single bit increases up the space requirements. Along
    with insertion and lookup operations, spectral BF supports deletion as well. The
    time complexity for all these operations is constant, i.e., <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math>. Handling
    ad-hoc iceberg queries, spectral Bloomjoins, providing fast aggressive index are
    some of the use cases of spectral BF. Ad-hoc iceberg queries perform queries for
    a threshold specified at query time and return a small portion of data. The facility
    of spectral Bloomjoins reduces the common rounds for remote databases sites while
    performing joins in order to minimize complexity and network usage. Moreover,
    spectral BF is used for scenarios that demands an index on a relation for frequency
    count queries, for instance, bifocal sampling. Spectral BF employs two scheme
    for its operations, i.e., minimal increase and recurring minimum. The former is
    suited for insertion and lookup whereas the later can support deletion as well.
    For sequence that requires insertions and lookup only, minimal increase shows
    improved performance over recurring minimum. <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi></mrow></math>
    is the total space requirement for this data structure where *N* is the overall
    length of array and *m* is the number of unique elements inserted into array.
    Now, we will discuss the two spectral BF scheme one by one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，标准BF不支持多重集合，即，如果一个元素在集合中重复多次，则不允许查询该元素的重复次数。2003年，谱BF[[65](bib.xhtml#ch00-bib-65)]专门设计用于支持多重集合，并且更适用于流数据。事实上，谱BF是计数BF的优化扩展。术语“谱”表示支持元素的重复次数在一个请求的频谱内。改进的查找、增强的准确性和支持删除是选择谱BF而不是标准BF的原因。与计数BF类似，使用的是一个*m*计数器数组而不是位向量。所有计数器都初始化为零。然而，使用计数器而不是单个位会增加空间需求。除了插入和查找操作外，谱BF还支持删除操作。所有这些操作的时间复杂度都是常数，即，<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>。处理临时冰山查询、谱Bloom连接、提供快速的积极索引是谱BF的一些用例。临时冰山查询在查询时执行具有指定阈值的查询，并返回少量数据。谱Bloom连接的功能减少了远程数据库站点的常见轮次，同时执行连接以最小化复杂性和网络使用。此外，谱BF用于需要关系上频率计数查询的场景，例如，双焦采样。谱BF采用两种方案进行操作，即，最小增量和重复最小值。前者适用于插入和查找，而后者也支持删除。对于只需要插入和查找的序列，最小增量显示出比重复最小值更好的性能。<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>N</mi></mrow></math>是此数据结构的总空间需求，其中*N*是数组的总长度，*m*是插入到数组中的唯一元素的数量。现在，我们将依次讨论两种谱BF方案。
- en: '**Minimal Increase**: This scheme is based on key insight that minimal counter
    has the most appropriate results for *k* counter positions corresponding to *k*
    hash functions as other items could also be hashed to same locations in large
    datasets. With this insight, for a increment operation, only minimal valued counter
    are incremented and rest are kept intact. For a multiset *S*, say <math alttext=""
    display="inline"><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow></math> be the
    frequency of element *x* in the set.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小增加**：这种方案基于一个关键的见解，即最小计数器对应于*k*个哈希函数的*k*个计数器位置具有最合适的结果，因为其他项在大型数据集中也可能被散列到相同的位置。有了这个见解，对于增量操作，只有最小值的计数器会增加，而其余的保持不变。对于一个多重集合*S*，假设<math
    alttext="" display="inline"><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow></math>是集合中元素*x*的频率。'
- en: 'Insertion: While inserting an element, positions corresponding to *k* hash
    functions are calculated and only minimal valued counter value is incremented
    by 1\. Consider a spectral BF with *10* counter values and *3* hash functions,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>.
    [Fig. 10.12](13chap_10.xhtml#fig10_12) represents insertion with minimal increase
    scheme. Here, element 9, 15, 8, 9, 8, 9 are inserted in series and while insertion
    only minimal counter value is incremented by 1\. For instance, while inserting
    element 8 for the first time, hash functions returned 8, 9, 6 as array location
    which has data 1, 1, 0 respectively. So while inserting 8, only value at location
    6, i.e., 0 is incremented. However, for second time insertion of element 9, hash
    functions returned 9, 1, 8 locations which has value 1, 1, 1\. As all three places
    have same counter values, so all get incremented by 1.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：在插入元素时，会计算与*k*个哈希函数对应的位置，并且只有最小值的计数器会加1。考虑一个具有*10*个计数器值和*3*个哈希函数的谱Bloom过滤器，即，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>。[Fig.
    10.12](13chap_10.xhtml#fig10_12) 表示使用最小增加方案进行插入。在这里，元素9、15、8、9、8、9按顺序插入，插入时只有最小计数器值加1。例如，第一次插入元素8时，哈希函数返回了数组位置8、9、6，其数据分别为1、1、0。因此，在插入8时，只有位置6的值，即0，会加1。但是，对于第二次插入元素9，哈希函数返回了位置9、1、8，其值为1、1、1。由于所有三个位置具有相同的计数器值，因此所有位置都会加1。
- en: 'Frequency query: A frequency count query for element *x* returns <math alttext=""
    display="inline"><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow></math>. After
    feeding through *k* hash function, return the minimum value among the *k* locations.
    [Fig. 10.13](13chap_10.xhtml#fig10_13) represents lookup operation with minimal
    increase scheme. Here, query for element 8 returned 2 as location corresponding
    to hash functions, i.e., 8, 9, 6 has value 3, 3, 2 respectively and minimum of
    them which is 2 is returned for frequency query result. Also, query for element
    13 returned 1 despite the fact it is not present in the set which is clearly a
    false positive.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率查询：对元素*x*的频率计数查询返回<math alttext="" display="inline"><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow></math>。经过*k*个哈希函数处理后，返回*k*个位置中的最小值。[图10.13](13chap_10.xhtml#fig10_13)表示了采用最小增量方案的查找操作。这里，查询元素8返回2作为对应于哈希函数的位置，即，8、9、6的值分别为3、3、2，它们的最小值为2，因此返回频率查询结果为2。此外，查询元素13返回1，尽管它不在集合中，这显然是一个错误的阳性。
- en: 'Deletion: Deletion is not preferable while using minimal increase. As all counter
    values are not incremented while inserting an element (only minimal counter values
    are incremented) so, the deletion operation may result in false negative. [Fig.
    10.14](13chap_10.xhtml#fig10_14) represents occurrence of false negative while
    performing deletion in spectral BF. Deletion of element 9 will decrement the counter
    value of locations 9, 1, 8 by 1 and consequently frequency query for element 8
    will return 1 which should be actually 2 as elements as 2 occurrences.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：在使用最小增量时，不推荐删除。因为在插入元素时并不是所有计数器值都会增加（只有最小计数器值会增加），所以删除操作可能会导致错误的负值。[图10.14](13chap_10.xhtml#fig10_14)表示在谱布隆过滤器中执行删除时发生错误的负值。删除元素9将会将位置9、1、8的计数器值减1，因此查询元素8的频率将返回1，但实际上应该是2，因为元素出现了2次。
- en: '![Figure 10.12](../images/fig10_12.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12](../images/fig10_12.jpg)'
- en: '**FIGURE 10.12.**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.12。**'
- en: Insertion in spectral BF following minimal increase scheme.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在谱布隆过滤器中采用最小增量方案进行插入。
- en: '![Figure 10.13](../images/fig10_13.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13](../images/fig10_13.jpg)'
- en: '**FIGURE 10.13.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.13。**'
- en: Lookup operation in spectral BF following minimal increase scheme.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在谱布隆过滤器中采用最小增量方案的查找操作。
- en: '![Figure 10.14](../images/fig10_14.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14](../images/fig10_14.jpg)'
- en: '**FIGURE 10.14.**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.14。**'
- en: Deletion operation in spectral BF following minimal increase scheme.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在谱布隆过滤器中采用最小增量方案的删除操作。
- en: '**Recurring Minimum:** Recurring Minimum employs two different spectral BF''s,
    primary (F1), secondary (F2). The key logic for recurring minimum is that elements
    facing errors while querying have less chances for recurring minima counter values.
    Here, the items with recurring minima counter values corresponding to *k* hash
    functions are maintained in primary spectral BF whereas elements with unique minimum
    counter values are maintained in secondary spectral BF. Hence, the secondary BF
    stores elements which faces higher error rates. Nevertheless, hashing twice into
    BF in case of unique minimum makes recurring minimum a complex method. Operations
    supported by recurring minimum scheme is discussed as follows.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复最小值：** 重复最小值使用两个不同的频谱 BF，主要（F1），次要（F2）。重复最小值的关键逻辑是，查询时遇到错误的元素具有较少的重复最小计数器值的机会。在这里，具有
    *k* 个哈希函数对应的重复最小计数器值的项目在主频谱 BF 中维护，而具有唯一最小计数器值的元素在次要频谱 BF 中维护。因此，次要 BF 存储面临更高错误率的元素。尽管如此，在唯一最小情况下进行两次哈希到
    BF 使得重复最小值成为一个复杂的方法。重复最小值方案支持的操作如下所述。'
- en: 'Insertion: To insert an item *x*, increment the corresponding *k* counters
    in primary BF. Next, check whether element *x* has recurring minimum counter value,
    if so continue the counter value process. Otherwise, if *x* has single minimum
    counter value, check for *x* in secondary BF and increment counter. If not found
    there, insert *x* to secondary Spectral BF with a value equal to minimal counter
    value retrieved from primary BF.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个项 *x*，在主 BF 中递增相应的 *k* 计数器。接下来，检查元素 *x* 是否具有重复的最小计数器值，如果是，则继续计数器值的过程。否则，如果
    *x* 具有单个最小计数器值，请在次要 BF 中检查 *x* 并递增计数器。如果在那里找不到，则将 *x* 插入到次要频谱 BF 中，其值等于从主 BF 检索到的最小计数器值。
- en: 'Frequency query: To query an element, first probe primary BF and check if an
    element has recurring minimum then return minimum counter value. Otherwise search
    in secondary BF and the minimum counter value from secondary BF is returned if
    value is greater than zero, if not minimum counter value from primary BF is returned.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率查询：查询一个元素时，首先探测主要的 BF 并检查一个元素是否有重复的最小值，然后返回最小计数器值。否则，在次要 BF 中搜索，如果值大于零，则返回次要
    BF 中的最小计数器值，如果没有，则返回主 BF 中的最小计数器值。
- en: 'Deletion: To delete an element, first delete the counter value by 1 in primary
    SBF. Also, if it has single minimum, decrement its counter value in secondary
    BF as well. Due to the reason that an element is inserted both to primary and
    secondary BF, false negative can never happen.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：要删除一个元素，首先在主 SBF 中将计数器值减 1。此外，如果它有单个最小值，则在次要 BF 中也递减其计数器值。由于一个元素同时插入了主 BF
    和次要 BF，所以假阴性永远不会发生。
- en: '[10.2.3.4 Deletable Bloom Filter (DBF)](contents.xhtml#rsec10_2_3_4)'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.4 可删除的布隆过滤器（DBF）](contents.xhtml#rsec10_2_3_4)'
- en: 'Deletable BF (DBF) [[165](bib.xhtml#ch00-bib-165)] was introduced to solve
    the problem of false negatives that happens while deleting elements in counting
    BF. However, instead of employing a counter array like counting BF, a bit array
    of *m* bits is used. The key insight behind DBF is that it tries to locate the
    bit region where collision while inserting an element can take place and deletion
    can only be done in collision free area. Here a bit array of *m* bits is divided
    into *r* region and each region should contain <math alttext="" display="inline"><mrow><mfrac><mrow><msup><mi>m</mi><mo>′</mo></msup></mrow><mi>r</mi></mfrac></mrow></math>
    bits each where <math alttext="" display="inline"><mrow><msup><mi>m</mi><mo>′</mo></msup><mo>=</mo><mi>m</mi><mo>−</mo><mi>r</mi></mrow></math>.
    At the starting of *m* bit array, a collision bitmap of size *r* is kept to code
    and these *r* bits are initialized to 0\. 1 in collision bitmap is marked for
    a collision prone area whereas zero represents a collision free region. A key
    question while designing BF is to choose the value of *r* as this value decides
    the capability of a BF to remove elements and FPR. The false positive probability
    for DBF is calculated as:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可删除布隆过滤器（DBF）[[165](bib.xhtml#ch00-bib-165)]被引入来解决在计数布隆过滤器中删除元素时出现的假负问题。然而，与计数布隆过滤器使用计数器数组不同，它使用了一个包含*m*位的位数组。DBF背后的关键见解是，它试图定位在插入元素时可能发生冲突的位区域，而删除只能在无冲突的区域进行。这里，一个*m*位的位数组被分为*r*个区域，每个区域应该包含<math
    alttext="" display="inline"><mrow><mfrac><mrow><msup><mi>m</mi><mo>′</mo></msup></mrow><mi>r</mi></mfrac></mrow></math>位，其中<math
    alttext="" display="inline"><mrow><msup><mi>m</mi><mo>′</mo></msup><mo>=</mo><mi>m</mi><mo>−</mo><mi>r</mi></mrow></math>。在*m*位数组的开头，保留了一个大小为*r*的冲突位图来编码，这些*r*位被初始化为0。冲突位图中的1表示冲突易发生区域，而零表示无冲突区域。在设计BF时的一个关键问题是选择*r*的值，因为这个值决定了BF删除元素和FPR的能力。DBF的假阳性概率计算如下：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close="]" open="["><mrow><mn>1</mn><mo>−</mo><msup><mrow><mfenced
    close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mrow><mi>m</mi><mo>−</mo><mi>r</mi></mrow></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mo>*</mo><mi>n</mi></mrow></msup></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.14)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>P</mi><mo>=</mo><msup><mrow><mfenced close="]" open="["><mrow><mn>1</mn><mo>−</mo><msup><mrow><mfenced
    close=")" open="("><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mrow><mi>m</mi><mo>−</mo><mi>r</mi></mrow></mfrac></mrow></mfenced></mrow><mrow><mi>k</mi><mo>*</mo><mi>n</mi></mrow></msup></mrow></mfenced></mrow><mi>k</mi></msup></mrow></mtd></mtr></mtable></mrow></math>(10.14)
- en: 'where, *n* is the total number of elements to be inserted. Operations supported
    by DBF are described as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*n*是要插入的元素总数。DBF支持的操作描述如下：
- en: 'Insertion: To insert an element, the *k* positions corresponding to *k* hash
    functions are set to 1\. If any cell among *k* locations is found to be already
    1, it represents case of collision and in response to this collision, the bit
    corresponding to the region where collision happened in collision bitmap is set
    to 1\. [Fig. 10.15](13chap_10.xhtml#fig10_15) represents insertion in DBF. Here,
    element 15, 9, 8, 4 are inserted in series with 3 hash functions as: <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>.
    For element 9, no collision is detected whereas for element 8, collision is detected
    at 8th location in region 3\. So, the corresponding bit in the collision bitmap
    is set to 1\. Similarly, for element 4, collision happens in region 1, 2, and
    3 so these same positions in collision bitmap are set to 1.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个元素，对应于*k*个哈希函数的*k*个位置被设置为1。如果*k*个位置中的任何一个单元格已经是1，则表示发生了冲突，在响应此冲突时，碰撞位图中发生冲突的区域的位被设置为1。[图10.15](13chap_10.xhtml#fig10_15)代表DBF中的插入。在这里，元素15、9、8、4被按序插入，使用3个哈希函数：<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mi>x</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>11</mn></mrow></math>。对于元素9，未检测到冲突，而对于元素8，在区域3的第8个位置检测到冲突。因此，碰撞位图中的相应位被设置为1。类似地，对于元素4，在区域1、2和3中发生冲突，因此这些碰撞位图中的相同位置被设置为1。
- en: '![Figure 10.15](../images/fig10_15.jpg)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.15](../images/fig10_15.jpg)'
- en: '**FIGURE 10.15.**'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图10.15。**'
- en: Insertion operation in deletable BF.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在可删除的BF中的插入操作。
- en: 'Lookup query: To query an element, pass the element in question through *k*
    hash functions and if any of *k* location is 0, the element is not in set otherwise
    it might be present.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找查询：要查询一个元素，将要查询的元素通过*k*个哈希函数，如果*k*个位置中有任何一个位置为0，则该元素不在集合中，否则可能存在。
- en: 'Deletion: To delete, among *k* computed hashed locations, reset only those
    bits that lie in collision free zone. If all *k* bits corresponding to hash functions
    are located in collision prone area, then the element is non-deletable. Hence,
    the deletion of an element is only possible if atleast any one bit among *k* can
    be reset to 0\. This way false negative are avoided but false positives are still
    possible. [Fig. 10.16](13chap_10.xhtml#fig10_16) represents deletion for DBF.
    As shown in the figure element 15 cannot be deleted because corresponding hashed
    locations, i.e., 4, 0, 8 all lies in collision prone area whereas element 9 is
    successfully deleted as among corresponding hashed locations 9th, 10th location
    lies in collision free area.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：要删除，在*k*个计算的哈希位置中，只重置位于无碰撞区域的位。如果所有对应哈希函数的*k*位位于碰撞区域，则该元素不可删除。因此，只有当*k*中的至少一个位可以重置为0时，才能删除元素。这样可以避免假负，但假正可能仍然存在。[图
    10.16](13chap_10.xhtml#fig10_16)展示了DBF的删除操作。如图所示，元素15无法删除，因为对应的哈希位置，即4、0、8都位于碰撞区域，而元素9成功被删除，因为对应的哈希位置中第9和第10位置位于无碰撞区域。
- en: '![Figure 10.16](../images/fig10_16.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.16](../images/fig10_16.jpg)'
- en: '**FIGURE 10.16.**'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.16.**'
- en: Deletion operation in DBF.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DBF中的删除操作。
- en: '[10.2.3.5 Stable BF](contents.xhtml#rsec10_2_3_5)'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.5 稳定BF](contents.xhtml#rsec10_2_3_5)'
- en: Unfortunately, the count of zero in BF decreases with time and there reaches
    a point when all the queries are answered as probably in the set. The reason behind
    introduction of SBF is to eliminate duplicates in the streaming data and to evict
    stale data before error reaches a pre-defined threshold value. Stable BF creates
    space for more recent items as this data is of more importance than the stale
    one. Similar to counting BF, an array of *d*-bit counters is used here and all
    counters are initialized to 0\. So, maximum counter value can reach <math alttext=""
    display="inline"><mrow><msup><mn>2</mn><mi>d</mi></msup><mo>−</mo><mn>1</mn></mrow></math>.
    To deal with stale data, Stable BF evicts stale data to create space for new data.
    Query processing, URL crawling, monitoring distinct IP addresses, graph processing
    are some of the applications of Stable BF.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，BF中零的计数随时间减少，到达一定时点时，所有查询都被回答为可能存在于集合中。SBF的引入是为了消除流数据中的重复项，并在错误达到预定义阈值之前驱逐过时数据。稳定BF为更新的数据创建了空间，因为这些数据比旧数据更重要。与计数BF类似，这里使用*d*位计数器数组，所有计数器初始化为0。因此，最大计数器值可以达到<math
    alttext="" display="inline"><mrow><msup><mn>2</mn><mi>d</mi></msup><mo>−</mo><mn>1</mn></mrow></math>。为了处理过时数据，稳定BF清除过时数据以为新数据创建空间。查询处理、URL抓取、监视不同IP地址、图处理是稳定BF的一些应用。
- en: 'Insertion: To insert an item, pass it through *k* hash functions. After some
    point when the number of zeros becomes constant, update Stable BF. To update,
    randomly *p* counter value is decremented by 1\. After this step, all *k* computed
    hash locations are set to a maximum value.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个项，需要通过*k*个哈希函数。在某个点上，当零的数量变得恒定时，更新稳定BF。要更新，随机减少*p*计数器值1。在这一步之后，所有*k*个计算出的哈希位置被设置为最大值。
- en: 'Checking duplicacy: To check duplicate value, query and check whether *k* hashed
    cells is hashed to 0 or 1\. For a case where any cell returns 0, there is no duplicate
    item in te set otherwise duplicacy exist. However, randomly setting bits to 0
    may result in false negative. Here, false negative is defined as a situation when
    query for duplicate item is answered as distinct. Also, false negative is dependent
    on input data distribution. For the elements that don''t have predecessor, the
    chances of false negative are zero.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查重复性：要检查重复值，查询并检查*k*个哈希单元是否哈希为0或1。对于任何一个单元返回0的情况，集合中不存在重复项，否则存在重复性。然而，随机将位设置为0可能导致错误负值。这里，错误负值定义为当查询重复项时被回答为不同的情况。另外，错误负值取决于输入数据分布。对于没有前任的元素，错误负值的机会为零。
- en: Moreover, Stable BF guarantees a tight upper bound on FPR while introducing
    false negative due to randomly eviction of stale information. Setting *p=0* and
    *d=1*, Stable BF behaves as SBF. [Fig. 10.17](13chap_10.xhtml#fig10_17) represents
    a case for *p=2* and *d=3*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，稳定BF保证了FPR的严格上限，同时由于随机逐出过时信息而引入了错误负值。设置*p=0*和*d=1*，稳定BF的行为类似于SBF。[图10.17](13chap_10.xhtml#fig10_17)表示*p=2*和*d=3*的情况。
- en: '![Figure 10.17](../images/fig10_17.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17](../images/fig10_17.jpg)'
- en: '**FIGURE 10.17.**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.17.**'
- en: Understanding Stable BF.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 理解稳定BF。
- en: '[10.2.3.6 Retouched Bloom Filter (RBF)](contents.xhtml#rsec10_2_3_6)'
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.6 修正的Bloom过滤器（RBF）](contents.xhtml#rsec10_2_3_6)'
- en: One approach to reduce false positive is by increasing the size of bit vector.
    However, this approach can lead to increased memory usage. Another BF variant
    to decrease FPR from the filter is introduced by Donnet *et al.* [[73](bib.xhtml#ch00-bib-73)]
    and named as RBF. This filter also enhances flexibility of the system. Here, false
    positives that are more troublesome over others are tried to be removed from the
    filter. However, this approach introduces random false negatives. False negatives
    are compensated with the advantage that more concerning false positives are handled.
    Here the false positives are tried to be identified after the construction of
    BF but before it has been used. Retouched BF randomly removes some false positive
    with a trade-off against introducing some false negatives. Notably, false negatives
    doesn't happen in standard BF.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 减少假阳性的一种方法是增加位向量的大小。然而，这种方法可能会增加内存使用量。Donnet 等人引入了另一种从过滤器中减少 FPR 的 BF 变种，并命名为
    RBF。该过滤器还增强了系统的灵活性。在这里，试图从过滤器中删除更为麻烦的假阳性。然而，这种方法引入了随机假阴性。在构建 BF 之后但在其被使用之前，试图识别出假阳性。经过调整的
    BF 通过与引入一些假阴性的权衡来随机移除一些假阳性。值得注意的是，在标准 BF 中不会发生假阴性。
- en: RBF works by resetting some chosen bits in bit vector to 0 in order to reduce
    FPR. This process of RBF is named as bit clearing process. Clearly, for an element
    if any position corresponding to *k* hash functions are reset to 0 in bit clearing
    process, it will result in false negative. The bit clearing process can be randomized
    or selective. The results of RBF are concluded on a metric *χ*. If the value of
    this metric is greater than 1, it implies that removed false positive proportion
    is higher over generated false negative proportion whereas a value lesser than
    1 represents that removed false positive proportion is lower than generated false
    negative.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: RBF 通过将位向量中的一些选定位重置为 0 来降低 FPR。这个 RBF 的过程被称为位清除过程。显然，对于一个元素，如果位清除过程中任何位置对应于
    *k* 个哈希函数的位置都被重置为 0，则会导致假阴性。位清除过程可以是随机的或有选择性的。RBF 的结果被总结在一个度量 *χ* 上。如果这个度量的值大于
    1，则意味着删除的假阳性比例高于生成的假阴性比例，而小于 1 的值表示删除的假阳性比例低于生成的假阴性。
- en: 'Randomized Bit clearing RBF: In random bit clearing process, randomly some
    bits are reset to 0, despite of the logic whether these bits are reset to 0\.
    For randomized bit clearing process, it is observed that value of *χ* is calculated
    as 1 which implies that overall error rate for the system is maintained.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机位清除 RBF：在随机位清除过程中，随机地将一些位重置为 0，尽管这些位是否重置为 0 的逻辑是不确定的。对于随机位清除过程，观察到 *χ* 的值计算为
    1，这意味着系统的整体错误率得以维持。
- en: 'Selective bit clearing RBF: Unlike randomized bit clearing, only those bits
    are reset to zero, that contributes to false positive. Selective clearing process
    has 4 algorithms to proceed which are discussed as follows:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择性位清除 RBF：与随机位清除不同，只有那些导致假阳性的位被重置为零。选择性清除过程有4种算法可以进行，如下所讨论：
- en: 'Random selection: The first one is random selection that doesn''t demand any
    intelligence for selective clearing process. Here, unlike randomized bit clearing
    process instead of resetting random bits in bit vector, only a bit among *k* available
    can be reset. Here, only one bit is reset that is related with false positive
    of troublesome keys.'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择：第一个是随机选择，对选择性清除过程不需要任何智能。在这里，与随机位清除过程不同，位向量中不是随机重置位，而是只有一个位可以被重置，该位与麻烦键的假阳性有关。
- en: 'Minimum false negative selection: Here, aim is to reduce the probability of
    occurrence of false negative that are generated with selective clearing process.
    This is processed by setting locally a counting vector that stores quantity of
    recorded elements. This algorithm considers possibility of hash collision in the
    bit vector among the hashed key of the element belonging to a set. The disadvantage
    with this algorithm is over estimation.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小误负选择：在这里，目标是减少选择性清除过程中产生的假负的概率。这通过在本地设置一个计数向量来处理，该向量存储记录元素的数量。此算法考虑了在位向量中哈希键和属于集合的元素的哈希键之间的哈希碰撞的可能性。这种算法的缺点是估计过高。
- en: 'Maximum false positive selection: This algorithm aims to remove maximum false
    positive. For every troublesome key to eliminate that was not previously deleted,
    among *k* hashed, chose the position to be reseted that decreaments the number
    of false positive.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大假阳性选择：此算法旨在删除最大假阳性。对于以前未删除的每个令人困扰的键，从*k*个哈希键中选择要重置的位置，以减少假阳性的数量。
- en: 'Ratio selection: The last algorithm is ratio selection which is a combination
    of minimum false negative selection and maximum false positive selection algorithm.
    This also aims to minimizes the generated false negatives and to maximize the
    removal of false positives.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例选择：最后一个算法是比例选择，它是最小误负选择和最大假阳性选择算法的组合。这也旨在最小化生成的假阴性并最大化假阳性的移除。
- en: Selective clearing process decreases the false positive rate at a greater degree
    than increase in generated false positive numbers. Clearly, RBF incurs extra processing
    cost of key removal and this cost is a multiple of RBF parameters such as- number
    of hash functions. For further details and involved mathematics user may refer
    to [[73](bib.xhtml#ch00-bib-73)].
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性清除过程使假阳性率大大降低，而生成的假阳性数量增加的程度小。显然，RBF 会增加键移除的额外处理成本，这个成本是 RBF 参数的倍数，比如哈希函数的数量。有关更多细节和涉及的数学内容，用户可以参考[[73](bib.xhtml#ch00-bib-73)]。
- en: '[10.2.3.7 Dynamic Bloom Filter](contents.xhtml#rsec10_2_3_7)'
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.7 动态布隆过滤器](contents.xhtml#rsec10_2_3_7)'
- en: As previously mentioned that BFs are not good for dynamic set, i.e., set whose
    size changes over time. Static set cannot perform operations of addition and deletion
    operation with standard BF. BF only works well for sets whose size is known in
    advance. Moreover, in BF target FPR threshold is computed after knowing the size
    of total elements. Specifically for applications that does not have any information
    about upper bound on cardinality of sets, it is difficult to decide BF size. In
    case, the number of elements exceeds the threshold of set size, SBF becomes quite
    unsuccessful because of occurrence of too many false positives. Moreover, for
    the distributed application scenario, all nodes on the network have to adopt similar
    configuration with an aim to achieve interoperability of standard BF among nodes.
    To handle such a case, nodes reconstruct their BF if cardinality size of even
    any one node exceeds the threshold value. For most stand alone applications, that
    have prior information about upper bound on total number of elements for a dynamic
    set, a larger space than known upperbound is allocated so that all items can be
    represented. However, this approach reduces the space efficiency of standard BF.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，Bloom Filter（BF）不适用于动态集合，即其大小随时间变化的集合。静态集合无法通过标准 BF 执行添加和删除操作。BF 只对事先已知大小的集合有效。此外，在
    BF 中，目标 FPR 阈值是在了解总元素大小之后计算的。对于那些没有关于集合基数上限的任何信息的应用程序而言，很难决定 BF 的大小。如果元素数量超过集合大小的阈值，SBF
    会变得非常不成功，因为会出现太多的误报。此外，在分布式应用场景中，网络上的所有节点必须采用相似的配置，以实现节点之间标准 BF 的互操作性。为了处理这种情况，如果即使一个节点的基数大小超过了阈值，所有节点都会重建它们的
    BF。对于大多数独立应用程序，对于动态集合，这些应用程序具有关于总元素数量的上限的先验信息，将分配比已知上限更大的空间，以便可以表示所有项目。然而，这种方法会降低标准
    BF 的空间效率。
- en: 'As a solution to this problem of standard BF, dynamic BF was introduced. For
    stand alone applications, dynamic BF can insert an item on demand. For distributed
    applications, dynamic BF handles interoperability issues among nodes as it consumes
    a suitable memory in order to reduce unnecessary waste and transmission overhead.
    Also, it controls rate of false match probability at an acceptable level even
    with an increasing number of elements. Here, in dynamic BF, the false positive
    probability is referred to as false match probability. Notably, dynamic BF can
    support static set as well. Here, a BF is called “active” if false probability
    rate is below a predefined upperbound, otherwise it is referred as full. A dynamic
    BF comprises of *s* homogeneous standard BFs. The *s* is initialized with value
    1 and it is in active state. The insertion of elements can only be done in an
    active BF and a new BF is appended after the previous active BF gets full. [Fig.
    10.18](13chap_10.xhtml#fig10_18) represents the data structure of dynamic BF.
    Let *NR* is the count of elements added to BF. Nevertheless, the dynamic BF is
    initialized with upper bound on false match probability of dynamic BF, max value
    of *s*, upper bound on false positive rate of standard BF, filter size *m* of
    each standard BF, the capacity *C* that is maximum number of items to be stored
    in one standard BF. To create a dynamic BF, initialize one standard BF with the
    above mentioned parameters. The operations supported by dynamic BF is discussed
    as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 解决标准BF问题的一个解决方案是引入了动态BF。对于独立应用，动态BF可以按需插入项目。对于分布式应用程序，动态BF处理节点之间的互操作性问题，因为它消耗适当的内存以减少不必要的浪费和传输开销。此外，它控制错误匹配概率的速率，即使元素数量增加也能保持在可接受的水平。在动态BF中，误报概率称为错误匹配概率。值得注意的是，动态BF也可以支持静态集合。在这里，如果错误概率低于预定义的上限，则BF称为“活动”，否则称为满。动态BF由*s*个同质标准BF组成。*s*的初始值为1，并且处于活动状态。元素的插入只能在活动BF中进行，当前一个活动BF满时，会在其后附加一个新的BF。[图10.18](13chap_10.xhtml#fig10_18)代表了动态BF的数据结构。设*NR*为添加到BF的元素计数。然而，动态BF的初始化值为动态BF的错误匹配概率上限，*s*的最大值，标准BF的错误概率上限，每个标准BF的过滤器大小*m*，即最多可存储的项目数。要创建动态BF，请使用上述参数初始化一个标准BF。动态BF支持的操作如下所述：
- en: 'Insertion: To insert an element, first locate active BF from given dynamic
    BF. If the current BF is not active, the next BF is employed as new active BF
    and value of *s* is incremented by one. Pass the element through *k* hash functions
    and insert the element in current active BF. Next increment the value of *NR*
    by 1 for current BF. After multiple insertions, when number of elements exceeds
    capacity threshold *c*, i.e., *NR <math alttext="" display="inline"><mo>></mo></math>*
    c, a new BF is appended and this newly created BF is referred to as active BF.
    At a time only one BF is active and rest are inactive. The time complexity for
    the insertion operation is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></math>.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个元素，首先从给定的动态布隆过滤器中找到活动布隆过滤器。如果当前的布隆过滤器不活跃，则使用下一个布隆过滤器作为新的活动布隆过滤器，并将 *s*
    的值增加一。通过 *k* 个哈希函数传递元素，并将元素插入当前活动的布隆过滤器中。然后增加当前布隆过滤器的 *NR* 值。在多次插入后，当元素数量超过容量阈值
    *c*，即 *NR <math alttext="" display="inline"><mo>></mo></math>* c 时，将附加一个新的布隆过滤器，并将这个新创建的布隆过滤器称为活动布隆过滤器。一次只有一个布隆过滤器是活动的，其余的是不活跃的。插入操作的时间复杂度为
    <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: 'Lookup query: To search an item, pass the item through *k* hash functions.
    If any of the BF stored in dynamic BF returned true, the element might be present
    into set otherwise if all BFs returned false, element is definitely not present
    into set. The time complexity for the lookup query is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></math>.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找查询：通过 *k* 个哈希函数传递项目来搜索项目。如果动态布隆过滤器中存储的任何一个返回 true，则元素可能存在于集合中；否则，如果所有的布隆过滤器返回
    false，则元素绝对不存在于集合中。查找查询的时间复杂度为 <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></math>。
- en: 'Deletion: Deletion in dynamic BF is somehow difficult. To delete, first check
    for the presence of an element in dynamic BF using lookup query operation discussed
    above. If the element is not present, deletion of element will be rejected. If
    the lookup query results are positive for a single BF, reset the corresponding
    *k* bits to 0 otherwise if multiple BFs returned 1, then dynamic BF don''t delete
    the element in order to prevent occurrence of false negatives. The time complexity
    of the deletion operation is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></math>.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：动态布隆过滤器中的删除有些困难。要删除，首先使用上述查找查询操作在动态布隆过滤器中检查元素是否存在。如果元素不存在，则拒绝删除元素。如果查找查询的结果对单个布隆过滤器为正，则将相应的
    *k* 位重置为 0，否则如果多个布隆过滤器返回 1，则动态布隆过滤器不会删除元素，以防止出现误删除。删除操作的时间复杂度为 <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>s</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: '![Figure 10.18](../images/fig10_18.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18](../images/fig10_18.jpg)'
- en: '**FIGURE 10.18.**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.18.**'
- en: Data structure of dynamic BF.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 动态布隆过滤器的数据结构。
- en: '[10.2.3.8 Cuckoo Filter](contents.xhtml#rsec10_2_3_8)'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.8 布谷过滤器](contents.xhtml#rsec10_2_3_8)'
- en: Similar to BF, cuckoo filter [[78](bib.xhtml#ch00-bib-78)] provides fast membership
    query with great space efficiency. Additionally, cuckoo filter supports deletion,
    limited counting with same space complexity. Cuckoo filter is based on the concept
    of cuckoo hashing. Cuckoo hashing is known for its excellence in handling collisions
    for hashing based data structures. In cuckoo hashing, a cuckoo hash table is employed
    which comprises an array of buckets and an item is supposed to be inserted Here,
    two hash functions each for a table is used. Each item is hashed with two different
    hash functions and each hash function indexes into a bucket. The item is stored
    in any of the two buckets. The item is first tried to be stored in the first bucket
    if there is nothing stored there otherwise the item is stored in the second bucket
    if the corresponding location in the second bucket is empty. In case if the second
    bucket is not empty, then item stored in the second bucket is evicted and reinserted
    in alternate hash index. Next, the element is placed in empty location. Clearly,
    this procedure faces the problem of displacing the older key. If alternate hash
    location of older key is empty, it is quite easy to relocate otherwise older key
    has to displace another key. This process is repeated till an empty bucket is
    found. If this situation leads to a cycle, completely new hash functions are selected
    and the whole data structure is reconstructed again. Hence, the amortized complexity
    for insertion is *O(1)*. The query procedure probes both buckets to check item's
    presence. [Fig. 10.19](13chap_10.xhtml#fig10_19) represents the insertion of element
    20, 50, 53, 75, 100, 67, 105, 3, 36, 39 in sequence.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 BF，布谷过滤器[[78](bib.xhtml#ch00-bib-78)]提供了快速的成员查询和出色的空间效率。此外，布谷过滤器支持删除、有限计数，并具有相同的空间复杂度。布谷过滤器基于布谷哈希的概念。布谷哈希以其处理基于哈希的数据结构碰撞的卓越性而闻名。在布谷哈希中，使用一个布谷哈希表，其中包括一个桶数组，假定要插入一个项。这里，每个表分别使用两个哈希函数。每个项都使用两个不同的哈希函数进行哈希处理，并且每个哈希函数都索引到一个桶。该项存储在两个桶中的任意一个中。首先尝试将项存储在第一个桶中，如果那里没有存储任何内容，则如果第二个桶中对应的位置为空，则将项存储在第二个桶中。如果第二个桶不为空，则在替代哈希索引中逐出并重新插入第二个桶中的项。接下来，元素放置在空位置中。显然，此过程面临将旧键位置替换的问题。如果旧键的备用哈希位置为空，那么重新定位就相当容易，否则，旧键必须替换另一个键。重复此过程直到找到一个空的桶为止。如果此情况导致循环，则会选择全新的哈希函数，并且整个数据结构会被重新构造。因此，插入的摊销复杂度为*O(1)*。查询过程会探测两个桶以检查项的存在。[图
    10.19](13chap_10.xhtml#fig10_19)代表了依次插入元素 20、50、53、75、100、67、105、3、36、39 的过程。
- en: '![Figure 10.19](../images/fig10_19.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19](../images/fig10_19.jpg)'
- en: '**FIGURE 10.19.**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.19.**'
- en: Insertion in cuckoo hashing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 布谷哈希中的插入。
- en: 'A cuckoo filter is determined by its fingerprint and bucket size. For example,
    a *(3,5)* filter implies 3 bit length filter and each bucket can store 5 fingerprints.
    It is concluded that cuckoo filter consumes less space than standard BF if target
    FPR is less than 3%. The membership query performance of cuckoo filter is better
    than standard BF even when 95% space of the filter is consumed. However, storing
    only fingerprint instead of actual item prevents insertion using standard cuckoo
    hashing. Here, the existing fingerprint has to be relocated to an alternate position
    instead of actual items. The operations of cuckoo filter are described as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由其指纹和桶大小确定的布谷鸟过滤器。例如，*(3,5)* 过滤器表示 3 位长度的过滤器，每个桶可以存储 5 个指纹。总结认为，如果目标假阳率小于 3%，则布谷鸟过滤器消耗的空间比标准
    BF 少。即使过滤器的空间使用了 95%，布谷鸟过滤器的成员查询性能也优于标准 BF。然而，仅存储指纹而不是实际项会阻止使用标准布谷鸟哈希进行插入。在这里，现有的指纹必须重新定位到替代位置，而不是实际项。布谷鸟过滤器的操作如下所述：
- en: 'Insertion: Here, the question is how to restore and rehash the original items
    for locating to alternate location? To deal with this problem, cuckoo filter employs
    ”partial key cuckoo hashing” to find item''s alternate location from its fingerprint.
    Here, for an item *x*, the index for two hash buckets is calculated as: <math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> and <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo></mrow></math>. By using XOR operation it is ensured that
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> can be computed using <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and
    fingerprint of *x*. Thus to relocate a key from either of the location calculated
    by <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> or
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> the alternate location is computed by <math
    alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo
    stretchy="false">)</mo></mrow></math> where, *i* is the index location of bucket
    where item is originally stored and *j* is the index of alternate bucket. With
    this process, original value of item *x* is not required. Consider a cuckoo filter
    with two entries per 10 buckets as shown in [Fig. 10.20](13chap_10.xhtml#fig10_20).
    To compute index location for item *x* use <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></math>. Say
    <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>
    and <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>
    are the indices computed from these hash functions. This example uses shift fold
    method to compute fingerprint <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>f</mi><mo
    stretchy="false">)</mo></mrow></math> for item *x* and hash of *x* is computed
    by *xmod*10\. To handle a collision, randomly pick <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>
    or <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>
    (say *i*) and displace fingerprint at bucket *i* to alternate bucket *j* using
    the formula <math alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo></mrow></math>. Following case may exist while inserting:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：在这里，问题是如何恢复和重新散列原始项以定位到替代位置？为了解决这个问题，布谷鸟过滤器采用了”部分键布谷鸟哈希”来从指纹中找到项目的替代位置。在这里，对于一个项目*x*，两个哈希桶的索引计算如下：<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> 和 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo></mrow></math>。通过使用XOR操作，确保了可以使用<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>和*x*的指纹来计算<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math>。因此，要将键从计算得到的<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>或<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math>的位置之一重新定位到替代位置，通过公式<math alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo
    stretchy="false">)</mo></mrow></math>计算替代位置，其中*i*是项目最初存储的桶的索引位置，*j*是替代桶的索引。通过这个过程，不需要项目*x*的原始值。考虑一个布谷鸟过滤器，每10个桶有两个条目，如[图10.20](13chap_10.xhtml#fig10_20)所示。要计算项目*x*的索引位置，请使用<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>和<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></math>。假设<math
    alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>和<math
    alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>是从这些哈希函数计算得到的索引。此示例使用移位折叠方法计算项目*x*的指纹<math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></math>，并且*x*的哈希值通过*xmod*10计算。要处理碰撞，随机选择<math
    alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>或<math
    alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>（假设*i*），并使用公式<math
    alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo></mrow></math>将桶*i*处的指纹移到替代桶*j*。在插入时可能存在以下情况：
- en: '*Case1: Insert(131)*'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Case1: 插入(131)*'
- en: (a)Use shift fold method to compute fingerprint *f*, *f*= 13+1 = 14.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a)使用移位折叠方法计算指纹*f*，*f*= 13+1 = 14。
- en: (b)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>131</mn><mo stretchy="false">)</mo></mrow></math> =
    131*mod*10 =1
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (b)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>131</mn><mo stretchy="false">)</mo></mrow></math> =
    131*mod*10 =1
- en: (c)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mn>14</mn><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>4</mn><mo>=</mo><mn>5</mn></mrow></math>
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (c)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mn>14</mn><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>4</mn><mo>=</mo><mn>5</mn></mrow></math>
- en: (d)As index 1 is available, insert *f* at the same location.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (d)由于索引1可用，在相同位置插入*f*。
- en: '*Case 2: Insert(1111)*'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Case 2: 插入(1111)*'
- en: (a)<math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1111</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>11</mn><mo>+</mo><mn>11</mn><mo>=</mo><mn>22</mn></mrow></math>
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a)<math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1111</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>11</mn><mo>+</mo><mn>11</mn><mo>=</mo><mn>22</mn></mrow></math>
- en: (b)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>1111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (b)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mn>1111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
- en: (c)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>3333</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow></math>
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (c)<math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>3333</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow></math>
- en: (d)As, both indices 1 and 5 are occupied, this represent collision case.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (d)由于索引1和5均被占用，这表示发生了碰撞情况。
- en: (e)Randomly pick <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>
    or <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>
    and displace the fingerprint from selected location to other bucket. Suppose <math
    alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>
    is selected, then <math alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo
    stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>4</mn><mo>=</mo><mn>5</mn></mrow></math>.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (e)随机选择 <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>
    或 <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow></math>
    并将指纹从所选位置移动到其他桶中。假设选择了 <math alttext="" display="inline"><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow></math>，那么
    <math alttext="" display="inline"><mrow><mi>j</mi><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo
    stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo
    stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo
    stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mo stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⊕</mo><mn>4</mn><mo>=</mo><mn>5</mn></mrow></math>。
- en: '![Figure 10.20](../images/fig10_20.jpg)'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.20](../images/fig10_20.jpg)'
- en: '**FIGURE 10.20.**'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 10.20.**'
- en: Insertion in cuckoo filter.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在杜鹃过滤器中插入。
- en: 'Lookup: For an item *x*, first compute fingerprint of *x* and two indices for
    the bucket. Next, read the content of these two locations. If there is match then
    filter returns true otherwise false. This way false negatives are avoided as there
    are no overflows. False positives can happen if two elements have same fingerprint
    and also hash indices are same. Clearly, this process has <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> time
    complexity. However, FPR becomes high when filter gets full.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找：对于项目*x*，首先计算*x*的指纹和桶的两个索引。接下来，读取这两个位置的内容。如果匹配，则过滤器返回true，否则返回false。这样可以避免假阴性，因为没有溢出。如果两个元素具有相同的指纹并且哈希索引也相同，则可能发生假阳性。显然，这个过程的时间复杂度为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>。然而，当过滤器填满时，FPR会变高。
- en: 'Deletion: To delete an item, first follow the same procedure of lookup query
    for the element to be deleted. If there is no match, deletion is not possible,
    otherwise if there is a match, simply delete the copy of that fingerprint from
    the bucket. To avoid ”false deletion”, the entry of the element is not cleared.
    With this insight, false positive nature of the filter is unchanged after deletion.
    This process takes <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> time complexity.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：要删除一个项目，首先按照查找查询的相同过程查找要删除的元素。如果没有匹配，删除不可能进行，否则如果有匹配，只需从桶中删除该指纹的副本。为了避免“错误删除”，元素的条目不会被清除。有了这个洞察力，删除后过滤器的假阳性性质保持不变。这个过程的时间复杂度为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>。
- en: However, unlike cuckoo hashing rather than storing original value, only fingerprints
    are stored in filter. Each element is stored in a *f* bit fingerprint. The space
    consumed by cuckoo filter is given by Eq. 10.15 where, *ϵ* specifies FPR, *α*
    is the maximum capacity of filter and *B* is the number of entries per bucket.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与布谷鸟哈希不同的是，过滤器中仅存储指纹而不是原始值。每个元素都存储在一个*f*位的指纹中。布谷鸟过滤器消耗的空间由等式10.15给出，其中，*ϵ*指定了FPR，*α*是过滤器的最大容量，*B*是每个桶的条目数。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mfrac><mn>1</mn><mi mathvariant="normal">ϵ</mi></mfrac><mo
    stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>2</mn><mi>B</mi><mo stretchy="false">)</mo></mrow><mi>α</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(10.15)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mfrac><mn>1</mn><mi mathvariant="normal">ϵ</mi></mfrac><mo
    stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mn>2</mn><mi>B</mi><mo stretchy="false">)</mo></mrow><mi>α</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>（10.15）
- en: '[10.2.3.9 Hierarchical BF](contents.xhtml#rsec10_2_3_9)'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.9 分层BF](contents.xhtml#rsec10_2_3_9)'
- en: In network terms, attribution is defined as a process of finding source and
    destination of some traffic. However, sometimes this process is difficult due
    to lack of logging mechanism for example, attacker may spoof address by using
    a zombie machine. Hierarchical BF facilitates the process of payload attribution
    where with a given payload, aim is to identify the sender or receiver of the given
    payload. This could be beneficial to detect certain security attacks, such as
    DDoS, spoofing. Shanmugasundarm et al. [[168](bib.xhtml#ch00-bib-168)] basically
    extended BF in order to support substring matching. As an advantage, this algorithm
    even does not require full packet for attribution, only a significant portion
    is enough. Along with this, the algorithm requires low storage requirements and
    also it ensures the privacy of data by simply storing hashes of payload rather
    than actual payloads.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络术语中，归因被定义为查找某些流量的源和目的地的过程。然而，有时这个过程很困难，因为缺乏日志记录机制，例如，攻击者可能使用僵尸机器欺骗地址。分层BF促进了有效负载归因过程，其中给定有效负载，目标是识别给定有效负载的发送者或接收者。这对于检测某些安全攻击，如DDoS、欺骗，可能是有益的。Shanmugasundarm等人[[168](bib.xhtml#ch00-bib-168)]基本上扩展了BF以支持子字符串匹配。作为一个优势，这个算法甚至不需要完整的数据包来进行归因，只需要一个重要的部分就足够了。除此之外，该算法需要较低的存储要求，并且通过仅存储有效负载的哈希而不是实际有效负载来确保数据的隐私。
- en: Here, payload of each packet of length *p* is first divided into set of *q*
    multiple blocks of size *s*. Each block is appended with its offset value. Next,
    each block with its offset value is hashed and inserted into standard BF. This
    data structure is named as block based BF with offset as shown in [Fig. 10.21](13chap_10.xhtml#fig10_21).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，长度为*p*的每个数据包的有效负载首先被分成大小为*s*的*q*个多个块的集合。每个块都附带其偏移值。接下来，对每个带有其偏移值的块进行哈希处理，并插入标准BF。这种数据结构被称为带偏移的基于块的BF，如[图10.21](13chap_10.xhtml#fig10_21)所示。
- en: '![Figure 10.21](../images/fig10_21.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21](../images/fig10_21.jpg)'
- en: '**FIGURE 10.21.**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.21.**'
- en: Hierarchical BF.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 分层BF。
- en: '[10.2.3.10 Stochastic Fair Blue](contents.xhtml#rsec10_2_3_10)'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.2.3.10 随机公平蓝色](contents.xhtml#rsec10_2_3_10)'
- en: Although authors do not define this data structure as a variant of BF but it
    has a lot in similar to working of BF. Stochastic Fair Blue (SFB) [[81](bib.xhtml#ch00-bib-81)]
    is a technique that uses counting BF along with blue algorithm. The authors proposed
    this scheme in order to solve TCP's congestion control problem. It detects heavy
    hitters to enhance the forwarding speed of multicast packets. SFB uses *N*k* bins,
    where *k* is the number of levels with each having *N* bins along with *k* hash
    functions. Also, each bin associates a dropping/marking probability <math alttext=""
    display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>. For each
    incoming packet, apply *k* hash functions to its connection ID (source-destination
    address pair, source-destination port pair, and protocol) and increments corresponding
    bin locations. If account of packets hashed to a bin goes above the maximum size
    of bin, then increment <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>
    with a value <math alttext="" display="inline"><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow></math>
    for the bin; otherwise decrement by a value <math alttext="" display="inline"><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow></math>
    in case the link is idle. A packet is placed in heavy hitter list if the value
    of <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>
    reaches to 1\. In order to reduce FPR, authors have used the idea of conservative
    update. For a packet, extract <math alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>
    among corresponding *k* hash locations. Now, a packet is marked as heavy hitter
    if <math alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow></math>
    and is then dropped. So, with BF heavy hitters can easily be detected with less
    space and less number of operation for each packet.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管作者并未将此数据结构定义为BF的变体，但它与BF的工作方式非常相似。随机公平蓝（SFB）[[81](bib.xhtml#ch00-bib-81)]是一种利用计数BF以及蓝色算法的技术。作者提出了这个方案，以解决TCP的拥塞控制问题。它检测重要流量以提高组播数据包的转发速度。SFB使用*N*k*个存储桶，其中*k*是级别数量，每个级别都有*N*个存储桶，以及*k*个哈希函数。此外，每个存储桶都关联一个丢弃/标记概率<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>。对于每个传入的数据包，将其连接ID（源-目的地地址对、源-目的地端口对和协议）应用*k*个哈希函数，并增加相应的桶位置。如果哈希到一个桶的数据包计数超过了桶的最大大小，那么增加<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>的值，其值为<math
    alttext="" display="inline"><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow></math>；否则，在链接空闲时，将其值减小<math
    alttext="" display="inline"><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow></math>。如果<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>的值达到1，则将数据包放入重要流量列表中。为了降低FPR，作者使用了保守更新的思想。对于一个数据包，在对应的*k*个哈希位置中提取<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>。现在，如果<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>的值等于1，则将数据包标记为重要流量，然后将其丢弃。因此，使用BF可以轻松检测到重要流量，而且每个数据包的空间和操作次数都较少。
- en: '[Fig. 10.22](13chap_10.xhtml#fig10_22) represents an example of stochastic
    fair blue. As shown, packet <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>x</mi></msub></mrow></math>
    higher up <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>
    of all bins it is mapped into. However, packet <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>y</mi></msub></mrow></math>
    may map in the same bin as heavy hitter flow in a level but in other levels, it
    maps into normal bin. As <math alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>
    for packet <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>y</mi></msub></mrow></math>
    is <math alttext="" display="inline"><mrow><mn>0.2</mn><mtext>\textless</mtext><mn>1</mn></mrow></math>,
    it is identified as normal flow whereas <math alttext="" display="inline"><mrow><msub><mi>p</mi><mi>x</mi></msub></mrow></math>
    is marked as heavy hitter.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.22](13chap_10.xhtml#fig10_22) 展示了随机公平蓝色的一个示例。如图所示，数据包<math alttext=""
    display="inline"><mrow><msub><mi>p</mi><mi>x</mi></msub></mrow></math>被映射到了所有箱子中的较高位置。<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow></math>。然而，数据包<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>y</mi></msub></mrow></math>可能在同一级别的同一个箱子中与重要的流相同，但在其他级别中，它将映射到普通箱子中。由于数据包<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>y</mi></msub></mrow></math>的<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>为<math
    alttext="" display="inline"><mrow><mn>0.2</mn><mtext>\textless</mtext><mn>1</mn></mrow></math>，因此被识别为普通流，而<math
    alttext="" display="inline"><mrow><msub><mi>p</mi><mi>x</mi></msub></mrow></math>被标记为重要流。'
- en: '![Figure 10.22](../images/fig10_22.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22](../images/fig10_22.jpg)'
- en: '**FIGURE 10.22.**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.22.**'
- en: Stochastic fair blue example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 随机公平蓝色的示例。
- en: '[10.3 Quotient Filter](contents.xhtml#rsec10_3)'
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[10.3 商数过滤器](contents.xhtml#rsec10_3)'
- en: After BF, Quotient Filter (QF) [[40](bib.xhtml#ch00-bib-40)] is popular among
    programmers for checking approximate membership queries (AMQ), i.e., it also checks
    whether an element belongs to a set or not. QF is a cache friendly scheme based
    on quotienting technique [[120](bib.xhtml#ch00-bib-120)] that even provides scalability
    outside the main memory. Similar to BF, the membership query result answers ”probably
    in the set” or ”definitely not in the set” as QF also generates false positive
    errors. Increasing filter size can significantly reduce error probability of query
    whereas inserting more elements into the set can increase the false positive rates.
    However, no false negatives are generated for any query results. A typical use
    case of AMQ QF is in database tables stored on disk. Any access to the database
    stored on disk will first check QF for the particular key. If the filter returns
    positive results, the disk will be accessed otherwise not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: BF后，商数过滤器（QF）[[40](bib.xhtml#ch00-bib-40)]在程序员中流行，用于检查近似成员查询（AMQ），即它还检查元素是否属于集合。
    QF是一种基于商数技术的缓存友好型方案[[120](bib.xhtml#ch00-bib-120)]，甚至在主存储器之外提供可扩展性。与BF类似，成员查询结果回答“可能在集合中”或“绝对不在集合中”，因为QF也会产生误报错误。增加过滤器大小可以显著降低查询的错误概率，而将更多元素插入集合中则可能增加误报率。但是，对于任何查询结果都不会生成假阴性。AMQ
    QF的典型用例是存储在磁盘上的数据库表。对存储在磁盘上的数据库的任何访问都将首先检查QF以获取特定键。如果过滤器返回积极结果，则访问磁盘，否则不访问。
- en: BF only provides beneficial when it is stored in the main memory. When BF size
    gets too large its performance significantly reduces. Another option is to store
    BF on disk but this approach requires too many random access to the disk because
    of the usage of multiple hash functions. Also, this approach will perform multiple
    input output operations. Moreover, in-memory buffering technique fails in providing
    scalability if BF size is much larger than in-memory buffer size. QF on the other
    hand, stores elements data really close to each other so as to avoid multiple
    random access. With this insight, QF uses a single hash function and provides
    ways to tackle high collision probability. However, the size consumed by QF is
    20% larger than BF.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当BF存储在主内存中时，才提供有益。当BF大小过大时，其性能显著降低。另一个选择是将BF存储在磁盘上，但是由于使用了多个哈希函数，此方法需要太多随机访问磁盘。此外，此方法将执行多个输入输出操作。此外，如果BF大小远大于内存缓冲区大小，则内存缓冲技术无法提供可扩展性。另一方面，QF将元素数据存储得非常接近，以避免多个随机访问。借此洞察力，QF使用单个哈希函数并提供了解决高碰撞概率的方法。然而，QF占用的空间比BF大20%。
- en: 'The QF is quite fascinated by the concept of hash tables where instead of storing
    actual elements, hashes of the element along with some meta data bits are stored.
    The additional meta data bits are used to handle collisions. Insertion, lookup,
    deletion, merging, resizing are the operations supported by QF. To perform QF
    operations, first pass the element *x* through a single hash function that in
    return generates *p* bit fingerprint. The fingerprint is further partitioned into
    two parts: remainder part which has *r* least significant bits and quotient part
    which has *q* most significant bits. The employed hash tables have a total of
    <math alttext="" display="inline"><mrow><msup><mn>2</mn><mi>q</mi></msup></mrow></math>
    slots and the remainder part for any element is stored in location indexed by
    the quotient. Hard collision happens if different valued elements hash similar
    fingerprint whereas soft collision happens if two different value fingerprints
    have same quotient but different remainder.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: QF对哈希表的概念非常着迷，其中不仅存储实际元素，而且存储元素的哈希值以及一些元数据位。额外的元数据位用于处理碰撞。QF支持插入、查找、删除、合并、调整大小等操作。要执行QF操作，首先将元素*x*通过单个哈希函数传递，该函数将生成*p*位指纹。指纹进一步分为两部分：余数部分，其中包含*r*个最低有效位，以及商部分，其中包含*q*个最高有效位。采用的哈希表总共有2^q个槽，而任何元素的余数部分都存储在由商索引的位置。如果不同值的元素散列出相似的指纹，则会发生硬碰撞，而如果两个不同值的指纹具有相同的商但不同的余数，则会发生软碰撞。
- en: 'Suppose a element *k* generate fingerprint *kf*, and after partition lets its
    remainder be *KR* and its quotient be *KQ*. If *KR* is stored exactly at slot
    *KQ*, the slot is termed as canonical slot. For a soft collision, *KR* is stored
    at next available slot to the right of location *KQ* in sorted order. Insertion
    algorithm makes sure that all fingerprints with same quotient bits are stored
    contagiously and such a set forms a run. It may also be possible that runs first
    fingerprint may not get stored in its canonical slot as it may get shifted with
    already stored remainder of some different quotient. A run having its first fingerprint
    stored in canonical slot refers to the start of the cluster. A cluster may comprise
    more than one run which ends at an empty slot or start of some other cluster.
    Along with elements fingerprint, three additional bits are stored in the slot
    as shown in [Fig. 10.23](13chap_10.xhtml#fig10_23). These bits are explained as
    follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 假设元素*k*生成指纹*kf*，并在分区后让其余数为*KR*，商为*KQ*。如果*KR*正好存储在槽*KQ*中，那么该槽被称为规范槽。对于软碰撞，*KR*存储在排序顺序中*KQ*右侧的下一个可用槽。插入算法确保所有具有相同商位的指纹都以连续方式存储，并形成一组运行。还可能出现一种情况，即运行的第一个指纹可能不会存储在其规范槽中，因为它可能会与已存储的某个不同商的余数位相移。具有其第一个指纹存储在规范槽中的运行指的是簇的开始。一个簇可能包含多个结束于空槽或其他簇的开始的运行。除了元素的指纹外，槽中还存储了三个额外位，如[图10.23](13chap_10.xhtml#fig10_23)所示。这些位的功能如下所述：
- en: '*is_occupied*: If this bit is set, it implies that this slot is the canonical
    slot for some inserted element in the filter. It may be possible that the key
    is not stored in its canonical slot but stored somewhere else in the filter.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*is_occupied*：如果设置了此位，则意味着此槽位是过滤器中某个插入元素的规范槽位。可能的情况是，键不存储在其规范槽位中，而是存储在过滤器的其他位置。'
- en: '*is_continuation*: If this bit is set, it implies that slot is occupied with
    some remainder but definitively not the first remainder of the run.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*is_continuation*：如果设置了此位，则意味着槽位被某个余数占用，但绝对不是运行的第一个余数。'
- en: '*is_shifted*: If this bit is set, it implies that slot is holding a remainder
    that is not in its canonical slot.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*is_shifted*：如果设置了此位，则意味着槽位保存的是不在其规范槽位中的余数。'
- en: 'However, with metadata bits, QF consumes 20% more space than BF (but less than
    counting BF) for the same data size. Also, throughput of lookup operation slows
    down 3 times. The only way false positive can happen is when there is a hard collision
    and its probability is given as: <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo>−</mo><mi>α</mi></mrow><mrow><msup><mn>2</mn><mi>r</mi></msup></mrow></mfrac></mrow></msup></mrow></math>,
    where *α* is load factor defined as the fraction of total elements and number
    of slots. When a new element is inserted, its slot is marked occupied and additional
    bits are updated accordingly. The significance of different combination of additional
    bits are specified in [Table 10.4](#tab10_4). Operations of QF are discussed as
    follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，带有元数据位的 QF 比 BF（但少于计数 BF）消耗的空间多 20%，用于相同数据大小。此外，查找操作的吞吐量减慢 3 倍。唯一可能发生误报的情况是发生硬碰撞时，其概率如下所示：<math
    alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mfrac><mrow><mo>−</mo><mi>α</mi></mrow><mrow><msup><mn>2</mn><mi>r</mi></msup></mrow></mfrac></mrow></msup></mrow></math>，其中
    *α* 被定义为总元素和槽位数的比例。插入新元素时，其槽位被标记为占用，并相应地更新其他位。不同附加位组合的重要性在 [Table 10.4](#tab10_4)
    中指定。QF 的操作如下所述：
- en: '![Figure 10.23](../images/fig10_23.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.23](../images/fig10_23.jpg)'
- en: '**FIGURE 10.23.**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.23.**'
- en: Structure of QF.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: QF 的结构。
- en: '**TABLE 10.4**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10.4**'
- en: Significance of possible combination of metadata bits.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的元数据位组合的重要性。
- en: '| 1 | 2 | 3 | Interpretation |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 3 | 解释 |'
- en: '| 0 | 0 | 0 | This Slot is empty |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 此槽位为空 |'
- en: '| 0 | 0 | 1 | This is start of run and remainder has been shifted from its
    canonical slot. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 这是一次运行的开始，并且余数已经从其规范槽位中移出。'
- en: '| 0 | 1 | 0 | This combination is not used. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 此组合未被使用。'
- en: '| 0 | 1 | 1 | This remainder is not first remainder in a run and also it has
    been shifted from its canonical slot |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 此余数不是运行中的第一个余数，并且它已经从其规范槽位中移出。'
- en: '| 1 | 0 | 0 | This is first remainder in run that too in canonical slot. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 这是运行中的第一个余数，也在规范槽位中。'
- en: '| 1 | 0 | 1 | This is holding first remainder in run that has been shifted
    from its canonical slot. In addition, the run meant for this slot exists that
    has been shifted right. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 这是持有已从其规范槽位移出的第一个余数的连续序列。此外，意为此槽位的连续序列已向右移动。 |'
- en: '| 1 | 1 | 0 | This combination is not used |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 此组合未被使用 |'
- en: '| 1 | 1 | 1 | This remainder is not first remainder in a run that has been
    shifted from its canonical slot. In addition, the run meant for this slot exists
    that has been shifted right. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 此余数不是已从其规范槽位移出的连续序列中的第一个余数。此外，意为此槽位的连续序列已向右移动。 |'
- en: '1: is_occupied, 2: is_continuation, 3: is_shifted'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 1：is_occupied，2：is_continuation，3：is_shifted
- en: '**Lookup**: To query any element *k* follow the following steps.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找**：要查询任何元素*k*，请按照以下步骤进行。'
- en: Hash the key to generate its fingerprint *kH*.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对键进行哈希处理以生成其指纹*kH*。
- en: Next, partition *kH* into quotient *kQ* and remainder *kR*. Clearly, canonical
    slot for element *k* is *kQ*. If canonical slot has all metadata bits as false,
    it implies slot is not occupied. Hence, the element is definitively not present
    in the set.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将*kH*分为商*kQ*和余数*kR*。很明显，元素*k*的规范槽位是*kQ*。如果规范槽位的所有元数据位都为false，则意味着槽位未被占用。因此，元素明确不存在于集合中。
- en: 'If *kQ* is occupied, then locate the run for *k*. As it is previously mentioned,
    remainder with same quotient are stored contagiously and it forms a run. The first
    in a run might not be present in canonical slot, if entire run has been shifted
    right by some another run in left. So, to locate quotient run, first locate start
    of the cluster and then find number of run to skip in a cluster to reach run for
    *kR*. For this:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*kQ*被占用，则定位*k*的连续序列。正如前面提到的，具有相同商的余数被连续存储，它形成一个连续序列。连续序列中的第一个元素可能不在规范槽位上，如果整个连续序列已被左侧的另一个连续序列向右移动。因此，要定位商序列，首先要定位集群的起始位置，然后找到在集群中跳过的连续序列的数量以达到*kR*的连续序列。为此：
- en: Scan left for locating start of the cluster. If *is_shifted* for slots to the
    left of *kQ* is false, it implies start of the cluster.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左扫描以定位集群的起始位置。如果*kQ*左侧的槽位的*is_shifted*为false，则意味着集群的起始位置。
- en: Scan right to keep track of running count that counts number of runs to skip
    in order to reach quotient run. The slots to the left of *kQ* with *is_occupied*
    set implies another run to be skipped. For each value of *is_occupied* as 1, increment
    the running count and decrement one if *is_continuation* is clear (implies start
    of another run) until running count reaches zero. When the value of running count
    becomes zero it implies that quotient run has been reached.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右扫描以跟踪一个计数器，该计数器计算要跳过的连续序列的数量以达到商序列。设置为1的*kQ*左侧的槽位意味着另一个要跳过的连续序列。对于*is_occupied*的每个值为1的情况，增加计数器的值，并在*is_continuation*清除时减去1（意味着另一个连续序列的开始），直到计数器的值达到零。当计数器的值变为零时，意味着商序列已经达到。
- en: Next, remainder corresponding to the run with *kR* is compared. If matches,
    the element *k* is probably present in the set otherwise definitely not in the
    filter.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将与 *kR* 运行对应的余数进行比较。如果匹配，则元素 *k* 可能存在于集合中，否则肯定不在过滤器中。
- en: '**Insertion:**'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**插入：**'
- en: Pass the element *k* to be inserted through the hash function to compute its
    fingerprint. First, ensure that the key is not already inserted in filter by using
    lookup procedure described above. If not inserted already, then follow the next
    step.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要插入的元素 *k* 通过哈希函数传递以计算其指纹。首先，通过上述描述的查找过程确保密钥尚未插入到过滤器中。如果尚未插入，则按照下一步操作。
- en: When the elements are inserted in a run, it is always done in sorted order.
    The element remainder may have to shift right in any slot even when they belong
    to same run and update the metadata bits accordingly. However, this shifting does
    not change the value of *is_occupied* bit.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素按运行顺序插入时，始终以排序顺序进行。即使它们属于同一运行，元素余数可能必须在任何槽中向右移动，并相应地更新元数据位。但是，此移位不会更改 *is_occupied*
    位的值。
- en: If a remainder is inserted at the starting of already existing run, this causes
    any previous remainder to be shifted to next available slot in right and in response
    set its *is_continuation* bit. The *is_shifted* also has to be reset in case remainder
    is shifted.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在已存在的运行的开头插入了余数，则会导致任何先前的余数向右移动到下一个可用的槽，并响应地设置其 *is_continuation* 位。如果移动了余数，则还必须重置
    *is_shifted*。
- en: For understanding QF, consider an example with quotient size 4 and remainder
    size 28\. Let the employed hash function generates a hash of 32 bit. First, element
    *144, 133, 4033* are added into QF as represented in [Fig. 10.24](13chap_10.xhtml#fig10_24)
    (a). Insertion for all 3 elements is done in canonical slot as these slots are
    not occupied.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 QF，请考虑一个商大小为 4 且余数大小为 28 的示例。让雇用的哈希函数生成 32 位哈希。首先，将元素 *144, 133, 4033* 加入到
    QF 中，如 [图 10.24](13chap_10.xhtml#fig10_24) (a) 所示。所有 3 个元素的插入都在规范槽中进行，因为这些槽未被占用。
- en: '![Figure 10.24](../images/fig10_24.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24](../images/fig10_24.jpg)'
- en: '**FIGURE 10.24.**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.24.**'
- en: Insertion of elements in QF.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QF 中插入元素。
- en: Next, element 9999 is added. The canonical slot for this element is already
    occupied. It is observed that *is_shift* and *is_continuation* bit is not set
    which implies it is beginning of cluster and also runs start. The remainder for
    element 999 is greater than that of element 144, so it should be stored to the
    right of element 144, i.e., slot 2 and set its *is_shifted* and *is_continuation*
    bit. The change in QF after insertion of element 9999 is reflected in [Fig. 10.24](13chap_10.xhtml#fig10_24)
    (b).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加元素 9999。该元素的规范槽已被占用。观察到 *is_shift* 和 *is_continuation* 位未设置，这意味着它是集群的开头并且运行已开始。元素
    999 的余数大于元素 144 的余数，因此应将其存储在元素 144 的右侧，即槽 2，并设置其 *is_shifted* 和 *is_continuation*
    位。在插入元素 9999 后，QF 的变化反映在 [图 10.24](13chap_10.xhtml#fig10_24) (b) 中。
- en: Next, element 14023 is to be added. Since slot 2 is already in use but its *is_occupied*
    bit is 0\. So, element 14023 has to be stored to next available slot to the right,
    i.e., slot 3 and set *is_shifted* bit for slot 3\. Also, set *is_occupied* bit
    for slot 2 as it is a canonical slot for element 14023\. The state of QF after
    insertion of element 14023 is represented in [Fig. 10.24](13chap_10.xhtml#fig10_24)
    (c).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要添加元素14023。由于槽2已在使用中，但其*is_occupied*位为0。因此，元素14023必须存储到右侧的下一个可用槽，即槽3，并为槽3设置*is_shifted*位。同时，为元素14023的规范槽2设置*is_occupied*位。插入元素14023后QF的状态如[图10.24](13chap_10.xhtml#fig10_24)（c）所示。
- en: Finally, element 55 is added into QF which after passing through hash function
    generates 0*x*10000001\. Since the canonical slot 1 is not free. The *is_shifted*
    and *is_continuation* bit value for slot 1 is 0 which implies it is beginning
    of the cluster and also it is runs start. The remainder for element 55 is smaller
    than remainder of element 144\. So, the existing remainder in slot 1 should be
    shifted right to slot 2 and accordingly set the *is_continuation* and *is_shifted*
    bit. The state of the QF after insertion of element 55 is represented in [Fig.
    10.24](13chap_10.xhtml#fig10_24) (d).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将元素55添加到QF中，经过哈希函数生成0*x*10000001。由于规范槽1不空闲。槽1的*is_shifted*和*is_continuation*位值为0，这意味着它是集群的起始，也是运行的开始。元素55的余数比元素144的余数小。因此，槽1中的现有余数应向右移动到槽2，并相应地设置*is_continuation*和*is_shifted*位。插入元素55后QF的状态如[图10.24](13chap_10.xhtml#fig10_24)（d）所示。
- en: Now, consider lookup query for element 4045\. Say *f(4045)* = 733433CD. As the
    canonical slot 7 is occupied. The value of *is_occupied*, *is_continuation* and
    *is_shifted* infers that it is start of the cluster as well as start of run. See
    [Fig. 10.24](13chap_10.xhtml#fig10_24) (d). The next slot to the right, i.e.,
    8 is empty which infers that slot 7 itself is a start and end of a run. Next,
    the remainder for element 4045 is compared with existing remainder in slot 7\.
    As the match for two values failed, so the element is definitely not present.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑查找元素4045的查询。假设*f(4045)* = 733433CD。由于规范槽7已被占用。*is_occupied*、*is_continuation*和*is_shifted*的值表明它既是集群的开始，也是运行的开始。参见[图10.24](13chap_10.xhtml#fig10_24)（d）。右侧的下一个槽，即8是空的，这表明槽7本身是运行的起始和结束。接下来，将元素4045的余数与槽7中的现有余数进行比较。由于两个值不匹配，因此该元素肯定不在其中。
- en: Next, consider the case for querying 133 whose fingerprint value is 48921258\.
    It can be observed that slot 4 is already occupied. Also, the value of its *is_shifted*
    bit is 1 which implies that the element corresponding to the current remainder
    has been stored in its canonical slot and is shifted. The value 1 for *is_canonical*
    slot represents that run for which this slot is a canonical slot exists but has
    been shifted to the right. For locating start of the cluster, scan left from slot
    4 and look for *is_shifted* as false, which is found to be slot 1\. So, slot 1
    indicates start of the cluster. Next, locate quotient run, for this scan to the
    left from slot 4 and check for *is_occupied*. If the value of *is_occupied* bit
    is 1 it implies another run to be skipped. There are 3 such slots, i.e., 1, 2
    and 4 which indicate that run for element 4033 is third run in the cluster. The
    start of current run and end of previous run is detected by *is_continuation*
    bit being false. The first run is at index 1, second at index 4, and third is
    at index 5\. Hence, index 5 is the quotient run for element 4033\. Now, compare
    the remainder stored in quotient run that starts at index 5 with the remainder
    of the element in question. However, there is only one slot in that run. So, compare
    the remainder of the element 4033 with existing remainder at slot 5\. As there
    is a match, so it is concluded that element 4033 is probably in the set.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑查询 133 的情况，其指纹值为 48921258\. 可以观察到槽 4 已经被占用。同时，其 *is_shifted* 位的值为 1，这意味着对应当前余数的元素已存储在其规范槽中并且已被移动。*is_canonical*
    位的值为 1 表示存在此槽的规范槽但已被向右移动的运行。为了找到簇的起始位置，从槽 4 开始向左扫描，并寻找 *is_shifted* 为 false 的槽，发现是槽
    1\. 因此，槽 1 表示簇的起始位置。接下来，定位商的运行，从槽 4 开始向左扫描并检查 *is_occupied*。如果 *is_occupied* 位的值为
    1，则意味着还有另一个运行需要跳过。有 3 个这样的槽，即 1、2 和 4，这表示元素 4033 的第三个运行在簇中。通过 *is_continuation*
    位的值为 false 检测当前运行的起始和前一个运行的结束。第一个运行位于索引 1，第二个位于索引 4，第三个位于索引 5\. 因此，索引 5 是元素 4033
    的商运行起始位置。现在，将索引 5 处商运行中存储的余数与问题中的元素的余数进行比较。然而，在该运行中只有一个槽。因此，将元素 4033 的余数与槽 5 处的现有余数进行比较。由于匹配，因此得出结论，元素
    4033 可能在集合中。
- en: '**Algorithm 1** Quotienting technique'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 1** 商技术'
- en: '**Input:** Fingerprint f'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入：** 指纹 f'
- en: '**Output:** Quotient f[q] and remainder f[r]'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：** 商 f[q] 和余数 f[r]'
- en: '1: f[r]←f mod 2^r'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '1: f[r]←f mod 2^r'
- en: '2: **2:** return f[q], f[r]'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '2: **2:** 返回 f[q]，f[r]'
- en: '**Algorithm 2** To find the run'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 2** 查找运行'
- en: '**Input:** Canonical bucket index f[q]'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入：** 规范桶索引 f[q]'
- en: '1: i ← f[q]'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '1: i ← f[q]'
- en: '2: **while** QF[i].is_shifted=1 **do**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '2: **当** QF[i].is_shifted=1 **时**'
- en: 3:i←i−1
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 3:i←i−1
- en: '4: **end while**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '4: **结束当**'
- en: '5: run[start]← i'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '5: run[start]← i'
- en: '6: **while** i≠f[q] **do**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '6: **当** i≠f[q] **时**'
- en: 7:**repeat**
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 7:**重复**
- en: 8:run[start]← runstart+1
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 8:run[start]← runstart+1
- en: 9:**until** QF[run[start]].is_continuation ≠1
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 9:**直到** QF[run[start]].is_continuation ≠1
- en: 10:**repeat**
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 10:**重复**
- en: 11:i←i+1
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 11:i←i+1
- en: 12:**until** QF[i].is_occupied=1
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 12:**直到** QF[i].is_occupied=1
- en: '13: **end while**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '13: **结束当**'
- en: '14: run[end]←run[start]'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '14: run[end]←run[start]'
- en: '15: **repeat**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '15: **重复**'
- en: 16:run[end]← run[end]+1
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 16:run[end]← run[end]+1
- en: '17: **until** QF[runend].is_continuation ≠1'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '17: **直到** QF[runend].is_continuation ≠1'
- en: '18: **Return** run[start], run[end]'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '18: **返回** run[start], run[end]'
- en: '**Algorithm 3** To test element in QF'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 3** 测试 QF 中的元素'
- en: '**Input**: Element *x*, hash function *h*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**: 元素 *x*, 哈希函数 *h*'
- en: '**Output: True for positive and false for negative result**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**: 正面为真，负面为假'
- en: '1: f←h(x) f[q], f[r]←f'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '1: f←h(x) f[q], f[r]←f'
- en: '2: **if** QF[fq.is_occupied≠1 ] **then**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '2: **如果** QF[fq.is_occupied≠1 ] **那么**'
- en: 3:return False
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 3:返回 假
- en: '4: **else**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '4: **否则**'
- en: 5:run[start], run[end]← **Find(f[q])**
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '5:run[start], run[end]← **查找(f[q])** '
- en: 6:**for** i← run[start] to runend **do**
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 6:**对于** i← run[start] 到 runend **执行**
- en: 7:**if** QF[i] =f[r] **then**
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 7:**如果** QF[i] =f[r] **那么**
- en: 8:return True
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 8:返回 真
- en: 9:**end if**
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 9:**结束如果**
- en: 10:**end for**
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 10:**结束循环**
- en: 11:Return False
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 11:返回 假
- en: '12: **end if**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '12: **结束如果**'
- en: '[10.4 Skip List](contents.xhtml#rsec10_4)'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[10.4 跳跃表](contents.xhtml#rsec10_4)'
- en: 'Skip list follows a linked list alike structure. However, the worst case time
    complexity for a search operation in linked list in <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> as
    the list is linearly traversed while searching whereas for a skip list it is <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>. For a set *S* of unique elements, skip
    list is defined as sequence of linked list *S0*, *S1*, *S2*, …….., *Sh*. The lower
    list (base list) has height 0 and this list is supposed to contain all elements
    of set *S* in non-decreasing order. Also, each list *Sl <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>l</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>......</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>* contains special items <math alttext=""
    display="inline"><mrow><mo>−</mo><mi>∞</mi></mrow></math> and <math alttext=""
    display="inline"><mrow><mo>+</mo><mi>∞</mi></mrow></math>. Each successive linked
    list in a series accommodate subset of elements from immediate previous list and
    the way subset of elements is chosen defines the type of linked list i.e., deterministic
    or probabilistic. Any element is inserted into new layer from immediate previous
    layer with a probability *p*. For probabilistic (or randomized) skip list, random
    coin flips are used to construct each higher level of elements whereas in deterministic
    (or perfect) skip list each higher level consists of <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>
    of elements from immediate lower list. In probabilistic skiplist, each element
    is added to the next level with probability of <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>.
    As this chapter is all about PDS, so for the sake of brevity the main focus is
    on probabilistic type skip list. Unlike other data structures, skip list does
    not use hashing still, it is considered as probabilistic data structure as it
    is based on concept of probability to construct subsequent layer above original
    layer of skip list. The name of data structure skip list is defended as higher
    level skips some elements from lower list. The operations of skip list are defined
    as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Skip list 采用类似链表的结构。然而，链表中搜索操作的最坏时间复杂度为 <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>，因为在搜索时列表是线性遍历的，而在
    skip list 中，时间复杂度为 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。对于一组唯一元素 *S*，skip list 被定义为链表序列 *S0*、*S1*、*S2*，……，*Sh*。较低的列表（基本列表）高度为
    0，假定该列表按非递减顺序包含集合 *S* 的所有元素。此外，每个列表 *Sl <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>l</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>......</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>* 包含特殊项目 <math alttext="" display="inline"><mrow><mo>−</mo><mi>∞</mi></mrow></math>
    和 <math alttext="" display="inline"><mrow><mo>+</mo><mi>∞</mi></mrow></math>。系列中的每个连续链表容纳来自上一个列表的子集，选择子集的方式定义了链表的类型，即确定性或概率性。任何元素都以概率
    *p* 插入到新层中，其中 *p* 是 <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>。对于概率性（或随机）skip
    list，使用随机硬币翻转来构造每个更高级别的元素，而在确定性（或完美）skip list 中，每个更高级别由来自即时下一个列表的 <math alttext=""
    display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math> 元素组成。在概率性跳表中，每个元素被添加到下一个级别的概率为
    <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math>。由于本章主要讨论
    PDS，为简洁起见，重点放在概率性跳表上。与其他数据结构不同，跳表不使用哈希，但仍被视为概率性数据结构，因为它基于概率概念构建了跳表原始层上面的后续层。跳表数据结构的名称之所以被称为跳表，是因为更高级别跳过了较低列表中的一些元素。跳表的操作定义如下：
- en: 'Searching: To start searching an item *i*, start from top lists left most item,
    i.e., <math alttext="" display="inline"><mrow><mo>−</mo><mi>∞</mi></mrow></math>
    in every case. At any current position say *p*, compare item *i* to be searched
    with with the item to the immediate right of *p* and store that element in a new
    variable say *v*, i.e., <math alttext="" display="inline"><mrow><mi>v</mi><mo>←</mo><mo
    stretchy="false">(</mo><mi>E</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>p</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
    and follow:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索：要开始搜索项目*i*，从左侧最顶部列表的最左边项目开始，即在任何情况下都是<math alttext="" display="inline"><mrow><mo>−</mo><mi>∞</mi></mrow></math>。在任何当前位置（称为*p*），将要搜索的项目*i*与*p*的右侧紧邻项目进行比较，并将该元素存储在一个新变量中，称为*v*，即<math
    alttext="" display="inline"><mrow><mi>v</mi><mo>←</mo><mo stretchy="false">(</mo><mi>E</mi><mo
    stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>，然后执行以下操作：
- en: If <math alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mi>v</mi></mrow></math>,
    return *v*.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果<math alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mi>v</mi></mrow></math>，则返回*v*。
- en: Otherwise if ( <math alttext="" display="inline"><mrow><mi>i</mi><mtext>\textgreater</mtext><mi>v</mi></mrow></math>),
    then move a single step towards right and if <math alttext="" display="inline"><mrow><mi>i</mi><mtext>\textless</mtext><mi>v</mi></mrow></math>,
    move a single step down and compare it to its immediate rightmost item. Repeat
    the same process until there is no option to go down which concludes that item
    is not in list.
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果（<math alttext="" display="inline"><mrow><mi>i</mi><mtext>\textgreater</mtext><mi>v</mi></mrow></math>），则向右移动一步，如果<math
    alttext="" display="inline"><mrow><mi>i</mi><mtext>\textless</mtext><mi>v</mi></mrow></math>，则向下移动一步，并将其与其右侧最右边的项目进行比较。重复相同的过程，直到没有向下的选项，这表明项目不在列表中。
- en: The search procedure for element 80 is represented in [Fig. 10.25](13chap_10.xhtml#fig10_25).
    For *n* elements, the search time complexity for skip list is <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> as at each level, number of items are cut
    down to half.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示元素80的搜索过程在[图10.25](13chap_10.xhtml#fig10_25)中。对于*n*个元素，跳表的搜索时间复杂度为<math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>，因为在每个级别，项目数量都减半。
- en: '![Figure 10.25](../images/fig10_25.jpg)'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.25](../images/fig10_25.jpg)'
- en: '**FIGURE 10.25.**'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图10.25。**'
- en: Searching in skip list.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在跳表中进行搜索。
- en: 'Insertion: To insert an item follow the following steps:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：要插入一个项目，请按照以下步骤操作：
- en: First follow the search algorithm to locate the position of the element at the
    bottom level.
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先按照搜索算法找到底层元素的位置。
- en: Next, toss a biased coin more than one time till a tail is encountered. Observe
    the count of coin showing head before a tail is encountered. Store this number
    in a variable say *x*.
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，抛出一个偏向正面的硬币多次，直到遇到尾部。观察在遇到尾部之前出现正面的硬币的次数。将此数字存储在一个变量中，称为*x*。
- en: If the value of *x=0*, add the item only at the bottom level, i.e., <math alttext=""
    display="inline"><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow></math>. Otherwise
    if <math alttext="" display="inline"><mrow><mi>x</mi><mo>≥</mo><mi>h</mi></mrow></math>,
    add additional new levels <math alttext="" display="inline"><mrow><msub><mi>S</mi><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>S</mi><mrow><mi>h</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>,</mo><mn>...</mn><mo>,</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>
    at the top of level *Sh* that only contains two special keys, ı.e., - <math alttext=""
    display="inline"><mi>∞</mi></math>, + <math alttext="" display="inline"><mi>∞</mi></math>
    and element *i*.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x=0*的值，则仅在底层添加项目，即<math alttext="" display="inline"><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow></math>。
    否则，如果<math alttext="" display="inline"><mrow><mi>x</mi><mo>≥</mo><mi>h</mi></mrow></math>，则在顶层*Sh*的顶部添加额外的新级别<math
    alttext="" display="inline"><mrow><msub><mi>S</mi><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>S</mi><mrow><mi>h</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>,</mo><mn>...</mn><mo>,</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>，其中只包含两个特殊键，即，-
    <math alttext="" display="inline"><mi>∞</mi></math>，+ <math alttext="" display="inline"><mi>∞</mi></math>
    和元素*i*。
- en: For *n* elements, the time complexity for inserting an element is <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>. Insertion of element 85 with value of *x
    =1* is presented in [Fig. 10.26](13chap_10.xhtml#fig10_26).
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于*n*个元素，插入元素的时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。 具有*x=1*值的元素85的插入在[图10.26](13chap_10.xhtml#fig10_26)中表示。
- en: '![Figure 10.26](../images/fig10_26.jpg)'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.26](../images/fig10_26.jpg)'
- en: '**FIGURE 10.26.**'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图10.26.**'
- en: Insertion in skip list.
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在跳跃列表中插入。
- en: 'Deletion: To delete an item *i*, follow the following steps'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：要删除项目*i*，请按照以下步骤进行：
- en: First search for *i*, using search algorithm described above and locate the
    position *p0, p1,………, ph* for item *i*.
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先使用上述搜索算法搜索*i*，并找到元素*i*的位置*p0，p1，………，ph*。
- en: Remove the element from list at levels *S0, S1,………, Sh* corresponding to the
    positions *p0, p1,………, ph*.
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从级别*S0，S1，………，Sh*中的位置*p0，p1，………，ph*处的列表中移除元素。
- en: The time complexity for deletion operation is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    for *n* elements. The deletion for element 87 is represented in [Fig. 10.27](13chap_10.xhtml#fig10_27).
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除操作的时间复杂度为*n*个元素的<math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。 元素87的删除在[图10.27](13chap_10.xhtml#fig10_27)中表示。
- en: '![Figure 10.27](../images/fig10_27.jpg)'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.27](../images/fig10_27.jpg)'
- en: '**FIGURE 10.27.**'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图10.27.**'
- en: Deletion in skip list.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳跃列表中的删除。
- en: The skip list provides beneficial in case where data structures need to be accessed
    concurrently. For example, skip list is used in designing highly scalable concurrent
    priority queue for heavy scale microprocessors [[171](bib.xhtml#ch00-bib-171)].
    Similarly, skip list is used to implement lock free dictionaries for a shared
    object in pre-emptive and concurrent environments in large scale multi-processors
    [[181](bib.xhtml#ch00-bib-181)]. Skip list implement a non-blocking (lock-free)
    algorithm for shared object which ensures that regardless of contention, atleast
    one operation will be active.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据结构需要同时访问的情况下，跳表提供了很多好处。例如，跳表用于设计高度可伸缩的并发优先级队列，用于大规模微处理器 [[171](bib.xhtml#ch00-bib-171)]。同样，跳表用于在大规模多处理器的抢占式和并发环境中实现无锁字典，用于共享对象
    [[181](bib.xhtml#ch00-bib-181)]。跳表实现了一种非阻塞（无锁）算法，用于共享对象，确保无论有多少争用，至少都会有一个操作处于活动状态。
- en: '[10.4.1 Skiplist implementation in Python](contents.xhtml#rsec10_4_1)'
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[10.4.1 Python 中的 Skiplist 实现](contents.xhtml#rsec10_4_1)'
- en: First, we will define a skip list node where each node is inked by a list of
    pointers to immediate next node.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个跳表节点，其中每个节点都由指向直接下一个节点的指针列表链接。
- en: '![](../images/list10_5.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list10_5.jpg)'
- en: Next, we will define a skip list
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个跳表
- en: '![](../images/list10_6.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list10_6.jpg)'
- en: To perform search, insert and delete operation it is important to define a update
    function that will start searching from top most level and passes the list of
    any level till an element larger than element in question is found. Then, next
    level is explored and the process is repeated as discussed above.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行搜索、插入和删除操作，重要的是定义一个更新函数，该函数将从最顶层开始搜索，并将列表传递到任何级别，直到找到一个大于问题中的元素的元素。然后，探索下一个级别，重复上述过程。
- en: '![](../images/list10_7.jpg)![](../images/list10_8.jpg)![](../images/list10_9.jpg)![](../images/list10_10.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list10_7.jpg)![](../images/list10_8.jpg)![](../images/list10_9.jpg)![](../images/list10_10.jpg)'
- en: Activity
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: Which of the following does not fall in the category of membership query PDS?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不属于成员查询 PDS 的范畴？
- en: BF
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BF
- en: Min Hash
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小哈希
- en: QF
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: QF
- en: Skip list
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳表
- en: In standard bloom filter, what is the search complexity for *k* hash functions,
    *m* filter size and *n* total elements to be inserted ?
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标准布隆过滤器中，对于 *k* 个哈希函数、*m* 过滤器大小和 *n* 总插入元素，搜索复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: Which of the following bloom filter does not support false negative?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种布隆过滤器不支持假阴性？
- en: Counting BF
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF
- en: Spectral BF
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光谱 BF
- en: Deletable BF
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可删除的 BF
- en: None of the above
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Which of the following is an advantage of counting BF over standard BF?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF 相对于标准 BF 的优势是什么？
- en: Less space requirements
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空间需求更少
- en: Counting BF never support false positive
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF 从不支持假阳性
- en: Counting BF never support false negative
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF 从不支持假阴性
- en: Counting bloom filter support deletion
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数布隆过滤器支持删除
- en: Which of the following mentioned bloom filter does not support deletion?
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下提到的哪种布隆过滤器不支持删除？
- en: Counting BF
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF
- en: Deletable BF
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可删除的 BF
- en: Scalable BF
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可扩展的 BF
- en: Dynamic BF
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态 BF
- en: What is the time complexity for deletion operation in a skip list having *n*
    elements?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个包含 *n* 个元素的跳表中，删除操作的时间复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow></math>
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: Which among the following is not a meta-data bit for QF?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是 QF 的元数据位？
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>o</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>p</mi><mi>i</mi><mi>e</mi><mi>d</mi></mrow></math>
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>o</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>p</mi><mi>i</mi><mi>e</mi><mi>d</mi></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></math>
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>e</mi><mi>t</mi></mrow></math>
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>e</mi><mi>t</mi></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></math>
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></math>
- en: 'QF is preferred over BF because:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: QF 优于 BF，因为：
- en: QF consumes less space over BF
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: QF 比 BF 占用更少的空间
- en: QF is cache friendly whereas a BF is not
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: QF 是缓存友好的，而 BF 不是
- en: BF provides scalability outside main memory whereas QF does not
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BF 在主内存之外提供可扩展性，而 QF 不提供
- en: None of the above
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: 1\. b  2\. a  3\. c  4\. d  5\. c  6\. a  7\. c  8\. c
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. b  2\. a  3\. c  4\. d  5\. c  6\. a  7\. c  8\. c
- en: <hgroup>
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[11](contents.xhtml#rchapter11)'
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[11](contents.xhtml#rchapter11)'
- en: '[Cardinality Estimation Probabilistic Data Structures](contents.xhtml#rchapter11)'
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[基数估计概率数据结构](contents.xhtml#rchapter11)'
- en: </hgroup>
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[11.1 Introduction](contents.xhtml#rsec11_1)'
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[11.1 简介](contents.xhtml#rsec11_1)'
- en: The next category of PDS is for cardinality estimation that is popularly used
    in query processing and data base design. Database models uses algorithms of cardinality
    estimation to compute selectivity of a predicate. Linear counting, LogLog, HyperLogLog
    are some of the algorithms that falls under this category. The aim of such a PDS
    is to count number of unique elements of a set where duplicates are present. For
    instance, for a set <math alttext="" display="inline"><mrow><mi>S</mi><mo>=</mo><mo
    stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math> the cardinality os the set is 4\. An important
    use case for such PDS is to compute number of unique visitors for a particular
    website. As per data given by, from May 2019 to Sep 2019, the total visit on Amazon
    web page is 2.22 B. If we believe that every 10th visitor was unique, the cardinality
    of such case is 222 million. Notable, with linear space requirements, cardinality
    estimation is difficult to achieve for any of deterministic data strictures. To
    compute cardinality estimation, a simple way is to first arrange sets element
    in ascending order. Next, apply linear scan on set S to eliminate duplicates.
    If we use merge sort, the cardinality of set S having *n* elements can be computed
    in <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> disc access with <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> extra
    space and hence this approach is inefficient. Another way to compute cardinality
    is by using a hash table data structure where hashes of elements are stored in
    hash table and cardinality is computed by total number of keys in hash table.
    Obviously, hashing has advantage of removing duplicates without sorting and hence
    require a single scan. However, for huge data set, hashing proves bad as it is
    difficult to fit the large has table in main memory. The time complexity for this
    approach is <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> with <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> extra
    space. Hence, with the traditional deterministic approaches, the query processing
    on increasing volume of data can only be processed in linear memory space.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: PDS 的下一个类别是用于在查询处理和数据库设计中广泛使用的基数估计。数据库模型使用基数估计算法来计算谓词的选择性。线性计数、LogLog、HyperLogLog
    是此类别下的一些算法。这样的 PDS 的目标是计算集合中存在重复项的唯一元素的数量。例如，对于集合 <math alttext="" display="inline"><mrow><mi>S</mi><mo>=</mo><mo
    stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>，集合的基数是 4。这种 PDS 的一个重要用例是计算特定网站的独立访问者数量。根据提供的数据，从
    2019 年 5 月到 2019 年 9 月，Amazon 网页的总访问量为 22 亿。如果我们认为每 10 个访问者中有一个是独立的，则这种情况下的基数为
    2.22 亿。值得注意的是，使用线性空间要求，基数估计对于任何确定性数据结构都很难实现。计算基数估计的一个简单方法是首先将集合元素按升序排列。接下来，在集合
    S 上应用线性扫描以消除重复项。如果我们使用归并排序，集合 S 的基数，其中 *n* 个元素，可以在 <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    的磁盘访问中计算出来，需要 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> 的额外空间，因此这种方法效率低下。另一种计算基数的方法是使用哈希表数据结构，其中元素的哈希存储在哈希表中，并且通过哈希表中的键的总数来计算基数。显然，哈希具有删除重复项而无需排序的优点，因此只需要一次扫描。然而，对于大数据集，哈希法表现不佳，因为很难将大的哈希表适应主内存。这种方法的时间复杂度是
    <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>，需要 <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> 的额外空间。因此，对于传统的确定性方法，随着数据量的增加，查询处理只能在线性内存空间中进行。
- en: PDS using probabilistic techniques estimates cardinality with low space requirements
    and linear time. Cardinality estimation PDS are also based on hashing. However,
    different from simple hashing, these data structure doesn't store values of elements
    in the hash table. Cardinality estimation using PDS can be done regardless of
    type of data and it can also be distributed over parallel machines with less communication
    overhead.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用概率技术的PDS可以估计出低空间要求和线性时间的基数。基数估计的PDS也是基于哈希的。然而，与简单的哈希不同，这些数据结构不会将元素的值存储在哈希表中。使用PDS进行基数估计可以不考虑数据类型，并且还可以在并行机器上分布，减少通信开销。
- en: '[11.2 Linear Counting](contents.xhtml#rsec11_2)'
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[11.2 线性计数](contents.xhtml#rsec11_2)'
- en: 'As a first attempt to compute cardinality with probabilistic approach, authors
    in [[213](bib.xhtml#ch00-bib-213)] introduced linear counting algorithm. Instead
    of storing actual element, linear counting simply set a bit corresponding to the
    element in the hash table. As it may be possible that, two records might collide
    to same location, so computed count might not be exact. Hence, cardinality is
    approximated that is computed from occupancy ratio of hash table. For a set having
    120 million elements, computing cardinality with linear counting approach requires
    1.25 MB of main memory, 1000 disk access, and 1% error rate. Linear counting offers
    a two step process for computing cardinality which are described as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概率方法计算基数的首次尝试，作者们在[[213](bib.xhtml#ch00-bib-213)]中介绍了线性计数算法。线性计数不是存储实际元素，而是简单地在哈希表中设置对应元素的位。由于可能存在两个记录碰撞到相同位置的情况，因此计算的计数可能不准确。因此，基数是通过哈希表的占用率来近似计算的。对于一个包含1.2亿个元素的集合，使用线性计数方法计算基数需要1.25
    MB的主存，1000次磁盘访问和1%的错误率。线性计数提供了计算基数的两个步骤，具体如下所述：
- en: Linear counting employs a hash table of size *m* in main memory along with a
    hash function. Every entry of hash table is initialized to 0\. To each incoming
    item, a hash function is applied and the corresponding index in hash table is
    set to 1.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性计数使用主存中大小为*m*的哈希表以及哈希函数。哈希表的每个条目都初始化为0。对于每个传入的项，都会应用一个哈希函数，并将哈希表中相应的索引设置为1。
- en: 'Next, count of blank entries (,i.e., 0) is noted. Lets call this number *x*.
    Then analyze the fraction of empty bits ( <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>)
    by taking fraction of *x* and *m*. Final estimated cardinality is computed by
    putting value in the following equation:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，记录空条目的数量（即，0）。我们将这个数字称为*x*。然后通过取*x*和*m*的比例来分析空位的分数（<math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>)。通过将值放入以下方程式中来计算最终估计的基数：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mover accent="true"><mi>n</mi><mo>^</mo></mover><mo>≈</mo><mo>−</mo><mi>m</mi><mi>l</mi><mi>n</mi><msub><mi>V</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow></math>(11.1)
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mover accent="true"><mi>n</mi><mo>^</mo></mover><mo>≈</mo><mo>−</mo><mi>m</mi><mi>l</mi><mi>n</mi><msub><mi>V</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow></math>(11.1)
- en: where, *n* is computed estimated cardinality.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*n* 是计算出的估计基数。
- en: The time complexity of linear counting algorithm is *O(n)* where, *n* is the
    total count of elements in set *S*. The accuracy in results of linear counting
    algorithm is dependent on load factor. Here, load factor is defined as fraction
    of unique elements and hash table size. A higher value of load factor decreases
    the accuracy of results and lower the value of load factor, higher is the result
    accuracy. Hence, if the hash table size is very small compared to total number
    of elements, it can lead to high risk of collisions. Otherwise if hash table size
    is large enough the risk of collision reduces but it will consume more space,
    Authors have concluded that for a load factor greater than 1, linear counting
    produces 1% of error. The expected relative error for estimated cardinality <math
    alttext="" display="inline"><mover accent="true"><mi>n</mi><mo>^</mo></mover></math>
    for a given multiset with *N* unique elements is given by Eq. 11.3\. The variable
    *t* represents load factor ( <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mi>m</mi></mfrac></mrow></math>).
    The relative error signifies, on an average what percentage of estimated cardinality
    <math alttext="" display="inline"><mover accent="true"><mi>n</mi><mo>^</mo></mover></math>
    is miscalculated and is given by.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 线性计数算法的时间复杂度为*O(n)*，其中，*n* 是集合 *S* 中元素的总计数。线性计数算法的结果准确性取决于负载因子。在这里，负载因子定义为唯一元素和哈希表大小的分数。负载因子的值越高，结果的准确性越低，而负载因子的值越低，结果的准确性越高。因此，如果哈希表大小与元素总数相比非常小，可能会导致碰撞的风险增加。否则，如果哈希表大小足够大，则碰撞的风险减小，但会消耗更多空间。作者得出结论，对于负载因子大于1的情况，线性计数产生1%的误差。给定具有*N*个唯一元素的给定多重集合的估计基数
    <math alttext="" display="inline"><mover accent="true"><mi>n</mi><mo>^</mo></mover></math>
    的预期相对误差由方程11.3给出。变量 *t* 表示负载因子 ( <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mi>m</mi></mfrac></mrow></math>)。相对误差表示平均估计基数
    <math alttext="" display="inline"><mover accent="true"><mi>n</mi><mo>^</mo></mover></math>
    的百分比被错误计算，给出如下。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mi>t</mi></msup><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow><mrow><mn>2</mn><mi>N</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.2)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mi>t</mi></msup><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow><mrow><mn>2</mn><mi>N</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.2)
- en: The hash table size is also influenced by standard error. The standard error
    is described as standard deviation of <math alttext="" display="inline"><mrow><mfrac><mrow><mover
    accent="true"><mo stretchy="false">(</mo><mo>^</mo></mover><mi>n</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac></mrow></math>
    and is calculated by following equation.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表大小也受标准错误的影响。 标准错误被描述为<mrow><mfrac><mrow><mover accent="true"><mo stretchy="false">(</mo><mo>^</mo></mover><mi>n</mi><mo
    stretchy="false">)</mo></mrow><mi>N</mi></mfrac></mrow>的标准偏差，并由以下方程式计算。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msqrt><mi>m</mi></msqrt><mfrac><mrow><msup><mrow><mo
    stretchy="false">(</mo><msup><mi>e</mi><mi>t</mi></msup><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></mrow><mi>N</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.3)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msqrt><mi>m</mi></msqrt><mfrac><mrow><msup><mrow><mo
    stretchy="false">(</mo><msup><mi>e</mi><mi>t</mi></msup><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></mrow><mi>N</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.3)
- en: Although in order to use this method, count of unique items should be known
    in prior so as to allocate a hash table of appropriate size. Clearly, linear counting
    approach is faster than traditional approach but it fails to produce accurate
    results. Hence use case for this data structure is for applications where 100%
    accuracy is not required. Nevertheless authors in [[38](bib.xhtml#ch00-bib-38)]
    suggested not to use linear counting algorithm for database relations whose cardinality
    is greater than 20 million because of extremely large table size. that provides
    more accurate results with less storage requirements. As a better solution, LogLog
    and HyperLogLog algorithms are also available.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，必须事先知道唯一项的数量，以便分配适当大小的哈希表。 显然，线性计数方法比传统方法更快，但不能产生准确的结果。 因此，这种数据结构的用例是对不需要100％准确性的应用程序。
    尽管如此，作者在[[38](bib.xhtml#ch00-bib-38)]中建议不要对基数大于2000万的数据库关系使用线性计数算法，因为表格非常大，这将导致更准确的结果，存储要求较小。
    作为更好的解决方案，还提供了LogLog和HyperLogLog算法。
- en: Lets understand linear counting with an example. Suppose <math alttext="" display="inline"><mrow><mi>m</mi><mo>=</mo><mn>16</mn></mrow></math>
    and hash function is based on modular hashing, i.e., <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>16</mn></mrow></math>
    where *k* is the key to be inserted. Let set *S* contains total of 10 elements,
    i.e., <math alttext="" display="inline"><mrow><mi>S</mi><mo>=</mo><mn>4</mn><mo>,</mo><mn>34</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>14</mn><mo>,</mo><mn>36</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>7</mn></mrow></math>.
    Notably, cardinality of this set is 7\. Pass these elements through hash function
    and set the corresponding bit to 1\. The resulting state of hash table after passing
    these elements is represented ?? as <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>34</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>36</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>a</mi><mi>n</mi><mi>d</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn></mrow></math>.
    In this case value of *x* is 11, load factor is <math alttext="" display="inline"><mrow><mfrac><mn>7</mn><mrow><mn>16</mn></mrow></mfrac></mrow></math>
    and consequently value of ( <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo
    stretchy="false">)</mo></mrow></math>) <math alttext="" display="inline"><mrow><mfrac><mrow><mn>11</mn></mrow><mrow><mn>16</mn></mrow></mfrac></mrow></math>
    which is equal to 0.6875\. To get final estimated cardinality, put the value of
    ( <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo
    stretchy="false">)</mo></mrow></math>) in Eq. 11.1 which results in <math alttext=""
    display="inline"><mrow><mover accent="true"><mi>n</mi><mo>^</mo></mover><mo>≈</mo><mo>−</mo><mn>16</mn><mo>*</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>0.6875</mn><mo stretchy="false">)</mo></mrow></math>
    which on solving gives 5.99 ≈ 6\. Due to collisions, estimated count is 6 whereas
    actual cardinality is 7\. This whole example is represented in [Fig. 11.1](#fig11_1)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解线性计数。假设 <math alttext="" display="inline"><mrow><mi>m</mi><mo>=</mo><mn>16</mn></mrow></math>
    并且哈希函数基于模哈希，即，<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>16</mn></mrow></math>
    其中 *k* 是要插入的键。让集合 *S* 包含总共 10 个元素，即，<math alttext="" display="inline"><mrow><mi>S</mi><mo>=</mo><mn>4</mn><mo>,</mo><mn>34</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>14</mn><mo>,</mo><mn>36</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>7</mn></mrow></math>。值得注意的是，该集合的基数为
    7。将这些元素通过哈希函数并将相应的位设置为 1。通过这些元素后，哈希表的结果状态表示为 <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>34</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>36</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>a</mi><mi>n</mi><mi>d</mi><mi>h</mi><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn></mrow></math>。在这种情况下，*x*
    的值为 11，负载因子为 <math alttext="" display="inline"><mrow><mfrac><mn>7</mn><mrow><mn>16</mn></mrow></mfrac></mrow></math>，因此（<math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo
    stretchy="false">)</mo></mrow></math>）的值为 <math alttext="" display="inline"><mrow><mfrac><mrow><mn>11</mn></mrow><mrow><mn>16</mn></mrow></mfrac></mrow></math>，即等于
    0.6875。要获得最终估计的基数，请将（<math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>n</mi></msub><mo
    stretchy="false">)</mo></mrow></math>）的值放入方程式 11.1 中，结果为 <math alttext="" display="inline"><mrow><mover
    accent="true"><mi>n</mi><mo>^</mo></mover><mo>≈</mo><mo>−</mo><mn>16</mn><mo>*</mo><mi>l</mi><mi>n</mi><mo
    stretchy="false">(</mo><mn>0.6875</mn><mo stretchy="false">)</mo></mrow></math>，求解得
    5.99 ≈ 6。由于碰撞，估计计数为 6，而实际基数为 7。整个例子在 [图 11.1](#fig11_1) 中表示。
- en: '![Figure 11.1](../images/fig11_1.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1](../images/fig11_1.jpg)'
- en: '**FIGURE 11.1.**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 11.1.**'
- en: Example of linear counting algorithm.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 线性计数算法示例。
- en: '![](../images/list11_1a.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list11_1a.jpg)'
- en: '[11.2.1 Implemtation code of linear counting](contents.xhtml#rsec11_2_1)'
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[11.2.1 线性计数的实现代码](contents.xhtml#rsec11_2_1)'
- en: The Python implemented code for linear counting is described as follows. Here,
    first a dataset is defined that takes 300 numbers between 0 and 20\. Next, we
    check number of unique values in dataset using len() function. The depicts that
    with increase in mapsize, load factor decreases and cardinality estimation generates
    more accurate results.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Python 实现的线性计数代码如下所示。这里，首先定义一个数据集，其中包含 300 个介于 0 和 20 之间的数字。接下来，我们使用 len() 函数检查数据集中唯一值的数量。结果表明，随着映射大小的增加，负载因子减小，基数估计生成更准确的结果。
- en: '![](../images/list11_1b.jpg)![](../images/list11_1c.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list11_1b.jpg)![](../images/list11_1c.jpg)'
- en: '[11.3 LogLog](contents.xhtml#rsec11_3)'
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[11.3 对数对数](contents.xhtml#rsec11_3)'
- en: 'Linear counting still consumes O(n) space which is linear space consumption.
    In this context, LogLog was introduced in [[74](bib.xhtml#ch00-bib-74)] which
    provides solution to cardinality estimation for large datasets. This algorithm
    uses memory in order of <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
    where, *N* is upper bound on number of unique items. In order to count, <math
    alttext="" display="inline"><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow></math>
    (4 billion) distinct items, this algorithms only requires <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow></math> bits of space. To understand
    the concept of LogLog, take an analogy: Suppose two friends Tom and Jerry went
    to a conference and there they decided to bet on who interacted with most strangers.
    So, they started keeping a counter of people they are interacting with. However
    counting as such can be a tedious task. So for next conference instead of just
    counting, they started writing their names on paper. This way it is better to
    count unique people rather than getting confused with total number of conversations.
    However, roaming around with a pen and a paper is not really easy. So, Tom came
    up with an alternative, rather than noting down names of persons, hey decided
    to ask last 6 digits of their contact number and the one with longest sequence
    of leading zeros in last 6 digits of contact number will be declared as winner.
    For example, a contact number of a person is 988866336, so longest sequence here
    is 0 as there are no leading zeros and if contact number is 00639, so longest
    sequence becomes 2\. Clearly if either Tom or Jerry interacts to a few people,
    probability of getting longest leading zeros is either 0 or 1\. As the number
    of people they interacted becomes large, chances of getting a leading zero sequence
    increases to being 3 or 4\. To get a value 6 for longest zero sequence, either
    of them had interacted with thousand of people to get someone with 00000 as their
    last 6 digits of contact number.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 线性计数仍然消耗O(n)的空间，即线性空间消耗。在这种情况下，LogLog在[[74](bib.xhtml#ch00-bib-74)]中被引入，为大型数据集的基数估计提供了解决方案。该算法的内存使用量为<math
    alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>，其中，*N*
    是唯一项的上限。为了计数<math alttext="" display="inline"><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow></math>（40亿）个不同的项，这个算法只需要<math
    alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow></math>位的空间。要理解LogLog的概念，可以举个类比：假设两个朋友汤姆和杰瑞去了一个会议，并在那里决定打赌谁与最多陌生人互动。于是，他们开始计数他们互动的人数。然而，这样的计数可能是一项乏味的任务。所以下次会议，他们不再只是计数，而是开始在纸上写下他们的名字。这样做，更好地计算了独特的人数，而不是被总的对话次数所困扰。然而，随身携带一支笔和一张纸并不容易。所以，汤姆想出了一个替代方案，而不是记录人的名字，他们决定询问对方联系电话号码的最后6位数字，最后6位数字中前导零的序列最长的人将被宣布为赢家。例如，一个人的联系电话号码是988866336，所以这里最长的序列是0，因为没有前导零，如果联系电话号码是00639，那么最长的序列就变成了2。显然，如果汤姆或杰瑞只与少数人互动，获得最长前导零的概率要么是0要么是1。随着他们互动的人数增多，获得前导零序列的概率增加到3或4。要获得最长的零序列值6，他们中的任何一个都必须与成千上万的人互动，以获得联系电话号码的最后6位数字为00000的人。
- en: 'Same concept is applied to LogLog algorithm. Here unique elements are counted
    in large set by hashing each element and then recording longest sequence of zeros
    for each element. LogLog employs a hash table having *m* entries or buckets along
    with a single hash function. Notably, with increase in value of *m*, average error
    rate decreases. As output of hash function is of fixed length, insertion of elements
    has time complexity of O(1). A step by step explanation of estimating cardinality
    with LogLog is described as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的概念也适用于LogLog算法。在这里，通过对每个元素进行哈希处理，然后记录每个元素的最长零序列来计算大型集合中的唯一元素数量。LogLog使用一个具有*m*个条目或桶以及一个单一哈希函数的哈希表。值得注意的是，随着*m*值的增加，平均误差率会降低。由于哈希函数的输出是固定长度的，因此元素的插入具有O(1)的时间复杂度。下面逐步解释使用LogLog估计基数的过程：
- en: For each incoming item, compute a fixed length hash of each item.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个传入的项，计算每个项的固定长度哈希值。
- en: Divide the hash obtained from previous step into two parts. First *k* bits signifies
    the index to a bucket and from the remaining sequence longest zero sequence is
    noted and the value of longest zero sequence is stored in that particular bucket.
    For instance, for a hash table of 16 buckets, a fixed length (10 bit) hash obtained
    is 1010 001001 and there are total of 16 buckets. So, first 4 bits tells about
    index of the bucket and from remaining bis longest zero sequence is noted, i.e.,
    2 is stored at location 10th.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将从上一步获得的哈希值分成两部分。前*k*位表示一个桶的索引，从剩余序列中记录最长的零序列，并将最长的零序列的值存储在该特定桶中。例如，对于一个包含16个桶的哈希表，获得的固定长度（10位）哈希值为1010
    001001，总共有16个桶。因此，前4位表示桶的索引，从剩余的位中记录最长的零序列，即，在第10个位置存储了2。
- en: For each hash obtained, only the largest value of longest string of leading
    zero so far is stored in each bucket.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个获得的哈希值，只有到目前为止最长的前导零字符串的值被存储在每个桶中。
- en: 'Lets say R1, R2,………, Rm denotes entries in the hash table. The final cardinality
    of the set can be computed by taking arithmetic mean of entries in hash table.
    To reduce the effect of outliers and to minimize variance, rather than taking
    average, mean is calculated. Hence, LogLog improves accuracy by storing multiple
    estimates and then averaging the results. So, final cardinality of the set can
    be computed as:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设R1、R2、………、Rm表示哈希表中的条目。集合的最终基数可以通过计算哈希表中条目的算术平均值来计算。为了减少异常值的影响并减小方差，不是取平均值，而是计算平均值。因此，LogLog通过存储多个估计值然后对结果进行平均来提高准确性。因此，集合的最终基数可以计算为：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>c</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mn>0.79402</mn><mo>*</mo><mi>m</mi><mo>*</mo><msup><mn>2</mn><mrow><mfrac><mrow><mstyle
    displaystyle="true"><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow></mstyle></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(11.4)
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>估</mi><mi>计</mi><mi>精</mi><mi>确</mi><mi>度</mi><mo>=</mo><mn>0.79402</mn><mo>*</mo><mi>m</mi><mo>*</mo><msup><mn>2</mn><mrow><mfrac><mrow><mstyle
    displaystyle="true"><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow></mstyle></mrow><mi>m</mi></mfrac></mrow></msup></mrow></mtd></mtr></mtable></mrow></math>(11.4)
- en: Taking *m* buckets basically simulates as different *m* hash functions are taken.
    The standard error of LogLog algorithm is given out to be <math alttext="" display="inline"><mrow><mfrac><mrow><mn>1.30</mn></mrow><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo
    stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></math>
    where, *m* signifies total bucket entries. Hence for a bucket with 2048 entries
    and each entry having S bits, an error of 2.5% is expected. The hash table can
    estimate cardinality till 227\. The clear insight of LogLog is that it is less
    likely for a number to start with a long string of zeros (probability of a number
    having 10 leading zeros is less however not rare). Although LogLog algorithm is
    not suitable for small cardinality and it can only work with sets having large
    cardinality. Also, it is required to decode a prior upper bound on the total items
    to be inserted so that hash table can be chosen. Lets take example of LogLog where
    <math alttext="" display="inline"><mrow><mi>m</mi><mo>=</mo><mn>16</mn></mrow></math>,
    index for any bucket takes 4 bits. This example counts unique visitors for a website.
    Refer to [Fig. 11.2](#fig11_2) After inserting 4 elements estimated cardinality
    is <math alttext="" display="inline"><mrow><mn>0.79402</mn><mo>*</mo><mn>16</mn><mo>*</mo><msup><mn>2</mn><mrow><mfrac><mn>6</mn><mrow><mn>16</mn></mrow></mfrac></mrow></msup><mo>≈</mo><mn>16.47</mn></mrow></math>.
    Clearly due to insertion of few elements, results of this algorithm are calculated
    wrong. However, for large cardinality algorithm will generate more accurate results.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 *m* 个桶基本上相当于采用了不同的 *m* 个哈希函数。LogLog 算法的标准误差为 <math alttext="" display="inline"><mrow><mfrac><mrow><mn>1.30</mn></mrow><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo
    stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></math>，其中
    *m* 表示总桶条目。因此，对于一个具有 2048 个条目且每个条目具有 S 位的桶，预期误差为 2.5%。哈希表可以估计基数直到 227\. LogLog
    的明显见解是，一个数字以长字符串的零开始的可能性较小（一个数字具有 10 个前导零的概率较小，但不是很罕见）。虽然 LogLog 算法不适用于小基数，并且它只能处理具有大基数的集合。此外，需要对要插入的总项数进行先前的上限解码，以便选择哈希表。让我们以
    LogLog 为例，其中 <math alttext="" display="inline"><mrow><mi>m</mi><mo>=</mo><mn>16</mn></mrow></math>，任何桶的索引占用
    4 位。该示例计算网站的独立访客。请参阅 [图 11.2](#fig11_2) 在插入 4 个元素后，估计的基数为 <math alttext="" display="inline"><mrow><mn>0.79402</mn><mo>*</mo><mn>16</mn><mo>*</mo><msup><mn>2</mn><mrow><mfrac><mn>6</mn><mrow><mn>16</mn></mrow></mfrac></mrow></msup><mo>≈</mo><mn>16.47</mn></mrow></math>。显然，由于插入了少量元素，此算法的结果计算错误。然而，对于大基数，该算法将生成更准确的结果。
- en: '![Figure 11.2](../images/fig11_2.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2](../images/fig11_2.jpg)'
- en: '**FIGURE 11.2.**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 11.2.**'
- en: LogLog example.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: LogLog 示例。
- en: '[11.3.1 Implementation of LogLog in Python](contents.xhtml#rsec11_3_1)'
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[11.3.1 Python 中 LogLog 的实现](contents.xhtml#rsec11_3_1)'
- en: '![](../images/list11_2a.jpg)![](../images/list11_2b.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list11_2a.jpg)![](../images/list11_2b.jpg)'
- en: '[11.4 HyperLogLog](contents.xhtml#rsec11_4)'
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[11.4 HyperLogLog](contents.xhtml#rsec11_4)'
- en: HyperLogLog (HLL) is most popular probabilistic algorithm that computes distinct
    items in a multiset. Rather than exact, HLL computes approximates in low storage
    requirements. HLL [[82](bib.xhtml#ch00-bib-82)] is an improved version of LogLog
    in two ways.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: HyperLogLog（HLL）是最流行的概率算法，用于计算多重集合中的不同项。与精确计算不同，HLL 在低存储要求下计算近似值。HLL[[82](bib.xhtml#ch00-bib-82)]在两个方面是
    LogLog 的改进版本。
- en: 'The insertion of any element in HLL has almost same procedure as discussed
    for LogLog. Different from LogLog, while combining buckets in step 4th, rather
    than using arithmetic mean, harmonic mean of the values in the bucket are taken.
    The sequential implementation of HLL is represented in [Fig. 11.3](#fig11_3) This
    is to decrement the effect of uncommon high max-leading zero count in the same
    bucket. Harmonic mean helps to ignore values that approaches towards infinity.
    Hence, it reduces the impact of exponentiating a noisy number and improves accuracy
    of cardinality estimation. HLL further reduces the effect of outliers to improve
    the accuracy of estimation by removing out the largest value before averaging.
    The estimated cardinality from HLL is given by:'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HLL 中插入任何元素的过程几乎与 LogLog 中讨论的过程相同。与 LogLog 不同的是，在第四步中组合桶时，不是使用算术平均值，而是取桶中值的调和平均值。HLL
    的顺序实现在[图 11.3](#fig11_3)中表示。这是为了减少同一桶中不常见的高最大前导零计数的影响。调和平均值有助于忽略接近无穷大的值。因此，它减少了干扰的指数化嘈杂数字的影响，并提高了基数估计的准确性。HLL
    进一步减少了离群值的影响，通过在平均之前移除最大值来提高估计的准确性。从 HLL 估算的基数如下所示：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>E</mi><mo>=</mo><msub><mi>α</mi><mi>m</mi></msub><mo>.</mo><mi>m</mi><mfrac><mi>m</mi><mrow><mfenced
    close=")" open="("><mrow><mstyle displaystyle="true"><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mrow><msup><mn>2</mn><mrow><mo>−</mo><msup><mi>R</mi><mi>j</mi></msup></mrow></msup></mrow></mstyle></mrow></mfenced></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.5)
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>E</mi><mo>=</mo><msub><mi>α</mi><mi>m</mi></msub><mo>.</mo><mi>m</mi><mfrac><mi>m</mi><mrow><mfenced
    close=")" open="("><mrow><mstyle displaystyle="true"><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mrow><msup><mn>2</mn><mrow><mo>−</mo><msup><mi>R</mi><mi>j</mi></msup></mrow></msup></mrow></mstyle></mrow></mfenced></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(11.5)
- en: '![Figure 11.3](../images/fig11_3.jpg)'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.3](../images/fig11_3.jpg)'
- en: '**FIGURE 11.3.**'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 11.3.**'
- en: Sequential implementation of HLL.
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HLL 的顺序实现。
- en: where, *α* is a constant whose value is chosen as per the number of buckets.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*α* 是一个常数，其值根据桶的数量选择。
- en: HLL makes correction for extreme cases, i.e., when all buckets are not occupied
    and when buckets are almost full and hash collisions causes underestimates. If
    the calculated estimation *E* is less than <math alttext="" display="inline"><mrow><mn>2.5</mn><mo>*</mo><mi>m</mi></mrow></math>
    and there are some buckets that has zero value for maximum leading zero, then
    the final cardinality in this case is replaced with
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HLL 对极端情况进行校正，即当所有桶都未被占用或者桶几乎全满且哈希冲突导致低估时。如果计算得到的估计值 *E* 小于 <math alttext=""
    display="inline"><mrow><mn>2.5</mn><mo>*</mo><mi>m</mi></mrow></math>，并且有一些桶的最大前导零值为零，则在这种情况下，最终基数被替换为
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>E</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mo>−</mo><mi>m</mi><mo>*</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="false">(</mo><mfrac><mi>V</mi><mi>m</mi></mfrac><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.6)
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>E</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mo>−</mo><mi>m</mi><mo>*</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="false">(</mo><mfrac><mi>V</mi><mi>m</mi></mfrac><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.6)
- en: 'where, *V* is the count of bucket with zero value for maximum leading zero.
    Whereas for big cardinalities that approaches the total size of hash table, i.e.,
    for <math alttext="" display="inline"><mrow><mi>E</mi><mo>></mo><mfrac><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><mrow><mn>30</mn></mrow></mfrac></mrow></math>,
    the final cardinality is computed as:'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*V* 表示最大前导零值为零的桶的计数。对于接近哈希表总大小的大基数，即 <math alttext="" display="inline"><mrow><mi>E</mi><mo>></mo><mfrac><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><mrow><mn>30</mn></mrow></mfrac></mrow></math>，最终基数计算如下：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>E</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mo>−</mo><msup><mn>2</mn><mi>m</mi></msup><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>E</mi><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow></mfrac><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.7)
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>E</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mo>−</mo><msup><mn>2</mn><mi>m</mi></msup><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>E</mi><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow></mfrac><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.7)
- en: Along with this, HLL supports merge operation that simply applies union of two
    HLL's and this function returns the maximum value from each pair of buckets, i.e.,
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，HLL 还支持合并操作，简单地应用两个 HLL 的并集，该函数返回每对桶中的最大值，即，
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>H</mi><mi>L</mi><msub><mi>L</mi><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo
    stretchy="false">(</mo><mi>H</mi><mi>L</mi><msub><mi>L</mi><mn>1</mn></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>,</mo><mi>H</mi><mi>L</mi><msub><mi>L</mi><mn>2</mn></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.8)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>H</mi><mi>L</mi><msub><mi>L</mi><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo
    stretchy="false">(</mo><mi>H</mi><mi>L</mi><msub><mi>L</mi><mn>1</mn></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>,</mo><mi>H</mi><mi>L</mi><msub><mi>L</mi><mn>2</mn></msub><mo
    stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(11.8)
- en: where, *j* varies from 1 to *m*. One of thee reason that HLL is more popular
    over LogLog because for the same count of items, HLL results in better accuracy
    when compared to LogLog. The Standard error rate of HLL is described as <math
    alttext="" display="inline"><mrow><mfrac><mrow><mn>1.04</mn></mrow><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></math>,
    where *m* is the number of buckets used. For instance, redis software use 16348
    registers by default, so in order to implement HLL, it returns the standard error
    of 0.81%. Original HLL still returns large error for small cardinality but with
    little improvements, it can manage very small range cardinality to large range
    cardinality.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*j* 的取值范围是从 1 到 *m*。相比于 LogLog，HLL 更受欢迎的一个原因是，对于相同数量的项目，HLL 的准确性比 LogLog
    更高。HLL 的标准误差率被描述为 <math alttext="" display="inline"><mrow><mfrac><mrow><mn>1.04</mn></mrow><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></math>，其中
    *m* 是使用的桶的数量。例如，Redis 软件默认使用 16348 个寄存器，因此为了实现 HLL，它返回标准误差为 0.81%。原始的 HLL 对于小基数仍然返回较大的误差，但稍加改进后，它可以处理非常小范围的基数到大范围的基数。
- en: Take an example that counts the number of unique users who visited a website
    so far. Suppose there are 16 buckets which imply that addressing a bucket requires
    4 bits. As shown in [Fig. 11.4](#fig11_4), for every IP address, first pass it
    through a HLL hash function that returns 16 bit fixed number. First four bits
    determine bucket number and from remaining bits count of leading zeros are extracted
    but only record of maximum number of leading zeros is kept and rest others are
    ignored. Similarly, for other IP addresses, the same process is repeated. To get
    the final cardinality, the harmonic mean of count column is taken. After inserting
    4 different IP addresses the estimated cardinality can be computed as <math alttext=""
    display="inline"><mrow><mfrac><mrow><mn>0.673</mn><mo>*</mo><mn>16</mn><mo>*</mo><mn>16</mn></mrow><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow></mfrac><mo>≈</mo><mn>551</mn></mrow></math>
    which is obviously not equal to 4 because for small cardinalities the HLL results
    shows strong bias. However, for large carnalities this algorithm works fine.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，统计迄今为止访问网站的唯一用户数量。假设有 16 个桶，这意味着寻址一个桶需要 4 位。如 [图 11.4](#fig11_4) 所示，对于每个
    IP 地址，首先将其通过 HLL 哈希函数传递，返回 16 位固定数字。前四位确定桶号，从剩余位中提取前导零的计数，但只保留最大前导零的记录，其余的被忽略。类似地，对其他
    IP 地址也是如此。为了得到最终的基数，取计数列的调和平均数。在插入 4 个不同的 IP 地址后，估计的基数可以计算为 <math alttext="" display="inline"><mrow><mfrac><mrow><mn>0.673</mn><mo>*</mo><mn>16</mn><mo>*</mo><mn>16</mn></mrow><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow></mfrac><mo>≈</mo><mn>551</mn></mrow></math>，显然不等于
    4，因为对于小基数，HLL 结果显示出强烈的偏见。然而，对于大基数，该算法运行良好。
- en: '![Figure 11.4](../images/fig11_4.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4](../images/fig11_4.jpg)'
- en: '**FIGURE 11.4.**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 11.4.**'
- en: HLL example.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: HLL 示例。
- en: '[11.4.1 Implementation of HLL in Python](contents.xhtml#rsec11_4_1)'
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[11.4.1 Python 中的 HLL 实现](contents.xhtml#rsec11_4_1)'
- en: '![](../images/list11_3a.jpg)![](../images/list11_3b.jpg)![](../images/list11_4.jpg)![](../images/list11_5a.jpg)![](../images/list11_5b.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list11_3a.jpg)![](../images/list11_3b.jpg)![](../images/list11_4.jpg)![](../images/list11_5a.jpg)![](../images/list11_5b.jpg)'
- en: Activity
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: What is the time complexity for linear counting algorithm for *n* number of
    total elements
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 *n* 个总元素的线性计数算法的时间复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: What is the time complexity for insertion operation of LogLog algorithm with
    a hash table of size *m*?
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大小为 *m* 的哈希表的 LogLog 算法的插入操作的时间复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: None of the above
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: For a hash table of size 32\. How many bits are reserved for index field and
    longest zero sequence field ?
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大小为 32 的哈希表。为索引字段和最长零序列字段保留了多少位？
- en: 6,25
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6,25
- en: 5,27
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5,27
- en: 16,16
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 16,16
- en: 10,22
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10,22
- en: HLL stands for?
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HLL 代表？
- en: HydroLogLog
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水日志
- en: HyperLogLog
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超对数日志
- en: Hyperloglinear
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超对数线性
- en: Hyperlinearlinear
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超线性线性
- en: What is the space requirement for LogLog data structure with *N* as upper bound
    on number of unique elements?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LogLog 数据结构的空间需求是多少，其中 *N* 是唯一元素数量的上限？
- en: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo
    stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
- en: To count, <math alttext="" display="inline"><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow></math>
    (4 billion) distinct items, LogLog algorithms only requires?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计数，<math alttext="" display="inline"><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow></math>（40亿）个不同项，LogLog
    算法只需要？
- en: 5 bits
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5 位
- en: 10 bits
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10 位
- en: 32 bits
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 32 位
- en: None of these
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: 1\. a  2\. b  3\. c  4\. b  5\. a  6\. a
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. a  2\. b  3\. c  4\. b  5\. a  6\. a
- en: <hgroup>
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[12](contents.xhtml#rchapter12)'
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[12](contents.xhtml#rchapter12)'
- en: '[Frequency Count Query Probabilistic Data Structures](contents.xhtml#rchapter12)'
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[频率计数查询概率数据结构](contents.xhtml#rchapter12)'
- en: </hgroup>
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[12.1 Introduction](contents.xhtml#rsec12_1)'
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[12.1 简介](contents.xhtml#rsec12_1)'
- en: This category concerns for estimating the count of a particular items in a set.
    For example, search engine uses frequency estimators for extracting frequently
    searched queries and network routers uses them for locating common source and
    destination addresses. One proposed solution to this randomly extract a sample
    from the set that shows properties of complete set. However, achieving true randomness
    is a quite unfavorable task. So, sampling also is not a useful solution to our
    problem. Also with hash tables, memory requirement becomes high (linear space
    requirements) as more items are added. Majority algorithm [[52](bib.xhtml#ch00-bib-52)]
    and Misra-Gries [[144](bib.xhtml#ch00-bib-144)] algorithms are two popular deterministic
    algorithms to solve frequency count problem. One of the effective way is to adopt
    approximation based queries for streaming data. In this context, an trending data
    structure is “Sketch” which based on summary based approach performs approximation
    queries. Sketch algorithms based on approximation and randomization are space
    and time efficient solutions in this context. Sketches refer to a category of
    algorithm that portrays a large set of data by a compact summary that is much
    smaller than actual data size [[89](bib.xhtml#ch00-bib-89)]. Machine learning,
    NLP, security are some important area where variants of sketches are being used
    [[203](bib.xhtml#ch00-bib-203)]. Sketches also solves problems faced by sampling
    technique and supports parallelization in practice. Parallelization in sketches
    implies that it can be implemented independently on different parts of data and
    further combines these parts that results in consistent aggregate. In short, parallelization
    imposes a straightforward divide and conquer approach for problems that faces
    scalability challenge. Moreover, sketches possess sub-linear asymptotic computational
    complexity which results in low computational power and storage. The algorithm
    under this category is characterized by two parameters, i.e., *ϵ* and *δ* where
    *ϵ* (accuracy parameter)describes the maximum affordable error in frequency estimation
    results with a maximum probability of *δ* (confidence parameter). These two parameters
    can be tuned as per available space. Also, for sketches error could be over-estimation,
    underestimation or a combination of both while estimating frequency.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别涉及对集合中特定项目的数量进行估计。例如，搜索引擎使用频率估计器来提取频繁搜索的查询，网络路由器使用它们来定位常见的源和目标地址。对此的一个提出的解决方案是从显示完整集合特性的集合中随机提取样本。然而，实现真正的随机性是一项相当不利的任务。因此，抽样也不是我们问题的一个有用的解决方案。另外，使用哈希表时，随着更多项目的添加，内存需求变得很高（线性空间需求）。Majority
    algorithm [[52](bib.xhtml#ch00-bib-52)] 和 Misra-Gries [[144](bib.xhtml#ch00-bib-144)]
    算法是解决频率计数问题的两种流行的确定性算法。一个有效的方法之一是采用基于近似的查询来处理流数据。在这个背景下，一种流行的数据结构是“Sketch”，它基于摘要的方法执行近似查询。基于近似和随机化的Sketch算法是这个背景下空间和时间有效的解决方案。Sketches指的是一类通过比实际数据大小小得多的紧凑摘要来描绘大量数据的算法
    [[89](bib.xhtml#ch00-bib-89)]。机器学习、自然语言处理、安全性是一些重要领域，其中Sketch的变体正在被使用 [[203](bib.xhtml#ch00-bib-203)]。Sketches还解决了抽样技术面临的问题，并在实践中支持并行化。Sketches中的并行化意味着它可以独立地在数据的不同部分上实现，并进一步组合这些部分，从而产生一致的聚合结果。简而言之，并行化对面临可伸缩性挑战的问题施加了一种直观的分而治之的方法。此外，Sketches具有次线性渐近计算复杂性，这导致低计算功率和存储。该类别下的算法由两个参数
    *ϵ* 和 *δ* 特征化，其中 *ϵ*（精度参数）描述了在最大概率下频率估计结果中的最大可承受误差，最大概率为 *δ*（置信度参数）。这两个参数可以根据可用空间进行调整。另外，对于Sketches，估计频率时的误差可能是过估计、低估计或两者的组合。
- en: '[12.2 Count-Min Sketch](contents.xhtml#rsec12_2)'
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[12.2 计数最小化草图](contents.xhtml#rsec12_2)'
- en: 'Count-Min Sketch (CMS) [[66](bib.xhtml#ch00-bib-66)] is most popularly available
    sketch data structure for executing frequency count queries. Specifically, this
    data structure serves efficient query processing on streaming data. CMS uses a
    compressed represent of data in order to guarantee low storage requirements. Similar
    to hash table, CMS employs a table with *w* width and depth *d*. While designing
    the sketch, the parameters *w* and *d* are fixed. The table is all initialized
    to zero. Different from hash table, rather than using a single hash function,
    for each row of table a different hash function is used, i.e., a total of *d*
    pairwise independent hash functions are used as shown in [Fig. 12.1](#fig12_1).
    Pairwise independence constructs a universal hash family that results in minimum
    collision [[113](bib.xhtml#ch00-bib-113)]. Hash functions from universal families
    are those classes having less collision probability. The hash functions should
    be chosen such that they spread out the incoming items so as to attain high accuracy.
    Each of hash function takes the incoming element and maps it to corresponding
    column within range of 1,2,3,…..,*w*. CMS consumes only sub-linear space with
    an disadvantage of over-counting because of hash collisions. Linear space complexity
    implies that with increase in data size, memory consumption also increases with
    a direct relationship between the two. Sub-linear on the other hand does not consumes
    equal memory to the data. It however consumes less than or half of the memory
    as compared to data as shown in [Fig. 12.2](#fig12_2). The operations supported
    by CMS are described as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 计数最小化草图（CMS）[[66](bib.xhtml#ch00-bib-66)] 是用于执行频率计数查询的最流行的可用草图数据结构。具体来说，这种数据结构能够对流数据进行高效的查询处理。CMS
    使用压缩的数据表示来保证低存储需求。类似于哈希表，CMS 使用宽度 *w* 和深度 *d* 的表。在设计草图时，参数 *w* 和 *d* 是固定的。表中的所有内容都初始化为零。与哈希表不同的是，CMS
    不是使用单个哈希函数，而是对于表的每一行使用不同的哈希函数，即使用了 *d* 个成对独立的哈希函数，如 [图 12.1](#fig12_1) 所示。成对独立构建了一个通用哈希族，导致最小碰撞
    [[113](bib.xhtml#ch00-bib-113)]。来自通用族的哈希函数是那些具有较低碰撞概率的类。哈希函数应该被选择为使得它们将传入的项分散开来以达到高精度。每个哈希函数将传入的元素映射到范围为
    1, 2, 3, ……, *w* 的相应列。CMS 只消耗次线性空间，但由于哈希碰撞而导致过度计数。线性空间复杂度意味着随着数据量的增加，内存消耗也会直接增加。而次线性空间复杂度不会消耗与数据相等的内存。但是它消耗的内存少于数据的一半，如
    [图 12.2](#fig12_2) 所示。CMS 支持的操作描述如下：
- en: '![Figure 12.1](../images/fig12_1.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1](../images/fig12_1.jpg)'
- en: '**FIGURE 12.1.**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.1.**'
- en: Structure of CMS.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 的结构。
- en: '![Figure 12.2](../images/fig12_2.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2](../images/fig12_2.jpg)'
- en: '**FIGURE 12.2.**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.2.**'
- en: Understanding sub-linear space requirements.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 理解次线性空间要求。
- en: 'Update(i, c): This function updates frequency of any incoming element *i* by
    a count *c*. To each incoming element, all *d* hash functions are applied and
    corresponding location between <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>w</mi></mrow></math>
    to each hash function is updated by adding a value *c* to the existing value.'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新（i，c）：此函数通过计数*c*更新任何传入元素*i*的频率。对于每个传入的元素，都会应用所有*d*个哈希函数，并且在每个哈希函数中的相应位置之间的<math
    alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>w</mi></mrow></math>更新现有值的值。
- en: 'Estimate(i): This function computes the frequency of an element *i* in a set.
    First locate the locations corresponding to *d* hash functions. Finally the frequency
    count for element *i* is the minimum value out of the *d* obtained locations.
    As hash functions are used, there are chances that different element may collide
    on same cell. Thus by selecting minimum value, closest accurate results are fetched
    for frequency queries. Clearly, the results from a CMS may overestimate but never
    underestimate. Notably, CMS performs counting first and then computes minimum,
    thus named count-min sketch.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算（i）：此函数计算集合中元素*i*的频率。首先定位对应于*d*个哈希函数的位置。最后，元素*i*的频率计数是*d*个获得的位置中的最小值。由于使用了哈希函数，不同元素可能会在同一个单元上发生碰撞。因此，通过选择最小值，可以为频率查询获取最接近准确的结果。显然，来自CMS的结果可能会高估但永远不会低估。值得注意的是，CMS首先进行计数，然后计算最小值，因此被称为计数-最小值草图。
- en: 'Delete(i, c): To delete element *i* from the set, simply decrement the d corresponding
    locations in each row by a count *c*.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除（i，c）：要从集合中删除元素*i*，只需在每一行中相应的位置递减计数*c*。
- en: 'Notably, the frequency estimation of CMS is somewhat similar to counting BF.
    Like other PDS, CMS use-cases are beneficial for application that does not care
    about exact frequency count of the element. Database query planning, finding heavy
    hitters in traffic monitoring, NLP, compressed sensing, joint-size estimations
    are some of the promising use-cases of frequency query estimation PDS. CMS also
    supports parallelization as here sub sketches can be merged by taking sum of tables.
    However, two sketches can only be merged if they are constructed using same value
    of *w* and *d* along with same hash functions. Moreover, CMS enables approximate
    addition of any summable value that supports a monoid. One of the disadvantage
    of CMS is that it shows behavior biased estimation of true frequency count of
    a number. Count-min-log sketch, count-min-mean sketch are some of the most recent
    improvements over CMS. Clearly, for any item *i*, actual frequency ( <math alttext=""
    display="inline"><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow></math>) is always
    less than or equal to estimated frequency ( <math alttext="" display="inline"><mrow><msub><mover
    accent="true"><mi>f</mi><mo>^</mo></mover><mi>i</mi></msub></mrow></math>). For
    a sketch of size *w*d*, setting <math alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mfrac><mn>2</mn><mi>ϵ</mi></mfrac></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="true">(</mo><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo stretchy="true">)</mo></mrow></math>
    ensures that estimate operation can exceed actual frequency by atmost <math alttext=""
    display="inline"><mrow><mi>ϵ</mi><mi>N</mi></mrow></math> ( <math alttext="" display="inline"><mrow><msub><mover
    accent="true"><mi>f</mi><mo>^</mo></mover><mi>i</mi></msub><mo>≤</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mi>ϵ</mi><mi>N</mi></mrow></math>)
    with atleast probability <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>δ</mi></mrow></math>.
    Effect of changing values of *w* and *d* is represented in [Table 12.1](#tab12_1).
    Hence cardinality estimation for size *N* has atmost of <math alttext="" display="inline"><mrow><mfrac><mrow><mn>2</mn><mi>N</mi></mrow><mi>w</mi></mfrac></mrow></math>
    error with atleast probability of <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><msup><mrow><mo
    stretchy="true">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="true">)</mo></mrow><mi>d</mi></msup></mrow></math>.
    Space consumed by CMS is O( <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>ϵ</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac></mrow></math>)
    and time taken by update and estimate is given by: <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="true">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo
    stretchy="true">)</mo><mo>=</mo><mi>O</mi><mo stretchy="true">(</mo><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math>. CMS also supports deletion by decrementing
    the corresponding hash location.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，CMS 的频率估计与计数 BF 有些相似。与其他 PDS 一样，CMS 的使用情况对于不关心元素的确切频率计数的应用是有益的。数据库查询规划、流量监控中查找重要数据、自然语言处理、压缩感知、联合大小估计是频率查询估计
    PDS 的一些有前途的使用情况。CMS 也支持并行化，因为这里的子草图可以通过取表的和来合并。但是，只有在使用相同的 *w* 和 *d* 值以及相同的哈希函数构建的两个草图才能合并。此外，CMS
    允许对支持幺半群的任何可加值进行近似添加。CMS 的一个缺点是它显示了对数字真实频率计数的行为偏向估计。Count-min-log 草图、count-min-mean
    草图是 CMS 的一些最近的改进。显然，对于任何项目 *i*，实际频率（<math alttext="" display="inline"><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow></math>）总是小于或等于估计频率（<math
    alttext="" display="inline"><mrow><msub><mover accent="true"><mi>f</mi><mo>^</mo></mover><mi>i</mi></msub></mrow></math>）。对于大小为
    *w*d* 的草图，设置 <math alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mfrac><mn>2</mn><mi>ϵ</mi></mfrac></mrow></math>
    和 <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="true">(</mo><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo stretchy="true">)</mo></mrow></math>
    确保估计操作最多可以超过实际频率 <math alttext="" display="inline"><mrow><mi>ϵ</mi><mi>N</mi></mrow></math>（<math
    alttext="" display="inline"><mrow><msub><mover accent="true"><mi>f</mi><mo>^</mo></mover><mi>i</mi></msub><mo>≤</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mi>ϵ</mi><mi>N</mi></mrow></math>）的概率至少为
    <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>δ</mi></mrow></math>。改变
    *w* 和 *d* 值的影响在 [表 12.1](#tab12_1) 中表示。因此，对于大小为 *N* 的基数估计，最多有 <math alttext=""
    display="inline"><mrow><mfrac><mrow><mn>2</mn><mi>N</mi></mrow><mi>w</mi></mfrac></mrow></math>
    的错误概率至少为 <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><msup><mrow><mo
    stretchy="true">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="true">)</mo></mrow><mi>d</mi></msup></mrow></math>。CMS
    消耗的空间是 O（<math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>ϵ</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac></mrow></math>），更新和估计所需的时间由
    <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo
    stretchy="true">)</mo><mo>=</mo><mi>O</mi><mo stretchy="true">(</mo><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math> 给出。CMS 还支持通过减少相应的哈希位置进行删除。
- en: '**TABLE 12.1**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 12.1**'
- en: Effects of change in parameters for CMS.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 参数变化的影响。
- en: '| Parameter | Increase | Decrease |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 增加 | 减少 |'
- en: '| --- | --- | --- |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| w |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| w |'
- en: High Accuracy
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高准确率
- en: More memory requirement
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的内存需求
- en: '| • Relatively more error rate |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| • 相对更高的错误率 |'
- en: '| d |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| d |'
- en: Updates will be processed at low speed
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新将以较低的速度处理
- en: Less false positive rate
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的误报率
- en: More memory Requirements
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的内存需求
- en: '|'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Less time in updating data
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据所需的时间较短
- en: Less memory requirements
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的内存需求
- en: '|'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: One of the major applications of CMS includes monitoring Heavy hitters. Heavy
    hitters are defined with respect to a threshold *ϕ* and if count of any item frequency
    is equal to or greater than *ϕ*, then that item may be regarded as a heavy hitter.
    Schechter *et al.* [[167](bib.xhtml#ch00-bib-167)] proposed an approach that identifies
    most popular passwords in order to prevent statistical-guessing attacks. Here,
    the main contribution of the authors is to deprive an attacker of guessing most
    popular passwords by not letting any of the passwords to get common. CMS gives
    better results when combined with BF. Gupta *et al.* [[94](bib.xhtml#ch00-bib-94)]
    presented an Intrusion Detection System model that works on PDS. To check whether
    a node is suspicious or not from a list of suspicious nodes, all incoming node
    are passed through a BF, followed by a CMS to count frequency of hits by a particular
    node if BF returns true.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 的主要应用之一是监测重要访问者。根据阈值 *ϕ* 定义了重要访问者，如果任何项目的频率计数等于或大于 *ϕ*，那么该项目可能被视为重要访问者。
    Schechter 等人 [[167](bib.xhtml#ch00-bib-167)] 提出了一种方法，用于识别最流行的密码，以防止统计猜测攻击。在这里，作者的主要贡献是通过不让任何密码变得普遍来剥夺攻击者猜测最流行的密码。
    CMS 与 BF 结合使用时效果更好。Gupta 等人 [[94](bib.xhtml#ch00-bib-94)] 提出了一种基于 PDS 的入侵检测系统模型。为了检查一个节点是否可疑，从一组可疑节点中，所有进入的节点都通过
    BF，然后通过 CMS 计算特定节点的命中频率，如果 BF 返回 true，则该节点被认为可疑。
- en: Lets understand CMS with a example. Consider a 2-D table where value of <math
    alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mn>6</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mn>4</mn></mrow></math>,
    i.e., 4 hash functions will be used and each row will have 6 buckets. Consider
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>2</mn><mo>=</mo><mo stretchy="true">(</mo><mn>2</mn><mo>*</mo><mi>i</mi><mo
    stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>.
    All 24 locations are initialized to zero. Each incoming element is passed through
    all 4 hash functions and corresponding positions are incremented by their given
    count. The series of operation update(12,1), update(5,2), update (16,1), update(6,1)
    is shown in [Fig. 12.3](#fig12_3). The results of element 12, 5, 16, 6 after passing
    through given hash function is shown in [Table 12.2](#tab12_2). The query operation
    Estimate(6) has been shown in [Fig. 12.4](#fig12_4) and query operation Estimate(12)
    has been represented in [Fig. 12.5](#fig12_5). For element 6, the estimate query
    return true result whereas for element 12, it shows an case of over-estimate.
    Last, the deletion of element 6 by a count 1 is shown in [Fig 12.6](#fig12_6).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解 CMS。考虑一个 2-D 表格，其中 <math alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mn>6</mn></mrow></math>
    且 <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mn>4</mn></mrow></math>，即将使用
    4 个哈希函数，每行将有 6 个桶。考虑 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>h</mi><mn>2</mn><mo>=</mo><mo stretchy="true">(</mo><mn>2</mn><mo>*</mo><mi>i</mi><mo
    stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    和 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>。所有
    24 个位置都初始化为零。每个传入的元素都经过这 4 个哈希函数，并且相应位置根据给定的计数递增。操作序列 update(12,1), update(5,2),
    update (16,1), update(6,1) 显示在 [图 12.3](#fig12_3) 中。通过给定哈希函数传递元素 12, 5, 16, 6
    的结果显示在 [表格 12.2](#tab12_2) 中。查询操作 Estimate(6) 在 [图 12.4](#fig12_4) 中展示，查询操作 Estimate(12)
    在 [图 12.5](#fig12_5) 中表示。对于元素 6，估计查询返回真实结果，而对于元素 12，它显示了一个过估计的情况。最后，通过计数 1 删除元素
    6 的操作显示在 [图 12.6](#fig12_6) 中。
- en: '![Figure 12.3](../images/fig12_3.jpg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3](../images/fig12_3.jpg)'
- en: '**FIGURE 12.3.**'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.3**'
- en: Update operation in CMS.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 中的更新操作。
- en: '**TABLE 12.2**'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 12.2**'
- en: Results of elements after passing through hash functions.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 经过哈希函数处理后的元素结果。
- en: '| Element | *h*[1] | *h*[2] | *h*[3] | *h*[4] |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | *h*[1] | *h*[2] | *h*[3] | *h*[4] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 12 | 0 | 0 | 0 | 5 |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 0 | 0 | 0 | 5 |'
- en: '| 5 | 5 | 4 | 2 | 1 |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 4 | 2 | 1 |'
- en: '| 16 | 4 | 2 | 1 | 5 |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 4 | 2 | 1 | 5 |'
- en: '| 6 | 0 | 0 | 0 | 3 |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | 0 | 0 | 3 |'
- en: '![Figure 12.4](../images/fig12_4.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4](../images/fig12_4.jpg)'
- en: '**FIGURE 12.4.**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.4.**'
- en: Estimate operation in CMS.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 中的估算操作。
- en: '![Figure 12.5](../images/fig12_5.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5](../images/fig12_5.jpg)'
- en: '**FIGURE 12.5.**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.5.**'
- en: Estimate operation in CMS representing over-estimate.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 中的估算操作代表了过估计。
- en: '![Figure 12.6](../images/fig12_6.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6](../images/fig12_6.jpg)'
- en: '**FIGURE 12.6.**'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.6.**'
- en: Estimate operation in CMS representing over-estimate.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: CMS 中的估算操作代表了过估计。
- en: '[12.2.1 Implementation of CMS with Python](contents.xhtml#rsec12_2_1)'
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[12.2.1 使用 Python 实现 CMS](contents.xhtml#rsec12_2_1)'
- en: '![](../images/list12_1a.jpg)![](../images/list12_1b.jpg)![](../images/list12_2a.jpg)![](../images/list12_2b.jpg)![](../images/list12_3.jpg)![](../images/list12_4.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list12_1a.jpg)![](../images/list12_1b.jpg)![](../images/list12_2a.jpg)![](../images/list12_2b.jpg)![](../images/list12_3.jpg)![](../images/list12_4.jpg)'
- en: '[12.2.2 Count-mean-min-sketch](contents.xhtml#rsec12_2_2)'
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[12.2.2 计数均值最小素描](contents.xhtml#rsec12_2_2)'
- en: 'To deal with biasness generated by CMS, authors of [[70](bib.xhtml#ch00-bib-70)],
    introduced a variant of CMS called count-mean-min (CMM). Authors have pointed
    out that due to property that a counter of CMS is touched by many elements so,
    an error is expected. Here, the authors characterize this error as noise. Notably,
    the CMS outputs the least noise counter In CMM, the authors aim to estimate the
    noise generated by each counter. To estimate noise from counters, note the values
    of other counters in a row that are not touched by element in question. Here,
    it is assumed that each element is mapped uniformly and randomly for all rows
    of the table. The value in each counter that is not touched by element is an independent
    random variable and follows the same distribution pattern as noise. The structure
    and updation procedure of CMM is similar to CMS. Here also a 2-D table (w*d) is
    employed that uses the same hash function (h0, h1, …., hd-1\. However, the estimation
    procedure of CMM is different from CMS. Rather than returning the minimum value
    from *d* counters, the estimated noise from these *d* counters is deducted and
    median of residues is returned. To compute noise in each *d* counters of a row,
    take average off all other counters in any row *i* except for the counters in
    any row *i*. Hence, the estimated noise for a counter is given by Eq.:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理CMS产生的偏差，[[70](bib.xhtml#ch00-bib-70)]的作者引入了CMS的变体称为计数均值最小（CMM）。作者指出，由于CMS的计数器被许多元素触摸，因此会出现误差。在这里，作者将这种误差称为噪声。值得注意的是，CMS输出最小噪声计数器。在CMM中，作者的目标是估计每个计数器产生的噪声。为了估计计数器的噪声，注意观察一行中未被问题元素触摸的其他计数器的值。在这里，假设每个元素在表的所有行中均匀且随机映射。未被元素触摸的每个计数器的值是一个独立的随机变量，并且遵循与噪声相同的分布模式。CMM的结构和更新过程与CMS类似。这里还使用了一个2-D表（w*d），它使用相同的哈希函数（h0、h1、…、hd-1）。但是，CMM的估计过程与CMS不同。不是从*d*个计数器中返回最小值，而是从这些*d*个计数器中估计的噪声中扣除并返回残差的中位数。要计算一行中*d*个计数器的噪声，请计算除该行中任何计数器之外的所有其他计数器的平均值。因此，计数器的估计噪声由以下方程给出：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>N</mi><mo>−</mo><mi>C</mi><mi>M</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(12.1)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>N</mi><mo>−</mo><mi>C</mi><mi>M</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(12.1)
- en: where, *N* is stream size,
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*N* 是数据流大小，
- en: '*CM[i, hi(q)]* is the counter for element *q* in row *i* and *i= o,1,…., d-1*,'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*CM[i, hi(q)]* 是第*i*行中元素*q*的计数器，*i= o,1,…., d-1*，'
- en: '*w* = sketch width'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '*w* = 笔记宽度'
- en: '*q* = Element in question'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*q* = 问题中的元素'
- en: 'This algorithm may also overestimate and the estimate count is given by median
    of:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法也可能会过度估计，其估计次数由中位数给出：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>C</mi><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>−</mo><mfrac><mrow><mi>N</mi><mo>−</mo><mi>C</mi><mi>M</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(12.2)
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>C</mi><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>−</mo><mfrac><mrow><mi>N</mi><mo>−</mo><mi>C</mi><mi>M</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>(12.2)
- en: for all *i* rows.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有*i*行。
- en: '[12.3 Count-sketch](contents.xhtml#rsec12_3)'
  id: totrans-651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[12.3 计数草图](contents.xhtml#rsec12_3)'
- en: 'Count-sketch is almost similar to CMS and it provides an estimate of frequency
    for any individual item. Actually, authors [[62](bib.xhtml#ch00-bib-62)] of count-sketch
    designed it to keep approximate count of highest frequency items in a stream.
    The difference between CMS and count-sketch two comes in the estimation process
    and in the nature of guaranteed accuracy for frequency estimate. Authors have
    proved that proposed algorithm is better than the sampling algorithm. Count sketch
    also employs a 2-D table of size *w*d* in size which is interpreted as array of
    *d* hash tables with each having *w* buckets. Different from CMS, rather than
    using a single hash function, two hash functions (*h and g*) are being used for
    each row of count sketch. Each hash functions <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><mn>......</mn><mo>,</mo><msub><mi>h</mi><mi>d</mi></msub></mrow></math>
    maps from *1,2,….,w* whereas <math alttext="" display="inline"><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>,</mo><msub><mi>s</mi><mn>2</mn></msub><mo>,</mo><mn>..........</mn><mo>,</mo><msub><mi>s</mi><mi>d</mi></msub></mrow></math>
    maps to -1, +1, i.e., either +1 or -1\. The operations supported by count-sketch
    are discussed as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: Count-sketch 几乎与 CMS 类似，并为任何单个项目提供频率估计。实际上，count-sketch 的作者[[62](bib.xhtml#ch00-bib-62)]设计它来在流中保持最高频率项目的近似计数。CMS
    和 count-sketch 的区别在于估计过程和频率估计的准确性保证的性质。作者已经证明所提出的算法比抽样算法更好。Count sketch 还使用大小为
    *w*d* 的二维表格，这被解释为具有 *w* 个桶的 *d* 个哈希表的数组。与 CMS 不同的是，count-sketch 每行不是使用单个哈希函数，而是使用两个哈希函数（*h*
    和 *g*）。每个哈希函数 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>,</mo><mn>......</mn><mo>,</mo><msub><mi>h</mi><mi>d</mi></msub></mrow></math>
    映射自 *1,2,….,w*，而 <math alttext="" display="inline"><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>,</mo><msub><mi>s</mi><mn>2</mn></msub><mo>,</mo><mn>..........</mn><mo>,</mo><msub><mi>s</mi><mi>d</mi></msub></mrow></math>
    映射到 -1 或 +1，即 +1 或 -1。Count-sketch 支持的操作如下讨论：
- en: 'Update(q, c): This operation updates an item *q* with count *c* to the count-sketch.
    For each hash table of array, compute the state of updated sketch as:'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Update(q, c): 此操作将项目 *q* 的计数 *c* 更新到 count-sketch 中。对于数组的每个哈希表，计算更新后的 sketch
    状态如下：'
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mo>*</mo><msub><mi>s</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo>></mo><mi>i</mi><mo>∈</mo><mo
    stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo stretchy="false">]</mo><mo>></mo><mi>a</mi><mi>n</mi><mi>d</mi><mo>></mo><mn>1</mn><mo><</mo><mi>k</mi><mo><</mo><mi>d</mi><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math>(12.3)
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mo>*</mo><msub><mi>s</mi><mi>i</mi></msub><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo>></mo><mi>i</mi><mo>∈</mo><mo
    stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo stretchy="false">]</mo><mo>></mo><mi>a</mi><mi>n</mi><mi>d</mi><mo>></mo><mn>1</mn><mo><</mo><mi>k</mi><mo><</mo><mi>d</mi><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math>（12.3）
- en: Introducing <math alttext="" display="inline"><mrow><mo>±</mo><mn>1</mn></mrow></math>
    can be helpful in better estimation for element *q* as it can better handle collision
    among elements. However, if an element *q* collides with multiple frequent elements,
    it wont result in good estimate for element *q* but in case of collision with
    infrequent elements impact of <math alttext="" display="inline"><mrow><mo>±</mo><mn>1</mn></mrow></math>
    is positive.
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引入<math alttext="" display="inline"><mrow><mo>±</mo><mn>1</mn></mrow></math>对元素*q*的更好估计可能会有所帮助，因为它可以更好地处理元素之间的碰撞。然而，如果元素*q*与多个频繁元素发生碰撞，则对元素*q*的估计不会很好，但在与不频繁元素发生碰撞的情况下，<math
    alttext="" display="inline"><mrow><mo>±</mo><mn>1</mn></mrow></math>的影响是积极的。
- en: 'Estimate(q): This operation find the approximate count of element *q* in sketch.
    To execute the operation take median of <math alttext="" display="inline"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="true">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="true">[</mo><mi>q</mi><mo stretchy="true">]</mo><mo>.</mo><msub><mi>s</mi><mi>k</mi></msub><mo
    stretchy="true">[</mo><mi>q</mi><mo stretchy="true">]</mo><mo stretchy="true">]</mo></mrow></math>
    where, <math alttext="" display="inline"><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo>]</mo></mrow></math>
    and <math alttext="" display="inline"><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>d</mi></mrow></math>.
    Authors have proved in results that the median is comparatively robust over mean.
    Moreover, mean is sensitive to the outliers.'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计（q）：该操作找到了草图中元素*q*的近似计数。要执行此操作，请取<math alttext="" display="inline"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="true">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="true">[</mo><mi>q</mi><mo stretchy="true">]</mo><mo>.</mo><msub><mi>s</mi><mi>k</mi></msub><mo
    stretchy="true">[</mo><mi>q</mi><mo stretchy="true">]</mo><mo stretchy="true">]</mo></mrow></math>的中位数，其中，<math
    alttext="" display="inline"><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo>]</mo></mrow></math>，而且<math
    alttext="" display="inline"><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>d</mi></mrow></math>。作者在结果中证明了中位数相对于均值具有较强的鲁棒性。此外，均值对异常值很敏感。
- en: However, the authors have not mentioned about delete operation anywhere in the
    base paper of count-sketch. Space consumed by Count-Sketch is <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mfrac><mn>1</mn><mrow><msup><mi>ϵ</mi><mn>2</mn></msup></mrow></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo
    stretchy="true">)</mo></mrow></math>. However, authors have ignored the space
    requirement of actual storage of elements from stream. Also, etting <math alttext=""
    display="inline"><mrow><mi>w</mi><mo>=</mo><mfrac><mn>2</mn><mrow><msup><mi>ϵ</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="true">(</mo><mfrac><mn>4</mn><mi>δ</mi></mfrac><mo stretchy="true">)</mo></mrow></math>
    achieves atmost error of <math alttext="" display="inline"><mrow><mi>ϵ</mi><mi>N</mi></mrow></math>
    with atleast probability of <math alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>δ</mi></mrow></math>
    where *N* is stream size. Notably, this algorithm generates overestimates as well
    as underestimate for a query.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 count-sketch 的基础论文中，作者并未提及删除操作。Count-Sketch 所消耗的空间为<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="true">(</mo><mfrac><mn>1</mn><mrow><msup><mi>ϵ</mi><mn>2</mn></msup></mrow></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>δ</mi></mfrac><mo
    stretchy="true">)</mo></mrow></math>。然而，作者忽略了流中元素的实际存储空间要求。此外，设置 <math alttext=""
    display="inline"><mrow><mi>w</mi><mo>=</mo><mfrac><mn>2</mn><mrow><msup><mi>ϵ</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
    和 <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo
    stretchy="true">(</mo><mfrac><mn>4</mn><mi>δ</mi></mfrac><mo stretchy="true">)</mo></mrow></math>
    可以实现至多<math alttext="" display="inline"><mrow><mi>ϵ</mi><mi>N</mi></mrow></math>的误差，至少有<math
    alttext="" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>δ</mi></mrow></math>的概率，其中*N*为流大小。值得注意的是，该算法对查询产生了高估和低估。
- en: Let's take an example to understand count-sketch more clearly. Consider a table
    with <math alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mn>6</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mn>4</mn></mrow></math>.
    The value of the hash function for each hash table is <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>h</mi><mn>2</mn><mo>=</mo><mo stretchy="true">(</mo><mn>2</mn><mo>*</mo><mi>i</mi><mo
    stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>
    and *g*1,*g*2 generate either <math alttext="" display="inline"><mrow><mo>−</mo><mn>1</mn></mrow></math>
    or <math alttext="" display="inline"><mrow><mo>+</mo><mn>1</mn></mrow></math>
    randomly for any incoming item. The result of elements after passing through hash
    function *h* and *g* is represented in [Table 12.3](#tab12_3). The operation <math
    alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo>,</mo><mn>2</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>16</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>
    in series has been represented in [Figs. 12.7](#fig12_7). Similarly, the operations
    <math alttext="" display="inline"><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo stretchy="true">)</mo></mrow></math> and <math
    alttext="" display="inline"><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo stretchy="true">)</mo></mrow></math> have
    been represented in [Fig. 12.8](#fig12_8) and [12.9](#fig12_9) respectively. It
    is clear from [Fig. 12.9](#fig12_9) that the query for element 12 results in over-estimation.
    Notably, the estimation query for count-sketch may result in under-estimation
    as well.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来更清楚地理解计数蓝图。考虑一个表，其中<math alttext="" display="inline"><mrow><mi>w</mi><mo>=</mo><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>d</mi><mo>=</mo><mn>4</mn></mrow></math>。每个哈希表的哈希函数值分别为<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>h</mi><mn>2</mn><mo>=</mo><mo stretchy="true">(</mo><mn>2</mn><mo>*</mo><mi>i</mi><mo
    stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>以及<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo>=</mo><mo
    stretchy="true">(</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="true">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>6</mn></mrow></math>，*g*1,*g*2对于任何输入项都会随机生成<math
    alttext="" display="inline"><mrow><mo>−</mo><mn>1</mn></mrow></math>或<math alttext=""
    display="inline"><mrow><mo>+</mo><mn>1</mn></mrow></math>。通过哈希函数*h*和*g*传递后的元素的结果在[表12.3](#tab12_3)中表示出来。连续执行<math
    alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo>,</mo><mn>2</mn><mo stretchy="true">)</mo></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>16</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>以及<math
    alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>在[图12.7](#fig12_7)中表示出来。类似地，操作<math
    alttext="" display="inline"><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo stretchy="true">)</mo></mrow></math>和<math
    alttext="" display="inline"><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo stretchy="true">)</mo></mrow></math>分别在[图12.8](#fig12_8)和[12.9](#fig12_9)中表示出来。从[图12.9](#fig12_9)可以清楚地看出，对元素12的查询结果是过估计的。值得注意的是，对计数蓝图的估计查询也可能导致欠估计。
- en: '**TABLE 12.3**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12.3**'
- en: Results of elements after passing through two hash functions *h* and *g*.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两个哈希函数 *h* 和 *g* 后元素的结果。
- en: '![Table 12.3](../images/tab12_3.jpg)![Figure 12.7](../images/fig12_7.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
  zh: '![表12.3](../images/tab12_3.jpg)![图12.7](../images/fig12_7.jpg)'
- en: '**FIGURE 12.7.**'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.7.**'
- en: Update operation in Count-sketch.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Count-sketch 中进行更新操作。
- en: '![Figure 12.8](../images/fig12_8.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8](../images/fig12_8.jpg)'
- en: '**FIGURE 12.8.**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.8.**'
- en: Estimate operation in count-sketch.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Count-sketch 中进行估算操作。
- en: '![Figure 12.9](../images/fig12_9.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9](../images/fig12_9.jpg)'
- en: '**FIGURE 12.9.**'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.9.**'
- en: Estimate operation in count-sketch representing over-estimate.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示过估算的 Count-sketch 中进行估算操作。
- en: '[12.4 Count-Min with Conservative Update Sketch](contents.xhtml#rsec12_4)'
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[12.4 采用保守更新的 Count-Min Sketch](contents.xhtml#rsec12_4)'
- en: 'The main logic behind the conservative update is “Minimal Increase” which only
    increment count with the minimum amount required to ensure that accuracy of the
    estimate remains. Counservative update (CU) can be applied to Count-Min-sketch
    and also to spectral BF. CM-CU sketch was introduced by authors of [[76](bib.xhtml#ch00-bib-76)]
    with an aim to reduce the false positive error in the result. Specifically, the
    authors of [[88](bib.xhtml#ch00-bib-88)] concluded that CMS with conservative
    update minimizes the over-estimation error by a factor of 1.5\. Similar to CMS,
    CM-CU also uses a 2-D table of size <math alttext="" display="inline"><mrow><mi>w</mi><mo>*</mo><mi>d</mi></mrow></math>
    where, *w* is the width and *d* is the depth of the table. Also, *k* hash functions
    equal to the depth of the table are used. For any incoming item, only the count
    by minimal amount will be incremented. However, the CM-CU sketch does not support
    deletion. The operations that are supported by CM-CU sketch are discussed as follows:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 保守更新背后的主要逻辑是“最小增量”，只有在确保估算的准确性的最小增量的情况下才会增加计数。保守更新（CU）可应用于 Count-Min-sketch，也可应用于频谱
    BF。 CMS 的保守更新（CM-CU）被作者在[[76](bib.xhtml#ch00-bib-76)] 中引入，目的是减少结果中的误报正错误。特别地，[[88](bib.xhtml#ch00-bib-88)]
    的作者得出结论，CMS 与保守更新最小化了超估计误差约 1.5 倍。与 CMS 类似，CM-CU 也使用大小为 <math alttext="" display="inline"><mrow><mi>w</mi><mo>*</mo><mi>d</mi></mrow></math>
    的二维表，其中，*w* 是表的宽度，*d* 是表的深度。还使用 *k* 个哈希函数，等于表的深度。对于任何传入的项，只会增加最小量的计数。然而，CM-CU
    Sketch 不支持删除。 CM-CU Sketch 支持的操作如下所述：
- en: 'Update (*q, c*): This operation adds an element *q* with count *c* to the sketch.
    To perform this operation, first, compute the approximate frequency of the element
    *q* from the existing state of the sketch by using the <math alttext="" display="inline"><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mi>q</mi><mo stretchy="true">)</mo></mrow></math> procedure
    explained for CMS, (i.e., by taking a minimum of the values returned from values
    indexed by *d* hash functions. Let''s call this value <math alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub></mrow></math>.
    Next, compare the values at *k* locations corresponding to *k* hash functions.
    Here, in CMS, the values at *k* locations are only incremented if the existing
    value in the sketch is less than <math alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub><mo>+</mo><mn>1</mn></mrow></math>,
    otherwise, the value won''t get changed. This type of conditional updation ensures
    that unnecessary updation and reduces over-estimation error. In order to update
    *q* with the count, *c* first compute <math alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub></mrow></math>
    using:'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '更新(*q, c*): 该操作将元素*q*与计数*c*添加到草图中。要执行此操作，首先从草图的现有状态中使用CMS中解释的<math alttext=""
    display="inline"><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mi>q</mi><mo stretchy="true">)</mo></mrow></math>过程计算元素*q*的近似频率（即通过取由*d*个哈希函数索引的值的最小值来完成此操作）。让我们将这个值称为<math
    alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub></mrow></math>。接下来，比较对应于*k*个哈希函数的*k*个位置的值。在这里，在CMS中，仅当草图中的现有值小于<math
    alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub><mo>+</mo><mn>1</mn></mrow></math>时，才会递增*k*个位置的值，否则值不会改变。这种条件更新类型确保了不必要的更新并减少了过度估计错误。为了使用以下方式更新*q*和计数*c*，首先计算<math
    alttext="" display="inline"><mrow><msub><mi>f</mi><mi>q</mi></msub></mrow></math>：'
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>f</mi><mi>q</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>k</mi></msub><mo>></mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>></mo><mo>∀</mo><mo>></mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>d</mi></mrow></mtd></mtr></mtable></mrow></math>(12.4)
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>f</mi><mi>q</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>k</mi></msub><mo>></mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>></mo><mo>∀</mo><mo>></mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>d</mi></mrow></mtd></mtr></mtable></mrow></math>(12.4)
- en: 'and update the count according o following equation:'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并根据以下方程式更新计数：
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>←</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>,</mo><msub><mi>f</mi><mi>q</mi></msub><mo>+</mo><mi>c</mi><mo>}</mo></mrow></mtd></mtr></mtable></mrow></math>(12.5)
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>←</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mi>s</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo
    stretchy="false">[</mo><mi>k</mi><mo>,</mo><msub><mi>h</mi><mi>k</mi></msub><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>,</mo><msub><mi>f</mi><mi>q</mi></msub><mo>+</mo><mi>c</mi><mo>}</mo></mrow></mtd></mtr></mtable></mrow></math>(12.5)
- en: '*Estimate(q)*: It follows the same procedure *Estimate(q)* as explained for
    CMS in [section 12.2](#sec12_2).'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*估计(q)*: 它遵循与[第12.2节](#sec12_2)中为 CMS 解释的相同程序 *Estimate(q)*。'
- en: The example for update operation has been represented in [Fig. 12.10](#fig12_10).
    Here, the operations <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo>,</mo><mn>2</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>16</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>
    in shown in series. The hash outputs for all these element has been shown in [Table
    12.2](#tab12_2). Similarly the operation Estimate(6) has been shown in [Fig. 12.11](#fig12_11).
    Experiments concluded that error rate is proportional to <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>M</mi></mfrac></mrow></math>
    where *M* is the available memory.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作示例已在 [图12.10](#fig12_10) 中表示。这里，操作 <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>12</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>5</mn><mo>,</mo><mn>2</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>16</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo
    stretchy="true">(</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo stretchy="true">)</mo></mrow></math>
    依次显示。所有这些元素的哈希输出在 [表12.2](#tab12_2) 中显示。类似地，操作 Estimate(6) 已在 [图12.11](#fig12_11)
    中显示。实验得出的结论是误差率与 <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mi>M</mi></mfrac></mrow></math>
    成正比，其中 *M* 是可用内存。
- en: '![Figure 12.10](../images/fig12_10.jpg)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10](../images/fig12_10.jpg)'
- en: '**FIGURE 12.10.**'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.10.**'
- en: Update operation in CM-CU sketch.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CM-CU 轮廓中的更新操作。
- en: '![Figure 12.11](../images/fig12_11.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11](../images/fig12_11.jpg)'
- en: '**FIGURE 12.11.**'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.11.**'
- en: Estimate operation in CM-CU sketch.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CM-CU 轮廓中估计操作。
- en: Activity
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: What is the main idea behind count-min with conservative update?
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保守更新的 count-min 背后的主要思想是什么？
- en: Minimal increase
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小增加
- en: Minimal decrease
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小减少
- en: Maximal increase
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大增加
- en: Maximal decrease
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大减少
- en: If a sketch employs a table of size <math alttext="" display="inline"><mrow><mi>t</mi><mo>*</mo><mi>b</mi></mrow></math>
    where *t* is number of rows and *b* is the number of columns, then how many hash
    functions are required in order to implement CMS?
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个草图使用大小为 <math alttext="" display="inline"><mrow><mi>t</mi><mo>*</mo><mi>b</mi></mrow></math>
    的表，其中 *t* 是行数，*b* 是列数，那么为了实现 CMS 需要多少个哈希函数？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo>+</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-692
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo>+</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo>*</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>t</mi><mo>*</mo><mi>b</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: Which measure of central tendency is used in order to execute query by count-sketch
    ?
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行计数草图查询，使用了哪种集中趋势度量？
- en: Mode
  id: totrans-697
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 众数
- en: Median
  id: totrans-698
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中位数
- en: Average
  id: totrans-699
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平均值
- en: Range
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围
- en: What is the impact on error rate with increase in width of 2-D array of CMS
    ?
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2-D CMS 数组宽度增加时的错误率影响是什么？
- en: Error rate will become high
  id: totrans-702
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误率会变高
- en: Error rate will get reduced
  id: totrans-703
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误率会降低
- en: Error could be high or low
  id: totrans-704
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误可能是高的或低的
- en: No relation between error rate and width of table
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误率与表的宽度之间没有关系
- en: Which of the following mentioned BF does not support deletion?
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下提到的 BF 中哪个不支持删除？
- en: Counting BF
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数 BF
- en: DBF
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DBF
- en: Stable BF
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定 BF
- en: Compressed BF
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩 BF
- en: Which among the following is the deterministic algorithm for frequency estimation?
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是用于频率估计的确定性算法？
- en: CMS
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMS
- en: HLL
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HLL
- en: Majority algorithm
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多数算法
- en: All of the above
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上全部
- en: What is the time complexity for updation operation in CMS?
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMS 中更新操作的时间复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>w</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>w</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math>
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="true">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>d</mi><mo
    stretchy="true">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></math>
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>s</mi><mo>_</mo><mi>s</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></math>
- en: What is the space requirement for CMS?
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMS 的空间需求是多少？
- en: Linear
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性
- en: Sub-linear
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚线性
- en: Super-linear
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超线性
- en: logarithmic
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数
- en: 1\. a  2\. b  3\. b  4\. b  5\. c  6\. c  7\. a  8\. b
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. a  2\. b  3\. b  4\. b  5\. c  6\. c  7\. a  8\. b
- en: <hgroup>
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[13](contents.xhtml#rchapter13)'
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[13](contents.xhtml#rchapter13)'
- en: '[Approximate Similarity Search Query Probabilistic Data Structures](contents.xhtml#rchapter13)'
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[近似相似性搜索查询概率数据结构](contents.xhtml#rchapter13)'
- en: </hgroup>
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[13.1 Introduction](contents.xhtml#rsec13_1)'
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[13.1 简介](contents.xhtml#rsec13_1)'
- en: Large datasets generated from a system may contain duplicates or near duplicates.
    Applying brute force technique to probe all possible combination can give exact
    nearest neighbor match, but this way is no scalable. Over and above, the traditional
    cluster analysis techniques (e.g., k-nearest neighbor) take quadratic or cubic
    time which seems unpractical for large datasets. Moreover, tree structure methods,
    such as- kd-trees, BDD trees etc. demands enough space and time as these methods
    compare given query with each record while searching to identify similar records
    [[83](bib.xhtml#ch00-bib-83)], [[106](bib.xhtml#ch00-bib-106)]. Hence, there is
    a demand for efficient similarity search method that can solve desired queries
    in low cost. To address this problem, researchers proposed using approximation
    techniques for high dimensional similarity search.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统生成的大型数据集可能包含重复或接近重复的数据。应用暴力技术来探索所有可能的组合可以得到精确的最近邻匹配，但这种方式是不可扩展的。此外，传统的聚类分析技术（例如，k-最近邻）需要二次或三次时间，对于大型数据集来说似乎不实用。而且，树结构方法，如
    kd 树、BDD 树等，需要足够的空间和时间，因为这些方法在搜索时将给定的查询与每个记录进行比较以识别相似的记录。因此，需要一种能以低成本解决所需查询的高效相似性搜索方法。为了解决这个问题，研究人员提出使用高维相似性搜索的近似技术。
- en: 'The data structure under this category approximates similarity search for high
    dimensional data. Sometimes, similarity search is also referred to as approximate
    nearest neighbor search or proximity search. In such type of problem, different
    features of interest e.g., text document, images are treated as points and a distance
    metric is used to identify similarity between two objects. The similarity search
    measure maps a pair of set to a similarity score in range [0,1]. Specifically,
    the aim here is to find duplicates or cluster of similar points in high dimensional
    attribute space. The use-cases for approximate similarity search includes finding
    similarity between web pages in the Internet, locating similar image or audio/video
    files, data deduplication, identifying plagiarism cases, identify variations in
    malware family etc. Mathematically, the problem is defined as: For a query *q*,
    the aim is to locate item *x* such that <math alttext="" display="inline"><mrow><mtext>dis</mtext><mo>(</mo><mi>q</mi><mo>,</mo><mi>x</mi><mo>)</mo><mo>≤</mo><mo>(</mo><mn>1</mn><mo>+</mo><mi>ϵ</mi><mo>)</mo><mi>d</mi><mi>i</mi><mi>s</mi><msup><mrow><mo
    stretchy="false">(</mo><mi>q</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>∗</mo></msup></mrow></math>
    where, *ϵ* is the at most estimated expected error [[212](bib.xhtml#ch00-bib-212)].'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类别下的数据结构近似于高维数据的相似性搜索。有时，相似性搜索也称为近似最近邻搜索或接近搜索。在这种类型的问题中，感兴趣的不同特征，如文本文档、图像被视为点，距离度量用于识别两个对象之间的相似性。相似性搜索度量将一对集合映射到范围为[0,1]的相似性分数。具体而言，这里的目标是在高维属性空间中找到重复项或相似点簇。近似相似性搜索的用例包括在互联网上查找网页之间的相似性，定位相似的图像或音频/视频文件，数据去重，识别抄袭案例，识别恶意软件家族的变体等。从数学上讲，该问题被定义为：对于查询*q*，目标是找到项目*x*，使得<math
    alttext="" display="inline"><mrow><mtext>dis</mtext><mo>(</mo><mi>q</mi><mo>,</mo><mi>x</mi><mo>)</mo><mo>≤</mo><mo>(</mo><mn>1</mn><mo>+</mo><mi>ϵ</mi><mo>)</mo><mi>d</mi><mi>i</mi><mi>s</mi><msup><mrow><mo
    stretchy="false">(</mo><mi>q</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>∗</mo></msup></mrow></math>，其中，*ϵ*是最多估计的预期误差[[212](bib.xhtml#ch00-bib-212)]。
- en: The fundamentals of approximate similarity also rely on hashing as hashing converts
    the data points to a low dimensional representation. Hash table lookup and fast
    distance approximation are two techniques of hashing to perform approximate nearest
    neighbor search. The former method uses a hash table as data structure that is
    comprised of buckets. Each item *x* is hashed to a bucket <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>. However,
    different from conventional hashing algorithm, here hash table aims to maximize
    probability of neighbor item collision. In contrast, the later computes the distance
    between given query and hash code of the reference item. Subsequently, the reference
    item having smallest distance are the candidates of nearest neighbor. Next, we
    will present the different types of approximate similarity search PDS.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 近似相似性的基本原理也依赖于哈希，因为哈希将数据点转换为低维表示。哈希表查找和快速距离近似是哈希的两种技术，用于执行近似最近邻搜索。前者方法使用哈希表作为数据结构，由桶组成。每个项目*x*都被哈希到一个桶<mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow>中。然而，不同于传统的哈希算法，这里的哈希表旨在最大化相邻项碰撞的概率。相反，后者计算给定查询和参考项的哈希码之间的距离。随后，具有最小距离的参考项是最近邻的候选项。接下来，我们将介绍近似相似性搜索PDS的不同类型。
- en: '[13.2 Minhashing](contents.xhtml#rsec13_2)'
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[13.2 最小哈希](contents.xhtml#rsec13_2)'
- en: 'Andrie Border introduced minhashing to detect duplicacy in web pages of AltaVista
    search engine [[53](bib.xhtml#ch00-bib-53)], [[54](bib.xhtml#ch00-bib-54)]. Minhash
    is based on the jaccard similarity notion to identify similarity between two sets.
    Jaccard similarity for two sets is the ratio of intersection to the union of two
    sets and is given by:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andrie Border引入了minhashing来检测AltaVista搜索引擎网页中的重复性[[53](bib.xhtml#ch00-bib-53)],
    [[54](bib.xhtml#ch00-bib-54)]。Minhash基于Jaccard相似性概念来识别两个集合之间的相似性。两个集合的Jaccard相似性是两个集合的交集与并集的比值，表示为:'
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>J</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mo>|</mo><msub><mi>S</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>S</mi><mn>2</mn></msub><mo>|</mo><mo>/</mo><mo>|</mo><msub><mi>S</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>S</mi><mn>2</mn></msub><mo>|</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math>(13.1)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>J</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mo>|</mo><msub><mi>S</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>S</mi><mn>2</mn></msub><mo>|</mo><mo>/</mo><mo>|</mo><msub><mi>S</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>S</mi><mn>2</mn></msub><mo>|</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math>(13.1)
- en: 'For example, take two small sets, <math alttext="" display="inline"><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>A</mi><mo>=</mo><mn>10</mn><mo>,</mo><mn>113</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>55</mn><mo>,</mo><mn>12</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>B</mi><mo>=</mo><mn>10</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>56</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>9</mn></mrow></math>.
    It can be noticed that there are 2 items in common between sets and there are
    total of 10 unique items in two sets. Therefore, the set A and B have a jaccard
    similarity of <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>9</mn></mfrac></mrow></math>.
    Although computing intersection and union between two set is an expensive operation.
    However, to compute similarity between documents, documents can also be represented
    as sets. Shingling is one of the popular way to convert a document into set. *k*-shingles
    is defined as set of all possible *k* size non repeatable substrings of the given
    document. A document with *n* words, having set of *k*-shingles consumes <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> space. Suppose a document is made up of
    a small sentence “Clustering large number of binary program is a difficult task”.
    So, 5 word long shingles are:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，取两个小集合，<math alttext="" display="inline"><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>A</mi><mo>=</mo><mn>10</mn><mo>,</mo><mn>113</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>55</mn><mo>,</mo><mn>12</mn></mrow></math>
    和 <math alttext="" display="inline"><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>B</mi><mo>=</mo><mn>10</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>56</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>9</mn></mrow></math>。可以注意到这两个集合之间有2个共同项，两个集合中总共有10个唯一项。因此，集合
    A 和 B 的 Jaccard 相似度为 <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>9</mn></mfrac></mrow></math>。尽管计算两个集合之间的交集和并集是一项昂贵的操作。然而，为了计算文档之间的相似性，文档也可以表示为集合。Shingling
    是将文档转换为集合的一种流行方式之一。*k*-shingles 被定义为给定文档的所有可能的 *k* 大小的不可重复子字符串的集合。一个由 *n* 个单词组成的文档，具有
    *k*-shingles 的集合占用 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> 的空间。假设一个文档由一个小句组成：“对大量的二进制程序进行聚类是一个困难的任务”。因此，5
    个词长的 shingles 为:'
- en: Clustering large number of binary
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对大量的二进制进行聚类
- en: large number of binary program
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量的二进制程序
- en: number of binary program is
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制程序的数量是
- en: of binary program is a
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制程序的数量是一个
- en: binary program is a difficult
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制程序是一个困难的
- en: program is a difficult task
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程是一个困难的任务
- en: 'Therefore, the document as a set is: (“Clustering large number of binary”,
    “large number of binary program”, “number of binary program is”, “of binary program
    is a”, “binary program is a difficult”, “program is a difficult task”). Time complexity
    to compute jaccard similarity is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>
    as there are total of <math alttext="" display="inline"><mrow><mfrac><mrow><mi>n</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow></math>
    comparisons.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，文档作为一个集合是：（“聚类大量的二进制”，“大量的二进制程序”，“二进制程序的数量”，“二进制程序是一个”，“二进制程序是一个困难的”，“程序是一个困难的任务”）。
    计算Jaccard相似性的时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math> ，因为总共有<math alttext="" display="inline"><mrow><mfrac><mrow><mi>n</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow></math>
    次比较。
- en: 'Moreover, the large collection of set can also be represented by a single boolean
    matrix. To represent set as boolean matrix, rows of the matrix contain elements
    of universal set whereas column of the matrix contains all sets. The entry in
    row *r* and column *c* is 1 if and only if set of row *r* is a member of column
    *c*, otherwise the entry is zero. In this case, column similarity is the jaccard
    similarity of the set having rows with column value 1\. To understand this, consider
    three columns C1, C2, C3 with values: From [Table 13.1](#tab13_1) <math alttext=""
    display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>
    as there are two rows in column C1 and C2 where both entries 1\. Therefore, intersection
    of set that column C1 and C2 represent is 2\. Also, there are rows where atleast
    one column has 1\. So, the union of represented set is 5\. Hence, the jaccard
    similarity is <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>
    which is 40%. Similarly, <math alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow></math>.
    Notably, this matrix is not sparse and calculating jaccard similarity for this
    case is quite simple. However, with this representation the resultant matrix is
    sparse, i.e., it has more zeros than one which is a overhead for the memory. From
    [Table 13.1](#tab13_1) <math alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>
    as there are wo rows in column C1 and C2 where both entries 1\. Therefore, intersection
    of set that column C1 and C2 represent is 2\. Also, there are rows where atleast
    one column has 1\. So, the union of represented set is 5\. Hence, the jaccard
    similarity is <math alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>
    which is 40%. Similarly, <math alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow></math>.
    Notably, this matrix is not sparse and calculating jaccard similarity for this
    case is quite simple. However, with this representation the resultant matrix is
    sparse, i.e., it has more zeros than one which is a overhead for the memory. Minhash
    algorithm provides a way for fast approximation to jaccard similarity of two sets.
    In order to implement minhashing, for each set minhash signature is computed and
    saved in signature matrix. The computed minhash signature has a fixed length and
    it is independent to the size of set. Signature matrix of minhash is made up of
    *h* rows that signifies number of hash functions and *c* columns which is equal
    to total number of sets. The signature matrix is useful as it provides almost
    same similarity as that of boolean matrix but with quite less storage space.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一组大集合也可以用一个布尔矩阵表示。为了将集合表示为布尔矩阵，矩阵的行包含通用集合的元素，而矩阵的列包含所有集合。矩阵的第*r*行和第*c*列的条目仅当行*r*的集合是列*c*的成员时为1，否则为零。在这种情况下，列相似性是具有列值为1的行的Jaccard相似性。为了理解这一点，考虑具有值的三列C1、C2、C3：从[Table
    13.1](#tab13_1) <math alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>，因为列C1和C2都有两行条目为1。因此，列C1和C2代表的集合的交集为2。此外，有行至少有一列为1。因此，表示的集合的并集为5。因此，Jaccard相似性为<math
    alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>，即40%。同样，<math
    alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow></math>。值得注意的是，这个矩阵不是稀疏的，计算这种情况的Jaccard相似性是相当简单的。然而，用这种表示的结果矩阵是稀疏的，即它的零元素比1多，这对内存来说是一种负担。从[Table
    13.1](#tab13_1) <math alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>，因为列C1和C2都有两行条目为1。因此，列C1和C2代表的集合的交集为2。此外，有行至少有一列为1。因此，表示的集合的并集为5。因此，Jaccard相似性为<math
    alttext="" display="inline"><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math>，即40%。同样，<math
    alttext="" display="inline"><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mn>
- en: '**TABLE 13.1**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13.1**'
- en: Understanding minhashing.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 理解最小哈希。
- en: '| C1 | C2 | C3 |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| C1 | C2 | C3 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 0 | 0 | 0 |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: Randomly permute rows.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机排列行。
- en: Compute minhash value, <math alttext="" display="inline"><mrow><mi>M</mi><mi>H</mi><mo
    stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></math> =index
    of first row (after permutation) with 1 in column *C*.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算最小哈希值，<math alttext="" display="inline"><mrow><mi>M</mi><mi>H</mi><mo stretchy="false">(</mo><mi>C</mi><mo
    stretchy="false">)</mo></mrow></math> =在列 *C* 中第一个含 1 的行的索引（在排列后）。
- en: Similarly, use multiple independent hash function and create a signature for
    each column so that signature matrix has *h* rows. These minhash functions are
    selected once and same set of minhash functions is applied to each column. Notably,
    large matrix produce less errors.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，使用多个独立的哈希函数，并为每个列创建一个签名，使得签名矩阵有 *h* 行。这些最小哈希函数只选取一次，并且相同的最小哈希函数集应用于每个列。值得注意的是，大矩阵产生较少的错误。
- en: Sim(C1, C2)= Sim(Sig(C1), Sig(C2), i.e., similarity between two sets is fraction
    of permutations where minhash value agree.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sim(C1, C2)= Sim(Sig(C1), Sig(C2)，即，两个集合之间的相似性是最小哈希值相符的排列分数。
- en: 'Lets understand this concept with an example. Consider a input matrix with
    5 columns and 7 rows as shown in [Fig. 13.1](#fig13_1). These columns are permuted
    thrice in order P1, P2, P3\. So, resultant signature matrix has 3 rows (each corresponding
    to one permutation) and 5 column. The minhash value for permutation 1 has value
    <math alttext="" display="inline"><mrow><mn>2</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>3</mn><mo>−</mo><mn>4</mn></mrow></math>
    for each 5 column respectively and the reason is discussed as follows: The row
    5 is first in order and row 4 is second and so on. Clearly, row 5 has 1 in second
    column and hence column second has got its first minhash value, next row 4 is
    analyzed. As row 4 has 1 for columns 1 and 3 and neither of these column has been
    assigned a value yet. So, both of these columns get a value of 2 in signature
    matrix. Next, row 2 is scanned and it has 1 for columns 2 and 4\. As, column 2
    is already having a minhash value, so only column 4 will get a value of 3 in signature
    matrix. Similarly, column 5 gets value 4\. Notably, we have discovered minhash
    value for each column so there is no point of moving further.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。考虑一个有 5 列 7 行的输入矩阵，如[图 13.1](#fig13_1)所示。这些列按顺序P1、P2、P3进行了三次排列。因此，结果签名矩阵有
    3 行（每行对应一个排列）和 5 列。排列 1 的最小哈希值分别为<math alttext="" display="inline"><mrow><mn>2</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>3</mn><mo>−</mo><mn>4</mn></mrow></math>，原因如下所述：第
    5 行是第一个顺序，第 4 行是第二个，依此类推。显然，第 5 行在第二列中有 1，因此第二列在签名矩阵中得到了其第一个最小哈希值，接下来分析第 4 行。由于第
    4 行的列 1 和 3 都为 1，并且这两列尚未被分配值。因此，这两列在签名矩阵中都得到了值 2。接下来，扫描第 2 行，它在第 2 和第 4 列中有 1。由于第
    2 列已经有一个最小哈希值，因此只有第 4 列在签名矩阵中得到了值 3。类似地，第 5 列得到值 4。值得注意的是，我们已经发现了每列的最小哈希值，因此没有继续移动的必要。
- en: '![Figure 13.1](../images/fig13_1.jpg)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1](../images/fig13_1.jpg)'
- en: '**FIGURE 13.1.**'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.1.**'
- en: Understanding minhashing.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 理解最小哈希。
- en: '**Surprising property**'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '**令人惊讶的特性**'
- en: 'If we consider all possible permutations of the rows then it is observed that:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑所有可能的行排列，则观察到：
- en: <math alttext="" display="inline"><mrow><mi>P</mi><mo stretchy="false">[</mo><mi>M</mi><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>M</mi><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo
    stretchy="false">]</mo><mo>=</mo><mi>J</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>P</mi><mo stretchy="false">[</mo><mi>M</mi><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>M</mi><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo
    stretchy="false">]</mo><mo>=</mo><mi>J</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>
- en: Unfortunately, with large dataset, its difficult to pick random permutation.
    Moreover, representing random permutations for large entries require huge amount
    of space. Also, accessing rows in order of any of these permutations requires
    many disc access to get each row which is clearly time consuming.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于大型数据集，随机排列很难选择。此外，为大量条目表示随机排列需要大量空间。此外，按照任何这些排列之一的顺序访问行需要许多磁盘访问以获取每行，这显然是耗时的。
- en: Lets look at a better implementation of minhashing. The idea is to simulate
    permutations without actually permuting rows. Here in this implementation, a normal
    hash function <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math> for each minhash function is chosen that
    hashes integer to some bucket. We assume that position of row *r* in the permutation
    is <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mo
    stretchy="false">)</mo></mrow></math>. Following steps are taken to obtain a signature
    matrix.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下更好的最小哈希实现。其思想是模拟排列而不实际对行进行排列。在这个实现中，为每个最小哈希函数选择了一个普通的哈希函数<math alttext=""
    display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></math>，将整数哈希到某个桶中。我们假设排列中行*r*的位置为<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mo
    stretchy="false">)</mo></mrow></math>。下面是获取签名矩阵的步骤。
- en: Rather than permuting rows, pick some number of ordinary hash functions, one
    corresponding to each minhash function we want to simulate.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是对行进行排列，选择一些普通的哈希函数，每个哈希函数对应我们想模拟的每个最小哈希函数。
- en: For each column *C* and each hash function <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math>,
    keep a slot <math alttext="" display="inline"><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow></math>. For example, number of slots is <math alttext=""
    display="inline"><mrow><mn>100</mn><mo>*</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi></mrow></math>.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个列*C*和每个哈希函数<math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math>，保持一个插槽<math
    alttext="" display="inline"><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow></math>。例如，插槽的数量是<math alttext="" display="inline"><mrow><mn>100</mn><mo>*</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi></mrow></math>。
- en: Initialize all slots <math alttext="" display="inline"><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow></math> to infinity.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有插槽<math alttext="" display="inline"><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow></math>初始化为无穷大。
- en: To compute minhash signature, <math alttext="" display="inline"><mrow><mi>M</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></math>
    should alwayz contain the smallest value of <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></math> for
    those column *C* has 1 in row *r*.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算最小哈希签名，<math alttext="" display="inline"><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow></math> 应始终包含对于那些列 *C* 在行 *r* 中有 1 的最小值 <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>r</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: '**Algorithm 4** Minhash algorithm'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 4** 最小哈希算法'
- en: The algorithm for above discussed method has been shown in algorithm 4.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的算法已在算法 4 中显示。
- en: '1: **for** each row r **do**'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '1: **对于** 每一行 r **执行**'
- en: 2:**for** each hash function **do**
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 2:**对于** 每一个哈希函数 **执行**
- en: 3:compute <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></math>;
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 3:计算 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></math>;
- en: 4:**for** each column c **do**
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 4:**对于** 每一列 c **执行**
- en: 5:**if** c has 1 in row r **then**
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 5:**如果** 列 c 在行 r 中有 1 **那么**
- en: 6:**for** each hash function <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math>
    **do**
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 6:**对于** 每一个哈希函数 <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math>
    **执行**
- en: 7:**if** hi(r) ¡ M(i,c) **then** M(i,c) ← hi(r);
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 7:**如果** hi(r) ¡ M(i,c) **那么** M(i,c) ← hi(r);
- en: 8:**end if**
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 8:**结束 如果**
- en: 9:**end for**
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 9:**结束 for**
- en: 10:**end if**
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 10:**结束 如果**
- en: 11:**end for**
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 11:**结束 for**
- en: 12:**end for**
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 12:**结束 for**
- en: '13: **end for**'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '13: **结束 for**'
- en: This implementation is fast as well as uses fixed memory footprint. Although
    signature matrix consumes comparatively less space to represent document signature
    but it still takes <math alttext="" display="inline"><mrow><mfenced close=")"
    open="("><mtable><mtr><mtd><mi>n</mi></mtd></mtr><mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced><mo
    stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math> approximate time
    for finding similar pair of comparison. To understand this concept with example,
    consider a matrix with 2 columns and 5 rows as represented in [Fig. 13.2](#fig13_2).
    Two hash functions are used here, i.e., <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>5</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>5</mn></mrow></math>.
    Hence, final signature matrix will be of length 2.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现既快速又使用固定的内存占用。尽管签名矩阵相对较少地占用空间来表示文档签名，但仍需要 <math alttext="" display="inline"><mrow><mfenced
    close=")" open="("><mtable><mtr><mtd><mi>n</mi></mtd></mtr><mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced><mo
    stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math> 的近似时间来找到相似的比较对。要通过示例理解这个概念，请考虑一个具有
    2 列和 5 行的矩阵，如 [图 13.2](#fig13_2) 中所示。这里使用了两个哈希函数，即 <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>5</mn></mrow></math>
    和 <math alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>5</mn></mrow></math>。因此，最终的签名矩阵将长度为
    2。
- en: '![Figure 13.2](../images/fig13_2.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2](../images/fig13_2.jpg)'
- en: '**FIGURE 13.2.**'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 13.2.**'
- en: Understanding minhashing.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 理解最小哈希（minhashing）。
- en: Initially all slots are infinity. The first row has 1 for column 1 and 0 in
    column 2\. So, both of the component for column 2 has not changed and it remains
    infinity but first column value will get changed to values of <math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> i.e., 1 and 3\. Now, consider second row
    where both columns has 1 and <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></math>. Simply for column 2,
    infinity values are replaced with hash values whereas for column 1 <math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>></mo><mi>h</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> so,
    this value will not changed and <math alttext="" display="inline"><mrow><mi>g</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo><</mo><mi>g</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> so,
    second component here will get changed to 0\. As minhash function uses minimum
    value encountered for each hash function. Hence, the name minhash is defendable.
    Likewise, other rows are observed and final signature matrix for both columns
    are shown in [Fig. 13.2](#fig13_2). Code 13.4 presents Python implementation using
    built-in hash function and *h* bitwise XOR masks for doing hashing.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，所有槽都是无穷大。第一行在第一列为 1，在第二列为 0。因此，第二列的组件都没有改变，仍然是无穷大，但是第一列的值会被改变为<math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math>和<math
    alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>的值，即 1 和 3。现在，考虑第二行，两列的值都为 1，<math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></math>。简单来说，对于第二列，无穷大的值被哈希值取代，而对于第一列<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>2</mn><mo
    stretchy="false">)</mo><mo>></mo><mi>h</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>，所以这个值不会改变，<math alttext="" display="inline"><mrow><mi>g</mi><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo><</mo><mi>g</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math>，所以第二个组件的值将被改变为
    0。由于 minhash 函数使用每个哈希函数遇到的最小值，因此 minhash 这个名字是有道理的。同样，观察其他行，最终的列签名矩阵分别显示在[图13.2](#fig13_2)中。代码
    13.4 展示了使用内置哈希函数和 *h* 按位异或掩码进行哈希的 Python 实现。
- en: '![](../images/list13_1.jpg)![](../images/list13_2a.jpg)![](../images/list13_2b.jpg)![](../images/list13_2c.jpg)![](../images/list13_3a.jpg)![](../images/list13_3b.jpg)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list13_1.jpg)![](../images/list13_2a.jpg)![](../images/list13_2b.jpg)![](../images/list13_2c.jpg)![](../images/list13_3a.jpg)![](../images/list13_3b.jpg)'
- en: '[13.3 Locality Sensitive Hashing](contents.xhtml#rsec13_3)'
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[13.3 局部敏感哈希](contents.xhtml#rsec13_3)'
- en: 'Locality Sensitive Hashing (LSH) aims to find nearest data points to the given
    query. Here, also hash tables are utilized to find close enough match. Detecting
    plagiarism, classifiaction by topic, recommendation systems, entity resolution,
    genome-wide association study, audio-video fingerprinting, etc. are some of the
    key areas where LSH is used. The idea that LSH uses is “repurpose collisions”
    which states rather than avoiding collisions, make collisions happen for nearly
    data points. So, in LSH nearby or close enough data points are made to be fall
    in same bucket and distant data points in different buckets. More formally, the
    algorithm selects a hash family *H* and this hash family is locality sensitive
    if:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 局部敏感哈希（LSH）旨在找到与给定查询最近的数据点。在这里，也利用了哈希表来找到足够接近的匹配项。检测抄袭、按主题分类、推荐系统、实体解析、全基因组关联研究、音视频指纹等是LSH被使用的一些关键领域。LSH使用的思想是“重用碰撞”，即与其避免碰撞，不如使几乎相邻的数据点发生碰撞。因此，在LSH中，附近或足够接近的数据点被放在同一个桶中，而远离的数据点被放在不同的桶中。更正式地说，算法选择了一个哈希族*H*，如果这个哈希族是局部敏感的，则：
- en: <math alttext="" display="inline"><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></math>
    is high if *A* is close enough to *B*
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 当*A*足够接近*B*时，<math alttext="" display="inline"><mrow><mi>P</mi><mi>r</mi><mo
    stretchy="false">[</mo><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></math>较高。
- en: <math alttext="" display="inline"><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></math>
    is low if *A* is far away from *B*
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 当*A*远离*B*时，<math alttext="" display="inline"><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></math>较低。
- en: LSH is an idea of hashing items many times and comparing only those that fall
    into same bucket even atleast once. However, LSH doesn't guarantee to provide
    exact answers but they give a good approximation. In order to implement LSH,
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: LSH是一个多次对项目进行哈希处理并仅比较至少一次落入同一桶中的项目的想法。然而，LSH不能保证提供精确的答案，但它们给出了一个很好的近似值。为了实现LSH，
- en: First step is to perform shingling on the set of given documents.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是对给定文档集进行shingling处理。
- en: Second step is to perform minhashing that outputs short integer representation
    of sets in form of signatures.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是执行minhashing，以签名形式输出集合的短整数表示。
- en: Notably, minhashing converts large sets to short signatures using hashing, while
    preserving similarity whereas LSH further finds pairs of signature that are likely
    to be similar.
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，minhash 将大型集合转换为使用哈希的短签名，同时保留相似性，而 LSH 进一步找到可能相似的签名对。
- en: Third step is to perform locality sensitive hashing that aims to find a small
    list of candidate pairs of signatures that are only evaluated for similarity check.
    Rather than probing all pair of a set for similarity check, only a list of candidate
    pairs are evaluated. To the minhash signature matrix, columns are hashed to different
    buckets using several hash functions and the documents that hashes to same bucket
    even for once are referred to as candidate pair.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三步是执行局部敏感哈希，旨在找到一小部分仅用于相似性检查的签名候选对列表。而不是针对一组所有对进行相似性检查，只对一小部分候选对进行评估。对于minhash签名矩阵，使用多个哈希函数将列哈希到不同的桶中，并且即使一次也将哈希到相同桶的文档被称为候选对。
- en: Rather than detecting completely similar documents, LSH finds similarity greater
    than *t* between documents. So, two columns C1 and C2 of min-hash signatures matrix
    are candidate pairs if their signatures agree for atleast fraction *t* of their
    signatures of rows. to perform hashing of a single column,
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LSH 不是检测完全相似的文档，而是找到文档之间大于*t*的相似度。因此，如果 min-hash 签名矩阵的两列 C1 和 C2 在至少*t*的行签名中的签名一致，则两列是候选对。要对单个列执行哈希，
- en: First partition signature matrix into *b* bands, having *r* rows per band.
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先将签名矩阵分成*b*个带，每个带有*r*行。
- en: Hash each band of each column in any of *k* buckets. For better efficiency,
    take *k* as large as possible.
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何*k*个桶中的每个列的每个带中哈希。为了更高效，尽可能取大的*k*。
- en: Identify the candidate pair that hashes to same bucket for atleast 1 band.
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别哈希到至少 1 个带的相同桶的候选对。
- en: '*b* and *r* should be selected to achieve most similar pairs and few non-similar
    pairs and also to eliminate false positives and false negatives. The more insight
    on choosing *b* and *r* is discussed next.'
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应选择*b*和*r*以实现最相似的对和少数不相似的对，同时消除误报和漏报。下面讨论了选择*b*和*r*的更多见解。
- en: The concept of band partition and hash function computation of one band is represented
    in [Fig. 13.3](#fig13_3) and [13.4](#fig13_4).
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个带的带分区和哈希函数计算的概念在[图 13.3](#fig13_3)和[13.4](#fig13_4)中表示。
- en: Finally, main memory is accessed to test whether candidate pairs have really
    similar signatures.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，访问主内存以测试候选对是否真的具有相似的签名。
- en: '![Figure 13.3](../images/fig13_3.jpg)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3](../images/fig13_3.jpg)'
- en: '**FIGURE 13.3.**'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 13.3.**'
- en: Band partition in LSH.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: LSH 中的带分区。
- en: '![Figure 13.4](../images/fig13_4.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4](../images/fig13_4.jpg)'
- en: '**FIGURE 13.4.**'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 13.4.**'
- en: Hash function for one band.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带的哈希函数。
- en: Observation
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 观察
- en: For a 100 row signature matrix, if we choose 25 bands of 4 signature per band
    then there is higher probability for two given documents to fall in same hash
    buckets as the two documents will be hashed 20 times (one for each band) and only
    few signatures are getting compared in each band, i.e., only 5 as compared to
    another case with 10 bands of 10 signatures per band. Hence, there is higher chance
    for false positives if higher number of bands are selected. In contrast, chances
    of false negatives increases if we chose a lower value of number of bands.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包含 100 行的签名矩阵，如果我们选择 25 个 4 个签名的组，则两个给定文档落入相同哈希桶的概率较高，因为这两个文档将被哈希 20 次（每个组一次），并且每个组中只有少数签名进行比较，即仅有
    5 个，与每个组有 10 个签名的 10 个组相比。因此，如果选择更多的组，误报的可能性就更高。相反，如果选择的组数较低，则误报的可能性会增加。
- en: 'Suppose there are 100,000 column and 100 rows in signature matrix which implies
    size of signature matrix is 100*100000\. Lets assume number of bands chosen are
    20 with 5 signature per band. To understand existence of false positives and false
    negatives consider two cases:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 假设签名矩阵中有 100,000 列和 100 行，这意味着签名矩阵的大小为 100*100000。假设选择的组数为 20，每组有 5 个签名。为了理解误报和漏报的存在，考虑两种情况：
- en: '**Case 1**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例 1**'
- en: Assume similarity threshold to be 80%, i.e., we want to retrieve all documents
    that are 80%similar pairs.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 假设相似度阈值为 80%，即我们希望检索出所有 80% 相似的文档对。
- en: 'Probability that two columns C1, C2 are identical in one particular band: <math
    alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>0.8</mn><mo
    stretchy="false">)</mo></mrow><mn>5</mn></msup><mo>=</mo><mn>0.32768</mn></mrow></math>.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '两列 C1、C2 在特定组中相同的概率: <math alttext="" display="inline"><mrow><msup><mrow><mo
    stretchy="false">(</mo><mn>0.8</mn><mo stretchy="false">)</mo></mrow><mn>5</mn></msup><mo>=</mo><mn>0.32768</mn></mrow></math>。'
- en: 'Probability that two columns C1, C2 are not identical in any of the 20 bands:
    <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.328</mn><mo
    stretchy="false">)</mo></mrow><mrow><mn>20</mn></mrow></msup><mo>=</mo><mn>0.00035</mn></mrow></math>.
    which implies about <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mrow><mn>3000</mn></mrow></mfrac></mrow></math>
    th of truly 80% similar sets are false negatives.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '两列 C1、C2 在任何 20 个组中都不相同的概率: <math alttext="" display="inline"><mrow><msup><mrow><mo
    stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.328</mn><mo stretchy="false">)</mo></mrow><mrow><mn>20</mn></mrow></msup><mo>=</mo><mn>0.00035</mn></mrow></math>，这意味着大约
    <math alttext="" display="inline"><mrow><mfrac><mn>1</mn><mrow><mn>3000</mn></mrow></mfrac></mrow></math>
    的真正 80% 相似集合是误报的否定。'
- en: '**Case 2**'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例 2**'
- en: Take another case for two documents to be 40% similar.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个两个文档相似度为 40% 的情况。
- en: 'Probability that two columns C1, C2 are identical in one particular band: <math
    alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>0.4</mn><mo
    stretchy="false">)</mo></mrow><mn>5</mn></msup><mo>=</mo><mn>0.01</mn></mrow></math>.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '两列 C1、C2 在特定组中相同的概率: <math alttext="" display="inline"><mrow><msup><mrow><mo
    stretchy="false">(</mo><mn>0.4</mn><mo stretchy="false">)</mo></mrow><mn>5</mn></msup><mo>=</mo><mn>0.01</mn></mrow></math>。'
- en: 'So, probability that two columns C1, C2 are identical in atleast one of 20
    bands: <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mo
    stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.01</mn><mo stretchy="false">)</mo><mo
    stretchy="false">)</mo><mo>=</mo><mn>0.19</mn></mrow></math>. which implies that
    there is about 20% probability of false positives.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，两列 C1、C2 至少在 20 个带中的一个中相同的概率为：<math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.01</mn><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0.19</mn></mrow></math>。这意味着假阳性的概率约为
    20%。
- en: Therefor *b* and *r* should be selected to achieve minimum rate of false positives
    and false negatives.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应选择 *b* 和 *r* 以达到最低的假阳性和假阴性率。
- en: '![](../images/list13_4a.jpg)![](../images/list13_4b.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list13_4a.jpg)![](../images/list13_4b.jpg)'
- en: '[13.3.1 Simhash](contents.xhtml#rsec13_3_1)'
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[13.3.1 Simhash](contents.xhtml#rsec13_3_1)'
- en: Simhash is a variant of LSH and unlike typical cryptographic algorithm, simhash
    also tries to maximize the probability of collision for almost similar item [[62](bib.xhtml#ch00-bib-62)].
    It was proposed by Moses Chankar in order to detect near duplicate documents.
    Simhashing is based on the concept of sign random projection [[34](bib.xhtml#ch00-bib-34)].
    It basically reduces dimensionality of data and maps highly dimensional data to
    *f*-bit fingerprint (*f* is very small generated from hashing).
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: Simhash 是 LSH 的一种变体，与典型的加密算法不同，Simhash 还试图使几乎相似的项目发生碰撞的概率最大化 [[62](bib.xhtml#ch00-bib-62)]。它由摩西·尚卡尔提出，用于检测近似重复的文档。Simhash
    基于符号随机投影的概念 [[34](bib.xhtml#ch00-bib-34)]。它基本上降低了数据的维度，并将高维数据映射到 *f* 位指纹 (*f*
    是从哈希生成的非常小的值)。
- en: 'Simhash fingerprint is usally generated from any feature of document. The document
    feature is generally *k*-word shingles or frequency of word. To compute simhash
    fingerprint, follow the steps below:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: Simhash 指纹通常是从文档的任何特征生成的。文档特征通常是 *k* -word shingles 或单词频率。要计算 simhash 指纹，请按照以下步骤进行：
- en: Generate the features of documents.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档的特征。
- en: Select a hash size *f* (8,16, 32.. etc.) and maintain a *f*-dimensional vector
    *V* and initialize all dimensions of vector to 0.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个哈希大小 *f*（8,16,32 等），并维护一个 *f* 维向量 *V*，并将向量的所有维度初始化为 0。
- en: Hash each feature to *f*-bit hash value (These unique f-bits of each feature
    increments/decrements the final *f* value of vector).
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个特征哈希到 *f* 位哈希值（每个特征的这些唯一的 f 位增加/减少向量的最终 *f* 值）。
- en: 'For each unique *f*-bit hash value:'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个唯一的 *f* 位哈希值：
- en: <math alttext="" display="inline"><mrow><mi>i</mi><mi>f</mi><mi>b</mi><mi>i</mi><msub><mi>t</mi><mi>i</mi></msub><mi>o</mi><mi>f</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mo>,</mo><mi>a</mi><mi>d</mi><mi>d</mi><mn>1</mn><mi>t</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>f</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo
    stretchy="false">(</mo><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-836
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>i</mi><mi>f</mi><mi>b</mi><mi>i</mi><msub><mi>t</mi><mi>i</mi></msub><mi>o</mi><mi>f</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mo>,</mo><mi>a</mi><mi>d</mi><mi>d</mi><mn>1</mn><mi>t</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>f</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo
    stretchy="false">(</mo><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo
    stretchy="false">)</mo></mrow></math>
- en: '*elsifbitiofhashisnotset*,*substract*1*fromV[i]*'
  id: totrans-837
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果哈希的位iof未设置*，*则从V[i]中减去1*。'
- en: Final simhash bit vector has
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的 simhash 位向量为
- en: <math alttext="" display="inline"><mrow><mi>b</mi><mi>i</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></math>
    as 1 if <math alttext="" display="inline"><mrow><mi>V</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mn>0</mn></mrow></math>
    and 0 otherwise.
  id: totrans-839
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 <math alttext="" display="inline"><mrow><mi>V</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mn>0</mn></mrow></math>
    时，<math alttext="" display="inline"><mrow><mi>b</mi><mi>i</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></math>
    设为1，否则设为0。
- en: For example, take a sentence “Data Structures”.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，取一句话“数据结构”。
- en: First, convert all higher case word to lower case word and divide into 3- word
    shingles, i.e., ‘dat’, ‘ata’, ‘tas’, ‘ast’, ‘str’, ‘tru’, ‘ruc’, ‘uct’, ‘ctu’,
    ‘tur’, ‘ure’, ‘res’.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将所有大写单词转换为小写单词，并分成3个单词的shingles，即“dat”，“ata”，“tas”，“ast”，“str”，“tru”，“ruc”，“uct”，“ctu”，“tur”，“ure”，“res”。
- en: Hash each shingle
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每个shingle进行哈希
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110000</mn></mrow></math>
  id: totrans-843
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110000</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mi>t</mi><mi>a</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10100001</mn></mrow></math>
  id: totrans-844
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mi>t</mi><mi>a</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10100001</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>s</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110010</mn></mrow></math>
  id: totrans-845
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>s</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110010</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mi>s</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01100011</mn></mrow></math>
  id: totrans-846
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mi>s</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01100011</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110100</mn></mrow></math>
  id: totrans-847
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110100</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>u</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>00100101</mn></mrow></math>
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>u</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>00100101</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mi>u</mi><mi>c</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110110</mn></mrow></math>
  id: totrans-849
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mi>u</mi><mi>c</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10110110</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mi>c</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10111000</mn></mrow></math>
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mi>c</mi><mi>t</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10111000</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>u</mi><mi>r</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01101001</mn></mrow></math>
  id: totrans-851
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mi>u</mi><mi>r</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01101001</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mi>r</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10111010</mn></mrow></math>
  id: totrans-852
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mi>r</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>10111010</mn></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01101011</mn></mrow></math>
  id: totrans-853
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo
    stretchy="false">)</mo><mo>=</mo><mn>01101011</mn></mrow></math>
- en: '*if <math alttext="" display="inline"><mrow><mi>s</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>.</mo><mi>h</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow></math>*,
    *V[i]* is incremented by 1'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果<math alttext="" display="inline"><mrow><mi>s</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>.</mo><mi>h</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow></math>*，则*V[i]*增加1'
- en: '*if <math alttext="" display="inline"><mrow><mi>s</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>.</mo><mi>h</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow></math>*,
    *V[i]* = is decremented by 1'
  id: totrans-855
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果<math alttext="" display="inline"><mrow><mi>s</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>.</mo><mi>h</mi><mo
    stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow></math>*，则*V[i]*减少1'
- en: The *V* vector is represented by [Fig. 13.5](#fig13_5).
  id: totrans-856
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*V*向量由[图13.5](#fig13_5)表示。'
- en: '![Figure 13.5](../images/fig13_5.jpg)'
  id: totrans-857
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图13.5](../images/fig13_5.jpg)'
- en: '**FIGURE 13.5.**'
  id: totrans-858
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图13.5.**'
- en: Simhash example.
  id: totrans-859
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Simhash示例。
- en: 'To compute final simhash fingerprint:'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算最终的simhash指纹：
- en: if <math alttext="" display="inline"><mrow><mi>V</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mn>0</mn></mrow></math>,
    *simhash[i]* = 1
  id: totrans-861
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果<math alttext="" display="inline"><mrow><mi>V</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mn>0</mn></mrow></math>，则*simhash[i]*
    = 1
- en: else *simhash[i]*= 0
  id: totrans-862
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则*simhash[i]*= 0
- en: So, simhash fingerprint is <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>10110000</mn><mo
    stretchy="false">)</mo></mrow></math>.
  id: totrans-863
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，simhash指纹为<math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>10110000</mn><mo
    stretchy="false">)</mo></mrow></math>。
- en: To detect similarity of document *d* with a given set of document. One solution
    is to take hamming distance of simhash fingerprint of fingerprint of *d* with
    all other documents simhash fingerprint value. However, with growing problem size
    this method is not efficient. In another approach, rather than comparing all simhash
    bits of document *d* with all bits in simhash value of document set, only compare
    some specific bit position. If they matches, only then hamming distance of two
    simhash fingerprint is computed.
  id: totrans-864
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检测文档*d*与给定一组文档的相似性。一个解决方案是计算*d*的simhash指纹与所有其他文档simhash指纹值的汉明距离。然而，随着问题规模的增长，这种方法并不高效。在另一种方法中，与其将文档*d*的所有simhash位与文档集合中的所有位进行比较，不如只比较一些特定的位位置。如果它们匹配，则计算两个simhash指纹的汉明距离。
- en: Activity
  id: totrans-865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: Which one of the following is not a type of similarity search PDS?
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一个不是PDS相似性搜索的一种类型？
- en: Minhash
  id: totrans-868
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小哈希
- en: Maxhash
  id: totrans-869
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maxhash
- en: LSH
  id: totrans-870
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LSH
- en: Simhash
  id: totrans-871
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Simhash
- en: The space consumed by set of k-shingles with total of *n* words in a documents
    is?
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个文档中包含n个单词的k-shingles集合所占用的空间是？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-873
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-874
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-875
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-876
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>*</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: The time consumed by signature matrix for comparing similar pairs is?
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于比较相似对的签名矩阵所消耗的时间是多少？
- en: <math alttext="" display="inline"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mi>n</mi></mtd></mtr><mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced><mo
    stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
  id: totrans-878
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mi>n</mi></mtd></mtr><mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced><mo
    stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-879
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-880
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-881
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: In general, probability of signature not to agree on any of the bands for two
    columns C1 and C2 is given by ?
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，对于两列 C1 和 C2，签名不在任何频段上达成一致的概率是多少？
- en: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>s</mi><mi>b</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>r</mi></msup></mrow></math>
  id: totrans-883
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>s</mi><mi>b</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>r</mi></msup></mrow></math>
- en: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>s</mi><mi>b</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>r</mi></msup></mrow></math>
  id: totrans-884
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>s</mi><mi>b</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>r</mi></msup></mrow></math>
- en: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>r</mi><mi>s</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>b</mi></msup></mrow></math>
  id: totrans-885
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>r</mi><mi>s</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>b</mi></msup></mrow></math>
- en: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>b</mi><mi>r</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>s</mi></msup></mrow></math>
  id: totrans-886
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>b</mi><mi>r</mi></msup><mo
    stretchy="false">)</mo></mrow><mi>s</mi></msup></mrow></math>
- en: Which among the following is not a distance metric ?
  id: totrans-887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是距离度量？
- en: Euclidean distance
  id: totrans-888
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: Hamming distance
  id: totrans-889
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汉明距离
- en: Cosine distance
  id: totrans-890
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余弦距离
- en: Signature distance
  id: totrans-891
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签名距离
- en: What is the time complexity to compute jaccard similarity for *n* given document?
  id: totrans-892
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算给定文档 *n* 的 Jaccard 相似度的时间复杂度是多少？
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-893
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-894
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-895
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo
    stretchy="false">)</mo></mrow></math>
- en: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
  id: totrans-896
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>
- en: 'Higher number of bands in LSH implies:'
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LSH 中更多的频段意味着：
- en: Lower false positives
  id: totrans-898
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较低的假阳性
- en: Higher false negatives
  id: totrans-899
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较高的假阴性
- en: Higher false positive
  id: totrans-900
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较高的假阳性
- en: Lower false negatives
  id: totrans-901
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较低的假阴性
- en: 'Locality sensitive hashing generates:'
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部敏感哈希生成：
- en: False positives only
  id: totrans-903
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅假阳性
- en: False negatives only
  id: totrans-904
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅假阴性
- en: Both false positives and false negatives
  id: totrans-905
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假阳性和假阴性都较高
- en: Neither of false positive and false negatives
  id: totrans-906
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假阳性和假阴性都不是
