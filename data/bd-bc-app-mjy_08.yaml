- en: 'Part V: Building Your Own Blockchain'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分：构建你自己的区块链
- en: In this part of the book, I go beyond Ethereum and discuss how to build your
    own blockchains. This enables developers to bypass the virtual machine and bake
    application logic directly into the blockchain itself for maximum efficiency.
    But of course, this type of application blockchain is also much less flexible
    and adaptable than smart contract-based blockchains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的这部分，我超越了以太坊，讨论了如何构建你自己的区块链。这使得开发者可以绕过虚拟机，将应用逻辑直接烘焙到区块链本身，以实现最大效率。但当然，这种基于应用区块链的灵活性和适应性也比智能合约基础的区块链要差很多。
- en: Using the open source Tendermint framework, I illustrate how to build application
    blockchains, as well as user-facing applications for those blockchains.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源的 Tendermint 框架，我展示了如何构建应用区块链以及为这些区块链编写面向用户的应用。
- en: 19. Getting Started with Tendermint
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19. 开始使用 Tendermint
- en: Tendermint provides infrastructure software that allows developers to build
    their own blockchain solutions. The Tendermint approach has two unique characteristics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 提供了基础设施软件，允许开发者构建他们自己的区块链解决方案。Tendermint 方法有两个独特特点。
- en: Tendermint utilizes a Byzantine fault tolerant (BFT) algorithm that allows for
    up to one-third of nodes failing or behaving maliciously.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tendermint 使用了拜占庭容错（BFT）算法，该算法允许最多有三分之一的节点失败或行为恶意。
- en: Tendermint consensus is reached by designated validator nodes. There are only
    a limited number of validators on the network.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tendermint 共识是由指定验证节点节点达成的。网络上只有有限数量的验证节点。
- en: At its core, Tendermint is a high-performance and scalable consensus engine.
    As a trade-off, it is also a weakly centralized solution; it is not completely
    decentralized like Bitcoin, as it requires designated validators and is somewhat
    less fault tolerant (Bitcoin allows 49 percent of nodes to fail while Tendermint
    allows one-third).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Tendermint 是一个高性能和可扩展的共识引擎。作为一种权衡，它也是一个弱中心化的解决方案；它不是完全去中心化的，就像比特币一样，因为它需要指定的验证节点，并且在容错性方面略低（比特币允许49%的节点失败，而
    Tendermint 允许三分之一）。
- en: Because Tendermint is designed as a consensus engine, it attempts to separate
    the “application logic” and “consensus logic” of blockchain applications. That
    separation allows Tendermint software to be embedded in any other blockchains
    as a drop-in consensus engine replacement; the host blockchain just needs to implement
    the Tendermint API, known as the Application BlockChain Interface (ABCI), to use
    Tendermint’s delegated proof-of-style (DPoS) consensus.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Tendermint 被设计为一种共识引擎，所以它试图将区块链应用的“应用逻辑”和“共识逻辑”分开。这种分离使得 Tendermint 软件可以被嵌入到任何其他区块链中，作为一个即插即用的共识引擎替代品；宿主区块链只需要实现
    Tendermint API，即应用区块链接口（ABCI），就可以使用 Tendermint 的委托证明风格（DPoS）共识。
- en: The clean separation between application and consensus logic in Tendermint makes
    it possible to build custom logic into blockchain applications. Those applications
    go far beyond the traditional smart contracts. They can utilize full stacks of
    enterprise software to handle complex application scenarios.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 中应用和共识逻辑的清晰分离使得将自定义逻辑构建到区块链应用中成为可能。这些应用远远超出了传统的智能合约。它们可以利用完整的的企业软件栈来处理复杂的应用场景。
- en: '**Note**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Substrate framework from Parity and Polkadot is similar to Tendermint and
    Cosmos SDK (see next chapter) in function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Parity 和 Polkadot 的 Substrate 框架在功能上与 Tendermint 和 Cosmos SDK（见下一章）相似。
- en: How It Works
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Every node of a Tendermint blockchain needs to run two pieces of software:
    the consensus engine known as Tendermint Core and an ABCI application specifically
    written for the blockchain (see [Figure 19.1](ch19.xhtml#ch19fig1)).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 区块链的每个节点都需要运行两段软件：名为 Tendermint Core 的共识引擎和为区块链特别编写的 ABCI 应用（见[图
    19.1](ch19.xhtml#ch19fig1)）。
- en: '![image](Images/yuan_f19_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f19_01.jpg)'
- en: '**Figure 19-1** A Tendermint blockchain node'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 19-1** 一个 Tendermint 区块链节点'
- en: The Tendermint Core software is responsible for building and synchronizing the
    blockchain across the network.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tendermint Core 软件负责在网络上构建和同步区块链。
- en: The ABCI application is responsible for processing and validating all transactions
    that get stored in the blockchain. Each blockchain could have a different ABCI
    application for a different application scenario or logic. For example, a blockchain
    that records cryptocurrency transactions will have a very different ABCI application
    than one that records real estate deeds.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABCI应用程序负责处理和验证存储在区块链上的所有交易。每个区块链可能都有一个不同的ABCI应用程序，用于不同的应用场景或逻辑。例如，记录加密货币交易的区块链将有一个与记录房地产契约的区块链非常不同的ABCI应用程序。
- en: '**Note**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The ABCI application can be arbitrarily complex and written in any language
    on any software stack. In fact, it can have its own database to store and manage
    its state. In a broad sense, it is a smart contract on steroids.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ABCI应用程序可以非常复杂，并且可以编写在任何软件堆栈上的任何语言中。实际上，它可以有自己的数据库来存储和管理其状态。广义上讲，它是智能合约的加强版。
- en: It Works as Follows
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以下是如何工作
- en: An external application sends a transaction request to any node on the network.
    The request is received by the Tendermint Core software. Notice that here we do
    not define what exactly is a transaction, as there are many different blockchain
    applications, and they have different definitions for transactions. For instance,
    some applications might define transactions as straight token exchanges, while
    others would consider recording a real-world event as a transaction. For our purposes,
    a transaction is simply a series of bytes to be recorded on the blockchain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 外部应用程序向网络上的任何节点发送交易请求。该请求被Tendermint Core软件接收。请注意，我们在这里并没有定义什么是交易，因为不同的区块链应用有不同的交易定义。例如，一些应用可能会将交易定义为直接的代币交换，而其他应用则可能将记录现实世界事件视为交易。对我们来说，交易仅仅是将要记录在区块链上的字节序列。
- en: Upon receiving the request, the Tendermint Core software immediately forwards
    the transaction request to the ABCI application running on the same node. The
    ABCI application parses the transaction data and makes a preliminary determination
    on whether it is a validate transaction. At this stage, the transaction will not
    result in any state change (i.e., nothing gets written to the database managed
    by the ABCI application).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 收到请求后，Tendermint Core软件立即将交易请求转发给同一节点上运行的ABCI应用程序。ABCI应用程序解析交易数据并对它是否为有效交易做出初步判断。在这个阶段，交易不会导致任何状态变化（即不会将任何内容写入由ABCI应用程序管理的数据库）。
- en: If the ABCI application’s preliminary determination is valid, the Tendermint
    Core software will broadcast and synchronize the transaction to all nodes on the
    network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ABCI应用程序的初步判断有效，Tendermint Core软件将广播并同步交易到网络上的所有节点。
- en: At a fixed time interval, the network creates a new block with all the transactions
    that are validated during this time interval. Validator nodes will vote on the
    new block, and if at least two-thirds of validator nodes agree, the new block
    will be appended to the blockchain and broadcast to all nodes on the network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定的时间间隔内，网络创建一个包含在这个时间间隔内验证的所有交易的新的区块。验证节点将对新区块进行投票，如果至少有三分之二的验证节点同意，新区块将被添加到区块链并广播到网络上的所有节点。
- en: Once a new block is added to the blockchain, each node will again rerun all
    the transactions included in the block to the node’s local ABCI application for
    processing. At this time, the ABCI application can update its database to store
    the application state changes caused by those transactions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新的区块被添加到区块链上，每个节点将重新运行包含在区块中的所有交易到节点的本地ABCI应用程序进行处理。此时，ABCI应用程序可以更新其数据库以存储那些交易引起的状态变化。
- en: '[Figure 19.2](ch19.xhtml#ch19fig2) summarizes the workflow described.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19.2** 总结了所描述的工作流程。'
- en: '![image](Images/yuan_f19_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f19_02.jpg)'
- en: '**Figure 19-2** The workflow'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19-2** 工作流程'
- en: '**Note**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: After a block is added to the blockchain, all nodes run the same transactions
    in the same order. Hence, after a block is added, the ABCI application instances
    on all nodes have the same persistent state stored in their databases. For example,
    the ABCI application could update the user accounts database if the transactions
    move tokens/funds between users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在将区块添加到区块链之后，所有节点以相同的顺序运行相同的交易。因此，在添加区块之后，所有节点的ABCI应用程序实例在其数据库中存储的持久状态相同。例如，如果交易在用户之间移动代币/资金，ABCI应用程序可以更新用户账户数据库。
- en: In the next section, let’s go through the exercise to set up a single Tendermint
    node to see how the Tendermint Core software and ABCI app work together.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们通过设置一个单一的Tendermint节点来了解Tendermint Core软件和ABCI应用是如何一起工作的。
- en: Set Up a Node
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置一个节点
- en: 'Let’s download the precompiled Tendermint binary applications from the following
    web page: [https://tendermint.com/downloads](https://tendermint.com/downloads).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下网页下载预编译的Tendermint二进制应用程序：[https://tendermint.com/downloads](https://tendermint.com/downloads)。
- en: 'You will need the `tendermint` and `abci` binaries for this step. Unpack the
    downloaded zip packages, and you will get the following executable binary files:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`tendermint`和`abci`二进制文件进行此步骤。解压下载的压缩包，您将得到以下可执行的二进制文件：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Move the binary files to the `$HOME/bin` directory so that they are accessible
    from the command line. You can now run them to check their versions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制文件移动到`$HOME/bin`目录，这样它们就可以从命令行访问了。现在您可以运行它们来检查它们的版本。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `dummy` program is a simple ABCI application. Once running, it listens for
    transactions from Tendermint Core on TCP port 46658\. Being a “dummy” program,
    it will simply approve and validate all transactions. You can run the dummy program
    in a command-line window.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`dummy`程序是一个简单的ABCI应用。运行后，它会在TCP端口46658上监听来自Tendermint Core的交易。作为一个“示例”程序，它将简单地批准并验证所有交易。您可以在命令行窗口中运行示例程序。'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, in another command-line window, initialize the Tendermint Core software
    on this machine. The `init` command creates the configuration files for a network
    made up of a single validator node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在另一个命令行窗口中，初始化这台机器上的Tendermint Core软件。`init`命令为只有一个验证节点组成的网络创建配置文件。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have initialized Tendermint Core on this computer before, you could
    either delete the `$HOME/.tendermint` directory and `init` again or use the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前在这个计算机上初始化过Tendermint Core，您可以删除`$HOME/.tendermint`目录并重新初始化，或者使用以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Note**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you encounter an error during Tendermint node startup, make sure you kill
    all Tendermint-related processes on your computer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动Tendermint节点时遇到错误，请确保您杀死了计算机上所有与Tendermint相关的进程。
- en: Now, you can start the Tendermint node. The node immediately connects to the
    `dummy` ABCI app through port 46658 and starts to create blocks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动Tendermint节点。节点会立即通过端口46658连接到`dummy` ABCI应用并开始创建区块。
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch19_images.xhtml#pro19_1)'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the output from the `dummy` window, showing that a Tendermint
    node is connected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`dummy`窗口输出的内容，显示了一个Tendermint节点已连接：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Tendermint node listens on port 46657 for new transactions. So, let’s now
    send a transaction to the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint节点监听端口46657以接收新交易。那么，我们现在就向网络发送一个交易吧。
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_2)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch19_images.xhtml#pro19_2)'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The transaction is received by Tendermint Core at port 46657, forwarded to
    the dummy ABCI app at port 46658, validated by `dummy`, and then recorded in the
    blockchain by Tendermint Core. The dummy application stores the key-value pair
    in the transaction in its own database. The Tendermint console shows the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 交易会被Tendermint Core在端口46657上接收，然后转发给在端口46658上的`dummy` ABCI应用，由`dummy`验证，然后由Tendermint
    Core记录在区块链上。示例应用会在其自己的数据库中存储交易中的键值对。Tendermint控制台显示以下内容：
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_4)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch19_images.xhtml#pro19_4)'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Note**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `broadcast_tx_commit` message sends the transaction (in the `tx` parameter)
    to the network node and waits until the transaction is committed in a new block
    on the blockchain. There are other messages that can send the transaction without
    waiting for confirmation. You will see them in the next chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcast_tx_commit`消息将交易（在`tx`参数中）发送到网络节点，并等待交易在区块链上的新区块中被确认。还有其他可以发送交易而不等待确认的消息。您将在下一章看到它们。'
- en: Finally, we can query the blockchain for the transaction we just sent. The query
    is passed to the `dummy` ABCI application. Since the `dummy` application saves
    the value in all transactions it validates, it will be able to interpret and respond
    to the query and pass the results via Tendermint Core.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以查询刚刚发送的交易所在的区块链。查询会被传递给`dummy` ABCI应用。由于`dummy`应用会保存它验证的所有交易的值，所以它能解释并响应查询，并通过Tendermint
    Core传递结果。
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_5)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch19_images.xhtml#pro19_5)'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Set Up a Network
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置一个网络
- en: Of course, most blockchain networks have more than one node! To set up a network
    with multiple nodes, you can do the following.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数区块链网络不止有一个节点！要设置一个多节点的网络，你可以进行以下操作。
- en: First, run the `tendermint init` commands on all node computers on the network.
    In the `$HOME/.tendermint` directory, you will see the `genesis.json` file, which
    contains this node’s public key. The node’s private key is in the `priv_validator.json`
    file and should never be shared with anyone.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在网络上的所有节点计算机上运行`tendermint init`命令。在`$HOME/.tendermint`目录中，你会看到`genesis.json`文件，其中包含这个节点的公钥。节点的私钥在`priv_validator.json`文件中，绝不应该与任何人分享。
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_6)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](Images/ch19_images.xhtml#pro19_6)查看代码图片。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Second, edit the `genesis.json` file on each node to add all peer nodes’ public
    key into the `validators` array. Those nodes are known as *initial validators*
    for a network. The network can add or remove validators dynamically once it is
    running.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在每个节点上编辑`genesis.json`文件，将所有对等节点的公钥添加到`validators`数组中。这些节点被称为网络的*初始验证者*。一旦网络运行，网络可以动态地添加或移除验证者。
- en: Finally, on each node computer, you can start `tendermint node` and the ABCI
    application (e.g., `dummy`). The nodes will discover each other by their public
    keys and then form a network. Notice that nodes on a network must run the same
    ABCI app since all nodes must process and validate transactions the same way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每一个节点计算机上，你可以启动`tendermint node`和ABCI应用（例如`dummy`）。节点将通过它们的公钥发现彼此，然后形成一个网络。请注意，网络上的节点必须运行相同的ABCI应用，因为所有节点必须以相同的方式处理和验证交易。
- en: Now you have a private Tendermint blockchain network. You can make it validate
    and record any transaction you like by writing your own ABCI applications, which
    you will see in [Chapter 20](ch20.xhtml#ch20). The Cosmos foundation also runs
    public test networks for developers and validators. For now, let’s review how
    the Tendermint blockchain network works.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个私有的Tendermint区块链网络。你可以通过编写你自己的ABCI应用来使它验证和记录任何你喜欢的交易，你将在[第20章](ch20.xhtml#ch20)看到这些应用。Cosmos基金会也为开发者和验证者运行公开测试网络。现在，让我们回顾一下Tendermint区块链网络是如何工作的。
- en: A new transaction is received and preliminarily validated on a single node.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的交易在一个单节点上被接收并初步验证。
- en: At a fixed time interval, validator nodes package all transactions since the
    last block and propose a new block.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在固定的时间间隔内，验证节点节点打包自上一次区块以来的所有交易，并提议一个新的区块。
- en: Once validators agree on a new block, it is broadcast to all nodes.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦验证者对一个新的区块达成共识，它就会被广播到所有的节点。
- en: All nodes process all transactions in the same order when a new block is added
    to the blockchain.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新区块被添加到区块链时，所有节点都会以相同的顺序处理所有交易。
- en: As a result, the application state of the blockchain (databases managed by the
    ABCI application) on all nodes are in sync.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，所有节点上的区块链应用状态（由ABCI应用管理的数据库）保持同步。
- en: Conclusion
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed how the Tendermint blockchain works by separating
    the consensus logic and application logic. The application logic, encapsulated
    in an ABCI application, allows developers to write versatile blockchain applications.
    I also demonstrated how to set up a Tendermint node and a network with a simple
    ABCI application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章节中，我讨论了Tendermint区块链是如何通过将共识逻辑与应用逻辑分离来工作的。封装在ABCI应用中的应用逻辑使得开发者能够编写多功能的区块链应用。我还展示了如何使用一个简单的ABCI应用来设置一个Tendermint节点和一个网络。
- en: 20. The Business Logic
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20. 业务逻辑
- en: 'In the previous chapter, I explained that the business logic of a Tendermint
    blockchain network is encapsulated in an Application BlockChain Interface (ABCI)
    application. So, as a developer, you just need to write an application to control
    how the network processes and validates transactions. Each ABCI application is
    a blockchain. Here are some examples:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我解释了Tendermint区块链网络的业务逻辑是封装在一个应用区块链接口（ABCI）应用中的。所以，作为一名开发者，你只需要编写一个应用来控制网络如何处理和验证交易。每一个ABCI应用都是一个区块链。以下是一些示例：
- en: The Binance decentralized exchange is an application blockchain designed for
    crypto exchange operations. It is built on top of Tendermint.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Binance去中心化交易所是一个为加密货币交易操作设计的应用区块链。它是建立在Tendermint之上的。
- en: The basecoin application creates a blockchain network with a native cryptocurrency.
    You can extend the token to support your own cryptocurrency features by forking
    the project. See [https://github.com/tendermint/basecoin](https://github.com/tendermint/basecoin).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basecoin`应用创建了一个具有原生加密货币的区块链网络。您可以通过分叉该项目来扩展代币，以支持您自己的加密货币功能。详见[https://github.com/tendermint/basecoin](https://github.com/tendermint/basecoin)。'
- en: The `ETGate` application is built on `basecoin` and enables token exchanges
    between Ethereum and Tendermint blockchains. See [https://github.com/mossid/etgate](https://github.com/mossid/etgate).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETGate`应用基于`basecoin`构建，使以太坊与Tendermint区块链之间能够进行代币交换。详见[https://github.com/mossid/etgate](https://github.com/mossid/etgate)。'
- en: The `ethermint` application allows you to run the Ethereum Virtual Machine (EVM)
    as an ABCI application on top of a Tendermint blockchain. This creates an Ethereum
    blockchain but with Tendermint’s Byzantine fault tolerant (BFT) validators as
    opposed to PoW miners. See [https://github.com/tendermint/ethermint](https://github.com/tendermint/ethermint).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ethermint`应用允许您在Tendermint区块链之上作为ABCI应用运行以太坊虚拟机（EVM）。这创建了一个以太坊区块链，但使用Tendermint的拜占庭容错（BFT）验证器，而不是PoW矿工。详见[https://github.com/tendermint/ethermint](https://github.com/tendermint/ethermint)。'
- en: The Plasma Cash is a layer 2 network implementation for Ethereum based on the
    Tendermint engine. It is a blockchain that connects to the Ethereum network via
    smart contracts. The Plasma Cash side chain allows for high-speed transactions
    that are impossible on Ethereum.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Plasma Cash是基于Tendermint引擎的以太坊第二层网络实现。它是一个通过智能合约与以太坊网络相连的区块链，Plasma Cash侧链允许进行在以太坊上无法实现的高速交易。
- en: The `merkleeyes` application creates a blockchain network that records transactions
    on a Merkle tree. It simulates a journaled data store. The insert/remove operations
    on the tree are recorded as transactions on the blockchain, and the current data
    on the tree can be queried from the blockchain’s query application programming
    interface (API) as well. See [https://github.com/tendermint/merkleeyes](https://github.com/tendermint/merkleeyes).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merkleeyes`应用创建了一个区块链网络，该网络在Merkle树 上记录交易。它模拟了一个记账式数据存储。树上的插入/删除操作作为交易记录在区块链上，当前树上的数据也可以从区块链的查询应用程序编程接口（API）中查询。详见[https://github.com/tendermint/merkleeyes](https://github.com/tendermint/merkleeyes)。'
- en: The CyberMiles application is a fully fledged ABCI application that incorporates
    delegated proof of stake (DPoS), on-chain governance, security features, and an
    enhanced EVM into a single ABCI application.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CyberMiles应用是一个完全成熟的ABCI应用，它将委托权益证明（DPoS）、链上治理、安全功能和增强的EVM整合到单一的ABCI应用中。
- en: In this chapter, we explore the ABCI protocol and create a simple ABCI application.
    We will also discuss application frameworks that are built on top of the ABCI,
    such as the Cosmos software development kit (SDK).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨ABCI协议并创建一个简单的ABCI应用。我们还将讨论建立在ABCI之上的应用框架，例如Cosmos软件开发工具包（SDK）。
- en: The Protocol
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: You already learned how a Tendermint network works at a high level. In this
    section, we will look into the detailed mechanism, including the message exchange
    between Tendermint Core, which manages the blockchain, and the ABCI application,
    which manages the application-specific logic.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了Tendermint网络在较高层次上是如何工作的。在本节中，我们将深入探讨其详细机制，包括Tendermint Core（管理区块链）与ABCI应用（管理应用特定逻辑）之间的消息交换。
- en: The ABCI protocol specifies the request/response communication between the Tendermint
    Core software and the ABCI application. By default, the ABCI application listens
    on TCP port 46658\. Tendermint Core sends messages to the ABCI application and
    acts on the responses ([Figure 20.1](ch20.xhtml#ch20fig1)). The protocol defines
    several kinds of messages. They follow the Tendermint Core and ABCI application
    interaction flow outlined in the previous chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ABCI协议定义了Tendermint Core软件与ABCI应用之间的请求/响应通信。默认情况下，ABCI应用监听TCP端口46658。Tendermint
    Core向ABCI应用发送消息并对响应采取行动（[图20.1](ch20.xhtml#ch20fig1)）。该协议定义了几种消息类型。它们遵循前章概述的Tendermint
    Core和ABCI应用交互流程。
- en: '![image](Images/yuan_f20_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f20_01.jpg)'
- en: '**Figure 20-1** Tendermint ABCI messages in the consensus flow'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图20-1** 共识流程中的Tendermint ABCI消息'
- en: Consensus on the Block
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区块上的共识
- en: The first type of message is the `CheckTx` message. When the node receives a
    transaction request (via port 46657, which Tendermint Core listens on by default),
    it forwards the transaction to the ABCI application in a `CheckTx` message for
    preliminary validation. The ABCI application has its own logic to parse, process,
    and validate the transaction and then return a result. If the `CheckTx` result
    is okay, the Tendermint node will broadcast and synchronize the transaction to
    all nodes in the blockchain network.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种消息类型是`CheckTx`消息。当节点接收到交易请求（通过Tendermint Core默认监听的46657端口），它将交易转发到ABCI应用的`CheckTx`消息进行初步验证。ABCI应用有自己的逻辑来解析、处理和验证交易，然后返回一个结果。如果`CheckTx`结果没问题，Tendermint节点将广播并将交易同步到区块链网络中的所有节点。
- en: It is important to note that every Tendermint node keeps its own pool of transactions
    that successfully passed the node’s `CheckTx`. It is known as the node’s *mempool*.
    The nodes on the network could each have a different set of transactions in the
    mempool. When a node proposes a new block, it packages together transactions in
    its own mempool. When the block is accepted by the network (i.e., consensus),
    all transactions in the block will be removed from all node mempools in the network.
    [Figure 20.2](ch20.xhtml#ch20fig2) outlines the consensus flow of the new block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每个Tendermint节点都保留自己的交易池，这些交易成功通过了节点的`CheckTx`。这被称为节点的*内存池*。网络上的节点可能有不同的交易集在内存池中。当一个节点提出一个新的块时，它会将内存池中的交易一起打包。当块被网络接受（即达成共识）时，网络中所有节点的内存池中的所有交易将被删除。
    [图20.2](ch20.xhtml#ch20fig2)概述了新区块的共识流程。
- en: '![image](Images/yuan_f20_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f20_02.jpg)'
- en: '**Figure 20-2** Tendermint consensus for each block'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图20-2** 每个块的Tendermint共识'
- en: When a Tendermint network reaches consensus on a new block, the nodes are only
    agreeing on the block’s structure and its cryptographic validity with regard to
    the previous blocks on the blockchain. The nodes actually have no idea about the
    validity of the transactions inside the block. To reach consensus on the results
    of the transactions inside the block, we will need the app hash from the `commit`
    message, which we will see next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当Tendermint网络就新区块达成共识时，节点只是就块的结构及其与区块链中先前块的加密有效性达成一致。节点实际上对块中交易的验证一无所知。为了就块中交易的结果达成共识，我们需要来自下一个将介绍的`commit`消息的应用哈希。
- en: Consensus on the Transactions
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易共识
- en: The second, and most important type of message, is the `DeliverTx` message.
    At fixed-time intervals, all validator nodes in the network will reach consensus
    and determine the next block to be added to the blockchain. This new block contains
    all valid transactions submitted to the network during the time interval, and
    it is broadcast to all nodes on the network. Each node will run all the transactions
    in the block to the node’s local ABCI application instance. Each transaction is
    embedded in a `DeliverTx` message. The block starts with a `StartBlock` message
    to the ABCI, followed by a series of `DeliverTx` messages for all transactions
    in the block, and ends with an `EndBlock` message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种，也是最重要的消息类型是`DeliverTx`消息。在固定时间间隔内，网络中的所有验证节点将达成共识并确定要添加到区块链的下一个块。这个新块包含在此时间间隔内提交给网络的所有有效交易，并且广播给网络上的所有节点。每个节点都将运行块中的所有交易到节点的本地ABCI应用实例。每个交易都嵌入在`DeliverTx`消息中。块从向ABCI发送的`StartBlock`消息开始，接着是一系列块中的所有交易的`DeliverTx`消息，并以一个`EndBlock`消息结束。
- en: The ABCI application processes the `DeliverTx` messages in the order they are
    received. The ABCI application maintains its own database and updates the database
    as it processes the transactions (e.g., the database could be a ledger for user
    accounts, and each transaction moves funds between accounts). Since all nodes
    process the same set of transactions in the same order, once they are done, the
    ABCI applications on all nodes should have the same persistent state (i.e., their
    database content should be synchronized).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ABCI应用按接收顺序处理`DeliverTx`消息。ABCI应用维护自己的数据库，并在处理交易时更新数据库（例如，数据库可以是用户账户的账本，每笔交易都会在账户之间转移资金）。由于所有节点都按相同顺序处理相同的事务集，一旦处理完成，所有节点的ABCI应用应具有相同的持久状态（即，它们的数据库内容应同步）。
- en: '**Note**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It is possible that the `DeliverTx` message to the ABCI application could return
    a failure result. Since the network validators have already reached consensus
    on the block, the blockchain will annotate the failed transaction in this block
    in the block header.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能ABCI应用程序的`DeliverTx`消息会返回一个失败的结果。由于网络验证者已经就区块达成了共识，区块链将在这个区块的区块头中注解失败的交易。
- en: A critical requirement of the ABCI application is that it must be deterministic.
    When it processes a set of transactions, it must reach the same results, in terms
    of the success/failure of each transaction and the overall application state,
    every time regardless of which node did the processing. That means the ACBI application
    logic should not have any dependency on random numbers, timestamps, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ABCI应用程序的一个关键要求是它必须是确定性的。当它处理一组交易时，无论哪个节点进行处理，它都必须每次达到相同的结果，就每个交易的成败和整个应用程序的状态而言。这意味着ACBI应用程序逻辑不应该有任何依赖随机数、时间戳等。
- en: The ABCI application does not save to a database after each `DeliverTx` message.
    Instead, it processes the entire block of transactions and saves only at the end
    when it sees a `Commit` message. The `Commit` message should return the current
    state of the node, such as the node’s database hash, known as the *app hash*.
    The blockchain will stop working altogether if two-thirds of the validator nodes
    cannot agree on an app hash at the `Commit` of any block. If a node returns an
    app hash that is different than most nodes, this node is deemed corrupt and will
    not be able to participate in future consensus voting.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次`DeliverTx`消息后，ABCI应用程序不会保存到数据库中。相反，它处理整个交易块，并在看到`Commit`消息时只在最后保存。`Commit`消息应返回节点的当前状态，例如节点的数据库散列，称为*app
    hash*。如果三分之二的验证节点在任何一个块的`Commit`阶段无法达成app hash共识，整个区块链将完全停止工作。如果一个节点返回的app hash与大多数节点不同，这个节点被认为是腐败的，将无法参与未来的共识投票。
- en: Getting Information
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取信息
- en: Finally, the ABCI protocol supports a third type of message, the `Query` message,
    which allows the Tendermint Core node to query the persistent state of the ABCI
    application. As mentioned, the ABCI application could maintain its own database,
    and the data stored in the database (i.e., its state) is determined by the history
    of transactions validated by the ABCI application. The blockchain node could query
    this database by issuing a query message.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ABCI协议支持第三种类型的消息，即`Query`消息，它允许Tendermint Core节点查询ABCI应用程序的持久状态。正如提到的，ABCI应用程序可以维护自己的数据库，数据库中存储的数据（即其状态）由ABCI应用程序验证的交易历史确定。区块链节点可以通过发送查询消息来查询这个数据库。
- en: A Sample Application
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: In the next sections, let’s get into the details by building an ABCI application.
    The application keeps track of a series of facts by their sources and stores the
    tallies in a database. The facts are submitted by external applications to any
    node on the blockchain. If a fact is accepted by the application, it will be recorded
    in the blockchain as a transaction. We will implement this application in the
    Java and GO languages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将通过构建一个ABCI应用程序来深入了解细节。该应用程序通过其来源跟踪一系列事实，并将总计存储在数据库中。事实是由外部应用程序提交给区块链上的任何节点的。如果一个事实被应用程序接受，它将被记录在区块链作为一个交易。我们将用Java和GO语言实现这个应用程序。
- en: Once the blockchain (Tendermint Core) and the facts ABCI application are running,
    you can send a series of facts as transactions to the blockchain. Each fact contains
    a source and a statement. Recall that Tendermint Core listens at port 46657 for
    transactions submitted to the blockchain.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦区块链（Tendermint Core）和事实ABCI应用程序运行起来，你可以将一系列事实作为交易发送到区块链上。每个事实都包含一个来源和一个陈述。回想一下，Tendermint
    Core在端口46657监听提交到区块链的交易。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_1)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_1)'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned in the previous chapter, there are several ways to send the transaction
    data (it could be any byte array in the `tx` parameter field).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前章所述，发送交易数据有几种方法（`tx`参数字段中的数据可以是任何字节数组）。
- en: '`/broadcast_tx_commit`: This is the message we used. It waits until the blockchain
    has validated the transaction and is added into a new block. When this message
    returns, you will be able to see both `CheckTx` and `DeliverTx` results.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/broadcast_tx_commit`：我们使用了这个消息。它等待区块链验证交易并添加到新的块中。当这个消息返回时，你将能够看到`CheckTx`和`DeliverTx`的结果。'
- en: '`/broadcast_tx_async`: This message sends the transaction data to a blockchain
    node and does not wait for the blockchain’s response.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/broadcast_tx_async`: 该消息将交易数据发送到区块链节点，并且不等待区块链的响应。'
- en: '`/broadcast_tx_sync`: This message sends the transaction data to a blockchain
    node and waits for the `CheckTx` to run. This message returns the `CheckTx` result.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/broadcast_tx_sync`: 该消息将交易数据发送到区块链节点，并等待`CheckTx`运行。该消息返回`CheckTx`的结果。'
- en: On the facts application console, you can see the transactions are processed
    and validated. Notice that there are both `CheckTx` and `DeliverTx` messages on
    all nodes. While the transaction is sent to only one node, the node broadcasts
    the transaction to all nodes once it passes the `CheckTx` message. So, each node
    will see this transaction, check it, save it to the mempool, and process it again
    when the new consensus block containing this transaction is received.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在facts应用程序控制台上，您可以看到交易被处理和验证。请注意，所有节点上都有`CheckTx`和`DeliverTx`消息。尽管交易只发送到一个节点，但一旦交易通过了`CheckTx`消息，节点就会将交易广播到所有节点。所以，每个节点都会看到这笔交易，检查它，将其保存到内存池中，并在接收到包含这笔交易的新共识块时再次处理它。
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can also query the blockchain for the current application state. The ABCI
    application returns a tally of facts by sources. Notice that the actual fact statements
    are stored in the blockchain as transactions, and the ABCI application stores
    only the tally in its data store. The `value` field in the response is a Base64-encoded
    string of the response text in the `log` field.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查询区块链的当前应用程序状态。ABCI应用程序返回一个来源的事实汇总。请注意，实际的事实声明存储在区块链作为交易中，而ABCI应用程序在其数据存储中只存储汇总。响应中的`value`字段是对`log`字段中的响应文本的Base64编码字符串。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_2)'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let’s look into how to implement this simple facts ABCI application. We
    will discuss both Java and GO language implementations. You can just choose a
    language you are most comfortable with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看如何实现这个简单的facts ABCI应用程序。我们将讨论Java和GO语言实现。您可以只需选择您最擅长的语言。
- en: Java Implementation
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: java实现
- en: The Java application is built on the jTendermint library. When the application
    starts up, it listens on ABCI’s default TCP port 46658 to receive transactions
    from the Tendermint Core software running on the same node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序基于jTendermint库构建。当应用程序启动时，它在ABCI的默认TCP端口46658上监听，以接收来自同一节点上运行的Tendermint
    Core软件的交易。
- en: For the sake of simplicity, we will not use an external relational database
    to store the application state. Instead, we instantiate a global hash table in
    the application as the data store. The hash table key is a unique source of the
    facts, and the value is the number of facts associated with this source. The downside,
    of course, is that the application state is lost if the application crashes. When
    the application starts, it starts a socket server to listen for messages from
    the blockchain.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将不使用外部关系数据库来存储应用程序状态。相反，我们在应用程序中实例化一个全局哈希表作为数据存储。哈希表键是事实的唯一来源，值是与该来源相关联的事实数量。当然，这种方法的缺点是如果应用程序崩溃，应用程序状态就会丢失。当应用程序启动时，它启动一个套接字服务器以监听来自区块链的消息。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_3)'
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ResponseCheckTx` method handles the `CheckTx` messages from Tendermint
    Core. As you probably recall, the `CheckTx` message is sent when the blockchain
    node receives a transaction request. The ABCI application simply parses the fact
    from the message into a source element and a statement element. If the message
    parses successfully, the ABCI application returns `ok`, and the transaction is
    broadcast and synchronized to all nodes on the network. For brevity, I removed
    the statements to log messages to the facts application console, which you saw
    in the previous section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCheckTx`方法处理来自Tendermint Core的`CheckTx`消息。正如您可能回忆起来的，当区块链节点接收到交易请求时，会发送`CheckTx`消息。ABCI应用程序简单地将消息中的事实解析为一个来源元素和一个陈述元素。如果消息解析成功，ABCI应用程序返回`ok`，并且交易被广播并同步到网络上的所有节点。为了简洁，我移除了将消息日志到facts应用程序控制台的部分，您在上一节中看到了这部分。'
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_4)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_4)'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Note**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `CheckTx` message in this example is simplistic. In most applications, the
    `CheckTx` message handler method will use the application’s current database state
    to check the transaction. The application state (i.e., the app hash) is updated
    by the last block’s `Commit` message. The `CheckTx` method should never modify
    the application state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的`CheckTx`消息比较简单。在大多数应用中，`CheckTx`消息处理方法将使用应用的当前数据库状态来检查交易。应用状态（即应用哈希）是由上一区块的`Commit`消息更新的。`CheckTx`方法绝不应该修改应用状态。
- en: Next, after the network reaches consensus on the next block, each node will
    send transactions in this block as a series of `DeliverTx` messages to the ABCI
    application. The `ResponseDeliverTx` method handles the `DeliverTx` messages.
    It again parses the fact in the message and then tallies by the source in a temporary
    cache. Since all nodes will see the same set of `DeliverTx` messages in the same
    order, they should update the application’s database in sequence. That is, a second
    `DeliverTx` is working off the database after changes have been made by the first
    `DeliverTx`. However, the `DeliverTx` itself should update only a temporary (often
    in-memory) replicate of the database, and the changes are flushed to the permanent
    (often on-disk) database at `Commit`. This is not only efficient but also ensures
    the application’s database state is always set at the `Commit` state of the last
    block. In this simple example, however, our application database is in memory
    and the `DeliverTx` processing does not depend on the current state of the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在网络对下一个区块达成共识之后，每个节点将把这个区块中的交易作为一系列`DeliverTx`消息发送给ABCI应用。`ResponseDeliverTx`方法处理这些`DeliverTx`消息。它再次解析消息中的事实，然后根据来源在临时缓存中进行汇总。由于所有节点将以相同的顺序看到相同的`DeliverTx`消息集，它们应该按顺序更新应用的数据库。也就是说，第二个`DeliverTx`是在第一个`DeliverTx`对数据库进行更改之后工作的。然而，`DeliverTx`本身只应更新数据库的临时（通常是内存中）副本，更改在`Commit`时刷新到永久的（通常在磁盘上）数据库。这不仅高效，还确保应用的数据库状态始终设置为最后一个块的`Commit`状态。在这个简单的例子中，我们的应用数据库是在内存中，`DeliverTx`处理不依赖于数据库的当前状态。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_5)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch20_images.xhtml#pro20_5)
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the ABCI application sees the `Commit` message, it saves all the temporary
    tallies to the `Hashtable`-based data store. It returns the hash code of the data
    store as the app hash. All nodes have to agree on the app hash after committing
    this block. If a node returns a different app hash than other nodes, it is deemed
    corrupt and will not be allowed to participate in the future consensus.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当ABCI应用看到`Commit`消息时，它将所有临时汇总保存到基于`Hashtable`的数据存储中。它返回数据存储的哈希码作为应用哈希。所有节点在提交这个块后必须同意应用哈希。如果一个节点返回与其他节点不同的应用哈希，则认为它损坏，将不允许它参与未来的共识。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_6)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch20_images.xhtml#pro20_6)
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, an external application can query the blockchain for the application
    state. In this case, a `Query` message will be passed from Tendermint Core to
    the application. The `ResponseQuery` method handles this message and returns the
    tallies for all sources from the data store.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个外部应用可以查询区块链以获取应用状态。在这种情况下，一个`Query`消息将从Tendermint Core传递到应用。`ResponseQuery`方法处理此消息，并返回数据存储中所有来源的汇总。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_7)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch20_images.xhtml#pro20_7)
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The blockchain itself stores the validated `source : statement` data submitted
    by external applications. The ABCI application stores the tallies of facts based
    on sources, and the tallies are synchronized across all nodes since the ABCI application
    on all nodes run the same set of transactions that get written into the blockchain.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '区块链本身存储外部应用提交的已验证的`source : statement`数据。ABCI应用根据来源存储事实的汇总，并且由于所有节点上运行的ABCI应用相同的一组交易会被写入区块链，所以这些汇总在所有节点之间是同步的。'
- en: We use Maven to build an executable binary of the application. You can review
    the `pom.xml` file in the source code repository to see how to build the executable
    JAR file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Maven构建应用的可执行二进制文件。您可以在源代码仓库中查看`pom.xml`文件，以了解如何构建可执行的JAR文件。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can run the ABCI application from command line and it will automatically
    connect to a Tendermint Core instance running on the same node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行运行ABCI应用，它会自动连接到同一节点上运行的Tendermint Core实例。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: GO Implementation
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go语言实现
- en: Tendermint itself is built on the GO programming language. It is not surprising
    that GO is a well-supported language platform to build ABCI applications. The
    `main` method in the application listens for ABCI messages on port 46658.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint本身是用GO编程语言构建的。GO是一种非常适合构建ABCI应用程序的成熟语言平台。应用程序中的`main`方法监听端口46658上的ABCI消息。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_8)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_8)'
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Similar to the Java application, we will use an in-memory map to store the application
    state (i.e., the facts tallies) for simplicity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java应用程序类似，为了简化，我们将使用一个内存映射来存储应用程序状态（即事实汇总）。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_10)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_10)'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `CheckTx` method handles the `CheckTx` messages from Tendermint Core. As
    you probably recall, the `CheckTx` message is sent when the blockchain node receives
    a transaction request. The ABCI application simply parses the fact from the message
    into a source element and a statement element. If the message parses successfully,
    the ABCI application returns okay, and the transaction is broadcast and synchronized
    to all nodes on the network.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckTx`方法处理来自Tendermint Core的`CheckTx`消息。正如您可能回忆起来的，当区块链节点接收到交易请求时，会发送`CheckTx`消息。ABCI应用程序简单地将消息中的事实解析为一个来源元素和一个陈述元素。如果消息解析成功，ABCI应用程序返回OK，并且交易被广播并在网络上所有节点同步。'
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_11)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_11)'
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Note**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `CheckTx` message in this example is simplistic. In most applications, the
    `CheckTx` message handler method will use the application’s current database state
    to check that the transaction is valid. The application state (i.e., the app hash)
    is updated by the last block’s `Commit` message. The `CheckTx` method should never
    modify the application state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的`CheckTx`消息很简单。在大多数应用程序中，`CheckTx`消息处理方法将使用应用程序的当前数据库状态来验证交易的有效性。应用程序状态（即应用程序哈希）是由最后一个块的`Commit`消息更新的。`CheckTx`方法绝不应该修改应用程序状态。
- en: Next, after the network reaches consensus on the next block, each node will
    send transactions in this block as a series of `DeliverTx` messages to the ABCI
    application. The `DeliverTx` method handles the `DeliverTx` messages. It again
    parses the fact in the message and then tallies by the source in a temporary cache.
    Since all nodes will see the same set of `DeliverTx` messages in the same order,
    they should update the application’s database in sequence. That is, a second `DeliverTx`
    is working off the database after changes have been made by the first `DeliverTx`.
    However, the `DeliverTx` itself should update only a temporary (often in-memory)
    replicate of the database, and the changes are flushed to the permanent (often
    on-disk) database at Commit. This is not only efficient but also ensures the application’s
    database state is always set at the `Commit` state of the last block.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在网络对下一个区块达成共识之后，每个节点会将这个区块中的交易作为一系列`DeliverTx`消息发送给ABCI应用程序。`DeliverTx`方法处理这些`DeliverTx`消息。它再次解析消息中的事实，然后根据来源在临时缓存中进行汇总。由于所有节点都会以相同的顺序看到相同的`DeliverTx`消息集合，它们应该依次更新应用程序的数据库。也就是说，第二个`DeliverTx`在第一个`DeliverTx`对数据库进行更改之后开始工作。然而，`DeliverTx`本身只应更新数据库的临时（通常是在内存中）副本，更改在提交时刷新到永久的（通常在磁盘上）数据库。这不仅高效，还确保了应用程序的数据库状态始终设置在上一个块的`Commit`状态。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_12)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_12)'
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the ABCI application sees the `Commit` message, it saves all the temporary
    tallies to the map-based data store. It returns the hash of the total count of
    entries in the data store as the app hash. All nodes have to agree on the app
    hash after committing this block. If a node returns a different app hash than
    other nodes, it is deemed corrupt and will not be allowed to participate in the
    future consensus.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当ABCI应用程序看到`Commit`消息时，它会将所有临时汇总保存到基于映射的数据存储中。它返回数据存储中条目总数哈希作为应用程序哈希。所有节点在提交这个块后必须同意应用程序哈希。如果一个节点返回与其他节点不同的应用程序哈希，则认为它损坏，将不允许它参与未来的共识。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_13)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_13)'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, an external application can query the blockchain for the application
    state. In this case, a `Query` message will be passed from Tendermint Core to
    the application. The `Query` method handles this message and returns the tallies
    for all sources from the data store.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，外部应用程序可以查询区块链的应用程序状态。在这种情况下，一个`Query`消息将从 Tendermint Core 传递到应用程序。`Query`方法处理这个消息，并返回数据存储中所有来源的计数。
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_14)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请点击[此处查看代码图片](Images/ch20_images.xhtml#pro20_14)
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The blockchain itself stores the validated `source : statement` data submitted
    by external applications. The ABCI application stores the tallies of facts based
    on sources, and the tallies are synchronized across all nodes since the ABCI application
    on all nodes run the same set of transactions that get written into the blockchain.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '区块链本身存储了外部应用程序提交的有效`source : statement`数据。ABCI 应用程序根据来源存储事实的计数，并且由于所有节点上的 ABCI
    应用程序运行相同的一组交易，这些交易被写入区块链，所以计数会在所有节点之间同步。'
- en: We use the default tools to compile and build the GO application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认工具来编译和构建 GO 应用程序。
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can run the application from command line and it will automatically connect
    to a Tendermint Core instance running on the same node.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行运行应用程序，它会自动连接到同一节点上运行的 Tendermint Core 实例。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Cosmos SDK
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cosmos SDK
- en: Tendermint provides a flexible framework for building business logic on top
    of its consensus engine. However, as you have seen, we have to write the entire
    application logic from scratch using ABCI. From Tendermint’s point of view, the
    application data is simply a byte array. For many blockchain applications, they
    require the same set of baseline functionalities, such as user accounts/address
    management, token issuance, and PoS-style staking. It is tedious and error prone
    for developers to write those components over and over again for all Tendermint-based
    blockchains. That gives rise to application frameworks on top of the ABCI for
    common business components. The Cosmos SDK is one such component library for Tendermint.
    It is written on the GO language. The Cosmos Hub project itself is built on the
    Cosmos SDK.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Tendermint 提供了一个灵活的框架，用于在其共识引擎之上构建业务逻辑。然而，正如您所看到的，我们必须从头开始使用 ABCI 编写整个应用程序逻辑。从
    Tendermint 的角度来看，应用程序数据只是一个字节数组。对于许多区块链应用程序，它们需要同一组基础功能，例如用户账户/地址管理、代币发行和 PoS
    风格的质押。对于所有基于 Tendermint 的区块链，开发者重复编写这些组件既繁琐又容易出错。这促使在 ABCI 之上出现了针对常见业务组件的应用框架。Cosmos
    SDK 就是为 Tendermint 编写的一个这样的组件库。它用 GO 语言编写。Cosmos Hub 项目本身就是建立在 Cosmos SDK 之上的。
- en: The Cosmos SDK is still evolving, and its technical details are beyond the scope
    of this book. I recommend you visit the Cosmos SDK web site for the latest documentation
    and tutorials ([https://github.com/cosmos/cosmos-sdk](https://github.com/cosmos/cosmos-sdk)).
    In this section, I will provide a high-level introduction to the design and functions
    of the SDK. The SDK provides built-in support for basic infrastructure needed
    for most ABCI applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos SDK 仍在不断发展中，其技术细节超出了本书的范围。我建议您访问 Cosmos SDK 官方网站获取最新的文档和教程([https://github.com/cosmos/cosmos-sdk](https://github.com/cosmos/cosmos-sdk)).
    在本节中，我将为您提供 SDK 设计和功能的概述。SDK 为大多数 ABCI 应用程序提供了内置的基本基础设施支持。
- en: The SDK allows developers to easily create and maintain any number of key-value
    data stores known as `KVStore`. Those data stores are used to manage application
    state data during `CheckTx` and `DeliverTx` operations. For example, `DeliverTx`
    needs to process all transactions in the block on a cached copy of the blockchain
    state and Commit those changes when the processing is successfully finished.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDK 允许开发者轻松创建和维护任意数量的关键值数据存储，称为`KVStore`。这些数据存储在`CheckTx`和`DeliverTx`操作期间用于管理应用程序状态数据。例如，`DeliverTx`需要在一个区块链状态的缓存副本上处理区块中的所有交易，并在处理成功完成后提交这些更改。
- en: The SDK provides a data marshalling and unmarshalling library called go-amino.
    It allows byte array data in transactions to be easily converted to GO objects
    back and forth.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDK 提供了一个名为 go-amino 的数据编解码库。它允许在交易中将字节数组数据轻松地相互转换为 GO 对象。
- en: The SDK provides a router object to route all messages from a Remote Procedure
    Call (RPC) connector to different modules in the SDK for further processing. The
    router is set up in the way that allows the messages to be processed by multiple
    modules in any specified order.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDK提供了一个路由器对象，用于将来自远程过程调用（RPC）连接器的所有消息路由到SDK中的不同模块以进一步处理。路由器以允许消息被多个模块以任何指定顺序处理的方式设置。
- en: 'In your Cosmos SDK application, you will configure the router for incoming
    messages. The following is an example from the Cosmos SDK tutorial:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Cosmos SDK应用程序中，你需要配置路由器以处理传入的消息。以下是从Cosmos SDK教程中摘取的一个例子：
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_15)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch20_images.xhtml#pro20_15)'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Incoming messages in transactions are first processed by the `bank` module and
    then the `staking` module. `app.bankKeeper` is a callback method implemented by
    the application developer to process events emitted from the `bank` module. For
    example, it could respond to events when one user transfers funds to another.
    The Cosmos SDK provides a library of modules. Currently, most of them are related
    to handling crypto tokens.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 交易中的传入消息首先由`bank`模块处理，然后由`staking`模块处理。`app.bankKeeper`是应用开发者实现的一个回调方法，用于处理来自`bank`模块的事件。例如，它可以响应一个用户向另一个用户转账的事件。Cosmos
    SDK提供了一个模块库。目前，大多数都与处理加密代币有关。
- en: The `auth` module checks and validates signatures in transactions.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`模块负责检查和验证交易中的签名。'
- en: The `bank` module manages user accounts and addresses for holding crypto tokens.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bank`模块负责管理用户账户和地址，用于持有加密代币。'
- en: The `mint` module manages minting and issues crypto tokens during the operation
    of the blockchain.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mint`模块负责在区块链运行过程中管理铸币和发行加密代币。'
- en: The `staking` module manages how users could stake their tokens to support network
    security in a proof-of-stake (PoS) manner.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staking`模块负责管理用户如何抵押他们的代币以支持 proof-of-stake (PoS) 方式下的网络安全。'
- en: The `distribution` module manages how the staking award (interest on staking)
    is distributed to users.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distribution`模块负责管理如何将抵押奖励（抵押利息）分发给用户。'
- en: The `slashing` module manages how to punish users who staked misbehaving actors
    in the system.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slashing`模块负责管理如何惩罚在系统中行为不当的抵押用户。'
- en: The `ibc` module manages the cross-chain asset exchange protocol supported by
    the Cosmos Hub.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ibc`模块负责管理由Cosmos Hub支持的跨链资产交换协议。'
- en: As of April 2019, the Cosmos SDK implements basic functionalities for a generic
    PoS blockchain. It does not yet support any virtual machine functionalities. To
    support programmable blockchains, the Cosmos SDK road map calls for incorporating
    virtual machines as modules to process transactions. The future of Cosmos SDK
    is bright.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2019年4月，Cosmos SDK实现了通用PoS区块链的基本功能。它尚未支持任何虚拟机功能。为了支持可编程区块链，Cosmos SDK的发展路线图呼吁将虚拟机作为模块来处理交易。Cosmos
    SDK的未来是光明的。
- en: Conclusion
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we explored the ABCI protocol and demonstrated how to build
    blockchain applications. Those ABCI applications allow the blockchain to offload
    much of the computationally intensive tasks. Developers can now write applications
    with complex transactional logic in a highly efficient manner. An important space
    to watch is the development of the Cosmos SDK, which could dramatically simplify
    the development of Tendermint-based application blockchains.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ABCI协议，并展示了如何构建区块链应用程序。这些ABCI应用程序使得区块链能够卸载许多计算密集型的任务。现在开发者可以以一种高度有效的方式编写具有复杂交易逻辑的应用程序。需要密切关注的一个领域是Cosmos
    SDK的发展，它可能会大大简化基于Tendermint的应用区块链的开发。
- en: 21. Creating a Blockchain Client
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21. 创建区块链客户端
- en: In the previous chapter, I discussed how to build Application BlockChain Interface
    (ABCI) applications to handle the business logic of a blockchain. That allows
    us to develop complex logic to process, transform, and validate transactions to
    be recorded in the blockchain. For each transaction, the ABCI application can
    apply rules, compute its persistent effects (e.g., changes to account balances
    for a monetary transaction), and save results in an off-chain database. Since
    the ABCI application can be written in any language and on any software stack
    and can support arbitrary transactional logic, it allows us to build a variety
    of different blockchains with specific purposes and optimizations. Each ABCI application
    is a blockchain.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我讨论了如何构建应用程序区块链接口（ABCI）应用程序来处理区块链的业务逻辑。这允许我们开发复杂的逻辑来处理、转换和验证交易以记录在区块链上。对于每一笔交易，ABCI应用程序可以应用规则，计算其持久效果（例如，货币交易的账户余额变化），并将结果保存在离线数据库中。由于ABCI应用程序可以编写在任何语言中，并且可以支持任意交易逻辑，它允许我们构建具有特定目的和优化的各种区块链。每个ABCI应用程序都是一个区块链。
- en: However, with all its power, the ABCI application is still designed around transactions.
    In traditional enterprise software terms, the ABCI application is middleware providing
    business or transactional logic. It does not provide user interface or high-level
    application logic. Similar to Ethereum, the ABCI applications also require a decentralized
    dapp (dapp) layer to be accessible to end users. The dapp utilizes data and functions
    provided by the blockchain (i.e., the ABCI application), and hence the dapp is
    a client to the blockchain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管ABCI应用程序功能强大，它仍然设计于围绕交易。用传统企业软件的术语来说，ABCI应用程序是提供业务或交易逻辑的中间件。它不提供用户界面或高级应用程序逻辑。与以太坊类似，ABCI应用程序也需要一个去中心化的dapp（dapp）层以便终端用户能够访问。dapp利用区块链提供的数据和功能（即ABCI应用程序），因此dapp是区块链的客户端。
- en: '**Note**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Tendermint dapp is different from the Ethereum dapp covered in earlier chapters
    of the book. An Ethereum dapp is a client for smart contracts deployed on the
    blockchain. It is limited to invoking public methods exposed by the contract.
    A Tendermint dapp, on the other hand, has full access to the transaction records
    stored in the blockchain, as well as off-chain databases maintained by the ABCI
    application. It is a “dapp on steroids.”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的Tendermint dapp与书中前几章介绍的以太坊dapp不同。以太坊dapp是部署在区块链上的智能合约的客户端。它限于调用合约公开的方法。另一方面，Tendermint
    dapp拥有对存储在区块链中的交易记录以及由ABCI应用程序维护的离线数据库的完全访问权限。它是“加强版dapp”。
- en: In this chapter, I will demonstrate how to build a dapp on the Tendermint platform,
    using the facts example from the previous chapter. We will build a web application,
    but the principle is the same for any type of modern user interface.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将展示如何使用上一章中的facts示例在Tendermint平台上构建一个dapp。我们将构建一个网络应用程序，但原理对于任何现代用户界面类型都是相同的。
- en: Overview of the Approach
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法概述
- en: The simplest approach to a dapp is to build an external application that interacts
    with the blockchain application programming interface (API). As described in earlier
    chapters, the API commands are sent via TCP/IP port 46657 to any node on the blockchain
    network. The application sends in transactions and queries via the `/broadcast_tx_commit`
    and `/abci_query` API methods, respectively. The dapp exists outside of the blockchain.
    It is not aware of the inner workings of the ABCI application. This is truly a
    blockchain as a service setup ([Figure 21.1](ch21.xhtml#ch21fig1)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实现dapp的最简单方法是构建一个与区块链应用程序编程接口（API）交互的外部应用程序。如前几章所述，API命令通过TCP/IP端口46657发送到区块链网络上的任何节点。应用程序通过`/broadcast_tx_commit`和`/abci_query`API方法分别发送交易和查询。dapp存在于区块链之外。它不知道ABCI应用程序的内部运作。这真的是一个区块链服务设置（见**图21.1**）。
- en: '![image](Images/yuan_f21_01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f21_01.jpg)'
- en: '**Figure 21-1** The dapp with blockchain as a service'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21-1** 以服务形式提供的区块链dapp'
- en: However, this type of dapp is just another web site or mobile app. It is typically
    created and managed by a central entity. It accesses the blockchain through a
    predefined custom data protocol and lacks in-depth access of the underlying data
    structure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种类型的dapp只是一个网站或移动应用程序。它通常由一个中心实体创建和管理。它通过预定义的自定义数据协议访问区块链，并且缺乏对底层数据结构的深入访问。
- en: An alternative is to build a distributed application that runs on each node.
    This application could be deeply integrated with the ABCI application, with local
    access to databases ([Figure 21.2](ch21.xhtml#ch21fig2)). The advantage of this
    approach is a higher level of decentralization and a more efficient application
    architecture. The disadvantages are that it creates a software dependency on the
    applications at the node level, and it increases the potential security risks
    for the blockchain, as nodes are serving application services via the Internet.
    Those disadvantages increase the difficulties of application deployment and management.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方案是构建一个在每个节点上运行的分布式应用。这个应用可以与ABCI应用深度集成，具有对数据库的本地访问([图21.2](ch21.xhtml#ch21fig2))。这种方法的优点是去中心化程度更高，应用架构更高效。缺点是它在节点层面创建了对应用的软件依赖，并且它增加了区块链的潜在安全风险，因为节点通过互联网提供应用服务。这些缺点增加了应用部署和管理的难度。
- en: '![image](Images/yuan_f21_02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f21_02.jpg)'
- en: '**Figure 21-2** A tightly integrated dapp architecture'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21-2** 紧密集成的dapp架构'
- en: '**Note**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Even in a decentralized architecture, where the dapp software runs on every
    node, there still needs to be a centralized entry point. For example, if the dapp
    is a web app, it still needs a URL. In this case, a lightweight centralized load
    balancer is needed to direct traffic to the blockchain nodes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在去中心化的架构中，dapp软件在每一个节点上运行，仍然需要一个中心化的入口点。例如，如果dapp是一个网络应用，它仍然需要一个URL。在这种情况下，需要一个轻量级中心化负载均衡器来将流量引导到区块链节点。
- en: The Sample Application
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例应用
- en: The sample application shown here is a web app user interface (UI) based on
    the facts application in [Chapter 20](ch20.xhtml#ch20). It allows the user to
    enter facts, with sources and statements, on a web page. And the same page displays
    the current tally of statements by sources ([Figure 21.3](ch21.xhtml#ch21fig3)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例应用是基于第20章中的事实应用的网络应用用户界面（UI）。它允许用户在一个网页上输入事实、来源和陈述。同一页面显示了按来源当前的陈述统计([图21.3](ch21.xhtml#ch21fig3))。
- en: '![image](Images/yuan_f21_03.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f21_03.jpg)'
- en: '**Figure 21-3** The dapp web app for facts'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21-3** 事实的dapp网络应用'
- en: In the next two sections, I will demonstrate how to create this web application
    in PHP and Java. The PHP application is a simple web application that used the
    Blockchain API as a back end. The Java application is tightly integrated with
    the ABCI application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我将演示如何使用PHP和Java创建这个网络应用。PHP应用是一个简单的网络应用，使用区块链API作为后端。Java应用与ABCI应用紧密集成。
- en: PHP
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: We developed a PHP web app to utilize the blockchain API via the TCP socket
    connection. The blockchain runs Tendermint Core and the facts ABCI application
    described in [Chapter 20](ch20.xhtml#ch20).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了一个PHP网络应用，通过TCP套接字连接使用区块链API。区块链运行Tendermint Core和第20章中描述的事实ABCI应用。
- en: The PHP code first checks whether this request is a submission of the form,
    and if it is, the PHP code will send the transaction to the blockchain and wait
    until it commits.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: PHP代码首先检查这个请求是否是表单的提交，如果是，PHP代码将发送交易到区块链并等待它提交。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_1)'
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, the PHP code queries the blockchain via its custom query API to check
    for the tally of facts based on the source. The query is passed to the ABCI application.
    As discussed, the ABCI application is responsible for parsing the query, creating
    a response, and sending the response via the blockchain. The ABCI response is
    in a structured JavaScript Object Notation (JSON) message. The value field in
    the response message contains the results encoded in hex characters. The PHP code
    will parse the hex content and then display the results in a table.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，PHP代码通过其自定义查询API查询区块链，以根据来源检查事实的统计。该查询传递给ABCI应用。如前所述，ABCI应用负责解析查询，创建响应，并通过区块链发送响应。ABCI响应是一个结构化的JavaScript对象表示法（JSON）消息。响应消息中的值字段包含用十六进制字符编码的结果。PHP代码将解析十六进制内容，然后将结果显示在表格中。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_2)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_2)'
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Java
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: The Java web application accomplishes the same functionalities as the PHP application,
    but it is directly integrated with the ABCI application’s data store. In fact,
    the ABCI application runs inside the same JVM as the Java web application. Let’s
    look into how this works.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Java网络应用程序实现了与PHP应用程序相同的功能性，但它与ABCI应用程序的数据存储直接集成。实际上，ABCI应用程序在同一个JVM中运行，与Java网络应用程序一起。让我们来看看这是如何实现的。
- en: In the Java web application’s `web.xml` file, we specify that a servlet will
    run as soon as the application loads in Tomcat.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java网络应用程序的`web.xml`文件中，我们指定了一个servlet将在应用程序在Tomcat中加载时立即运行。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_3)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_3)'
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That servlet loads and runs the ABCI application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那个servlet加载并运行ABCI应用程序。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_4)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_4)'
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, in the servlet filter in front of the `index.jsp` web page, we first check
    whether a new fact (source and statement) is submitted in this request. If this
    is the case, the filter sends the transaction to the blockchain using its regular
    TCP socket API connection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`index.jsp`网页前的Servlet过滤器中，我们首先检查这个请求中是否提交了一个新事实（源和陈述）。如果是这样，过滤器使用其常规的TCP套接字API连接将事务发送到区块链。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_5)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_5)'
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The filter then queries the ABCI application’s data store directly to get a
    tally of facts by sources. Notice that we do not go through the socket-based blockchain
    query API for this. While for this simple application the data store query is
    simple and well supported by the blockchain query API, I can envision application
    scenarios where the dapp makes heavy use of the off-chain application data store
    for complex business logic and UI logic.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器然后直接查询ABCI应用程序的数据存储以获取来源的事实汇总。注意我们这次没有通过基于套接字的区块链查询API进行操作。虽然对于这个简单的应用程序，数据存储查询简单且得到区块链查询API的良好支持，但我可以预见应用程序场景中，dapp会大量使用离链应用程序数据存储来进行复杂的业务逻辑和UI逻辑。
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_6)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch21_images.xhtml#pro21_6)'
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Java application can be found in the book’s GitHub repository. You can
    build a WAR file ready for Apache Tomcat deployment by running the following Maven
    build command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序可以在本书的GitHub仓库中找到。您可以运行以下Maven构建命令来生成准备在Apache Tomcat部署的WAR文件：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Conclusion
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I showed how to build a complete blockchain application accessible
    to end users. I showed a web application, but it could easily be a web service
    to support rich client (i.e., mobile) applications. While it is possible to build
    completely decentralized dapps, most dapps are created and operated by companies
    offering services to their users.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了如何构建一个可以向最终用户提供的完整区块链应用程序。我展示了一个网络应用程序，但它很容易就是一个支持丰富客户端（即移动应用）的网络服务。虽然可以构建完全去中心化的dapps，但大多数dapps都是由向其用户提供服务的公司创建和运营的。
