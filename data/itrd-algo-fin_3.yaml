- en: ''
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part III
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分
- en: Blockchain and Cryptocurrency
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链和加密货币
- en: Chapter 16
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章
- en: Background Concepts for Blockchain
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的背景概念
- en: Understanding blockchain requires some background in two different areas of
    computer science and mathematics, namely cryptography and distributed computing.
    In this chapter, we provide a minimal introduction to these two areas.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解区块链需要一些计算机科学和数学的背景知识，即密码学和分布式计算。在本章中，我们对这两个领域进行了最基本的介绍。
- en: 16.1 Cryptography
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1 密码术
- en: 16.1.1 Cryptographic Hash Function
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1 密码哈希函数
- en: Digital information appears in various forms. Examples would be messages on
    social networks, financial transactions and images. Whatever be the form, at a
    very basic level, any particular digital information can be considered to be a
    sequence of bits. The length of the sequence is not fixed. It can vary quite a
    bit, from a few hundred bits for a short message to a billion (or more) bits for
    a large image.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数字信息以各种形式出现，例如社交网络上的消息、金融交易和图像。无论形式如何，在非常基本的层面上，任何特定的数字信息都可以被视为一系列位。序列的长度不是固定的，它可以有很大的变化，从一个短消息的几百位到一个大图像的十亿（甚至更多）位。
- en: A fundamental requirement in many cryptographic applications is the ability
    to associate a unique identifier to any digital information. Such an identifier
    is typically a short fixed length binary string. In many cases, it is more convenient
    to work with the unique identifier of a digital information rather than the information
    itself. Conventionlly, the digital information is called the *message* and the
    associated unique identifier is called the *digest* of the message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多加密应用中，一个基本要求是能够将唯一标识符与任何数字信息关联起来。这样的标识符通常是一个短的固定长度的二进制字符串。在许多情况下，与数字信息的唯一标识符一起工作会更方便，而不是直接使用数字信息本身。通常，数字信息被称为*消息*，而关联的唯一标识符被称为*摘要*。
- en: A hash function is a method for computing the digest corresponding to any given
    message. Different hash functions give rise to different methods for computing
    a digest. Nevertheless, any such hash function should satisfy certain properties
    discussed below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是计算与任何给定消息对应的摘要的方法。不同的哈希函数导致不同的计算摘要的方法。然而，任何这样的哈希函数都应满足下面讨论的某些特性。
- en: '*Domain*: The domain of the hash function is ![inline-image](../images/CH016_1.jpg)
    where ![inline-image](../images/CH016_2.jpg) is a constant. This means that the
    hash function can be used to compute the digest of messages having lengths from
    0 (corresponding to the empty string) to ![inline-image](../images/CH016_3.jpg).
    Usually ![inline-image](../images/CH016_4.jpg) is taken to be a very large value
    such as 2^(64).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*域*：哈希函数的域是![inline-image](../images/CH016_1.jpg)，其中![inline-image](../images/CH016_2.jpg)是一个常数。这意味着哈希函数可以用于计算具有长度从0（对应空字符串）到![inline-image](../images/CH016_3.jpg)的消息的摘要。通常情况下，![inline-image](../images/CH016_4.jpg)被取为一个非常大的值，如2^(64)。'
- en: '*Range*: The range of the hash function is ![inline-image](../images/CH016_5.jpg),
    where *n* is a constant. This means that the digest produced by the hash function
    on any message is an *n*-bit string. The choice of *n* is determined by certain
    security considerations. Typically, *n* = 256 or higher.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*值域*：哈希函数的值域为 ![inline-image](../images/CH016_5.jpg)，其中 *n* 是一个常数。这意味着哈希函数对任何消息产生的摘要都是一个
    *n* 位的字符串。选择 *n* 受到一定的安全考虑的影响。通常情况下，*n* = 256 或更高。'
- en: '*Efficiency*: In many applications, it is routinely required to compute digests
    of millions of messages. So, a basic requirement is that it should be very fast
    to evaluate the application of the hash function to a message.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*效率*：在许多应用中，通常需要计算数百万条消息的摘要。因此，基本要求是计算哈希函数应用于消息的过程应该非常快速。'
- en: Formally, a hash function is a map
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，哈希函数是一个映射
- en: '![display-image](../images/CH016_6.jpg)(16.1)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH016_6.jpg)(16.1)'
- en: where ![inline-image](../images/CH016_7.jpg) and ![inline-image](../images/CH016_8.jpg)
    are finite non-empty sets with ![inline-image](../images/CH016_9.jpg). Here, ![inline-image](../images/CH016_10.jpg)
    denotes the cardinality of a finite set *S*, i.e. the number of elements in *S*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![inline-image](../images/CH016_7.jpg) 和 ![inline-image](../images/CH016_8.jpg)
    是有限非空集合，满足 ![inline-image](../images/CH016_9.jpg)。这里，![inline-image](../images/CH016_10.jpg)
    表示有限集合 *S* 的基数，即 *S* 中的元素数量。
- en: Note that the domain of a hash function is larger than its range. This implies
    that there cannot be a unique digest for every message in the domain of the hash
    function. Recall that we had motivated hash functions by the requirement of ensuring
    unique digests. Clearly, the condition of the domain being larger than the range
    and the requirement of unique digests are contradictory. This contradiction is
    resolved in the following manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的定义域大于其值域。这意味着哈希函数的定义域中不可能有唯一的摘要与每个消息对应。回想我们之前为哈希函数提出的要求是确保唯一摘要。显然，定义域大于值域的条件和唯一摘要的要求是矛盾的。这种矛盾以以下方式解决。
- en: Let *M* and ![inline-image](../images/CH016_11.jpg) be two distinct elements
    of ![inline-image](../images/CH016_12.jpg) such that ![inline-image](../images/CH016_13.jpg).
    The pair of messages ![inline-image](../images/CH016_14.jpg) is called a collision
    for *H*. It is true that if *H* is evaluated on all elements in its domain, then
    collisions will certainly arise. However, since the domain is very large, in practice
    it will not be possible to evaluate *H* on the entire domain. Compared to the
    size of the domain, the hash function will be evaluated on only an insignificant
    fraction of the domain. To ensure the uniqueness of the digests, it is sufficient
    for the hash function to behave like an injective function on the inputs on which
    it is actually evaluated. This in particular means that in practice collisions
    should not arise. This leads to the following required property of a hash function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让*M*和![inline-image](../images/CH016_11.jpg)成为![inline-image](../images/CH016_12.jpg)的两个不同元素，使得![inline-image](../images/CH016_13.jpg)。消息对![inline-image](../images/CH016_14.jpg)被称为*H*的一次碰撞。确实，如果在其定义域上对*H*进行评估，碰撞肯定会发生。但是，由于定义域非常大，在实践中将无法对*H*进行整个定义域的评估。与定义域的大小相比，哈希函数只会在定义域的微不足道的一小部分上进行评估。为了确保摘要的唯一性，哈希函数只需在实际评估的输入上表现得像一个单射函数即可。特别是，这意味着在实践中不应该发生碰撞。这导致哈希函数的以下所需特性。
- en: '**Collision-Resistant Hash Function (CRHF):** A hash function *H* is said to
    be collision resistant if it is *computationally difficult* to find a collision
    for *H*. Computational difficulty in the present context means that given reasonable
    computational resources, it should not be possible to find a collision for *H*
    in a reasonable amount of time.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**抗碰撞哈希函数（CRHF）：** 如果哈希函数*H*很难找到一个碰撞，那么称为抗碰撞的哈希函数。在当前的语境中，计算困难意味着在合理的计算资源下，不应该能够在合理的时间内找到*H*的碰撞。'
- en: We have mentioned above that it should be possible to evaluate a hash function
    very fast, i.e. given a message *M*, it should be possible to compute the digest
    *H*(*M*) within a (very small) fraction of a second. Consider the converse problem.
    Suppose that we are given a digest *y* which is an *n*-bit string. How difficult
    is it to find a message *M* such that *H*(*M*) = *y*? More generally, how difficult
    is it to find a pre-image of any given digest? One way to find a pre-image is
    to repeatedly apply *H* to different messages until a message is found which maps
    under *H* to *y*. Since there are 2 ^([*n*]) possible digests, this procedure
    may require applying *H* to 2 ^([*n*]) messages. A requirement on a hash function
    is that there should essentially be no better way of finding a pre-image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，应该能够非常快速地评估一个哈希函数，即，给定一个消息*M*，应该能够在（非常小的）一秒内计算出摘要*H*(*M*)。考虑相反的问题。假设我们给定了一个*n*比特字符串的摘要*y*。找到一个消息*M*，使得*H*(*M*)
    = *y*，有多难呢？更一般地说，找到任何给定摘要的原像有多难呢？一种找到原像的方法是反复将*H*应用于不同的消息，直到找到一个消息，该消息在*H*下映射到*y*。由于存在2
    ^([*n*])个可能的摘要，这个过程可能需要将*H*应用于2 ^([*n*])个消息。对哈希函数的一个要求是基本上没有更好的方法来找到原像。
- en: '**One-Way Hash Function (OWHF):** A hash function *H* is said to be one way,
    if it is *computationally difficult* to find a pre-image of any element in the
    range of *H*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**单向哈希函数（OWHF）：** 如果一个哈希函数 *H* 被认为是单向的，那么在 *H* 的值域中找到任何元素的原像是*计算难度*的。'
- en: Suppose that *M* and *y* are known such that *H*(*M*) = *y*. One may wish to
    find a message ![inline-image](../images/CH016_15.jpg) such that ![inline-image](../images/CH016_16.jpg).
    In other words, one pre-image of *y* under *H* is known to be *M* and the problem
    is to find another pre-image of *y*. This is not the same as asking for a pre-image
    of *y*. Neither is it the same as asking for a collision for *H*, since in a collision,
    one simply asks for a pair of distinct messages *M* and ![inline-image](../images/CH016_17.jpg)
    such that ![inline-image](../images/CH016_18.jpg); this is different from first
    specifying *y* and *M* and then asking for ![inline-image](../images/CH016_19.jpg).
    In fact, evidence suggests that finding a second pre-image has the same difficulty
    level as finding a pre-image and is actually a much more difficult task than finding
    a collision.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已知 *M* 和 *y*，使得 *H*(*M*) = *y*。一个可能希望找到一个消息 ![inline-image](../images/CH016_15.jpg)，使得
    ![inline-image](../images/CH016_16.jpg)。换句话说，已知*H*下的*y*的一个原像是*M*，问题是找到另一个*y*的原像。这不同于请求*y*的原像。也不同于要求*H*的冲突，因为在冲突中，只需请求一对不同的消息*M*和![inline-image](../images/CH016_17.jpg)，使得![inline-image](../images/CH016_18.jpg)；这与首先指定*y*和*M*然后请求![inline-image](../images/CH016_19.jpg)是不同的。事实上，有证据表明找到第二个原像的难度与找到一个原像的难度相同，实际上比找到一个冲突要困难得多。
- en: '**Second Pre-Image-Resistant Hash Function:** A hash function *H* is said to
    be second pre-image resistant if it is *computationally difficult* to perform
    the following task. For any element in the range of *H*, given one of its pre-images,
    find a second one (or report that there is no second pre-image).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次预像抗碰撞哈希函数：** 哈希函数 *H* 被称为二次预像抗碰撞的，如果对于执行以下任务来说是计算难度较大的。对于 *H* 的任何一个值域中的元素，在给定其中一个原像的情况下，找到第二个（或者报告没有第二个原像）是困难的。'
- en: Later, we justify the collision-resistant, one-way and the second pre-image-resistant
    properties of hash functions in the context of blockchain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，在区块链的上下文中，我们证明了哈希函数的抗碰撞、单向和二次预像抗碰撞的性质。
- en: 16.1.2 Hash Function as a Random Oracle
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2 哈希函数作为随机预言机
- en: A cryptographic hash function is often modelled as a random oracle. Here a random
    oracle is a uniform random function from ![inline-image](../images/CH016_20.jpg)
    to ![inline-image](../images/CH016_21.jpg). Recall that ![inline-image](../images/CH016_22.jpg)
    and ![inline-image](../images/CH016_23.jpg) are finite non-empty sets. So, the
    set ![inline-image](../images/CH016_24.jpg) of all functions from ![inline-image](../images/CH016_25.jpg)
    to ![inline-image](../images/CH016_26.jpg) is a finite set. Suppose ![inline-image](../images/CH016_27.jpg)
    is a function chosen uniformly at random from ![inline-image](../images/CH016_28.jpg).
    Such an ![inline-image](../images/CH016_29.jpg) is said to be a random oracle.
    The function ![inline-image](../images/CH016_30.jpg) is viewed in the following
    manner. It is queried on an element of ![inline-image](../images/CH016_31.jpg)
    and returns an element of ![inline-image](../images/CH016_32.jpg). A crucial property
    of a random oracle is the following. Suppose *M* 1,…,*M* *k* are distinct elements
    of ![inline-image](../images/CH016_33.jpg). Then ![inline-image](../images/CH016_34.jpg)
    are *independent and uniform random* elements of ![inline-image](../images/CH016_35.jpg).
    Note that ![inline-image](../images/CH016_36.jpg) is a function, so if it is evaluated
    on the same input twice, it will return the same answer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数通常被建模为随机预言机。在这里，随机预言机是一个从 ![inline-image](../images/CH016_20.jpg) 到 ![inline-image](../images/CH016_21.jpg)
    的均匀随机函数。请记住，![inline-image](../images/CH016_22.jpg) 和 ![inline-image](../images/CH016_23.jpg)
    是有限非空集合。因此，从 ![inline-image](../images/CH016_24.jpg) 到 ![inline-image](../images/CH016_26.jpg)
    的所有函数的集合是一个有限集合。假设 ![inline-image](../images/CH016_27.jpg) 是从 ![inline-image](../images/CH016_28.jpg)
    均匀随机选择的函数。这样的 ![inline-image](../images/CH016_29.jpg) 被称为随机预言机。函数 ![inline-image](../images/CH016_30.jpg)
    的视图如下。它在 ![inline-image](../images/CH016_31.jpg) 的元素上查询并返回 ![inline-image](../images/CH016_32.jpg)
    的元素。随机预言机的一个关键属性如下。假设 *M* 1,…,*M* *k* 是 ![inline-image](../images/CH016_33.jpg)
    的不同元素。那么 ![inline-image](../images/CH016_34.jpg) 是 ![inline-image](../images/CH016_35.jpg)
    中的*独立和均匀随机*元素。请注意，![inline-image](../images/CH016_36.jpg) 是一个函数，因此如果它在相同的输入上评估两次，它将返回相同的答案。
- en: Even though ![inline-image](../images/CH016_37.jpg) is a random oracle, the
    domain is still larger than the range. So, ![inline-image](../images/CH016_38.jpg)
    will still have collisions. Let us consider the difficulty of finding a collision
    for ![inline-image](../images/CH016_39.jpg). The only way to evaluate ![inline-image](../images/CH016_40.jpg)
    is by querying it on (distinct) messages *M* 1,…,*M* *k* . Suppose ![inline-image](../images/CH016_41.jpg)
    are the corresponding outputs. The probability that ![inline-image](../images/CH016_42.jpg)
    are all distinct is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管![inline-image](../images/CH016_37.jpg)是一个随机预言机，但定义域仍然大于值域。因此，![inline-image](../images/CH016_38.jpg)仍然会发生碰撞。让我们考虑找到![inline-image](../images/CH016_39.jpg)碰撞的难度。评估![inline-image](../images/CH016_40.jpg)的唯一方法是在（不同的）消息*M*1,…,*M*k上查询它。假设![inline-image](../images/CH016_41.jpg)是相应的输出。![inline-image](../images/CH016_42.jpg)都是不同的概率是
- en: '![display-image](../images/CH016_43.jpg)(16.2)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH016_43.jpg)(16.2)'
- en: For ![inline-image](../images/CH016_44.jpg), it can be shown that ![inline-image](../images/CH016_45.jpg).
    The probability of obtaining a collision is ![inline-image](../images/CH016_46.jpg).
    For *k* about ![inline-image](../images/CH016_47.jpg), the probability of obtaining
    a collision becomes greater than ![inline-image](../images/CH016_48.jpg). The
    value ![inline-image](../images/CH016_49.jpg) is called the birthday bound (following
    the so-called birthday paradox). So, if ![inline-image](../images/CH016_50.jpg)
    is queried on ![inline-image](../images/CH016_51.jpg) distinct messages, then
    finding a collision becomes likely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于![inline-image](../images/CH016_44.jpg)，可以证明![inline-image](../images/CH016_45.jpg)。获得碰撞的概率是![inline-image](../images/CH016_46.jpg)。对于大约![inline-image](../images/CH016_47.jpg)的*k*，获得碰撞的概率大于![inline-image](../images/CH016_48.jpg)。值![inline-image](../images/CH016_49.jpg)被称为生日界限（遵循所谓的生日悖论）。因此，如果在![inline-image](../images/CH016_51.jpg)上查询![inline-image](../images/CH016_50.jpg)不同的消息，那么找到碰撞就变得可能。
- en: A concrete hash function *H* is not a random oracle. Often, however, it is assumed
    that *H* behaves like a random oracle. In particular, it is expected that *H*
    would need to be evaluated on ![inline-image](../images/CH016_52.jpg) distinct
    messages before obtaining a collision. The random oracle assumption on *H* is
    also often used to (heuristically) argue about the distribution of the outputs
    of *H*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的哈希函数*H*不是一个随机预言机。然而，通常假设*H*的行为类似于随机预言机。特别是，人们期望在获得碰撞之前需要对*H*进行![inline-image](../images/CH016_52.jpg)次评估。对*H*的随机预言机假设也经常用于（启发式地）论证*H*的输出分布。
- en: 16.1.3 Digital Signature Schemes
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.3数字签名方案
- en: A signature is a key component of any contract. It affirms the signer's commitment
    to the contract in a manner which cannot be repudiated in the future. In the digital
    world, a digital signature fulfills a role similar to that of a handwritten signature
    in the physical world. A digital signature is not, however, an exact analogue
    of a physical handwritten signature. We do not get into the finer distinctions
    between digital and physical signatures. Instead, we provide below a high-level
    overview of digital signatures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是任何合同的关键组成部分。它确认了签署者对合同的承诺，这种承诺在未来无法否认。在数字世界中，数字签名履行了类似于物理世界中手写签名的角色。然而，数字签名并不是物理手写签名的确切类比。我们不深入讨论数字和物理签名之间的细微差别。相反，我们在下面提供了数字签名的高级概述。
- en: An electronic contract (e-contract) is a digital document. Like a physical contract,
    an e-contract requires a non-repudiable commitment from the parties involved in
    the contract. This is achieved by affixing the digital signatures of the parties
    to the contract. Suppose Alice signs a digital document *M* to produce a signature
    *s*. There are two basic requirements from any such digital signature. First,
    it must be guaranteed that only Alice could have produced *s* on the message *M*.
    Second, given *M* and *s*, it must be possible for any other party (say Bob) to
    verify that *s* is indeed Alice's signature on *M*. The first condition requires
    Alice to possess some information which is available only to her. This is called
    Alice's signing (or secret) key ![inline-image](../images/CH016_53.jpg). To enable
    the second condition of public verifiability by Bob, Alice has to make public
    some information corresponding to her secret key. This is called Alice's verification
    (or public) key ![inline-image](../images/CH016_54.jpg).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电子合同（e-合同）是一种数字文档。像物理合同一样，e-合同需要合同参与方的不可否认的承诺。这通过在合同上附上各方的数字签名来实现。假设爱丽丝签署了数字文档*M*以产生签名*s*。任何这样的数字签名都有两个基本要求。首先，必须保证只有爱丽丝才能在消息*M*上产生*s*。其次，给定*M*和*s*，任何其他方（比如鲍勃）都必须能够验证*s*确实是爱丽丝在*M*上的签名。第一个条件要求爱丽丝拥有一些仅她知道的信息。这称为爱丽丝的签名（或秘密）密钥
    ![inline-image](../images/CH016_53.jpg)。为了使鲍勃能够进行公开验证的第二个条件，爱丽丝必须公开一些与她的秘密密钥对应的信息。这称为爱丽丝的验证（或公开）密钥
    ![inline-image](../images/CH016_54.jpg)。
- en: 'More formally, a digital signature scheme consists of three procedures (or
    algorithms): ![inline-image](../images/CH016_55.jpg). Alice runs the ![inline-image](../images/CH016_56.jpg)
    algorithm to produce a matched pair of signing-verification key ![inline-image](../images/CH016_57.jpg).
    She keeps ![inline-image](../images/CH016_58.jpg) secret and publishes ![inline-image](../images/CH016_59.jpg)
    as her verification key. To sign a message *M*, Alice uses the ![inline-image](../images/CH016_60.jpg)
    algorithm on *M* and ![inline-image](../images/CH016_61.jpg) to produce a signature
    *s*. She then provides (*M*, *s*) as the message-signature pair. To verify, Bob
    uses the ![inline-image](../images/CH016_62.jpg) algorithm on (*M*, *s*) and ![inline-image](../images/CH016_63.jpg);
    if the answer of ![inline-image](../images/CH016_64.jpg) is ‘yes’, Bob accepts
    *s* as Alice''s signature on *M*, while if the answer is ‘no’, Bob rejects the
    message-signature pair.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，数字签名方案由三个过程（或算法）组成：![内联图片](../images/CH016_55.jpg)。爱丽丝运行![内联图片](../images/CH016_56.jpg)算法以生成一对匹配的签名-验证密钥![内联图片](../images/CH016_57.jpg)。她保持![内联图片](../images/CH016_58.jpg)保密，并发布![内联图片](../images/CH016_59.jpg)作为她的验证密钥。为了签署一条消息*M*，爱丽丝对*M*使用![内联图片](../images/CH016_60.jpg)算法和![内联图片](../images/CH016_61.jpg)以生成签名*s*。然后，她提供(*M*,
    *s*)作为消息-签名对。为了验证，鲍勃对(*M*, *s*)使用![内联图片](../images/CH016_62.jpg)算法和![内联图片](../images/CH016_63.jpg);
    如果![内联图片](../images/CH016_64.jpg)的答案是‘是’，鲍勃接受*s*作为爱丽丝对*M*的签名，而如果答案是‘否’，鲍勃拒绝消息-签名对。
- en: Note that the algorithms ![inline-image](../images/CH016_65.jpg) are not specific
    to Alice. Any other entity, say Charles, can also use ![inline-image](../images/CH016_66.jpg)
    to generate his signing and verification keys ![inline-image](../images/CH016_67.jpg)
    and ![inline-image](../images/CH016_68.jpg), respectively; and use ![inline-image](../images/CH016_69.jpg)
    with ![inline-image](../images/CH016_70.jpg) to sign a message. Further, ![inline-image](../images/CH016_71.jpg)
    can be used by Bob to verify signatures generated by Charles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，算法![内联图片](../images/CH016_65.jpg)并不特定于爱丽丝。任何其他实体，比如查尔斯，也可以使用![内联图片](../images/CH016_66.jpg)生成他的签名和验证密钥![内联图片](../images/CH016_67.jpg)和![内联图片](../images/CH016_68.jpg)，并使用![内联图片](../images/CH016_69.jpg)与![内联图片](../images/CH016_70.jpg)来签署一条消息。此外，![内联图片](../images/CH016_71.jpg)还可以被鲍勃用来验证查尔斯生成的签名。
- en: A key requirement of a digital signature scheme is non-repudiability. If Alice
    claims *s* is her signature on a message *M*, then later she cannot go back on
    her claim and deny that she signed *M*. This is achieved by ensuring that ![inline-image](../images/CH016_72.jpg)
    will return ‘yes’ on inputs (*M*, *s*) and ![inline-image](../images/CH016_73.jpg)
    if and only if *s* was produced by applying ![inline-image](../images/CH016_74.jpg)
    on inputs *M* and ![inline-image](../images/CH016_75.jpg). Since ![inline-image](../images/CH016_76.jpg)
    is known only to Alice, it is concluded that she must have signed the message.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名方案的一个关键要求是不可否认性。如果爱丽丝声称*s*是她在消息*M*上的签名，那么她以后不能撤回她的声明并否认她签署了*M*。这通过确保当且仅当*s*是通过在*M*和的输入上应用![inline-image](../images/CH016_74.jpg)得到的时，![inline-image](../images/CH016_72.jpg)对(*M*,
    *s*)的输入返回“是”，并且![inline-image](../images/CH016_73.jpg)。由于![inline-image](../images/CH016_76.jpg)仅为爱丽丝所知，因此可以得出结论她必须已经签署了消息。
- en: For any signature scheme (digital or physical), the major threat is the possibility
    of forging a signature. Note that message-signature pairs are public. So, it is
    possible for a forger, say Eve, to obtain several valid message-signature pairs
    (*M* 1, *s* 1),…,(*M* [*k*] , *s* *k* ) produced by Alice using her signing key
    ![inline-image](../images/CH016_77.jpg). Eve does not have access to ![inline-image](../images/CH016_78.jpg).
    Suppose that after studying the obtained valid message-signature pairs produced
    by Alice, Eve produces a pair ![inline-image](../images/CH016_79.jpg) which is
    not equal to ![inline-image](../images/CH016_80.jpg) for any *i*. Further, suppose
    that running ![inline-image](../images/CH016_81.jpg) on ![inline-image](../images/CH016_82.jpg)
    and ![inline-image](../images/CH016_83.jpg) results in a ‘yes’ answer. So, ![inline-image](../images/CH016_84.jpg)
    is a message-signature pair which has not been produced by Alice, yet it verifies
    under her verification key. This means that Eve has successfully managed to forge
    a signature of Alice. A secure digital signature scheme should disallow such forgeries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何签名方案（数字或物理），主要威胁是伪造签名的可能性。请注意，消息-签名对是公开的。因此，对于伪造者（比如夏娃），可以获得由爱丽丝使用她的签名密钥![inline-image](../images/CH016_77.jpg)生成的几个有效的消息-签名对(*M*
    1, *s* 1),…,(*M* [*k*], *s* *k* )。夏娃无法访问![inline-image](../images/CH016_78.jpg)。假设在研究由爱丽丝生成的获得的有效消息-签名对之后，夏娃产生了一个对*[inline-image](../images/CH016_79.jpg)*不等于任何*i*的对。此外，假设在![inline-image](../images/CH016_82.jpg)和![inline-image](../images/CH016_83.jpg)上运行![inline-image](../images/CH016_81.jpg)的结果是“是”。因此，![inline-image](../images/CH016_84.jpg)是一个消息-签名对，它没有由爱丽丝生成，但在她的验证密钥下验证。这意味着夏娃成功地伪造了爱丽丝的签名。安全的数字签名方案应该阻止这样的伪造。
- en: 16.2 Distributed Computing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2 分布式计算
- en: Distributed computing is a very broad notion. A basic feature of a distributed
    computing system is a collection of computers which are connected by a network.
    More generally, one may consider the computers to be the components of the system.
    The components interact among themselves by passing messages to each other using
    the network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算是一个非常广泛的概念。分布式计算系统的一个基本特征是由网络连接的计算机集合。更一般地，可以将计算机视为系统的组成部分。这些组件通过使用网络相互交互，通过向彼此发送消息来实现交互。
- en: The topology of the network can be varied. Rarely is it the case where all nodes
    are directly connected to each other since such a connection structure would be
    very expensive. The topology could be structured, where the graph describing the
    interconnection network has some kind of a regular structure. Distributed computing
    systems based on the Internet, however, have an unstructured topology. Each component
    can communicate directly with only a small number of neighbours.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的拓扑结构可以是多样的。很少情况下所有节点都直接连接在一起，因为这样的连接结构将会非常昂贵。拓扑结构可以是结构化的，其中描述相互连接网络的图具有某种规则结构。然而，基于互联网的分布式计算系统具有非结构化的拓扑结构。每个组件只能与少数邻居直接通信。
- en: The components operate asynchronously, i.e. there is no global clock determining
    which component does what at each time step. Further, the components can operate
    concurrently and pass messages to other components as and when required. One important
    characteristic is that components can fail. The failures occur independently and
    also asynchronously. Failure does not necessarily mean stoppage of operation.
    A failed component could be producing ‘garbage’ messages. In an adversarial scenario,
    a component could come under the control of an adversary who can then send out
    messages from the compromised component in order to mislead the operating components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件以异步方式运行，即没有全局时钟确定每个时间步骤中哪个组件执行什么操作。此外，这些组件可以并行运行，并在需要时向其他组件传递消息。一个重要的特点是组件可能会发生故障。故障会独立发生，并且异步发生。故障并不一定意味着操作停止。一个失败的组件可能会产生‘垃圾’消息。在对抗性场景中，一个组件可能会受到对手控制，然后从被损坏的组件发送消息，以误导正在运行的组件。
- en: The goal of a distributed computing system is to get some work done. The nature
    of the work could be to perform a joint computation of some computational task.
    Each component performs a portion of the work and sends to one special component.
    This component pools together the inputs from the various components to compute
    the final result. Alternatively, the task could be for the components to agree
    upon a common value. Since the components are distributed and communicate only
    using the network, this task itself is quite complex. In addition, it is required
    to perform the task under possible failure or possible malicious control of the
    components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算系统的目标是完成一些工作。工作的性质可能是执行某些计算任务的联合计算。每个组件执行工作的一部分，并将其发送给一个特殊的组件。该组件将来自各个组件的输入汇集在一起，计算出最终结果。或者，任务可能是让组件就一个共同的值达成一致。由于组件是分布式的，并且仅使用网络进行通信，因此这个任务本身就非常复杂。此外，还需要在可能的组件故障或可能的恶意控制下执行任务。
- en: There are several types of distributed computing networks. Two typical examples
    are the client–server networks and the peer-to-peer (P2P) networks. In the client–server
    network, there is a set of clients, each of which can connect to a background
    server as and when required. Typically, clients may use the server to authenticate
    a user or to complete some heavy computation. The client–server model is not very
    relevant for blockchains, so we do not discuss it any further.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的分布式计算网络。两个典型的例子是客户端-服务器网络和点对点（P2P）网络。在客户端-服务器网络中，有一组客户端，每个客户端都可以在需要时连接到一个后台服务器。通常，客户端可能使用服务器对用户进行身份验证或完成一些繁重的计算。客户端-服务器模型对区块链不太相关，因此我们不再进一步讨论。
- en: 16.2.1 Peer-to-Peer Network
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1 点对点网络
- en: A P2P network is an interconnected network of components (sometimes called nodes).
    There is no central administrative system. All the peers, i.e. the nodes, have
    equal rights (hence the name peer). Note that equal rights does not necessarily
    mean equal computational resources. Two nodes could have different amounts of
    computing powers, yet as far as access to common resources of the network is concerned,
    both the nodes would have the same rights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络是一个相互连接的组件（有时称为节点）网络。没有中央管理系统。所有对等体，即节点，具有相等的权利（因此称为对等体）。请注意，相等的权利并不一定意味着相等的计算资源。两个节点可能具有不同数量的计算能力，但就访问网络的共享资源而言，这两个节点将具有相同的权利。
- en: A node in a P2P network may supply its computational resources to the other
    nodes. Alternatively, it may also utilise the resources of the other nodes for
    its purposes. So, a node is both a supplier and a consumer of resources. Well-known
    examples of P2P networks are file sharing systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络中的一个节点可以向其他节点提供其计算资源。或者，它也可以利用其他节点的资源来完成自己的目的。因此，一个节点既是资源的提供者，也是资源的消费者。点对点网络的著名例子是文件共享系统。
- en: P2P networks usually do not have any structure. A node forwards messages to
    (a subset of) its neighbours. Any such message is then further relayed to the
    neighbours of the neighbours and so on and may ultimately reach all the nodes
    of the system. The manner in which nodes communicate using the network is determined
    by a protocol.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: P2P 网络通常没有任何结构。一个节点将消息转发给（一部分）邻居。任何此类消息然后进一步转发给邻居的邻居，依此类推，最终可能到达系统的所有节点。节点使用网络进行通信的方式由协议确定。
- en: 16.2.2 Gossip Protocol
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2 八卦协议
- en: A gossip protocol is a template for P2P communication. It is based on how epidemics
    spread. Peer-to-peer gossip is used to ensure that data are routed to all members
    of a network. There are two possible purposes. The first is dissemination of data,
    and the second is aggregation of data. In the context of blockchain, dissemination
    of data is more relevant.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个八卦协议是 P2P 通信的模板。它基于流行病传播的原理。点对点八卦用于确保数据被路由到网络的所有成员。有两种可能的目的。第一种是数据的传播，第二种是数据的聚合。在区块链的背景下，数据的传播更为相关。
- en: A gossip protocol is not unique, though any gossip protocol possesses some relevant
    features. A node interacts with some of its neighbouring nodes in a periodic manner,
    i.e. after some fixed interval of time, a node sends its data to its neighbours
    and receives their data. Each such interaction exchanges only a limited amount
    of information. Usually, some randomness is used by a node in selecting the nodes
    with which it will communicate. Since a node sends out the data to a number of
    nodes, there is an implicit redundancy in the system. The same data may reach
    a particular node using two different paths.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦协议并不是唯一的，尽管任何八卦协议都具有一些相关特征。一个节点以周期性的方式与其一些相邻节点交互，即在一定时间间隔之后，一个节点向其邻居发送其数据并接收它们的数据。每次这样的交互仅交换有限量的信息。通常，一个节点在选择与其通信的节点时会使用一些随机性。由于一个节点向多个节点发送数据，系统中存在隐含的冗余。相同的数据可能通过两条不同的路径到达特定的节点。
- en: The communication among nodes is not assumed to be reliable. Links may fail,
    nodes may fail. Also, as mentioned above, one or more nodes may come under the
    control of an adversary. It is a challenge to achieve some notion of reliable
    communication even under such circumstances.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的通信并不假定是可靠的。链接可能失败，节点可能失败。此外，如上所述，一个或多个节点可能受到对手的控制。在这种情况下，即使在这种情况下，实现某种可靠通信的概念也是一项挑战。
- en: 16.2.3 Byzantine Agreement
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.3 拜占庭协议
- en: In the above discussion, we have mentioned the possibility of malicious behaviour
    of participating nodes. Let us consider this in a little more detail. Suppose
    each of the nodes has some input (say a bit) and the goal is for all the nodes
    to decide on a common value. This common value must somehow depend on one or more
    of the inputs, as otherwise the problem becomes trivial; all the nodes agree on
    some constant value (say 1). To start with, assume for simplicity that any two
    nodes communicate directly. Typically, the nodes would be connected using a P2P
    network and a node would have to use the gossip protocol of the node to send a
    message to all the other nodes in the network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述讨论中，我们已经提到了参与节点可能存在恶意行为的可能性。让我们更详细地考虑一下这个问题。假设每个节点都有一些输入（比如一个位），目标是让所有节点决定一个共同的值。这个共同的值必须在某种程度上依赖于一个或多个输入，否则问题就变得太简单了；所有节点都会同意某个常量值（比如1）。首先，为简单起见，假设任意两个节点可以直接通信。通常情况下，节点会通过对节点的疏散协议向网络中的所有其他节点发送消息来连接。 '
- en: The nodes cannot be assumed to be reliable. A subset of nodes will perform the
    correct behaviour, while the behaviour of the rest of the nodes cannot be predicted.
    These other nodes are called Byzantine nodes. Byzantine behaviour of a node refers
    to arbitrary and/or unpredictable behaviour. It may stop relaying values, it may
    relay a random value, or it may even relay a malicious value (i.e. a value which
    is intended to confound the correct or non-Byzantine nodes). The correct nodes
    operate asynchronously and independent of each other. On the other hand, the Byzantine
    nodes can coordinate their activities as all of them may come under the control
    of some adversary. Whether a node is Byzantine or correct will not be known to
    the correct nodes. However, we may assume that a node cannot forge the sender
    address, i.e. a single node cannot impersonate all the nodes in the network.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不能假设节点是可靠的。一部分节点将执行正确的行为，而其余节点的行为无法预测。这些其他节点称为拜占庭节点。节点的拜占庭行为指的是任意和/或不可预测的行为。它可能停止中继值，它可能中继一个随机值，或者甚至可能中继一个恶意值（即旨在使正确或非拜占庭节点混淆的值）。正确的节点异步地且彼此独立地运行。另一方面，拜占庭节点可以协调他们的活动，因为他们所有人都可能受到某个对手的控制。正确的节点不会知道节点是拜占庭的还是正确的。然而，我们可以假设一个节点不能伪造发送者地址，即一个单独的节点不能冒充网络中的所有节点。
- en: The goal of a Byzantine agreement protocol is for the correct nodes to agree
    on a common value under the above circumstances. Relevant features of an agreement
    protocol are that there must be termination, i.e. the protocol must terminate
    after a finite time. On termination, all the correct nodes should have a common
    value. This common value must be valid. There are several notions of validity.
    Any-input validity refers to the common value being the input of at least one
    (not necessarily correct) node. Correct-input validity refers to the common value
    being the input of at least one correct node. All-same validity refers to the
    situation where if all the correct nodes start with the same value, then the common
    value must be this value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭协议的目标是使正确的节点在上述情况下达成共识。协议的相关特性包括必须终止，即协议必须在有限时间内终止。终止时，所有正确的节点应该有一个共同的值。这个共同的值必须有效。有几种有效性概念。任何输入有效性是指共同值是至少一个（不一定是正确的）节点的输入。正确输入的有效性是指共同值是至少一个正确节点的输入。全相同的有效性是指如果所有正确的节点从相同的值开始，那么共同值必须是这个值。
- en: A basic question is whether Byzantine agreement is at all possible. It has been
    proved that for a network of *n* nodes, Byzantine agreement is not possible if
    at least ![inline-image](../images/CH016_85.jpg) of the nodes are Byzantine. On
    the other hand, research in this area over several decades has led to a collection
    of positive results obtaining various Byzantine agreement protocols under different
    scenarios.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本问题是拜占庭协议是否可能。已经证明，对于一个包含 *n* 个节点的网络，如果至少有 ![inline-image](../images/CH016_85.jpg)
    的节点是拜占庭节点，则拜占庭协议是不可能的。另一方面，在这个领域数十年的研究已经取得了一系列积极的结果，在不同的情况下获得了各种拜占庭协议。
- en: 16.2.4 Consensus Protocol
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.4 共识协议
- en: A consensus protocol is a method of agreement among a number of nodes for a
    single data value in the presence of Byzantine nodes. The properties of termination
    and agreement discussed above are necessary properties of any consensus protocol.
    As for validity (sometimes also called integrity), typically the all-same notion
    of validity is used, i.e. if all the correct nodes proposed the same value, then
    at the end of the protocol any correct node must decide upon this value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议是在存在拜占庭节点的情况下，多个节点就单个数据值达成一致的方法。上述终止和一致性的属性是任何共识协议的必要属性。至于有效性（有时也称为完整性），通常使用全相同的有效性概念，即如果所有正确的节点提议了相同的值，那么在协议结束时，任何正确的节点都必须决定采用此值。
- en: '**Notes**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Introduction to cryptology can be found in textbooks on cryptography such as
    the one by Stinson and Paterson (2018). Digital signature schemes have a large
    literature and come in many variants. See Sarkar (2015) for an overview of various
    types of digital signature schemes. Presently, there are several standardised
    digital signature schemes. We mention the elliptic curve digital signature scheme
    (ECDSA) which has been standardised by the NIST of the US (see NIST, 2016). The
    ECDSA is used in the cryptocurrency Bitcoin.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学导论可以在密码学教材中找到，例如Stinson和Paterson（2018）的教材。数字签名方案有大量文献，并有许多变种。有关各种数字签名方案的概述，请参见Sarkar（2015）。目前，有几种标准化的数字签名方案。我们提到了由美国NIST标准化的椭圆曲线数字签名方案（ECDSA）（请参见NIST，2016）。ECDSA在加密货币比特币中使用。
- en: The Byzantine problem was introduced in Lamport, Shostak, and Pease (1982).
    Since then there has been a huge amount of work in the area. Our coverage has
    been rudimentary. Further discussions can be found in a number of textbooks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭问题最早出现在Lamport，Shostak和Pease（1982）中。此后，该领域进行了大量工作。我们的涉及尚属基础。更多讨论可以在许多教科书中找到。
- en: Chapter 17
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章
- en: Introduction to Blockchain
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链介绍
- en: This chapter provides an overview of the basic blockchain technology. In the
    next chapter we will see how a blockchain can be used to implement a cryptocurrency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了基本的区块链技术。在下一章中，我们将看到如何使用区块链来实现加密货币。
- en: 17.1 Transactions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1 交易
- en: Simply put, a transaction is a record of some kind of exchange between two or
    more parties. For example, one party supplies a service, while a second party
    provides payment for the service. To make a payment, a party must possess some
    amount of funds and then must provide a signed statement transferring the funds
    to another party.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，交易是两个或更多方之间某种交换的记录。例如，一方提供服务，而第二方为服务支付费用。要进行支付，一方必须拥有一定金额的资金，然后必须提供签名的声明，将资金转移给另一方。
- en: More generally, one can consider contracts between parties. A contract can be
    much more flexible than a transaction. It may include exit and penalty clauses
    and also may refer to unknown situations in the future. So, the language for writing
    a contract must be expressive enough to cover a whole multitude of tasks. We will
    come back to this issue when we discuss the interesting notion of smart contracts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，人们可以考虑各方之间的合同。合同比交易灵活得多。它可以包括退出和惩罚条款，也可能涉及未来的未知情况。因此，撰写合同的语言必须足够表达，以涵盖各种任务。当我们讨论有趣的智能合同概念时，我们将再次回到这个问题上。
- en: Whether we consider a transaction or a contract, such an instrument will be
    considered valid only if it is signed by the parties who are involved. For example,
    if somebody wishes to make a payment, the person must sign the statement which
    transfers money to another person. In the physical world, this is achieved by
    a signed cheque. So, the signature of the person making the payment is the key
    issue. Moving to the digital world, a transaction needs to be signed. For doing
    this, a digital signature scheme is used. Suppose Alice wishes to make a payment
    of $100 to Bob. She uses her signing key ![inline-image](../images/CH017_1.jpg)
    to digitally sign the statement ‘I transfer $100 to Bob’. This statement is considered
    to be a message *M*, and the signing algorithm is invoked on *M* and ![inline-image](../images/CH017_2.jpg)
    to produce the signature *s*. Using the verification algorithm and Alice's verification
    key ![inline-image](../images/CH017_3.jpg), anybody can verify that *s* is indeed
    Alice's signature on the message *M*. For the moment, let us consider transactions
    to be signed statement of this type. Later, we will consider somewhat more details.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们考虑的是一笔交易还是一份合同，只有涉及方签署的这种工具才被认为是有效的。例如，如果有人希望进行支付，该人必须签署将款项转移到另一个人的声明。在物理世界中，这是通过签署支票实现的。因此，付款人的签名是关键问题。转移到数字世界后，交易需要签名。为此，使用数字签名方案。假设Alice希望向Bob支付100美元。她使用自己的签名密钥
    ![inline-image](../images/CH017_1.jpg) 对声明“我将100美元转移到Bob”的数字签名。该声明被视为消息*M*，并且签名算法在*M*和
    ![inline-image](../images/CH017_2.jpg) 上被调用以生成签名*s*。使用验证算法和Alice的验证密钥 ![inline-image](../images/CH017_3.jpg)，任何人都可以验证*s*确实是Alice对消息*M*的签名。目前，让我们将交易视为这种类型的签署声明。稍后，我们将考虑更多细节。
- en: 17.2 Blocks of Transactions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2 交易区块
- en: An active system will generate millions of transactions. Further, future transactions
    may be based on the current transactions. For example, a payment system will consist
    of transactions where parties make payments to other parties. One party can receive
    money from another party and then based on the money received make a payment to
    a third party. At a top level, one may view the entire system to be the set of
    transactions that has taken place so far within the system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个活跃的系统将产生数百万笔交易。此外，未来的交易可能基于当前的交易。例如，支付系统将包括各方向其他方支付款项的交易。一方可以从另一方收到款项，然后根据收到的款项向第三方支付款项。在高层次上，我们可以将整个系统视为迄今为止在系统内发生的交易集合。
- en: For the purposes of keeping record, the transactions will need to be grouped
    together and stored. A block is essentially a group of transactions. There is
    no particular order in which the transactions in a block are stored.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录目的，交易需要被分组并存储。一个区块本质上是一组交易。区块中的交易存储顺序并无特定要求。
- en: Transactions can have varying sizes depending upon their complexities. In the
    context of payment system, a transaction may record a simple payment from one
    account of a party to another party. Such a transaction will have a small size.
    On the other hand, a transaction may also record payment from multiple accounts
    of a party to several parties. This will have a larger size. A block usually has
    a fixed size. So, depending upon the sizes of the transactions, it may store a
    variable number of transactions. This, however, is not important for a conceptual
    understanding. It is enough to view a block as storing a number of transactions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的大小可能会有所不同，取决于它们的复杂性。在支付系统的上下文中，一个交易可能记录一个简单的支付，从一个方的一个帐户到另一个方。这样的交易将有一个小的大小。另一方面，一个交易也可能记录了从一个方的多个帐户到多个方的支付。这将有一个更大的大小。一个区块通常有一个固定的大小。所以，取决于交易的大小，它可能存储不同数量的交易。然而，这对于概念理解并不重要。将一个区块视为存储一些交易就足够了。
- en: 17.3 Public Ledger as a Blockchain
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3 公开分类账作为区块链
- en: Transactions of a system are entered and recorded in a ledger. In a physical
    system, a ledger would be a physical book where a bunch of transactions would
    be entered on each page of the book. In a digital system, blocks of transactions
    are chained together in a structure called a blockchain. A cryptographic hash
    function *H* is used to chain together the blocks of transactions. The entire
    chain is made public. So, a blockchain implements a public ledger.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的交易被输入和记录在一个分类账中。在一个物理系统中，分类账将是一本物理书，在书的每一页上都会输入一堆交易。在数字系统中，交易块被链接在一起形成一个称为区块链的结构。一个加密哈希函数
    *H* 被用来将交易块链接在一起。整个链是公开的。所以，区块链实现了一个公开分类账。
- en: We have mentioned that a block contains a set of transactions. While this is
    indeed a rough conceptual view of a block, the actual information present in a
    block is more than just the transactions in it. Below we provide a more formal
    description.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过一个区块包含一组交易。虽然这确实是一个对区块的粗略概念视图，但区块中实际包含的信息不仅仅是其中的交易。下面我们提供一个更正式的描述。
- en: Let *B* 0, *B* 1, …, *B* *r* be a sequence of blocks. The first block *B* 0
    is special since it has no previous blocks. It is sometimes called the *genesis
    block*. Formally, the block *B* [*i*] , *i* ≥ 1, can be considered to be a triplet
    ![inline-image](../images/CH017_4.jpg). (A block also stores some additional information
    called metadata which we ignore for the moment.) The transactions in the block
    constitute the component *R* [*i*] of the block *B* [*i*] and *h* [*i*] is the
    linking information. For the moment, let us ignore the role of ![inline-image](../images/CH017_5.jpg).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *B* 0, *B* 1, …, *B* *r* 成为一个区块序列。第一个区块 *B* 0 是特殊的，因为它没有前一个区块。有时候它被称为*创世区块*。正式来说，区块
    *B* [*i*]，*i* ≥ 1，可以被看作是一个三元组 ![inline-image](../images/CH017_4.jpg)。（一个区块还存储一些被称为元数据的附加信息，我们暂时忽略它。）区块中的交易构成了区块
    *B* [*i*] 的组件 *R* [*i*]，*h* [*i*] 是链接信息。暂时来说，让我们忽略 ![inline-image](../images/CH017_5.jpg)的作用。
- en: 'The hash function *H* is applied to the block *B* [*i*]−1 to obtain the component
    *h* [*i*] of the block *B* [*i*] , i.e. *h* [*i*] = *H*(*B* [*i*]−1). So, one
    may consider the component *h* [*i*] in the present block to ‘point’ to the previous
    block *B* [*i*]−1\. In other words, the hash function *H* is used to create the
    quantities *h* 1, *h* 2, … , *h* *r* which are the links in the blockchain. Note
    that the genesis block *B* 0 does not have the component *h* 0, since there is
    no earlier block to which it can point. Pictorially, this may be depicted as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数*H*被应用于块*B*[*i*]−1，以获得块*B*[*i*]的组成部分*h*[*i*]，即*h*[*i*] = *H*(*B*[*i*]−1)。因此，一个可以考虑在当前块中的组成部分*h*[*i*]指向前一块*B*[*i*]−1。换句话说，哈希函数*H*用于创建量*h*1、*h*2、……、*h**r*，它们是区块链中的链接。请注意，创世区块*B*0没有组成部分*h*0，因为它没有早期的块可以指向。在图形上，这可能被描述如下：
- en: '![display-image](../images/CH017_6.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_6.jpg)'
- en: The arrows in the blockchain point in the backward direction indicating that
    the digest of block *B* [*i*] is part of block *B* [*i*]+1\. The chain, however,
    is computed only in the forward direction. Once the chain up to block *B* *r*
    is prepared, a group of transactions is taken as *R* *r*+1, the digest *h* *r*+1
    = *H*(*B* *r* ) is computed (for a suitable value of ![inline-image](../images/CH017_7.jpg))
    and the block ![inline-image](../images/CH017_8.jpg) is appended to the head of
    the chain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的箭头指向后向方向，表明块*B*[*i*]的摘要是块*B*[*i*]+1的一部分。然而，链只在正向方向计算。一旦链达到块*B**r*，一组交易被视为*R**r*+1，计算摘要*h**r*+1
    = *H*(*B**r* )（对于适当的值![inline-image](../images/CH017_7.jpg)），并且块![inline-image](../images/CH017_8.jpg)被附加到链的头部。
- en: A basic requirement on any ledger is immutability. Essentially this means that
    once a transaction is entered into a ledger, it should not be possible to undo
    or alter it in any manner. This property should also hold in the case of a public
    ledger as described above. Ensuring immutability of the public ledger amounts
    to ensuring that once a block (and hence the transactions in the block) is inserted
    into the blockchain it cannot be changed thereafter. Let us consider this in more
    detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何账本的基本要求是不可变性。基本上意味着一旦交易记录进入账本，就不应该有任何方式可以撤销或更改它。在上述公共账本的情况下，这种属性也应该成立。确保公共账本的不可变性相当于确保一旦一个区块（因此是区块中的交易）被插入到区块链中后，就不能再进行更改。让我们更详细地考虑一下这一点。
- en: 'Suppose there are two blocks ![inline-image](../images/CH017_9.jpg) and ![inline-image](../images/CH017_10.jpg)
    with ![inline-image](../images/CH017_11.jpg) such that ![inline-image](../images/CH017_12.jpg).
    The component *R* [*i*] of block *B* [*i*] consists of all the transactions that
    have been included in the block. The difference between *R* [*i*] and ![inline-image](../images/CH017_13.jpg)
    could be due to alteration of some transaction *T* in ![inline-image](../images/CH017_14.jpg)
    to obtain transaction ![inline-image](../images/CH017_15.jpg) which is included
    in ![inline-image](../images/CH017_16.jpg). Since the digest of both *B* [*i*]
    and ![inline-image](../images/CH017_17.jpg) under the hash function *H* are equal
    and both the blocks contain the same value of ![inline-image](../images/CH017_18.jpg),
    any of the following two blockchains are valid:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个块![inline-image](../images/CH017_9.jpg)和![inline-image](../images/CH017_10.jpg)，满足![inline-image](../images/CH017_11.jpg)，使得![inline-image](../images/CH017_12.jpg)。块*B*
    [*i*]的组件*R* [*i*]包含了已经包含在块中的所有交易。*R* [*i*]和![inline-image](../images/CH017_13.jpg)之间的差异可能是由于修改了某些交易*T*来获得包含在![inline-image](../images/CH017_16.jpg)中的交易![inline-image](../images/CH017_15.jpg)。由于哈希函数*H*下的*B*
    [*i*]和![inline-image](../images/CH017_17.jpg)的摘要相等，并且两个块都包含相同的![inline-image](../images/CH017_18.jpg)的值，以下两个区块链都是有效的：
- en: '![display-image](../images/CH017_19.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_19.jpg)'
- en: '![display-image](../images/CH017_20.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_20.jpg)'
- en: An adversary may conduct transaction *T* which enters the first blockchain and
    then replaces the first blockchain by the second one which contains the transaction
    ![inline-image](../images/CH017_21.jpg) instead of *T*. This clearly violates
    the immutability of the blockchain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可能进行交易*T*，该交易进入第一个区块链，然后用包含交易![inline-image](../images/CH017_21.jpg)而不是*T*的第二个区块链替换第一个区块链。这显然违反了区块链的不可变性。
- en: The above scenario arose due to the occurrence of ![inline-image](../images/CH017_22.jpg)
    such that ![inline-image](../images/CH017_23.jpg). The pair ![inline-image](../images/CH017_24.jpg)
    is a collision for the hash function *H*. One of the requirements on *H* is that
    it should be collision-resistant, i.e. it should be computationally difficult
    to find a collision for *H*. For a collision-resistant *H*, it will not be possible
    (in reasonable time) to find *B* [*i*] and ![inline-image](../images/CH017_25.jpg)
    such that ![inline-image](../images/CH017_26.jpg). So, the described strategy
    of modifying the public ledger will not work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情景是由于![inline-image](../images/CH017_22.jpg)的发生而产生，使得![inline-image](../images/CH017_23.jpg)。对于哈希函数*H*，成对![inline-image](../images/CH017_24.jpg)是其碰撞。*H*的要求之一是它应该是碰撞性抗的，即对于*H*找到碰撞应该是计算上困难的。对于碰撞性抗的*H*，在合理的时间内不可能找到*B*
    [*i*]和![inline-image](../images/CH017_25.jpg)这样的![inline-image](../images/CH017_26.jpg)。因此，修改公共账本的描述策略将无法奏效。
- en: We have mentioned that the blockchain is to be computed in the forward direction.
    Let us consider the possibility of computing it in the backward direction. Suppose
    that the blockchain has *r* blocks and ![inline-image](../images/CH017_27.jpg)
    is the head of the blockchain. Computing the chain in the backward direction requires
    obtaining a block ![inline-image](../images/CH017_28.jpg) such that ![inline-image](../images/CH017_29.jpg).
    First assume that this is indeed possible. This would affect the immutability
    of the blockchain, since then *B* *r*−1 can be overwritten by ![inline-image](../images/CH017_30.jpg)
    to obtain a valid blockchain. The backward computation is possible only if given
    *h* [*r*] , it is possible to find ![inline-image](../images/CH017_31.jpg) such
    that ![inline-image](../images/CH017_32.jpg). In effect, this means that it is
    possible to compute a pre-image of *h* *r* under *H*. Recall that one of the properties
    required of the hash function *H* is that it is one-way which ensures that it
    is computationally difficult to find pre-images under *H*. So, the one-way property
    of the hash function *H* ensures that the blockchain cannot be computed in the
    backward direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过区块链是向前计算的。让我们考虑向后计算的可能性。假设区块链有*r*个块，![inline-image](../images/CH017_27.jpg)是区块链的头。在向后方向计算链条需要获取一个块![inline-image](../images/CH017_28.jpg)，使得![inline-image](../images/CH017_29.jpg)。首先假设这确实是可能的。这将影响区块链的不可变性，因为然后*B*
    *r*−1可以被![inline-image](../images/CH017_30.jpg)覆盖以获得有效的区块链。只有在给定*h* [*r*]的情况下，向后计算才可能找到![inline-image](../images/CH017_31.jpg)，使得![inline-image](../images/CH017_32.jpg)。实际上，这意味着可以在*H*下计算*h*
    *r*的前像。回想一下，哈希函数*H*所需的一个属性是它是单向的，这确保了在*H*下找到前像是计算难度很大的。因此，哈希函数*H*的单向属性确保了不能向后计算区块链。
- en: 17.4 Distributed Public Ledger
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4 分布式公共分类帐
- en: We have described how a public ledger can be set up using a blockchain. There
    could, conceivably, be implementations of a public ledger without using a blockchain.
    Presently, however, the most important method for realising a public ledger is
    to base it on a blockchain. So, our discussion of public ledger will be entirely
    based on blockchain technology.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了如何使用区块链建立一个公共分类帐。理论上，可以使用不使用区块链的公共分类帐的实现。然而，目前实现公共分类帐的最重要方法是基于区块链。因此，我们对公共分类帐的讨论将完全基于区块链技术。
- en: In the previous sections of the chapter, we have provided a basic overview of
    a blockchain. The relevance of cryptographic properties of the hash function to
    the immutability of a blockchain has been explained. Next comes the question of
    how a blockchain is maintained. The short answer to this is that a blockchain
    is maintained in a distributed fashion. In this section, we elaborate further
    on this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们提供了区块链的基本概述。已经解释了哈希函数的加密属性与区块链的不可变性的相关性。接下来的问题是如何维护区块链。对此的简短答案是，区块链是以分布式方式维护的。在本节中，我们进一步阐述了这一点。
- en: The setting that we consider consists of many parties who are geographically
    distributed across the planet. There would be differences in the complexities
    of the parties. For the present, we ignore such differences and consider each
    party to be a node of the system. Again, for simplicity, we assume a node to be
    a computer. These nodes are connected to each other using the internet (or, maybe
    a part of it). So, one particular node can communicate directly to only a small
    number of nodes in its neighbourhood. This is the setting of P2P network, as has
    been described in Section 16.2.1.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的环境包括许多地理分布在全球各地的参与方。各方的复杂性可能会有所不同。目前，我们忽略这些差异，将每个参与方视为系统的一个节点。同样，为了简单起见，我们假设一个节点就是一台计算机。这些节点通过互联网（或者可能是其一部分）相互连接。因此，一个特定的节点只能直接与其邻近的少数节点进行通信。这就是P2P网络的设置，如第16.2.1节所述。
- en: The nodes themselves generate transactions which are to be included in the public
    ledger. The question then arises as to who maintains the public ledger. The answer
    is that all the nodes maintain the public ledger, i.e. each node maintains a copy
    of the public ledger. Since we are considering that the public ledger is implemented
    as a blockchain, it follows that each node maintains a copy of the blockchain.
    Since the blockchain is distributed across the whole network, the resulting public
    ledger is often called distributed public ledger. At this point, a crucial question
    arises. How is it ensured that the copies of the blockchain maintained by the
    different nodes are consistent? Below we address this issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 节点本身会生成需要包含在公共分类账中的交易。那么，谁来维护公共分类账呢？答案是所有节点都维护公共分类账，即每个节点都维护公共分类账的一份拷贝。由于我们考虑的公共分类账是以区块链实现的，因此每个节点都维护区块链的一份拷贝。由于区块链分布在整个网络中，因此产生的公共分类账通常称为分布式公共分类账。在这一点上，一个关键的问题出现了。如何确保由不同节点维护的区块链拷贝是一致的呢？下面我们来解决这个问题。
- en: Let us consider a particular node *v*. Transactions occur at the node *v*, i.e.
    the entity responsible for the node *v* may initiate transactions. These transactions
    are to be entered into the blockchain. So, node *v* uses the gossip protocol of
    the P2P network to send out the transactions to a subset of its neighbouring nodes.
    These neighbouring nodes further propagate the transactions until the transactions
    reach the entire network. Usually the gossip network is quite efficient and a
    transaction reaches the entire network within a few seconds (or, even less time).
    Similarly, node *v* receives transactions which have occurred at other nodes in
    the network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个特定的节点*v*。交易发生在节点*v*上，即负责节点*v*的实体可能会启动交易。这些交易需要记录在区块链中。因此，节点*v*使用P2P网络的八卦协议将交易发送到其邻近节点的子集。这些邻近节点进一步传播交易，直到交易达到整个网络。通常，八卦网络非常高效，交易在几秒钟内（甚至更短的时间内）就能传播到整个网络。同样，节点*v*接收到网络中其他节点发生的交易。
- en: We have mentioned that each node in the network maintains a copy of the blockchain.
    The blockchain consists of blocks where each block is a group of transactions.
    Each node also receives transactions which have occurred in the network. Along
    with a copy of the blockchain, each node also maintains a list of transactions
    which have so far not entered the blockchain. This is the set of ‘un-blocked’
    transactions. Note that at a particular point of time, the list of un-blocked
    transactions maintained by the different nodes need not be the same; in fact,
    they will mostly be different. This is because a transaction generated at a particular
    node will require some time to travel throughout the network. Until it has reached
    all the nodes in the system, a subset of nodes will be recording it as ‘un-blocked’
    while the other nodes will not even be knowing about it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到网络中的每个节点都维护着区块链的一个副本。区块链由一组交易组成，每个区块都是一组交易。每个节点还会接收网络中发生的交易。除了区块链的副本外，每个节点还维护着一份迄今尚未进入区块链的交易列表。这就是所谓的‘未阻塞’交易集合。需要注意的是，在特定时间点上，不同节点维护的未阻塞交易列表可能并不相同；事实上，它们通常是不同的。这是因为在特定节点生成的交易需要一定时间才能传播到整个网络。在它到达所有节点之前，一部分节点将把它记录为‘未阻塞’，而其他节点甚至可能不知道它的存在。
- en: Again, let us get back to node *v*. This node maintains a copy of the blockchain
    and a list of un-blocked transactions. Let us denote node *v*'s copy of the blockchain
    by ![inline-image](../images/CH017_33.jpg) and its list of un-blocked transactions
    as ![inline-image](../images/CH017_34.jpg). Apart from generating and propagating
    transactions, each node also tries to create a block and propagate it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们回到节点*v*。这个节点维护着区块链的一个副本和一个未被阻塞的交易列表。让我们用![inline-image](../images/CH017_33.jpg)来表示节点*v*的区块链副本，用![inline-image](../images/CH017_34.jpg)表示其未被阻塞的交易列表。除了生成和传播交易外，每个节点还尝试创建并传播一个区块。
- en: Suppose the header of ![inline-image](../images/CH017_35.jpg) is a block ![inline-image](../images/CH017_36.jpg),
    where *h* *r* = *H*(*B* *r*−1) is the digest under the hash function *H* of the
    previous block *B* *r*−1 in ![inline-image](../images/CH017_37.jpg), ![inline-image](../images/CH017_38.jpg)
    is the set of transactions in the block *B* and ![inline-image](../images/CH017_39.jpg)
    is a quantity which plays a special role. Node *v* takes a group of transactions
    from ![inline-image](../images/CH017_40.jpg) and checks the validity of each of
    these transactions. The checking of validity includes checking proper format and
    the verifications of the digital signatures of the various parties in a transaction.
    If a check fails, then *v* rejects the corresponding transaction and removes it
    from ![inline-image](../images/CH017_41.jpg). Once all the checks succeed, *v*
    takes this group of transactions to be ![inline-image](../images/CH017_42.jpg).
    Node *v* then computes ![inline-image](../images/CH017_43.jpg). Next, it attempts
    to obtain a suitable value for ![inline-image](../images/CH017_44.jpg) so as to
    be able to form a block ![inline-image](../images/CH017_45.jpg). We will later
    explain how ![inline-image](../images/CH017_46.jpg) is obtained. Once node *v*
    has been able to form block ![inline-image](../images/CH017_47.jpg), it removes
    the transactions in ![inline-image](../images/CH017_48.jpg) from ![inline-image](../images/CH017_49.jpg),
    inserts ![inline-image](../images/CH017_50.jpg) into ![inline-image](../images/CH017_51.jpg)
    as the new header and propagates this block to the network using the gossip protocol.
    So, apart from transactions, nodes in the network also propagate blocks that they
    have created.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设![inline-image](../images/CH017_35.jpg)的头部是一个区块![inline-image](../images/CH017_36.jpg)，其中
    *h* *r* = *H*(*B* *r*−1) 是前一个区块 *B* *r*−1 在![inline-image](../images/CH017_37.jpg)下哈希函数
    *H* 的摘要，![inline-image](../images/CH017_38.jpg)是区块 *B* 中的交易集，而![inline-image](../images/CH017_39.jpg)是一个发挥特殊作用的量。节点
    *v* 从![inline-image](../images/CH017_40.jpg)中取一组交易并检查每笔交易的有效性。有效性检查包括检查正确的格式和交易中各方数字签名的验证。如果检查失败，那么
    *v* 将拒绝相应的交易并将其从![inline-image](../images/CH017_41.jpg)中移除。一旦所有检查都成功，*v* 将这组交易视为![inline-image](../images/CH017_42.jpg)。然后，节点
    *v* 计算![inline-image](../images/CH017_43.jpg)。接下来，它尝试获得适当的值以便能够形成一个区块![inline-image](../images/CH017_45.jpg)。我们将在后面解释![inline-image](../images/CH017_46.jpg)是如何获得的。一旦节点
    *v* 能够形成区块![inline-image](../images/CH017_47.jpg)，它就从![inline-image](../images/CH017_49.jpg)中移除![inline-image](../images/CH017_48.jpg)中的交易，将![inline-image](../images/CH017_50.jpg)插入![inline-image](../images/CH017_51.jpg)作为新的头部，并使用八卦协议将该区块传播到网络中。因此，除了交易外，网络中的节点还会传播它们创建的区块。
- en: Let us now consider what happens when node *v* receives a block ![inline-image](../images/CH017_52.jpg).
    It checks whether ![inline-image](../images/CH017_53.jpg) and if this is true,
    it then inserts *B* as the new header in ![inline-image](../images/CH017_54.jpg)
    and removes the transactions in *R* from ![inline-image](../images/CH017_55.jpg).
    This results in the extension of the copy of the blockchain ![inline-image](../images/CH017_56.jpg)
    available with node *v* by one block. The gossip protocol ensures that the block
    *B* reaches all the nodes. Assuming that all nodes have the same copy of the blockchain,
    each node extends its copy of the blockchain by the block *B* and again all nodes
    in the network have the same copy of the blockchain. Recall that the start of
    the blockchain is by the genesis block which all nodes certainly have. So, ignoring
    conflicts, each node maintains the same copy of the blockchain.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点*v*接收到一个块![inline-image](../images/CH017_52.jpg)时，让我们考虑接下来会发生什么。 它会检查是否![inline-image](../images/CH017_53.jpg)，如果是，则将*B*插入![inline-image](../images/CH017_54.jpg)中并从![inline-image](../images/CH017_55.jpg)中删除*R*中的交易。
    这会导致节点*v*可用的区块链副本![inline-image](../images/CH017_56.jpg)扩展了一个块。 八卦协议确保块*B*到达所有节点。
    假设所有节点都具有相同的区块链副本，每个节点都将其区块链副本扩展了一个块*B*，然后网络中的所有节点再次具有相同的区块链副本。 请记住，区块链的起始点是所有节点肯定拥有的创世块。
    因此，忽略冲突，每个节点都维护相同的区块链副本。
- en: Conflicts, however, do arise. The nodes are creating blocks concurrently and
    independently of each other. Whenever a block is created, it is transmitted to
    the gossip network. Further, the list of un-blocked transactions maintained by
    the nodes is different. So, blocks created by different nodes will not necessarily
    have the same set of transactions. It is quite possible that the node *v* almost
    simultaneously receives two different blocks ![inline-image](../images/CH017_57.jpg)
    and ![inline-image](../images/CH017_58.jpg) such that ![inline-image](../images/CH017_59.jpg).
    In other words, both the blocks *B* and ![inline-image](../images/CH017_60.jpg)
    are compatible with the copy of the blockchain ![inline-image](../images/CH017_61.jpg)
    maintained by *v*. Note that one of the blocks *B* and ![inline-image](../images/CH017_62.jpg)
    could have been created by *v* itself. At this point, there needs to be some kind
    of a conflict resolution mechanism to determine which of the two blocks *B* and
    ![inline-image](../images/CH017_63.jpg) is to be inserted as the new header of
    ![inline-image](../images/CH017_64.jpg). The overall protocol for the blockchain
    will specify this conflict resolution mechanism. Later we will consider the special
    case of the Bitcoin protocol. For the moment, it is sufficient to note that one
    of the blocks *B* and ![inline-image](../images/CH017_65.jpg) is entered as the
    new header by *v*, while the other block is rejected. Suppose block *B* is accepted
    and ![inline-image](../images/CH017_66.jpg) is rejected. So, in some sense the
    blockchain protocol has to define when block *B* will be preferred over block
    ![inline-image](../images/CH017_67.jpg). Note that this preference relation is
    specified by the blockchain protocol and is followed by all the nodes in the network.
    So, all the nodes will prefer *B* over ![inline-image](../images/CH017_68.jpg)
    and extend their copies of the blockchain using *B* rather than ![inline-image](../images/CH017_69.jpg).
    This is a kind of consensus among the nodes and the preference relation of the
    blockchain protocol essentially specifies the consensus algorithm.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，冲突是不可避免的。节点并行且独立地创建区块。每当创建一个区块，它就会被传输到八卦网络中。此外，节点维护的未被阻塞的交易列表是不同的。因此，由不同节点创建的区块不一定具有相同的交易集。很有可能节点*v*几乎同时接收到两个不同的区块![inline-image](../images/CH017_57.jpg)和![inline-image](../images/CH017_58.jpg)，使得![inline-image](../images/CH017_59.jpg)。换句话说，区块*B*和![inline-image](../images/CH017_60.jpg)都与*v*维护的区块链的副本![inline-image](../images/CH017_61.jpg)兼容。请注意，区块*B*和![inline-image](../images/CH017_62.jpg)中的一个可能是由*v*自己创建的。在这一点上，需要一种冲突解决机制来确定两个区块*B*和![inline-image](../images/CH017_63.jpg)中的哪一个将被插入为![inline-image](../images/CH017_64.jpg)的新标题。区块链的整体协议将指定这种冲突解决机制。稍后我们将考虑比特币协议的特殊情况。目前，只需注意区块*B*和![inline-image](../images/CH017_65.jpg)中的一个被*v*输入为新标题，而另一个区块被拒绝。假设区块*B*被接受而![inline-image](../images/CH017_66.jpg)被拒绝。因此，在某种意义上，区块链协议必须定义区块*B*何时优先于区块![inline-image](../images/CH017_67.jpg)。请注意，此偏好关系由区块链协议指定，并由网络中的所有节点遵循。因此，所有节点都将优先选择*B*而不是![inline-image](../images/CH017_68.jpg)并使用*B*扩展其区块链的副本而不是![inline-image](../images/CH017_69.jpg)。这是节点之间的一种共识，而区块链协议的偏好关系基本上指定了共识算法。
- en: The scenario is actually more complex than the above. Competition to enter the
    blockchain is not only restricted to the two blocks which are received almost
    simultaneously by a node. Consider again node *v* and its copy of the blockchain
    ![inline-image](../images/CH017_70.jpg). Suppose node *v* receives a block ![inline-image](../images/CH017_71.jpg)
    and it finds that *H*(*B* [*i*]−1) = *h*. This means that the blockchain (*B*
    0,…,*B* [*i*]−1, *B*) is valid. Node *v* now has the option of either rejecting
    block *B* or of modifying its copy of the blockchain to (*B* 0,…,*B* [*i*]−1,
    *B*) and rejecting blocks ![inline-image](../images/CH017_72.jpg). The actual
    decision on which option node *v* should choose is also determined by the conflict
    resolution mechanism of the blockchain protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况比上述更复杂。进入区块链的竞争不仅仅局限于几乎同时被一个节点接收的两个区块。再次考虑节点*v*及其区块链的副本![inline-image](../images/CH017_70.jpg)。假设节点*v*接收到一个区块![inline-image](../images/CH017_71.jpg)，并且发现*H*(*B*
    [*i*]−1) = *h*。这意味着区块链(*B* 0,…,*B* [*i*]−1, *B*)是有效的。节点*v*现在可以选择拒绝区块*B*，或者修改其区块链副本为(*B*
    0,…,*B* [*i*]−1, *B*)并拒绝区块![inline-image](../images/CH017_72.jpg)。节点*v*应该选择哪个选项的实际决定也由区块链协议的冲突解决机制确定。
- en: Suppose that following the blockchain protocol, node *v* chooses the blockchain
    (*B* 0,…,*B* [*i*]−1, *B*) and rejects the blocks *B* [*i*] ,…,*B* *r*−1, *B*
    *r* . Since the consensus protocol is followed by all the nodes in the network,
    any other node whose local copy of the blockchain is ![inline-image](../images/CH017_73.jpg)
    and receives block *B* also opts for the blockchain (*B* 0,…,*B* [*i*]−1, *B*)
    and rejects the blocks *B* [*i*] ,…,*B* *r*−1, *B* *r* . These later blocks are
    called stale blocks (and sometimes also called orphan blocks, though technically
    orphan blocks are different objects). The cost of creating these stale blocks
    has been wasted.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设按照区块链协议，节点*v*选择了区块链(*B* 0,…,*B* [*i*]−1, *B*)并拒绝了区块*B* [*i*]，…,*B* *r*−1,
    *B* *r*。由于网络中的所有节点都遵循共识协议，任何其他本地区块链副本为![inline-image](../images/CH017_73.jpg)且接收到区块*B*的节点也会选择区块链(*B*
    0,…,*B* [*i*]−1, *B*)并拒绝区块*B* [*i*]，…,*B* *r*−1, *B* *r*。这些后来的区块被称为陈旧区块（有时也称为孤立区块，尽管在技术上孤立区块是不同的对象）。创建这些陈旧区块的成本被浪费了。
- en: Another possibility may arise. Suppose that the local copies of the blockchain
    of all the nodes is ![inline-image](../images/CH017_74.jpg) and all of them receive
    block *B*. Further suppose that the rules of the blockchain protocol dictates
    that the blockchain must be modified to ![inline-image](../images/CH017_75.jpg).
    At this point, some of the nodes in the network decide to follow the protocol
    and update the local copies of the their blockchain while the rest of the nodes
    discard block *B* and continue with the blockchain ![inline-image](../images/CH017_76.jpg).
    This gives rise to two different blockchains which are the same up to block *B*
    [*i*]−1 and then forks into two distinct chains. The two disjoint subsets of nodes
    which work on the two different blockchains will no longer accept blocks and transactions
    from each other. Effectively, this results in a partition of the network into
    two different parts. This process is called forking of the blockchain and also
    the network. Forking can arise for a number of reasons. One important reason for
    a fork to occur is a change in the blockchain protocol which is accepted by a
    subset of nodes, but, not by the other nodes. In the context of cryptocurrency,
    forking may lead to one cryptocurrency being split into two cryptocurrencies.
    Later we provide further explanation of how this may happen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能会出现另一种情况。假设所有节点的区块链的本地副本为 ![inline-image](../images/CH017_74.jpg)，它们都收到了区块
    *B*。进一步假设区块链协议规定区块链必须修改为 ![inline-image](../images/CH017_75.jpg)。此时，网络中的一些节点决定遵循协议并更新他们的区块链本地副本，而其余节点则丢弃区块
    *B* 并继续使用区块链 ![inline-image](../images/CH017_76.jpg)。这样就产生了两条不同的区块链，它们在区块 *B*
    [*i*]−1之前相同，然后分叉成两条不同的链。在这两个不同的区块链上工作的两个不相交的节点子集将不再接受彼此的区块和交易。实际上，这导致网络分为两个不同的部分。这个过程称为区块链和网络的分叉。分叉可能因多种原因而发生。导致分叉发生的一个重要原因是区块链协议的变化，该变化被一部分节点接受，而其他节点不接受。在加密货币的背景下，分叉可能导致一种加密货币分裂为两种加密货币。稍后我们将进一步解释这种情况可能发生的方式。
- en: 17.5 Permissionless versus Permissioned Blockchain
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5 允许性与许可性区块链
- en: Distributed public ledger based on blockchain has been popularised by Bitcoin
    and the follow-up cryptocurrencies. Notable among the follow-ups is Ethereum which
    apart from providing a cryptocurrency also provides a platform for implementing
    smart contracts. All such blockchains can be considered to be public blockchains.
    In such blockchains, there is no restriction on who can become a node in the network.
    Anybody can download the software for the blockchain protocol onto a computer
    and create a node of the blockchain network. Such a system is considered to be
    permissionless since no permission is required from any authority to join the
    network. It is also called a decentralised system due to the fact that all nodes
    in the network have equal privileges, i.e. they are peers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于区块链的分布式公共账本由比特币及其后续加密货币推广开来。其中值得注意的是以太坊，除了提供加密货币外，还提供了一个实现智能合约的平台。所有这些区块链都可以被视为公共区块链。在这种区块链中，没有限制谁可以成为网络中的节点。任何人都可以在计算机上下载区块链协议的软件，并创建一个区块链网络的节点。这样的系统被认为是无需许可的，因为不需要从任何权威处获得加入网络的许可。由于网络中的所有节点都具有相同的特权，即它们是对等的，它也被称为分散式系统。
- en: Subsequent to the popularisation of cryptocurrencies there has been a great
    deal of interest in the underlying blockchain technology to implement distributed
    public ledgers for various tasks. An organisation, for example, may employ a blockchain
    to maintain a public ledger of interal records. This would be very convenient,
    since the public ledger would be accessible to all internal members of the organisation.
    Such a public ledger is not really public, since the organisation might not wish
    to reveal its internal documents to entities outside the organisation. Further,
    it may also wish to provide access to the ledger only to a set of privileged members
    of the organisation. So, permission from some central authority is required to
    join the blockchain. Such a system is called permissioned blockchain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密货币流行之后，人们对实现各种任务的分布式公共账本的底层区块链技术产生了极大兴趣。例如，一个组织可以使用区块链来维护内部记录的公共账本。这将非常方便，因为公共账本将对组织内所有成员可访问。这样的公共账本实际上并不是公开的，因为组织可能不希望将其内部文件透露给组织外的实体。此外，它可能还希望仅将账本访问权限提供给一组特权组织成员。因此，需要从某个中央机构获得许可才能加入区块链。这样的系统称为许可区块链。
- en: Chapter 18
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章
- en: 'Cryptocurrency: Basics'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币：基础知识
- en: In this chapter, we will consider cryptocurrencies. The cryptocurrency Bitcoin
    was proposed in 2009 and till date remains the most successful of all cryptocurrencies.
    Subsequent to Bitcoin, over 1,500 cryptocurrencies have been proposed. All of
    these are based on the blockchain technology, and most of them are conceptually
    very similar to Bitcoin differing mostly in the choice of tools to implement the
    various components. Our discussion of how a cryptocurrency can be realised using
    the Blockchain technology will be based on Bitcoin. Later we will discuss some
    conceptual variations that arise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑加密货币。比特币加密货币于2009年提出，并且至今仍然是所有加密货币中最成功的。在比特币之后，提出了1500多种加密货币。所有这些加密货币都基于区块链技术，其中大多数在概念上与比特币非常相似，主要区别在于选择实现各种组件的工具。我们关于如何使用区块链技术实现加密货币的讨论将以比特币为基础。稍后我们将讨论一些概念上的变化。
- en: 18.1 Owner
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1 所有者
- en: While considering a cryptocurrency, the first issue that comes to the mind is
    how the currency is created. We will, however, defer this point. Let us assume
    that there is a unit of cryptocurrency and it exists. Existence of a cryptocurrency
    means that various amounts of it are held by different owners. At any point of
    time, the total amount of a cryptocurrency is the sum of the various amounts of
    the cryptocurrency held by the different owners. So, there is no existence of
    the cryptocurrency outside ownership.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑加密货币时，首先想到的问题是货币是如何创建的。然而，我们将推迟这一点。让我们假设存在一单位加密货币。加密货币的存在意味着不同的所有者持有不同数量的加密货币。在任何时间点，加密货币的总量是由不同所有者持有的加密货币数量之和。因此，在所有权之外不存在加密货币的存在。
- en: In the physical world, a physical entity is the owner of a certain amount of
    any currency. Such a physical entity can be a person or an organisation. Ownership
    of physical currency can mean various things. One important consequence of ownership
    is that it provides the owner with the privilege of spending the amount of currency
    that is held by the owner. The spending is effected by transferring (a part of)
    the amount held by the owner to another entity. This later entity then becomes
    the new owner of the said amount of the currency.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，某个物理实体是某种货币的所有者。这样的物理实体可以是一个人或一个组织。拥有物理货币可以意味着各种各样的事情。所有权的一个重要后果是，它为所有者提供了花费所持有的货币数量的特权。花费是通过将所有者持有的金额的（一部分）转移给另一个实体来实现的。然后，该后续实体成为该货币数量的新所有者。
- en: A cryptocurrency system emulates the spending aspects of a physical currency.
    In doing this, it abstracts away the requirement of a physical entity. The notion
    of ownership is captured by the spending ability, i.e. the owner of a certain
    amount of cryptocurrency can spend this amount.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币系统模拟了物理货币的花费方面。通过这样做，它抽象出了对物理实体的要求。所有权的概念通过花费能力来捕捉，即一定数量的加密货币的所有者可以花费这个数量。
- en: Fix a digital signature scheme. Using the ![inline-image](../images/CH018_1.jpg)
    algorithm of the scheme, it is possible to create a pair of signing (or secret)
    and verification (or public) keys. Each time the ![inline-image](../images/CH018_2.jpg)
    algorithm is invoked, it returns a new pair of secret/public keys. At a conceptual
    level, in a cryptocurrency system, the public keys are the owners of various amounts
    of the cryptocurrency. (We will modify this statement later.) Suppose, a public
    key ![inline-image](../images/CH018_3.jpg) owns *x* amount of the cryptocurrency.
    Then ![inline-image](../images/CH018_4.jpg) can make payments of *x* 1,…,*x* [*t*]
    amounts of the cryptocurrency to public keys ![inline-image](../images/CH018_5.jpg),
    respectively, such that *x* = *x* 1 + ⋯ + *x* [*t*] . For making this payment,
    the signing key ![inline-image](../images/CH018_6.jpg) corresponding to ![inline-image](../images/CH018_7.jpg)
    is required. Whoever possesses this signing key can make such a payment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修复数字签名方案。使用方案的![inline-image](../images/CH018_1.jpg)算法，可以创建一对签名（或秘密）和验证（或公共）密钥。每次调用![inline-image](../images/CH018_2.jpg)算法时，它都会返回一对新的秘密/公共密钥。在概念上，在加密货币系统中，公共密钥是各种金额加密货币的所有者。（我们稍后会修改这个声明。）假设，一个公钥![inline-image](../images/CH018_3.jpg)拥有
    *x* 金额的加密货币。然后![inline-image](../images/CH018_4.jpg)可以向相应的公钥![inline-image](../images/CH018_5.jpg)支付
    *x* 1,…,*x* [*t*] 金额的加密货币，使得 *x* = *x* 1 + ⋯ + *x* [*t*] 。为了进行这种支付，需要与![inline-image](../images/CH018_7.jpg)对应的签名密钥![inline-image](../images/CH018_6.jpg)。拥有此签名密钥的人可以进行此类支付。
- en: Physical entities are owners of the signing keys which allow them to make payments
    held by the corresponding public keys. One physical entity can create multiple
    signing and public keys. The total ownership of cryptocurrency by this physical
    entity is the sum of the various amounts of cryptocurrencies which are held by
    the public keys for which the physical entity possesses the corresponding signing
    keys. If a signing key is lost, then there is no way to spend the amount of cryptocurrency
    owned by the corresponding public key. This amount of cryptocurrency essentially
    goes out of the system and is lost.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 物理实体是拥有相应公钥的签名密钥的所有者，这使得它们能够支付相应公钥持有的加密货币。一个物理实体可以创建多个签名和公钥。此物理实体对加密货币的总拥有权是该物理实体持有相应签名密钥的公钥持有的各种加密货币金额之和。如果签名密钥丢失，则无法花费由相应公钥拥有的加密货币金额。这笔加密货币实质上退出系统并且丢失。
- en: A cryptocurrency system provides a certain amount of anonymity to a participating
    physical entity. Identities of the physical entities who participate in the system
    are not part of the system. The system only recognises public keys. Payments are
    made from one public key to one or more public keys. For making such a payment,
    the identity of the physical entity is not required. As long as the physical entity
    possesses the appropriate signing key, it can make the required payment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币系统为参与的物理实体提供一定程度的匿名性。参与系统的物理实体的身份不是系统的一部分。系统只识别公钥。支付是从一个公钥到一个或多个公钥进行的。为了进行这样的支付，不需要物理实体的身份。只要物理实体拥有适当的签名密钥，它就可以进行所需的支付。
- en: 18.2 Transactions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2 交易
- en: In Chapter 17, we have considered transactions in an abstract manner. In the
    context of a cryptocurrency, a transaction is a record of payment of the amount
    of cryptocurrency owned by one public key ![inline-image](../images/CH018_8.jpg)
    to one or more public keys ![inline-image](../images/CH018_9.jpg). So, there is
    a spender public key ![inline-image](../images/CH018_10.jpg) and a set of recipient
    public keys ![inline-image](../images/CH018_11.jpg). The statement of transfer
    is considered to be a message *M*. This message is digitally signed with the signing
    key ![inline-image](../images/CH018_12.jpg) corresponding to ![inline-image](../images/CH018_13.jpg)
    to produce a signature *s*. The task of signing represents the spender's commitment
    to the transaction. Since signing keys are not made public, only the physical
    entity who possesses the signing key ![inline-image](../images/CH018_14.jpg) can
    sign off on the transfer of funds. The statement of transfer *M* along with the
    signature *s* constitute a transaction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17章中，我们以抽象的方式考虑了交易。在加密货币的背景下，一笔交易是指将由一个公钥 ![inline-image](../images/CH018_8.jpg)
    拥有的加密货币金额支付给一个或多个公钥 ![inline-image](../images/CH018_9.jpg) 的记录。因此，存在一个支付者公钥 ![inline-image](../images/CH018_10.jpg)
    和一组接收者公钥 ![inline-image](../images/CH018_11.jpg)。转账声明被视为一条消息 *M*。该消息使用与 ![inline-image](../images/CH018_13.jpg)
    相对应的签名密钥 ![inline-image](../images/CH018_12.jpg) 进行数字签名以生成签名 *s*。签名的任务代表支付者对交易的承诺。由于签名密钥不是公开的，因此只有拥有签名密钥
    ![inline-image](../images/CH018_14.jpg) 的物理实体才能签署资金的转移。转账声明 *M* 与签名 *s* 组成了一笔交易。
- en: Verification of a transaction (*M*, *s*) consists of several checks. One of
    these is the verification of the signature. The spender public key ![inline-image](../images/CH018_15.jpg)
    is public. So, anybody can use the verification algorithm along with ![inline-image](../images/CH018_16.jpg)
    to verify that (*M*, *s*) is a valid message-signature pair.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 交易 (*M*, *s*) 的验证包括几项检查。其中之一是签名的验证。支付者的公钥 ![inline-image](../images/CH018_15.jpg)
    是公开的。因此，任何人都可以使用验证算法和 ![inline-image](../images/CH018_16.jpg) 来验证 (*M*, *s*) 是否是一个有效的消息-签名对。
- en: The other important check on a transaction is to verify that ![inline-image](../images/CH018_17.jpg)
    indeed owns the stated amount of cryptocurrency. We consider this issue. As discussed
    in Chapter 17, transactions are grouped together into blocks, and the blocks are
    organised into the blockchain. The blockchain is public and constitutes the public
    ledger. So, any transaction which is part of the blockchain is publicly available.
    In the above, we have discussed how the transfer of cryptocurrency from one public
    key to another public key is effected. There is also a method for creating specific
    amounts of cryptocurrency and assigning it to a public key, and this information
    is also available on the blockchain. (We will discuss the procedure for creation
    of cryptocurrency later.) So, a certain amount of cryptocurrency gets created
    and assigned to a public key; a transaction distributes this amount to a set of
    public keys; subsequent transactions, in turn, distribute the amounts to other
    public keys and so on. All such information is available on the blockchain. Consequently,
    at any point of time, using the blockchain, it is possible to determine whether
    a particular public key indeed possesses a stated amount of cryptocurrency. As
    a result, it is possible to verify whether the spender public key in a transaction
    is indeed the owner of the amount it spends in the transaction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对交易的另一个重要检查是验证![inline-image](../images/CH018_17.jpg)确实拥有所声明的加密货币数量。我们考虑了这个问题。正如第17章所讨论的，交易被组合成块，并且这些块被组织成区块链。区块链是公开的，并构成公共账本。因此，任何属于区块链的交易都是公开可见的。在上文中，我们已经讨论了如何从一个公钥转移到另一个公钥。还有一种方法可以创建特定数量的加密货币并将其分配给一个公钥，这些信息也可以在区块链上找到。（我们将稍后讨论创建加密货币的程序。）因此，一定数量的加密货币被创建并分配给一个公钥；一笔交易将这个数量分配给一组公钥；随后的交易依次将金额分配给其他公钥，依此类推。所有这些信息都可以在区块链上找到。因此，在任何时候，使用区块链，都可以确定一个特定的公钥是否确实拥有所声明的加密货币数量。因此，可以验证交易中的花费者公钥是否确实是在交易中花费的金额的所有者。
- en: Chapter 17 discussed how a P2P network is used to implement a blockchain. One
    of the activities of the nodes in such a network is to group transactions into
    blocks. Before including a transaction into a block, a node verifies the transaction.
    Apart from basic verification, such as the sum of the amount transferred to the
    recipient public keys is at most the amount owned by the spender public keys,
    this verification consists of two essential tasks. The first is to determine whether
    the spender public key indeed owns the amount of cryptocurrency to be transferred,
    and the second is the verification of the signature in the transaction. If either
    of these checks fail, the transaction is discarded. Otherwise, the node includes
    it in the list of transactions and attempts to create a block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章讨论了如何使用P2P网络来实现区块链。在这种网络中，节点的一个活动是将交易分组到区块中。在将交易包含到一个区块之前，节点会验证交易。除了基本验证，如转移到收款者公钥的金额之和至多等于花费者公钥拥有的金额之外，这种验证包括两个关键任务。第一个是确定花费者公钥是否确实拥有要转移的加密货币金额，第二个是验证交易中的签名。如果这些检查中的任何一个失败，交易将被丢弃。否则，节点会将其包含在交易列表中，并尝试创建一个区块。
- en: So, far we have mentioned that a transaction consists of a single spender public
    key and possibly more than one recipient public keys. It is also possible for
    a transaction to have multiple spender public keys. In this case, the transaction
    has to be signed by the signing keys corresponding to each of the spender public
    keys. Further, the sum of the amounts of the cryptocurrency transferred to all
    the recipient public keys must be at most the sum of the amounts of the cryptocurrency
    owned by all the spender public keys.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到一个交易由一个花费者公钥和可能多个收款者公钥组成。一个交易也可能有多个花费者公钥。在这种情况下，交易必须由与每个花费者公钥对应的签名密钥签名。此外，转移到所有收款者公钥的加密货币金额之和必须至多等于所有花费者公钥拥有的加密货币金额之和。
- en: Suppose there are *s* spender public keys owning *x* 1,…,*x* *s* amounts of
    the cryptocurrency and there are *t* recipient public keys receiving *y* 1,…,*y*
    [*t*] amounts of the cryptocurrency. Then a necessary condition for a valid transaction
    is that ![inline-image](../images/CH018_18.jpg). If ![inline-image](../images/CH018_19.jpg),
    then the entire input amount is transferred to the output. On the other hand,
    if ![inline-image](../images/CH018_20.jpg), then the difference ![inline-image](../images/CH018_21.jpg)
    is transferred to the node in the P2P network which successfully creates a block
    containing the transaction. This difference *δ* is called the transaction fee
    and is an incentive for nodes in the network to include the transaction in a block.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在 *s* 个花费者公钥拥有 *x* 1,…,*x* *s* 数量的加密货币，并且存在 *t* 个接收者公钥接收 *y* 1,…,*y* [*t*]
    数量的加密货币。那么有效交易的一个必要条件是 ![inline-image](../images/CH018_18.jpg)。如果 ![inline-image](../images/CH018_19.jpg)，那么整个输入金额将被转移到输出中。另一方面，如果
    ![inline-image](../images/CH018_20.jpg)，那么差额 ![inline-image](../images/CH018_21.jpg)
    将被转移到成功创建包含交易的区块的 P2P 网络中的节点。这个差额 *δ* 被称为交易费，是网络中的节点将交易包含在区块中的激励。
- en: Note that the entire amount ![inline-image](../images/CH018_22.jpg) owned by
    the spender public keys is utilised, either by transferring to recipient public
    keys or as the transaction fee. There is no way for a spender public key to retain
    a part of the amount that it holds. Suppose a physical entity *A* possesses the
    secret key ![inline-image](../images/CH018_23.jpg) corresponding to a public key
    ![inline-image](../images/CH018_24.jpg) which owns *x* amount of the cryptocurrency.
    Further, suppose *A* wishes to make a payment of an amount *y* < *x* to a public
    key ![inline-image](../images/CH018_25.jpg). If *A* creates a transaction with
    ![inline-image](../images/CH018_26.jpg) as the spender key and transferring *y*
    to ![inline-image](../images/CH018_27.jpg), then the amount *x* − *y* becomes
    the transaction fee and is a loss to *A*. The way to make such a part payment
    is the following. Entity *A* creates a new public/signing key pair ![inline-image](../images/CH018_28.jpg)
    and ![inline-image](../images/CH018_29.jpg) and keeps ![inline-image](../images/CH018_30.jpg)
    secret. It then creates a transaction with ![inline-image](../images/CH018_31.jpg)
    as the spender public key transferring amount *y* to ![inline-image](../images/CH018_32.jpg)
    and amount *z* to ![inline-image](../images/CH018_33.jpg) such that *y* + *z*
    ≤ *x*. Since *A* possesses the signing key ![inline-image](../images/CH018_34.jpg),
    it can later spend the amount *z* assigned to ![inline-image](../images/CH018_35.jpg).
    Note that if *y* + *z* = *x*, then there is no transaction fee. Entity *A* may
    set the value of *z* such that there is a small amount of transaction fee to incentivise
    nodes to include the transaction into a block.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，花费者公钥拥有的整个金额![inline-image](../images/CH018_22.jpg)要么用于转移到接收者公钥，要么作为交易费用。花费者公钥无法保留其所持金额的一部分。假设一个实体*A*拥有与持有*x*金额的公钥![inline-image](../images/CH018_24.jpg)对应的秘钥![inline-image](../images/CH018_23.jpg)。此外，假设*A*希望向公钥![inline-image](../images/CH018_25.jpg)支付小于*x*的金额*y*。如果*A*创建一个以![inline-image](../images/CH018_26.jpg)作为花费者密钥，并向![inline-image](../images/CH018_27.jpg)转移*y*的交易，那么金额*x*
    − *y*将成为交易费用，对*A*来说是损失。实现这种部分支付的方法如下。实体*A*创建一个新的公共/签名密钥对![inline-image](../images/CH018_28.jpg)和![inline-image](../images/CH018_29.jpg)，并保持![inline-image](../images/CH018_30.jpg)的机密。然后，它创建一个以![inline-image](../images/CH018_31.jpg)作为花费者公钥，向![inline-image](../images/CH018_32.jpg)转移金额*y*和向![inline-image](../images/CH018_33.jpg)转移金额*z*的交易，使得*y*
    + *z* ≤ *x*。由于*A*拥有分配给![inline-image](../images/CH018_35.jpg)的金额*z*的签名密钥![inline-image](../images/CH018_34.jpg)，因此它稍后可以花费这笔金额*z*。请注意，如果*y*
    + *z* = *x*，则不存在交易费用。实体*A*可以设置*z*的值，以便有少量的交易费用，以激励节点将交易包含到一个区块中。
- en: 18.3 Cryptocurrency Addresses
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3 加密货币地址
- en: We have mentioned that public keys are owners of cryptocurrency. This statement
    is not accurate. More technically, the owners of cryptocurrency are addresses.
    These addresses are formed by applying a hash function to the public keys. The
    hash function that is used to generate the addresses may be different from the
    hash function used to chain the blocks in the blockchain. Suppose *H* 1 is the
    hash function used to generate addresses. Given a public key ![inline-image](../images/CH018_36.jpg),
    an address is computed as ![inline-image](../images/CH018_37.jpg).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到公钥是加密货币的所有者。这种说法并不准确。更准确地说，加密货币的所有者是地址。这些地址是通过将哈希函数应用于公钥而形成的。用于生成地址的哈希函数可能与用于链式区块的哈希函数不同。假设*H*1是用于生成地址的哈希函数。给定一个公钥![inline-image](../images/CH018_36.jpg)，地址计算为![inline-image](../images/CH018_37.jpg)。
- en: Assuming that *H* 1 is collision resistant, cryptocurrency addresses are unique
    encodings of the public keys. Suppose that (*sk*, *pk*) is a pair of signing and
    verification keys and ![inline-image](../images/CH018_38.jpg). The amount of cryptocurrency
    associated with the address can be spent by whoever possesses the signing key
    ![inline-image](../images/CH018_39.jpg). If it is possible to generate another
    pair of signing and verification keys ![inline-image](../images/CH018_40.jpg)
    such that ![inline-image](../images/CH018_41.jpg), then using ![inline-image](../images/CH018_42.jpg)
    it becomes possible to spend the amount associated with the address *a*. Given
    ![inline-image](../images/CH018_43.jpg) and ![inline-image](../images/CH018_44.jpg),
    the task of obtaining ![inline-image](../images/CH018_45.jpg) such that ![inline-image](../images/CH018_46.jpg)
    is that of finding a second pre-image of the element *a* in the range of *H* 1\.
    Under the assumption that *H* 1 is second pre-image resistant, this task is computationally
    infeasible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*H*1是碰撞抵抗的，加密货币地址是公钥的唯一编码。假设(*sk*, *pk*)是一对签名和验证密钥，并且![inline-image](../images/CH018_38.jpg)。与地址关联的加密货币金额可以由持有签名密钥的人花费![inline-image](../images/CH018_39.jpg)。如果可能生成另一对签名和验证密钥![inline-image](../images/CH018_40.jpg)，使得![inline-image](../images/CH018_41.jpg)，那么使用![inline-image](../images/CH018_42.jpg)就可以花费与地址*a*关联的金额。给定![inline-image](../images/CH018_43.jpg)和![inline-image](../images/CH018_44.jpg)，获得![inline-image](../images/CH018_45.jpg)使得![inline-image](../images/CH018_46.jpg)的任务是在*H*1的范围内找到元素*a*的第二个前像。在*H*1是第二个前像抵抗的假设下，这个任务是计算上不可行的。
- en: We have mentioned that a transaction transfers funds from spender public keys
    to recipient public keys. A more accurate statement is that a transation transfers
    funds from spender addresses to recipient addresses where the addresses are computed
    as digests of relevant public keys by applying the hash function *H* 1\. For a
    conceptual understanding, it is not required to distinguish between public keys
    and their addresses. Accordingly, we will continue talking about cryptocurrency
    being assigned to public keys rather than to addresses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，一笔交易将资金从花费者的公钥转移到收款者的公钥。更准确地说，一笔交易将资金从花费者的地址转移到收款者的地址，这些地址是通过应用哈希函数 *H*
    对相关公钥的摘要计算得出的。为了概念上的理解，不需要区分公钥和它们的地址。因此，我们将继续谈论加密货币被分配给公钥，而不是地址。
- en: 18.4 Recapitulation
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4 回顾
- en: Let us briefly recapitulate what has been discussed. The owners of various amounts
    of cryptocurrency are public keys. Transactions record the details of payment
    from one or more public keys to one or more other public keys.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下讨论的内容。各种数量的加密货币的所有者是公钥。交易记录了从一个或多个公钥到一个或多个其他公钥的支付细节。
- en: A cryptocurrency is implemented using a blockchain. Groups of transactions are
    organised into blocks, and the blocks are sequenced into the blockchain. The blockchain
    is maintained in a distributed fashion by a P2P network. Complete information
    regarding which public key owns what amount of cryptocurrency is available from
    the blockchain. Each node in the network maintains its own copy of the blockchain
    and the list of transactions which are yet to be inserted into the blockchain.
    Nodes generate transactions and use the gossip protocol of the P2P network to
    propagate them. Nodes also create blocks and propagate them using the gossip protocol.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区块链实现加密货币。交易组织成块，并且这些块被顺序排列到区块链中。区块链通过点对点网络以分布式方式维护。关于哪个公钥拥有多少加密货币的完整信息可从区块链获取。网络中的每个节点维护自己的区块链副本和尚未插入到区块链的交易列表。节点生成交易并使用点对点网络的八卦协议传播它们。节点还创建块并使用八卦协议传播它们。
- en: A block is of the form ![inline-image](../images/CH018_47.jpg), where *h* is
    the digest under the hash function *H* of the previous block, *R* is a list of
    transactions and ![inline-image](../images/CH018_48.jpg) is a special value. So
    far, we have not explained the role of ![inline-image](../images/CH018_49.jpg).
    This parameter plays a crucial role in the creation of a block. Next we explain
    how a block is created and the role of ![inline-image](../images/CH018_50.jpg)
    in it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块的形式如 ![inline-image](../images/CH018_47.jpg)，其中 *h* 是前一个区块在哈希函数 *H* 下的摘要，*R*
    是交易列表，而 ![inline-image](../images/CH018_48.jpg) 则是一个特殊值。到目前为止，我们还没有解释 ![inline-image](../images/CH018_49.jpg)
    的角色。这个参数在创建区块中起着至关重要的作用。接下来我们将解释区块如何创建以及 ![inline-image](../images/CH018_50.jpg)
    在其中的作用。
- en: 18.5 Creation of a Block via Proof of Work
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.5 通过工作证明创建区块
- en: Consider a node *v* whose local copy of the blockchain is ![inline-image](../images/CH018_51.jpg)
    with a block ![inline-image](../images/CH018_52.jpg) as the header. The list of
    un-blocked transactions available with *v* is ![inline-image](../images/CH018_53.jpg).
    To create a block, *v* chooses a list of transactions *R* from ![inline-image](../images/CH018_54.jpg)
    and verifies each of them. The verification checks on the transactions have been
    explained above. Node *v* computes ![inline-image](../images/CH018_55.jpg). Next
    it attempts to create a block ![inline-image](../images/CH018_56.jpg). It is in
    this step that ![inline-image](../images/CH018_57.jpg) plays a role.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个节点 *v*，其区块链的本地副本为 ![inline-image](../images/CH018_51.jpg)，其中的一个区块 ![inline-image](../images/CH018_52.jpg)
    为头部。节点 *v* 可用的未封锁交易列表为 ![inline-image](../images/CH018_53.jpg)。要创建一个区块，*v* 从 ![inline-image](../images/CH018_54.jpg)
    中选择一个交易列表 *R* 并验证每个交易。交易验证检查已在上文中解释过。节点 *v* 计算 ![inline-image](../images/CH018_55.jpg)。然后尝试创建一个区块
    ![inline-image](../images/CH018_56.jpg)。正是在这一步中，![inline-image](../images/CH018_57.jpg)
    起到作用。
- en: To create a block, node *v* is expected to do some work. Further, *v* is required
    to provide a proof that the required work has indeed been done. There is a system-wide
    parameter *d* which determines the *difficulty* of generating a proof of work.
    The difficulty *d* is a positive integer which controls the amount of work that
    is required to create a new block. The parameter *d* is not the actual difficulty;
    rather, the difficulty is inversely proportional to *d* as we will see below.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个区块，节点 *v* 预期需要做一些工作。此外，*v* 还需要提供一个证明，证明所需工作确实已完成。系统范围内有一个参数 *d*，它确定了生成工作证明的*难度*。难度
    *d* 是一个正整数，控制着创建新区块所需的工作量。参数 *d* 并非实际难度；相反，难度与 *d* 成反比，我们将在下文看到。
- en: As explained earlier, the digest (or, output) of the hash function *H* is an
    *n*-bit binary string and can be considered to be the binary representation of
    integers in the set {0,…,2 ^([*n*]) −1}. Interpreted in this manner, the output
    of *H* can be considered to be an integer. Suppose on some input, the output of
    *H* is *y*. If the most significant bit of *y* is 0, then *y* is less than 2 ^(*n*−1);
    if the two most significant bits of *y* is 0, then *y* is less than 2 ^(*n*−2);
    and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面解释的，哈希函数 *H* 的摘要（或输出）是一个 *n* 位二进制字符串，可以被视为集合 {0,…,2 ^(*n*) −1} 中整数的二进制表示。用这种方式解释，*H*
    的输出可以被视为一个整数。假设在某些输入上，*H* 的输出是 *y*。如果 *y* 的最高有效位为 0，则 *y* 小于 2 ^(*n*−1)；如果 *y*
    的两个最高有效位为 0，则 *y* 小于 2 ^(*n*−2)；依此类推。
- en: For node *v* to create a block ![inline-image](../images/CH018_58.jpg), it must
    find a value of ![inline-image](../images/CH018_59.jpg) such that ![inline-image](../images/CH018_60.jpg).
    Let us consider the difficulty of this computational task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要使节点 *v* 创建一个区块 ![inline-image](../images/CH018_58.jpg)，它必须找到一个值 *x*，使得 ![inline-image](../images/CH018_59.jpg)。让我们考虑一下这个计算任务的难度。
- en: One way for *v* to determine ![inline-image](../images/CH018_61.jpg) is to first
    choose a value *y* which is less than *d* and then find an ![inline-image](../images/CH018_62.jpg)
    such that ![inline-image](../images/CH018_63.jpg). This means that given a particular
    output *y*, it is required to find a pre-image ![inline-image](../images/CH018_64.jpg)
    of *y* under *H*, i.e. to invert the function *H*. Recall that one of the basic
    properties of *H* is that it is one-way which means that it is computationally
    infeasible to invert *H*. So, we can assume that *v* is unable to determine ![inline-image](../images/CH018_65.jpg)
    by inverting *H* on the digest *y*. The input to *H* is ![inline-image](../images/CH018_66.jpg),
    of which ![inline-image](../images/CH018_67.jpg) is obtained as ![inline-image](../images/CH018_68.jpg)
    and *R* is the set of transactions to be included in the block *B*. The quantities
    ![inline-image](../images/CH018_69.jpg) and *R* are fixed and there is flexibility
    only in choosing ![inline-image](../images/CH018_70.jpg). So, the task of inverting
    *H* in the present context is not simply to obtain any particular pre-image of
    *y*, but, one that has ![inline-image](../images/CH018_71.jpg) and *R* as the
    first two components. This is an even more difficult task than simply inverting
    *H*. Of course, since *H* is one-way to start with, this distinction does not
    matter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*v*确定![inline-image](../images/CH018_61.jpg)的一种方法是首先选择一个小于*d*的值*y*，然后找到一个![inline-image](../images/CH018_62.jpg)，使得![inline-image](../images/CH018_63.jpg)。这意味着给定一个特定的输出*y*，需要找到函数*H*下的一个预像![inline-image](../images/CH018_64.jpg)，即反转函数*H*。回想一下*H*的基本属性之一是它是单向的，这意味着计算上不可行地反转*H*。所以，我们可以假设*v*无法通过在摘要*y*上反转*H*来确定![inline-image](../images/CH018_65.jpg)。*H*的输入是![inline-image](../images/CH018_66.jpg)，其中![inline-image](../images/CH018_67.jpg)被获得为![inline-image](../images/CH018_68.jpg)，*R*是要包含在区块*B*中的交易集合。数量![inline-image](../images/CH018_69.jpg)和*R*是固定的，只有在选择![inline-image](../images/CH018_70.jpg)方面有灵活性。因此，在当前情况下反转*H*的任务不仅是获得*y*的任何特定的预像，而且是具有![inline-image](../images/CH018_71.jpg)和*R*作为前两个组成部分的预像。这比简单地反转*H*更困难。当然，由于*H*本来就是单向的，这种区别并不重要。'
- en: Another way in which *v* can attempt to find ![inline-image](../images/CH018_72.jpg)
    is to repeatedly try distinct values of ![inline-image](../images/CH018_73.jpg)
    and compute ![inline-image](../images/CH018_74.jpg). By trying many values, *v*
    can hope to eventually find a value ![inline-image](../images/CH018_75.jpg) such
    that ![inline-image](../images/CH018_76.jpg). At this point, *v* has been able
    to create the block ![inline-image](../images/CH018_77.jpg). Node *v* will propagate
    *B* using the gossip protocol.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种*v*尝试寻找![inline-image](../images/CH018_72.jpg)的方法是反复尝试不同的值![inline-image](../images/CH018_73.jpg)，并计算![inline-image](../images/CH018_74.jpg)。通过尝试许多值，*v*可以希望最终找到一个值![inline-image](../images/CH018_75.jpg)，使得![inline-image](../images/CH018_76.jpg)。在这一点上，*v*已经能够创建区块![inline-image](../images/CH018_77.jpg)。节点*v*将使用八卦协议传播*B*。
- en: How many times should *H* have to be computed before finding a desirable ![inline-image](../images/CH018_78.jpg)?
    To answer this question, the random oracle assumption on *H* is used, i.e. the
    hash function *H* is assumed to behave like a uniform random function which on
    distinct inputs returns independent and uniformly distributed *n*-bit strings
    (equivalently, independent and uniformly distributed integers from the set {0,…,2
    ^([*n*]) −1}). For any positive integer *d*, there are *d* non-negative integers
    less than *d*. So, under the random oracle assumption on *H*, the probability
    that a single invocation of *H* returns a *y* such that *y* < *d* is *d*/2 ^([*n*])
    . Considering *y* < *d* to be success, repeated invocations of *H* gives rise
    to independent Bernoulli trials with probability of success *d*/2 ^([*n*]) . The
    expected number of successes in *N* such trials is ![inline-image](../images/CH018_79.jpg).
    We wish to obtain one success and so setting *Nd*/2 ^([*n*]) = 1 gives *N* = 2
    ^([*n*]) /*d*, i.e. in about 2 ^([*n*]) /*d* trials, one may expect to obtain
    a ![inline-image](../images/CH018_80.jpg) such that ![inline-image](../images/CH018_81.jpg).
    So, for example, if *d* = 2 ^(*n*−32), then successful creation of a block requires
    about 2^(32) invocations of *H*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在找到一个理想的![内联图像](../images/CH018_78.jpg)之前计算*H*多少次？为了回答这个问题，假设*H*是一个随机预言，即假设散列函数*H*的行为类似于一个均匀随机函数，对不同的输入返回独立且均匀分布的*n*位字符串（等价地，从集合{0,…,2
    ^([*n*]) −1}中返回独立且均匀分布的整数）。对于任何正整数*d*，有*d*个非负整数小于*d*。因此，在*H*的随机预言假设下，单次调用*H*返回一个*y*，使得*y*
    < *d*的概率为*d*/2 ^([*n*])。考虑*y* < *d*为成功，重复调用*H*产生独立的伯努利试验，成功概率为*d*/2 ^([*n*])。在这样的*N*次试验中成功的预期次数是![内联图像](../images/CH018_79.jpg)。我们希望获得一次成功，因此设置*Nd*/2
    ^([*n*]) = 1得到*N* = 2 ^([*n*]) /*d*，即在大约2 ^([*n*]) /*d*次试验中，可以期望获得一个![内联图像](../images/CH018_80.jpg)，使得![内联图像](../images/CH018_81.jpg)。因此，例如，如果*d*
    = 2 ^(*n*−32)，则成功创建一个区块需要大约2^(32)次调用*H*。
- en: Creation of a block by a node *v* requires repeated invocation of the hash function
    *H*. This is the work that the node *v* has to do to create the block. The value
    of ![inline-image](../images/CH018_82.jpg) such that ![inline-image](../images/CH018_83.jpg)
    is the *proof* that node *v* has indeed put in the required amount of work. Note
    that given the value ![inline-image](../images/CH018_84.jpg), checking the condition
    ![inline-image](../images/CH018_85.jpg) requires only one invocation of *H* and
    is very efficient. So, generating a proof of work is time consuming, while verifying
    a given proof is easy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点*v*创建一个区块需要重复调用散列函数*H*。这是节点*v*需要做的工作来创建区块。使得![内联图像](../images/CH018_82.jpg)的值使得![内联图像](../images/CH018_83.jpg)成立，这是节点*v*确实投入了所需的工作量的*证明*。请注意，给定值![内联图像](../images/CH018_84.jpg)，检查条件![内联图像](../images/CH018_85.jpg)只需要一次*H*的调用，并且非常高效。因此，生成工作证明是耗时的，而验证给定证明是容易的。
- en: Any new block created by a node is propagated on the P2P network using the gossip
    protocol. Nodes which receive a new block will insert it into its copy of the
    blockchain. Before doing this, a node will verify the proof of work. If the verification
    fails, then the block will be rejected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个节点创建的新区块都会使用八卦协议在P2P网络上传播。接收到新区块的节点会将其插入到自己的区块链副本中。在执行此操作之前，节点会验证工作证明。如果验证失败，则会拒绝该区块。
- en: The actual difficulty is inversely proportional to *d*. Difficulty of creating
    a new block is stored as part of the metadata of the block. The difficulty of
    a blockchain is the sum of difficulties of the blocks in the blockchain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际困难与*d*成反比。创建新区块的难度作为区块的元数据的一部分存储。区块链的难度是区块链中各区块的难度之和。
- en: 18.6 Block Reward and Creation of Cryptocurrency
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.6 区块奖励和加密货币的创建
- en: Creating a new block requires a node to put in a certain amount of work. This
    work consists of using the computational resources of the node and has a cost.
    To incentivise nodes to create blocks, the system provides for a block reward.
    The block reward comes in the form of certain amount of cryptocurrency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新区块需要节点投入一定量的工作。这项工作包括使用节点的计算资源，并带有成本。为了激励节点创建区块，系统提供了区块奖励。区块奖励以一定数量的加密货币形式提供。
- en: There are two components to a block reward. The first component comes from the
    minting of new currency which goes to the creator of the block. The second component
    consists of the transaction fees available in the transactions which have been
    grouped together in the block. The issue of transaction fees has already been
    explained. To incentivise nodes to include a transaction into a block, the total
    amount of cryptocurrency transferred to recipient public keys is kept less than
    the total amount of cryptocurrency held by the spender public keys. The difference
    is the fee of the transaction and is claimed by the node which successfully creates
    a block containing this transaction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 区块奖励有两个组成部分。第一个组成部分来自于铸造新货币，该部分归区块创建者所有。第二个组成部分由交易费组成，这些交易已经被组合到区块中。交易费问题已经解释过了。为了激励节点将交易包含在区块中，转账给接收方公钥的加密货币总金额被保持小于由花费方公钥持有的加密货币总金额。差额是交易的费用，并由成功创建包含此交易的区块的节点所要求。
- en: New currency is created when a block is successfully created. The successful
    creation of a block is also called *mining* of a block. The rules of the cryptocurrency
    system specify the amount of cryptocurrency that is to be created when a block
    is successfully mined. This amount of cryptocurrency was not previously present
    in the system. So, the volume of cryptocurrency grows as new blocks are mined.
    In fact, the rules of the cryptocurrency system actually specify the rate at which
    the volume of cryptocurrency grows. The rate of creation of cryptocurrency decreases
    over time until finally no more new currency will be created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功创建一个块时，新货币就会被创建。成功创建一个块也称为挖掘一个块。加密货币系统的规则指定了成功挖掘一个块时应创建的加密货币数量。这些加密货币数量在系统中之前并不存在。因此，随着新块的挖掘，加密货币的数量会增加。实际上，加密货币系统的规则实际上指定了加密货币数量增长的速率。加密货币的创建速率随时间减少，直到最终不再创建新货币。
- en: Suppose node *v* successfully mines a block ![inline-image](../images/CH018_86.jpg).
    It may be noted here that all transactions in *R* other than the first one are
    present in ![inline-image](../images/CH018_87.jpg). The first transaction in *R*
    is special and is called a *coinbase transaction*. This transaction does not have
    any spender public key. It only has one or more recipient public keys. The amount
    of cryptocurrency assigned to the recipient public keys is the block reward which
    is the sum of the transaction fees of all the transactions in *R* and the amount
    of new currency that is created with the mining of the block. At a time when no
    more new currency will be created, the block reward will consist entirely of the
    transaction fees.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点*v*成功挖掘了一个块![inline-image](../images/CH018_86.jpg)。这里需要注意的是，*R*中除了第一个交易之外的所有交易都存在于![inline-image](../images/CH018_87.jpg)中。*R*中的第一笔交易是特殊的，称为*coinbase交易*。该交易没有任何花费者公钥。它只有一个或多个收款人公钥。分配给收款人公钥的加密货币金额是块奖励，它等于*R*中所有交易的交易费之和以及挖掘该块时创建的新货币金额。当不再创建新货币时，块奖励将完全由交易费组成。
- en: 18.7 Hash Rate
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.7 哈希率
- en: We have seen that in about 2 ^([*n*]) /*d* invocations of *H* it becomes likely
    to obtain a digest which is less than *d*. These invocations are independent and
    can be performed in parallel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在大约2 ^([*n*]) /*d*次调用*H*后，有可能获得一个小于*d*的摘要。这些调用是独立的，可以并行执行。
- en: The nodes in the P2P network of the cryptocurrency system compete among themselves
    to mine a block. Mining a block essentially consists of applying the hash function
    *H* repeatedly. The repeated application of *H* requires computational power.
    Since computing consumes energy, mining a block also consumes a significant amount
    of electricity. While the nodes have the same privileges on the network, by no
    means do they have the same amount of computational power. Nodes with greater
    computational resources are more likely to mine a block.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币系统的P2P网络中的节点彼此竞争以挖掘区块。挖掘区块本质上是反复应用哈希函数*H*。反复应用*H*需要计算能力。由于计算消耗能量，挖掘一个区块也消耗大量电力。尽管节点在网络上拥有相同的特权，但它们的计算能力却不相同。具有更多计算资源的节点更有可能挖掘一个区块。
- en: At any point of time, the nodes in the P2P network are applying *H* to mine
    a block. So, one may consider the total computational power of the network to
    be the number of times *H* is invoked in one second by all the nodes in the network.
    Essentially, this is the rate at which the entire network applies the hash function
    *H*. The hash rate *ν* *v* of a node *v* is the number of times *v* is able to
    apply *H* in one second. Then the total hash rate of the network is ![inline-image](../images/CH018_88.jpg)
    where the sum is over all the nodes in the network. The proportion of the hash
    rate of the entire network controlled by *v* is ![inline-image](../images/CH018_89.jpg).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，P2P网络中的节点都在应用*H*来挖掘一个区块。因此，人们可以认为网络的总计算能力是网络中所有节点一秒钟内调用*H*的次数。本质上，这是整个网络应用哈希函数*H*的速率。节点*v*的哈希率*ν*
    *v*是*v*一秒钟内能够应用*H*的次数。那么网络的总哈希率是![inline-image](../images/CH018_88.jpg)，其中求和是对网络中的所有节点进行的。*v*控制的整个网络哈希率的比例是![inline-image](../images/CH018_89.jpg)。
- en: The quantity *p* *v* is the probability of *v* being able to mine the next block.
    Assume that a sufficiently large number *N* of blocks have been mined in the network.
    Then the expected number of blocks mined by *v* is *p* *v* *N*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*p* *v* 的数量是*v*能够挖掘下一个区块的概率。假设网络中已经挖出足够多的区块*N*。那么*v*挖掘的预期区块数量是*p* *v* *N*。'
- en: A node *v* has to invest a certain amount of money μ to attain a hash rate *ν*
    *v* . Its expected return on this investment after *N* blocks have been mined
    is the total amount of block reward earned from *p* *v* *N* blocks. The business
    venture is profitable for *v* only if the total block reward for *p* *v* *N* blocks
    is more than *μ*. In determining profitablity, node *v* not only has to consider
    the cost of increasing its own hash rate but also has to take into account the
    investments being made by other nodes. This is because *p* *v* is the ratio of
    *ν* *v* to *ν*, where *ν* is the sum of the hash rates of all the nodes in the
    network. If *v* increases *ν* [*v*] , but other nodes also increase their hash
    rates perhaps outpacing *ν* [*v*] , then the ratio *p* *v* = *ν* *v* /*ν* may
    actually go down even though *ν* *v* increases. In such a situation, node *v*
    will not be able to make a profit even though it has increased its hash rate through
    a new investment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点 *v* 必须投资一定金额的资金 μ 才能获得哈希率 *ν* *v*。在挖掘了 *N* 个区块之后，它对这笔投资的预期回报是从 *p* *v*
    *N* 个区块中获得的总区块奖励。仅当 *p* *v* *N* 个区块的总区块奖励大于μ时，节点 *v* 的商业冒险才是有利可图的。在确定盈利能力时，节点
    *v* 不仅必须考虑增加自己的哈希率的成本，还必须考虑其他节点正在进行的投资。这是因为 *p* *v* 是 *ν* *v* 与网络中所有节点的哈希率之和 *ν*
    的比率。如果 *v* 增加了 *ν* [*v*]，但其他节点也增加了它们的哈希率，甚至可能超过了 *ν* [*v*]，那么，尽管 *ν* [*v*] 增加，但比率
    *p* *v* = *ν* *v* /*ν* 可能实际下降。在这种情况下，即使通过新投资增加了哈希率，节点 *v* 也将无法获利。
- en: An interesting example is that of China's Bitmain versus Japan's GMO. GMO had
    invested heavily to improve its hash rate. However, Bitmain outpaced GMO and eventually,
    even though GMO increased its hash rate, its probability of mining did not improve.
    Overall, the investment in increasing computational power was not compensated
    by increased returns. This led GMO to withdraw from Bitcoin mining at the end
    of 2018, taking a loss of about US $300 million.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是中国的比特大陆与日本的GMO。GMO曾大量投资以提高其哈希率。然而，比特大陆超越了GMO，最终，即使GMO提高了其哈希率，其挖矿概率也没有提高。总的来说，增加计算能力的投资并没有得到增加的回报。这导致GMO在2018年底退出比特币挖矿，蒙受了大约3亿美元的损失。
- en: 18.8 Updating the Difficulty Parameter
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.8 更新难度参数
- en: Suppose the network hash rate is ν hashes per second. With a fixed value of
    *d*, the number of hashes required to obtain a new block is about 2 ^([*n*]) /*d*.
    So, considering the network as a whole, a new block is mined in about every 2
    ^([*n*]) /(*dν*) seconds. Recall that the mining of a new block leads to the creation
    of new cryptocurrency. Thus, new amounts of the cryptocurrency are created every
    2 ^([*n*]) /(*dν*) seconds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设网络哈希率为每秒 ν 次哈希。在固定值 *d* 的情况下，获得新区块所需的哈希次数大约是 2 ^([*n*]) / *d*。因此，考虑整个网络的话，大约每
    2 ^([*n*]) / (*dν*) 秒就会挖到一个新区块。请记住，挖掘新区块会导致新加密货币的创造。因此，每 2 ^([*n*]) / (*dν*) 秒都会创建新的加密货币数量。
- en: The hash rate *ν* of the network depends upon the total computational capabilities
    of all the nodes in the P2P network. As the nodes in the network increase their
    computational resources, the hash rate *ν* increases. If *d* is kept constant,
    then new cryptocurrency will be created faster. If the total amount of money in
    the system increases very fast, this would lead to an inflationary situation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的哈希率 *ν* 取决于 P2P 网络中所有节点的总计算能力。随着网络中的节点增加其计算资源，哈希率 *ν* 也会增加。如果 *d* 保持不变，那么新加密货币将被更快地创建出来。如果系统中的总货币数量增长得非常快，这将导致通货膨胀的情况。
- en: There are two ways in which such an inflationary scenario can be prevented.
    First, the value of the parameter *d* is decreased so that the value of 2 ^([*n*])
    /(*dν*) remains constant. Second, the amount of cryptocurrency created per block
    decreases at a steady pace. We discuss these two points with specific reference
    to Bitcoin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式防止这种通货膨胀的情况发生。首先，减小参数 *d* 的值，以使 2 ^([*n*]) /(*dν*) 的值保持不变。其次，每个区块创建的加密货币数量以稳定的速度减少。我们将具体讨论这两点，特别涉及比特币。
- en: The goal of Bitcoin is to ensure that a new block is mined in about 10 minutes,
    i.e. ![inline-image](../images/CH018_90.jpg). When *ν* increases, the value of
    *d* is decreased so that the ratio 2 ^([*n*]) /(*dν*) remains about 360\. Since,
    we are considering a P2P network, there is no central node which knows the total
    hash rate *ν* of the system. So, the adjustment of the parameter *d* cannot be
    done directly based on the knowledge of *ν*. An increase of the hash rate *ν*
    of the network will have the effect of new blocks being discovered faster. The
    block discovery time is part of the metadata of each block and is available from
    the blockchain. So, the nodes in the network are able to obtain the time that
    was required to discover each block in the blockchain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的目标是确保每个新区块的挖掘时间约为 10 分钟，即 ![inline-image](../images/CH018_90.jpg)。当 *ν*
    增加时，*d* 的值会减小，以使比例 2 ^([*n*]) /(*dν*) 保持约为 360。由于我们考虑的是一个 P2P 网络，没有中心节点知道系统的总哈希率
    *ν*。因此，无法根据 *ν* 的知识直接调整参数 *d*。网络哈希率 *ν* 的增加将导致新区块被更快地发现。区块发现时间是每个区块的元数据的一部分，并可从区块链获取。因此，网络中的节点能够获取发现每个区块所需的时间。
- en: At the creation rate of 10 minutes per block, in 2 weeks a total of 2,016 blocks
    can be mined. The Bitcoin protocol considers the mined blocks to be divided into
    windows of 2,016 blocks. The value of *d* is constant in each window of 2,016
    blocks, i.e. each such window is a constant difficulty period. At the end of a
    window of 2,016 blocks, the time to compute these blocks is considered. If this
    time is less than 2 weeks, then it indicates that the hash rate *ν* of the network
    has gone up, while if the time is more than 2 weeks, then the hash rate has gone
    down. The value of *d* is accordingly adjusted. We do not provide the exact details
    of this procedure, since that is not required for a conceptual understanding of
    the idea. It is sufficient to note that if less than 2 weeks' time was required,
    then the value of *d* is reduced while if more than 2 weeks' time was required,
    then the value of *d* is increased. In the next window of 2,016 blocks, the value
    of *d* remains constant. So far, the difficulty updation algorithm of Bitcoin
    has worked well to ensure that a new block is mined in about 10 minutes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个区块的创建速率为10分钟的情况下，2周内可以挖掘总共2,016个区块。比特币协议将这些挖掘出的区块分为2,016个区块的窗口。在每个这样的窗口中，*d*
    的值是恒定的，即每个窗口都是一个恒定的难度周期。在一个2,016个区块的窗口结束时，计算这些区块的时间被考虑在内。如果这个时间少于2周，那么说明网络的哈希率
    *ν* 上升了，而如果时间超过2周，那么哈希率下降了。*d* 的值会相应地进行调整。我们不提供此过程的详细细节，因为这对于理解这个概念并不需要。重要的是要注意，如果需要少于2周的时间，那么
    *d* 的值会减少，而如果需要超过2周的时间，*d* 的值会增加。在接下来的2,016个区块的窗口中，*d* 的值保持恒定。到目前为止，比特币的难度更新算法已经很好地确保了大约10分钟挖掘一个新区块。
- en: 18.9 Controlling the Rate of Money Creation
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.9 控制货币创建速率
- en: The other way to control inflation is to reduce the amount of new currency that
    is created with every mined block. This is done in a controlled fashion. For this
    purpose, the blocks in the blockchain are considered to be divided into windows
    of size 210,000 blocks. At the rate of about 10 mintues for mining a block, the
    time for mining 210,000 blocks is about 4 years. In each window of 210,000 blocks,
    the amount of Bitcoin created by the mining of a new block remains constant. At
    the end of 210,000 blocks, this amount is halved. In the first window of 210,000
    blocks, the mining of each new block created 50 Bitcoins. In the next window of
    210,000, the mining of each new block created 25 bitcoins. The Bitcoin protocol
    is designed so that there are 64 such halving events. After that, the mining of
    a new block will not create any new Bitcoin. At the rate of 10 minutes per block,
    this event is expected to occur sometime in the year 2140\. The total amount of
    Bitcoin that can be created is 21 million. When no more new Bitcoin can be created,
    the entire cost of mining will have to be borne by the transaction fees of the
    transactions to be included in a block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 控制通货膨胀的另一种方式是减少每个挖掘区块所创建的新货币数量。这是有计划地进行的。为此，将区块链中的区块视为大小为 210,000 个区块的窗口进行划分。以每
    10 分钟挖掘一个区块的速度计算，挖掘 210,000 个区块的时间约为 4 年。在每个 210,000 个区块的窗口中，通过挖掘新区块所创建的比特币数量保持恒定。在
    210,000 个区块结束时，此数量减半。在首个 210,000 个区块窗口中，每个新区块的挖掘都会创建 50 个比特币。在接下来的 210,000 个区块窗口中，每个新区块的挖掘都会创建
    25 个比特币。比特币协议的设计是在此过程中有 64 次减半事件。之后，挖掘新区块将不再创建任何新的比特币。以每个区块 10 分钟的速度计算，此事件预计将在
    2140 年的某个时候发生。可以创建的比特币总量为 21 百万枚。当无法再创建新的比特币时，挖矿的全部成本将由要包含在一个区块中的交易的交易费用承担。
- en: 18.10 Choosing between Competing Blocks
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.10 在竞争区块之间选择
- en: In Chapter 17, we have explained that each node in the P2P network maintains
    a private copy of the blockchain. Newly created blocks are propagated through
    the network using the gossip protocol. It is important to note that the time for
    a block to propagate through the entire network is insignificant in comparison
    to the time to create a new block.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 17 章中，我们已经解释了 P2P 网络中的每个节点都维护着区块链的私有副本。新创建的区块通过八卦协议在网络中传播。重要的是要注意，一个区块在整个网络中传播所需的时间与创建新区块的时间相比微不足道。
- en: Suppose a node *v* obtains a block. As mentioned earlier, it is possible for
    *v* to obtain two or more blocks almost simultaneously. The rules of the cryptocurrency
    system have to specify how node *v* will update its private copy of the blockchain.
    We explain this with reference to Bitcoin.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个节点 *v* 获取了一个区块。如前所述，*v* 几乎可以同时获取两个或更多个区块。加密货币系统的规则必须指定节点 *v* 如何更新其私有区块链副本。我们以比特币为例来解释这一点。
- en: The conflict resolution mechanism is based on difficulty. One simple rule is
    that if two blocks have the same difficulty, then *v* retains the block that it
    obtained earlier. Now suppose that *v* obtains two or more blocks such that there
    arises the possibility of two blockchains which are the same up to some point
    and then branch out. These two possible blockchains have two different values
    of difficulty. The updation rules of Bitcoin specify that node *v* will maintain
    the more difficult blockchain and discard the blockchain with lesser difficulty.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突解决机制基于难度。一个简单的规则是，如果两个块具有相同的难度，那么 *v* 会保留它更早获取的块。现在假设 *v* 获取了两个或更多块，从而出现了两个块链的可能性，这两个块链在某一点上相同然后分叉。这两个可能的区块链具有两个不同的难度值。比特币的更新规则规定节点
    *v* 将保留更难的区块链并且丢弃难度较低的区块链。
- en: Given that the blocks have the same difficulty, node *v* will retain the longer
    chain. It is, however, possible, that node *v* will retain the shorter chain if
    it is more difficult. Difficulty of a blockchain captures the amount of work that
    has been put in to create the blockchain. Thus, the rules specify that the chain
    which required higher amount of work for its creation is retained.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设块具有相同的难度，节点 *v* 将保留更长的链。然而，如果更短的链更难，节点 *v* 也可能保留更短的链。区块链的难度捕获了创建区块链所需的工作量。因此，规则规定保留需要更多工作来创建的链。
- en: 18.11 Confirmation of Transaction
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11 交易确认
- en: Transactions are issued by users. A transaction *T* enters the network through
    some node and is propagated to all the nodes. At some point, some node chooses
    the transaction for inclusion into a block *B*. Suppose that the node successfully
    mines the block. The block *B* is then propagated to the entire network. The node
    which originally propagated the transaction *T* also gets *B* and appends it to
    the head of its blockchain. At this point, the user which issued the transaction
    *T* may consider that the transaction has been confirmed by the network. However,
    as pointed out above, it is possible that the receipt or creation of another block
    ![inline-image](../images/CH018_91.jpg) results in the block *B* being removed
    from the blockchain. If this happens, then transaction *T* is no longer in the
    blockchain and the confirmation becomes invalid.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 交易由用户发出。一个交易 *T* 通过某个节点进入网络，并传播到所有节点。在某一时刻，某个节点选择将交易包含在一个块 *B* 中。假设该节点成功挖出了该块。块
    *B* 然后传播到整个网络。最初传播交易 *T* 的节点也会获得 *B* 并将其附加到其区块链的头部。此时，发出交易 *T* 的用户可能认为该交易已被网络确认。然而，如上所述，可能会收到或创建另一个区块
    ![inline-image](../images/CH018_91.jpg) 导致从区块链中删除块 *B*。如果发生这种情况，则交易 *T* 不再在区块链中，确认变得无效。
- en: In view of this problem, it is usually recommended that the user wait until
    the block *B* containing the transaction *T* is buried sufficiently deep in the
    blockchain. It is extremely unlikely that the blockchain will be modified to this
    depth. Bitcoin, for example, recommends waiting until block *B* is six blocks
    deep in the blockchain. Considering that a block is generated every 10 minutes,
    generating six blocks takes about an hour. So, the user has to wait for about
    an hour before considering that the transaction has been confirmed on the blockchain.
    This time does not consider the waiting time for a transaction to get into a block.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个问题，通常建议用户等待包含交易*T*的区块*B*在区块链中被充分深埋。区块链被修改到这种程度的可能性极小。例如，比特币建议等待区块*B*在区块链中深入六个区块。考虑到每10分钟生成一个区块，生成六个区块大约需要一个小时。因此，用户必须等待大约一个小时，然后才能确认交易已在区块链上确认。这段时间不考虑交易进入区块的等待时间。
- en: 18.12 No Double Spending
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.12 不允许双重支付
- en: A basic requirement for any currency is that it should not be possible to spend
    the same currency twice. Double spending refers to the situation where the owner
    of a currency is able to spend the same currency twice. Let us consider how such
    a situation may arise in a cryptocurrency and why this should not be possible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 货币的一个基本要求是不应该有可能两次花费相同的货币。双重支付是指货币所有者能够两次花费相同货币的情况。让我们考虑一下在加密货币中可能出现这种情况的原因以及为什么这种情况不应该发生。
- en: Suppose a user *U* makes a payment of a certain amount of cryptocurrency as
    part of a transaction *T*. This user controls a node of the P2P network and introduces
    *T* to the network through this node. At some point of time, the transaction *T*
    is included into a mined block *B* and becomes part of the blockchain. Further,
    suppose that *B* gets embedded sufficiently deep in the blockchain so that the
    transaction *T* is considered to be confirmed. At this point, the user *U* receives
    the goods or services in lieu of the payment made via *T*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户*U*作为交易*T*的一部分支付了一定数量的加密货币。该用户控制P2P网络的一个节点，并通过该节点将*T*引入网络。在某个时间点，交易*T*被包含在一个已挖掘的区块*B*中，并成为区块链的一部分。进一步假设*B*被嵌入到区块链中足够深，以至于交易*T*被认为已确认。此时，用户*U*收到了*通过*T*进行的支付所得到的商品或服务。
- en: The payment made by *U* in transaction *T* is from a spender public key ![inline-image](../images/CH018_92.jpg)
    for which the corresponding signing key ![inline-image](../images/CH018_93.jpg)
    is known to *U*. Supppose that ![inline-image](../images/CH018_94.jpg) initially
    had *x* units of the cryptocurrency. After the transaction *T*, ![inline-image](../images/CH018_95.jpg)
    will no longer have any cryptocurrency associated with it. Once *T* gets confirmed,
    the public ledger records that there is no more currency associated with ![inline-image](../images/CH018_96.jpg).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* 在交易 *T* 中所做的支付来自一个花费者的公钥 ![inline-image](../images/CH018_92.jpg)，其对应的签名密钥
    ![inline-image](../images/CH018_93.jpg) 为 *U* 所知。假设 ![inline-image](../images/CH018_94.jpg)
    最初拥有 *x* 个单位的加密货币。在交易 *T* 之后，![inline-image](../images/CH018_95.jpg) 将不再与任何加密货币相关联。一旦
    *T* 得到确认，公共账本记录了与 ![inline-image](../images/CH018_96.jpg) 不再相关联任何货币。'
- en: Now consider that *U* wishes to spend the currency associated with ![inline-image](../images/CH018_97.jpg)
    again. The public ledger records that the entire amount associated with ![inline-image](../images/CH018_98.jpg)
    has been spent as part of transaction *T*. So, by checking the public ledger,
    anybody can verify that subsequent to transaction *T*, there is no longer any
    amount associated with ![inline-image](../images/CH018_99.jpg). So, while transaction
    *T* is on the public ledger, it is not possible for *U* to again spend the amount
    associated with ![inline-image](../images/CH018_100.jpg). Consequently, *U* may
    try to modify the public ledger so as to remove *T* from it. The transaction *T*
    is a part of the block *B*. So, *T* can be removed only by removing block *B*.
    Suppose *U* performs a new transaction ![inline-image](../images/CH018_101.jpg)
    which spends the amount associated with ![inline-image](../images/CH018_102.jpg)
    but the recipient public keys are different from those in *T*. *U* then replaces
    *T* in *B* with ![inline-image](../images/CH018_103.jpg) to create a possible
    block ![inline-image](../images/CH018_104.jpg). The creation of the block ![inline-image](../images/CH018_105.jpg)
    will require *U* to mine it, i.e. *U* will have to obtain a suitable value of
    ![inline-image](../images/CH018_106.jpg).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 *U* 希望再次花费与 ![inline-image](../images/CH018_97.jpg) 相关的货币。公共账本记录了与 ![inline-image](../images/CH018_98.jpg)
    相关的整个金额已作为交易 *T* 的一部分花费。因此，通过检查公共账本，任何人都可以验证在交易 *T* 之后，与 ![inline-image](../images/CH018_99.jpg)
    不再相关联任何金额。因此，当交易 *T* 在公共账本上时，*U* 不可能再次花费与 ![inline-image](../images/CH018_100.jpg)
    相关联的金额。因此，*U* 可能会试图修改公共账本以删除其中的 *T*。交易 *T* 是区块 *B* 的一部分。因此，只能通过删除区块 *B* 来删除交易
    *T*。假设 *U* 执行了一笔新交易 ![inline-image](../images/CH018_101.jpg)，其中花费了与 ![inline-image](../images/CH018_102.jpg)
    相关联的金额，但接收方的公钥与 *T* 中的不同。然后，*U* 将 *B* 中的 *T* 替换为 ![inline-image](../images/CH018_103.jpg)
    以创建可能的区块 ![inline-image](../images/CH018_104.jpg)。创建区块 ![inline-image](../images/CH018_105.jpg)
    将需要 *U* 进行挖矿，即 *U* 必须获得合适的 ![inline-image](../images/CH018_106.jpg) 的值。
- en: At the time when *U* received the benefits of his original payment in the transaction
    *T*, the block *B* had already been embedded sufficiently deep in the blockchain.
    So, if *U* tries to modify the blockchain by replacing *B* with ![inline-image](../images/CH018_107.jpg),
    *U* will be required not only to mine the block ![inline-image](../images/CH018_108.jpg)
    but also the blocks subsequent to *B* in the blockchain. Suppose *B* had been
    embedded *t* blocks deep in the blockchain. Then *U* will be required to mine
    *t* blocks and propagate the new blocks to the network. Further, *U* will have
    to ensure that its propagation of the modified blockchain is accepted by the network.
    For this, it is required to mine these *t* blocks *before* some other node mines
    a new header for the original blockchain. Since, otherwise, *U*'s propagation
    of the modified blockchain will be rejected by the nodes in the network.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当*U*在交易*T*中收到原始支付的好处时，区块*B*已经足够深地嵌入到区块链中。因此，如果*U*试图通过用![inline-image](../images/CH018_107.jpg)替换*B*来修改区块链，*U*不仅需要挖掘出来![inline-image](../images/CH018_108.jpg)这个区块，还需要挖掘出区块链中*B*之后的区块。假设*B*在区块链中嵌入的深度为*t*个区块。那么*U*需要挖掘*t*个区块并将新的区块传播到网络中。此外，*U*还必须确保其修改后的区块链传播被网络接受。为此，*U*需要在某个其他节点为原始区块链挖掘新的头块*之前*挖掘这*t*个区块。否则，*U*修改后的区块链传播将被网络中的节点拒绝。
- en: Thus, to double spend (i.e. to spend the currency associated with ![inline-image](../images/CH018_109.jpg)
    twice), *U* will be required to have substantially more computational power than
    the combined computational power of all the other nodes in the network. As long
    as such a condition does not occur, it is not possible to double spend.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要进行双花（即将与![inline-image](../images/CH018_109.jpg)相关的货币花费两次），*U*需要拥有远远超过网络中所有其他节点的综合计算能力。只要不出现这种情况，就不可能进行双花。
- en: 18.13 The 51% Attack
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.13 51%攻击
- en: A cryptocurrency system can be said to have been defeated if it becomes possible
    to spend the same amount of currency twice. This can be seen as an attack on the
    cryptocurrency system and is called a double spending attack.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密货币系统变得可以花费相同金额的货币两次，那么可以说该加密货币系统已经被打败。这可以看作是对加密货币系统的攻击，称为双重支付攻击。
- en: The computational power of a node *v* is measured by its hash rate *ν* *v* .
    Suppose that the node *v* acquires computational power such that *ν* *v* > *ν*/2,
    where ![inline-image](../images/CH018_110.jpg) is the total hash rate of the network.
    In other words, the hash rate of *v* is more than half of the network hash rate.
    As a result, *v* has more than 50% probability of mining each new block. This
    provides *v* with a high degree of control over the blocks that are mined and
    also increases its chances of launching a double spending attack on the network.
    Such a scenario is called the 51% attack.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 *v* 的计算能力由其哈希率 *ν* *v* 衡量。假设节点 *v* 获得了计算能力，使得 *ν* *v* > *ν*/2，其中 ![inline-image](../images/CH018_110.jpg)
    是网络的总哈希率。换句话说，节点 *v* 的哈希率超过了网络哈希率的一半。因此，*v* 有超过 50% 的概率挖掘每个新区块。这使得 *v* 对挖掘的区块具有高度控制权，并增加了发动网络双花攻击的机会。这种情况被称为
    51% 攻击。
- en: A double spending attack on the network may lead to a serious loss of credibility
    of the cryptocurrency and bring down its value. The lowering of value of the cryptocurrency
    will also affect the gains of the adversary who would have invested heavily in
    acquiring the computational power to ensure more than half of the hash rate of
    the network. It has been argued that this provides a natural de-motivating factor
    for an adversary to launch a double spending attack. However, double spending
    attacks have indeed been reported on several cryptocurrencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对网络的双花攻击可能导致加密货币的信誉严重受损，并降低其价值。加密货币价值的降低也会影响投资大量获取计算能力以确保网络哈希率超过一半的对手的收益。有人认为这为对手发动双花攻击提供了自然的打击因素。然而，确实有报道称多种加密货币遭受了双花攻击。
- en: Chapter 19
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 19 章
- en: 'Cryptocurrency: Further Issues'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币：进一步的问题
- en: In the previous chapter, we have seen some of the basic concepts of cryptocurrency.
    The present chapter looks at a number of issues which arise when a cryptocurrency
    is adopted in the real world.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一些加密货币的基本概念。本章将探讨当加密货币在现实世界中被采用时会出现的一些问题。
- en: 19.1 Mining Pools
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1 挖矿池
- en: The nodes in the P2P network compete with each other to mine new blocks. This
    competition is inherently non-cooperative, i.e. the nodes do not cooperate among
    themselves for the task of block mining.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: P2P 网络中的节点彼此竞争挖掘新区块。这种竞争本质上是非合作的，即节点之间不协作进行区块挖掘任务。
- en: Mining of a block is a computation-intensive task. For Bitcoin, a substantial
    amount of computational power is required to ensure a significant probability
    of success in mining a block. An individual entity with limited computational
    power may not be able to successfully mine a block within a reasonable amount
    of time. This is the motivation for a group of entities to pool together their
    computational resources towards the goal of block mining. The pool as a whole
    acquires sufficient computational capability to ensure that a block is mined within
    a reasonable time. When a block is mined, the block reward is distributed among
    the members of the pool according to some formula based on the shares of the work
    done by each of the entities. The goal for an entity is that joining a pool ensures
    a steady flow of income rather than waiting for a few years before being able
    to successfully mine a block on its own.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 区块的挖掘是一个计算密集型任务。对于比特币来说，需要大量的计算能力才能确保在挖掘一个区块时有很大的成功概率。具有有限计算能力的个体实体可能无法在合理的时间内成功挖掘一个区块。这就是一群实体共同汇集他们的计算资源朝着挖掘区块的目标努力的动机。整个矿池获得了足够的计算能力，以确保在合理的时间内挖掘一个区块。当一个区块被挖掘时，根据每个实体所做工作的份额，区块奖励按照某个公式分配给了矿池成员。对一个实体来说，加入一个矿池确保了稳定的收入流而不是等待几年才能自己成功挖掘一个区块。
- en: A mining pool represents a cooperative process. The method of sharing the block
    reward among the members of the pool provides the incentive mechanism. There are
    several such incentive mechanisms which are used in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 矿池代表了一种合作过程。在矿池成员之间分配区块奖励的方法提供了激励机制。实践中有几种这样的激励机制。
- en: While the overall task of block mining is non-cooperative, entities with low
    computational powers can cooperate among themselves to create mining pools. Thus,
    the activity of block mining shows both non-cooperative and cooperative characteristics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整个区块挖掘任务是非合作的，但是计算能力较低的实体可以相互合作以创建矿池。因此，区块挖掘活动同时展现了非合作和合作的特性。
- en: 19.2 Change of Rules
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2 变更规则
- en: It has been mentioned several times that a cryptocurrency system (or protocol)
    operates under certain rules. These rules are implemented by the software which
    the nodes in the P2P network run. The basis for the operation of a cryptocurrency
    system is consensus. The rules which regulate the cryptocurrency operations are
    accepted by all the nodes. A set of rules is initially written and implemented
    in the software for the cryptocurrency system. Entities which would like to join
    the system, download the software and run them on computers and thus become nodes
    in the network. Entities can also have their own version of the software for possibly
    improving efficiency. Any such software will have to implement the same set of
    rules.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提到了多次，加密货币系统（或协议）是根据某些规则运作的。这些规则由 P2P 网络中的节点运行的软件实现。加密货币系统运作的基础是共识。规范加密货币运作的规则被所有节点接受。一组规则最初被写入并在加密货币系统的软件中实现。希望加入系统的实体下载该软件并在计算机上运行，从而成为网络中的节点。实体还可以拥有自己的软件版本，可能会提高效率。任何此类软件都必须实现相同的一组规则。
- en: As the system evolves with more and more nodes joining and transactions taking
    place, it may become necessary to change some of the rules. Consensus will also
    be required for such a change of rules. Cryptocurrency systems usually have in
    place some kind of mechanism for proposing and accepting a change of rule. We
    explain this issue in more detail with reference to Bitcoin.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的节点加入系统并进行交易，系统可能需要更改一些规则。这样的规则更改也需要共识。加密货币系统通常会有某种机制来提出和接受规则的更改。我们将更详细地解释这个问题，参考比特币。
- en: A proposal for a change of rules in Bitcoin is called a Bitcoin Improvement
    Protocol (BIP). A BIP is initially proposed by a handful of developers. One month
    after a BIP is defined it moves into a phase called the *started* phase. At this
    stage, support to the BIP has to be indicated by the participants in the network.
    The metadata for all blocks contain a provision for indicating support to a proposed
    BIP. This is in the form of a bit. The miner which mines the block, sets the bit
    to 1 if it supports the associated BIP, otherwise it is set to 0\. Several BIPs
    may be simultaneously under consideration. For each such BIP, a miner indicates
    its support or lack of it by setting the associated bit in the metadata of the
    newly mined block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对比特币规则的更改提出的建议称为比特币改进提案（BIP）。BIP 最初由少数开发人员提出。在定义了 BIP 一个月后，它进入了一个称为*启动*阶段的阶段。在此阶段，网络中的参与者必须表示对
    BIP 的支持。所有区块的元数据都包含了表示对拟议 BIP 的支持的条款。这是以位的形式表示的。挖掘区块的矿工，如果支持相关的 BIP，则将位设置为 1，否则将设置为
    0。可以同时考虑多个 BIP。对于每个这样的 BIP，矿工通过在新挖掘的区块的元数据中设置相关位来表示其支持或缺乏支持。
- en: A constant difficulty period is a window of 2,016 blocks during which the difficulty
    of block mining remains the same. Since mining a block takes about 10 minutes,
    a constant difficulty period lasts for about 2 weeks. In a year, there are about
    26 such constant difficulty periods. If in any such constant difficulty period,
    a BIP obtains support above a certain threshold number of blocks, then in the
    next difficulty period, all entities who wish to adopt the new rules can do so.
    The required threshold is 1,916 blocks (which is roughly 95% of 2016, the number
    of blocks mined in a 2-week period). Once the desired level of support is obtained
    for a BIP, it gets activated. After that, transactions and blocks following the
    new rules are accepted by the nodes in the network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 恒定难度周期是一个窗口，其中包含 2,016 个区块，在此期间区块挖掘的难度保持不变。由于挖掘一个区块大约需要 10 分钟，一个恒定难度周期大约持续 2
    周。一年中大约有 26 个这样的恒定难度周期。如果在任何这样的恒定难度周期中，某个 BIP 获得了超过一定阈值数量的区块的支持，那么在下一个难度周期中，所有希望采纳新规则的实体都可以这样做。所需的阈值为
    1,916 个区块（大约为 2016 的 95%，即 2 周内挖掘的区块数）。一旦某个 BIP 获得了期望的支持水平，它就会被激活。之后，网络中的节点将接受遵循新规则的交易和区块。
- en: A BIP is said to time-out or fail if it is not activated within 1 year of it
    being started. At that point, it is no longer considered for voting by the setting
    of bits in the newly mined blocks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个 BIP 在启动后的 1 年内没有被激活，则被认为是超时或失败。在那时，它不再被新挖掘的区块中的位设置为投票考虑。
- en: 19.3 Forks
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3 分叉
- en: We have mentioned how forking may arise when a node receives new blocks which
    require modifying its copy of the blockchain. This kind of forking is localised
    at the node itself. To handle such a fork, the node discards blocks from its blockchain
    and adopts the new blocks so as to be consistent with the other nodes. So, this
    kind of forking is transient, and the individual node of the system soon gets
    in synchronisation with the consensus public blockchain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，当节点接收到需要修改其区块链副本的新区块时，分叉可能会发生。这种分叉在节点本身是局部化的。为了处理这样的分叉，节点会丢弃其区块链中的区块，并采用新区块，以便与其他节点保持一致。因此，这种分叉是暂时的，系统中的个体节点很快就会与共识公共区块链同步。
- en: Forking of a blockchain can be more serious. Transactions and blocks have to
    follow the consensus rules. If the rules change and some of the nodes choose to
    follow the new rules, but the other nodes adhere to the old rules, then forking
    occurs. Such a forking leads to two distinct blockchains. The two blockchains
    have a common history, i.e. they have the same blocks up to a certain point and
    after that there is a bifurcation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的分叉可能更为严重。交易和区块必须遵循共识规则。如果规则发生变化，一些节点选择遵循新规则，而其他节点坚持旧规则，那么就会发生分叉。这样的分叉导致两个不同的区块链。这两个区块链有一个共同的历史，即它们在某一点之前有相同的区块，之后就会有一个分叉。
- en: There are two types of forks, namely soft and hard forks. Suppose a rule change
    is such that the blocks following the new rule are compatible with the older rules,
    then the nodes which choose to follow the older rules will continue incorporating
    such blocks into their blockchain. On the other hand, blocks generated by the
    old rules may not be acceptable to the nodes which follow the new rules. This
    leads to a fork. Such a fork is called a soft fork. A hard fork occurs when blocks
    which follow the new rules are incompatible with the old rules and are rejected
    by the nodes which follow the old rules. In view of this, a soft fork is said
    to be backward compatible while a hard fork is not.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的分叉，即软分叉和硬分叉。假设规则更改使得遵循新规则的区块与旧规则兼容，那么选择遵循旧规则的节点将继续将这些区块纳入其区块链中。另一方面，遵循旧规则的节点可能不接受使用新规则生成的区块。这导致了一次分叉。这样的分叉称为软分叉。硬分叉发生在遵循新规则的区块与旧规则不兼容且被遵循旧规则的节点拒绝的情况下。基于此，软分叉被称为向后兼容，而硬分叉则不是。
- en: To consider common examples of soft and hard forks, suppose initially there
    is no limit on the number of transactions that can be included in a block. A later
    rule change imposes a size limit of a block. Then blocks following the new rule
    are compatible with the old rule and will be accepted by the nodes following the
    old rule. On the other hand, blocks generated using the old rule may be larger
    than the new size limit. Such blocks will be rejected by the nodes following the
    new rule. This leads to a soft fork. Now suppose that a further rule change takes
    place which increases the size limit of a block. Then a block following the new
    rule may be of size greater than that mandated by the old rules. Such a block
    will be rejected by the nodes which follow the old rules. This leads to a hard
    fork.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑软分叉和硬分叉的常见例子，假设最初没有限制可以包含在一个区块中的交易数量。后来的规则更改设置了一个区块的大小限制。那么遵循新规则的区块与旧规则兼容，并将被遵循旧规则的节点接受。另一方面，使用旧规则生成的区块可能大于新的大小限制。这样的区块将被遵循新规则的节点拒绝。这导致了一次软分叉。现在假设发生了进一步的规则更改，增加了一个区块的大小限制。那么遵循新规则的区块可能大于旧规则规定的大小。这样的区块将被遵循旧规则的节点拒绝。这导致了一次硬分叉。
- en: While the above example is provided at several places, the two situations considered
    in the examples are not really that different. In the case of soft fork, generated
    blocks which follow either the old or the new rules will be accepted by the nodes
    which follow the old rules, while generated blocks which follow the new rules
    will be accepted only by the nodes which follow the new rules. On the other hand,
    in the case of hard fork, generated blocks which follow either the old or the
    new rules will be accepted by the nodes which follow the new rules, while generated
    blocks which follow the old rules will be accepted only by the nodes which follow
    the old rules. As such there is no essential difference between these two types
    of forks. One set of nodes accept blocks which follow either of the two rules,
    while another set of nodes accept blocks which follow only one set of rules. The
    blockchain of the nodes which follow either of the two rules will grow faster
    than the blockchain of the nodes which follow one set of rules.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上面的例子在几个地方提到，但是这些例子中考虑的两种情况实际上并没有那么不同。在软分叉的情况下，遵循旧规则或新规则的生成的区块将被遵循旧规则的节点接受，而遵循新规则的生成的区块只会被遵循新规则的节点接受。另一方面，在硬分叉的情况下，遵循旧规则或新规则的生成的区块将被遵循新规则的节点接受，而遵循旧规则的生成的区块只会被遵循旧规则的节点接受。因此，这两种分叉类型之间没有实质性的区别。一组节点接受遵循两种规则之一的区块，而另一组节点只接受遵循一组规则的区块。遵循两种规则之一的节点的区块链将比只遵循一组规则的节点的区块链增长得更快。
- en: In a hard fork, blocks following the new rules are incompatible with the old
    rules. This does not say anything about whether blocks following the old rules
    are compatible with the new rules. It is possible that they are compatible as
    in the example of hard fork described above. On the other hand, it is also possible
    that the blocks following the old rule are incompatible with the new rules. This
    latter scenario means that blocks generated by one set of rules are incompatible
    with the other set of rules. Such a fork is irreconcilable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬分叉中，遵循新规则的区块与旧规则不兼容。这并不意味着遵循旧规则的区块是否与新规则兼容。就像上面描述的硬分叉示例一样，它们可能是兼容的。另一方面，遵循旧规则的区块也可能与新规则不兼容。后一种情况意味着由一组规则生成的区块与另一组规则不兼容。这样的分叉是不可调和的。
- en: Either a soft or a hard fork can be resolved by all the nodes adopting the new
    set of rules. The sooner this happens, the better it is for the cryptocurrency.
    If, however, one set of nodes continues to follow the old rules while the other
    nodes follow the new rules, then this leads to a split in the network and the
    blockchain. Such an eventuality can cause major disruption and lead to a cryptocurrency
    itself being bifurcated into two distinct currencies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点采用新的规则可以解决软分叉或硬分叉。这种情况发生得越早，对加密货币越好。然而，如果一组节点继续遵循旧规则，而其他节点遵循新规则，那么这将导致网络和区块链的分裂。这种情况可能会造成重大破坏，并导致加密货币本身被分裂为两种不同的货币。
- en: If a fork results in the creation of two distinct cryptocurrencies, a peculiar
    situation may arise. The two cryptocurrencies will be supported by two blockchains.
    The two blockchains, however, will be the same up to a certain point and will
    bifurcate after that. Suppose an amount of cryptocurrency was transferred to a
    public key *pk* *U* in a transaction *T* which is present in the common part of
    the two blockchains. The transaction *T* will be considered to be valid in all
    subsequent blocks. In particular, *T* will be considered to be valid by both the
    blockchains. As a result, the entity which possesses the corresponding signing
    key *sk* *U* can now spend the amount on the two parts after the forking has taken
    place. This essentially constitutes spending the same amount on both the blockchains.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一次分叉导致创建了两种不同的加密货币，可能会出现一种奇特的情况。这两种加密货币将由两个区块链支持。然而，两个区块链在某一点上是相同的，并在此之后分叉。假设加密货币的一笔交易*T*将一定金额转移到一个公钥*pk*
    *U*，该交易*T*存在于两个区块链的公共部分。交易*T*将被视为在所有后续区块中有效。特别是，*T*将被两个区块链视为有效。因此，拥有相应签名密钥*sk*
    *U*的实体现在可以在分叉发生后在两个部分上花费该金额。这本质上是在两个区块链上花费相同的金额。
- en: 19.4 Value of a Cryptocurrency
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4 加密货币的价值
- en: Unlike fiat currencies, a cryptocurrency is not backed by any sovereign power.
    A cryptocurrency system becomes functional when a software implementing the system
    is made available to the public. This, by itself, is not sufficient to guarantee
    that the cryptocurrency will be adopted. As more and more computers become nodes
    on the P2P network by downloading and running the software, the acceptance of
    the cryptocurrency grows. Conversely, nodes join the P2P network if there is some
    value in doing so and this value arises from a broad acceptability of the cryptocurrency.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与法定货币不同，加密货币不受任何主权力量支持。当一个实现该系统的软件向公众提供时，加密货币系统才变得可用。但仅凭这一点并不足以保证加密货币会被采用。随着越来越多的计算机通过下载和运行软件成为P2P网络上的节点，加密货币的接受度增加。相反，如果存在加入P2P网络的价值，节点将加入该网络，而这个价值来自于加密货币的广泛可接受性。
- en: A currency is used to pay for receiving some goods or services. Fundamentally,
    for a cryptocurrency to be used, there must be a set of entities who trust the
    system and are willing to accept payment in the currency for providing goods and
    services. As the size of such a set of entities grows, so does the acceptability
    of the cryptocurrency. Within a cryptocurrency system, the price of any particular
    goods and services in the cryptocurrency is determined by the market, just as
    in any other currency. Controlling the rate at which new amounts of the cryptocurrency
    is created (through block mining) provides a way to control inflationary pressure
    on the market.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一种货币用于支付获取某些商品或服务。基本上，为了使用加密货币，必须有一组信任系统并愿意接受该货币支付提供商品和服务的实体。随着这样一组实体的规模增长，加密货币的可接受性也会增加。在加密货币系统中，任何特定商品和服务的价格由市场决定，就像其他任何货币一样。通过控制创建新加密货币数量的速率（通过区块挖掘），可以控制市场上的通货膨胀压力。
- en: Within the ambit of the cryptocurrency system, the relative values of different
    goods and services are determined by their availability and the demand for them
    among the holders of the cryptocurrency. As such, there is no intrinsic value
    of one unit of the cryptocurrency.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密货币系统的范围内，不同商品和服务的相对价值取决于它们的可用性以及持有者之间对它们的需求。因此，一个单位加密货币没有内在价值。
- en: 19.5 Cryptocurrency Exchange
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5 加密货币交换
- en: Suppose an entity receives payment using a cryptocurrency in return for providing
    some goods and services. This amount of cryptocurrency can be used for further
    payments of other goods and services. It is possible that an entity possessing
    a certain amount of cryptocurrency wishes to purchase some goods or service which
    is not available from entities who are willing to accept payment using the cryptocurrency.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个实体以加密货币的形式收到支付，以换取提供某些商品和服务。这笔加密货币的数量可以用于进一步支付其他商品和服务。可能某个持有一定数量加密货币的实体希望购买某些无法从愿意接受加密货币支付的实体处获得的商品或服务。
- en: To take another example, we have mentioned that the process of mining requires
    investment to increase computational power. This investment will typically be
    in terms of some fiat currency. The block reward for successful mining of a block
    is available in terms of the cryptocurrency. The miner needs to determine its
    net profit (or, loss) which is the difference between the return on block rewards
    and the investment. Unless both these quantities can be expressed in the same
    base, the difference cannot be computed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们提到挖掘过程需要投资以增加计算能力。这种投资通常以某种法定货币来衡量。成功挖掘一个区块的区块奖励以加密货币的形式提供。矿工需要确定其净利润（或者说，亏损），即区块奖励与投资回报之间的差额。除非这两个量可以用相同的基准来表达，否则无法计算出差额。
- en: Scenarios such as the above have motivated the emergence of cryptocurrency exchanges
    such as Coinbase or Kraken. A particular exchange may accept a few cryptocurrencies.
    On such an exchange it is possible to sell the accepted cryptocurrency and receive
    fiat currency in return. These exchanges also provide the facility for buying
    cryptocurrency. So, one may sell fiat currency and obtain cryptocurrency in return.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情景促使了加密货币交易所如Coinbase或Kraken的出现。特定交易所可能接受几种加密货币。在这样的交易所上，可以出售被接受的加密货币，并获得法定货币作为回报。这些交易所还提供购买加密货币的功能。因此，可以出售法定货币并以加密货币作为回报。
- en: Suppose an entity holds a certain amount of cryptocurrency against a public
    key *pk* for which it possesses the corresponding signing key *sk*. Selling the
    cryptocurrency amounts to issuing a transaction where the spender public key is
    *pk* and the recipient public key is *pk*′ for which the receiving entity possesses
    the corresponding signing key *sk*′. Once this transaction is confirmed on the
    blockchain, the receiving entity transfers the agreed upon amount of the fiat
    currency to the seller of the cryptocurrency. Buying an amount of cryptocurrency
    in exchange for fiat currency is similar. Many major cities across the world have
    Bitcoin ATMs, which pay cash against Bitcoins. Some of these ATMs also accept
    other cryptocurrencies such as Litecoin and Ethereum. Further, there are also
    cryptocurrency debit cards like Monaco, Bitpay, CoinJar, and BCCPay.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个实体持有一定数量的加密货币，对应公钥为*pk*，并拥有相应的签名密钥*sk*。出售加密货币相当于发出一笔交易，其中支出者的公钥是*pk*，接收者的公钥是*pk*′，接收实体拥有相应的签名密钥*sk*′。一旦这笔交易在区块链上确认，接收实体就会将约定的金额的法定货币转给加密货币的卖家。以法定货币换取一定数量的加密货币类似。世界各地许多主要城市都设有比特币自动取款机，可以用现金兑换比特币。其中一些自动取款机还接受其他加密货币，如莱特币和以太坊。此外，还有像Monaco、Bitpay、CoinJar和BCCPay等加密货币借记卡。
- en: One of the original purposes of cryptocurrency exchanges was to facilitate the
    conversion of cryptocurreny to and from fiat currencies. Presently, however, cryptocurrency
    exchanges have developed beyond this original goal. They are gradually developing
    functionalities similar to that of regular stock exchanges. In a stock exchange,
    traders buy and sell assets or their derivatives, making profit from the price
    fluctuations of the items that are traded. Some cryptocurrency exchanges provide
    the opportunity to trade pairs. Such a pair could consist of a cryptocurrency
    and a fiat currency, or it could consist of two different cryptocurrencies. Profit
    or loss is made by the trader depending upon how the prices of the two currencies
    in a pair change relative to each other.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币交易所最初的目的之一是促进加密货币与法定货币之间的兑换。然而，目前，加密货币交易所已经超越了这一最初的目标。它们正在逐渐发展出类似于常规股票交易所的功能。在股票交易所，交易员买卖资产或其衍生品，从交易的物品价格波动中获利。一些加密货币交易所提供了交易对的机会。这样的交易对可能由加密货币和法定货币组成，也可能由两种不同的加密货币组成。交易员的利润或亏损取决于交易对中两种货币的价格相对变化。
- en: 19.6 Cryptocurrency Community
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.6 加密货币社区
- en: A cryptocurrency community consists of all entities who participate in the activities
    related to the functioning of the cryptocurrency. At the lowermost level are the
    users who use the cryptocurrency for payments and also themselves make payments
    using the cryptocurrency. Miners are entities who are involved in the task of
    mining of blocks resulting in the creation of new amounts of the cryptocurrency.
    As discussed earlier, mining pools can be formed by entities to combine the computational
    resource required to mine a block. Finally, there are the cryptocurrency exchanges.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币社区包括参与与加密货币运作相关活动的所有实体。在最底层的是使用加密货币进行支付的用户，他们也使用加密货币自己进行支付。矿工是参与挖掘区块任务的实体，从而创造出新的加密货币数量。正如前面讨论的，实体可以组成矿池，以结合挖掘区块所需的计算资源。最后，还有加密货币交易所。
- en: All the entities in a cryptocurrency community are bound by the rules governing
    the currency. These rules are not enforced by any central agency. Rather, the
    force of the rules arise from their being accepted by all the entities in the
    system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币社区中的所有实体都受到规则的约束。这些规则不是由任何中央机构强制执行的。相反，规则的力量来自于所有系统实体的接受。
- en: 19.7 Stablecoin
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7 稳定币
- en: The exchange rate of a cryptocurrency can vary quite a lot. This is possibly
    due to speculative pressure. A wide variation in the exchange rate can deter people
    from adopting and using a crytocurrency. Several ideas and projects have been
    introduced to tackle this problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币的汇率可能会有很大变化。这可能是由于投机压力造成的。汇率的大幅变化可能会阻止人们采用和使用加密货币。已经提出了几种想法和项目来解决这个问题。
- en: At a basic level, the idea of stabilising the price of a cryptocurrency is to
    peg it to another asset. This later asset can be a fiat currency or some exchange-traded
    commodity, or it could even be another cryptocurrency. A cryptocurrency which
    has been designed to withstand high price volatility is called a stablecoin. A
    stablecoin could be either centralised or decentralised.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本水平上，稳定加密货币价格的想法是将其与另一种资产挂钩。这种后续资产可以是法定货币或某种交易所交易的商品，甚至可以是另一种加密货币。一种被设计成能够承受高价格波动的加密货币被称为稳定币。稳定币可以是中心化的，也可以是去中心化的。
- en: In a centralised stablecoin, a trusted third party backs the cryptocurrency
    by performing the peg. The peg itself could be to a fiat currency which is maintained
    in some bank or in some kind of regulated financial institution which can serve
    as a depositary of the fiat currency used to peg the stablecoin. Alternatively,
    the peg could be to some exchange-traded commodity such as precious metals. The
    amount of the back-up currency or commodity used for the peg has to reflect the
    actual amount of the stablecoin in circulation. Since the value of the peg varies
    outside the space of the stablecoin, it protects the stablecoin from wild price
    fluctuations. Variation in the price of the underlying asset, however, will have
    an effect on the price of the stablecoin. Nonetheless, due to arbitrage, it is
    unlikely that the price of a stablecoin will drop below the price of the asset
    used for the peg. The main criticism of centralised stablecoin is the use of the
    trusted party which goes against the basic ethos of cryptocurrency.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在中心化稳定币中，一个受信任的第三方通过执行挂钩来支持加密货币。挂钩本身可以是对某种法定货币，该货币保留在某些银行或某种受监管的金融机构中，后者可以充当用于挂钩稳定币的法定货币的存款人。另外，挂钩也可以是对一些交易所交易的商品，比如贵金属。用于挂钩的备份货币或商品的数量必须反映出流通中的稳定币的实际数量。由于挂钩的价值在稳定币的空间之外变动，因此它可以保护稳定币免受狂野的价格波动影响。然而，基础资产价格的变动将影响稳定币的价格。尽管如此，由于套利的存在，稳定币的价格不太可能低于用于挂钩的资产的价格。对中心化稳定币的主要批评是使用了违反加密货币基本精神的可信方。
- en: A decentralised stablecoin is pegged to another cryptocurrency. The mechanism
    is enforced through smart contracts on the blockchain itself. Since it is decentralised,
    there is no single centralised trusted party. For one thing, a decentralised stablecoin
    is more complicated to implement. Also, the variation in the prices of different
    crytocurrencies are usually correlated, so a stablecoin pegged to another cryptocurrency
    may not be sufficiently immune to wide price fluctuations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化稳定币是与另一种加密货币挂钩的。这种机制是通过区块链上的智能合约强制执行的。由于它是去中心化的，所以没有单一的中心化可信方。首先，去中心化稳定币的实施更加复杂。此外，不同加密货币价格的变动通常是相关的，因此与另一种加密货币挂钩的稳定币可能不足以免受广泛价格波动的影响。
- en: There are other more complicated variants of stablecoin which we do not include
    in this brief description.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此处不包括本简要描述中的其他更复杂的稳定币变体。
- en: 19.8 Criticisms of Cryptocurrencies
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8 加密货币的批评
- en: Cryptocurrencies are a new and potentially disruptive technology. The rapid
    growth of Bitcoin and other cryptocurrencies have also brought in a fair share
    of criticism. The main arguments against cryptocurrencies are summarised below.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币是一项新的、潜在具有颠覆性的技术。比特币和其他加密货币的快速增长也引来了相当多的批评。以下是针对加密货币的主要批评观点。
- en: '**Use in illegal transactions:** Cryptocurrencies bypass national boundaries
    and regulations. This makes them useful for making payments which are outside
    the scope of legal frameworks of nations. One such application would be payment
    for contraband substances. There are reports that such usage of Bitcoin has indeed
    been made.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于非法交易：** 加密货币绕过了国家边界和法规。这使它们成为进行超出国家法律框架范围的支付的工具。其中一种应用是支付非法物质。有报道称，确实已经有人利用比特币进行了此类用途。'
- en: '**High electricity consumption:** In a proof-of-work type cryptocurrency, the
    process of mining requires a huge amount of energy. Moreover, since the miners
    compete and there is only one winner, the energy consumption by the other miners
    is essentially wasted. This has led miners to relocate to locations with cheaper
    sources of energy. Nonetheless, considering energy itself to be a scarce resource,
    wastage of energy is undesirable.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**高耗电量：** 在一种工作量证明类型的加密货币中，挖矿过程需要大量能源。此外，由于矿工们竞争，只有一个获胜者，其他矿工的能源消耗基本上是浪费的。这导致矿工们搬迁到能源更便宜的地方。然而，考虑到能源本身是一种稀缺资源，能源的浪费是不可取的。'
- en: '**Technical flaws:** There have been reports of hacks into exchanges where
    the hackers made away with a considerable sum. Even without hacking, a fork in
    a cryptocurrency can cause confusion and result in decrease of value. The burden
    of the loss for such events has fallen on individual owners of cryptocurrencies.
    Such technical issues dent user confidence.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术缺陷：** 曾有报道称，黑客入侵了一些交易所，并夺走了相当可观的金额。即使没有黑客攻击，加密货币的分叉也会造成混乱，并导致价值下降。此类事件的损失负担已落在加密货币的个人所有者身上。这些技术问题损害了用户的信心。'
- en: '**Tendency towards centralisation:** A fundamental property of a cryptocurrency
    is that it is decentralised so that no single entity needs to be trusted. On the
    other hand, there has been an increasing tendency towards centralisation. The
    entry of miners with massive computational apparatus and the formation of mining
    pools have essentially shut out individuals from the process of mining. This has
    resulted in mining power being centralised in the hands of a few. Further, code
    maintenance and software updates are in practice also controlled by a small number
    of people.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心化倾向：** 加密货币的基本属性之一是去中心化，因此无需信任任何单一实体。另一方面，近年来出现了向中心化的趋势。拥有大规模计算设备的矿工的涌入以及矿池的形成实际上使个人无法参与挖矿过程。这导致挖矿算力集中在少数人手中。此外，代码维护和软件更新实际上也由少数人控制着。'
- en: '**Inadequate for retail payments:** Due to the rather long confirmation time
    of a cryptocurrency transaction, it becomes impractical to use these for making
    small purchases.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**不适用于零售支付：** 由于加密货币交易的确认时间相对较长，因此将其用于进行小额购买变得不切实际。'
- en: '**Not money:** In economics, money is something which should have three properties:
    a store of value, a medium of exchange and a unit of account. It has been alleged
    that cryptocurrencies have none of these properties, though some have stated that
    they at least serve as a medium of exchange.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**不是货币：** 在经济学中，货币应具有三个属性：价值储存、交换媒介和计价单位。有人声称加密货币没有这些属性，尽管有人表示它们至少可以作为交换媒介。'
- en: '**Price volatility:** The exchange rates of cryptocurrencies against fiat currencies
    have varied quite a lot in the past. This has encouraged speculative purchase
    of cryptocurrencies which has sometimes led to losses for the investors. Some
    national regulatory agencies have issued investor alerts about cryptocurrencies.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格波动：** 加密货币对法定货币的汇率过去曾有相当大的波动。这鼓励了对加密货币的投机性购买，有时会导致投资者损失。一些国家的监管机构已发布了关于加密货币的投资者警告。'
- en: '**Economic bubble/Ponzi scheme:** Several eminent personalities have mentioned
    that Bitcoin is an economic bubble which will burst sooner rather than later.
    There have also been criticisms that Bitcoin is a Ponzi scheme.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**经济泡沫/庞氏骗局：** 几位知名人士提到比特币是一个经济泡沫，它迟早会破灭。还有人批评比特币是一个庞氏骗局。'
- en: 19.9 Government Regulations
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.9 政府监管
- en: Nations across the world have taken notice of the growth of Bitcoin and cryptocurrencies.
    The reactions have mostly been negative though the degree of hostility varies.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各国都注意到了比特币和加密货币的增长。尽管敌意程度有所不同，但反应大多是负面的。
- en: The US Financial Crimes Enforcement Network (FinCEN) have established regulations
    for controlling activities related to cryptocurrencies. Miners who sell their
    generated coins are considered to be Money Service Businesses and are required
    by FinCEN to register and operate within the legal framework. Various US agencies
    have officially seized Bitcoins in the process, granting them some kind of a legal
    coginsance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 美国金融犯罪执法网络（FinCEN）已经制定了控制与加密货币相关活动的法规。出售其生成的货币的矿工被视为货币服务企业，并要求其在FinCEN规定的法律框架内注册并运营。各种美国机构在此过程中已经正式扣押了比特币，从而赋予它们某种法律认可。
- en: China has been the home to some of the largest miners of Bitcoins. However,
    it is illegal to buy any real-world goods with any virtual currency. The People's
    Bank of China has prohibited Chinese financial institutions from using Bitcoins.
    Further, China has also banned trading in Bitcoin.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 中国是一些最大比特币矿工的家园。然而，使用任何虚拟货币购买任何实物商品都是违法的。中国人民银行禁止中国金融机构使用比特币。此外，中国还禁止比特币交易。
- en: Due to the decentralised nature of cryptocurrencies, it is difficult to come
    up with a regulatory framework. It is possible, however, to criminalise the use
    of cryptocurrencies and shut down exchanges. This would constitute a de facto
    blanket ban of cryptocurrencies. The legal status of cryptocurrencies varies across
    nations. As of the date of this writing, an absolute ban applies in Algeria, Bolivia,
    Egypt, Iraq, Morocco, Nepal, Pakistan and United Arab Emirates. Some form of implicit
    ban applies in Bahrain, Bangladesh, China, Colombia, the Dominican Republic, Indonesia,
    Iran, Kuwait, Lesotho, Lithuania, Macau, Oman, Qatar, Saudi Arabia and Taiwan.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密货币的去中心化特性，很难制定监管框架。然而，可以将使用加密货币定罪并关闭交易所。这将构成对加密货币的事实上的全面禁令。各国对加密货币的法律地位不同。截至本文撰写日期，阿尔及利亚、玻利维亚、埃及、伊拉克、摩洛哥、尼泊尔、巴基斯坦和阿联酋绝对禁止使用加密货币。巴林、孟加拉国、中国、哥伦比亚、多米尼加共和国、印度尼西亚、伊朗、科威特、莱索托、立陶宛、澳门、阿曼、卡塔尔、沙特阿拉伯和台湾则实施某种形式的隐性禁令。
- en: There are some nations where cryptocurrency-related activities are legal. These
    include the European Union, the United States, Mexico, Japan, South Korea and
    others. There are other countries such as Canada and India where cryptocurrencies
    are not illegal, but there there is a banking ban.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一些国家允许加密货币相关活动合法进行。这些国家包括欧盟、美国、墨西哥、日本、韩国等。还有其他国家，如加拿大和印度，加密货币不是非法的，但存在银行禁令。
- en: 19.10 Central Bank–issued Digital Currency
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.10 央行数字货币
- en: Central banks of different countries have started exploring the idea of issuing
    digital currencies. Such a currency could be pegged to the national currency creating
    a stablecoin. The backbone for a central bank–issued digital currency would still
    be a blockchain. This blockchain would be maintained in a distributed form. However,
    only the central bank would have the authority to add new blocks and to create
    new amounts of the digital currency. This would lead to a centralised currency.
    Holders of the digital currency would have to trust the central bank. This is
    opposed to the trustless system of cryptocurrencies such as Bitcoin. Till date,
    there has been no concrete implementations of digital currencies by any central
    bank.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不同国家的央行已经开始探讨发行数字货币的想法。这样的货币可以与国家货币挂钩，形成稳定币。央行发行的数字货币的基础仍然是区块链。这个区块链将以分布式形式维护。然而，只有央行才有权添加新的区块并创建新的数字货币数量。这将导致中央集权的货币。数字货币的持有者必须信任央行。这与比特币等加密货币的无需信任系统相对立。迄今为止，任何央行都没有具体实施数字货币。
- en: Digital currencies issued by central banks can make it easier to make cross-border
    payments. For example, Saudi Arabia and UAE have launched a pilot cryptocurrency
    for easier cross-border payments. The Central Bank of Singapore has launched projects
    to improve inter-bank payments and to facilitate bank users exchange currencies
    with each other. The Bank of Israel is actively considering the possibility of
    launching a digital currency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 央行发行的数字货币可以更容易地进行跨境支付。例如，沙特阿拉伯和阿联酋已经推出了一个试点加密货币，以便更轻松地进行跨境支付。新加坡的中央银行推出了改善银行间支付和促进银行用户互相交换货币的项目。以色列银行正在积极考虑发行数字货币的可能性。
- en: In 2017, a study entitled ‘Global Blockchain Benchmarking Study’ was conducted
    by the Cambridge Centre for Alternative Finance. The study found that central
    banks were very positive about adopting blockchain technology for some purpose
    within the next two years. Also, a number of central banks were enthusiastic about
    issuing their own digital currencies. The main reason for such enthusiasm is the
    potential for cost reductions in terms of transactions, settlements and reconciliation
    costs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，剑桥替代金融中心进行了一项名为“全球区块链基准研究”的研究。研究发现，各国央行对在未来两年内采用区块链技术非常积极。此外，许多央行对发行自己的数字货币充满热情。这种热情的主要原因是潜在的交易成本、结算成本和对账成本的降低。
- en: From a national point of view, replacing physical cash with digital currency
    has an advantage. Cash transactions are anonymous and cannot be tracked. On the
    other hand, transactions made by digital currency are recorded on the blockchain
    and are auditable. This will lead to a widening of the tax base and possible prevention
    of untaxed transactions. On the flip side, it would also lead to a loss of privacy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从国家角度来看，用数字货币取代现金具有优势。现金交易是匿名的，无法追踪。另一方面，数字货币的交易记录在区块链上，并且可审计。这将导致税基扩大和可能防止未纳税交易。另一方面，这也会导致隐私丧失。
- en: 19.11 Lightning Network
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.11 闪电网络
- en: A major problem with a proof-of-work cryptocurrency is scalability. The number
    of transactions that can be processed per second is very limited. For example,
    Bitcoin can process about seven transactions per second. Payment systems such
    as Visa can process about two thousand transactions per second. So, if Bitcoin
    is to become competitive with Visa, there must be some way of speeding up transaction
    settlements. Further, for small payments, such as for a cup of coffee, waiting
    several minutes for the relevant transaction to be confirmed is rather impractical.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种工作证明加密货币的主要问题是可扩展性。每秒可处理的交易数量非常有限。例如，比特币每秒可以处理约七笔交易。像Visa这样的支付系统每秒可以处理约两千笔交易。因此，如果比特币要与Visa竞争，就必须有一种加速交易结算的方式。此外，对于小额支付，例如一杯咖啡，等待几分钟确认相关交易是相当不切实际的。
- en: One proposed solution to this problem has been called the lightning network.
    The idea is *not* to use the blockchain to confirm each and every transaction.
    Suppose two entities transfer funds between themselves quite often. To do this,
    they create a payment channel. Such a channel is created by both of them depositing
    an agreed upon amount of cryptocurrency to a 2-out-of-2 multi-signature address.
    Such an address arises from a special type of signature scheme which requires
    the consent of both the parties for the amount to be spent. Such a payment channel
    is a transaction, but it is not immediately broadcast to the network. Once the
    payment channel is created, the two entities can issue transactions to each other
    which essentially redistribute the total amount in the payment channel between
    themselves. These transactions are scripted so that the previous transactions
    are invalidated. None of these transactions are broadcast to the network. At some
    point, both or one of the entities may wish to finalise the deal. The latest transaction
    is then broadcast to the network and confirmed on the blockchain. So, instead
    of all the micropayments that occurred on the payment channel, only one transaction
    gets confirmed on the blockchain.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对此问题提出的一种解决方案被称为闪电网络。其想法*不是*使用区块链来确认每一笔交易。假设两个实体之间经常转移资金。为此，它们创建了一个支付通道。这样的通道是由它们两个都向一个2对2多签名地址存入一定数量的加密货币而创建的。这样的地址源自一种特殊类型的签名方案，它需要双方的同意才能花费金额。这样的支付通道是一笔交易，但不会立即广播到网络。一旦支付通道创建完成，两个实体就可以向对方发出交易，从而在它们之间重新分配支付通道中的总金额。这些交易被脚本化，以使之前的交易无效。这些交易都不会广播到网络。在某个时候，双方或其中一方可能希望完成交易。然后，最新的交易被广播到网络并在区块链上确认。因此，与在支付通道上发生的所有微支付相比，只有一笔交易在区块链上得到确认。
- en: It is not feasible for every pair of entities to set up payment channels between
    themselves. Instead it is envisaged that there will be a network of such small
    micropayment channels. The two entities which wish to transact will be connected
    by an appropriate path of payment channels.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每对实体都能够在它们之间建立支付通道。相反，预计将会有一个这样的小型微支付通道网络。希望进行交易的两个实体将通过适当的支付通道路径相连。
- en: This technology has the potential to speed up transaction processing to millions
    of transactions per second. It was initially proposed for Bitcoin. Subsequent
    work has led to development of lightning network for other cryptocurrencies. Note
    that transactions made on the payment channel are not confirmed on the blockchain.
    So, it is unlikely that large payments will be made using the lightning network.
    Rather, it is envisaged that small payments such as that of a cup of coffee will
    benefit from the speed of the lightning network.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术有望将交易处理加速到每秒数百万次。最初它是为比特币提出的。随后的工作导致了闪电网络用于其他加密货币的发展。请注意，在支付通道上进行的交易不会在区块链上得到确认。因此，使用闪电网络进行大额支付的可能性很小。相反，人们预计小额支付，比如一杯咖啡的支付，将从闪电网络的速度中受益。
- en: 19.12 Sidechain
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.12 侧链
- en: The concept of sidechains has been introduced to provide flexibility to a blockchain-based
    cryptocurrency. It also provides interoperability between different cryptocurrencies.
    Sidechains are also called childchains.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链的概念被引入以提供对基于区块链的加密货币的灵活性。它还为不同加密货币之间的互操作性提供了可能。侧链也被称为子链。
- en: To understand the notion, consider two separate cryptocurrencies – each operating
    with its independent blockchain. One of these chains is identified as the main
    chain, and the other chain is called a sidechain. Suppose it is required to transfer
    a certain amount from the main chain to the sidechain. To do this, an entity issues
    a transaction on the main chain where a payment is made to a specified address.
    This locks the amount on the main chain and the entity can no longer use this
    amount on the main chain. After a waiting period, an equivalent amount of cryptocurrency
    is released on the sidechain to the entity. This entity can now make payments
    on the sidechain. This essentially pegs the amount on the sidechain to the amount
    locked on the main chain. A similar procedure is adopted to transfer money from
    the sidechain to the mainchain. The two-way peg is enabled by a federation which
    is a group of servers acting as an intermediary between the main chain and the
    sidechain.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个概念，可以考虑两个独立的加密货币 - 每个都在其独立的区块链上运行。其中一个链被标识为主链，另一个链被称为侧链。假设需要将一定数量的资金从主链转移到侧链。为此，一个实体在主链上发出一个交易，在指定的地址进行支付。这将在主链上锁定金额，实体将无法在主链上再使用这笔金额。经过一段等待时间后，相当数量的加密货币将在侧链上释放给该实体。这个实体现在可以在侧链上进行支付。这基本上将侧链上的金额与主链上锁定的金额挂钩。从侧链向主链转移资金采用类似的程序。双向挂钩是由联合体实现的，它是一组充当主链和侧链之间中介的服务器。
- en: Each sidechain has its own security and a breakdown of a sidechain does not
    affect the main chain. This makes sidechains a great way to experiment with new
    ideas. Further, sidechains can be launched for specific purposes such as to deal
    with transactions of only a specific type. Sidechains can also be used to enhance
    the capabilities of a blockchain. For example, the Bitcoin blockchain does not
    have support for smart contracts. There has been a sidechain to the main Bitcoin
    blockchain which allows smart contracts to be implemented.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个侧链都有自己的安全性，侧链的崩溃不会影响主链。这使得侧链成为尝试新想法的好方法。此外，侧链可以针对特定目的启动，比如处理仅特定类型的交易。侧链还可以用于增强区块链的功能。例如，比特币区块链没有智能合约支持。已经有了一个主比特币区块链的侧链，允许实现智能合约。
- en: 19.13 Proof of Stake
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.13 权益证明
- en: The process of mining a block is energy intensive. Miners simultaneously compete
    to create a new block. Only one miner is successful, while the efforts of the
    other miners are wasted. Further, as the difficulty of creating a new block is
    raised, miners have to put in ever increasing efforts to create a proof of work.
    So, proof-of-work-based cryptocurrencies are energy inefficient.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘区块的过程消耗大量能源。矿工同时竞争创建新区块。只有一个矿工成功，而其他矿工的努力则被浪费。此外，随着创建新区块的难度提高，矿工必须不断加大工作量来创建工作证明。因此，基于工作证明的加密货币存在能源效率低的问题。
- en: Alternative approaches have been suggested to the problem of creating a new
    block. In a proof-of-work-based cryptocurrency, all nodes in the P2P network can
    participate in the block creation process. The node which first presents the required
    proof of work gets to add a new block to the blockchain. The alternative strategy
    is to allow only a subset of nodes to participate in the mining process. For example,
    entities which hold a certain amount of the cryptocurrency can only participate
    in the generation of the next block. The amount of cryptocurrency held by an entity
    is verifiable from the blockchain. The entity is considered to be a valid stakeholder
    in the cryptocurrency, and its holding of the cryptocurrency is a proof of its
    stake.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了解决创建新区块问题的替代方法。在基于工作证明的加密货币中，P2P 网络中的所有节点都可以参与区块创建过程。首先提出所需工作证明的节点可以将新区块添加到区块链中。另一种替代策略是只允许节点子集参与挖矿过程。例如，持有一定数量加密货币的实体只能参与下一个区块的生成。实体持有的加密货币数量可以从区块链中验证。该实体被视为加密货币的有效持有者，其持有的加密货币是其持股的证明。
- en: Using only the amount of cryptocurrency to determine the creation of a new block
    will lead to undesirable centralisation since only the wealthiest entity will
    get to add blocks to the blockchain. To alleviate this problem, a combination
    of age and wealth has been suggested to select the entity for adding a new block.
    Here age refers to the number of days the coins have been held.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用加密货币的数量来确定新区块的创建会导致不良的集中化，因为只有最富有的实体才能添加区块到区块链上。为了缓解这个问题，提出了一种结合了年龄和财富的方法来选择添加新区块的实体。这里的年龄指的是持币天数。
- en: Ouroboros is a cryptocurrency mechanism which uses proof of stake to elect an
    entity to add a new block. In this procedure, all entities which hold a certain
    minimum amount of the cryptocurrency has a chance of being elected. The probability
    of an entity being elected is proportional to the amount of cryptocurrency which
    it holds. Time is divided into slots, and in each slot an elected entity can add
    a new block to the blockchain. Simultaneously, all the stakeholders participate
    in the election of the entity which will be adding a block in the next slot. This
    election process is fairly complicated and requires a secure multiparty computation
    of random bits.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Ouroboros 是一种加密货币机制，它使用股权证明来选举一个实体添加一个新的区块。在这个过程中，所有持有一定数量的加密货币的实体都有被选中的机会。一个实体被选中的概率与其持有的加密货币数量成正比。时间被划分为时隙，在每个时隙中，一个被选中的实体可以向区块链添加一个新的区块。同时，所有的利益相关者参与选举下一个时隙将要添加区块的实体。这个选举过程相当复杂，需要对随机比特进行安全的多方计算。
- en: Algorand is a cryptocurrency which follows a method for block selection similar
    to proof-of-stake protocols. In particular, voting power is proportional to the
    amount of funds held. In each round, a random committee is selected which will
    decide the next block to be added to the blockchain. The selection of the committee
    is done by each entity doing a private computation and determining from the result
    whether it is part of the committee. No interaction is required at this step.
    The committee members exchange messages to determine the next block. The scheme
    introduces a notion called player replacability whereby the committee need not
    remain the same for all the messages. Theoretical basis for the scheme arises
    from secure consensus protocols for Byzantine fault tolerance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Algorand 是一种加密货币，其遵循类似股权证明协议的区块选择方法。特别地，投票权与持有的资金数量成正比。在每一轮中，会选择一个随机委员会来决定下一个要添加到区块链中的区块。委员会的选择是通过每个实体进行私人计算并根据结果确定自己是否是委员会的一部分来完成的。在这一步骤中不需要互动。委员会成员交换消息来确定下一个区块。该方案引入了一种称为“玩家可替代性”的概念，其中委员会在所有消息中不需要保持不变。该方案的理论基础来自于拜占庭容错的安全共识协议。
- en: Chapter 20
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 20 章
- en: Examples of Cryptocurrencies
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币示例
- en: Bitcoin was the first proposed cryptocurrency. Since then many other cryptocurrencies
    have been proposed. These are sometimes referred to as altcoins standing for alternative
    cryptocurrencies. We briefly discuss a few important cryptocurrencies.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是首次提出的加密货币。此后，许多其他加密货币被提出。有时将这些称为替代加密货币的替代品。我们简要讨论了几种重要的加密货币。
- en: Our description of how cryptocurrency systems work has been based on Bitcoin.
    For the other cryptocurrencies, we briefly mention how their technology differs
    from Bitcoin.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对加密货币系统如何运作的描述是基于比特币的。对于其他加密货币，我们简要提及它们的技术与比特币的不同之处。
- en: 20.1 Bitcoin
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1 比特币
- en: Bitcoin was proposed in 2009 by an unknown person (or a group of persons) under
    the name of Satoshi Nakamoto (see Nakamoto, 2009). The first implementation was
    also released by Satoshi Nakamoto as an open source software. On 3 January 2009,
    the genesis block was mined by Satoshi. Hal Finney downloaded the Bitcoin software
    on its release date. On 12 January 2009, the first Bitcoin transaction was made
    when Hal Finney received 10 Bitcoins from Satoshi Nakamoto. During the early days,
    Nakamoto is estimated to have mined one million Bitcoins. He [¹](#fn1) disappeared
    in 2010\. Before disappearing he handed over the password of the code repository
    to Gavin Andresen. Later Andresen decided to decentralise control.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币于2009年由一个名为中本聪的未知人士（或一群人）提出（见中本聪，2009年）。第一个实现也由中本聪以开源软件的形式发布。2009年1月3日，中本聪挖掘了创世区块。Hal
    Finney在发布日期下载了比特币软件。2009年1月12日，第一笔比特币交易发生在Hal Finney收到来自中本聪的10比特币时。在早期，中本聪据估计已挖掘了一百万比特币。他在2010年消失了。在消失之前，他将代码库的密码交给了Gavin
    Andresen。后来，Andresen决定分散控制权。
- en: Since its release, over the last decade, Bitcoin has grown from an obscure cryptocurrency
    to being a potentially breakthrough technology. As of January 2018, the size of
    the full Bitcoin blockchain was about 150 GB. Presently several million users
    use Bitcoin. The unit of the Bitcoin system is a Bitcoin. A Bitcoin is divisible.
    The smallest amount is 10^(−8) Bitcoin which is called a Satoshi.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 自发布以来，在过去的十年中，比特币已从一种鲜为人知的加密货币发展成为一个可能的突破性技术。截至2018年1月，完整的比特币区块链大小约为150 GB。目前有数百万用户使用比特币。比特币系统的单位是比特币。比特币是可分割的。最小的数量是10^(−8)比特币，称为一聪。
- en: If the private key of a Bitcoin address is lost, then there is no way to spend
    the amount of Bitcoin associated with the address. In 2013, a person claimed to
    have lost 7,500 Bitcoins when he accidentally discarded a hard drive containing
    his private key. It is believed that about 20% of all Bitcoins has been lost.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比特币地址的私钥丢失，则无法花费与该地址关联的比特币金额。2013年，一名个人声称当他意外丢弃了包含私钥的硬盘时，他丢失了7500比特币。据信，大约有20%的比特币已经丢失。
- en: The monetory policy of Bitcoin has been described earlier. Successful mining
    of a block creates a certain amount of Bitcoins. Initially, this was 50 Bitcoins.
    After every 210,000 blocks (which takes about 4 years), the amount of Bitcoin
    created per block is halved. The total amount of Bitcoins that will ever be created
    is 21 million which will be reached around the year 2140\. The rate of supply
    of Bitcoin ensures that Bitcoin remains valuable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的货币政策早已被描述。成功挖掘一个区块会创造一定数量的比特币。最初，这是50个比特币。每过210,000个区块（大约4年），每个区块创建的比特币数量减半。将被创建的比特币总量为2100万，在约2140年达到。比特币供应速度确保了比特币的价值。
- en: Client software to operate Bitcoin is called a wallet. These can operate in
    several ways. Full clients store the full copy of the blockchain and can perform
    the full validation checks. Due to the large size of the blockchain, it is not
    feasible to store the entire blockchain on computing devices which have limited
    memory. Lightweight clients are wallets which do not store the full blockchain,
    but interact with full clients for sending and receiving transactions. Consequently,
    lightweight wallets are easier to set up and operate on low-power, low-bandwidth
    devices such as smartphones. The trade-off is that such a wallet must trust the
    server. Wallets can as well be provided online by a third party. The credentials
    are stored with the online provider rather than on the user's device. This requires
    complete trust in the online provider. The Bitcoin Core is the best known implementation
    of the client software.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 操作比特币的客户端软件被称为钱包。这些钱包可以通过几种方式运行。完整客户端存储了整个区块链的完整副本，并可以执行完整的验证检查。由于区块链的大小很大，因此在内存有限的计算设备上存储整个区块链是不可行的。轻量级客户端是不存储完整区块链的钱包，而是与完整客户端交互以发送和接收交易。因此，轻量级钱包更容易设置和在低功率、低带宽设备上运行，如智能手机。折衷之处在于这样的钱包必须信任服务器。第三方也可以在线提供钱包。凭证存储在在线提供商而不是用户设备上。这需要对在线提供商完全的信任。比特币核心是客户端软件的最著名实现。
- en: Bitcoin has been forked several times. A hard fork on 1 August 2017 created
    a new cryptocurrency called the Bitcoin Cash. The goal of Bitcoin Cash was to
    allow larger block size so that the rate of transaction processing could be increased.
    Another hard fork created the Bitcoin Gold on 24 October 2017.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币已经多次分叉。2017年8月1日的硬分叉创建了一种新的加密货币，名为比特币现金。比特币现金的目标是允许更大的区块大小，以便增加交易处理速度。另一次硬分叉在2017年10月24日创建了比特币黄金。
- en: Decentralisation is a cherished goal of Bitcoin. There has been, however, a
    tendency towards centralisation. One aspect of this is the creation of mining
    pools. The mining pools together contribute a large fraction of the computational
    power of the network. In 2013, about 75% of the hash rate of the network was controlled
    by six mining pools. More alarmingly, in 2014, the mining pool Ghash.io obtained
    51% of the hash rate giving them the power to launch a 51% attack (see Section
    18.13). Since then, the pool has voluntarily capped their hash rate at 39.99%
    for the benefit of the whole network. Other parts of the Bitcoin ecosystem, such
    as the maintenance of the software, are also controlled by a small set of entities.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的分权化是一个珍视的目标。然而，有一种向中心化的趋势。其中之一就是挖矿池的创建。挖矿池共同贡献了网络的大部分计算能力。2013年，约有75%的网络算力由六个挖矿池控制。更令人担忧的是，2014年，挖矿池Ghash.io获得了51%的算力，使他们有能力发起51%攻击（见第18.13节）。自那时起，该矿池自愿将其算力限制在39.99%以造福整个网络。比特币生态系统的其他部分，如软件的维护，也受到少数实体的控制。
- en: Bitcoin supposedly provides a measure of anonymity. This is due to the fact
    that the funds are associated with addresses, where the owners of the addresses
    are not required to be identified. Analysis of the transactions available on the
    blockchain, however, indicates holding patterns. Further, cryptocurrency exchanges
    can be required by law to collect personal information. Technically speaking,
    all Bitcoins are equivalent. The blockchain, on the other hand, records the history
    of each Bitcoin. Some users may refuse to accept Bitcoins coming from controversial
    transactions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 据称，比特币提供了一定程度的匿名性。这是因为资金与地址关联，地址的所有者无需被识别。然而，对区块链上可用交易的分析表明了持有模式。此外，加密货币交易所可能会被法律要求收集个人信息。从技术上讲，所有比特币都是等价的。另一方面，区块链记录了每个比特币的历史。一些用户可能拒绝接受来自有争议交易的比特币。
- en: A transaction in a Bitcoin is a description of transfer of coins from input
    to output addresses which is signed using the signing keys of the input addresses.
    While this is a very basic functionality, Bitcoin also provides for transactions
    to describe somewhat more complex conditions. For example, it is possible to create
    a multi-signature transaction, i.e. one which is signed by several entities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的交易是从输入地址到输出地址的硬币转移的描述，使用输入地址的签名密钥进行签名。虽然这是一个非常基本的功能，比特币也允许交易描述相对复杂的条件。例如，可以创建一个多重签名交易，即由多个实体签名的交易。
- en: 20.2 Ethereum and Smart Contracts
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2 以太坊和智能合约
- en: Ethereum brought in a new innovation to the blockchain technology. At a bare
    bones level, a blockchain is a linked chain of blocks, where each block contains
    a list of transactions. A transaction essentially transfers cryptocurrency from
    a set of input addresses to a set of output addresses. Transactions are signed
    using the signing key of the sender. While Bitcoin transactions describe more
    general conditions, it does not go all the way.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊为区块链技术带来了一项新的创新。在最基本的层面上，区块链是一个链接的区块链，每个区块包含一个交易列表。交易基本上是将加密货币从一组输入地址转移到一组输出地址。交易使用发送方的签名密钥进行签名。虽然比特币交易描述了更一般的条件，但没有走到底。
- en: The pertinent question that is raised is how much more complex scenarios can
    be handled? For example, one may wish to describe a contract between two parties.
    Such a contract could be a simple thing like a small loan or it could even be
    the sale of a car. Further, the execution of a contract could depend on an event
    in the future such as the price of some share in a stock exchange. The main innovation
    of Ethereum is the ability to handle all such scenarios and more.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的相关问题是，能处理多么复杂的场景？例如，一个人可能希望描述两方之间的合同。这样的合同可能是一个简单的事情，比如小额贷款，或者甚至是汽车的销售。此外，合同的执行可能取决于将来某个事件，例如股票交易所的某些股票的价格。以太坊的主要创新是能够处理所有这些场景以及更多。
- en: To understand the capability of Ethereum, we need to step back for a moment
    and consider what it means to compute something. This was an important question
    in the early decades of the twentieth century. An answer was provided by Alan
    Turing who proposed a very simple model of computation which is now called a Turing
    machine. Turing also introduced the notion of universality and proposed the construction
    of a universal Turing machine which is capable of simulating any Turing machine.
    The intuitive notion of computation by itself is hard to define and so it cannot
    be formally proved that Turing machines can indeed compute all that may be intuitively
    considered to be computable. The Church–Turing thesis is the hypothesis that this
    is indeed the case, i.e. our intuitive notion of computation is exactly captured
    by a universal Turing machine.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解以太坊的能力，我们需要稍作停顿，思考一下计算的含义。这是二十世纪早期几十年间的一个重要问题。艾伦·图灵提出了一个非常简单的计算模型，现在称为图灵机。图灵还引入了普适性的概念，并提出了一种通用图灵机的构造，它能够模拟任何图灵机。计算的直觉概念本身很难定义，因此不能正式证明图灵机确实可以计算一切可能被直观认为是可计算的东西。丘奇-图灵论题是这样的假设，即我们对计算的直觉概念确实被通用图灵机所捕捉。
- en: Turing machines are not the only possible models of computation. Alternative
    systems such as the lambda calculus and recursive functions have been proposed.
    All of these systems have been shown to be equivalent. In particular, this means,
    for example, that the lambda calculus system of rules can be used to simulate
    a universal Turing machine. More generally, a language consisting of rules to
    manipulate data is said to be Turing complete if it can be used to simulate a
    universal Turing machine and by extension any Turing machine.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机并不是计算的唯一可能模型。其他系统，如λ演算和递归函数，也被提出。所有这些系统都被证明是等价的。特别是，这意味着，例如，λ演算规则系统可以用来模拟通用图灵机。更一般地，如果一种语言由操作数据的规则组成，并且可以用来模拟通用图灵机，进而模拟任意图灵机，那么这种语言被称为图灵完备的。
- en: In view of the above, a theoretical goal for designing a language which can
    describe complex scenarios is to ensure that the language is Turing complete.
    Ethereum provides such a language (subject to some practical limitations). This
    allows Ethereum to describe contracts, and more generally, to describe autonomous
    agents of almost arbitrary complexity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述观点，设计一种可以描述复杂场景的语言的理论目标是确保该语言是图灵完备的。以太坊提供了这样一种语言（在一些实际限制下）。这使得以太坊能够描述合约，更一般地说，描述几乎任意复杂性的自治代理。
- en: Before describing Ethereum, let us consider the Bitcoin blockchain once more.
    A useful view of what happens is that of a state transition system. At any point
    of time, among other things, the blockchain provides a record of all the Bitcoins
    that have been generated so far. This information can be summarised as a state
    where the state is a list of addresses and the amount of Bitcoins held by each
    address. A block consists of a list of transactions which essentially transfers
    Bitcoins from one set of addresses to another set of addresses. After the creation
    of a new block, we obtain a new state. So, the processing of a list of transactions
    by the creation of a new block can be considered to be transition from one state
    to another.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述以太坊之前，让我们再次考虑比特币区块链。一个有用的观点是把它看作是一个状态转换系统。在任何时刻，区块链提供了迄今为止生成的所有比特币的记录。这些信息可以总结为一个状态，其中状态是一个地址列表，以及每个地址持有的比特币数量。一个区块包含了一系列交易，这些交易基本上是将比特币从一个地址集合转移到另一个地址集合。在创建新区块之后，我们得到一个新的状态。因此，通过创建新区块处理一系列交易可以被认为是从一个状态到另一个状态的转换。
- en: Ethereum starts off with such a state transition view of the blockchain. States
    in Ethereum, however, are more complex than those of Bitcoin.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊从区块链的这种状态转换观点开始。然而，以太坊的状态比比特币的状态更复杂。
- en: 'The basic object in Ethereum is an ‘account’ which consists of four items:
    a nonce; the account''s present Ether balance (Ether is a unit of currency in
    Ethereum); a program to describe a contract (which is optional); and the account''s
    storage. Each account has an address. Accounts are of two types, namely, user
    (or externally owned) account and contract account. A user account does not have
    any program, while contract accounts have associated programs. Each account has
    an address which is computed by applying a hash function to the address of the
    creator of the account along with the relevant nonce of the creator account.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的基本对象是一个‘账户’，它包括四个项目：一个 nonce；账户的当前以太币余额（以太币是以太坊中的货币单位）；描述合约的程序（可选）；和账户的存储。每个账户都有一个地址。账户有两种类型，即用户（或外部拥有）账户和合约账户。用户账户没有任何程序，而合约账户有关联的程序。每个账户都有一个地址，该地址是通过对账户创建者的地址应用哈希函数以及创建者账户的相关
    nonce 来计算得出的。
- en: Interaction between accounts is enabled by passing messages from one account
    to another. Messages can be created by both user and contract accounts and can
    contain data. Further, if the recipient of a message is a contract account, then
    there is an option to return a response. In Ethereum, the term transaction is
    used to denote a signed message sent from a user account. The sending of a message
    from any account increments the nonce of the account. For a contract account,
    every time a message is received, the code is activated. This allows the contract
    account to read and write its internal storage and send other messages or even
    create new contracts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 账户之间的交互是通过将消息从一个账户传递到另一个账户来实现的。消息可以由用户账户和合约账户创建，并且可以包含数据。此外，如果消息的接收者是一个合约账户，那么有一个选项可以返回响应。在以太坊中，术语“交易”用来表示从用户账户发送的签名消息。从任何账户发送消息会增加账户的
    nonce。对于合约账户，每次接收到消息时，代码都会被激活。这允许合约账户读取和写入其内部存储，并发送其他消息，甚至创建新的合约。
- en: An Ethereum state is a snapshot of the set of accounts. A state transition takes
    place by the processing of a list of messages. Each message alters the values
    of the internal variables of one or more accounts. This alteration may be due
    to the execution of the code inside a contract account. Processing of a message
    may also lead to the creation of new accounts. So, a snapshot of the set of accounts
    after processing of the messages is the new state of the system.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊状态是账户集合的快照。状态转换通过处理一系列消息而发生。每个消息都会改变一个或多个账户的内部变量的值。这种变化可能是由于在合约账户内部执行代码而导致的。处理消息也可能导致新账户的创建。因此，在处理消息后账户集合的快照即为系统的新状态。
- en: Let us now see how this state transition view is mapped to a blockchain. A block
    in the Ethereum blockchain contains a copy of the messages/transactions that have
    been processed as well as the most recent state. Along with this, it stores two
    other values, the block number and the difficulty. Blocks are chained together
    through a proof-of-work style mechanism using a hash function. This part is the
    same as the basic blockchain technology. Validating a block consists of several
    actions such as verifying timestamp, reference to the previous block, difficulty
    and other checks. One important check is to ensure that applying the messages
    in the present block to the state recorded in the previous block leads to the
    state recorded in the present block. Note that this validation step requires applying
    messages to the individual accounts which for contract accounts means running
    the program embedded in such accounts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这种状态转换视图是如何映射到区块链的。以太坊区块链中的一个区块包含已经处理的消息/交易的副本以及最近的状态。除此之外，它还存储了另外两个值，即区块编号和难度。区块通过哈希函数使用工作量证明机制链在一起。这部分与基本的区块链技术相同。验证一个区块包括多个动作，比如验证时间戳、对上一个区块的引用、难度和其他检查。一个重要的检查是确保将当前区块中的消息应用于前一个区块中记录的状态会导致当前区块中记录的状态。请注意，这个验证步骤需要将消息应用于各个账户，对于合约账户来说，这意味着运行这些账户中嵌入的程序。
- en: The execution of contracts in Ethereum can also be initiated by external information.
    For example, one may describe a contract account to transfer a certain amount
    of money if the price of some share in a stock exchange reaches a certain value.
    Once such a contract is released to the network, mining nodes will check the relevant
    stock ticker and execute the code at the appropriate time in the future. It will
    not be required for the original creator of the account to initiate any further
    action. Such a provision can greatly facilitate the generation and execution of
    financial derivatives.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中合约的执行也可以由外部信息启动。例如，一个人可以描述一个合约账户，如果股票交易所中某股的价格达到某个值，就会转移一定金额的资金。一旦这样的合约发布到网络上，挖矿节点将检查相关的股票行情，并在将来的适当时间执行代码。原始账户的创建者不需要进一步采取任何行动。这样的规定可以极大地促进金融衍生品的生成和执行。
- en: Ethereum operates in a P2P network in a manner similar to that of other distributed
    permissionless cryptocurrencies. Nodes introduce messages and transactions into
    the network. Miners collect together a set of such messages/transactions and compete
    with each other to create the next block to be inserted into the blockchain. Newly
    created blocks are propagated through the P2P network. Nodes maintain their private
    copies of the blockchain and follow the consensus algorithm of Ethereum for updating
    this copy. Before adding a new block to their private copies, nodes have to validate
    the block. Among other things, this constitutes running the programs for the relevant
    contract accounts. So, the programs for each contract account are executed on
    all the nodes of the network. While this can be considered to be a wastage of
    computational power, such independent executions of a contract program by the
    nodes essentially ensures that no trusted third party is required in the entire
    set-up.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊以类似于其他分布式无权限加密货币的方式在P2P网络中运作。节点向网络中引入消息和交易。矿工们收集这些消息/交易的集合，并相互竞争以创建下一个要插入区块链的区块。新创建的区块通过P2P网络传播。节点维护他们的区块链的私有副本，并遵循以太坊的共识算法来更新此副本。在将新区块添加到他们的私有副本之前，节点必须验证该区块。在其他方面，这包括运行与相关合约账户有关的程序。因此，网络的所有节点上都执行合约账户的程序。虽然这可能被认为是对计算能力的浪费，但节点对合约程序的独立执行实际上确保了整个设置不需要信任的第三方。
- en: Ethereum was proposed in late 2013 by Vitalik Buterin and the system started
    on 30 July 2015\. The currency of Ethereum is denoted as Ether. The system started
    with 72 million premined coins. Ethereum provides a monetory policy for the generation
    of Ether and a sophisticated incentive policy for execution of contracts so as
    to reimburse the cost of the miners who run the code for the contracts. Over the
    years, Ethereum has suffered its own problems such as the exploitation of a software
    flaw in a contract to steal the equivalent of about $50 million Ether. There have
    also been disputes leading to a hard fork of the blockchain.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是由Vitalik Buterin于2013年底提出的，系统于2015年7月30日启动。以太坊的货币记为Ether。系统起初预挖了7200万个币。以太坊为Ether的生成提供了货币政策，并为执行合约提供了复杂的激励政策，以补偿运行合约代码的矿工的成本。多年来，以太坊也遭受了自己的问题，例如利用合约中的软件缺陷窃取大约5000万美元的Ether的事件。还发生了导致区块链硬分叉的争议。
- en: 20.3 Ripple and Payment Systems
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3 波动币和支付系统
- en: In the present set-up, transferring funds across banks and across national boundaries
    is a difficult and time-consuming procedure. It can take up to several days to
    transfer funds and involve substantial commissions to the intermediaries involved
    in the process. A major innovation of Ripple is to harness the technology of distributed
    systems to provide an efficient and low-cost solution to the problem.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的设置中，跨银行和跨国界转移资金是一个困难且耗时的程序。将资金转移可能需要数天的时间，并涉及到参与过程的中间人的大量佣金。Ripple的一个重大创新是利用分布式系统技术来提供一个高效且低成本的解决方案。
- en: Ripple is a payment system. Using Ripple, it is possible to transfer almost
    any kind of financial token. Such tokens could be fiat currencies, cryptocurrencies,
    frequent flier miles, etc. Ripple also provides an in-built cryptocurrency called
    XRP. A total of 100 billion XRP was created at the beginning by Ripple Lab, the
    creator of Ripple. There is no provision for creating any more XRP. Ripple Labs
    have slowly released XRP into the system.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple是一个支付系统。使用Ripple，几乎可以转移任何类型的金融代币。这些代币可以是法定货币、加密货币、常旅客里程等。Ripple还提供了一个内置的加密货币称为XRP。在创立Ripple的Ripple
    Lab公司最初创建了总共1000亿XRP。没有任何关于创造更多XRP的规定。Ripple Lab公司已经逐渐释放了XRP到系统中。
- en: The Ripple technology is *not* based on blockchain. So, there is no concept
    of mining to create new currency. Ripple provides a kind of semi-permissioned
    and semi-decentralised system. Even though XRP was created by Ripple Labs and
    presently 55% is still held by them, it is arguably possible for the Ripple network
    to operate even if Ripple Labs shuts down.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple技术*不*基于区块链。因此，没有挖掘新货币的概念。Ripple提供了一种半许可和半分散的系统。尽管XRP是由Ripple Lab公司创建的，目前仍有55%的XRP由他们持有，但可以说，即使Ripple
    Lab公司关闭，Ripple网络也有可能继续运行。
- en: Users of the Ripple system hold accounts. Transactions consist of payments from
    a set of accounts to another set of accounts. Users can directly make payments
    to users they trust. Alternatively, the Ripple network attempts to build a line
    of trust between two users where two consecutive parties in the line have mutual
    trust. One of the major roles of XRP is to serve as the main liquidity holding
    in the network. An entity can convert its preferred token to XRP, the payment
    is made in XRP and at the receiving end, XRP is converted into the preferred token
    of the recipient. Another role of XRP is to secure the network against certain
    kinds of overloading attacks. Each transaction requires burning up a small amount
    of XRP. The amount by itself is so small that for a transaction it is an insignificant
    cost. However, if an entity tries to overload the system with a huge number of
    transactions, then the cost in XRP to such an entity will also be huge which serves
    as a deterrent.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple系统的用户拥有账户。交易包括从一组账户向另一组账户的支付。用户可以直接向他们信任的用户付款。另外，Ripple网络试图在两个用户之间建立信任线，其中信任线上的两个连续方彼此信任。XRP的一个主要作用是作为网络中的主要流动性持有。一个实体可以将其首选代币转换为XRP，支付是以XRP进行的，而在接收端，XRP会被转换为收件人的首选代币。XRP的另一个作用是防范某些类型的过载攻击对网络的影响。每笔交易都需要燃烧一小部分XRP。这个数量本身很小，对于一笔交易来说是微不足道的成本。然而，如果一个实体试图用大量的交易来过载系统，那么对这样一个实体而言，以XRP计算的成本也将是巨大的，这起到了威慑作用。
- en: A ledger in Ripple is a record of the amount of currency in each user's account.
    Ripple follows a distributed system. Nodes in the network are servers running
    the Ripple server software. Banks and financial institutions join the Ripple network
    by becoming a node in the network. Each server maintains a copy of the ledger.
    The ledger is updated every few seconds using a consensus mechanism. The last-closed
    ledger is the most recent state of the ledger that has been ratified by the consensus
    mechanism. The open ledger is the one which is currently being confirmed. Once
    confirmed this becomes the last closed ledger. The history of all payments is
    available in the list of states of the ledgers that have been confirmed till date.
    For the purposes of approving payments, it is not required to keep the entire
    ledger history, though most nodes still do so.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple中的账本是记录每个用户账户中货币数量的记录。Ripple采用分布式系统。网络中的节点是运行Ripple服务器软件的服务器。银行和金融机构通过成为网络中的节点来加入Ripple网络。每个服务器都维护着账本的一份副本。账本使用共识机制每隔几秒钟更新一次。最后关闭的账本是已经由共识机制批准的最近状态的账本。开放账本是当前正在确认的账本。一旦确认，这个账本就成为了最后关闭的账本。所有支付的历史记录都可以在已确认的账本状态列表中找到。为了批准支付，不需要保留整个账本历史记录，尽管大多数节点仍然这样做。
- en: Ledger updation is done by the nodes following a consensus mechanism. Each node
    maintains a list of unique node list (UNL) which it consults. The set of UNL is
    not the set of all nodes in the network. It is sufficient that the node should
    trust the nodes in UNL as a whole. For this, individual trust in each node in
    UNL is not required. For example, if the UNL of a node includes a bank in the
    US and a bank in China, the node may assume that two such banks are unlikely to
    collude even if it may not trust the individual banks.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 账本更新由遵循共识机制的节点完成。每个节点维护一个唯一节点列表（UNL），并咨询该列表。UNL的集合不是网络中所有节点的集合。节点只需相信UNL中的节点整体即可。为此，并不需要对UNL中每个节点的个体信任。例如，如果节点的UNL包括美国的一家银行和中国的一家银行，则该节点可以假设即使它可能不信任这两家银行，这两家银行也不太可能串通。
- en: Any server can broadcast transactions to be included in the next updation of
    the ledger. All the servers attempt to include every valid transaction when a
    new consensus round starts. The consensus protocol proceeds in several rounds.
    To start the protocol, each server takes all valid transactions it has received
    prior to the beginning of the consensus protocol which have not yet been applied.
    The server makes these transactions public as a candidate list of transactions.
    Each server then takes the union of the candidate sets of all the nodes in its
    UNL and votes on the transactions. A server decides to proceed with a transaction
    in the next round if the transaction receives a certain minimum percentage of
    approving votes. For the final round of consensus, a server decides to accept
    a transaction if the transaction is approved by at least 80% of the server's UNL.
    Finally, the server applies the accepted transactions to its copy of the open
    ledger, and the updated ledger becomes the last closed ledger.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 任何服务器都可以广播要包含在下一次账本更新中的交易。当新的共识轮开始时，所有服务器都尝试包含每笔有效交易。共识协议分几个轮次进行。为了启动协议，每个服务器在共识协议开始之前接收到的尚未应用的所有有效交易。服务器将这些交易公开为候选交易列表。然后，每个服务器将其UNL中所有节点的候选交易集合的并集取出并对交易进行投票。如果交易获得了一定最低比例的赞成票，服务器决定在下一轮继续进行该交易。对于最后一轮共识，如果交易获得了服务器UNL至少80%的批准，则服务器决定接受该交易。最后，服务器将被接受的交易应用于其打开账本的副本，更新后的账本成为最后一个封闭的账本。
- en: There are three crucial properties of the consensus protocol, namely correctness,
    agreement and termination. Correctness is shown by arguing that if the number
    of Byzantine nodes in the network is below a certain level, then no invalid transaction
    will be confirmed by the consensus protocol. Agreement refers to the fact that
    if the nodes start out with the same state of the ledger, then after the execution
    of the consensus protocol, all the nodes again have the same state of the ledger.
    Finally, it can be argued that the consensus protocol terminates and each valid
    transaction gets applied to the ledger within a finite amount of time. In practice,
    Ripple network is reported to be able to handle about 1,500 transactions per second,
    making it much faster than blockchain-based technologies such as Bitcoin or Ethereum.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议的三个关键属性是正确性、一致性和终止性。通过论证，可以表明如果网络中的拜占庭节点数量低于某个水平，则共识协议不会确认任何无效交易。一致性指的是如果节点以相同的账本状态开始，那么在执行共识协议后，所有节点再次具有相同的账本状态。最后，可以论证共识协议终止，并且每个有效交易在有限时间内被应用到账本上。实际上，据报道，瑞波网络能够处理约每秒1,500笔交易，使其比基于区块链的技术（如比特币或以太坊）快得多。
- en: ¹Since the identity of Satoshi Nakamoto is unknown, use of the pronoun ‘he’
    is possibly inaccurate. We use it only for the sake of convenience.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ¹由于中本聪的身份不明，使用代词“他”可能不准确。我们仅出于方便之用而使用它。
- en: Chapter 21
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21章
- en: Applications of Blockchain
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用
- en: The underlying technology behind Bitcoin and most other cryptocurrencies is
    blockchain. In this context, the blockchain is permissionless, trustless and distributed.
    The basic technology of blockchain, however, is amenable to other applications
    including permissioned and trusted scenarios. In this chapter, we briefly describe
    a few such applications.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币和大多数其他加密货币背后的基础技术是区块链。在这种情况下，区块链是无需许可的、无需信任的、分布式的。然而，区块链的基本技术也适用于其他场景，包括经过许可和值得信赖的场景。在本章中，我们简要描述了几种这样的应用。
- en: Since a blockchain essentially implements a ledger, any application which utilises
    a ledger can potentially benefit from the use of blockchain. Depending on the
    access control mechanism of the ledger, it is possible to realise an appropriate
    blockchain. The fundamental idea of implementing a ledger by a blockchain opens
    up immense potential for the blockchain technology.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链本质上实现了账本，任何利用账本的应用都有可能从区块链的使用中受益。根据账本的访问控制机制，可以实现一个合适的区块链。通过将账本实现为区块链的基本理念，为区块链技术开辟了巨大的潜力。
- en: 21.1 Fintech Applications
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1 金融科技应用
- en: We have already discussed Ripple which provides a solution for making international
    payments in an efficient and low cost manner. Ripple, however, does not use a
    blockchain. We mention a few other financial technology solutions which have already
    been proposed. These have features which can also be used for making international
    payments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过瑞波币（Ripple），它提供了一种高效且低成本的国际支付解决方案。然而，瑞波币并不使用区块链。我们提到了一些其他已经提出的金融科技解决方案。这些解决方案具有也可用于国际支付的功能特性。
- en: One of the leading investment banks, JPMorgan Chase & Co., has launched a product
    called Quorum, which is a permissioned blockchain. The design of Quorum is based
    upon Ethereum with some differences. The basic difference, of course, is that
    Quorum is a permissioned blockchain, meaning that not everybody can join the network.
    The nodes of the network are people who have been verified and authenticated by
    the network authority. A major consideration for banks is the privacy of transactions.
    Quorum provides support for both public and private transactions. The innovation
    is to support private transactions without breaking the blockchain. Another more
    technical difference is that unlike Ethereum, the consensus mechanism in Quorum
    uses voting.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 领先的投资银行之一，摩根大通公司（JPMorgan Chase & Co.）推出了一款名为Quorum的产品，这是一个许可的区块链。 Quorum的设计基于以太坊，并有一些不同之处。当然，基本区别在于Quorum是一个许可的区块链，意味着不是每个人都可以加入网络。网络的节点是经过验证和认证的人员，由网络授权机构进行。银行的一个重要考虑因素是交易的隐私性。Quorum支持公共和私人交易。创新之处在于支持私人交易而不会破坏区块链。另一个更技术上的区别是，与以太坊不同，Quorum中的共识机制使用投票。
- en: A recently formed company called R3 leads an industry consortium. R3 has launched
    a product called Corda which is a distributed ledger solution geared specifically
    towards the financial world. Corda does not use a blockchain. In this aspect,
    it is similar to Ripple, though the background technology for the two systems
    is different. The goal of Corda is to provide a platform with some basic services
    so that other services can be built on top of the platform in a manner which is
    compatible between the network participants.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最近成立的一家名为R3的公司领导着一个行业联盟。 R3推出了一款名为Corda的产品，这是一个专门面向金融界的分布式分类账解决方案。 Corda不使用区块链。在这方面，它类似于瑞波币（Ripple），尽管两个系统的背景技术不同。Corda的目标是提供一个具有一些基本服务的平台，以便其他服务可以在平台上进行构建，并且网络参与者之间的兼容性。
- en: IBM Blockchain is a blockchain-based solution for the financial industry. This
    includes banking and in particular cross-border payments. MasterCard Blockchain
    is another solution for the payment industry.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Blockchain是面向金融行业的基于区块链的解决方案。这包括银行业，特别是跨境支付。万事达卡（MasterCard）区块链是支付行业的另一个解决方案。
- en: As a response to various distributed ledger technologies (blockchain or otherwise),
    the previous global leader in cross-border payments, SWIFT, has launched a new
    product called the Global Payment Initiative (GPI). This does not use distributed
    ledger and is instead built upon the existing SWIFT technology. In the coming
    years, it remains to be seen how the hugely lucrative market of international
    payment plays out.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对各种分布式账本技术（区块链或其他技术）的响应，之前全球跨境支付的领导者 SWIFT 推出了一款名为全球支付倡议（GPI）的新产品。这款产品并不使用分布式账本技术，而是基于现有的
    SWIFT 技术构建的。在未来几年，国际支付这一巨大利润的市场将如何发展，仍有待观察。
- en: 21.2 Logistics Management
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2 物流管理
- en: Traditionally logistics requires intermediaries whose role is to verify, maintain
    and forward records. The presence of such intermediaries pushes up the cost and
    the delay in the processing of the paperwork. A prime example is the shipping
    industry. The processing of paperwork for international container shipping can
    take many days, resulting in major delays. The distributed ledger technology based
    upon blockchain has the potential to cut through the dense formalities and significantly
    speed up the entire logistics processing. IBM and Maersk have teamed up to develop
    a blockchain solution for the shipping industry. As competition, five ocean shipping
    lines and four terminal operators have teamed up to form the Global Shipping Business
    Network (GSBN) which will provide blockchain-based solution to the logistics management
    problem in the shipping industry.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，物流需要中间商来验证、维护和转发记录。这些中间商的存在会增加成本，延迟文档处理时间。一个典型的例子是航运业。国际集装箱航运的文档处理可能需要数天时间，导致重大延误。基于区块链的分布式账本技术有可能突破繁琐的手续，显著加快整个物流处理过程。IBM
    和马士基已经联手为航运业开发了区块链解决方案。作为竞争，五家海洋航运公司和四家码头操作公司已经组成了全球航运业务网络（GSBN），将为航运业的物流管理问题提供基于区块链的解决方案。
- en: 21.3 Supply Chain Management
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3 供应链管理
- en: Today, leading companies run supply chain management and enterprise resource
    planning (ERP) software for managing their supply chains. These software allow
    products to be tracked from their origins to the final form. There are, however,
    periods when companies have limited visibilities of the products. Such scenarios
    arise due to gaps between different systems within a company as well as across
    companies. Existing technology provides mechanism for bridging such gaps, but,
    due to lack of complete synchronisation, it is possible that the same product
    appears to be at two places at the same time. This violates a basic requirement
    of inventory management.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，领先的公司使用供应链管理和企业资源计划（ERP）软件来管理他们的供应链。这些软件允许从产品的起源追踪到最终形态。然而，有时公司可能对产品的可见性有所限制。这种情况是由于公司内部和公司之间不同系统之间存在差距导致的。现有技术提供了弥合这些差距的机制，但是由于缺乏完全的同步，可能导致同一产品在同一时间出现在两个地方。这违反了库存管理的基本要求。
- en: Over the years, global supply chains have become part of a huge ecosystem rather
    than being part of a vertically integrated company. Also, supply chains have become
    more dynamic with shorter product life cycles. These issues have accentuated the
    gaps in the existing software solutions for supply chain management.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，全球供应链已成为庞大生态系统的一部分，而不再是垂直一体化公司的一部分。此外，供应链由于产品生命周期缩短而变得更加动态。这些问题突显了现有供应链管理软件中存在的差距。
- en: It is in this context that blockchain-based distributed ledger technology has
    the potential to deliver substantial benefits. The blockchain is to be used as
    a ledger for transactions which record movement of products. For one thing, this
    will prevent an item appearing simultaneously at two places. The visibility of
    all the parts and the entire product will be clear from the blockchain. Sharing
    the same blockchain with all entities of the supply chain ecosystem will eliminate
    the intercompany gaps. Further, a blockchain will provide immediate proof about
    how various goods were obtained and their compliance with necessary regulations.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术在这一背景下具有提供实质性好处的潜力。区块链被用作记录产品流动的交易账本。首先，这将防止物品同时出现在两个地方。所有零部件和整个产品的可见性将从区块链清晰可见。与供应链生态系统的所有实体共享同一区块链将消除公司间的差距。此外，区块链将立即提供关于各种商品获取方式以及它们是否符合必要法规的证据。
- en: BHP, the largest mining company in the world, has announced that it will use
    blockchain to record movements of wellbore rock and fluid samples and to better
    secure the real-time data that are generated during delivery. IBM has also announced
    a blockchain-based solution for the supply chain industry.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最大的矿业公司BHP宣布将使用区块链记录油井岩石和流体样品的流动，并更好地保护在交付过程中生成的实时数据。IBM也宣布了一种基于区块链的供应链解决方案。
- en: 21.4 Governance
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4 治理
- en: A government is duty-bound to provide certain services to the citizens. Such
    services are to be provided in a transparent and accountable manner and at the
    same time ensure the enforcement of any possible service delivery guarantee. Examples
    of government services would include access to property records, birth/death/marriage
    registration, delivery of subsidies and access to information. All these require
    maintaining some kind of records by various governmental agencies. A typical bureaucratic
    process often delays the processing and access to information that may be required
    by citizens. It is in this aspect that blockchain-based digital technology provides
    very promising resolution. At a very broad level, uploading documents to the blockchain
    ensures their integrity, persistence and availability.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 政府有责任向公民提供某些服务。这些服务应该以透明和负责任的方式提供，并同时确保对可能的服务交付保证的执行。政府服务的例子包括访问财产记录、出生/死亡/婚姻登记、补贴发放和信息获取。所有这些都需要各种政府机构维护某种记录。典型的官僚程序经常会延迟公民可能需要的处理和信息获取。正是在这个方面，基于区块链的数字技术提供了非常有前景的解决方案。在非常广泛的层面上，将文档上传到区块链确保了它们的完整性、持久性和可用性。
- en: While the idea of blockchain-based e-governance has a great deal of potential,
    till date there have been no significant implementations. One possible reason
    is that moving to a blockchain-based solution will be a huge technological step
    for both governmental offices and the citizens. There has to be significant preparatory
    work in the society before such a move can take place. Another reason is possible
    lack of interest in such a move from the government itself. While governments
    over the world are interested in cutting costs, unless forced they are unwilling
    to take steps which make governance accountable and transparent. Blockchain technology
    will indeed cut costs, but it will also at the same time introduce accountability
    and transparency.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于区块链的电子治理的想法具有巨大的潜力，但至今还没有重大的实施。一个可能的原因是，转向基于区块链的解决方案对政府机构和公民来说将是一个巨大的技术进步。在这样的举措发生之前，社会上必须进行重要的准备工作。另一个原因是政府本身对此类举措可能缺乏兴趣。尽管世界各地的政府都有兴趣削减成本，但除非被迫，否则他们不愿采取使治理具有问责性和透明度的举措。区块链技术的确会降低成本，但同时也会引入问责性和透明度。
