- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_16](https://doi.org/10.1007/978-1-4842-7480-4_16)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者，独家许可给 APress Media, LLC，Springer Nature 公司的一部分 2022J. T. George介绍区块链应用[https://doi.org/10.1007/978-1-4842-7480-4_16](https://doi.org/10.1007/978-1-4842-7480-4_16)
- en: 16. Blockchain Technology and Distributed System Future Scope and B-Coin Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 区块链技术和分布式系统的未来展望及 B-Coin 项目
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joseph Thachil George^([1](#Aff2))(1)意大利罗马
- en: Blockchain systems have attracted various industry stakeholders, including those
    in finance, healthcare, utilities, real estate, and government, since it solves
    many security problems in distributed systems. Public blockchains will play a
    significant role in cyber-security and Internet of Things (IoT) security as the
    commercial, government, and military sectors become more comfortable with it.
    At the same time, security and privacy problems in public blockchains will need
    to be addressed before they can be incorporated into existing core cloud and IoT
    devices.^([1](#Fn1))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链系统吸引了各行各业的利益相关者，包括金融、医疗保健、公用事业、房地产和政府部门，因为它解决了分布式系统中的许多安全问题。随着商业、政府和军事部门对其越来越习惯，公共区块链将在网络安全和物联网（IoT）安全中发挥重要作用。与此同时，公共区块链中的安全和隐私问题需要在将其纳入现有核心云和物联网设备之前解决。
- en: The development of blockchain systems will bring new concerns linked to the
    Internet of Smart Things, including trust, security, and privacy. Academia and
    business are collaborating to create blockchain platforms to address these urgent
    cloud and IoT security issues.¹
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链系统的发展将带来与智能物联网相关的新问题，包括信任、安全和隐私。学术界和商界正在合作创建区块链平台，以解决这些紧迫的云和物联网安全问题。
- en: We now know that blockchain platforms address issues such as cloud-based data
    proofing, information sharing, cloud storage, smart vehicles, IoT mass transit
    security, attack surface analysis, double spending prevention, trustless platform
    security, failure consensus protocols, statistics, and performance measures in
    cloud and IoT systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，区块链平台解决了诸如基于云的数据验证、信息共享、云存储、智能车辆、物联网大众交通安全、攻击面分析、双重花费预防、无信任平台安全、故障一致性协议、统计和性能测量等问题。
- en: Military and commercial organizations have also used cloud technology to enable
    data storage, on-demand computation, and dynamic provisioning. Cloud services’
    ecosystems are diverse and dynamic. They necessitate interoperability since they
    incorporate multiple hardware and software components from several suppliers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 军事和商业组织也利用云技术实现数据存储、按需计算和动态配置。云服务的生态系统多样而动态。它们需要互操作性，因为它们集成了来自多个供应商的多个硬件和软件组件。
- en: 16.1 Blockchain and IoT Security
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 区块链与物联网安全
- en: Vehicles, infrastructures, home monitors, smart healthcare imaging, and wearable
    electronics have all embraced the Internet of Things (IoT) as the principal way
    to optimize interconnectedness between the cyber and physical worlds. In the IoT
    context, security is still a major problem. Despite considerable advancements
    in security in the area of information technology in recent years, security at
    the application level remains an open research issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆、基础设施、家庭监控、智能医疗成像和可穿戴电子产品都已将物联网（IoT）视为优化网络化连接的主要方式，将网络和物理世界连接起来。 在物联网环境中，安全仍然是一个主要问题。
    尽管近年来在信息技术安全领域取得了相当大的进展，但在应用程序级别的安全仍然是一个开放的研究问题。
- en: 16.1.1 Blockchain Implementations and Use Cases in IoT
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 物联网中的区块链实施和用例
- en: The distributed ledger technology  that underpins cryptocurrency, particularly
    Bitcoin, is known as blockchain. It’s already being used in a number of industries,
    notably in retail to move items through supply chains more easily and securely,
    and in medicine to preserve the integrity of contracts, clinical studies, and
    the medications themselves.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 支撑加密货币，尤其是比特币的分布式账本技术被称为区块链。 它已经被广泛应用于许多行业，尤其是在零售业，以更轻松、安全地运送商品，并且在医学领域保持合同、临床研究和药物本身的完整性。
- en: The quality of the products is constantly checked by incorporating blockchain
    into these and other industries. A blockchain-focused research center has also
    been formed to encourage the development and commercialization of the technology
    and its potential to transform the IoT ecosystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将区块链纳入这些行业以及其他行业，产品的质量得到了持续检查。 还成立了一个专注于区块链的研究中心，以鼓励技术及其潜力对物联网生态系统进行转型的发展和商业化。
- en: 16.1.2 Challenges with Integrating Blockchain Into IoT
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 将区块链整合到物联网中的挑战
- en: The IoT blockchain is gaining traction, but it is not without its challenges.
    To begin, the blockchain’s central idea is the chain of activities that have been
    completed. The chain is created by storing a reference to earlier operations,
    which are referred to in Bitcoin as *blocks* . Creating blocks, on the other hand,
    is a computationally expensive task that necessitates several processors and a
    significant amount of time. Because it’s tough to make a single block, manipulating
    it would be far more complex—you’d have to fake the preceding block and then follow
    the chain you made to modify it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网区块链正在引起关注，但并非没有挑战。 首先，区块链的核心思想是已完成的活动链。 该链通过存储对先前操作的引用来创建，在比特币中称为*块* 。 另一方面，创建块是一项计算成本高昂的任务，需要多个处理器和大量时间。
    由于很难制造一个单一的块，因此操纵它将更加复杂——您必须伪造前面的块，然后按照您制作的链来修改它。
- en: 16.2 Safety Recommendations
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 安全建议
- en: If properly managed, blockchain can significantly reduce costs and improve efficiency
    in IoT systems. However, technological adoption in IoT-enabled workplaces is far
    from ideal. Only 10% of blockchain ledgers in operation, for instance, are expected
    to integrate embedded technologies by 2020\. Additionally, most IoT systems have
    a long way to go before they are computationally capable of handling the load.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果得到正确管理，区块链可以显著降低物联网系统的成本并提高效率。然而，物联网启用的工作场所在技术上的采用还远远不够理想。例如，到2020年，预计只有10%的区块链账本将集成嵌入式技术。此外，大多数物联网系统在计算能力上还有很长的路要走，才能处理这样的负载。
- en: 'IoT users, both people and companies, should seek multi-layered security with
    end-to-end security that spans from the gateway to the endpoint and is capable
    of preventing potential network attacks and compromises, in addition to timely
    software upgrades to avoid downtime. This includes the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网用户，包括个人和公司，应该寻求多层次的安全性，端到端的安全性应该从网关延伸到端点，能够防止潜在的网络攻击和妥协，此外还要及时进行软件升级以避免停机。这包括以下几点：
- en: '**Changing the default credentials**. IoT botnets have been found to use manufacturer
    default credentials to connect to linked devices. To decrease the danger of a
    device breach, it is advised that users enable secure passwords and use unique
    and complicated passwords.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改默认凭证**。已发现物联网僵尸网络使用制造商默认凭证连接到相关设备。为了降低设备被攻击的危险，建议用户启用安全密码并使用独特而复杂的密码。'
- en: '**Strengthening the router’s security**. A network is made susceptible by a
    weak router. Using security management solutions to protect routers helps users
    keep track of all devices connected while protecting privacy and productivity.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加强路由器的安全性**。一个弱势路由器会使网络变得容易受攻击。使用安全管理解决方案来保护路由器，有助于用户跟踪所有连接的设备，同时保护隐私和生产力。'
- en: '**Configuring security devices**. The device’s default settings must be evaluated
    and modified to meet the needs of the user. To improve security, it’s a good idea
    to personalize features and turn off those that aren’t needed. Keep an eye on
    the network traffic. Actively monitoring for unusual behavior on the Internet
    can assist consumers in avoiding harmful efforts. Real-time scanning provided
    by security solutions may also be used to identify malware automatically and effectively.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置安全设备**。必须评估并修改设备的默认设置以满足用户的需求。为了提高安全性，最好个性化功能并关闭不需要的功能。密切关注网络流量。积极监视互联网上的异常行为，有助于消费者避免有害攻击。安全解决方案提供的实时扫描也可用于自动识别和有效地清除恶意软件。'
- en: '**Implementing additional security measures**. For extra protection, users
    should activate firewalls and use the Wi-Fi Protected Access II security protocol.
    Web reputations and application control-based technologies also give greater network
    visibility.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施额外的安全措施**。为了额外的保护，用户应该激活防火墙并使用Wi-Fi保护接入II安全协议。基于网络声誉和应用程序控制的技术还能提供更高的网络可见性。'
- en: 16.3 Blockchain Security and Privacy
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链安全与隐私
- en: Security and privacy threats can be exploited on blockchain networks. Several
    chapters characterize attack surfaces, identify vulnerabilities in consensus protocols,
    discuss privacy and security threats to blockchain without and with required authorization,
    diagnose problems to defend against duplicate spending, and isolate effective
    defenses adopted by blockchain technology or proposed by researchers to mitigate
    the risks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安全和隐私威胁可以在区块链网络上被利用。几个章节描述了攻击面，识别了共识协议中的漏洞，讨论了在没有和有必要授权的情况下对区块链的隐私和安全威胁，诊断了防止重复支出的问题，并隔离了区块链技术采用或研究人员提出的有效防御措施以减轻风险。
- en: Through cryptography, there is blockchain-based document ownership of all existing
    currencies inside a cryptocurrency ecosystem at any one time. A transaction is
    stored in a “block” on the blockchain once it has been confirmed and cryptographically
    verified by other network members or nodes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过密码学，在任何时候都有基于区块链的加密货币生态系统内所有现有货币的文档所有权。一笔交易一旦得到其他网络成员或节点的确认和密码验证后，就会被存储在区块链上的一个“块”中。
- en: The timing of the transaction, prior transactions, and transaction details are
    all stored in a block. Events are kept chronologically and cannot be altered after
    they have been entered as a block. Since the birth of Bitcoin and the initial
    use of blockchain technology, this technology has stimulated the development of
    additional cryptocurrencies and applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的时间、先前的交易和交易细节都存储在一个区块中。事件按时间顺序保存，并且一旦被输入为一个区块，就不能被修改。自比特币诞生和区块链技术最初的使用以来，这项技术已经刺激了其他加密货币和应用的发展。
- en: Data is not validated and controlled by a single organization, as in traditional
    systems, due to decentralization. Rather, every node or computer connected to
    the network verifies the authenticity of transactions. Cryptography secures and
    verifies transactions and data in the blockchain technology.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于去中心化，数据不是由单一组织验证和控制，如传统系统那样。相反，连接到网络的每个节点或计算机都验证交易的真实性。密码学在区块链技术中保护和验证交易和数据。
- en: Data breaches have grown more prevalent as the use of technology has increased.
    Personal data and information are stored, abused, and misused, posing a danger
    to privacy. Numerous people are advocating for blockchain technology to be widely
    used because it can increase user privacy, data security, and data ownership.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的使用增加，数据泄露变得更加普遍。个人数据和信息被存储、滥用和误用，构成了对隐私的危险。许多人主张广泛使用区块链技术，因为它可以提高用户隐私、数据安全和数据所有权。
- en: 16.4 The Future Scope
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 未来展望
- en: Despite the fact that there are numerous blockchain systems on the market and
    that substantial research and development is being done on specific blockchain
    aspects, additional study in the following categories is required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管市场上有大量的区块链系统，并且正在对特定的区块链方面进行大量的研究和开发，但还需要进一步研究以下类别。
- en: '16.4.1 Blockchain Architecture: Private, Public, or Hybrid-Public Blockchain
    Design'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.1 区块链架构：私有、公共或混合-公共区块链设计
- en: Transactions are conducted in a decentralized manner. Commercial businesses,
    on the other hand, are wary of incorporating a public blockchain into their corporate
    solutions, due to worries about privacy, performance, and reaction time. To solve
    these problems, more R&D in the public blockchain system is required.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 交易以分散的方式进行。另一方面，商业企业对将公共区块链纳入其企业解决方案持谨慎态度，原因是担心隐私、性能和反应时间。为了解决这些问题，需要在公共区块链系统中进行更多的研发工作。
- en: Meanwhile, corporate players are moving closer to private/approved consensus
    mechanisms. Depending on the type of governance, this architecture might range
    from a single member to a consortium that controls the blockchain platform. The
    architecture, protocol, or method by which transactions are verified on these
    blockchain platforms has administrative components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，企业参与者正在向私有/批准的共识机制靠拢。根据治理类型的不同，这种架构可能从单一成员延伸到控制区块链平台的财团。这些区块链平台上验证交易的架构、协议或方法具有行政组件。
- en: 16.4.2 Inducement
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.2 诱因
- en: In Bitcoin, there is a monetary incentive to join the blockchain platform; however,
    there are no monetary incentives in use cases like provenance and identity management.
    To achieve maximum involvement, the incentive structure must be included in the
    protocol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，加入区块链平台有经济激励；然而，在溯源和身份管理等使用案例中没有经济激励。为了实现最大的参与度，激励结构必须包含在协议中。
- en: To guarantee that blockchain protocols function to maximize advantages for the
    use case, mechanisms for incentive design may be generated from use cases. While
    trust management of the public blockchain may prevent manipulations or fraud,
    it is critical that the architecture incorporate incentive mechanisms with anti-fraud
    or anti-justice qualities. The processes involved in motivating participation
    need the development of theoretical models.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保区块链协议能够最大程度地发挥使用案例的优势，可以从使用案例中生成激励设计的机制。尽管公共区块链的信任管理可能会防止操纵或欺诈，但至关重要的是，架构需要纳入具有防欺诈或反公正特性的激励机制。激励参与的过程需要开发理论模型。
- en: 16.4.3 Data Privacy
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.3 数据隐私
- en: Because blockchain transactions are public, data analysis techniques may be
    used to analyze the vast quantities of data included inside them. The identities
    of participants and the precise transactions they have done might be revealed
    as a result of this research. Stealth addresses, homomorphic cryptography, and
    zero-knowledge proof are among the approaches used to solve privacy problems in
    public blockchain systems. A mix of approaches is necessary to obtain the appropriate
    level of anonymity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链交易是公开的，数据分析技术可以用来分析其中包含的大量数据。通过这项研究，参与者的身份以及他们进行的具体交易可能会被揭示出来。在公共区块链系统中解决隐私问题的方法包括隐形地址、同态加密和零知识证明。需要采用多种方法来获得适当的匿名水平。
- en: 16.5 Having Realistic Expectations of Blockchain
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 对区块链的现实期望
- en: Blockchain technology has been gaining attention for some time, and it can perhaps
    be said that despite being a complex technology, it has become a “mainstream”
    theme. Blockchain technology issues have been addressed by large newspapers, radios,
    and television shows that normally rarely focus on such innovative technologies.
    In many cases, blockchain technology is proposed as “the solution” to problems
    and needs that have never been truly satisfied by traditional technology. The
    expectations, not only of companies but of consumers, on blockchain technology
    have greatly increased. On the one hand, this situation favors debate and growth,
    but on the other hand it creates a dangerous situation because some of the “beneficial
    effects” “that today are attributed to blockchain technology are the result of
    misunderstandings. It is important to emphasize that blockchain technology cannot
    solve all our problems. The following sections discuss some of these issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术已经引起了一段时间的关注，可以说尽管它是一种复杂的技术，但已经成为了一个“主流”主题。一些通常很少关注这类创新技术的大型报纸、广播和电视节目已经开始涉及区块链技术的问题。在许多情况下，区块链技术被提出作为解决问题和需求的“方案”，而这些问题和需求以前从未真正被传统技术满足。对区块链技术的期望不仅来自公司，还来自消费者，这大大增加了。一方面，这种情况有利于辩论和增长，但另一方面，它也造成了一种危险的情况，因为一些“有益影响”实际上是由于对区块链技术的误解而产生的。重要的是要强调，区块链技术不能解决我们所有的问题。以下各节将讨论其中一些问题。
- en: 16.6 Food Certification
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 食品认证
- en: In the agri-food sector, blockchain technology has growing consensus, precisely
    because it can provide guarantees of reliability on often complex and fragmented
    supply chains, not only due to the size of the companies but because of the culture
    of the organizations or countries in which they are located. Blockchain technology
    guarantees the certainty, the immutability, and the transparency of the data that
    accompanies production.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在农业食品领域，区块链技术日益得到共识，这主要是因为它能够在通常复杂而分散的供应链上提供可靠性保证，这种可靠性不仅源于公司规模的大小，还有组织或国家的文化。区块链技术保证了伴随生产的数据的确定性、不可变性和透明性。
- en: We must not think that blockchain is, in itself, a guarantee of quality, which
    can “by itself” guarantee not only the certification but the quality of the product.
    Blockchain technology certifies the data and guarantees its identity and transparency
    for all ac-tors. But if the original data does not correctly represent the product
    that goes into production, if that data is “wrong” to begin with, blockchain technology
    does not correct it. On the contrary, blockchain ensures that that “wrong” data
    is kept intact throughout the supply chain. As they say, “garbage in, garbage
    out”.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应认为区块链本身就是质量的保证，它可以“单独”保证不仅认证而且产品的质量。区块链技术对数据进行认证，并为所有参与者保证其身份和透明度。但是，如果原始数据不正确地代表了投入生产的产品，如果该数据本身就是“错误的”，那么区块链技术就无法更正它。相反，区块链确保了该“错误”的数据在整个供应链中保持不变。正如人们所说，“垃圾进，垃圾出”。
- en: The transparency of blockchain is a possible corrective, because everyone can
    see that the data and everyone can (if they are able to do so) ascertain its value
    and propose a correction. Blockchain technology guarantees the process of managing
    that data for all participants.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的透明性可能是一种可能的纠正措施，因为每个人都可以看到数据，并且每个人都可以（如果他们能够做到的话）确定其价值并提出更正。区块链技术保证了所有参与者管理数据的过程。
- en: 16.7 Smart Contracts and Notaries
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.7 智能合约与公证人
- en: '*Smart contracts* can cause some confusion when compared to the discipline
    of the traditional contract. However, by briefly reviewing the essential requirements
    of the contract governed by civil code, it is easy to identify numerous similarities
    that could constitute the legal basis for assimilating smart contracts into the
    discipline of the traditional contract.^([2](#Fn2))'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能合约*与传统合同学科相比可能会引起一些混淆。然而，通过简要回顾由民法管辖的合同的基本要求，很容易发现许多相似之处，这些相似之处可能构成将智能合约纳入传统合同学科的法律基础。^([2](#Fn2))'
- en: It is possible to state that the space of operation of this principle coincides
    with the space of operation of private autonomy; as an agreement, the contract
    is by definition a bilateral act. However, there are possible unilateral acts
    that can be classified in the contractual legal regime. In this case, they are
    non-intrusive unilateral acts of the legal sphere, as they “leave intact the power
    of the subject involved to totally self-determine with respect to the situation
    created.”^([3](#Fn3)) Examples of these types of contracts are power of attorney,
    wills, and waivers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这一原则的操作空间与私人自治的操作空间重合；作为一项协议，合同从定义上是一种双边行为。然而，存在可能分类为合同法律制度的单方行为。在这种情况下，它们是法律领域的非侵入性单方行为，因为它们“完全保留了相关主体就所产生情况进行自我决定的权力。”^([3](#Fn3))
    这些类型的合同的例子包括委托书、遗嘱和放弃权。
- en: 16.7.1 Applying Blockchain Technology to Smart Contracts
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7.1 将区块链技术应用于智能合约
- en: At this junction, a quick description of how blockchain technology pertains
    to a smart contract and how a contract might physically assume a directly technical
    shape, as opposed to natural language, is required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交汇点，需要简要描述区块链技术如何与智能合约相关，以及合约如何可能在物理上呈现出直接的技术形态，而不是自然语言。
- en: 'Preliminarily, it’s important to note that the parties’ involvement is plainly
    required at the outset. The parties will decide the contract’s conditions by mutual
    agreement. The core of the structure may be considered to be made up of three
    major elements: the account (also known as the parties’ identity), the assets
    you have (assets), and the contract.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要明确指出各方的参与在开始阶段是必需的。各方将通过相互协议决定合约的条件。结构的核心可被认为是由三个主要元素组成的：账户（也称为各方的身份）、您拥有的资产（资产）和合约。
- en: We use the term “account” to refer to an address that may be used to identify
    a person, entity, or group of individuals who will proceed to interact with the
    ledger in question, the so-called “ledger” of which we spoke previously in the
    chapter. Instead, products, often known as “assets,” contain both tangible and
    intangible items, as well as invoices and units of value transferred.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语“账户”来指代一个地址，该地址可用于识别将与所讨论的账本进行交互的人、实体或一组个人，即我们在本章前面提到的所谓“账本”。相反，产品通常被称为“资产”，包括有形和无形的物品，以及发票和转移的价值单位。
- en: Assets can be defined more broadly as a collection of values traded and held
    by one or more parties that have access to the cryptographic key that permits
    a contract to be settled. The contract, defined as a logical series of activities
    that mediates the transfer of cash and data between the parties, is the final
    prerequisite (accounts).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 资产可以更广泛地定义为一组由一个或多个具有访问密码密钥的一方持有和交易的价值集合，该密钥允许合约结算。合约被定义为一系列逻辑活动，它在各方之间调解现金和数据的转移，是最后一个先决条件（账户）。
- en: These accounts change their status by sending updates to the master register,
    which include approved transactions. Before being collected and sequenced into
    a block, transactions are transmitted and validated for their integrity and for
    data integrity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些账户通过向主注册表发送更新来改变它们的状态，其中包括经过批准的交易。在被收集并排序到一个块之前，交易会被传输并验证其完整性和数据完整性。
- en: 'The account holder on the network digitally signs all transactions on the ledger.
    This gives the ledger three key characteristics that distinguish it from traditional
    network traffic:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的账户持有者在账本上对所有交易进行数字签名。这使得账本具有三个与传统网络流量不同的关键特征：
- en: Authentication as part of harmful activity cannot be misrepresented as utilizing
    an account that isn’t a part of the transaction if it isn’t.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证作为有害活动的一部分不能被误认为是利用不参与交易的账户。
- en: The transaction’s integrity, because the receipt of the transaction cannot be
    altered once it has occurred.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的完整性，因为一旦发生交易，其收据就无法更改。
- en: Non-malleability, because any modifications to the transaction will invalidate
    the issuer’s signature and render the transaction void.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可篡改性，因为对交易的任何修改都将使发行者的签名无效并使交易无效。
- en: Before being added to the chain, each provision is negotiated and accepted by
    both parties. Once the clause has been accepted, it is placed into the first block
    and converted from plain language to an encrypted language that the system can
    understand.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加到链中之前，每个条款都是由双方协商和接受的。一旦条款被接受，它就会被放入第一个区块，并转换为系统可以理解的加密语言。
- en: The parties’ real actions are to input, using their cryptographic keys, both
    the clauses intended to perform the contract and the actions that the system will
    carry out automatically in the case of a breach. The contract will advance if
    the system records the fulfillment of the fact referred to in the clause; if,
    on the other hand, the clause’s content is broken, the contract will use technologies
    that make the remedies given by the parties individually or by law.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 各方的实际行动是使用他们的加密密钥输入既用于执行合同的条款，也用于系统在发生违约时自动执行的操作。如果系统记录了条款所述事实的实现，合同将继续进行；如果条款内容被破坏，合同将使用技术，这些技术使得各方或法律单独给出的补救措施。
- en: It will not be feasible to utilize the “backup” method if you find yourself
    in a scenario where one party claims to have a contract with certain provisions
    and the other claims to have the same contract, but with different clauses. The
    blockchain, like other everyday technology such as mobile phones and computers,
    has a data storage mechanism.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于一种情况下，其中一方声称与某些条款的合同，而另一方声称具有相同的合同，但有不同的条款，则无法利用“备份”方法。区块链，像手机和计算机等其他日常技术一样，具有数据存储机制。
- en: No doubt, smart contracts based on blockchain technology can bring enormous
    benefits to companies, organizations, and public administrations. The prospects
    are unquestionable and sectors such as insurance, logistics, and procurement are
    already reaping important benefits from it. Here too there remains a point of
    utmost attention in the transition phase from the real, physical, and digital
    world, in the certainty of providing correct information by subjects, persons,
    or companies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，基于区块链技术的智能合同可以为公司、组织和公共管理带来巨大的利益。前景是毋庸置疑的，保险、物流和采购等行业已经从中获得了重要的好处。在从真实、物理和数字世界的过渡阶段中，提供正确信息的主体、个人或公司的确保是至关重要的。
- en: How to manage this passage the scenario is still open to debate. The function
    of the notary can play an important role in providing guarantees about secure
    data. Again, the blockchain does not ascertain the “truth” or quality of the information.
    The blockchain guarantees its incorruptibility, protects the data from possible
    violations, and transparently exposes changes to all the actors involved. In this
    way, blockchain speeds up any identification of “errors,” but it is not an “intelligent
    system” that can guarantee quality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如何管理这一过渡情况仍然有待辩论。公证人的作用可以在提供关于安全数据的保证方面发挥重要作用。再次强调，区块链不能确定信息的“真相”或质量。区块链保证了其不可腐败性，保护数据免受可能的违规行为，并向所有相关方透明地展示更改。通过这种方式，区块链加快了对“错误”的识别，但它不是一个能够保证质量的“智能系统”。
- en: 16.7.2 Developing Blockchain in the Market
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7.2 在市场中发展区块链
- en: Blockchain technology  is a recent phenomenon that has experienced an important
    series of accelerations and that has created many expectations. At the same time,
    developing and implementing blockchain is not an easy task and no single company
    can make it happen. For everyone—producers and companies and user organizations—blockchain
    is an ecosystem phenomenon, of a collaborative type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术是一个近期出现的现象，经历了重要的一系列加速，并产生了许多期望。与此同时，开发和实施区块链并不是一件容易的事情，没有哪个单一的公司能够实现这一目标。对于每个人——生产者、公司和用户组织——区块链都是一种协作型生态系统现象。
- en: If, on the one hand, the level of attention that accompanies blockchain is very
    high, on the other hand, the number of concrete cases, of projects actually in
    production in companies and organizations, is still quite low.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，伴随区块链的关注程度非常高，另一方面，实际在公司和组织中生产的具体案例数量还相当有限。
- en: 16.7.3 The Geopolitics of the Blockchain
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7.3 区块链的地缘政治
- en: Blockchain  has the characteristics of a revolution, and it also has disruptive
    characteristics, which can be destabilizing. For this and other reasons, there
    are very different ways of approaching the blockchain technology. There are countries
    or geographical areas that have embraced it (such as Dubai, Estonia, and Singapore),
    and there are countries that are taking a very careful and pragmatic approach,
    for example with an intense study of new regulations appropriate to management
    of such an innovative phenomenon (such as Switzerland, Austria, and Malta).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链具有革命性的特征，同时也具有颠覆性的特点，可能会造成不稳定。出于这个原因以及其他原因，人们对待区块链技术的方式各不相同。有些国家或地区已经拥抱了它（例如迪拜、爱沙尼亚和新加坡），而有些国家则采取非常谨慎和务实的方式，例如对于这种创新现象的管理适用新规定进行深入研究（例如瑞士、奥地利和马耳他）。
- en: Then there is Europe, which is looking for its own dimension and is doing so
    with a series of initiatives, including the European Blockchain Partnership. There
    are also countries that are looking at blockchain with skepticism.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是欧洲，它正在寻找自己的维度，并通过一系列举措来实现这一点，其中包括欧洲区块链合作伙伴关系。也有一些国家对区块链持怀疑态度。
- en: 16.7.4 Books, Whitepapers, and Blockchains
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7.4 书籍、白皮书和区块链
- en: With blockchain, an intense activity of publication, study, and in-depth analysis
    began with a rich publication of books and whitepapers. In the blockchain books
    section, you will find books specifically related to blockchain. In the books
    and whitepapers section, you will find information about the potential of Industry
    4.0 and digital transformation, including selected texts related to the issues
    of digital transformation in companies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有了区块链，一个密集的出版、研究和深度分析活动开始了，有大量的书籍和白皮书出版。在区块链书籍部分，你会找到专门与区块链相关的书籍。在书籍和白皮书部分，你会找到关于工业4.0和数字化转型潜力的信息，包括与公司数字化转型问题相关的一些选定文本。
- en: 16.8 Bitcoin (B-Coin) Sample Project
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.8 比特币（B-Coin）示例项目
- en: 'This project illustrates a cryptocurrency implemented in Python on top of blockchain
    technology. It is a simple blockchain cryptocurrency and should be used only for
    educational purposes. This blockchain network has no central authority. The information
    in it is open for everyone to see. Recall the main properties of blockchain technology:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目演示了一个在区块链技术之上用Python实现的加密货币。这是一个简单的区块链加密货币，仅供教育目的使用。这个区块链网络没有中央管理机构。其中的信息对所有人都是公开的。回顾一下区块链技术的主要特性：
- en: Decentralization
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化
- en: Transparency
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度
- en: Immutability
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: In this simple implementation of blockchain, B-Coin is built on top of the blockchain
    implementation. You can find more information in the original paper, found in
    the original Bitcoin repository at [https://github.com/bitcoin](https://github.com/bitcoin).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的区块链实现中，B-Coin是建立在区块链实现之上的。你可以在原始比特币存储库的原始论文中找到更多信息，网址为[https://github.com/bitcoin](https://github.com/bitcoin)。
- en: 'Here are the project’s requirements:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目的需求：
- en: Python 3.1 or 3.2
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.1 或 3.2
- en: Flask or Django
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 或 Django
- en: Requests
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Requests
- en: Postman
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman
- en: 16.8.1 The Project Code
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8.1 项目代码
- en: The following task is done using the code found in bitcoin.py. It has a class
    called blockchain. Note that this class creates blocks with five fields—index,
    timestamp, proof, previous_hash, and transactions. Additionally, we have a proof
    of work for mining the block. The goal is to have four leading zeros in the resultant
    hash. (See Listing [16-1](#PC2).)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的任务是使用在bitcoin.py中找到的代码完成的。它有一个名为blockchain的类。请注意，这个类创建的块有五个字段——索引、时间戳、证明、前一个哈希和交易。此外，我们还有一个用于挖掘区块的工作证明。目标是在结果哈希中有四个前导零。（见清单[16-1](#PC2)。）
- en: 'It has the following functions and methods: # add transactions # adding the
    node # replacing the chain with the longest chainIn addition to these methods
    , it has the POST and GET methods for managing blocks in the chain.*************#
    Creating a block chain**class Blockchain:*    *def __init__(self):*        *#
    our whole chain*        *self.chain=[]*        *# list of transactions*        *self.transactions
    = []*        *# genesis block*        *self.create_block(proof= 1 , previous_hash=''0'')*        *#
    nodes in the network should be unique*        *self.nodes = set()*    *"""*    *This
    class is for method is for creating block with five fields*    *index, timestamp,
    proof, previous_hash,transactions*    *"""*    *def create_block(self, proof,
    previous_hash):*        *block={''index'' : len(self.chain) + 1,*                *''timestamp''
    : str(datetime.datetime.now()),*                *''proof'' : proof,*                *''previous_hash''
    : previous_hash,*                *''transactions'' : self.transactions}*        *#
    empty the transactions after all are added to the block*        *self.transactions
    = []*        *self.chain.append(block)*        *return block*    *# Getting the
    old block*    *def get_previous_block(self):*        *return self.chain[-1]**#
    We have a proof of work for mining the block.**# The goal is to have four leading
    zeros in the resultant hash.*    *def proof_of_work(self,previous_proof):*        *new_proof
    = 1*        *check_proof = False*        *# create a hash and look if new_proof**2
    - previous_proof**2 has leading 4 0s else increment the proof and check*        *while
    check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof**#
    Hashing**# json. dumps() accepts a json object as input and returns a string.**#
    The hex() function returns a string after converting the string to bytes.*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *# Checking if a block is valid
    or not*    *def is_chain_valid(self, block):*        *previous_block = self.chain[0]*        *block_index=1*        *while
    block_index < len(self.chain):*            *block = self.chain[block_index]*            *#
    Check if the previous hash in the current block differs from the preceding block''s
    original hash.*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *# Check if the resultant hash of the proof**2 - previous_proof**2
    does not have 4 leading 0s*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *# update the block and increase the index*            *previous_block=block*            *block_index
    +=1*        *return True*    *# add transactions*    *# We''ll send it to Postman
    in json format as a sample request.*    *def add_transaction(self, sender, receiver,
    amount):*        *self.transactions.append({''sender'' : sender,*                           *''receiver''
    : receiver,*                           *''amount'' : amount})*        *previous_block
    = self.get_previous_block()*        *# return the index of the current block (+1
    for genesis block)*        *return previous_block[''index''] + 1*    *# adding
    the node*    *def add_node(self,address):*        *# parsed_url = urlparse(''http://127.0.0.1:1000/'')*        *#
    parsed_url.netloc - ''127.0.0.1:1000''*        *parsed_url = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *#
    replacing the chain with the longest chain*    *def replace_chain(self):*        *#
    taking all of our nodes*        *network = self.nodes*        *longest_chain =
    None*        *# max_length is set to the current length*        *max_length =
    len(self.chain)*        *# go through all of the nodes and see all of their chains*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *#
    if chain is valid*            *if response.status_code == 200:*                *#
    get its length and the chain*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *# if it has the length greater than
    the current length update the max_length and the longest chain*                *if
    length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *# if longest_chain
    is set chain the chain to the longest_chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**# Creating a web
    app**app = Flask(__name__)**# Creating a port 1000 address for the node.**# uuid4()
    generates a globally unique identifier at random (UUID - generated using synchronization
    methods that ensure no two processes can obtain the same UUID)**node_address =
    str(uuid4()).replace(''-'', '''')**# Putting together a blockchain**blockchain=Blockchain()**#
    Mining a block**@app.route(''/mine_block'', methods = [''GET''])**def mine_block():*    *"""**We''ll
    use the previous block''s proof to compute the new proof and build the current
    block using that proof and the prior hash.*    *"""*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *# We may award the bcoin if we mine a block.
    The miner who receives the block can be chosen.*    *blockchain.add_transaction(sender
    = node_address, receiver = ''Bharathi'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *# Return the response*    *response = {''message'' : ''You
    just mined a block, congrats!'',*                *''index'' : block[''index''],*                *''timestamp''
    : block[''timestamp''],*                *''proof'' : block[''proof''],*                *''previous_hash''
    : block[''previous_hash''],*                *''transactions'' : block[''transactions'']}*    *#
    With an application/json mimetype, return a JSON representation of the supplied
    parameters (Multipurpose Internet Mail Extensions or MIME type).*    *return jsonify(response),
    200**# Getting the blockchain**@app.route(''/get_chain'', methods = [''GET''])**def
    get_chain():*    *# Return the response*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**# Checking if the
    Blockchain is valid**@app.route(''/is_valid'', methods = [''GET''])**def is_valid():*    *is_valid
    = blockchain.is_chain_valid(blockchain.chain)*    *if is_valid:*        *response
    = {''message'': ''Everything is fine. The Blockchain is correct..''}*    *else:*        *response
    = {''message'': ''Weve got an issue. The Blockchain isnt trustworthy..''}*    *return
    jsonify(response), 200**# Adding a new transaction to the blockchain**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *# We''re sending the transactions
    to Postman in json format, thus we''ll get them back in json format.*    *json
    = request.get_json()*    *# checking if it contains all of the keys*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some elements of the transactions are missing'',
    400*    *# We will add the transaction and return the answer as added if it has
    all of the components.*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : fThis transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**# Our blockchain is becoming more decentralized.**#Connecting
    new nodes**@app.route(''/connect_node'', methods = [''POST''])**def connect_node():*    *#
    connecting all of the other nodes manually*    *json = request.get_json()*    *nodes
    = json.get(''nodes'')*    *# return none if node field is null*    *if nodes is
    None:*        *return ''No node'', 400**# We''ll manually add the nodes. This
    is repeated for each node.**# Because our nodes are a set, it will only include
    unique values if done separately for each node.*    *for node in nodes:*        *blockchain.add_node(node)*    *#
    show the nodes and mark the answer as all connected*    *response = {''message''
    : ''All of the nodes are now linked together. The node has now been added to the
    Bitcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *#
    http 201 created*    *return jsonify(response), 201**# Replacing the chain by
    the longest chain**@app.route(''/replace_chain'', methods = [''GET''])**def replace_chain():*    *#
    If any chain is longer, the longest chain will be displayed instead, otherwise
    the same chain will be displayed.*    *is_chain_replaced = blockchain.replace_chain()*    *if
    is_chain_replaced:*        *response = {''message'': ''Because the nodes are different,
    the longest chain is used to replace the chain..'',*                    *''new_chain''
    : blockchain.chain}*    *else:*        *response = {''message'': ''Everything
    is fine. The chain is the most*        *extensive.'', ''new_chain'' : blockchain.chain}*    *return
    jsonify(response), 200**# Running the app on the port**app.run(host = ''0.0.0.0'',
    port = 1001)********************************************************************************Listing
    16-1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '它具有以下功能和方法： # 添加交易 # 添加节点 # 用最长链替换链。除了这些方法之外，它还具有管理链中块的POST和GET方法。*************#
    创建区块链**class Blockchain:*    *def __init__(self):*        *# 整个链*        *self.chain=[]*        *#
    交易列表*        *self.transactions = []*        *# 创世区块*        *self.create_block(proof=
    1 , previous_hash=''0'')*        *# 网络中的节点应该是唯一的*        *self.nodes = set()*    *"""*    *此类用于创建具有五个字段的区块*    *索引，时间戳，证明，前一个哈希，交易*    *"""*    *def
    create_block(self, proof, previous_hash):*        *block={''index'' : len(self.chain)
    + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *# 在所有交易都添加到区块后清空交易*        *self.transactions =
    []*        *self.chain.append(block)*        *return block*    *# 获取上一个区块*    *def
    get_previous_block(self):*        *return self.chain[-1]**# 我们有一个工作证明来挖掘区块。**#
    目标是使结果哈希中有四个前导零。*    *def proof_of_work(self,previous_proof):*        *new_proof
    = 1*        *check_proof = False*        *# 创建哈希并查看新的证明**2 - previous_proof**2是否有前导4个零，否则增加证明并检查*        *while
    check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof**#
    哈希化**# json. dumps()接受json对象作为输入并返回一个字符串。**# hex()函数将字符串转换为字节后返回一个字符串。*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *# 检查区块是否有效*    *def is_chain_valid(self,
    block):*        *previous_block = self.chain[0]*        *block_index=1*        *while
    block_index < len(self.chain):*            *block = self.chain[block_index]*            *#
    检查当前块中的前一个哈希是否与前一个块的原始哈希不同。*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *# 检查证明**2 - previous_proof**2的结果哈希是否没有4个前导零*            *previous_proof
    = previous_block[''proof'']*            *proof = block[''proof'']*            *hash_operation
    = hashlib.sha256(str(proof**2 - previous_proof**2).encode()).hexdigest()*            *if
    hash_operation[:4] !=''0000'':*                *return False*            *# 更新区块并增加索引*            *previous_block=block*            *block_index
    +=1*        *return True*    *# 添加交易*    *# 我们将以json格式将其发送到Postman作为示例请求。*    *def
    add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *# 返回当前块的索引（+1用于创世块）*        *return
    previous_block[''index''] + 1*    *# 添加节点*    *def add_node(self,address):*        *#
    parsed_url = urlparse(''http://127.0.0.1:1000/'')*        *# parsed_url.netloc
    - ''127.0.0.1:1000''*        *parsed_url = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *#
    用最长链替换链*    *def replace_chain(self):*        *# 获取所有节点*        *network = self.nodes*        *longest_chain
    = None*        *# max_length设置为当前长度*        *max_length = len(self.chain)*        *#
    遍历所有节点并查看它们的所有链*        *for node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *#
    如果链有效*            *if response.status_code == 200:*                *# 获取其长度和链*                *length
    = response.json()[''length'']*                *chain = response.json()[''chain'']*                *#
    如果长度大于当前长度，更新max_length和最长链*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *# 如果最长链已设置，将链替换为最长链*        *if
    longest_chain:*            *self.chain = longest_chain*            *return True*        *return
    False**# 创建一个web应用**app = Flask(__name__)**# 为节点创建一个端口1000地址。**# uuid4()会随机生成一个全局唯一标识符（UUID-使用同步方法生成的UUID，确保没有两个进程可以获取相同的UUID）**node_address
    = str(uuid4()).replace(''-'', '''')**# 组合区块链**blockchain=Blockchain()**# 挖掘一个区块**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *"""**我们将使用先前的块的证明来计算新的证明，并使用'
- en: bitcoin.py
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: bitcoin.py
- en: The next Python files are bcoin-node-1001.py, bcoin-node-1002.py, and bcoin-node-1003.py.
    These files represent each node (Bitcoins 1001, 1002, and 1003).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 Python 文件是 bcoin-node-1001.py、bcoin-node-1002.py 和 bcoin-node-1003.py。这些文件分别代表每个节点（比特币
    1001、1002 和 1003）。
- en: 'bcoin-node-1001.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1001). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this, the main block has GET and POST methods (see Listing [16-2](#PC3)).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bcoin-node-1001.py：有一个名为 Blockchain 的类，用于管理区块链中的节点（或比特币节点-1001）。此外，它具有用于创建区块、添加交易和验证区块的函数。除此之外，主块还有
    GET 和 POST 方法（参见列表 [16-2](#PC3)）。
- en: 'bcoin-node-1002.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1002). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this , the main block has GET and POST methods (see Listing [16-3](#PC4)).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bcoin-node-1002.py：有一个名为 Blockchain 的类，用于管理区块链中的节点（或比特币节点-1002）。此外，它具有用于创建区块、添加交易和验证区块的函数。除此之外，主块还有
    GET 和 POST 方法（参见列表 [16-3](#PC4)）。
- en: 'bcoin-node-1003.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1003). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this, the main block has GET and POST methods (see Listing [16-4](#PC5)).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bcoin-node-1003.py：有一个名为 Blockchain 的类，用于管理区块链中的节点（或比特币节点-1003）。此外，它具有用于创建区块、添加交易和验证区块的函数。除此之外，主块还有
    GET 和 POST 方法（参见列表 [16-4](#PC5)）。
- en: 'The following code listings show Python codes for three different Bitcoins.*#
    This is the Python class for Blockchain**class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()**#Function for creating block*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True**#Function for adding transaction*    *def add_transaction(self, sender,
    receiver, amount):*        *self.transactions.append({''sender'' : sender,*                           *''receiver''
    : receiver,*                           *''amount'' : amount})*        *previous_block
    = self.get_previous_block()*        *return previous_block[''index''] + 1*    *def
    add_node(self,address):*        *parsed_url = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def
    replace_chain(self):*        *network = self.nodes*        *longest_chain = None*        *max_length
    = len(self.chain)*        *for node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Bharathi'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Congrats, you just mined a block!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**#Get method for
    blockchain**@app.route(''/get_chain'', methods = [''GET''])**def get_chain():*    *response
    = {''chain'' : blockchain.chain,*                *''length'' : len(blockchain.chain)}*    *return
    jsonify(response), 200* *#Validate method for blockchain**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct.''}*    *else:*        *response = {''message'': ''Weve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200* *#POST
    method for blockchain**@app.route(''/add_transaction'', methods = [''POST''])**def
    add_transaction():*    *json = request.get_json()*    *transaction_keys = [''sender'',
    ''receiver'', ''amount'']*    *if not all(key in json for key in transaction_keys):*        *return
    ''Some transactional components are missing.'', 400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201* *#Connect to the node**@app.route(''/connect_node'', methods
    = [''POST''])**def connect_node():*    *json = request.get_json()*    *nodes =
    json.get(''nodes'')*    *if nodes is None:*        *return ''No node'', 400*    *for
    node in nodes:*        *blockchain.add_node(node)*    *response = {''message''
    : ''All of the nodes are now linked together. The node has now been added to the
    Bitcoin blockchain'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201* *#method for changing mode**@app.route(''/replace_chain'',
    methods = [''GET''])**def replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if
    is_chain_replaced:*        *response = {''message'': ''Because the nodes are different,
    the longest chain is used to replace the chain..'',*                    *''new_chain''
    : blockchain.chain}*    *else:*        *response = {''message'': ''Everything
    is fine. The Blockchain is correct.*        *The chain is the longest one'',''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1001)***********************************************************Listing
    16-2'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码列表显示了三种不同比特币的 Python 代码。*# 这是区块链的 Python 类**class Blockchain:*    *def
    __init__(self):*        *self.chain=[]*        *self.transactions = []*        *self.create_block(proof=
    1 , previous_hash=''0'')*        *self.nodes = set()**# 用于创建区块的函数*    *def create_block(self,
    proof, previous_hash):*        *block={''index'' : len(self.chain) + 1,*                *''timestamp''
    : str(datetime.datetime.now()),*                *''proof'' : proof,*                *''previous_hash''
    : previous_hash,*                *''transactions'' : self.transactions}*        *self.transactions
    = []*        *self.chain.append(block)*        *return block*    *def get_previous_block(self):*        *return
    self.chain[-1]*    *def proof_of_work(self,previous_proof):*        *new_proof
    = 1*        *check_proof = False*        *while check_proof is False:*            *hash_operation
    = hashlib.sha256(str(new_proof**2 - previous_proof**2).encode()).hexdigest()*            *if
    hash_operation[:4]==''0000'':*                *check_proof =  True*            *else:*                *new_proof
    +=1*        *return new_proof*    *def hash(self,block):*        *encoded_block
    = json.dumps(block, sort_keys = True).encode()*        *return hashlib.sha256(encoded_block).hexdigest()*    *def
    is_chain_valid(self, block):*        *previous_block = self.chain[0]*        *block_index=1*        *while
    block_index < len(self.chain):*            *block = self.chain[block_index]*            *if
    block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True**# 添加交易的函数*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Bharathi'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Congrats, you just mined a block!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**# 获取区块链的方法**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200* *# 验证区块链的方法**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct.''}*    *else:*        *response = {''message'': ''Weve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200* *# 添加交易的
    POST 方法**@app.route(''/add_transaction'', methods = [''POST''])**def add_transaction():*    *json
    = request.get_json()*    *transaction_keys = [''sender'', ''receiver'', ''amount'']*    *if
    not all(key in json for key in transaction_keys):*        *return ''Some transactional
    components are missing.'', 400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : ''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201* *# 连接节点的方法**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bitcoin blockchain'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201* *# 更换链的方法**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain'
- en: bcoin-node-1001.py
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: bcoin-node-1001.py
- en: '*class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Meghna'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Youve just mined a block, so congrats!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct..''}*    *else:*        *response = {''message'': ''We ve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *json = request.get_json()*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some transactional components are missing.'',
    400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : f''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bitcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain..'',*                    *''new_chain'' : blockchain.chain}*    *else:*        *response
    = {''message'': ''Everything seems to be fine. It is the most extensive chain.'',*                    *''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1002)*Listing 16-3'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Meghna'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Youve just mined a block, so congrats!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct..''}*    *else:*        *response = {''message'': ''We ve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *json = request.get_json()*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some transactional components are missing.'',
    400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : f''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bitcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain..'',*                    *''new_chain'' : blockchain.chain}*    *else:*        *response
    = {''message'': ''Everything seems to be fine. It is the most extensive chain.'',*                    *''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1002)*Listing 16-3'
- en: bcoin-node-1002.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: bcoin-node-1002.py
- en: '*class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Meghna'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''You just mined a block, congrats!!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct.''}*    *else:*        *response = {''message'': ''We ve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *json = request.get_json()*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some elements of the transactions are missing'',
    400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : f''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain..'',*                    *''new_chain'' : blockchain.chain}*    *else:*        *response
    = {''message'': ''Everything is fine. The chain is the most extensive.'',*                    *''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1003)****************************************************************************Listing
    16-4'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*class Blockchain:*    '
- en: bcoin-node-1003.py
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: bcoin-node-1003.py
- en: 'Example node addresses (nodes.json in Listing [16-5](#PC6)) and transaction
    formats are shown in the .json files (transaction.json in Listing [16-6](#PC7)).{    "nodes"
    : ["http://127.0.0.1:1001",               "http://127.0.0.1:1002",               "http://127.0.0.1:1003"]}***************************************************************************Listing
    16-5'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '节点示例地址（[16-5](#PC6)中的nodes.json）和交易格式在.json文件中展示（[16-6](#PC7)中的transaction.json）。{    "nodes"
    : ["http://127.0.0.1:1001",               "http://127.0.0.1:1002",               "http://127.0.0.1:1003"]}***************************************************************************Listing
    16-5'
- en: nodes.json
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: nodes.json
- en: To add a transaction, copy the contents from transaction.json and POST it in
    the JSON format to http://127.0.0.1:1001/add_transaction in Postman, as shown
    in Listing [16-6](#PC7).-Listing 16-6
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加交易，请将transaction.json中的内容复制并以JSON格式POST到Postman中的http://127.0.0.1:1001/add_transaction，如[16-6](#PC7)中所示。-Listing
    16-6
- en: transaction.json
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: transaction.json
- en: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg)'
- en: '*****************************************************************************************************'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*****************************************************************************************************'
- en: 16.8.2 Changing the Blockchain into Cryptocurrency
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8.2 将区块链转化为加密货币
- en: 'To change the blockchain into cryptocurrency, follow these steps. First you
    have to add a transaction:*self.transactions = [] transaction to be created before****self.create_block
    Function******Then ; add_transaction(self, sender, receiver, amount)***Now you
    create a consensus:self.nodes = set()    **this is for init method**add_node(self,
    address)   **add node method for adding a new node**replace_chain(self)   **replace
    chain with long one**Now you have to decentralize the blockchain and apply consensus
    and transaction to it. In this sample coin, there are three nodes. They utilize
    the following addresses and ports listed (Flask):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将区块链转变为加密货币，请按照以下步骤操作。首先，您需要添加一笔交易：*self.transactions = [] 之前创建的交易****self.create_block
    函数******然后；add_transaction(self, sender, receiver, amount)***现在您创建一个共识：self.nodes
    = set()    **这是init方法**add_node(self, address)   **添加新节点的方法**replace_chain(self)   **用较长的链替换链**现在您需要将区块链分散化并应用共识和交易。在这个示例币中，有三个节点。它们利用以下列出的地址和端口（Flask）：
- en: 'Node 1: http://127.0.0.1:1001/'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点1：http://127.0.0.1:1001/
- en: 'Node 2: http://127.0.0.1:1002/'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点2：http://127.0.0.1:1002/
- en: 'Node 3: http://127.0.0.1:1003/'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点3：http://127.0.0.1:1003/
- en: 'To decentralize the Bitcoin network, mine blocks, send transactions, and apply
    consensus, copies of the code (bitcoin.py) have been created:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分散化比特币网络，挖掘区块，发送交易，并应用共识，已经创建了代码副本（bitcoin.py）：
- en: 'Node 1: bitcoin_node_1_1001.py'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点1：bitcoin_node_1_1001.py
- en: 'Node 2: bitcoin_node_2_1002.py'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点2：bitcoin_node_2_1002.py
- en: 'Node 3: bitcoin_node_3_1003.py'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点3：bitcoin_node_3_1003.py
- en: Once the application is running on Flask, Postman requests are used to query
    the blockchain, create transactions, and apply a consensus. In this case, port
    1001 was utilized (Node 1).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Flask 应用程序正在运行，就可以使用 Postman 请求来查询区块链、创建交易并应用共识。在这种情况下，端口 1001 被利用（节点 1）。
- en: 16.8.3 GET
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8.3 GET
- en: 'Get chain: [http://127.0.0.1:1001/get_chain](http://127.0.0.1:5001/get_chain)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 获取链：[http://127.0.0.1:1001/get_chain](http://127.0.0.1:5001/get_chain)
- en: 'Mine block: [http://127.0.0.1:1001/mine_block](http://127.0.0.1:5001/mine_block)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘区块：[http://127.0.0.1:1001/mine_block](http://127.0.0.1:5001/mine_block)
- en: 'Replace chain: [http://127.0.0.1:1001/replace_chain](http://127.0.0.1:5001/replace_chain)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 替换链：[http://127.0.0.1:1001/replace_chain](http://127.0.0.1:5001/replace_chain)
- en: 16.8.4 POST
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8.4 POST
- en: 'Add transaction: [http://127.0.0.1:1001/add_transaction](http://127.0.0.1:5001/add_transaction)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加交易：[http://127.0.0.1:1001/add_transaction](http://127.0.0.1:5001/add_transaction)
- en: 'Connect node: [http://127.0.0.1:1001/connect_node](http://127.0.0.1:5001/connect_node)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 连接节点：[http://127.0.0.1:1001/connect_node](http://127.0.0.1:5001/connect_node)
- en: 'Source code: [https://github.com/JosephThachilGeorge/Bitcoin](https://github.com/JosephThachilGeorge/Bitcoin)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码：[https://github.com/JosephThachilGeorge/Bitcoin](https://github.com/JosephThachilGeorge/Bitcoin)
- en: By looking at this project, you have come to know the concept of Bitcoin and
    how to mine it. So the question is, who are the miners?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个项目，你已经了解了比特币的概念以及如何进行挖矿。那么问题来了，谁是矿工呢？
- en: 16.9 Functions of the Nodes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.9 节点的功能
- en: The Bitcoin network is formed of nodes, that is, computers in communication
    with each other, thanks to Bitcoin’s open source software.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络由节点组成，即彼此通信的计算机，这要归功于比特币的开源软件。
- en: 'Nodes can have different functions: some nodes validate the regularity of transactions
    and other nodes propagate transactions to other nodes. The nodes of interest in
    this article are called “miners” and they create the chain of blocks, called blockchain,
    where all transactions are forever recorded.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以有不同的功能：一些节点验证交易的规则性，其他节点将交易传播给其他节点。本文中感兴趣的节点被称为“矿工”，它们创建区块链，即所有交易都永久记录的区块链。
- en: 'Now let’s see what miners do. Mining nodes are owned by private citizens or
    companies that invest huge resources to solve a mathematical problem that can
    only be solved by trial and error. Anyone can mine Bitcoin money; let’s see what
    you need to have:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看矿工做些什么。挖矿节点由私人公民或公司拥有，他们投入了巨大的资源来解决只能通过试错解决的数学问题。任何人都可以挖比特币；让我们看看你需要什么：
- en: For mining, you need specialized equipment; often, video cards for video games
    would suffice. However, there are now powerful processors (ASICS) developed to
    calculate the SHA-256 equation of Bitcoin to enhance the odds of winning.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行挖矿需要专用设备；通常情况下，用于视频游戏的显卡就足够了。然而，现在已经开发出了强大的处理器（ASIC），用于计算比特币的 SHA-256 方程，以增加获胜的几率。
- en: The second condition is to generate or purchase a large amount of electricity
    to power computers and associated cooling equipment; in fact, mining these machines
    heats up the surroundings and you must maintain an ideal temperature to maintain
    the machine’s physical integrity.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个条件是生成或购买大量电力来为计算机和相关冷却设备供电；事实上，这些机器的挖矿会使周围变热，你必须保持一个理想的温度以维持机器的物理完整性。
- en: The next stage is to plan out how many hours will be needed to run the mining
    farm. Personnel working at Bitcoin mines are also responsible for the upkeep and
    replacement of machines, which, when used to their full computing capability,
    rapidly fail.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的阶段是计划运行采矿农场所需的时间。在比特币矿场工作的人员还负责机器的维护和更换，当机器被充分利用其计算能力时，会迅速损坏。
- en: All of this while competing with other miners.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都是在与其他矿工竞争的同时进行的。
- en: 'Once the operations begin, your calculators do nothing but compute the same
    equation (SHA-256) over and over again, taking data from the Bitcoin network as
    input, and then trying to add a new number to the equation to see whether the
    output matches the protocol’s requirements. The result is a hexadecimal number
    of this type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作开始，你的计算器只会不停地重复计算相同的方程式（SHA-256），以比特币网络的数据作为输入，然后尝试向方程式中添加一个新数字，以查看输出是否符合协议的要求。结果是这种类型的十六进制数：
- en: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg)'
- en: On first try, the mining machine inserts the number 1 into the SHA-256 equation
    and checks the output to see how many zeros are in front of the number. It recalculates
    SHA-256 using the same set of transactions on the second try and adds the number
    2\. On the third attempt it adds the number 3, and so on, until it obtains a number
    that starts with zeros. The outcome is completely random. These are huge numbers;
    in reality, every 10 minutes or so, one of the computers across the world discovers
    the exact number of zeros required by the protocol at that time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次尝试时，采矿机将数字1插入SHA-256方程式中，并检查输出，以查看数字前面有多少个零。它在第二次尝试中使用相同的交易集重新计算SHA-256，并添加数字2。在第三次尝试中，它添加数字3，依此类推，直到获得以零开头的数字。结果是完全随机的。这些是巨大的数字；实际上，世界各地的计算机大约每10分钟就会发现协议当前所需的确切零数量。
- en: When a miner discovers a viable solution, the entire computer network is vulnerable
    to transaction blockage. Because the conclusion is mathematically repeatable and
    verifiable, all miners can check it quickly and simply. The transactions included
    inside the mined block are 100% legitimate and may be added to the block chain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当矿工发现一个可行的解决方案时，整个计算机网络都容易受到交易阻塞的影响。由于结论在数学上是可重复验证的，所有矿工都可以快速简单地检查它。所挖掘块内包含的交易是100%合法的，并且可以添加到区块链上。
- en: The miner is a node or a user who has installed Bitcoin on their computer, but
    in addition to validating and propagating transactions, the miner also bears the
    responsibility of expending energy to solve the mathematical challenge that underpins
    the authorization to write in blockchain.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工是一个节点或者一个在其计算机上安装了比特币的用户，但除了验证和传播交易外，矿工还承担着耗费能量来解决支撑写入区块链的授权的数学挑战的责任。
- en: These specific nodes make accessible energy resources in order to earn the prize
    while also ensuring that the system is protected against double spending in the
    absence of a centralized coordinator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定节点提供可访问的能源资源，以赢得奖励，同时确保在没有集中协调员的情况下系统对抗双重支出。
- en: 16.9.1 Create a New Candidate Block by Combining Valid Transactions
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.9.1 通过合并有效交易创建新的候选区块
- en: The nearest nodes instantly check if you have the funds to spend once you send
    your transaction. The transaction is queued to be executed by the miners if this
    verification passes. The transaction is collected by a miner, who then combines
    it with other transactions in the ether to form a candidate block of transactions
    to be added to the blockchain. The miner’s job at this stage is to calculate the
    number that begins with 0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您发送交易，最近的节点立即检查您是否有资金可供使用。如果此验证通过，则交易被排队等待矿工执行。矿工收集交易，然后将其与其他交易合并到以太中形成候选交易区块的交易中。在这个阶段，矿工的工作是计算以0开头的数字。
- en: 16.9.2 Computing Power on the Defensive Wall (Hash Rate)
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.9.2 防御墙上的计算能力（哈希率）
- en: Because the amount of hash power (computing power) brought into the system is
    fully committed to ensuring that there are no fraudulent transactions, even miners
    who do not win the Bitcoins in the last block have contributed to Bitcoin’s security.
    This protective wall defends against double spending as well as intruders attempting
    to tamper with the blockchain’s facts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引入系统的哈希功率（计算能力）完全致力于确保没有欺诈交易，即使不是上一个区块中赢得比特币的矿工也为比特币的安全做出了贡献。这道保护墙不仅防御双重支出，还防御试图篡改区块链事实的入侵者。
- en: Each miner can theoretically have a distinct set of transactions, and the first
    miner to discover a solution using the transactions they select gets to add their
    candidate block to the blockchain. When the network has agreed on which is the
    last valid block, the race starts to find the next block.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矿工理论上可以有一套不同的交易集合，而首个通过选择交易而发现解决方案的矿工将其候选区块添加到区块链中。当网络就最后一个有效区块达成一致时，竞争就开始了，以找到下一个区块。
- en: When the system’s processing capacity is good enough that valid blocks are discovered
    in fewer than 10 minutes, the mathematical puzzle’s complexity is increased by
    increasing the number of zeros in front of the solution to be found. While the
    system facilitates the solution by requiring miners to find a number with fewer
    zeros in front if the system’s computing power is insufficient and requires that
    new blocks are only found every 15 minutes, the system facilitates the solution
    by requiring miners to find a number with fewer zeros in front if the system’s
    computing power is insufficient.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统的处理能力足够好，以至于有效的区块发现少于10分钟，数学难题的复杂性就会增加，增加要找到的解决方案前面的零的数量。虽然当系统的计算能力不足以要求新区块每15分钟才能发现时，系统会通过要求矿工找到前面零数量更少的数字来促使解决方案，但是系统通过要求矿工找到前面零数量更少的数字来促使解决方案，以保证发现区块。
- en: This technique adapts to the difficulty dependent on the system’s computational
    capacity. As a result, as computer power declines, discovering Bitcoin is simpler,
    and more people will be motivated to mine, keeping the system afloat. When mining
    Bitcoin gets too difficult; however, only the most efficient miners remain on
    the market. This indicates that when the price of Bitcoin rises, hash power rises
    as well—more value, more computer power, and greater security.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术根据系统的计算能力而调整难度。因此，当计算机能力下降时，发现比特币会更加简单，更多的人会被激励去挖矿，从而保持系统的运转。然而，当挖掘比特币变得太困难时，只有最高效的矿工才会留在市场上。这表明，当比特币价格上涨时，哈希率也会上升——价值更高，计算机能力更大，安全性更高。
- en: 16.10 Creating New Bitcoins
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.10 创造新比特币
- en: Bitcoin is a currency, and contributing to its creation and upkeep allows you
    to earn Bitcoin in exchange for your efforts. Every four years, the compensation
    for blocks is halved. After ten years of unbroken activity, we are at 6.25 Bitcoins
    every 10 minutes. Aside from the Bitcoin prize, a successful miner also receives
    any commissions associated with the individual transactions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是一种货币，为其创建和维护做出贡献可以让你换取比特币。每四年，区块的奖励会减半。经过十年的不间断活动，我们目前每10分钟会产生6.25个比特币。除了比特币奖励外，成功的矿工还会获得与个别交易相关的任何佣金。
- en: As you can see, the quantity of new Bitcoins continues to decrease; at the time
    of writing, the total number of Bitcoins produced since 2009 is about 18 million.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，新比特币的数量仍在减少；在撰写本文时，自2009年以来产生的比特币总数约为1800万。
- en: Continuing the mathematical series, around the year 2140, 21 million Bitcoins
    will have been mined.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 继续数学系列，到公元2140年左右，将开采出2100万个比特币。
- en: 16.10.1 The Concept of Decentralization
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.10.1 分权化的概念
- en: Miners are components, nodes of the network, with the special duty of producing
    blockchain blocks and releasing new Bitcoins, ensuring security against double
    spending attempts.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工是网络的组成部分，是特别负责生产区块链区块和释放新比特币的节点，确保安全防范双重支付企图。
- en: The notion of decentralization  , or, to put it another way, the fact that you
    don’t need a central coordinator to verify that all parties behave correctly,
    is perhaps one of Bitcoin’s most revolutionary features.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分散化的概念，或者换句话说，你不需要一个中央协调员来验证所有方的行为是否正确，也许是比特币最具革命性的特征之一。
- en: How does Bitcoin’s decentralized coordination work? The answer is “proof of
    work,” a new approach for reaching an agreement on the state of balances. The
    job entails gathering transactions, generating candidate blocks, and computing
    hash with zeros in front, as stated. Proof of work is nothing more than a cunning
    ruse to compel the system to coordinate every 10 minutes on the status of Bitcoin
    balances.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的去中心化协调是如何工作的？答案是“工作证明”，这是一种关于余额状态达成一致的新方法。这项工作包括收集交易、生成候选区块，并计算以零开头的哈希，如上所述。工作证明只是一个狡猾的诡计，目的是迫使系统每10分钟在比特币余额状态上协调。
- en: The incentive mechanism draws new miners who are ready to spend resources to
    discover Bitcoin, and none of the participants in the game are interested in acting
    against the Bitcoin network’s interests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 激励机制吸引了愿意花费资源发现比特币的新矿工，游戏参与者都不会对比特币网络的利益行为不轨。
- en: Miners make significant investments in order to earn Bitcoins, and they will
    never attempt to compromise the protocol’s resilience because doing so would result
    in them losing the whole worth of the Bitcoins in their possession. Miners seldom
    sell their Bitcoins for less than the cost of manufacturing. This means that Bitcoin
    has a minimum price, determined by the cost of mining a single Bitcoin successfully.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工为了赚取比特币而进行了重大投资，他们绝不会试图 compromise 协议的弹性，因为这样做会导致他们失去手中的比特币的全部价值。矿工很少以低于制造成本的价格出售比特币。这意味着比特币有一个最低价格，由成功挖掘一枚比特币的成本确定。
- en: Miners are honest because deceiving the system costs a lot of money initially;
    it is predicted that rearranging blockchain history to attack the system would
    cost $5 billion. Second, all hacking efforts would be futile since each node has
    the option of accepting or rejecting updates to its blockchain copy. Blocks with
    a double expense will never be accepted by honest nodes. In reality, the attacker
    would be on a blockchain other than the main one, a blockchain that has no value
    since it includes fraudulent data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工是诚实的，因为欺骗系统的成本非常高昂；据预测，重新安排区块链历史以攻击系统将花费 50 亿美元。其次，所有的黑客攻击都将是徒劳的，因为每个节点都有接受或拒绝更新其区块链副本的选择。具有双重支出的区块永远不会被诚实的节点接受。事实上，攻击者将在一个不是主要区块链的区块链上，这个区块链没有价值，因为它包含欺诈数据。
- en: 16.11 Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.11 总结
- en: This chapter discussed the future scope of blockchain technology and distributed
    systems and touched on how you can achieve secure transactions using blockchain.
    The B-Coin project showed how Bitcoin works and how you can attain secure transactions
    using the Bitcoin concept.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了区块链技术和分布式系统的未来范围，并涉及如何利用区块链实现安全交易。B-Coin项目展示了比特币的运作方式以及如何利用比特币概念实现安全交易。
- en: I am sure that you now understand what Bitcoins are for. The uses of this digital
    currency, in fact, can be multiple and are not only linked to the speculation
    that is made on it. The blockchain method is also particularly interesting for
    its future developments, which could be related to every aspect of our existence.
    Now that you know how Bitcoin works, nothing can stop you in the discovery of
    the cryptocurrency!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在已经明白比特币的用途了。事实上，这种数字货币的用途可能是多样化的，不仅仅局限于对其进行的投机。区块链方法对于其未来的发展也尤其有趣，这些发展可能与我们生活的方方面面都有关。现在你知道比特币是如何运作的了，没有什么能阻止你去探索加密货币了！
- en: The next chapter will focus on automated vehicle management systems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点讨论自动化车辆管理系统。
