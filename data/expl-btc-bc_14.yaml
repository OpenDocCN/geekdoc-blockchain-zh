- en: '[CHAPTER 12](toc.xhtml#c12)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 12 章](toc.xhtml#c12)'
- en: '[Segregated Witness](toc.xhtml#c12)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[隔离见证](toc.xhtml#c12)'
- en: Till now, you have learned about Bitcoin and its building blocks, whitepaper,
    network protocol, network messaging, database indexing, transaction creation,
    transaction scripting, and smart contracts. This covers Bitcoin from all aspects
    of its functionality and implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了比特币及其构建块、白皮书、网络协议、网络消息传递、数据库索引、交易创建、交易脚本和智能合约。这涵盖了比特币在功能和实现的各个方面。
- en: In this section, we will look at some of the advanced topics that make Bitcoin
    even more interesting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一些使比特币更加有趣的高级主题。
- en: We will start this chapter with segregated witness, also called *SegWit*. Segregated
    witness is one of the biggest enhancements in the history of Bitcoin, and it is
    the only enhancement that somewhat modifies the Bitcoin Whitepaper, solves long-standing
    transaction malleability bug, increases the capacity of a block that Satoshi made
    limited to 1MB, changes the way miners calculate network fee, and changes the
    way enhancements were traditionally accepted, opening a new way of looking at
    feature activation. All this happened in one enhancement, so it requires a chapter
    dedicated to it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从隔离见证，也称为 *SegWit* 开始。隔离见证是比特币历史上最重要的增强之一，是唯一一个在某种程度上修改比特币白皮书的增强，解决了长期存在的交易篡改漏洞，增加了
    Satoshi 限制为 1MB 的区块容量的方式，改变了矿工计算网络费用的方式，以及改变了传统上接受增强的方式，开启了一个新的特性激活方式。所有这些都发生在一个增强中，因此需要专门的章节来介绍。
- en: '[Structure](toc.xhtml#s252a)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s252a)'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding segregated witness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解隔离见证
- en: Transaction malleability
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易篡改性
- en: Segregated witness
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离见证
- en: User Activated Soft Fork (UASF)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户激活软分叉（UASF）
- en: Transaction structure
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易结构
- en: Coinbase transaction
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coinbase 交易
- en: Other transactions
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他交易
- en: Segregated witness as scaling solution
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离见证作为扩容解决方案
- en: Transaction fee calculation
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易费计算
- en: New standard scripts
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的标准脚本
- en: Native SegWit transaction scripts
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 SegWit 交易脚本
- en: Native P2WPKH
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 P2WPKH
- en: Native P2WSH
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 P2WSH
- en: Wrapped SegWit scripts
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装 SegWit 脚本
- en: Wrapped P2WPKH or P2SH-P2WPKH
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装 P2WPKH 或 P2SH-P2WPKH
- en: Wrapped P2WSH or P2SH-P2WSH
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装 P2WSH 或 P2SH-P2WSH
- en: Signature verification
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名验证
- en: Address format and generation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址格式和生成
- en: '[Objectives](toc.xhtml#s253a)'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[目标](toc.xhtml#s253a)'
- en: In this chapter, you will learn about the segregated witness enhancement, why
    it was required, what problems it solved, what its features are, how to identify
    a SegWit transaction, how to verify and create script types introduced by SegWit,
    and how to calculate network fees for SegWit transactions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习有关隔离见证增强的内容，为什么它是必要的，它解决了什么问题，它的特点是什么，如何识别 SegWit 交易，如何验证和创建 SegWit
    引入的脚本类型，以及如何计算 SegWit 交易的网络费用。
- en: We will go into great depth to understand each aspect of this enhancement by
    understanding how the bug is resolved and how the change is made to the original
    whitepaper, understanding the BIP enhancements that were introduced covering each
    script type in detail, and verifying and creating transactions using them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究此改进的每个方面，通过理解漏洞是如何解决以及对原始白皮书进行了哪些改变，了解引入的 BIP 改进详细介绍了每个脚本类型，并验证和创建使用它们的交易。
- en: '[Understanding segregated witness](toc.xhtml#s254a)'
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[理解隔离见证](toc.xhtml#s254a)'
- en: Segregated witness was introduced primarily to fix multiple *transaction malleability*
    bugs. In this section, you will understand what *transaction malleability* bugs
    had kept the Bitcoin network vulnerable for several years and how exchanges had
    to place hacks to avoid the issues arising due to the bugs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证主要是为了修复多个*交易可塑性*漏洞。在这一部分，你将了解*交易可塑性*漏洞如何使比特币网络在多年间处于脆弱状态以及交易所如何采取措施来避免由漏洞引起的问题。
- en: '[Transaction malleability](toc.xhtml#s255a)'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[交易可塑性](toc.xhtml#s255a)'
- en: Transaction malleability is a scenario when the same transaction can have different
    transaction IDs, which in turn, means two different transactions that represent
    the same transaction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 交易可塑性是指同一笔交易可能具有不同的交易 ID，这意味着代表同一笔交易的两笔不同交易。
- en: Consequently, it was not possible to depend on an unconfirmed transaction even
    though it was signed by the same person. For instance, someone could just modify
    a mempool transaction and publish it, which may get mined. This means it is not
    possible to chain unconfirmed transactions even if they are your own.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使是由同一人签名的未确认交易也不可能依赖。例如，有人可以简单地修改一个内存池交易并发布它，然后可能被挖掘。这意味着即使是你自己的未确认交易，也不可能链式连接。
- en: It is also possible that a wallet may be waiting for a different transaction
    ID but receives a different transaction ID and so, it ignores the transaction.
    This would lead a wallet to believe that it is processing a different transaction,
    so it may consider your transaction as unconfirmed even though it was confirmed.
    This may be used by a hacker to misguide a wallet or an exchange.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能一个钱包正在等待不同的交易 ID，但接收到了不同的交易 ID，所以它忽略了交易。这会导致钱包认为它正在处理不同的交易，因此尽管已经确认，但它可能认为你的交易未确认。这可能被黑客用来误导钱包或交易所。
- en: A transaction malleability bug can be used by the signer (first party), or it
    can be used by the second or the thi^(rd) party, which receives or knows about
    the transaction and modifies it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 交易可塑性漏洞可被签名者（第一方）利用，或者可被接收或了解交易并进行修改的第二方或第三方利用。
- en: The following are the transaction malleability issues that existed when the
    Bitcoin network initially came into existence.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比特币网络初始存在的交易可塑性问题。
- en: 'Malleability bug used by second or third party:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二方或第三方利用的可塑性漏洞：
- en: In the elliptic curve cryptography used by Bitcoin, (R, S) and (R, -S) are both
    valid points on the curve. Prior to the SegWit enhancement, this was taken care
    of by considering the smaller of two valid values of S.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比特币中使用的椭圆曲线密码学中，(R, S) 和 (R, -S) 都是曲线上的有效点。在 SegWit 增强之前，这是通过考虑两个有效的 S 值中较小的一个来处理的。
- en: In the initial years, Non-DER encoded signatures were valid. These were made
    illegal, and the DER format was enforced strictly.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最初的几年里，非 DER 编码的签名是有效的。这些被定为非法，严格执行 DER 格式。
- en: Leading zeroes in front of signature.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名前导零。
- en: Several script-related modifications that do not change their intended validity
    are also sources of malleability. As an example, opcode OP_0 pushes zero bytes
    to stack, which means doing nothing, so inserting OP_0 doesn’t change script behavior.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个与脚本相关的修改，不会改变它们的预期有效性，也是可塑性的来源。例如，操作码 OP_0 将零字节推送到堆栈，意味着什么都不做，因此插入 OP_0 不会改变脚本行为。
- en: 'Malleability bug used by first party:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一方使用的可塑性漏洞：
- en: While signing a message, a signer needs to generate a random number. This random
    leads to different but valid signatures. This issue is resolved by RFC6979, which
    specifies deterministic digital signature generation procedure. However, this
    cannot be verified, so it still causes malleability.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在签署消息时，签署者需要生成一个随机数。这个随机数导致不同但有效的签名。这个问题由 RFC6979 解决，该规范指定了确定性数字签名生成过程。然而，这不能被验证，因此仍然会导致可塑性。
- en: It is possible to solve second- and third-party malleability by introducing
    rules that are enforced on scripting and signature format, but this does not solve
    the malleability bug misused by the signer themselves to deceive the wallet of
    exchange. BIP-62 tried to solve the transaction malleability problems arising
    by second or third party misuse of malleability, but its implementation was quite
    complicated as it was trying to solve so many issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入对脚本和签名格式执行的规则，可以解决第二方和第三方的塑性问题，但这并不能解决签名者自己误用可塑性来欺骗交易所钱包的塑性错误。BIP-62 试图解决由第二方或第三方滥用可塑性而引起的交易可塑性问题，但其实施相当复杂，因为它试图解决这么多问题。
- en: '**Tip: If you are sending Bitcoins through a pre-SegWit transaction, then you
    need to be aware that anyone can change your transaction-ID. Additionally, you
    should not chain transactions that are not confirmed.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示：如果您通过预 SegWit 交易发送比特币，那么您需要注意任何人都可以更改您的交易 ID。此外，您不应链接未确认的交易。**'
- en: Even though BIP-62 solved most problems, it was not perfect, so unconfirmed
    transactions could not be chained. This means a dependent transaction could become
    invalid if a modified parent transaction gets accepted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 BIP-62 解决了大多数问题，但它并不完美，因此未确认的交易无法链接。这意味着如果修改后的父交易被接受，依赖交易可能会变为无效。
- en: 'The following diagram shows how transaction malleability affects dependent
    unconfirmed transactions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了交易可塑性如何影响依赖未确认交易：
- en: '![](images/Figure-12.1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.1.jpg)'
- en: '**Figure 12.1:** Effect of transaction malleability on unconfirmed transaction'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.1：** 未确认交易的交易篡改效应'
- en: 'The following sequence explains how this can happen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下顺序解释了这种情况是如何发生的：
- en: Alice creates transaction TxA, which pays Bob.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 创建了交易 TxA，向 Bob 支付。
- en: Alice tells Bob that she had made payment and that the transaction ID is TxA.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 告诉 Bob 她已经付款，交易 ID 是 TxA。
- en: The attacker creates transaction TxA’ and publishes it on the Bitcoin network
    just after receiving TxA.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者创建了交易 TxA’，并在收到 TxA 后立即将其发布到比特币网络上。
- en: Alice creates transaction TxB, paying Carol from the change collected in TxA.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 创建了交易 TxB，使用 TxA 中收集的找零支付了 Carol。
- en: TxA’ gets added to Bitcoin blockchain.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TxA’ 被添加到比特币区块链中。
- en: Bob never receives a confirmation for TxA and considers that it failed.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 从未收到有关 TxA 的确认，并认为交易失败了。
- en: Similarly, Carol never receives payment as TxA’ was not input to TxB.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，由于 TxA’ 没有输入到 TxB 中，Carol 也没有收到付款。
- en: Alice pays Bob and Carol again, not knowing that her transaction to Bob was
    successful.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 再次向 Bob 和 Carol 支付，不知道她向 Bob 的交易成功了。
- en: Bob received payment twice and Alice now needs to get it back, provided Bob
    agrees.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 收到了两次付款，现在 Alice 需要把钱退回来，前提是 Bob 同意。
- en: In 2014, the world’s biggest exchange was hacked, and people lost a massive
    amount of money. It is considered that the attacker used transaction malleability
    to hack their exchange. However, we know how these things happened and why they
    happened, so exchanges and wallet software are aware of these issues, and they
    have taken steps to not fall into the trap.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2014 年，全球最大的交易所遭受了黑客攻击，人们损失了大量资金。据认为，攻击者利用交易篡改来攻击他们的交易所。然而，我们知道这些事情是如何发生的以及为什么会发生，因此交易所和钱包软件都意识到了这些问题，并采取了措施以避免陷入陷阱。
- en: Transaction malleability was finally resolved with the implementation of segregated
    witness enhancement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 随着隔离见证增强的实施，交易篡改问题最终得到解决。
- en: '[Segregated witness](toc.xhtml#s256a)'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[隔离见证](toc.xhtml#s256a)'
- en: Segregated witness is the solution to the long-lasting transaction malleability
    issue. It moves the signature out of the transaction ID calculation, solving all
    forms of transaction malleability issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证是解决长期交易篡改问题的方案。它将签名从交易 ID 计算中移出，从而解决了所有形式的交易篡改问题。
- en: 'The following diagram shows how SegWit changes the whitepaper:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了隔离见证如何改变白皮书：
- en: '![](images/Figure-12.2.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.2.jpg)'
- en: '**Figure 12.2:** Segwit transaction diagram showing the difference in the whitepaper'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.2：** 显示白皮书中差异的隔离见证交易图表'
- en: In the preceding diagram, you can see that the case of SegWit transaction signature
    is not part of the transaction anymore. It is sent along with the transaction
    as an extension.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到隔离见证交易签名不再是交易的一部分。它作为扩展与交易一起发送。
- en: SegWit allowed transactions to be chained while they are unconfirmed, and we
    can rely on transaction ID. This allowed two individuals to send offline transactions
    if both have signed the payment contract. Consequently, Lightning Network became
    feasible, which changed the way payments can be done across the globe. We will
    discuss this further in the next chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SegWit允许未确认的交易进行链式连接，并且我们可以依赖于交易ID。这使得两个个体可以发送离线交易，如果两者都签署了支付合同。因此，闪电网络变得可行，改变了全球支付方式。我们将在下一章进一步讨论这个问题。
- en: When SegWit was planned, the 1MB block limit appeared as a scalability issue
    because blocks were hitting the limit, mempool was getting full, and network fees
    would spike.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当规划SegWit时，1MB的区块限制看起来是一个可扩展性问题，因为区块达到了限制，内存池已满，并且网络费用会飙升。
- en: Since SegWit was a softfork, older nodes ignore the signatures in a SegWit transaction,
    so they are not part of the 1MB block calculation. This allowed the incorporation
    of the required increase in block size into the enhancement. This increase in
    block size for SegWit transactions also reduced the transaction fees for those
    transactions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SegWit是一个软分叉，旧节点会忽略SegWit交易中的签名，因此它们不计入1MB区块计算范围内。这使得将所需的区块大小增加纳入了增强功能。对于SegWit交易的区块大小增加也降低了这些交易的交易费用。
- en: In the modified block size calculation for the upgraded node, the bytes related
    to the SegWit in a transaction are considered a quarter of a byte. Additionally,
    with SegWit, new standard scriptPubKey were introduced, which further reduced
    byte requirements in a transaction. Both these things made SegWit transactions
    more economical.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级节点的修改后的区块大小计算中，交易中与SegWit相关的字节被视为四分之一字节。此外，SegWit引入了新的标准scriptPubKey，进一步减少了交易中的字节需求。这两件事使得SegWit交易更经济。
- en: SegWit activation had impact the way we look at the value of Bitcoin, network,
    and enhancements. There existed a thinking that major enhancements should happen
    through hard fork and that voting on enhancements should be based on hash power.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SegWit激活影响了我们看待比特币、网络和增强功能的方式。有一种思想认为主要的增强应该通过硬分叉来进行，对增强的投票应该基于哈希功率。
- en: Since SegWit activation was a major change, it affected everyone in the ecosystem,
    and everyone had to make a choice, which many tried to delay. SegWit activation
    followed BIP 9 and entered the *start* phase on 15^(th) November, 2016\. So, timeout
    was set at 1 year after the start date, before which consensus needed to be reached;
    otherwise, the activation was to be marked as failed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SegWit激活是一项重大变革，它影响了生态系统中的每个人，每个人都不得不做出选择，许多人试图延迟这一选择。SegWit激活遵循BIP 9并于2016年11月15日进入*启动*阶段。因此，在启动日期后一年设置了超时，必须在此之前达成共识；否则，激活将被标记为失败。
- en: By August 2017, a vast majority of nodes were SegWit ready, but consensus was
    not reached among miners. The Bitcoin developer community saw this as a misalignment
    between the economic majority and the hash power majority. With the rise of mining
    pools, the hash power majority did not represent the economic majority as few
    mining pools owned most of the hash power, and this was evident in user support
    for new enhancement. To allow other stakeholders to play a role in decision-making,
    we needed to change the way enhancements get activated. This led to the new activation
    mechanism called **User-Activated-Soft-Fork** (**UASF**).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到了 2017 年 8 月，绝大多数节点都已准备好支持隔离见证，但矿工之间并未达成共识。比特币开发者社区将此视为经济多数和算力多数之间的不一致。随着矿池的崛起，算力多数并未代表经济多数，因为少数矿池拥有大部分算力，而这在用户对新增强支持方面是明显的。为了让其他利益相关者参与决策，我们需要改变增强功能的激活方式。这导致了称为**用户激活软分叉**（**UASF**）的新激活机制的出现。
- en: '[User Activated Soft Fork (UASF)](toc.xhtml#s257a)'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[用户激活软分叉（UASF）](toc.xhtml#s257a)'
- en: User Activated Soft Fork is an activation rule enforced by economic majority
    instead of hash power majority, as was done by miners. The economic majority is
    representative of the will of full nodes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用户激活软分叉是由经济多数而不是算力多数强制执行的激活规则，就像矿工所做的那样。经济多数代表了全节点的意愿。
- en: BIP 148 was created to enforce SegWit deployment if the hash power majority
    does not activate segregated witness-related BIPs, which were BIP 141, BIP 143,
    and BIP 147.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: BIP 148 是为了强制推行隔离见证（SegWit）部署而创建的，如果算力的大多数不激活与隔离见证相关的 BIP，这些 BIP 是 BIP 141、BIP
    143 和 BIP 147。
- en: '[Transaction structure](toc.xhtml#s258a)'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[交易结构](toc.xhtml#s258a)'
- en: Segregated witness moves signature out of the transaction ID calculation and
    so, modifies transaction structure. You have learned that the integrity of transactions
    included in a block is verified by adding Merkle –root to the block header. The
    Merkle –root is calculated using transaction ID for all the block transactions
    in the order. Since segregated witness moves signature out of transaction-ID calculation,
    Merkle root also does not verify the integrity of signatures in a block. But why
    should we care if it does not help the attacker as it cannot change transaction
    ID? The answer to this is that the attacker can use this as Denial-of-Service
    attack. An attacker can take a valid block and create millions of valid blocks
    and broadcast them over the network. This will make the Bitcoin network unable
    to verify transactions and blocks and will bring the whole network down.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证将签名从交易 ID 计算中移出，因此修改了交易结构。你已经了解到，区块中包含的交易的完整性是通过将默克尔根添加到区块头来验证的。默克尔根是使用交易
    ID 对所有区块交易按顺序计算得到的。由于隔离见证将签名从交易 ID 计算中移出，因此默克尔根也不再验证区块中签名的完整性。但是，如果它无法改变交易 ID，我们为什么要在意呢？答案是攻击者可以将其用作拒绝服务攻击。攻击者可以获取一个有效的区块并创建数百万个有效的区块，并将它们广播到网络中。这将导致比特币网络无法验证交易和区块，并将使整个网络崩溃。
- en: The Bitcoin block contains segregated witness Merkle root or witness root in
    one of the coinbase transaction outputs. This ensures the integrity of the full
    content of all the transactions, including signatures. The segregated witnessMerkle
    root is Merkle root of the whole transaction, unlike Merkle root in block header,
    which uses transaction ID of all the transactions to calculate Merkle root.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块包含隔离见证默克尔根或见证根在其中一个coinbase交易输出中。这确保了所有交易的完整内容的完整性，包括签名。隔离见证默克尔根是整个交易的默克尔根，不同于区块头中的默克尔根，后者使用所有交易的交易ID来计算默克尔根。
- en: We will first understand the structure of normal transaction ID, and then we
    will calculate *wtxid* and then use it to get witness root.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解普通交易ID的结构，然后我们将计算*wtxid*，然后使用它来获取见证根。
- en: Coinbase transaction
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coinbase交易
- en: 'The following diagram shows coinbase transaction with additional information
    related to SegWit:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了带有与SegWit相关的附加信息的coinbase交易：
- en: '![](images/Figure-12.3.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.3.jpg)'
- en: '**Figure 12.3:** Coinbase transaction structure'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.3：** Coinbase交易结构'
- en: 'In the preceding diagram, there are a few things to remember:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图表中，有几件事情需要记住：
- en: Number of witnesses = Number of inputs
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 见证数量 = 输入数量
- en: SegWit Marker is 0x00
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit标记为0x00
- en: For SegWit transaction, SegWit Flag is set to 0x01
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于SegWit交易，SegWit标志设置为0x01
- en: Number of Inputs = 1
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入数量= 1
- en: Commitment Hash = hash256 (Witness Root Hash || Witness Reserved Value)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺哈希=hash256（见证根哈希|| 见证保留值）
- en: Witness root hash is the Merkle root of the witness transaction ID or hash256
    of full transaction
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 见证根哈希是见证交易ID或完整交易的hash256的默克尔根
- en: Witness Reserved Value is the 32-byte witness in the coinbase transaction. Since
    there is real input in a coinbase transaction the witness reserved value could
    be anything. Since everyone can look at the value in witnessing, the commitment
    hash can be verified.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 见证保留值是coinbase交易中的32字节见证。由于coinbase交易中存在真实输入，见证保留值可以是任何值。由于每个人都可以查看见证值，因此可以验证承诺哈希。
- en: '**Transaction ID** (**txid**) is calculated by taking hash256 of the following
    sections of a transaction:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**交易ID**（**txid**）是通过对交易的以下部分进行hash256计算得到的：'
- en: '`txid = hash256([version][input count][inputs][output count][outputs] [locktime])`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid = hash256([version][input count][inputs][output count][outputs] [locktime])`'
- en: 'Witness Transaction ID (*wtxid*) is calculated by taking hash256 of the full
    transaction, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 见证交易ID（*wtxid*）通过对完整交易进行hash256计算得到，如下所示：
- en: '`wtxid = hash256([version][segwit marker][segwit flag][input count][inputs]
    [output count][outputs][witness data][locktime])`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`wtxid = hash256([version][segwit marker][segwit flag][input count][inputs]
    [output count][outputs][witness data][locktime])`'
- en: 'The following program parses a coinbase translation in a recent block:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序解析了最近一个区块中的coinbase交易：
- en: '`def getCoinbaseTransactionInfo(txn_m: mmap):`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getCoinbaseTransactionInfo(txn_m: mmap):`'
- en: '`tx = {}`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = {}`'
- en: '`startloc = txn_m.tell()`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`startloc = txn_m.tell()`'
- en: '`tx[‘version’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘version’] = txn_m.read(4)[::-1].hex()`'
- en: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inp_cnt’] = getVarInt(txn_m)`  '
- en: '`tx[‘is_segwit’] = False`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘is_segwit’] = False`  '
- en: '`if tx[‘inp_cnt’] == 0:`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘inp_cnt’] == 0:`  '
- en: '`# check segwit flag`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 检查隔离见证标志`  '
- en: '`tx[‘is_segwit’] = (int.from_bytes(txn_m.read(1), byteorder=’little’) == 1)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘is_segwit’] = (int.from_bytes(txn_m.read(1), byteorder=’little’) == 1)`  '
- en: '`if tx[‘is_segwit’] == True:`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘is_segwit’] == True:`  '
- en: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inp_cnt’] = getVarInt(txn_m)`  '
- en: '`inp_l = []`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_l = []`  '
- en: '`for i in range(tx[‘inp_cnt’]):`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘inp_cnt’]):`  '
- en: '`inp = {}`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp = {}`  '
- en: '`inp[‘prev_tx_hash’] = txn_m.read(32)[::-1].hex()`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘prev_tx_hash’] = txn_m.read(32)[::-1].hex()`  '
- en: '`inp[‘prev_tx_out_index’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘prev_tx_out_index’] = txn_m.read(4)[::-1].hex()`  '
- en: '`inp[‘bytes_coinbase_data’] = getVarInt(txn_m)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘bytes_coinbase_data’] = getVarInt(txn_m)`  '
- en: '`pos = txn_m.tell()`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`pos = txn_m.tell()`  '
- en: '`inp[‘bytes_height’] = getVarInt(txn_m)`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘bytes_height’] = getVarInt(txn_m)`  '
- en: '`inp[‘height’] = int.from_bytes(txn_m.read(inp[‘bytes_height’]), byteorder=’little’)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘height’] = int.from_bytes(txn_m.read(inp[‘bytes_height’]), byteorder=’little’)`  '
- en: '`size = txn_m.tell() - pos`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`size = txn_m.tell() - pos`  '
- en: '`coinbase_arb_data_size = inp[‘bytes_coinbase_data’] - size`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`coinbase_arb_data_size = inp[‘bytes_coinbase_data’] - size`  '
- en: '`inp[‘coinbase_arb_data’] = txn_m.read(coinbase_arb_data_size).hex()`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘coinbase_arb_data’] = txn_m.read(coinbase_arb_data_size).hex()`  '
- en: '`inp[‘sequence’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘sequence’] = txn_m.read(4)[::-1].hex()`  '
- en: '`inp_l.append(inp)`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_l.append(inp)`  '
- en: '`tx[‘inputs’] = inp_l`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’] = inp_l`  '
- en: '`tx[‘out_cnt’] = getVarInt(txn_m)`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘out_cnt’] = getVarInt(txn_m)`  '
- en: '`out_l = []`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_l = []`  '
- en: '`for i in range(tx[‘out_cnt’]):`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘out_cnt’]):`  '
- en: '`out = {}`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`out = {}`  '
- en: '`out[‘satoshis’] = int.from_bytes(txn_m.read(8), byteorder=’little’)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘satoshis’] = int.from_bytes(txn_m.read(8), byteorder=’little’)`  '
- en: '`out[‘bytes_scriptpubkey’] = getVarInt(txn_m)`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘bytes_scriptpubkey’] = getVarInt(txn_m)`  '
- en: '`out[‘scriptpubkey’] = txn_m.read(out[‘bytes_scriptpubkey’]).hex()`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘scriptpubkey’] = txn_m.read(out[‘bytes_scriptpubkey’]).hex()`  '
- en: '`out_l.append(out)`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_l.append(out)`  '
- en: '`tx[‘outs’] = out_l`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘outs’] = out_l`  '
- en: '`curloc = txn_m.tell()`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`curloc = txn_m.tell()`  '
- en: '`txn_m.seek(startloc)`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(startloc)`  '
- en: '`txid_b = txn_m.read(curloc - startloc)`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = txn_m.read(curloc - startloc)`  '
- en: '`if tx[‘is_segwit’] == True:`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘is_segwit’] == True:`  '
- en: '`# if segflag is true than remove segwit marker and flag from txhash calculation`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 如果 segflag 为真，则从 txhash 计算中删除 segwit 标记和标志`  '
- en: '`txid_b = txid_b[:4] + txid_b[6:]`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = txid_b[:4] + txid_b[6:]`  '
- en: '`for i in range(tx[‘inp_cnt’]):`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘inp_cnt’]):`  '
- en: '`tx[‘inputs’][i][‘witness_cnt’] = getVarInt(txn_m)`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’][i][‘witness_cnt’] = getVarInt(txn_m)`  '
- en: '`witness_cnt = tx[‘inputs’][i][‘witness_cnt’]`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_cnt = tx[‘inputs’][i][‘witness_cnt’]`  '
- en: '`witness_l = []`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = []`  '
- en: '`for j in range(witness_cnt):`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`for j in range(witness_cnt):`  '
- en: '`witness = {}`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness = {}`  '
- en: '`witness[‘size’] = getVarInt(txn_m)`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness[‘size’] = getVarInt(txn_m)`  '
- en: '`witness[‘witness’] = txn_m.read(witness[‘size’]).hex()`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness[‘witness’] = txn_m.read(witness[‘size’]).hex()`  '
- en: '`witness_l.append(witness)`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l.append(witness)`  '
- en: '`tx[‘inputs’][i][‘witnesses’] = witness_l`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’][i][‘witnesses’] = witness_l`'
- en: '`locktime_b = txn_m.read(4)`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`locktime_b = txn_m.read(4)`  '
- en: '`txid_b += locktime_b`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b += locktime_b`  '
- en: '`tx[‘locktime’] = int.from_bytes(locktime_b, byteorder=’little’)`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘locktime’] = int.from_bytes(locktime_b, byteorder=’little’)`  '
- en: '`tx[‘txid’] = hash256(txid_b)[::-1].hex()`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘txid’] = hash256(txid_b)[::-1].hex()`  '
- en: '`return tx`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`return tx`  '
- en: '**Program 12.1:** Parser for coinbase transaction'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.1：** 用于 coinbase 交易的解析器  '
- en: To get the coinbase transaction hex code for a block at height 668000, we first
    get the transaction hash of the coinbase transaction, which is the first transaction
    in the list of transactions in a block.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取高度为668000的区块的coinbase交易十六进制代码，我们首先获取coinbase交易的交易哈希，即区块中交易列表中的第一笔交易。
- en: '![](images/Figure-12.4.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.4.jpg)'
- en: '**Figure 12.4:** CLI Commands to get coinbase transaction ID'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.4：** 获取coinbase交易ID的CLI命令'
- en: 'We then get the coinbase transaction hex-code by using Bitcoin Core CLI as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过Bitcoin Core CLI获取coinbase交易十六进制代码如下：
- en: '![](images/Figure-12.5.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.5.jpg)'
- en: '**Figure 12.5:** CLI Command to get coinbase transaction hex code from its
    transaction ID'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.5：** 从其交易ID获取coinbase交易十六进制代码的CLI命令'
- en: 'We call the preceding method using coinbase transaction bytes, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用coinbase交易字节调用上述方法，如下所示：
- en: '`txn_b = bytes.fromhex(‘010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff400360310a040e5012602f706f6f6c696e2e636f6d2f746170726f6f742f626970392f57414aa61d1d79f4d92b134a2172611e120154741700bd36220000000000ffffffff041d066c260000000017a9149837b6ca944b36f71b94d19cf1e1acd179726424870000000000000000266a24b9e11b6db14323c98fb36550f3bf4d5ce2ea5fcb878ec778a849a99add2cc2e76141432b0000000000000000266a24aa21a9ed1cb4ceb5ec7fef10b852514760a409539056be66601f589c5539e443fbbfdcfc00000000000000002b6a2952534b424c4f434b3a68894f43c4cff546f6ee51f9e9475bcd2bfff279283cb6de9fc47c2c002eb263012000000000000000000000000000000000000000000000000000000000000000006b6066c1’)`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_b = bytes.fromhex(‘010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff400360310a040e5012602f706f6f6c696e2e636f6d2f746170726f6f742f626970392f57414aa61d1d79f4d92b134a2172611e120154741700bd36220000000000ffffffff041d066c260000000017a9149837b6ca944b36f71b94d19cf1e1acd179726424870000000000000000266a24b9e11b6db14323c98fb36550f3bf4d5ce2ea5fcb878ec778a849a99add2cc2e76141432b0000000000000000266a24aa21a9ed1cb4ceb5ec7fef10b852514760a409539056be66601f589c5539e443fbbfdcfc00000000000000002b6a2952534b424c4f434b3a68894f43c4cff546f6ee51f9e9475bcd2bfff279283cb6de9fc47c2c002eb263012000000000000000000000000000000000000000000000000000000000000000006b6066c1’)`'
- en: '`txn_m = mmap.mmap(-1, len(txn_b) + 1)`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m = mmap.mmap(-1, len(txn_b) + 1)`'
- en: '`txn_m.write(txn_b)`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.write(txn_b)`'
- en: '`txn_m.seek(0)`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(0)`'
- en: '`tx = getCoinbaseTransactionInfo(txn_m)`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getCoinbaseTransactionInfo(txn_m)`'
- en: '`print(json.dumps(tx))`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(json.dumps(tx))`'
- en: 'And we get following coinbase transaction information:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到以下coinbase交易信息：
- en: '![](images/Figure-12.6.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.6.jpg)'
- en: '**Figure 12.6:** Coinbase transaction information obtained from executing the
    Python program'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.6：** 从执行Python程序中获取的coinbase交易信息'
- en: Other transactions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他交易
- en: 'Here’s the illustration of SegWit transaction:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是隔离见证交易的示例：
- en: '![](images/Figure-12.7.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.7.jpg)'
- en: '**Figure 12.7:** Segregated witness transaction structure'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.7：** 隔离见证交易结构'
- en: The preceding transaction diagram shows that witness data contains scriptSig
    information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述交易图表显示，见证数据包含scriptSig信息。
- en: '[Segregated witness as scaling solution](toc.xhtml#s259a)'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[隔离见证作为扩展解决方案](toc.xhtml#s259a)'
- en: 'Segregated witness enhancement also allowed blocks to finally be larger than
    1 MB. It changed the way we calculate transaction byte size, now called weight.
    The new block size limit calculated in terms of weight is 4MB. The actual maximum
    block size is not really 4MB; it is much less. It is somewhere between 2 to 3
    MB. Here’s how we calculate weight:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉见证的增强功能也允许区块最终比1MB更大。它改变了我们计算事务字节大小的方式，现在称为权重。以权重计算的新块大小限制为4MB。实际最大块大小并不真的是4MB；它要小得多。它在2到3MB之间。这是我们如何计算权重的方法：
- en: '`weight = (4 * sizeof ([version][input count][inputs][output count][outputs]
    [locktime])) + sizeof ([segwit marker][segwit flag] [witness data])`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`weight = (4 * sizeof ([version][input count][inputs][output count][outputs]
    [locktime])) + sizeof ([segwit marker][segwit flag] [witness data])`'
- en: A miner is in the business of maximizing profit. For them, every byte counts,
    and they pick up transactions that ultimately lead to maximum accumulated network
    fees. When the miner sees a SegWit transaction, they know that weight is what
    matters and so they look for transactions with the highest bitcoin per weight
    paid.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工的业务是最大化利润。对他们来说，每一个字节都很重要，他们选择最终导致最大累积网络费用的交易。当矿工看到一个分叉见证交易时，他们知道重量才是最重要的，因此他们寻找支付比特币最高的交易。
- en: 'We use the transaction structure diagram and the learnings about `**txid**`,
    `**wtxid**`, and `**weight**` to write a program to parse a SegWit transaction
    and calculate these values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用事务结构图和关于`**txid**`、`**wtxid**`和`**weight**`的学习来编写一个程序，解析分叉见证事务并计算这些值：
- en: '`def getTransactionInfo(txn_m: mmap):`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getTransactionInfo(txn_m: mmap):`'
- en: '`tx = {}`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = {}`'
- en: '`startloc = txn_m.tell()`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`startloc = txn_m.tell()`'
- en: '`tx[‘version’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘version’] = txn_m.read(4)[::-1].hex()`'
- en: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
- en: '`tx[‘is_segwit’] = False`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘is_segwit’] = False`'
- en: '`if tx[‘inp_cnt’] == 0:`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘inp_cnt’] == 0:`'
- en: '`# check segwit flag`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`# check segwit flag`'
- en: '`tx[‘is_segwit’] = (int.from_bytes(txn_m.read(1), byteorder=’little’) == 1)`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘is_segwit’] = (int.from_bytes(txn_m.read(1), byteorder=’little’) == 1)`'
- en: '`if tx[‘is_segwit’] == True:`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘is_segwit’] == True:`'
- en: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inp_cnt’] = getVarInt(txn_m)`'
- en: '`inp_l = []`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_l = []`'
- en: '`for i in range(tx[‘inp_cnt’]):`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘inp_cnt’]):`'
- en: '`inp = {}`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp = {}`'
- en: '`inp[‘prev_tx_hash’] = txn_m.read(32)[::-1].hex()`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘prev_tx_hash’] = txn_m.read(32)[::-1].hex()`'
- en: '`inp[‘prev_tx_out_index’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘prev_tx_out_index’] = txn_m.read(4)[::-1].hex()`'
- en: '`inp[‘bytes_scriptsig’] = getVarInt(txn_m)`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘bytes_scriptsig’] = getVarInt(txn_m)`'
- en: '`inp[‘scriptsig’] = txn_m.read(inp[‘bytes_scriptsig’]).hex()`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘scriptsig’] = txn_m.read(inp[‘bytes_scriptsig’]).hex()`'
- en: '`inp[‘sequence’] = txn_m.read(4)[::-1].hex()`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp[‘sequence’] = txn_m.read(4)[::-1].hex()`'
- en: '`inp_l.append(inp)`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_l.append(inp)`'
- en: '`tx[‘inputs’] = inp_l`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’] = inp_l`'
- en: '`tx[‘out_cnt’] = getVarInt(txn_m)`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘out_cnt’] = getVarInt(txn_m)`'
- en: '`out_l = []`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_l = []`'
- en: '`for i in range(tx[‘out_cnt’]):`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘out_cnt’]):`'
- en: '`out = {}`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`out = {}`'
- en: '`out[‘satoshis’] = int.from_bytes(txn_m.read(8), byteorder=’little’)`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘satoshis’] = int.from_bytes(txn_m.read(8), byteorder=’little’)`'
- en: '`out[‘bytes_scriptpubkey’] = getVarInt(txn_m)`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘bytes_scriptpubkey’] = getVarInt(txn_m)`'
- en: '`out[‘scriptpubkey’] = txn_m.read(out[‘bytes_scriptpubkey’]).hex()`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`out[‘scriptpubkey’] = txn_m.read(out[‘bytes_scriptpubkey’]).hex()`'
- en: '`out_l.append(out)`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_l.append(out)`'
- en: '`tx[‘outs’] = out_l`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘outs’] = out_l`'
- en: '`curloc = txn_m.tell()`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`curloc = txn_m.tell()`'
- en: '`txn_m.seek(startloc)`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(startloc)`'
- en: '`txid_b = txn_m.read(curloc - startloc)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = txn_m.read(curloc - startloc)`'
- en: '`if tx[‘is_segwit’] == True:`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘is_segwit’] == True:`'
- en: '`# if SegWit flag is true than remove SegWit marker and flag from txhash calculation`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 如果 SegWit 标志为 true，则从 txhash 计算中删除 SegWit 标记和标志`'
- en: '`txid_b = txid_b[:4] + txid_b[6:]`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = txid_b[:4] + txid_b[6:]`'
- en: '`for i in range(tx[‘inp_cnt’]):`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(tx[‘inp_cnt’]):`'
- en: '`tx[‘inputs’][i][‘witness_cnt’] = getVarInt(txn_m)`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’][i][‘witness_cnt’] = getVarInt(txn_m)`'
- en: '`witness_l = []`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = []`'
- en: '`witness_cnt = tx[‘inputs’][i][‘witness_cnt’]`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_cnt = tx[‘inputs’][i][‘witness_cnt’]`'
- en: '`for j in range(witness_cnt):`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`for j in range(witness_cnt):`'
- en: '`witness = {}`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness = {}`'
- en: '`witness[‘size’] = getVarInt(txn_m)`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness[‘size’] = getVarInt(txn_m)`'
- en: '`witness[‘witness’] = txn_m.read(witness[‘size’]).hex()`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness[‘witness’] = txn_m.read(witness[‘size’]).hex()`'
- en: '`witness_l.append(witness)`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l.append(witness)`'
- en: '`tx[‘inputs’][i][‘witnesses’] = witness_l`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘inputs’][i][‘witnesses’] = witness_l`'
- en: '`locktime_b = txn_m.read(4)`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`locktime_b = txn_m.read(4)`'
- en: '`txid_b += locktime_b`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b += locktime_b`'
- en: '`tx[‘locktime’] = int.from_bytes(locktime_b, byteorder=’little’)`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘locktime’] = int.from_bytes(locktime_b, byteorder=’little’)`'
- en: '`tx[‘txid’] = hash256(txid_b)[::-1].hex()`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘txid’] = hash256(txid_b)[::-1].hex()`'
- en: '`curloc = txn_m.tell()`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`curloc = txn_m.tell()`'
- en: '`txn_m.seek(startloc)`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(startloc)`'
- en: '`wtxid_b = txn_m.read(curloc - startloc)`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`wtxid_b = txn_m.read(curloc - startloc)`'
- en: '`tx[‘wtxid’] = hash256(wtxid_b)[::-1].hex()`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘wtxid’] = hash256(wtxid_b)[::-1].hex()`'
- en: '`tx[‘bytes’] = len(wtxid_b)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘bytes’] = len(wtxid_b)`'
- en: '`tx[‘weight’] = (len(wtxid_b) - len(txid_b)) + (len(txid_b) * 4)`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx[‘weight’] = (len(wtxid_b) - len(txid_b)) + (len(txid_b) * 4)`'
- en: '`return tx`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`return tx`'
- en: '**Program 12.2:** Parser for transaction'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.2：** 交易解析器'
- en: 'The preceding program gives us transaction information of a given SegWit transaction.
    We are using the program to parse transaction with `**txid**`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序给出了给定 SegWit 交易的交易信息。我们正在使用该程序解析带有 `**txid**` 的交易：
- en: '`c6176c811328a9fd82a3a71da78e73781bc5c9a6580fdee4cf4392b165b1a072`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`c6176c811328a9fd82a3a71da78e73781bc5c9a6580fdee4cf4392b165b1a072`'
- en: 'We can get `**wtxid**` or transaction hash using Bitcoin Core as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Bitcoin Core 如下获取 `**wtxid**` 或交易哈希：
- en: '![](images/Figure-12.8.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.8.jpg)'
- en: '**Figure 12.8:** CLI command to get wtxid from txid'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.8：** 从 txid 获取 wtxid 的 CLI 命令'
- en: 'We call the method as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用该方法如下：
- en: '`txn_b = bytes.fromhex(‘02000000000102dc0f4a1601bd6bfec4241fede438bee45958773fe5d95f88ec890e2363983e0c0100000000ffffffff904d74d770c0ef5ce91190750b235d7ffb340b82b392812ba8e6ad5f0a8c4ca70000000000ffffffff02f31f0a00000000001600140c986c1d8ad520c072ee1aa0a151615c891ef71455b8180000000000160014097e656deb55afa3786c600a87d990dcab86fc2d024730440220685234e91eb14e6d1717c543193181700b1cbf5fecddbee79ed9b6b0bbf24077022033dac5cc679dca810327dcac4b84ba2b007a3a4fda6fb2cbc6099ae91c53804f01210277bed123bc0c0f9883b0bc14014f0385d39eac7ac7212d8c9928fa4121a191f4024730440220635eb52780098e3bd1e39a630a23f553ac62b97d0cd0356fa34ceb47cb0195250220599b83d8872ff173781b83b36bf159b59ed7685f73811f449fa1df814fbef15c0121022cd4d498f1ed0ee382eefe4b6e1d8c5aa678d47b693389ccdf77559b3220c5fa00000000’)`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_b = bytes.fromhex(‘02000000000102dc0f4a1601bd6bfec4241fede438bee45958773fe5d95f88ec890e2363983e0c0100000000ffffffff904d74d770c0ef5ce91190750b235d7ffb340b82b392812ba8e6ad5f0a8c4ca70000000000ffffffff02f31f0a00000000001600140c986c1d8ad520c072ee1aa0a151615c891ef71455b8180000000000160014097e656deb55afa3786c600a87d990dcab86fc2d024730440220685234e91eb14e6d1717c543193181700b1cbf5fecddbee79ed9b6b0bbf24077022033dac5cc679dca810327dcac4b84ba2b007a3a4fda6fb2cbc6099ae91c53804f01210277bed123bc0c0f9883b0bc14014f0385d39eac7ac7212d8c9928fa4121a191f4024730440220635eb52780098e3bd1e39a630a23f553ac62b97d0cd0356fa34ceb47cb0195250220599b83d8872ff173781b83b36bf159b59ed7685f73811f449fa1df814fbef15c0121022cd4d498f1ed0ee382eefe4b6e1d8c5aa678d47b693389ccdf77559b3220c5fa00000000’)`'
- en: '`txn_m = mmap.mmap(-1, len(txn_b) + 1)`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m = mmap.mmap(-1, len(txn_b) + 1)`'
- en: '`txn_m.write(txn_b)`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.write(txn_b)`'
- en: '`txn_m.seek(0)`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(0)`'
- en: '`tx = getTransactionInfo(txn_m)`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(txn_m)`'
- en: '`print(json.dumps(tx))`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(json.dumps(tx))`'
- en: 'We get following transaction information:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下交易信息：
- en: '![](images/Figure-12.9.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.9.jpg)'
- en: '**Figure 12.9:** Transaction information obtained by executing the Python program'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.9：** 通过执行Python程序获取的交易信息'
- en: 'In the preceding program, `**vsize**` is calculated as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，`**vsize**`的计算如下：
- en: '`vsize = weight / 4`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`vsize = weight / 4`'
- en: The preceding program also gives us `**wtxid**`. To ensure the integrity of
    the whole transaction along with witness data, we calculate commitment hash. This
    commitment hash is derived using segregated witness –Merkle root, which is calculated
    by using `**wtxid**` of all the transactions in a block. When the miner is adding
    commitment hash to coinbase transaction, they cannot know `**wtxid**` of coinbase
    transaction. This is the reason we don’t calculate `**wtxid**` of the coinbase
    transaction. Instead, we give it a 32-byte value consisting of all zeroes. Additionally,
    we need witness reserve value, which is the first witness of the first input.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序还给了我们`**wtxid**`。为了确保整个交易以及见证数据的完整性，我们计算承诺哈希。这个承诺哈希是使用隔离见证 - 默克尔根派生的，它是通过使用一个块中所有交易的`**wtxid**`来计算的。当矿工将承诺哈希添加到coinbase交易时，他们无法知道coinbase交易的`**wtxid**`。这就是我们不计算coinbase交易的`**wtxid**`的原因。相反，我们给它一个由所有零字节组成的32字节值。此外，我们需要见证保留值，它是第一个输入的第一个见证。
- en: 'In the following program, we calculate the commitment hash:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，我们计算承诺哈希：
- en: '`def getWitnessReservedValue(cb_tx: dict):`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getWitnessReservedValue(cb_tx: dict):`'
- en: '`return cb_tx[‘inputs’][0][‘witnesses’][0][‘witness’]`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`return cb_tx[‘inputs’][0][‘witnesses’][0][‘witness’]`'
- en: '`def getRootHashes(txn_m):`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getRootHashes(txn_m):`'
- en: '`txcount = getVarInt(txn_m)`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`txcount = getVarInt(txn_m)`'
- en: '`wtxid_l = []`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`wtxid_l = []`'
- en: '`txid_l = []`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l = []`'
- en: '`cb_tx = getCoinbaseTransactionInfo(txn_m)`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`cb_tx = getCoinbaseTransactionInfo(txn_m)`'
- en: '`txid_l.append(cb_tx[‘txid’])`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l.append(cb_tx[‘txid’])`'
- en: '`wtxid_l.append(bytes(32).hex())`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`wtxid_l.append(bytes(32).hex())`'
- en: '`for txindex in range(txcount - 1):`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`for txindex in range(txcount - 1):`'
- en: '`tx = getTransactionInfo(txn_m)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(txn_m)`'
- en: '`wtxid_l.append(tx[‘wtxid’])`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`wtxid_l.append(tx[‘wtxid’])`'
- en: '`txid_l.append(tx[‘txid’])`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l.append(tx[‘txid’])`'
- en: '`witness_merkle_root_h = buildMerkleRoot(wtxid_l)`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_merkle_root_h = buildMerkleRoot(wtxid_l)`'
- en: '`merkle_root_h = buildMerkleRoot(txid_l)`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`merkle_root_h = buildMerkleRoot(txid_l)`'
- en: '`return merkle_root_h, witness_merkle_root_h, cb_tx`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`return merkle_root_h, witness_merkle_root_h, cb_tx`'
- en: '`def calculateCommitmentHash(blkhash_b: bytes, block_db):`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`def calculateCommitmentHash(blkhash_b: bytes, block_db):`'
- en: '`jsonobj = getBlockIndex(blkhash_b, block_db)`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonobj = getBlockIndex(blkhash_b, block_db)`'
- en: '`if ‘data_pos’ in jsonobj:`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`if ‘data_pos’ in jsonobj:`'
- en: '`txn_filepath = os.path.join(blocks_path_g, ‘blk%05d.dat’ % jsonobj[‘n_file’])`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_filepath = os.path.join(blocks_path_g, ‘blk%05d.dat’ % jsonobj[‘n_file’])`'
- en: '`start = jsonobj[‘data_pos’]`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`start = jsonobj[‘data_pos’]`'
- en: '`elif ‘undo_pos’ in jsonobj:`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif ‘undo_pos’ in jsonobj:`'
- en: '`txn_filepath = os.path.join(blocks_path_g, ‘rev%05d.dat’ % jsonobj[‘n_file’])`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_filepath = os.path.join(blocks_path_g, ‘rev%05d.dat’ % jsonobj[‘n_file’])`'
- en: '`start = jsonobj[‘undo_pos’]`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`start = jsonobj[‘undo_pos’]`'
- en: '`# load file to memory`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 将文件加载到内存`'
- en: '`with open(txn_filepath, ‘rb’) as txn_file:`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`with open(txn_filepath, ‘rb’) as txn_file:`'
- en: '`#File is open read-only`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 文件以只读方式打开`'
- en: '`with mmap.mmap(txn_file.fileno(), 0, prot = mmap.PROT_READ, flags = mmap.MAP_PRIVATE)
    as txn_m:`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`with mmap.mmap(txn_file.fileno(), 0, prot = mmap.PROT_READ, flags = mmap.MAP_PRIVATE)
    as txn_m:`'
- en: '`txn_m.seek(start)`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn_m.seek(start)`'
- en: '`blkhdr = getBlockHeader(txn_m.read(80))`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkhdr = getBlockHeader(txn_m.read(80))`'
- en: '`merkle_root_h, witness_merkle_root_h, cb_tx = getRootHashes(txn_m)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`merkle_root_h, witness_merkle_root_h, cb_tx = getRootHashes(txn_m)`'
- en: '`print(‘Calculated Witness Merkle Root Hash\t = %s’ % witness_merkle_root_h)`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘计算的见证默克尔根哈希\t = %s’ % witness_merkle_root_h)`'
- en: '`print(‘Calculated Merkle Root Hash\t = %s’ % merkle_root_h)`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘计算的默克尔根哈希\t = %s’ % merkle_root_h)`'
- en: '`witness_reserved_value = getWitnessReservedValue(cb_tx)`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_reserved_value = getWitnessReservedValue(cb_tx)`'
- en: '`print(‘witness_reserved_value = ‘, witness_reserved_value)`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘见证保留值 = ‘, witness_reserved_value)`'
- en: '`# calculate commitment hash`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 计算承诺哈希`'
- en: '`commitment_hb = hashOfJoinedStr(witness_merkle_root_h, witness_reserved_value)`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitment_hb = hashOfJoinedStr(witness_merkle_root_h, witness_reserved_value)`'
- en: '`commitment_h = commitment_hb.hex()`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitment_h = commitment_hb.hex()`'
- en: '`print(‘calculated commitment hash = ‘, commitment_h)`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘计算的承诺哈希 = ‘, commitment_h)`'
- en: '`return commitment_h, cb_tx`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`return commitment_h, cb_tx`'
- en: '**Program 12.3:** Calculate commitment hash'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.3：** 计算承诺哈希'
- en: 'To verify that the calculated transaction hash is correct, we use the output
    index that has scriptPubKey starting with ‘`**6a24aa21a9ed**`’:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证计算的交易哈希是否正确，我们使用以‘`**6a24aa21a9ed**`’开头的 scriptPubKey 的输出索引：
- en: '`def getCommitmentHashInCbTx(cb_tx: dict):`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getCommitmentHashInCbTx(cb_tx: dict):`'
- en: '`for output in cb_tx[‘outs’]:`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`for output in cb_tx[‘outs’]:`'
- en: '`if output[‘scriptpubkey’][:12] == ‘6a24aa21a9ed’:`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`if output[‘scriptpubkey’][:12] == ‘6a24aa21a9ed’:`'
- en: '`commitment_h = output[‘scriptpubkey’][12:]`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitment_h = output[‘scriptpubkey’][12:]`'
- en: '`print(‘Actual commitment hash = ‘, commitment_h)`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Actual commitment hash = ‘, commitment_h)`'
- en: '`return commitment_h`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`return commitment_h`'
- en: '`def verifyCommitmentHash(cb_tx: dict, commitment_h: str):`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`def verifyCommitmentHash(cb_tx: dict, commitment_h: str):`'
- en: '`if getCommitmentHashInCbTx(cb_tx) == commitment_h:`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`if getCommitmentHashInCbTx(cb_tx) == commitment_h:`'
- en: '`print(‘Commitment hash matches’)`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Commitment hash matches’)`'
- en: '`else:`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘Invalid commitment hash’)`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Invalid commitment hash’)`'
- en: '**Program 12.4:** Verify commitment hash'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.4：** 验证承诺哈希'
- en: 'We call the preceding programs as follows to calculate commitment hash and
    verify its correctness:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下调用前述程序来计算承诺哈希并验证其正确性：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`blk_hb = bytes.fromhex(‘00000000000000000000f608724d1e152a875384e5ed06ae4a889c5a6c19c2f1’)[::-1]`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_hb = bytes.fromhex(‘00000000000000000000f608724d1e152a875384e5ed06ae4a889c5a6c19c2f1’)[::-1]`'
- en: '`commitment_h, cb_tx = calculateCommitmentHash(blk_hb, block_db_g)`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitment_h, cb_tx = calculateCommitmentHash(blk_hb, block_db_g)`'
- en: '`verifyCommitmentHash(cb_tx, commitment_h)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyCommitmentHash(cb_tx, commitment_h)`'
- en: 'This gives us the following result:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '![](images/Figure-12.10.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.10.jpg)'
- en: '**Figure 12.10:** Commitment hash obtained by executing the Python program'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.10：** 通过执行 Python 程序获得的承诺哈希'
- en: '[Transaction fee calculation](toc.xhtml#s260a)'
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[交易费用计算](toc.xhtml#s260a)'
- en: Bitcoin Core provides us fee estimates based on factors such as transaction
    fees collected in each transaction, which are in mempool, mempool size, and mempool
    clearing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Bitcoin Core 根据诸如每个交易中收集的交易费、内存池中的交易、内存池大小和内存池清除等因素为我们提供费用估算。
- en: 'The following Bitcoin Core CLI command gives us a fee estimate:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Bitcoin Core CLI 命令给出了费用估算：
- en: '![](images/Figure-12.11.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.11.jpg)'
- en: '**Figure 12.11:** CLI command to get recommended transaction fee rate'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.11：** 获取推荐交易费率的 CLI 命令'
- en: This shows that to get a transaction included within the next six blocks, we
    need to pay 0.00075062 per kilo-vbytes. The vbytes here are the same as vsize
    we get in the Bitcoin Core CLI output.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，要在接下来的六个区块内包含交易，我们需要支付每千字节 0.00075062 的费用。这里的 vbytes 与我们在 Bitcoin Core CLI
    输出中获得的 vsize 相同。
- en: 'The following program calculates the **Estimated Minimum Fee** required for
    getting the transaction confirmed:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序计算获取交易确认所需的**估计最低费用**：
- en: '`def calculateTransactionFee(vsize: int, feerate: float):`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`def calculateTransactionFee(vsize: int, feerate: float):`'
- en: '`return feerate * vsize/1000`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`return feerate * vsize/1000`'
- en: '**Program 12.5:** Program to calculate transaction fee'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.5：** 计算交易费用的程序'
- en: 'We call the preceding method with the fee-rate estimation we got using Bitcoin
    Core CLI and `**vsize**` we got after dividing weight by 4:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Bitcoin Core CLI 获得的费率估算和我们通过将权重除以 4 得到的 `**vsize**` 调用前述方法：
- en: '`feerate = 0.00075062`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`feerate = 0.00075062`'
- en: '`vsize = 208`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`vsize = 208`'
- en: '`fee = calculateTransactionFee(vsize, feerate)`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`fee = calculateTransactionFee(vsize, feerate)`'
- en: '`print(‘Estimated Minimum Fee in bitcoin = ‘, fee)`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Estimated Minimum Fee in bitcoin = ‘, fee)`'
- en: 'We get following result:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](images/Figure-12.12.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.12.jpg)'
- en: '**Figure 12.12:** Calculated transaction fee based on recommended fee rate
    and vsize'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.12：** 根据推荐费率和 vsize 计算的交易费用'
- en: In US Dollars, this comes to $4.75 as current market price of 1![](images/Bitcoin.jpg)
    is $30425.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在美元中，这相当于$4.75，因为当前市场价格为 1![](images/Bitcoin.jpg) 为 $30425。
- en: '[New standard scripts](toc.xhtml#s261a)'
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[新的标准脚本](toc.xhtml#s261a)'
- en: 'Segregated witnesses introduced four new standard scripts. The scripts are
    defined in BIP 143 and can be found at the following URL:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证引入了四个新的标准脚本。这些脚本在 BIP 143 中定义，并可在以下 URL 找到：
- en: '**[https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**[https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)**'
- en: In the next section, we will understand each of these scripts and build programs
    to verify the transaction on mainnet blockchain.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解每个脚本，并构建程序来验证主网区块链上的交易。
- en: '[Native SegWit transaction scripts](toc.xhtml#s262a)'
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[本地 SegWit 交易脚本](toc.xhtml#s262a)'
- en: SegWit transaction, in addition to protecting fund transfer from transaction
    malleability, provides direct monetary benefit in terms of reduced transaction
    fee.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: SegWit 交易除了保护交易可塑性外，还在降低交易费用方面提供直接的货币利益。
- en: 'A native SegWit transaction looks as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 SegWit 交易如下所示：
- en: '`Previous scriptPubKey: <1-byte witness version> <2-40 bytes witness program>`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`上一个 scriptPubKey： <1 字节见证版本> <2-40 字节见证程序>`'
- en: '`ScriptSig: (empty)`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptSig: (空)`'
- en: '`Witness Data: <witness data>`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`见证数据： <见证数据>`'
- en: 'We can see that the `**previous scriptPubKey**` consists of two parts: witness
    version and witness program. This suggests that each witness version can have
    different programs. This is a scalable structure and allows future enhancements.
    In this chapter, we are discussing the scripts introduced in the first version
    of Segwit enhancement. The next version is used for Taproot and Schnorr signatures.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`**上一个 scriptPubKey**`由两部分组成：见证版本和见证程序。这表明每个见证版本可以有不同的程序。这是一种可扩展的结构，允许未来的增强。在本章中，我们讨论了
    Segwit 增强的第一个版本中引入的脚本。下一个版本用于 Taproot 和 Schnorr 签名。
- en: '[Native P2WPKH](toc.xhtml#s263a)'
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[本地 P2WPKH](toc.xhtml#s263a)'
- en: As the name suggests, P2WPKH is the SegWit alternate to the P2PKH script, which
    we already covered in *[Chapter 10, Create and Validate Transactions](c10.xhtml)*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，P2WPKH 是 P2PKH 脚本的 SegWit 替代，我们已经在*[第 10 章，创建和验证交易](c10.xhtml)*中涵盖过。
- en: 'The P2WPKH transaction is as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: P2WPKH 交易如下：
- en: '`Previous scriptPubKey: 0 <20-byte-PublicKeyHash>`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`上一个 scriptPubKey： 0 <20 字节公钥哈希>`'
- en: '`ScriptSig: (empty)`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptSig: (空)`'
- en: '`Witness data:`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`见证数据：`'
- en: '`<Signature>`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`<签名>`'
- en: '`<PublicKey>`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`<公钥>`'
- en: 'We can see that witness data is the same as `**scriptSig**` in P2PKH. So, we
    only need to make small modifications in the script execution. We need to do the
    following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到见证数据与 P2PKH 中的`**scriptSig**`相同。因此，我们只需要在脚本执行中进行小的修改。我们需要做以下几步：
- en: Convert `**previous scriptPubKey**` to P2PKH standard script.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`**上一个 scriptPubKey**`转换为 P2PKH 标准脚本。
- en: Add witness data to the stack before processing `**previous scriptPubKey**`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理`**previous scriptPubKey**`之前向堆栈添加见证数据。
- en: We modified the program used in P2SH in *[Chapter 10, Create and Validate Transactions](c04.xhtml)*
    to perform this exact activity to include the verification of P2WPKH transactions.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了在*[第10章，创建和验证交易](c04.xhtml)*中用于P2SH的程序，以执行包括对P2WPKH交易的验证的准确活动。
- en: We modify `**verifyScript**` to include a check for P2WPKH by following these
    steps.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤修改`**verifyScript**`以包含对P2WPKH的检查。
- en: 'If `**scriptsig_b**` is an empty string, add all elements of witness data corresponding
    to the required input index:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`**scriptsig_b**`是空字符串，则添加对应于所需输入索引的所有见证数据元素：
- en: '`if scriptsig_b == b`**’’**`:`'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if scriptsig_b == b`**’’**`:`'
- en: '`# native segwit`'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`# native segwit`'
- en: '`print(‘native segwit’)`'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘native segwit’)`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`else:`'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`execScript(scriptsig_b, inp_index, tx)`'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`execScript(scriptsig_b, inp_index, tx)`'
- en: 'Convert `**Previous scriptPubKey**` to standard P2PKH script:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`**Previous scriptPubKey**`转换为标准的P2PKH脚本：
- en: '`if isP2WPKH(prev_scriptpubkey_b) == **True**:`'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if isP2WPKH(prev_scriptpubkey_b) == **True**:`'
- en: '`**print**(**‘P2WPKH’**)`'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**print**(**‘P2WPKH’**)`'
- en: '`# convert 0 <20-byte PKH> to OP_DUP OP_HASH160 <PKH> OP_EQUALVERIFY`'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`# convert 0 <20-byte PKH> to OP_DUP OP_HASH160 <PKH> OP_EQUALVERIFY`'
- en: '`prev_scriptpubkey_b = **bytes**([**0x76**, **0xa9**, **0x14**]) + prev_scriptpubkey_b[**2**:]
    + **bytes**([**0x88**, **0xac**])`'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = **bytes**([**0x76**, **0xa9**, **0x14**]) + prev_scriptpubkey_b[**2**:]
    + **bytes**([**0x88**, **0xac**])`'
- en: '`is_segwit = **True**`'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is_segwit = **True**`'
- en: 'The following is the definition of all the methods used in the preceding changes:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述更改中使用的所有方法的定义：
- en: '`def pushWitnessData(witness_l: list):`'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`def pushWitnessData(witness_l: list):`'
- en: '`for data in witness_l:`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`for data in witness_l:`'
- en: '`st.append(bytes.fromhex(data[‘witness’]))`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(bytes.fromhex(data[‘witness’]))`'
- en: '`def getWitnessList(tx: dict, inp_index: int):`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getWitnessList(tx: dict, inp_index: int):`'
- en: '`return tx[‘inputs’][inp_index][‘witnesses’]`'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`return tx[‘inputs’][inp_index][‘witnesses’]`'
- en: '`def isP2WPKH(prev_scriptpubkey_b: bytes):`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`def isP2WPKH(prev_scriptpubkey_b: bytes):`'
- en: '`#0014<20 bytes>`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`#0014<20 bytes>`'
- en: '`if len(prev_scriptpubkey_b) == 22 and prev_scriptpubkey_b[0:2] == b’\x00\x14’:`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(prev_scriptpubkey_b) == 22 and prev_scriptpubkey_b[0:2] == b’\x00\x14’:`'
- en: '`return True`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`return False`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '**Program 12.6:** Updates in program to verify P2WPKH script'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序12.6：** 更新程序以验证P2WPKH脚本'
- en: 'Here’s the code to call `**verifyScript**` to verify P2WPKH script:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用`**verifyScript**`以验证P2WPKH脚本的代码：
- en: '`#txid :: 808767ec8b388a7d6c34b9658e573e39034831fea49f0f22911393d6f8e195fb`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`#txid :: 808767ec8b388a7d6c34b9658e573e39034831fea49f0f22911393d6f8e195fb`'
- en: '`tx_s = ‘0100000000010240fc776263b1a4104da05cf069c8e7b0aeb7f7e4c686062906df9ab5d384716f0100000000ffffffff86ab7969a4d661aeaf8845f49eb2e5d30f6fb657d7694b8289224658158a62870000000000ffffffff02ea430000000000001976a9145d57c599fd94fce0cec607e15716f46468cb281b88aca47e000000000000160014f57aed6b1c121a10bec610987cbf414fb168778402483045022100eb6c3485c4ff17390dfbe35be9940b442783bd103095219c285331372b18913b02205bcbc7ce889823af020030d075832f314d1cc905269edf295e813dc7238dc37301210359522a87dc9c907d1669811b7254faf96d7ffcb1f22736bfcd0168fb19b9c98602483045022100acefd6d2ad0b56ad5837cd9d75b49c9f36f5deb6b12e290bbdc14076a38017cd02207a1add2928912d900756874e487d49b49defc7fc6f9805e9777afa929de5ffcb012102948374b79fa597475cab313e63d61d3d546288e6b9b3f80bd1ecc1a514dc382a00000000’`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_s = ‘0100000000010240fc776263b1a4104da05cf069c8e7b0aeb7f7e4c686062906df9ab5d384716f0100000000ffffffff86ab7969a4d661aeaf8845f49eb2e5d30f6fb657d7694b8289224658158a62870000000000ffffffff02ea430000000000001976a9145d57c599fd94fce0cec607e15716f46468cb281b88aca47e000000000000160014f57aed6b1c121a10bec610987cbf414fb168778402483045022100eb6c3485c4ff17390dfbe35be9940b442783bd103095219c285331372b18913b02205bcbc7ce889823af020030d075832f314d1cc905269edf295e813dc7238dc37301210359522a87dc9c907d1669811b7254faf96d7ffcb1f22736bfcd0168fb19b9c98602483045022100acefd6d2ad0b56ad5837cd9d75b49c9f36f5deb6b12e290bbdc14076a38017cd02207a1add2928912d900756874e487d49b49defc7fc6f9805e9777afa929de5ffcb012102948374b79fa597475cab313e63d61d3d546288e6b9b3f80bd1ecc1a514dc382a00000000’`'
- en: '`tx_b = bytes.fromhex(tx_s)`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_b = bytes.fromhex(tx_s)`'
- en: '`tx_m = bytes2Mmap(tx_b)`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_m = bytes2Mmap(tx_b)`'
- en: '`tx = getTransactionInfo(tx_m)`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(tx_m)`'
- en: '`verifyScript(tx, 0)`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, 0)`'
- en: 'We will cover signature verification later in the chapter. Signature verification
    is defined in detail in BIP 143\. We execute the preceding program, which verifies
    script, and we get the following results:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面介绍签名验证。签名验证在 BIP 143 中有详细定义。我们执行前述程序，验证脚本，并得到以下结果：
- en: '![](images/Figure-12.13.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.13.jpg)'
- en: '**Figure 12.13:** Executing the Python program shows that the signature is
    valid'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.13：** 执行 Python 程序显示签名有效'
- en: Though the result says signature is valid, we haven’t discussed in this subtopic
    and should be ignored.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结果显示签名有效，但我们在这个子主题中没有讨论过，应该忽略。
- en: '[Native P2WSH](toc.xhtml#s264a)'
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[本地 P2WSH](toc.xhtml#s264a)'
- en: 'P2WSH is SegWit alternative to P2SH. The P2WSH transaction is as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: P2WSH 是 P2SH 的 SegWit 替代方案。P2WSH 交易如下：
- en: '`Previous scriptPubKey: 0 <32-byte Redeem-Script-Hash>`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`上一个 scriptPubKey：0 <32 字节 赎回脚本哈希>`'
- en: '`ScriptSig: (empty)`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptSig: (空)`'
- en: '`Witness:`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`见证：`'
- en: '`<Signature 1>`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`<签名 1>`'
- en: '`<Signature 2>`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`<签名 2>`'
- en: '`…`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`'
- en: '`<redeemScript>`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`<赎回脚本>`'
- en: 'Here, P2SH-P2WSH uses a hash256 hashing algorithm. So, we convert `**previous
    scriptPubKey**` to the following script:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，P2SH-P2WSH 使用 hash256 哈希算法。所以，我们将 `**上一个 scriptPubKey**` 转换为以下脚本：
- en: '`OP_SHA256 <32-byte-redeemScriptHash> OP_EQUAL`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`OP_SHA256 <32 字节赎回脚本哈希> OP_EQUAL`'
- en: 'We modify `**verifyScript**` to include check for P2WSH:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改 `**verifyScript**` 以包含对 P2WSH 的检查：
- en: '`if isP2WSH(prev_scriptpubkey_b) == True:`'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isP2WSH(prev_scriptpubkey_b) == True:`'
- en: '`print(‘P2WSH’)`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2WSH’)`'
- en: '`prev_scriptpubkey_b = **bytes**([**0xa8**, **0x20**]) + prev_scriptpubkey_b[**2**:]
    + **bytes**([**0x87**])`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = **bytes**([**0xa8**, **0x20**]) + prev_scriptpubkey_b[**2**:]
    + **bytes**([**0x87**])`'
- en: 'Here’s the implementation of `**isP2WSH**`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `**isP2WSH**` 的实现：
- en: '`def isP2WSH(prev_scriptpubkey_b: bytes):`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`def isP2WSH(prev_scriptpubkey_b: bytes):`'
- en: '`#0020<32 bytes>`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`#0020<32 字节>`'
- en: '`if len(prev_scriptpubkey_b) == 34 and prev_scriptpubkey_b[0:2] == b’\x00\x20’:`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(prev_scriptpubkey_b) == 34 and prev_scriptpubkey_b[0:2] == b’\x00\x20’:`'
- en: '`return True`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`return False`'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: 'We also need to handle OP_SHA256\. We need to add a check to the `**execScript**`
    method, as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理 OP_SHA256。我们需要在 `**execScript**` 方法中添加一个检查，如下所示：
- en: '`def opSha256():`'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`def opSha256():`'
- en: '`v = st.pop()`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`v = st.pop()`'
- en: '`h = hashlib.sha256(v).digest()`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = hashlib.sha256(v).digest()`'
- en: '`st.append(h)`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.append(h)`'
- en: '`def execScript(script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`def execScript(script_b: bytes, inp_index: int, tx: dict):`'
- en: '`l = len(script_b)`'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`l = len(script_b)`'
- en: '`script_m = bytes2Mmap(script_b)`'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_m = bytes2Mmap(script_b)`'
- en: '`while script_m.tell() < l:`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`while script_m.tell() < l:`'
- en: '`v = script_m.read(1)`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`v = script_m.read(1)`'
- en: '`b = int.from_bytes(v, byteorder=’big’)`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = int.from_bytes(v, byteorder=’big’)`'
- en: '`if b in g_pushdata:`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`if b in g_pushdata:`'
- en: '`script_m.seek(-1, 1)`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_m.seek(-1, 1)`'
- en: '`b = decodePushdata(script_m)`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`b = decodePushdata(script_m)`'
- en: '`d = script_m.read(b)`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`d = script_m.read(b)`'
- en: '`pushdata(d)`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushdata(d)`'
- en: '`elif v == b’\x76’:`'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\x76’:`'
- en: '`opDup()`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`opDup()`'
- en: '`elif v == b’\xa8’:`'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xa8’:`'
- en: '`opSha256()`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`opSha256()`'
- en: '`elif v == b’\xa9’:`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xa9’:`'
- en: '`opHash160()`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`opHash160()`'
- en: '`elif b in g_pushnumber:`'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif b in g_pushnumber:`'
- en: '`opNum(b)`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`opNum(b)`'
- en: '`elif v == b’\x87’:`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\x87’:`'
- en: '`opEqual()`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`opEqual()`'
- en: '`elif v == b’\x88’:`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\x88’:`'
- en: '`opEqualVerify()`'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`opEqualVerify()`'
- en: '`elif v == b’\xac’:`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xac’:`'
- en: '`opCheckSig(script_b, inp_index, tx)`'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`opCheckSig(script_b, inp_index, tx)`'
- en: '`elif v == b’\xae’:`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif v == b’\xae’:`'
- en: '`opCheckMultisig(script_b, inp_index, tx)`'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`opCheckMultisig(script_b, inp_index, tx)`'
- en: '**Program 12.7:** Updates in program to verify P2WSH script'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.7：** 更新程序以验证 P2WSH 脚本'
- en: 'We call the program with changes, as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了有改动的程序，如下所示：
- en: '`#txid :: dffe1dc8f36cbc39c0f40b090912c5a00da13e3534f97aec0ef5bfe552019897`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`#txid :: dffe1dc8f36cbc39c0f40b090912c5a00da13e3534f97aec0ef5bfe552019897`'
- en: '`tx_s = ‘02000000000102c2aa999f988ded79cb8021420a01469212fa67e666c7d4078a2aaba1b13adf5c0100000000000000007d2ac99074ba44aac9afc79449d9aa29ae206136b511b12cbe699137740424f80100000000000000000220f31d01000000001976a9143913ef9cfc2bbf68665d735b89538dfb883b59f488ac48c70f0b000000002200209705cdfcbc459a220e7f39ffe547a31335505c2357f452ae12a22b9ae36ea59d040047304402205ca8ff900fd03ca9cba763eccb0888ec943269257286a852e9ba96cbc7da340a02206b84aff30cc2c7669fa4133a317fd9c04b013c1d1f42a647b400f62c9f61343101473044022041e2797e0a4b63878b03ff68d4fce8d6b31909e940024dcfd1c0eea33b7a5a160220140aca6751de16c377ea972e47cfc238b3d6d56477f348fa193588828e51e0030169522103ac79bbcf0ff2204220fbd0f906a8c0ae35ad0c1863852102f83af40e7af36cba2102cf85157ae613db5b445594e76f971cf21a0e26d0e70a85c447d3506fe678ddc721035f32d7cc9b710d8e5084dd93aa67efe95c6d32ba2a71b833fb035063ee40efd953ae0400473044022054c259d498dd1f32a449d7a53c597be64ed6331b32f9e9b2a96a098333d993660220789c04d6f69af4919ac97a963dbf2920df287fd4b5fb9ce595290acae3a59e6301473044022009f219deb061a83bf9505c3642efbdb3ef1af9dbef873c118d757d336a63ab0802201763f0ede288e3c7e1993263e47da73d3f43fa00a58c58bcc85e72c743076caf0169522102e67ce679d617d674d68eea95ecb166c67b4b5520105c4745adf37ce8a40b92dc21029ff54b8bf26dbddd7bd4336593d2ff17519d5374989f36a6f5f8239675ff79a421039000ee2853c6db4bd956e80b1ecfb8711bf3e0a9a8886d15450c29458b60473153ae00000000’`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_s = ‘02000000000102c2aa999f988ded79cb8021420a01469212fa67e666c7d4078a2aaba1b13adf5c0100000000000000007d2ac99074ba44aac9afc79449d9aa29ae206136b511b12cbe699137740424f80100000000000000000220f31d01000000001976a9143913ef9cfc2bbf68665d735b89538dfb883b59f488ac48c70f0b000000002200209705cdfcbc459a220e7f39ffe547a31335505c2357f452ae12a22b9ae36ea59d040047304402205ca8ff900fd03ca9cba763eccb0888ec943269257286a852e9ba96cbc7da340a02206b84aff30cc2c7669fa4133a317fd9c04b013c1d1f42a647b400f62c9f61343101473044022041e2797e0a4b63878b03ff68d4fce8d6b31909e940024dcfd1c0eea33b7a5a160220140aca6751de16c377ea972e47cfc238b3d6d56477f348fa193588828e51e0030169522103ac79bbcf0ff2204220fbd0f906a8c0ae35ad0c1863852102f83af40e7af36cba2102cf85157ae613db5b445594e76f971cf21a0e26d0e70a85c447d3506fe678ddc721035f32d7cc9b710d8e5084dd93aa67efe95c6d32ba2a71b833fb035063ee40efd953ae0400473044022054c259d498dd1f32a449d7a53c597be64ed6331b32f9e9b2a96a098333d993660220789c04d6f69af4919ac97a963dbf2920df287fd4b5fb9ce595290acae3a59e6301473044022009f219deb061a83bf9505c3642efbdb3ef1af9dbef873c118d757d336a63ab0802201763f0ede288e3c7e1993263e47da73d3f43fa00a58c58bcc85e72c743076caf0169522102e67ce679d617d674d68eea95ecb166c67b4b5520105c4745adf37ce8a40b92dc21029ff54b8bf26dbddd7bd4336593d2ff17519d5374989f36a6f5f8239675ff79a421039000ee2853c6db4bd956e80b1ecfb8711bf3e0a9a8886d15450c29458b60473153ae00000000’`'
- en: '`tx_b = bytes.fromhex(tx_s)`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_b = bytes.fromhex(tx_s)`'
- en: '`tx_m = bytes2Mmap(tx_b)`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_m = bytes2Mmap(tx_b)`'
- en: '`tx = getTransactionInfo(tx_m)`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(tx_m)`'
- en: '`verifyScript(tx, 0)`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, 0)`'
- en: 'On executing the preceding program, we get the following results:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述程序后，我们得到以下结果：
- en: '![](images/Figure-12.14.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.14.jpg)'
- en: '**Figure 12.14:** Executing the Python program shows that P2WSH Script is valid'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.14：** 执行 Python 程序后显示 P2WSH 脚本有效'
- en: '[Wrapped SegWit scripts](toc.xhtml#s265a)'
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[包装的隔离见证脚本](toc.xhtml#s265a)'
- en: The native SegWit scripts explained in the previous subtopics can also be wrapped
    inside P2SH. This allows easier migration to a newer format as a wrapped SegWit
    script still works with exchanges that have not yet upgraded to SegWit. Since
    SegWit solved the long-standing issue and was in the interest of the Bitcoin developer
    community to provide Bitcoin users a mechanism to migrate even before exchanges
    have migrated.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子主题中解释的原生 SegWit 脚本也可以包裹在 P2SH 中。这使得更容易迁移到一个更新的格式，因为一个被包裹的 SegWit 脚本仍然可以在尚未升级到
    SegWit 的交易所中使用。由于 SegWit 解决了长期存在的问题，并且对比特币开发者社区有利，为比特币用户提供了一种在交易所迁移之前就可以迁移的机制。
- en: If we want to move bitcoin to a Segwit wallet, then since Wrapped Segwit address
    is a P2SH address, the current exchange has no problem transferring bitcoin. Instead,
    if we try to send it to the native SegWit address, the current exchange will not
    understand the new addressing format, so the transaction will not be carried out.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将比特币转移到 Segwit 钱包中，那么由于 Wrapped Segwit 地址是一个 P2SH 地址，当前交易所在转移比特币时不会遇到问题。但是，如果我们尝试将其发送到原生
    SegWit 地址，则当前交易所将无法理解新的寻址格式，因此不会执行交易。
- en: '[Wrapped P2WPKH or P2SH-P2WPKH](toc.xhtml#s266a)'
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Wrapped P2WPKH 或 P2SH-P2WPKH](toc.xhtml#s266a)'
- en: 'P2SH-P2WPKH transaction has the following scripts:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: P2SH-P2WPKH 交易具有以下脚本：
- en: '`Previous scriptPubKey: OP_HASH160 <20-byte Redeem-Script-Hash> OP_EQUAL`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`Previous scriptPubKey: OP_HASH160 <20-byte Redeem-Script-Hash> OP_EQUAL`'
- en: '`ScriptSig: 0 <20-byte-PublicKeyHash>`'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptSig: 0 <20-byte-PublicKeyHash>`'
- en: '`Witness:`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`Witness:`'
- en: '`<Signature>`'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Signature>`'
- en: '`<PublicKey>`'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`<PublicKey>`'
- en: '`Redeem Script: scriptSig`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redeem Script: scriptSig`'
- en: 'We modify `**verifyScript**` to include a check for wrapped P2WPKH, as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改`**verifyScript**`以包括对包裹的 P2WPKH 的检查，如下所示：
- en: '`if checkWrappedP2WPKH(st) == True:`'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedP2WPKH(st) == True:`'
- en: '`prev_scriptpubkey_b = st[-1]`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = st[-1]`'
- en: '`st.pop()`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.pop()`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`print(‘P2SH_P2WPKH’)`'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH_P2WPKH’)`'
- en: 'This `**checkWrappedP2WPKH**` is implemented as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`**checkWrappedP2WPKH**`的实现如下：
- en: '`def checkWrappedP2WPKH(st):`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`def checkWrappedP2WPKH(st):`'
- en: '`script_b = st[-1]`'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_b = st[-1]`'
- en: '`if script_b[:2] == b’\x00\x14’ and len(script_b) == 22:`'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`if script_b[:2] == b’\x00\x14’ and len(script_b) == 22:`'
- en: '`return True`'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`else:`'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`return False`'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '**Program 12.8:** Method to check is script is P2SH_P2WPKH'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.8：** 检查脚本是否为 P2SH_P2WPKH 的方法'
- en: 'We call the updated method with transaction containing P2SH-P2WPKH script as
    follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用包含 P2SH-P2WPKH 脚本的交易来调用更新后的方法，如下所示：
- en: '`#txid :: c137ca3dc53cd1562da3fd5ceea22c8902c3cfd28b5303ecc70675dfff71ec2d`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`#txid :: c137ca3dc53cd1562da3fd5ceea22c8902c3cfd28b5303ecc70675dfff71ec2d`'
- en: '`tx_s = ‘020000000001027b806bcadab5c41bd3ccab867112fa041b36e0a8aff518296713721e36aed9f10000000017160014a5736b5f1caaf929de80829ec3acc2e13187f2c5feffffff7cbecb8841826bdb493bac6706be865731e414309d3640631f3571090abfdf20000000001716001405a7ef9d2ab852d55c58e42ac2d60202b2b6c9b0feffffff0234553d00000000001976a914265d799ec0fc523faba0ec8f5ee6f0621140a78588ac9cc911000000000017a9144bc6f0e3b0b3a26135ec3e5c6f88edb80881ce2c8702473044022072ddd8d42edee4662e388b8433c15516097d3bdb8a9ccec0acc21a7f7d068132022012f0ecfeb8682236c27fb8a591512102dfd8387a99111dad25a92fe65641841b01210335c4cfa33717ecea14e644ef938c9ecbcb7bd8569e8f407a014d835a8fb94efe02483045022100c038dd6cdf67aee993416e8471664a019f1d3204602e2acf759cf3cf3852d57c022017a84cdbc515de745587d62bb2b10597800c1b20f382a5b116ea8a0424ea242d012102e5692a54cbc71cb19cbc50b886305f0df9f462eae91125b39a85804cfe7a48012b310a00’`'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_s = ‘020000000001027b806bcadab5c41bd3ccab867112fa041b36e0a8aff518296713721e36aed9f10000000017160014a5736b5f1caaf929de80829ec3acc2e13187f2c5feffffff7cbecb8841826bdb493bac6706be865731e414309d3640631f3571090abfdf20000000001716001405a7ef9d2ab852d55c58e42ac2d60202b2b6c9b0feffffff0234553d00000000001976a914265d799ec0fc523faba0ec8f5ee6f0621140a78588ac9cc911000000000017a9144bc6f0e3b0b3a26135ec3e5c6f88edb80881ce2c8702473044022072ddd8d42edee4662e388b8433c15516097d3bdb8a9ccec0acc21a7f7d068132022012f0ecfeb8682236c27fb8a591512102dfd8387a99111dad25a92fe65641841b01210335c4cfa33717ecea14e644ef938c9ecbcb7bd8569e8f407a014d835a8fb94efe02483045022100c038dd6cdf67aee993416e8471664a019f1d3204602e2acf759cf3cf3852d57c022017a84cdbc515de745587d62bb2b10597800c1b20f382a5b116ea8a0424ea242d012102e5692a54cbc71cb19cbc50b886305f0df9f462eae91125b39a85804cfe7a48012b310a00’`'
- en: '`tx_b = bytes.fromhex(tx_s)`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_b = bytes.fromhex(tx_s)`'
- en: '`tx_m = bytes2Mmap(tx_b)`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_m = bytes2Mmap(tx_b)`'
- en: '`tx = getTransactionInfo(tx_m)`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(tx_m)`'
- en: '`verifyScript(tx, 0)`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, 0)`'
- en: 'On executing the preceding program, we get the following result:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述程序时，我们得到以下结果：
- en: '![](images/Figure-12.15.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.15.jpg)'
- en: '**Figure 12.15:** Executing the Python program shows that signature is valid'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.15：** 执行 Python 程序显示签名有效。'
- en: '[Wrapped P2WSH or P2SH-P2WSH](toc.xhtml#s267a)'
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[包装的 P2WSH 或 P2SH-P2WSH](toc.xhtml#s267a)'
- en: 'P2SH-P2WSH transaction has the following scripts:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: P2SH-P2WSH 交易具有以下脚本：
- en: '`Previous scriptPubKey: OP_HASH160 <20-byte-P2SH-RedeemScriptHash> OP_EQUAL`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`Previous scriptPubKey: OP_HASH160 <20 字节 P2SH-赎回脚本哈希> OP_EQUAL`'
- en: '`ScriptSig: 0 <32-byte P2WSH-Redeem-Script-Hash>`'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptSig: 0 <32 字节 P2WSH-赎回脚本哈希>`'
- en: '`Witness:`'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**见证：**'
- en: '`<witness items>`'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`<见证项>`'
- en: '`<P2WSH-Redeem-Script>`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`<P2WSH-赎回脚本>`'
- en: '`P2SH RedeemScript: scriptSig`'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`P2SH 赎回脚本：scriptSig`'
- en: 'We modify `**verifyScript**` to include check for wrapped P2WSH as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改`**verifyScript**`方法，包括检查包装 P2WSH 如下：
- en: '`if checkWrappedP2WSH(st) == True:`'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedP2WSH(st) == True:`'
- en: '`prev_scriptpubkey_b = st[-1]`'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = st[-1]`'
- en: '`st.pop()`'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.pop()`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`print(‘P2SH_P2SH’)`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH_P2SH’)`'
- en: 'The `**checkWrappedP2WSH method**` is implemented as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**checkWrappedP2WSH 方法**实现如下：'
- en: '`def checkWrappedP2WSH(st):`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`def checkWrappedP2WSH(st):`'
- en: '`script_b = st[-1]`'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_b = st[-1]`'
- en: '`if script_b[:2] == b’\x00\x20’ and len(script_b) == 34:`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`if script_b[:2] == b’\x00\x20’ and len(script_b) == 34:`'
- en: '`return True`'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`else:`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`return False`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '**Program 12.9:** Method to check is script is P2SH_P2WSH'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.9：** 检查是否为 P2SH_P2WSH 的方法'
- en: 'The combined changes made in the current and previous subtopics of SegWit transactions
    gives us the following `**verifyScript**`:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 综合当前和SegWit交易的以前子主题所做的更改，我们得到以下的`**verifyScript**`：
- en: '`def getPrevScriptPubKey(tx: dict, inp_index: int):`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getPrevScriptPubKey(tx: dict, inp_index: int):`'
- en: '`prevtx_rb = bytes.fromhex(tx[‘inputs’][inp_index][‘prev_tx_hash’])[::-1]`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevtx_rb = bytes.fromhex(tx[‘inputs’][inp_index][‘prev_tx_hash’])[::-1]`'
- en: '`prevtx_outindex = tx[‘inputs’][inp_index][‘prev_tx_out_index’]`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevtx_outindex = tx[‘inputs’][inp_index][‘prev_tx_out_index’]`'
- en: '`prevtx = findTransaction(prevtx_rb, txindex_db_g)`'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevtx = findTransaction(prevtx_rb, txindex_db_g)`'
- en: '`prevScriptPubkey = prevtx[‘outs’][prevtx_outindex][‘scriptpubkey’]`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevScriptPubkey = prevtx[‘outs’][prevtx_outindex][‘scriptpubkey’]`'
- en: '`prevScriptPubkey_b = bytes.fromhex(prevScriptPubkey)`'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevScriptPubkey_b = bytes.fromhex(prevScriptPubkey)`'
- en: '`return prevScriptPubkey_b`'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`return prevScriptPubkey_b`'
- en: '`def verifyScript(tx: dict, inp_index: int):`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`def verifyScript(tx: dict, inp_index: int):`'
- en: '`scriptsig_b = getScriptSig(tx, inp_index)`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptsig_b = getScriptSig(tx, inp_index)`'
- en: '`if scriptsig_b == b’’:`'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`if scriptsig_b == b’’:`'
- en: '`# native segwit`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`# native segwit`'
- en: '`print(‘native segwit’)`'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘native segwit’)`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`else:`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`execScript(scriptsig_b, inp_index, tx)`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(scriptsig_b, inp_index, tx)`'
- en: '`prev_scriptpubkey_b = getPrevScriptPubKey(tx, inp_index)`'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = getPrevScriptPubKey(tx, inp_index)`'
- en: '`isP2SH = False`'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`isP2SH = False`'
- en: '`if checkWrappedP2WPKH(st) == True:`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedP2WPKH(st) == True:`'
- en: '`prev_scriptpubkey_b = st[-1]`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = st[-1]`'
- en: '`st.pop()`'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.pop()`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`print(‘P2SH_P2WPKH’)`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH_P2WPKH’)`'
- en: '`if checkWrappedP2WSH(st) == True:`'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedP2WSH(st) == True:`'
- en: '`prev_scriptpubkey_b = st[-1]`'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = st[-1]`'
- en: '`st.pop()`'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.pop()`'
- en: '`witness_l = getWitnessList(tx, inp_index)`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness_l = getWitnessList(tx, inp_index)`'
- en: '`pushWitnessData(witness_l)`'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushWitnessData(witness_l)`'
- en: '`print(‘P2SH_P2WSH’)`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH_P2WSH’)`'
- en: '`if checkWrappedMultisig(st) == True:`'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`if checkWrappedMultisig(st) == True:`'
- en: '`redeemscript_b = st[-1]`'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`redeemscript_b = st[-1]`'
- en: '`isP2SH = True`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`isP2SH = True`'
- en: '`print(‘P2SH’)`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2SH’)`'
- en: '`if isP2WPKH(prev_scriptpubkey_b) == True:`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isP2WPKH(prev_scriptpubkey_b) == True:`'
- en: '`print(‘P2WPKH’)`'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2WPKH’)`'
- en: '`prev_scriptpubkey_b = bytes([0x76, 0xa9, 0x14]) + prev_scriptpubkey_b[2:]
    + bytes([0x88, 0xac])`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = bytes([0x76, 0xa9, 0x14]) + prev_scriptpubkey_b[2:]
    + bytes([0x88, 0xac])`'
- en: '`if isP2WSH(prev_scriptpubkey_b) == True:`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isP2WSH(prev_scriptpubkey_b) == True:`'
- en: '`print(‘P2WSH’)`'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘P2WSH’)`'
- en: '`prev_scriptpubkey_b = bytes([0xa8, 0x20]) + prev_scriptpubkey_b[2:] + bytes([0x87])`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_scriptpubkey_b = bytes([0xa8, 0x20]) + prev_scriptpubkey_b[2:] + bytes([0x87])`'
- en: '`print(‘previous scriptpubkey = ‘, prev_scriptpubkey_b.hex())`'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘previous scriptpubkey = ‘, prev_scriptpubkey_b.hex())`'
- en: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(prev_scriptpubkey_b, inp_index, tx)`'
- en: '`status = st.pop()`'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`status = st.pop()`'
- en: '`if status == b’\x01’:`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`if status == b’\x01’:`'
- en: '`print(‘1st Script succeeded’)`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script succeeded’)`'
- en: '`elif status == b’\x01’:`'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif status == b’\x01’:`'
- en: '`print(‘1st Script Failed’)`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Script Failed’)`'
- en: '`return`'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`else:`'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘1st Invalid state’)`'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘1st Invalid state’)`'
- en: '`return`'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`if isP2SH == True:`'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isP2SH == True:`'
- en: '`execScript(redeemscript_b, inp_index, tx)`'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`execScript(redeemscript_b, inp_index, tx)`'
- en: '`status = st.pop()`'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`status = st.pop()`'
- en: '`if status == b’\x01’:`'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`if status == b’\x01’:`'
- en: '`print(‘2nd Script succeeded’)`'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Script succeeded’)`'
- en: '`elif status == b’\x01’:`'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif status == b’\x01’:`'
- en: '`print(‘2nd Script Failed’)`'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Script Failed’)`'
- en: '`else:`'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘2nd Invalid state’)`'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘2nd Invalid state’)`'
- en: '**Program 12.10:** Updated Program to verify SegWit transaction'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.10：** 更新的程序以验证 SegWit 交易'
- en: 'We call the updated method with transaction containing P2SH-P2WSH script as
    follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用包含 P2SH-P2WSH 脚本的交易调用更新后的方法如下：
- en: '`#txid :: c6ab739d8455cd5133e9f93f542f70a2ccef0c7fb05de998db817dd680af3a91`'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`#txid :: c6ab739d8455cd5133e9f93f542f70a2ccef0c7fb05de998db817dd680af3a91`'
- en: '`tx_s = ‘010000000001024e453d886f11e3af494ce6073956b0de6eaed80865529ab45f778d660459907e2500000023220020ffc74359d1e79a79b94319a1695a68810e439e4c32e4c1be2b0b7c915ca78536ffffffff4e453d886f11e3af494ce6073956b0de6eaed80865529ab45f778d660459907e29000000232200207a21661b84ac4a34a6afc034030faba8ce8344635ebaf34cde31083f186bf871ffffffff02b02a02000000000017a9147b60c1eebfc2c78c9993668dab556344bf1f78d187d9df0500000000002200206f50cccbc64ea3f6cc434d5878bbe45a609e5592026ce6704f586a0e795a6ae40300483045022100d168fa78728fda205eee72ad7b789bc3153adeec982b2588a1526509aa1e2ae8022010443c0652848492dad4904f45258f5452256bfe23d9c715bf052d908154de6e0125512102972c9ea94bfcd5956220f2e99776b3c5ebcca9373a2eccb3fb5fff8bbc9f999451ae03004830450221009691361fa2953e54bc5287306c023fc2d098aa6e85ed1a66d3369e93781260b102201fb639437128d361a12ea385a61bd49247d25c254d1efc03d5272dd368c0acfa01255121027c6cbed24ad235fe147413272ba92cfd61d5ab338c4dabd74cbfb7d11746da5451ae00000000’`'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_s = ‘010000000001024e453d886f11e3af494ce6073956b0de6eaed80865529ab45f778d660459907e2500000023220020ffc74359d1e79a79b94319a1695a68810e439e4c32e4c1be2b0b7c915ca78536ffffffff4e453d886f11e3af494ce6073956b0de6eaed80865529ab45f778d660459907e29000000232200207a21661b84ac4a34a6afc034030faba8ce8344635ebaf34cde31083f186bf871ffffffff02b02a02000000000017a9147b60c1eebfc2c78c9993668dab556344bf1f78d187d9df0500000000002200206f50cccbc64ea3f6cc434d5878bbe45a609e5592026ce6704f586a0e795a6ae40300483045022100d168fa78728fda205eee72ad7b789bc3153adeec982b2588a1526509aa1e2ae8022010443c0652848492dad4904f45258f5452256bfe23d9c715bf052d908154de6e0125512102972c9ea94bfcd5956220f2e99776b3c5ebcca9373a2eccb3fb5fff8bbc9f999451ae03004830450221009691361fa2953e54bc5287306c023fc2d098aa6e85ed1a66d3369e93781260b102201fb639437128d361a12ea385a61bd49247d25c254d1efc03d5272dd368c0acfa01255121027c6cbed24ad235fe147413272ba92cfd61d5ab338c4dabd74cbfb7d11746da5451ae00000000’`'
- en: '`tx_b = bytes.fromhex(tx_s)`'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_b = bytes.fromhex(tx_s)`'
- en: '`tx_m = bytes2Mmap(tx_b)`'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_m = bytes2Mmap(tx_b)`'
- en: '`tx = getTransactionInfo(tx_m)`'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx = getTransactionInfo(tx_m)`'
- en: '`verifyScript(tx, 0)`'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyScript(tx, 0)`'
- en: 'Running the preceding code gives us the following result:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会给我们带来以下结果：
- en: '![](images/Figure-12.16.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.16.jpg)'
- en: '**Figure 12.16:** Executing the Python program shows that P2SH_P2WSH Script
    is valid'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.16：** 执行 Python 程序显示 P2SH_P2WSH 脚本有效'
- en: We learned that with simple modifications to the P2PKH/P2SH transaction verification
    program, we can also verify SegWit transactions. We still haven’t learned to create
    the right message for signature verification, so we will look at that in the next
    topic.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，通过对 P2PKH/P2SH 交易验证程序进行简单修改，我们也可以验证 SegWit 交易。我们还没有学会为签名验证创建正确的消息，所以我们将在下一个主题中讨论这个问题。
- en: '[Signature verification](toc.xhtml#s268a)'
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[签名验证](toc.xhtml#s268a)'
- en: In this section, we will understand BIP 143 to create the correct signature
    preimage. All SegWit transactions with the same sighash type have the same method
    of creating a signature preimage.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解 BIP 143 来创建正确的签名预像。所有具有相同 sighash 类型的 SegWit 交易都具有相同的签名预像创建方法。
- en: 'A signature preimage has the following structure:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 一个签名预像具有以下结构：
- en: '![](images/Figure-12.17.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.17.jpg)'
- en: '**Figure 12.17:** Signature preimage structure for SegWit transaction'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.17：** SegWit 交易的签名预像结构'
- en: 'Each part of the preimage is defined as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 签名预像的每一部分定义如下：
- en: Considering,
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑，
- en: '***TxIDprev: TxID of previous transaction***'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '***TxIDprev：上一个交易的 TxID***'
- en: '***TxOutIndexprev: Output index of previous transaction in inputs***'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '***TxOutIndexprev：在输入中上一个交易的输出索引***'
- en: '***output:*** *output of the transaction*'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '***output：*** *交易的输出*'
- en: '***‖:*** *concatenation*'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '***‖：*** *串联*'
- en: '***Hash256:*** *double SHA256 hash*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '***Hash256：*** *双 SHA256 哈希*'
- en: 'We have the following definition of each part of a signature preimage for sighash
    type `**SIGHASH_ALL**`:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 sighash 类型 `**SIGHASH_ALL**` 的每一部分签名预像有以下定义：
- en: '*hashPrevouts = Hash256(‖(TxID_prev∥ TxOutIndex[prev] ))*'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '*hashPrevouts = Hash256(‖(TxID_prev∥ TxOutIndex[prev] ))*'
- en: '*hashSequence = Hash256(‖(nSequence))*'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*hashSequence = Hash256(‖(nSequence))*'
- en: '*outpoint = TxID[prev] TxOutIndex[prev]*'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '*outpoint = TxID[prev] TxOutIndex[prev]*'
- en: '*scriptCode = executing script*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*scriptCode = 执行脚本*'
- en: '*hashOutputs = Hash256(‖(output))*'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*hashOutputs = Hash256(‖(output))*'
- en: 'We use this information to modify the P2SH transaction verification method
    written in *[Chapter 10, Create and Validate Transactions](c10.xhtml)* in order
    to include SegWit transactions. This is done as follows:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些信息修改了写在 *[第 10 章，创建和验证交易](c10.xhtml)* 中的 P2SH 交易验证方法，以包含 SegWit 交易。操作如下所示：
- en: '`def setVarInt(n: int):`'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`def setVarInt(n: int):`'
- en: '`if n < 0xfd:`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`if n < 0xfd:`'
- en: '`n_h = ‘%02x’ % n`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘%02x’ % n`'
- en: '`elif n > 0xfd and n < 0xffff:`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif n > 0xfd and n < 0xffff:`'
- en: '`n_h = ‘fd%04x’ % n`'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘fd%04x’ % n`'
- en: '`elif n > 0xffff and n < 0xFFFFFFFF:`'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif n > 0xffff and n < 0xFFFFFFFF:`'
- en: '`n_h = ‘fe%08x’ % n`'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘fe%08x’ % n`'
- en: '`else:`'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`n_h = ‘ff%016x’ % n`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘ff%016x’ % n`'
- en: '`return bytes.fromhex(n_h)`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`return bytes.fromhex(n_h)`'
- en: '`def getAmountFromPrevout(prev_tx_hash_b: bytes, prev_tx_out_index_b: bytes):`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getAmountFromPrevout(prev_tx_hash_b: bytes, prev_tx_out_index_b: bytes):`'
- en: '`prevtx = findTransaction(prev_tx_hash_b, txindex_db_g)`'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevtx = findTransaction(prev_tx_hash_b, txindex_db_g)`'
- en: '`prevtx_outindex = int.from_bytes(prev_tx_out_index_b, byteorder = ‘little’)`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevtx_outindex = int.from_bytes(prev_tx_out_index_b, byteorder = ‘little’)`'
- en: '`prevAmount = prevtx[‘outs’][prevtx_outindex][‘satoshis’]`'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevAmount = prevtx[‘outs’][prevtx_outindex][‘satoshis’]`'
- en: '`amount_b = struct.pack(“<Q”, prevAmount)`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`amount_b = struct.pack(“<Q”, prevAmount)`'
- en: '`return amount_b`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`return amount_b`'
- en: '`def createMsgForSigForSegwit(tx: dict, script_b: bytes, inp_index: int, sighash_type:
    int):`'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createMsgForSigForSegwit(tx: dict, script_b: bytes, inp_index: int, sighash_type:
    int):`'
- en: '`version_b = bytes.fromhex(tx[‘version’])[::-1]`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = bytes.fromhex(tx[‘version’])[::-1]`'
- en: '`inp_cnt = tx[‘inp_cnt’]`'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`inp_cnt = tx[‘inp_cnt’]`'
- en: '`prevouts_b = b’’`'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevouts_b = b’’`'
- en: '`sequences_b = b’’`'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequences_b = b’’`'
- en: '`for i in range(inp_cnt):`'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(inp_cnt):`'
- en: '`tx_inp = tx[‘inputs’][i]`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_inp = tx[‘inputs’][i]`'
- en: '`prev_tx_hash_b = bytes.fromhex(tx_inp[‘prev_tx_hash’])[::-1]`'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_tx_hash_b = bytes.fromhex(tx_inp[‘prev_tx_hash’])[::-1]`'
- en: '`prev_tx_out_index_b = struct.pack(‘<L’, tx_inp[‘prev_tx_out_index’])`'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev_tx_out_index_b = struct.pack(‘<L’, tx_inp[‘prev_tx_out_index’])`'
- en: '`sequences_b += struct.pack(‘<L’, tx_inp[‘sequence’])`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequences_b += struct.pack(‘<L’, tx_inp[‘sequence’])`'
- en: '`prevouts_b += prev_tx_hash_b + prev_tx_out_index_b`'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`prevouts_b += prev_tx_hash_b + prev_tx_out_index_b`'
- en: '`if i == inp_index:`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`if i == inp_index:`'
- en: '`outpoint_b = prev_tx_hash_b + prev_tx_out_index_b`'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`outpoint_b = prev_tx_hash_b + prev_tx_out_index_b`'
- en: '`print(‘script = ‘, script_b.hex())`'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘script = ‘, script_b.hex())`'
- en: '`scriptCode_b = bytes.fromhex(‘%x’ % len(script_b)) + script_b`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptCode_b = bytes.fromhex(‘%x’ % len(script_b)) + script_b`'
- en: '`amount_b = getAmountFromPrevout(prev_tx_hash_b, prev_tx_out_index_b)`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`amount_b = getAmountFromPrevout(prev_tx_hash_b, prev_tx_out_index_b)`'
- en: '`sequence_b = struct.pack(‘<L’, tx_inp[‘sequence’])`'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence_b = struct.pack(‘<L’, tx_inp[‘sequence’])`'
- en: '`out_cnt = tx[‘out_cnt’]`'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_cnt = tx[‘out_cnt’]`'
- en: '`outputs_b = b’’`'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs_b = b’’`'
- en: '`for o in range(out_cnt):`'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`for o in range(out_cnt):`'
- en: '`tx_out = tx[‘outs’][o]`'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_out = tx[‘outs’][o]`'
- en: '`satoshis_b = struct.pack(‘<Q’, tx_out[‘satoshis’])`'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`satoshis_b = struct.pack(‘<Q’, tx_out[‘satoshis’])`'
- en: '`bytes_scriptpubkey_b = setVarInt(tx_out[‘bytes_scriptpubkey’])`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes_scriptpubkey_b = setVarInt(tx_out[‘bytes_scriptpubkey’])`'
- en: '`scriptpubkey_b = bytes.fromhex(tx_out[‘scriptpubkey’])`'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptpubkey_b = bytes.fromhex(tx_out[‘scriptpubkey’])`'
- en: '`outputs_b += satoshis_b + bytes_scriptpubkey_b + scriptpubkey_b`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs_b += satoshis_b + bytes_scriptpubkey_b + scriptpubkey_b`'
- en: '`locktime_b = struct.pack(‘<L’, tx[‘locktime’])`'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`locktime_b = struct.pack(‘<L’, tx[‘locktime’])`'
- en: '`hashPrevouts_b = hash256(prevouts_b)`'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashPrevouts_b = hash256(prevouts_b)`'
- en: '`hashSequence_b = hash256(sequences_b)`'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashSequence_b = hash256(sequences_b)`'
- en: '`hashOutputs_b = hash256(outputs_b)`'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashOutputs_b = hash256(outputs_b)`'
- en: '`hashType_b = struct.pack(‘<L’, sighash_type)`'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashType_b = struct.pack(‘<L’, sighash_type)`'
- en: '`msg_b = version_b + hashPrevouts_b + hashSequence_b + outpoint_b + scriptCode_b
    + amount_b + sequence_b + hashOutputs_b + locktime_b + hashType_b`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg_b = version_b + hashPrevouts_b + hashSequence_b + outpoint_b + scriptCode_b
    + amount_b + sequence_b + hashOutputs_b + locktime_b + hashType_b`'
- en: '`return msg_b`'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`return msg_b`'
- en: '**Program 12.11:** Create a signature preimage for SegWit transaction'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.11：** 为隔离见证事务创建签名前图'
- en: 'The method is called from the following `**sigcheck**` method if the transaction
    has segregated witness:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是从以下`**sigcheck**`方法中调用的，如果事务有隔离见证：
- en: '`def uncompressPubkey(pubkey_b: bytes):`'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`def uncompressPubkey(pubkey_b: bytes):`'
- en: '`pubkey_P = PublicKey.decode(pubkey_b)`'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_P = PublicKey.decode(pubkey_b)`'
- en: '`pubkey_b = PublicKey.encode(pubkey_P, compressed=False)`'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubkey_b = PublicKey.encode(pubkey_P, compressed=False)`'
- en: '`return pubkey_b`'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`return pubkey_b`'
- en: '`def sigcheck(sig_b: bytes, pubkey_b: bytes,`'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sigcheck(sig_b: bytes, pubkey_b: bytes,`'
- en: '`script_b: bytes, inp_index: int, tx: dict):`'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '`script_b: bytes, inp_index: int, tx: dict):`'
- en: '`sighash_type = sig_b[-1]`'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`sighash_type = sig_b[-1]`'
- en: '`if tx[‘is_segwit’] == True:`'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`if tx[‘is_segwit’] == True:`'
- en: '`msg_b = createMsgForSigForSegwit(tx, script_b, inp_index, sighash_type)`'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg_b = createMsgForSigForSegwit(tx, script_b, inp_index, sighash_type)`'
- en: '`else:`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`msg_b = createMsgForSig(tx, script_b, inp_index, sighash_type)`'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg_b = createMsgForSig(tx, script_b, inp_index, sighash_type)`'
- en: '`print(‘sig = %s’ % sig_b.hex())`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘sig = %s’ % sig_b.hex())`'
- en: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘pubkey = %s’ % pubkey_b.hex())`'
- en: '`print(‘msg = %s’ % msg_b.hex())`'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘msg = %s’ % msg_b.hex())`'
- en: '`msg_h = hashlib.sha256(msg_b).digest()`'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg_h = hashlib.sha256(msg_b).digest()`'
- en: '`print(‘msg_h = %s’ % msg_h.hex())`'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘msg_h = %s’ % msg_h.hex())`'
- en: '`prefix = pubkey_b[0:1]`'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix = pubkey_b[0:1]`'
- en: '`if prefix == b”\x02” or prefix == b”\x03”:`'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`if prefix == b”\x02” or prefix == b”\x03”:`'
- en: '`fullpubkey_b = uncompressPubkey(pubkey_b)[1:]`'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullpubkey_b = uncompressPubkey(pubkey_b)[1:]`'
- en: '`elif prefix == b”\x04”:`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif prefix == b”\x04”:`'
- en: '`fullpubkey_b = pubkey_b[1:]`'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullpubkey_b = pubkey_b[1:]`'
- en: '`rs_b = getRandSFromSig(sig_b)`'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`rs_b = getRandSFromSig(sig_b)`'
- en: '`print(‘rs = %s’ % rs_b.hex())`'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘rs = %s’ % rs_b.hex())`'
- en: '`vk = ecdsa.VerifyingKey.from_string(fullpubkey_b, curve=ecdsa.SECP256k1)`'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`vk = ecdsa.VerifyingKey.from_string(fullpubkey_b, curve=ecdsa.SECP256k1)`'
- en: '`if vk.verify(rs_b, msg_h, hashlib.sha256) == True:`'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`if vk.verify(rs_b, msg_h, hashlib.sha256) == True:`'
- en: '`print(“Signature is Valid”)`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“签名有效”)`'
- en: '`return b’\x01’`'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '`return b’\x01’`'
- en: '`else:`'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(“Signature is not Valid”)`'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“签名无效”)`'
- en: '`return b’\x00’`'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`return b’\x00’`'
- en: '**Program 12.12:** Verify signature in SegWit transaction'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.12：** 验证隔离见证交易中的签名'
- en: 'For other sighash types, we use the following mathematical expressions:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他 sighash 类型，我们使用以下数学表达式：
- en: '*For sighash type SIGHASH_NONE:*'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于 sighash 类型 SIGHASH_NONE：*'
- en: '*hashPrevouts = Hash256(‖(TxID[prev] TxOutIndex[prev] ))*'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashPrevouts = Hash256(‖(TxID[prev] TxOutIndex[prev] ))*'
- en: '*hashSequence = 32 byte of zeroes*'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashSequence = 32 字节的零*'
- en: '*hashOutputs = 32 byte of zeroes*'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashOutputs = 32 字节的零*'
- en: 'For sighash type SIGHASH_SINGLE:'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 sighash 类型 SIGHASH_SINGLE：
- en: '*hashPrevouts = Hash256(‖(TxID[prev] TxOutIndex[prev] ))*'
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashPrevouts = Hash256(‖(TxID[prev] TxOutIndex[prev] ))*'
- en: '*hashSequence = 32 bytes of zeroes*'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashSequence = 32 字节的零*'
- en: '*hashOutputs = Hash256(output[inputindex] )*'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashOutputs = Hash256(output[inputindex] )*'
- en: 'For sighash type SIGHASH_ALL|SIGHASH_ANYONECANPAY:'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 sighash 类型 SIGHASH_ALL|SIGHASH_ANYONECANPAY：
- en: '*hashPrevouts = 32 bytes of zeroes*'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashPrevouts = 32 字节的零*'
- en: '*hashSequence = 32 bytes of zeroes*'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashSequence = 32 字节的零*'
- en: '*hashOutputs = Hash256(‖(output))*'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashOutputs = Hash256(‖(output))*'
- en: 'For sighash type SIGHASH_NONE|SIGHASH_ANYONECANPAY:'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 sighash 类型 SIGHASH_NONE|SIGHASH_ANYONECANPAY：
- en: '*hashPrevouts = 32 bytes of zeroes*'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashPrevouts = 32 字节的零*'
- en: '*hashSequence = 32 bytes of zeroes*'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashSequence = 32 字节的零*'
- en: '*hashOutputs = 32 bytes of zeroes*'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashOutputs = 32 字节的零*'
- en: 'For sighash_type SIGHASH_SINGLE|SIGHASH_ANYONECANPAY:'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 sighash_type SIGHASH_SINGLE|SIGHASH_ANYONECANPAY：
- en: '*hashPrevouts=32 bytes of zeroes*'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashPrevouts = 32 字节的零*'
- en: '*hashSequence=32 bytes of zeroes*'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashSequence=32 字节的零*'
- en: '*hashOutputs=Hash256(output[inputindex] )*'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*hashOutputs=Hash256(output[inputindex] )*'
- en: As we have learned to create signature preimage for SIGHASH_ALL, we can similarly
    build preimage using the preceding information for other sighash types.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学会为 SIGHASH_ALL 创建签名预图一样，我们可以使用前述信息类似地构建其他 sighash 类型的预图。
- en: '[Address format and generation](toc.xhtml#s269a)'
  id: totrans-718
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[地址格式和生成](toc.xhtml#s269a)'
- en: 'Segregated witnesses introduced a shorter address format based on the bech32
    algorithm. The BIP 173 provides information about the bech32 format used in Bitcoin
    SegWit addressing. Listed here are a few advantages of bech32 over the base58check
    algorithm used in non-SegWit transactions:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证引入了基于 bech32 算法的较短地址格式。BIP 173 提供了有关比特币隔离见证地址中使用的 bech32 格式的信息。以下列出了 bech32
    相对于非隔离见证交易中使用的 base58check 算法的一些优点：
- en: Base58 needs a lot of space in QR codes, as it cannot use the *alphanumeric
    mode*.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base58 在 QR 码中需要大量空间，因为它无法使用*字母数字模式*。
- en: The mixed case in base58 makes it inconvenient to reliably write down, type
    on mobile keyboards, or read out loud.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base58 中的混合大小写使得可靠地书写、在移动键盘上输入或大声阅读变得不方便。
- en: The double SHA256 checksum is slow and has no error-detection guarantees.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重 SHA256 校验和缓慢且没有错误检测保证。
- en: Most of the research on error-detecting codes only applies to character-set
    sizes that are a prime power, which 58 is not.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数关于错误检测码的研究仅适用于字符集大小为质数幂，而 58 不是质数幂。
- en: Base58 decoding is complicated and relatively slow.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base58 解码复杂且相对缓慢。
- en: 'A bech32 string is at most 90 characters long and consists of the following:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: bech32 字符串最多为 90 个字符长，由以下内容组成：
- en: The ***human-readable*** **part** is intended to convey the type of data or
    anything else that is relevant to the reader. This part MUST contain 1-83 US-ASCII
    characters, with each character having a value in the range [33-126]. HRP validity
    may be further restricted by specific applications.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***人类可读*** **部分** 旨在传达数据类型或任何对读者相关的信息。此部分必须包含 1-83 个 US-ASCII 字符，每个字符的值在 [33-126]
    范围内。HRP 的有效性可能会被特定应用进一步限制。'
- en: The ***separator*** is always “1”. In case “1” is allowed inside the human-readable
    part, the last one in the string is the separator.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***分隔符*** 总是“1”。如果“1”允许出现在人类可读部分内部，则字符串中的最后一个是分隔符。'
- en: The ***data part*** is at least 6 characters long and only consists of alphanumeric
    characters, excluding “1”, “b”, “i”, and “o”.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数据部分*** 至少为 6 个字符长，且仅由字母数字字符组成，不包括“1”、“b”、“i”和“o”。'
- en: 'We will use the following Python library for bech32 encoding and decoding:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 Python 库进行 bech32 编码和解码：
- en: '![](images/Figure-12.18.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.18.jpg)'
- en: '**Figure 12.18:** Required PIP package for the new Segwit addresses'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.18：** 新 Segwit 地址所需的 PIP 包'
- en: 'As we have learned, in the case of native SegWit transaction the `**previous
    scriptPubKey**` has the following format:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，在本地 SegWit 交易的情况下，`**previous scriptPubKey**` 的格式如下：
- en: '`<1-byte witness version> <2-40 bytes witness program>`'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`<1 字节见证版本> <2-40 字节见证程序>`'
- en: The current version is 0, for P2WPKH, witness program is 20-byte in size, and
    for P2WSH, witness program is 32-byte in size.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本为 0，对于 P2WPKH，见证程序大小为 20 字节，对于 P2WSH，见证程序大小为 32 字节。
- en: 'The following is the previous scriptPubkey in the native P2WPKH transaction
    example we discussed in the one of the previous sections:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在之前的某个章节中讨论的原生 P2WPKH 交易示例中的前一个 scriptPubkey：
- en: '`Previous scriptPubkey: 0x0014122bf8b77dceee01c0fa1f2b36d155fea2a5b016`'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`前一个 scriptPubkey: 0x0014122bf8b77dceee01c0fa1f2b36d155fea2a5b016`'
- en: '`=> witness version = 0x00`'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`=> 见证版本 = 0x00`'
- en: '`=> witness program size = 0x14 = 20-bytes`'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`=> 见证程序大小 = 0x14 = 20 字节`'
- en: '`=> witness program = 0x122bf8b77dceee01c0fa1f2b36d155fea2a5b016`'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`=> 见证程序 = 0x122bf8b77dceee01c0fa1f2b36d155fea2a5b016`'
- en: 'The following program encodes witness program and prints address:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序对见证程序进行编码并打印地址：
- en: '`import bech32`'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`import bech32`'
- en: '`witprog = bytes.fromhex(‘122bf8b77dceee01c0fa1f2b36d155fea2a5b016’)`'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`witprog = bytes.fromhex(‘122bf8b77dceee01c0fa1f2b36d155fea2a5b016’)`'
- en: '`witver = 0x00`'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '`witver = 0x00`'
- en: '`hrp = ‘bc’`'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '`hrp = ‘bc’`'
- en: '`address = bech32.encode(hrp, witver, witprog)`'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = bech32.encode(hrp, witver, witprog)`'
- en: '`print(address)`'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(address)`'
- en: '**Program 12.13:** Generate bech32 address for Native SegWit address'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.13：** 生成本地 SegWit 地址的 bech32 地址'
- en: 'In the preceding program, `**hrp**` stands for **human-readable-part**. The
    following are the HRP codes corresponding to the network:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，`**hrp**` 代表 **人类可读部分**。以下是与网络对应的 HRP 代码：
- en: '| **HRP codes** | **Network** |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| **HRP 代码** | **网络** |'
- en: '| bc | Mainnet |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| bc | 主网 |'
- en: '| tb | Testnet |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| tb | 测试网 |'
- en: '| tb | Regtest |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '| tb | 回归测试 |'
- en: '**Table 12.1:** HRP codes for Bitcoin networks'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12.1：** 比特币网络的 HRP 代码'
- en: 'On running the program, we get the following address:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，我们得到以下地址：
- en: '![](images/Figure-12.19.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.19.jpg)'
- en: '**Figure 12.19:** Generated bech32 address from the private key'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.19：** 从私钥生成的 bech32 地址'
- en: 'We can check whether the address is correct by looking at the corresponding
    transaction in blockchain using Bitcoin Core client. The following is the output
    index 1 of `**txid 6f7184d3b59adf06290686c6e4f7b7aeb0e7c869f05ca04d10a4b1636277fc40**`:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用比特币核心客户端查看区块链中相应交易来检查地址是否正确。以下是 `**txid 6f7184d3b59adf06290686c6e4f7b7aeb0e7c869f05ca04d10a4b1636277fc40**`
    的输出索引 1：
- en: '![](images/Figure-12.20.jpg)'
  id: totrans-758
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.20.jpg)'
- en: '**Figure 12.20:** Shows the bech32 address in transaction output'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.20：** 显示交易输出中的 bech32 地址'
- en: 'Now, we will do it for native P2WSH. We are using the P2WSH transaction used
    in the example in a previous section, where:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为本地 P2WSH 进行操作。我们使用前面部分中示例中使用的 P2WSH 交易，其中：
- en: '`Previous scriptPubkey = 0020d0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091`'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '`上一个 scriptPubkey = 0020d0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091`'
- en: So,
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，
- en: '`witness version = 0x00`'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`witness version = 0x00`'
- en: '`=> witness program size = 0x20 = 32-bytes`'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '`=> 见证程序大小 = 0x20 = 32 字节`'
- en: '`=> witness program =`'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '`=> 见证程序 =`'
- en: '`0xd0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091`'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`0xd0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091`'
- en: 'Here’s the program to get bech32 address corresponding to P2WSH:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是获取与 P2WSH 对应的 bech32 地址的程序：
- en: '`witprog = bytes.fromhex(‘d0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091’)`'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`witprog = bytes.fromhex(‘d0862d6e40d240ea1711f6d897f5e7b07e974a593704077edffb7b67fd34b091’)`'
- en: '`witver = 0x00`'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '`witver = 0x00`'
- en: '`hrp = ‘bc’`'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`hrp = ‘bc’`'
- en: '`address = bech32.encode(hrp, witver, witprog)`'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '`address = bech32.encode(hrp, witver, witprog)`'
- en: '`print(address)`'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(address)`'
- en: 'This gives us the following address:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们以下地址：
- en: '![](images/Figure-12.21.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.21.jpg)'
- en: '**Figure 12.21:** Generated bech32 address from the private key'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.21：** 从私钥生成的 bech32 地址'
- en: In the preceding program, we are looking at previous `**txid**` at index 0 of
    `**txid**`*:*
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述程序中，我们查看了前一个 `**txid**` 在 `**txid**` 的索引 0 处的部分*:* '
- en: '`dffe1dc8f36cbc39c0f40b090912c5a00da13e3534f97aec0ef5bfe552019897`'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`dffe1dc8f36cbc39c0f40b090912c5a00da13e3534f97aec0ef5bfe552019897`'
- en: 'By looking at `**outindex**` of the previous `**txid**` using Bitcoin Core
    client, we get the following previous scriptPubkey and the corresponding address:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用比特币核心客户端查看前一个 `**txid**` 的 `**outindex**`，我们得到了以下前一个 scriptPubkey 和相应的地址：
- en: '![](images/Figure-12.22.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.22.jpg)'
- en: '**Figure 12.22:** Shows the bech32 address in transaction output'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.22：** 展示了交易输出中的 bech32 地址'
- en: 'The following is the code to decrypt bech32 addresses:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解密 bech32 地址的代码：
- en: '`witver, witprog_l = bech32.decode(address[:2], address)`'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '`witver, witprog_l = bech32.decode(address[:2], address)`'
- en: '`witprog_b = bytes(witprog_l)`'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`witprog_b = bytes(witprog_l)`'
- en: '`scriptpubkey_b = bytes([witver]) + bytes([len(witprog_b)]) + witprog_b`'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptpubkey_b = bytes([witver]) + bytes([len(witprog_b)]) + witprog_b`'
- en: '`print(‘scriptpubkey = ‘, scriptpubkey_b.hex())`'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘scriptpubkey = ‘, scriptpubkey_b.hex())`'
- en: '**Program 12.14:** Decode bech32 address to getscriptpubkey'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 12.14：** 解码 bech32 地址以获取 scriptpubkey'
- en: 'Using it to decode bech32 address for the P2WPKH in the following execution:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的执行中使用它来解码 P2WPKH 的 bech32 地址：
- en: '![](images/Figure-12.23.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.23.jpg)'
- en: '**Figure 12.23:** Decoded bech32 address to get scriptpubkey'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.23：** 解码 bech32 地址以获取 scriptpubkey'
- en: 'And using it to decode the bech32 address for the P2WSH in the following execution:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 并在下面的执行中使用它来解码 P2WSH 的 bech32 地址：
- en: '![](images/Figure-12.24.jpg)'
  id: totrans-791
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-12.24.jpg)'
- en: '**Figure 12.24:** Decoded bech32 address to get scriptpubkey'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 12.24：** 解码 bech32 地址以获取 scriptpubkey'
- en: This brings us to the end of this chapter, wherein we have likely covered all
    the aspects of segregated witness enhancements.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的结束，我们很可能已经涵盖了隔离见证增强的所有方面。
- en: '[Conclusion](toc.xhtml#s270a)'
  id: totrans-794
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](toc.xhtml#s270a)'
- en: In this chapter, you learned about segregated witness enhancement. You learned
    why it was important and the impact it has on overall Bitcoin. Additionally, you
    learned about the several changes that happened along with this enhancement, like
    we changed the way we see network enhancements. The chapter covered the new address
    encoding algorithms and taught you to encode and decode addresses. You learned
    to verify the new standard transaction scripts introduced by SegWit, learned the
    structure of transactions, and verify them along with signatures.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了隔离见证增强。您了解了为什么它很重要以及它对整体比特币的影响。此外，您还了解了与此增强同时发生的几个变化，比如我们改变了我们看待网络增强的方式。本章涵盖了新的地址编码算法，并教会了您如何对地址进行编码和解码。您学会了验证
    SegWit 引入的新标准交易脚本，了解了交易的结构，并验证了它们以及签名。
- en: In the next chapter, we will cover the Lightning Network, which is both a part
    of Bitcoin and still a separate development. It’s a layer-two protocol that can
    provide Bitcoin speed, which Bitcoin lacks by design. It is an important development
    in scalability.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖闪电网络，它既是比特币的一部分，又是一个独立的发展。它是一个第二层协议，可以提供比特币设计上所缺乏的速度。这是一个在可扩展性方面的重要发展。
- en: '[Points to remember](toc.xhtml#s271a)'
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[记住的要点](toc.xhtml#s271a)'
- en: Bitcoin originally had multiple transaction malleability bugs.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币最初存在多个交易可篡改漏洞。
- en: BIP62 was the original workaround for the transaction malleability issue, which
    was cumbersome to implement.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BIP62 是用于事务可篡改问题的原始解决方案，但实施起来很麻烦。
- en: Transaction malleability made unconfirmed transactions unreliable even for the
    signer of the transaction.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务篡改使得未确认的交易对于交易签署者而言不可靠。
- en: Segregated witness solved all transaction malleability issues by moving signature
    out of the transaction ID calculation. The section that is not part of the transaction
    ID calculation is called witness data.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离见证通过将签名移出事务 ID 计算解决了所有事务可篡改问题。不计入事务 ID 计算的部分称为见证数据。
- en: Segregated witness was implemented as a softfork.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离见证被实施为软分叉。
- en: SegWit activation followed BIP 9.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit 激活遵循 BIP 9。
- en: BIP 148 was created to enforce SegWit deployment if the hash power majority
    does not activate segregated witness related BIPs, which were BIP 141, BIP 143,
    and BIP 147\. This was the first time **User Activated Soft Fork** (**UASF**)
    was used to enforce feature activation.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BIP 148 的创建是为了在哈希功率多数派未激活与隔离见证相关的 BIP（BIP 141、BIP 143 和 BIP 147）时强制执行 SegWit
    部署。这是**用户激活软分叉**（**UASF**）首次用于强制执行功能激活。
- en: UASF is an activation rule enforced by the economic majority instead of the
    hash power majority.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UASF 是由经济多数派而不是哈希功率多数派强制执行的激活规则。
- en: Segregated witness Merkle oot is calculated by taking the hash of the whole
    transaction of all the transactions in the block, prepending the hash with 32-byte
    zeros and calculating Merkle root.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离见证 Merkle 根是通过对块中所有交易的整个交易进行哈希计算，将哈希前置为 32 字节的零，然后计算 Merkle 根来计算的。
- en: Hash of calculated segregated witness –Merkle oot concatenated with witness-reserve-value
    (provided by a miner in the first input of coinbase transaction) determines commitment-hash,
    which is in one of the outputs of coinbase transaction.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算的隔离见证哈希 - Merkle 根与见证保留值的哈希（由矿工在 coinbase 交易的第一个输入中提供）连接起来形成承诺哈希，这个哈希位于 coinbase
    交易的一个输出中。
- en: SegWit allowed blocks to be larger than 1 MB as the bytes within witness data
    are considered one-fourth of their size. So, Bitcoin software changes the way
    it counts bytes. In this counting, size remains within 1 MB even though it may
    actually be bigger than 1 MB.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit 允许块的大小大于 1 MB，因为见证数据中的字节被认为是其大小的四分之一。因此，比特币软件更改了计算字节的方式。在此计数中，尽管实际可能大于
    1 MB，但大小仍保持在 1 MB 以内。
- en: Using segregated witness for creating transactions reduces the amount of required
    network fees.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用隔离见证创建交易可减少所需的网络费用量。
- en: 'SegWit introduced four new standard scripts: P2WPKH, P2WSH, P2SH-P2WPKH, and
    P2SH-P2WSH.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit 引入了四种新的标准脚本：P2WPKH、P2WSH、P2SH-P2WPKH 和 P2SH-P2WSH。
- en: Native SegWit script hash and public key hash are encoded using bech32.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 SegWit 脚本哈希和公钥哈希使用 bech32 进行编码。
- en: SegWit address has a scalable scheme, contains version, and the current version
    is 0.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit 地址具有可扩展的方案，包含版本，当前版本为 0。
- en: SegWit transaction signature is generated using a message format different from
    non-SegWit transactions. This message format is defined in BIP143.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SegWit 交易签名是使用与非 SegWit 交易不同的消息格式生成的。该消息格式在 BIP143 中定义。
- en: '[Questions](toc.xhtml#s272a)'
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[问题](toc.xhtml#s272a)'
- en: Calculate the approximate vsize of P2PKH, P2SH-P2WPKH, and P2WPKH transactions
    with 1 input and 1 output. Compare them and determine percentage saving by using
    SegWit transactions.
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算具有 1 个输入和 1 个输出的 P2PKH、P2SH-P2WPKH 和 P2WPKH 交易的近似 vsize。比较它们，并确定使用 SegWit
    交易可节省的百分比。
- en: Calculate approximate vsize of 2-2 multisig P2SH, P2SH-P2WSH, and P2WSH transactions
    with 1 input and 1 output. Compare them and determine percentage saving by using
    SegWit transactions.
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算具有 1 个输入和 1 个输出的 2-2 多重签名 P2SH、P2SH-P2WSH 和 P2WSH 交易的近似 vsize。比较它们，并确定使用 SegWit
    交易可节省的百分比。
- en: 'Write programs to create transactions:'
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序以创建交易：
- en: Write a program to create a P2WPKH transaction.
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序以创建 P2WPKH 交易。
- en: Write a program to create a P2WSH transaction.
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序以创建 P2WSH 交易。
- en: Write a program to create a P2SH-P2WPKH transaction.
  id: totrans-820
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序以创建 P2SH-P2WPKH 交易。
- en: Write a program to create P2SH-P2WSH transactions.
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序以创建 P2SH-P2WSH 交易。
- en: 'Fill in the blanks:'
  id: totrans-822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填空：
- en: BIP ______ contains details of UASF for enforcing SegWit related BIPs.
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BIP ______ 包含有关强制执行与 SegWit 相关的 BIP 的 UASF 的详细信息。
- en: Before SegWit BIP _______ provided a workaround for the transaction malleability
    bug.
  id: totrans-824
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SegWit 之前，BIP _______ 提供了交易篡改漏洞的解决方法。
- en: Transaction malleability bugs originate as for a transaction, _____________
    can be different but still valid.
  id: totrans-825
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易篡改漏洞的根源在于对于一个交易，_________ 可以不同但仍然有效。
- en: 'True/False:'
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：
- en: After SegWit softfork was activated, a non SegWit transaction became invalid
    and was rejected by the network.
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SegWit 软分叉激活之后，非 SegWit 交易变得无效，并被网络拒绝。
- en: BIP 148 replaced BIP 9 activation on the Bitcoin network.
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: BIP 148 取代了比特币网络上的 BIP 9 激活。
- en: Bech32 encoding generates alphanumeric characters meaning either capital or
    small alphabets and/or numbers.
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bech32 编码生成的是包含大写或小写字母和/或数字的字母数字字符。
