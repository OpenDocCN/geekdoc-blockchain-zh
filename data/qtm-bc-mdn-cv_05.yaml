- en: '© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022A.
    Kumar et al. (eds.)Quantum and Blockchain for Modern Computing Systems: Vision
    and AdvancementsLecture Notes on Data Engineering and Communications Technologies133[https://doi.org/10.1007/978-3-031-04613-1_5](https://doi.org/10.1007/978-3-031-04613-1_5)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（作者）独家许可给施普林格自然瑞士AG 2022A. Kumar等人（编）量子与区块链用于现代计算系统：愿景与进展数据工程与通信技术讲义133[https://doi.org/10.1007/978-3-031-04613-1_5](https://doi.org/10.1007/978-3-031-04613-1_5)
- en: A Conceptual Framework for Scaling and Security in Serverless Environments Using
    Blockchain and Quantum Key Distribution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种利用区块链和量子密钥分发在无服务器环境中扩展和提高安全性的概念框架
- en: 'P. R. Mahalingam^([1](#Aff5) [ ](#ContactOfAuthor1))(1)Muthoot Institute of
    Technology and Science, Kochi, Kerala, IndiaP. R. MahalingamEmail: [prmahalingam@gmail.com](mailto:prmahalingam@gmail.com)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: P. R. Mahalingam^([1](#Aff5) [ ](#ContactOfAuthor1))(1)印度喀拉拉邦科钦库奇的Muthoot技术与科学学院P.
    R. Mahalingam电子邮件：[prmahalingam@gmail.com](mailto:prmahalingam@gmail.com)
- en: Abstract
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Serverless computing is one of the most preferred deployment strategies in today’s
    world. It refers to a concept where execution environment is not predefined during
    deployment, but scaled based on demand. The concept has gained importance with
    improvements in cloud computing, which banks on this concept. Nowadays, cloud
    service providers are able to expose this concept as a cloud service itself, with
    application like GCP Cloud Functions and AWS Lambda. But as services go online,
    securing them becomes a challenge. Serverless computing was originally envisaged
    as a stateless environment, but now it has evolved to semi-stateful entities,
    making them prone to state analysis and hijacking. With current cryptosystems
    being outmatched at a fast pace, and quantum computing expected to break almost
    all cryptographic algorithms in the coming decade, it is imperative that serverless
    communications be encrypted in a much more secure fashion. A concept based on
    quantum key distribution and blockchain is proposed to improve application scaling
    and security. Blockchain platforms like Ethereum work based on smart contracts,
    which can execute pieces of code on the nodes and place results on the blockchain
    after consensus. The same can be adapted to serverless computing because smart
    contract codebase is deployed on the node itself, and is triggered by user requests.
    The user-defined function can then be deployed as a smart contract. When demand
    is huge, more nodes can be spun up, which contain the codebase for the smart contract,
    and they can initiate execution. In order to enhance security, the communication
    between endpoints can be protected by using Quantum Key Distribution, and even
    among the nodes, selections can be done using principles behind QKD. After execution
    is complete, the result is placed on the blockchain itself, which acts as a log
    of execution, as well as carry the result.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是当今世界上最受欢迎的部署策略之一。它指的是在部署过程中不预先定义执行环境，而是根据需求进行扩展的概念。随着云计算的改进，这一概念变得越来越重要，云计算依赖于这一概念。如今，云服务提供商能够将这一概念作为云服务本身提供，例如
    GCP 云函数和 AWS Lambda。但随着服务上线，确保其安全性变得具有挑战性。无服务器计算最初被构想为一种无状态环境，但现在已经发展成半状态实体，使它们容易受到状态分析和劫持的影响。由于当前的加密系统以快速的速度被超越，并且量子计算预计在未来十年内破解几乎所有的加密算法，因此有必要以更加安全的方式对无服务器通信进行加密。提出了一种基于量子密钥分发和区块链的概念，以改善应用程序的扩展性和安全性。像以太坊这样的区块链平台是基于智能合约运行的，智能合约可以在节点上执行代码片段，并在共识之后将结果放置在区块链上。同样，可以将这一概念应用到无服务器计算中，因为智能合约代码库部署在节点本身上，并且由用户请求触发。用户定义的函数然后可以部署为智能合约。当需求量巨大时，可以启动更多的节点，这些节点包含智能合约的代码库，并且它们可以启动执行。为了增强安全性，端点之间的通信可以通过使用量子密钥分发来保护，甚至在节点之间，可以使用量子密钥分发背后的原理进行选择。执行完成后，结果被放置在区块链上，区块链本身充当执行日志，并携带结果。
- en: 1 Introduction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 引言
- en: Serverless computing is a concept that has gained importance over the last decade,
    with the rise in popularity of cloud computing. As per popular cloud service providers
    like AWS and Azure, *serverless computing* allows the user to build applications
    that can be run over the internet, without worrying about underlying infrastructure.
    The term *serverless* doesn’t refer to the absence of servers entirely. It simply
    refers to the transparent nature of the whole ecosystem so that the user doesn’t
    feel there is a server in between them and the execution environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是在过去十年中变得重要的概念，随着云计算的日益普及。根据像AWS和Azure这样的流行云服务提供商，*无服务器计算*允许用户构建可以在互联网上运行的应用程序，而无需担心基础架构。术语*无服务器*并不完全指没有服务器的存在，而是指整个生态系统的透明性，使用户感觉不到有服务器存在于他们和执行环境之间。
- en: The transparency offered by cloud providers is achieved by a complex framework
    of *autoscaling* programs that constantly monitor the demand on servers and automatically
    start/stop new instances of the server. The transparency also removes many aspects
    of security from the user’s control. While these are advantageous from a deployment
    point of view, it does pose a risk when the user is not aware of what is happening
    in the background. It provides developers with a simplified programming model
    for rapid application development and deployment, abstracting away underlying
    complexities, cheaper deployment (since cloud providers support as pay-as-you-go
    model), better code templates, and coordination. But at the same time, there is
    little control over platform design decisions that control QoS, scaling, and fault
    tolerance  [[1](#CR1)–[3](#CR3)].
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商提供的透明性是通过一套复杂的*自动扩展*程序框架实现的，该框架不断监控服务器的需求，并自动启动/停止新的服务器实例。透明性还使用户对安全的许多方面失去控制。虽然这对部署来说是有利的，但当用户不了解后台发生了什么时，就会存在风险。它为开发人员提供了简化的快速应用程序开发和部署的编程模型，摒弃了底层复杂性，部署更为经济（因为云提供商支持按需付费模式），提供更好的代码模板和协调。但同时，对控制QoS、扩展性和容错性的平台设计决策的控制很少[[1](#CR1)–[3](#CR3)]。
- en: This chapter provides an insight towards how technologies like blockchain and
    quantum computing can help in ensuring scalability and security of serverless
    computing platforms. Section [2](#Sec2) discusses the architecture of serverless
    computing and how it evolved from basic client-server models. Section [3](#Sec5)
    gives an insight into the concept behind blockchain, how it is popularly deployed,
    and aspects like smart contracts that can come in handy when integrating with
    serverless computing. Section [4](#Sec8) gives an overview of quantum physics
    and their role in developing a new programming and execution paradigm. Section
    [5](#Sec10) discusses about different opportunities to include blockchain in serverless
    platforms, while Sect. [6](#Sec11) talks about security loopholes and management.
    The discussion is consolidated in Sect. [7](#Sec14), where a model is proposed
    to combine all advantages discussed till then, and how it can be architected.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了区块链和量子计算等技术如何帮助确保无服务器计算平台的可扩展性和安全性。[第2节](#Sec2)讨论了无服务器计算的架构以及它是如何从基本的客户端-服务器模型演变而来的。[第3节](#Sec5)深入探讨了区块链背后的概念，它如何被广泛部署，以及在与无服务器计算集成时可以派上用场的智能合约等方面。[第4节](#Sec8)概述了量子物理学及其在开发新的编程和执行范式中的作用。[第5节](#Sec10)讨论了在无服务器平台中包含区块链的不同机会，而第6节（#Sec11）则谈论了安全漏洞和管理。这些讨论在[第7节](#Sec14)中得到了总结，提出了一个模型，将到目前为止讨论的所有优点结合起来，并探讨了如何构建这个模型。
- en: 2 Serverless Computing
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 无服务器计算
- en: Cloud computing has gained a lot of importance and popularity over the last
    few years, especially since applications began to get migrated to microservice
    architectures  [[1](#CR1)]. Conventional software packages were highly cohesive,
    with all capabilities embedded into their own modules inside the same package.
    But with microservice architecture, developers were able to migrate each module
    individually into their own packages, and deploy them independently. This was
    supported by advances in client-server computing, which enabled services to offload
    their computing to the server, and client limited to providing basic processing,
    and rendering inputs and results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算在过去几年中获得了很大的重要性和流行度，特别是自从应用程序开始迁移到微服务架构[[1](#CR1)]以来。传统的软件包具有高内聚性，所有功能都嵌入到同一个软件包的各个模块中。但是，通过微服务架构，开发人员能够将每个模块单独迁移到自己的软件包中，并独立部署它们。这得到了客户端-服务器计算的进展的支持，它使得服务能够将它们的计算负载转移到服务器上，而客户端仅限于提供基本处理和呈现输入和结果。
- en: When we consider the philosophy of cloud computing, there are three levels of
    deployment which are popularly considered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑云计算的哲学时，通常有三个部署级别被广泛考虑。
- en: IaaS
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: IaaS
- en: Infrastructure-as-a-Service (IaaS) is the deployment strategy where *bare-bones*
    infrastructure is provided, which contains only the storage, compute, and networking
    infrastructure. All installations, software configurations, and management is
    required to be done by the user. Only physical security and infrastructure maintenance
    falls under the responsibility of the service provider.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即服务（IaaS）是部署策略，其中提供了*裸骨*基础设施，仅包含存储、计算和网络基础设施。所有的安装、软件配置和管理都需要用户来完成。只有物理安全和基础设施维护属于服务提供商的责任范围。
- en: PaaS
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS
- en: Platform-as-a-Service adds the software layer on top of IaaS. Basic software
    is provided either off the shelf, or as a readily installable package. Developers
    may use the provided resources to build their applications. In this case, physical
    security and infrastructure management is still managed by the service provider,
    but updating and securing the software from the user side is still under the responsibility
    of developers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 平台即服务在IaaS之上添加了软件层。基本软件可以提供现成的，也可以作为一个易于安装的包提供。开发人员可以利用提供的资源构建他们的应用程序。在这种情况下，物理安全和基础设施管理仍由服务提供商管理，但是从用户方面更新和保护软件仍由开发人员负责。
- en: SaaS
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SaaS
- en: Software-as-a-Service refers to the cloud application services, which are fully
    hosted and managed by service providers. An example of the same is Gmail, which
    is fully managed by Google. Here, everything except the end user security is managed
    by the service provider.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件即服务是指由服务提供商完全托管和管理的云应用服务。一个例子就是由谷歌完全管理的Gmail。在这里，除了最终用户安全性之外，一切都由服务提供商管理。
- en: Serverless computing can be thought of as a platform that is a mix of these.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算可以被看作是一个融合了这些特点的平台。
- en: 2.1 Going Serverless
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 走向无服务器
- en: Before serverless and cloud computing became popular, the domain was controlled
    by *distributed computing*. In this paradigm, the required processing and storage
    capability is distributed among a set of participating nodes, each housing a fully
    autonomous unit. When data is to be stored, it is migrated to two or more nodes
    (which is called *replication*) to ensure availability in case of failures. Processes
    are also replicated appropriately and done close to the location of their data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器计算和云计算变得流行之前，该领域由*分布式计算*控制。在这种范式中，所需的处理和存储能力分布在一组参与节点中，每个节点都包含一个完全自治的单元。当数据需要存储时，它会迁移到两个或更多节点上（这被称为*复制*），以确保在故障发生时可用性。进程也会适当地复制并且在其数据所在地附近执行。
- en: Serverless computing is an execution model based on cloud computing in which
    the cloud service provider automatically allocates, manages, scales, and deallocates
    compute services based on demand. In short, server management is transferred from
    the developer to cloud service provider. This is extremely useful in scenarios
    where execution is in the form of short bursts, rather than consistent loads.
    Data input and output is managed from persistent storage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是基于云计算的执行模型，在这种模型中，云服务提供商根据需求自动分配、管理、扩展和收回计算服务。简而言之，服务器管理由开发人员转移到云服务提供商。这在执行短时间脉冲而非持续负载的场景中非常有用。数据输入和输出由持久性存储管理。
- en: From a cloud provider point of view, serverless computing provides an opportunity
    to control the development stack, efficient optimization and management of cloud
    resources (making the entire process cheaper), encourage usage of native applications,
    and attract audience by lowering the effort needed to create applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从云提供商的角度来看，无服务器计算为控制开发堆栈，高效优化和管理云资源（使整个过程更加便宜），鼓励使用原生应用程序，并通过降低创建应用程序所需的工作量来吸引受众提供了机会。
- en: The concept shows strong similarity to that of SaaS, since both share the philosophy
    of automatic management and provisioning. But the major difference between both
    of them lies in the workload that gets executed. While SaaS is tuned for persistent
    and consistent workloads that need to be available round the clock, serverless
    is useful for intense workloads that last for a short duration. This is popularly
    implemented using a concept called **Function-as-a-Service (FaaS)**, which is
    in fact, a subset of the serverless paradigm. All major cloud service providers
    (CSPs) have their own offering for serverless platforms. The list of popular services
    are given in Table [1](#Tab1), and an extensive evaluation of production grade
    platforms is available in [[4](#CR4), [5](#CR5)]. Open source implementations
    like Kubeless, OpenWhisk, Fission, and OpenFaaS are also available for serverless
    platforms [[6](#CR6)].Table 1
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与SaaS的概念非常相似，因为两者都共享自动管理和提供的理念。但它们之间的主要区别在于执行的工作负载。虽然SaaS适用于需要全天候可用的持续和一致的工作负载，但无服务器适用于持续时间短暂的密集工作负载。这通常是使用称为**函数即服务（FaaS）**的概念实现的，实际上，这是无服务器范例的子集。所有主要的云服务提供商都有他们自己的无服务器平台。热门服务列表见表[1](#Tab1)，生产级平台的详细评估可在[[4](#CR4),[5](#CR5)]中找到。Kubeless、OpenWhisk、Fission和OpenFaaS等开源实现也可用于无服务器平台[[6](#CR6)]。Table
    1
- en: Serverless provisions of popular CSPs
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 热门云服务供应商的无服务器提供
- en: '| Service | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| AWS Lambda | The service was named after lambda calculus, which popularized
    functional execution. Lambda uses micro-VMs using Kernel-based Virtual Machines
    for rapid provisioning and low overhead. Code can be directly deployed using the
    raw source code, or as a built-up version using containers. The platform supports
    Node.js, Python, Go, Java, etc. The concept of serverless was made popular with
    the announcement of Lambda [[1](#CR1)] |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| AWS Lambda | 该服务的命名灵感来自于lambda演算，lambda演算推广了函数执行。Lambda 使用基于内核的虚拟机进行快速配置和低开销的微型
    VM。代码可以直接使用原始源代码部署，也可以使用容器的构建版本部署。该平台支持 Node.js、Python、Go、Java 等。随着 Lambda 的宣布，无服务器的概念变得流行
    [[1](#CR1)] |'
- en: '| Azure Functions | A managed service provided by Azure, that can be used to
    build web APIs (with inbuilt support for HTTP web hooks), respond to database
    changes, process IoT streams, manage message queues, etc. with deployment support
    for external pipelines also. Stateful behavior is also supported using *Azure
    Durable Functions* with the help of orchestrator functions and entity functions
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Azure Functions | Azure 提供的托管服务，可用于构建 Web API（内置对 HTTP Web 钩子的支持）、响应数据库更改、处理
    IoT 流、管理消息队列等，还支持外部管道的部署。还可以使用 *Azure Durable Functions* 来支持有状态行为，借助编排器函数和实体函数
    |'
- en: '| Google Cloud Run | Enables development and deployment of containerized apps.
    It supports languages like Java, Go, Python, Ruby, and Node.js |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Google Cloud Run | 可以开发和部署容器化应用程序。支持 Java、Go、Python、Ruby 和 Node.js 等语言 |'
- en: '| Google App Engine | Fully managed platform and developer environment with
    completely elastic compute and storage management |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Google App Engine | 完全托管的平台和开发者环境，具有完全弹性的计算和存储管理 |'
- en: '| Google Cloud Functions | The pay-as-you-go FaaS implementation provided by
    GCP, with support for hybrid cloud and multi-cloud scenarios |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Google Cloud Functions | GCP 提供的按使用量付费的 FaaS 实现，支持混合云和多云场景 |'
- en: '| IBM Cloud Code Engine | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| IBM Cloud Code Engine | 描述 |'
- en: '| Red Hat OpenShift Serverless | It is based on the open source KNative project.
    The project extensively uses Kubernetes controllers and definitions to execute
    serverless tasks. The focus is placed on (i) building containers, (ii) handling
    events to trigger containers, and (iii) rapid deployment and automatic scaling
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Red Hat OpenShift Serverless | 基于开源的 KNative 项目。该项目广泛使用 Kubernetes 控制器和定义来执行无服务器任务。重点放在
    (i) 构建容器、(ii) 处理触发容器的事件，以及 (iii) 快速部署和自动扩展上 |'
- en: A general architecture of serverless platforms is given in Fig. [1](#Fig1).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig1_HTML.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端无架构的通用架构如图 [1](#Fig1) 所示。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig1_HTML.png)
- en: Fig. 1
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: General architecture of serverless computing [[1](#CR1)]
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端无计算的通用架构 [[1](#CR1)]
- en: The advantages of serverless computing are as follows [[7](#CR7), [8](#CR8)].
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算的优势如下 [[7](#CR7), [8](#CR8)]。
- en: '**Lower costs**—Most CSPs run serverless under a pay-as-you-go model [[9](#CR9)].
    It has to be noted that serverless can scale to even zero instances, thereby costing
    nothing at all [[1](#CR1)]. Splitting the task into microservices running in parallel
    is highly cost effective for tasks that can be parallelized.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更低的成本** — 大多数CSP都在按使用量付费的模式下运行无服务器[[9](#CR9)]。必须注意的是，无服务器可以扩展到零实例，因此根本不需要任何费用[[1](#CR1)]。将任务拆分为并行运行的微服务对于可以并行化的任务非常经济高效。'
- en: '**Simplified scalability**—Since autoscaling is given as part of the platform,
    scaling policies can be avoided.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的可伸缩性** — 由于自动缩放是作为平台的一部分提供的，因此可以避免扩展策略。'
- en: '**Simplified backend code**—Modularity can be maximized since each function
    is supposed to do a fixed, minimum task. Serverless functions typically execute
    a single main function that takes data (mostly in JSON format) as input, and produces
    a similar format as output [[1](#CR1)]. It also enables developers to focus on
    code (in a language of their choice), not infrastructure. CSPs prefer serverless
    code to be triggered as API calls. If any complex operation is needed, it is preferred
    to use cascaded calls [[10](#CR10)].'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的后端代码** — 可以最大化模块化，因为每个函数都应该执行一个固定的、最小的任务。无服务器函数通常执行一个接受数据（主要是JSON格式）作为输入的主函数，并生成类似格式的输出[[1](#CR1)]。这还使开发人员能够专注于代码（使用他们选择的语言），而不是基础设施。CSP更喜欢无服务器代码以API调用的形式触发。如果需要进行任何复杂的操作，则更倾向于使用级联调用[[10](#CR10)]。'
- en: '**Quicker turnaround**—Deployment is nearly instantaneous. If the code can
    be packaged to a container [[11](#CR11)], it can be repeatably deployed with minimal
    delay.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的响应** — 部署几乎是瞬间完成的。如果代码可以打包成容器[[11](#CR11)]，那么它可以在最短的延迟内重复部署。'
- en: But serverless comes with some tradeoffs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是无服务器也带来了一些权衡。
- en: Serverless doesn’t offer savings for workloads characterized by predictable,
    steady or long-running processes. Conventionally, serverless code executes for
    a maximum of 15 min, before they are swapped out for another allocation.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有可预测、稳定或长时间运行进程特征的工作负载，无服务器不提供节省。传统上，无服务器代码最多执行15分钟，然后被其他分配所替换。
- en: Serverless applications sometimes need to start up from scratch to serve a new
    request. It may be a concern for low latency applications.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器应用有时需要从头开始启动以服务新请求。对于低延迟应用可能是一个问题。
- en: Managing and monitoring the environment may be challenging if there are a lot
    of functions. On evaluation by [[12](#CR12)], it was found that serverless architectures
    tend to overprovision resources to manage initialization overhead when the process
    has to be started from scratch.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在大量函数，则管理和监视环境可能会具有挑战性。根据[[12](#CR12)]的评估，发现无服务器架构在必须从头开始启动进程时，倾向于过度配置资源以管理初始化开销。
- en: Vendor lock-in may be required if the code uses vendor-specific libraries.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码使用供应商特定的库，可能需要供应商锁定。
- en: Serverless deployments are stateless by definition. Hence subsequent invocations
    may get routed to different VMs, making any persistent storage difficult. Any
    such storage will result in I/O bottlenecks, eliminating the performance advantage
    given by FaaS [[13](#CR13)].
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器部署在定义上是无状态的。因此，后续调用可能会被路由到不同的虚拟机，使任何持久性存储变得困难。任何此类存储都将导致I/O瓶颈，消除了FaaS提供的性能优势[[13](#CR13)]。
- en: No specialized hardware is available to support serverless computing [[13](#CR13)].
    As cloud processes are ephemeral, each invocation may run on hardware at different
    location, making cost unpredictable [[14](#CR14)].
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有专门的硬件支持无服务器计算[[13](#CR13)]。由于云处理是短暂的，每次调用可能在不同位置的硬件上运行，使成本不可预测[[14](#CR14)]。
- en: Hardware heterogeneity will have to be taken into consideration when designing
    functions. If the program is tightly tuned with a particular architecture in mind,
    it may fail or perform below par when provisioned on any other architecture [[14](#CR14)].
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计函数时必须考虑硬件异构性。如果程序是针对特定架构进行精密调整的，则在任何其他架构上进行配置时可能会失败或性能不佳[[14](#CR14)]。
- en: 'The technology stack for implementing serverless architectures will need to
    take into consideration a number of components. Serverless refers to FaaS and
    other associated cloud services and resources for which configuration, management
    and billing of services are invisible to the user. The major components that will
    be need designing are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现无服务器架构的技术栈将需要考虑多个组件。无服务器指的是对用户不可见的FaaS和其他关联云服务和资源的配置、管理和计费。需要设计的主要组件包括：
- en: '**Functions as a Service (FaaS):** It represents the core compute (processing)
    engine in serverless. It is conventionally developed using languages like Java,
    Python, Go, etc. and deployed either as program itself, or as a container. Another
    option is to use WebAssembly [[15](#CR15)], which has its limitations in capability
    since the native code should be in C or C++, but is extremely efficient during
    execution.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数即服务（FaaS）：** 它代表无服务器中的核心计算（处理）引擎。它通常使用诸如Java、Python、Go等语言开发，并部署为程序本身，或作为容器。另一个选择是使用WebAssembly[[15](#CR15)]，它在执行期间非常高效，但在功能上有其限制，因为原生代码应该是C或C++。'
- en: '**Serverless databases and storage:** It involves transitioning away from provisioning
    SQL and NoSQL instances that scale linearly with demand in both infrastructure
    and pricing.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器数据库和存储：** 这涉及远离按需与基础架构和定价成比例扩展的SQL和NoSQL实例的部署。'
- en: '**Event streaming and messaging:** Event-driven and stream-processing workloads
    (like Apache Kafka) need to be supported.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件流和消息传递：** 需要支持基于事件驱动和流处理的工作负载（如Apache Kafka）。'
- en: '**API gateways:** Invocation is best done via gateways, which can be configured
    for security and load balancing as needed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关：** 最好通过网关进行调用，可以根据需要配置安全性和负载平衡。'
- en: 2.2 Shared Responsibility Model
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 共享责任模型
- en: One of the operational principles in cloud security is that of shared responsibility
    model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 云安全中的操作原则之一是共享责任模型。
- en: Shared Responsibility model states that cloud service providers ensure security
    of the cloud, whereas security in the cloud is the responsibility of the developer
    and user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 共享责任模型规定，云服务提供商确保云的安全，而云中的安全是开发人员和用户的责任。
- en: This means that CSPs ensure physical security of cloud infrastructure from any
    tampering, and provide enough replication to keep the availability of stored data.
    But the provider won’t be responsible for any data loss or data leak due to improper
    security practices in applications developed on that (except SaaS, where CSPs
    are responsible for the service also). Shared responsibility also states that
    users are solely responsible for the security of their login credentials. Even
    though many providers now give additional facilities like Multi Factor Authentication,
    it is up to the user to safeguard their credentials.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着云服务提供商（CSPs）确保云基础设施的物理安全不受任何篡改，并提供足够的复制以保持存储数据的可用性。但是，提供商不会对由于应用程序中的不当安全实践而导致的任何数据丢失或数据泄漏负责（除了SaaS，其中CSPs还负责服务）。共享责任还规定，用户完全负责保护其登录凭据的安全性。尽管现在许多提供商提供了额外的设施，如多因素身份验证，但用户必须保护其凭据。
- en: This brings us to the requirement of secure communication between client and
    server in serverless applications also. If the communication is not properly secured,
    it will be open to any eavesdropper or malicious entity, thereby leading to unexpected
    data loss and disclosure. More discussion on security in serverless domain is
    done in Sect. [6](#Sec11).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了在无服务器应用程序中客户端和服务器之间进行安全通信的要求。如果通信没有得到适当的保护，将对任何窃听者或恶意实体敞开，从而导致意外数据丢失和泄露。对无服务器领域中安全性的更多讨论在第
    [6](#Sec11) 节中进行。
- en: 3 Blockchain
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链
- en: Blockchain is a distributed ledger framework that is popularly known as the
    foundation of Bitcoin. It is made up of a series of transactions stored on *blocks*,
    with blocks connected to each other using a *chain* of links. Any transaction
    that is committed and gets logged into the chain must be agreed upon by majority
    of participants in the distributed system through a method called *consensus*
    [[16](#CR16), [17](#CR17)].
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一种分布式分类账框架，通常被称为比特币的基础。它由存储在 *块* 上的一系列交易组成，这些块通过 *链* 的链接相互提交并记录到链中的交易都必须由分布式系统中大多数参与者通过一种称为*共识*的方法达成一致意见[[16](#CR16),
    [17](#CR17)]。
- en: Links are created using hash values, with each block storing the hash value
    of the previous block also. This makes the chain tamper-evident, since a change
    in any previous block will automatically invalidate all subsequent hashes. This
    property of blockchain makes it suitable for maintaining data logs. There are
    four main characteristics which make blockchain useful [[18](#CR18), [19](#CR19)].
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是使用哈希值创建的，每个块都存储着上一个块的哈希值。这使得链具有防篡改的特性，因为任何前面块的更改都会自动使所有后续哈希值失效。这种区块链的属性使其适用于维护数据日志。有四个主要特征使得区块链有用[[18](#CR18),
    [19](#CR19)]。
- en: '**Decentralization**—The need of any third party moderator or validator is
    eliminated with the help of distributed consensus. A transaction is said to be
    committed only after a majority of nodes in the blockchain agree that it is valid.
    This also makes it hard to forge a new entry.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化** —— 借助分布式共识，消除了任何第三方调解者或验证者的需求。只有当区块链中的大多数节点都同意某个交易有效时，该交易才被认为是已提交的。这也使得伪造新条目变得困难。'
- en: '**Persistent**—Once added, it is difficult to remove any entry from the chain
    because it is inherently tamper-evident.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性** —— 一旦添加，很难从链中删除任何条目，因为它本质上是防篡改的。'
- en: '**Anonymous**—Users interact with chains using a generated address, which is
    difficult to trace back to the original user. This is taken advantage of in cryptocurrencies.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名性** —— 用户使用生成的地址与链进行交互，很难追溯到原始用户。这在加密货币中得到了利用。'
- en: '**Auditability**—Any transaction can be traced back to the original entry,
    since data cannot be erased from the chain. In Bitcoin, this is done using the
    *Unspent Transaction Output* entry.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可审计性** —— 由于数据无法从链中擦除，因此任何交易都可以追溯到原始条目。在比特币中，这是通过*未花费的交易输出*条目来实现的。'
- en: Another application domain of blockchain is in transaction code execution, which
    is made possible using the concept of **smart contracts**. They are small pieces
    of code that are executed when a transaction is deemed successful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的另一个应用领域是在交易代码执行中，这是通过**智能合约**的概念实现的。它们是在交易被认为成功时执行的小段代码。
- en: 3.1 Blockchain Architecture
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 区块链架构
- en: A general architecture of blockchain is given in Figs. [2](#Fig2) and [3](#Fig3).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig2_HTML.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的一般架构见图[2](#Fig2)和[3](#Fig3)。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig2_HTML.png)
- en: Fig. 2
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: General architecture of blockchain [[18](#CR18)]
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的一般架构[[18](#CR18)]
- en: '![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig3_HTML.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig3_HTML.png)'
- en: Fig. 3
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: Structure of a block [[18](#CR18)]
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 区块的结构[[18](#CR18)]
- en: A block consists of a *block header* followed by *block body* [[18](#CR18),
    [19](#CR19)]. Transactions are managed with the help of a merkel tree, which creates
    hash values based on a tree-like arrangement of elements. The root of a merkel
    tree will represent the hash of all elements under it. This is added to the block
    header. The header also contains recordkeeping information like version, timestamp,
    etc., followed by the hash of previous block. All transaction information is maintained
    in the block body.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块由*区块头*后跟*区块体*[[18](#CR18), [19](#CR19)]组成。交易是通过 Merkle 树管理的，Merkle 树根据元素的树状排列创建哈希值。Merkle
    树的根代表其下所有元素的哈希值。这被添加到区块头中。区块头还包含版本、时间戳等记录信息，然后是上一个区块的哈希值。所有交易信息都在区块体中维护。
- en: Consensus is the core of any blockchain ecosystem. This is since transactions
    cannot be added to the chain unless there is approval from majority of participating
    nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 共识是任何区块链生态系统的核心。这是因为除非获得大多数参与节点的批准，否则无法向区块链添加交易。
- en: Two popular consensus algorithms are considered here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里考虑了两种流行的共识算法。
- en: '1.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: '**Proof of Work (PoW)**—In PoW, each node of the network (called a *miner*)
    calculates a hash value of the block header for authority to initiate a transaction
    (called *mining*). A value called *nonce* is present in the header, which is tweaked
    to change the hash value. In order to start a transaction, the computed hash should
    be less than a predetermined threshold. If a node reaches that threshold, the
    status is broadcast to all nodes, and everyone needs to validate that block. On
    validation, nodes add the block to their chain. If multiple miners generate valid
    blocks simultaneously, the chain is forked at that point, and eventually shorter
    forks are discarded. Even though the process is quite effective, it is computationally
    expensive.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**工作证明（PoW）**—在 PoW 中，网络的每个节点（称为*矿工*）都要计算区块头的哈希值，以获得发起交易的权限（称为*挖矿*）。头部中存在一个称为*随机数*的值，用于更改哈希值。为了发起交易，计算出的哈希值应该小于预定的阈值。如果一个节点达到了该阈值，状态将向所有节点广播，并且每个人都需要验证该区块。经过验证，节点将该区块添加到它们的链中。如果多个矿工同时生成有效的区块，链就会在那一点分叉，最终较短的分叉被丢弃。尽管这个过程非常有效，但在计算上是昂贵的。'
- en: '2.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: '**Proof of Stake (PoS)**—It is an energy-saving alternative to PoW where miners
    prove authority based on the amount of currency held by them. Here, mining cost
    is nearly zero. The nodes need to broadcast their account balance and the network
    reaches a consensus on who can add the next block.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**股权证明（PoS）**—这是一种节能替代 PoW 的方法，在这种方法中，矿工根据其持有的货币数量证明权威。在这里，挖矿成本几乎为零。节点需要广播他们的账户余额，网络就会就添加下一个区块达成共识。'
- en: If we want to draw parallels between blockchain and conventional databases,
    we need to consider database read and write operations. In blockchain, *writing*
    is analogous to creating consensus in the blockchain and adding a new block. *Reading*
    simply involves reading and auditing the entries in blockchain [[20](#CR20)].
    Considering that there are analogous operations, decision needs to be made on
    when blockchain becomes important. This is explained in details using a simple
    illustration in [[20](#CR20)], which is given in Fig. [4](#Fig4).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig4_HTML.png)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将区块链与传统数据库进行类比，我们需要考虑数据库的读写操作。 在区块链中，*写入*类似于在区块链中创建共识并添加新块。 *阅读*只涉及阅读和审核区块链中的条目
    [[20](#CR20)]。 考虑到有类似的操作，需要决定何时区块链变得重要。 这在[[20](#CR20)]中用简单的示例详细解释，如图[4](#Fig4)所示。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig4_HTML.png)
- en: Fig. 4
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: When to use blockchain [[20](#CR20)]
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用区块链 [[20](#CR20)]
- en: Hyperledger and Ethereum are two popular implementations of blockchain [[21](#CR21)].
    Hyperledger follows the traditionalist model, wherein the user has control over
    the data, and the entire processing is based on how information moves across the
    chain. Ethereum considers the problem in a different perspective. It is a permissionless
    platform, which implements the concept of smart contracts through a scripting
    platform. For that, it makes use of the *Ethereum Virtual Machine (EVM)*, which
    enables us to strike parallels with the micro-VMs of serverless computing. Such
    diverse implementations have enabled blockchain to find applications in a number
    of domains like Internet of Things, healthcare, supply chain, governance, etc.
    A functional description is given in [[19](#CR19)], which is depicted in Fig. [5](#Fig5).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig5_HTML.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 超级账本和以太坊是区块链的两种流行实现 [[21](#CR21)]。 超级账本遵循传统模式，在该模式中用户控制数据，并且整个处理过程基于信息在链上的传递方式。
    以太坊从不同角度考虑了这个问题。 它是一个无需许可的平台，通过脚本平台实现智能合约的概念。 为此，它利用了*以太坊虚拟机（EVM）*，这使我们能够与无服务器计算的微型虚拟机进行类比。
    这样多样化的实现使得区块链能够在诸如物联网、医疗保健、供应链、治理等多个领域找到应用。 在[[19](#CR19)]中给出了功能描述，如图[5](#Fig5)所示。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig5_HTML.png)
- en: Fig. 5
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: Functional architecture of blockchain [[19](#CR19)]
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的功能架构 [[19](#CR19)]
- en: 3.2 Smart Contracts
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 智能合约
- en: Smart contracts open up an avenue to incorporate executable codes into blockchain.
    They enable higher order functions and a level of complexity to be added to the
    conventional blockchain framework. This is quite useful in applications like real
    estate management and supply chain management, where every transaction needs to
    be validated not only from the blockchain point of view, but in terms of the data
    contained within. The concept of smart contract can be used like a database trigger
    to inspect the contents being logged into the chain once ready. They also allow
    specific computations to be performed so that the transaction is completed (analogous
    to signing the physical sale letter, smart contracts may be considered as digitally
    signing a sale letter).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约为将可执行代码纳入区块链打开了一条途径。它们使得可以在传统的区块链框架中添加更高阶的功能和一定程度的复杂性成为可能。这在房地产管理和供应链管理等应用中非常有用，因为每一笔交易都需要从区块链的角度进行验证，同时也需要根据其中包含的数据进行验证。智能合约的概念可以像数据库触发器一样使用，以检查一旦准备好就要记录到链中的内容。它们还允许执行特定的计算，以便完成交易（类似于签署实体销售函，智能合约可以被视为数字签署销售函）。
- en: A smart contract is an encapsulation of functions (code) and state (data) that
    is deployed using signed transactions on the blockchain network [[22](#CR22)].
    This contract is executed by nodes within the blockchain network and the results
    of execution are recorded on the blockchain. In many cases, the publishing nodes
    execute the contract when publishing new blocks. In some implementations, nodes
    only validate the results of the nodes that are publishing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是使用区块链网络上的已签名交易部署的函数（代码）和状态（数据）的封装[[22](#CR22)]。该合约由区块链网络内的节点执行，并将执行结果记录在区块链上。在许多情况下，发布节点在发布新区块时执行合约。在某些实现中，节点仅验证发布节点的结果。
- en: Based on the complexity of the code, there is a time limit on how long a contract
    can execute. Any violation of this time limit will result in forced termination
    of the contract execution, and the transaction is discarded. This prevents malicious
    users from deploying and executing smart contracts that can potentially lead to
    denial of service attacks. For conventional blockchain implementations, executing
    a smart contract will incur a small fee, which is deducted from their stake. But
    for permissioned blockchain networks, this may not be required since users are
    known in advance, and other methods of preventing malicious execution can be used
    (like removing access rights).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码的复杂性，合约执行的时间有限制。任何违反此时间限制的行为都将导致合约执行的强制终止，并且交易将被丢弃。这可以防止恶意用户部署和执行可能导致拒绝服务攻击的智能合约。对于传统的区块链实现，执行智能合约将产生小额费用，这些费用将从他们的利益中扣除。但对于权限区块链网络，这可能并不需要，因为用户在预先已知，可以使用其他方法来防止恶意执行（比如移除访问权限）。
- en: 4 Quantum Computing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子计算
- en: According to Li et al [[23](#CR23)], quantum computing combines the capabilities
    of quantum mechanics and computer science. While the elementary unit of computation
    in a conventional computational unit is the *bit*, quantum computers perform computations
    in terms of *qubit* (quantum bit). A qubit can be considered as a two-level atom.
    The advantage of quantum entities is that they can be in super-position of basic
    states. This means that all of these numbers represented by the basic states can
    be manipulated simultaneously, leading to opportunities for enormous parallelism.
    This is a huge paradigm shift from the conventional computing model which was
    based on boolean algebra, turing machine, and lambda calculus.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据李等人 [[23](#CR23)] 的说法，量子计算结合了量子力学和计算机科学的能力。在传统计算单元中，计算的基本单位是*比特*，而量子计算机则以*量子位*（量子比特）进行计算。量子位可以被看作是一个两级原子。量子实体的优势在于它们可以处于基本状态的叠加态。这意味着所有这些由基本状态表示的数字可以同时被操纵，从而带来了巨大的并行性机会。这是一个巨大的范式转变，与传统的基于布尔代数、图灵机和λ演算的计算模型相比。
- en: Quantum computation requires the following to be in place before processing
    can begin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算需要以下条件才能开始处理。
- en: A two-level system to ensure compatibility with conventional binary logic (represented
    as |0> and |1>)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个两级系统以确保与传统二进制逻辑的兼容性（表示为|0>和|1>）
- en: Initial state for the qubit (one of the levels mentioned above)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态为量子位（上面提到的其中一种水平）
- en: A method to measure the state of qubit
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种测量量子位状态的方法
- en: Construction of basic gate operations (analogous to boolean logic)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本门操作（类似于布尔逻辑）
- en: Decoherence time, which ensures the system attains stability after any interaction
    with the surroundings and within itself.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退相干时间，确保系统在与周围环境和内部的任何相互作用之后达到稳定状态。
- en: One of the important features of quantum models is that of entanglement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 量子模型的一个重要特征之一是纠缠。
- en: Entanglement states that, measurements of one particle affect measurements of
    another. It creates a virtual synchronization mechanism between qubits [[24](#CR24)].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 纠缠表明，对一个粒子的测量会影响另一个粒子的测量。它在量子位之间创建了一种虚拟的同步机制 [[24](#CR24)]。
- en: Considering entanglement, any state of superposition in quantum computing can
    be represented as follows.![$$\begin{aligned} |\psi&gt; = \alpha |0&gt; + \beta
    |1&gt; \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ1.png)(1)This
    representation can be directly converted to the Hilbert space by giving corresponding
    base vectors. This gives rise to the following mathematical model.![$$\begin{aligned}
    |0&gt; = \begin{bmatrix}1 \\ 0 \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ2.png)(2)![$$\begin{aligned}
    |1&gt; = \begin{bmatrix}0 \\ 1 \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ3.png)(3)![$$\begin{aligned}
    |\psi&gt; = \alpha |0&gt; + \beta |1&gt; = \begin{bmatrix}\alpha \\ \beta \end{bmatrix}
    \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ4.png)(4)For
    two qubits, we can generate a 4-dimensional basis, with four coefficients of superposition.
    The same can be converted to the Hilbert space also as seen earlier.![$$\begin{aligned}
    |\psi&gt; = \alpha |00&gt; + \beta |01&gt; + \gamma |10&gt; + \delta |11&gt; \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ5.png)(5)![$$\begin{aligned}
    \Longrightarrow |\psi &gt; = \alpha \begin{bmatrix}1\\ 0\\ 0\\ 0 \end{bmatrix}
    + \beta \begin{bmatrix}0\\ 1\\ 0\\ 0 \end{bmatrix} + \gamma \begin{bmatrix}0\\
    0\\ 1\\ 0 \end{bmatrix} + \delta \begin{bmatrix}0\\ 0\\ 0\\ 1 \end{bmatrix} =
    \begin{bmatrix}\alpha \\ \beta \\ \gamma \\ \delta \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ6.png)(6)This
    concept enables us to extend a N-state system to a 2^N-state system with different
    levels of superposition. This has led to the generation of a number of quantum-based
    computational models like Quantum Turing Machine, Quantum circuits, etc. The concept
    is explained well in the 2014 thesis by Markus Kiili. The ideal state of the system
    is termed as the *normalized* state, which is characterized by the sum of squares
    of superposition coefficients becoming 1.![$$\begin{aligned} \alpha ^{2} + \beta
    ^{2} = 1 \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ7.png)(7)![$$\begin{aligned}
    \alpha ^{2} + \beta ^{2} + \gamma ^{2} + \delta ^{2} = 1 \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ8.png)(8)If
    the condition cannot be met, manual normalization may be needed [[25](#CR25)].
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到纠缠，量子计算中的任何叠加态都可以表示如下。
- en: 4.1 Quantum Key Distribution
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 量子密钥分发
- en: It has been estimated that quantum computers will be able to break current cryptographic
    algorithms using brute force itself [[26](#CR26)]. Security systems like in blockchain
    rely on one-way codes (like hashes) that are easily computable in the forward
    direction, but computationally difficult to reverse engineer. Two such common
    methods are *Integer Factorization Problem* and *Discrete Logarithm Problem*.
    Shor’s factorization algorithm [[27](#CR27)] gave an insight towards how quantum
    computing and entanglement can create shortcuts in executing massively parallel
    tasks. While the complexity of the algorithm remains the same, qubits allow multiple
    combinations to be tried out in parallel, thereby reducing the required time to
    a great extent.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有估计称量子计算机将能够仅通过暴力破解当前的加密算法[[26](#CR26)]。像区块链中的安全系统依赖于单向代码（如哈希），这些代码在正向方向上很容易计算，但在反向工程上计算量很大。两种常见的方法是*整数因子分解问题*和*离散对数问题*。Shor
    的因子分解算法[[27](#CR27)]揭示了量子计算和纠缠如何在执行大规模并行任务时创建捷径。虽然算法的复杂度保持不变，但量子比特允许并行尝试多种组合，从而大大缩短了所需的时间。
- en: Quantum computing itself gives a solution to this. It works by harnessing the
    property of entanglement which states that measurement of one particle affects
    the measurement of its pair.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算本身就给出了解决方案。它利用了纠缠的属性，即一个粒子的测量会影响其配对粒子的测量。
- en: In other words, communications using quantum computing are inherently authenticated,
    and fundamental principles of physics states that quantum states cannot be copied
    or measured without alteration. Hence, any eavesdropper will immediately leave
    a mark, and is detected. This is the fundamental principle behind **Quantum Key
    Distribution (QKD)**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用量子计算进行通信本质上是经过身份验证的，物理学的基本原理表明量子态无法被复制或测量而不受到改变。因此，任何窃听者都会立即留下痕迹，并被检测到。这是**量子密钥分发（QKD）**的基本原理。
- en: A comprehensive description of the concept is available in [[28](#CR28)]. QKD
    uses quantum states to establish a random key for cryptography. Here, data is
    sent across an optical channel, which is best suited for encoding quantum information.
    The sequence of actions are as follows, considering a communication between Alice
    and Bob.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的综合描述可在[[28](#CR28)]中找到。QKD 使用量子态来建立密码学的随机密钥。在这里，数据通过光学通道发送，这是最适合编码量子信息的。以下是行动的序列，考虑到
    Alice 和 Bob 之间的通信。
- en: '1.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Alice sends to Bob 2n qubits, each prepared in one of the states |0>, |1>, |+>,
    |-> randomly chosen. Since communication is optical, this may be done using polarizers.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Alice 将 2n 个量子比特发送给 Bob，每个量子比特都是随机选择的 |0>、|1>、|+>、|-> 状态之一。由于通信是光学的，这可以使用偏振器来完成。
- en: '2.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Bob measures the received bits, choosing the measurement basis randomly between
    |0>,|1> and |+>,|->. This can be achieved using polarity filters.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Bob 测量接收到的比特，随机选择测量基础为 |0>、|1> 和 |+>、|->。这可以通过极性滤波器来实现。
- en: '3.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Alice and Bob inform each other publicly of the basis they used to prepare or
    measure each qubit.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Alice 和 Bob 公开告知对方他们用来准备或测量每个量子比特的基础。
- en: '4.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Both find out on which occasions they used the same basis. This happens on average
    half the time. Those occasions in which same basis is used are retained.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们找出彼此在哪些场合使用了相同的基础。这平均发生了一半的时间。那些使用相同基础的场合被保留下来。
- en: '5.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Ideally, they now share the same random string of n qubits, which are then mapped
    to classical bits (for example, |0> and |+> map to 0, |1> and |-> map to 1). This
    bit string is called RQT (*Raw Quantum Transmission*).
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理想情况下，他们现在共享这 n 个量子比特的相同随机字符串，然后将这些量子比特映射到经典比特（例如，|0> 和 |+> 映射到 0，|1> 和 |->
    映射到 1）。这个位串被称为 RQT（*原始量子传输*）。
- en: '6.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Alice and Bob announce a randomly chosen (and predefined) set of n/2 bits from
    the RQT. If all those bits match, the undisclosed n/2 bits are accepted as the
    key. Otherwise it is discarded and a fresh transmission is initiated.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Alice 和 Bob 公布了从 RQT 中随机选择（并预先定义）的一组 n/2 位。如果所有这些位都匹配，未公开的 n/2 位将被接受作为密钥。否则，它将被丢弃，并重新启动新的传输。
- en: While the algorithm seems straightforward, the fundamental principle of quantum
    entanglement is used here. Alice and Bob don’t disclose the data being sent across.
    Only the basis used for each instance is disclosed publicly, and it is ineffective
    to an eavesdropper as long as the original qubit stream is absent. If an eavesdropper
    manages to intercept the bit stream, the qubit will change in orientation, and
    that bit won’t match in the RQT. Taking a probabilistic estimate, if an eavesdropper
    was listening to the entire transmission, it would have changed the orientation
    of all bits, and it should be detectable using just 50% of the RQT (since it is
    a binary system). This is achieved in Step 6 of the process given above. The advantage
    of this method is that a majority of the algorithm can be directly implemented.
    But challenge remains in the realm of long distance transmission, since optical
    communication needs to be reliable not only in terms of intensity, but in terms
    of polarity also. The QKD procedure is illustrated in *Quantum Flagship*, which
    is given in Fig. [6](#Fig6).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig6_HTML.png)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管算法看起来很直接，但是这里使用了量子纠缠的基本原理。Alice 和 Bob 没有公开传输的数据。每个实例使用的基础只是公开的，只要原始的量子比特流不存在，对窃听者就没有效果。如果窃听者设法拦截了位流，量子比特的方向就会改变，而且那个比特就不会匹配
    RQT 中的对应位。根据概率估计，如果窃听者一直监听整个传输，那么它就会改变所有比特的方向，并且只需用到 RQT 的 50% 就可以检测到（因为它是一个二进制系统）。这是上述过程的第
    6 步中完成的。这种方法的优势在于绝大部分算法可以直接实现。但是在远距离传输领域依旧面临挑战，因为光通信不仅在强度方面需要可靠，也在极性方面需要可靠。QKD
    过程在 *Quantum Flagship* 中有所说明，见图[6](#Fig6)。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig6_HTML.png)
- en: Fig. 6
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: 'Working of QKD *(Courtesy: Quantum Flagship)*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: QKD 的工作原理（*提供者：量子旗舰*）
- en: 5 Blockchain in Serverless Computing
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 区块链在无服务器计算中的应用
- en: Tien et al. [[29](#CR29)] has introduced a data-centric view of blockchain.
    It breaks the ecosystem down into four layers, each dealing with a different type
    of data item. The layers are as follows.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Tien等人[[29](#CR29)]提出了区块链的数据中心视图。它将生态系统分解为四个层，每个层处理不同类型的数据项。这些层如下所示。
- en: '1.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: '**Consensus:** It deals with data that prove authority of adding new data into
    the chain. As part of that, values like nonce, stake, etc. may be transferred
    and validated.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**共识：** 处理证明将新数据添加到链中的权限的数据。作为其中的一部分，值如 nonce、质押等可能被转移和验证。'
- en: '2.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: '**Data model:** It refers to the actual data being processed in the chain.
    It may comprise of transaction data, indices, blocks, etc. Those who qualify after
    consensus get the authority to generate an instance of the data model and write
    it to block after approval.'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**数据模型：** 指的是链上正在处理的实际数据。它可能包括交易数据、索引、块等。符合共识条件的人有权生成数据模型的实例，并在获得批准后将其写入区块。'
- en: '3.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: '**Execution engine:** It denotes processing done on the data model. It may
    be pieces of code run on VMs, containers, etc.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**执行引擎：** 表示对数据模型执行的处理。它可能是在虚拟机、容器等上运行的代码片段。'
- en: '4.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: '**Application:** It refers to the application layer code, embedded in the form
    of smart contracts, that get executed within the execution engine.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用程序：** 指的是以智能合约形式嵌入的应用程序层代码，在执行引擎内执行。'
- en: The layered architecture diagram from [[29](#CR29)] has been adapted in Fig. [7](#Fig7).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig7_HTML.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自[[29](#CR29)]中的分层架构图已在图[7](#Fig7)中进行了调整。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig7_HTML.png)
- en: Fig. 7
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: Layered architecture—A data centric view of blockchain [[29](#CR29)]
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构—区块链的数据中心视图[[29](#CR29)]
- en: Considering the layered stack discussed in [[29](#CR29)], an abstract model
    can be created wherein parallels can be established between blockchain implementations
    and serverless platforms. This will enable easier integration of blockchain into
    serverless frameworks. The possibility is explored in Table [2](#Tab2).Table 2
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到[[29](#CR29)]中讨论的分层堆栈，可以创建一个抽象模型，在其中可以建立区块链实现和无服务器平台之间的类比。这将使区块链更容易集成到无服务器框架中。这种可能性在表[2](#Tab2)中得到了探讨。表2
- en: Possibility of integrating blockchain into serverless platforms
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将区块链整合到无服务器平台的可能性
- en: '| Blockchain layer | Use in serverless platforms |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 区块链层 | 在无服务器平台中的使用 |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Consensus | When there are excessive number of requests to be handled, serverless
    platforms can automatically scale the processing capability by adding more virtual
    machines. Consequently, there will be a number of nodes concurrently waiting for
    new requests. Consensus methods can be used by the load balancer to select which
    node should accept the request |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 共识 | 当有大量请求需要处理时，无服务器平台可以通过添加更多虚拟机来自动扩展处理能力。因此，将会有许多节点同时等待新请求。负载均衡器可以使用共识方法来选择哪个节点应该接受请求。
    |'
- en: '| Data model | Serverless platforms use request-response model of execution.
    This involves request header, request body, response code, response header, and
    response payload. Requests are directly forwarded to the selected node, which
    can execute it, and return the result. Prior to sending the result, the request
    and response data should be logged to the blockchain after validation |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 数据模型 | 无服务器平台使用请求-响应执行模型。这涉及请求标头、请求主体、响应代码、响应标头和响应有效载荷。请求直接转发到选定的节点，该节点可以执行它，并返回结果。在发送结果之前，应验证请求和响应数据后将其记录到区块链中
    |'
- en: '| Execution engine | This may be a micro-VM or container on which the server
    code should run. While one node is selected for execution, others may have to
    validate the output by running their own code and verifying if the output is as
    advertised. Depending on the language of choice, the container or VM can be installed.
    The Ethereum platform already supports EVM for running its smart contracts |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 执行引擎 | 这可以是微型虚拟机或容器，用于运行服务器代码。虽然选择了一个节点进行执行，但其他节点可能需要通过运行自己的代码并验证输出是否如广告中所述来验证输出。根据选择的语言，可以安装容器或虚拟机。以太坊平台已经支持用于运行其智能合约的EVM
    |'
- en: '| Application | Whenever a new request comes, it is logged as a transaction
    and the smart contract is initiated. The smart contract will contain the actual
    code to be executed, and the output is written to the chain after validation |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序 | 每当有新的请求到来时，都会将其记录为一个事务，并启动智能合约。智能合约将包含要执行的实际代码，并在验证后将输出写入链中 |'
- en: FBaaS [[30](#CR30)] is an implementation which provides blockchain as a cloud-like
    service. It comprised of the following layers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: FBaaS [[30](#CR30)]是提供区块链作为云服务的实现。它由以下几层组成。
- en: '1.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: '*Infrastructure layer* set up on regular compute nodes (not serverless).'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*基础设施层*建立在普通计算节点上（不是无服务器）。'
- en: '2.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: '*Components layer* to handle authentication and authorization operations, that
    are commonly used in execution. *Role Based Access Control* is used for this purpose.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*组件层*处理在执行中常用的身份验证和授权操作。用于此目的的是*基于角色的访问控制*。'
- en: '3.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: '*Services layer* that houses the blockchain code to be executed. It takes care
    of object storage, transaction initiation, mining, chain management, and conflict
    resolutions (in case of inconsistency). It also performs autoscaling by deploying
    containers as needed. This process is referred to as *Function Server*.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*服务层*承载要执行的区块链代码。它负责对象存储、事务启动、挖矿、链管理和冲突解决（在一致性不一致的情况下）。它还通过根据需要部署容器来执行自动扩展。这个过程被称为*功能服务器*。'
- en: '4.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: '*Business logic layer* that exposes the services to be used by participants.
    Abstractions can be added on top of existing layers to extend the functionality.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*业务逻辑层*公开供参与者使用的服务。可以在现有层之上添加抽象以扩展功能。'
- en: ChainFaaS [[31](#CR31)] is an implementation that uses blockchain to implement
    a serverless platform. The role of blockchain in the architecture is to maintain
    a log of execution, and keep track of financial transactions (which are given
    as an execution fee to the service provider). It implements the architecture discussed
    above in a different way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ChainFaaS [[31](#CR31)] 是一种利用区块链实现无服务器平台的实现。区块链在架构中的作用是维护执行日志，并跟踪财务交易（作为执行费用支付给服务提供者）。它以不同的方式实现了上述讨论的架构。
- en: '1.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: '*Blockchain network* takes care of logging and keeps track of execution fee.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*区块链网络* 负责记录日志并跟踪执行费用。'
- en: '2.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: '*Serverless controller* is the interface to the outside, and maintains the
    scheduling part.'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*无服务器控制器* 是与外部的接口，并维护调度部分。'
- en: '3.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: '*Execution network* is responsible for maintaining and deploying containers
    and VMs to perform execution.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*执行网络* 负责维护和部署容器和虚拟机以执行操作。'
- en: Yet another implementation of microservices using blockchain was discussed in
    [[32](#CR32)]. It created a comparison between conventional serverless API-based
    implementations, and blockchain-based implementations. In the architecture proposed
    in [[32](#CR32)], microservices are directly written as smart contracts, similar
    to that done by APIs. These smart contracts may use remote procedure calls to
    access external entities. The architecture from [[32](#CR32)] is given in Fig. [8](#Fig8).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig8_HTML.png)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用区块链的微服务实现在 [[32](#CR32)] 中进行了讨论。它对传统的基于 API 的无服务器实现和基于区块链的实现进行了比较。在 [[32](#CR32)]
    提出的架构中，微服务直接编写为智能合约，类似于 API 所做的。这些智能合约可以使用远程过程调用来访问外部实体。[[32](#CR32)] 中的架构如图 [8](#Fig8)
    所示。
- en: Fig. 8
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8
- en: API versus Blockchain—Implementing microservices [[32](#CR32)]
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: API 对比区块链——实现微服务 [[32](#CR32)]
- en: The three implementations seen above can be compared in terms of the generic
    architecture discussed in Table [2](#Tab2). The comparison is given in Table [3](#Tab3).Table
    3
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三种实现可以根据表 [2](#Tab2) 中讨论的通用架构进行比较。比较结果如表 [3](#Tab3) 所示。
- en: Comparison of FBaaS, ChainFaaS and Microservices architectures
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: FBaaS、ChainFaaS 和微服务架构的比较
- en: '| Blockchain layer | FBaaS [[30](#CR30)] | ChainFaaS [[31](#CR31)] | Microservices
    [[32](#CR32)] |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 区块链层 | FBaaS [[30](#CR30)] | ChainFaaS [[31](#CR31)] | 微服务 [[32](#CR32)]
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Consensus | Services layer | Blockchain network | Blockchain layer |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 共识 | 服务层 | 区块链网络 | 区块链层 |'
- en: '| Data model | Services layer | Blockchain network | Blockchain layer |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 数据模型 | 服务层 | 区块链网络 | 区块链层 |'
- en: '| Execution engine | Services layer | Execution network | API gateway and blockchain
    layer |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 执行引擎 | 服务层 | 执行网络 | API 网关和区块链层 |'
- en: '| Application | Business logic layer | Serverless controller | API frontend
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | 业务逻辑层 | 无服务器控制器 | API 前端 |'
- en: 6 Quantum Key Distribution in Serverless Computing
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 无服务器计算中的量子密钥分发
- en: 6.1 Security in Serverless Domain
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1 无服务器域中的安全性
- en: Eric et al. [[14](#CR14)] have listed the most important security issues caused
    exclusively due to serverless computing. While this paradigm suffers from all
    security loopholes in terms of authentication and protocol-level breaches, the
    fact that there is limited control over resource provisioning raises some additional
    dangers. The dangers are due to application disintegration for modularity, and
    relocation for load balancing. The important security challenges to be considered
    are as follows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Eric 等人[[14](#CR14)]列出了仅由无服务器计算引起的最重要的安全问题。虽然这种范式在认证和协议级违规方面都存在安全漏洞，但由于对资源供应的控制有限，会引发一些额外的危险。这些危险是由于应用程序模块化而引起的应用程序分解和负载平衡而导致的。需要考虑的重要安全挑战如下。
- en: Physical isolation may have to ensured so that no attacker can gain colocated
    access to any other process. Since cloud processes are ephemeral, there is a chance
    that an attacker can gain access to an unprotected process in the middle of their
    execution.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理隔离可能必须确保，以防止任何攻击者获得对其他进程的共同访问。由于云进程是短暂的，攻击者有可能在它们执行中间时获得对未受保护进程的访问。
- en: Fine-grained security management may be required since security policies have
    to be enforced at each node where the code is executed.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要细粒度的安全管理，因为安全策略必须在执行代码的每个节点强制执行。
- en: As large applications get disintegrated to small functions, they will have to
    maintain communication between themselves so that continuity is maintained. As
    part of that, intermediate outputs will have to be transferred between API calls.
    This transfer may leak patterns and sensitive information even if it is protected
    end to end.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着大型应用程序被分解为小函数，它们将必须保持彼此之间的通信，以确保连续性。作为其中的一部分，中间输出将必须在 API 调用之间传输。即使端到端受保护，这种转移也可能泄漏模式和敏感信息。
- en: If any external service is accessed from within the function (like external
    databases), access privilege needs to be exposed to all possible hosting locations
    for the function. Otherwise certain accesses will be blocked since they are not
    in the allowed list [[2](#CR2)].
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在函数内部访问任何外部服务（如外部数据库），则需要将访问权限暴露给函数的所有可能托管位置。否则，由于它们不在允许列表中，某些访问将被阻止[[2](#CR2)]。
- en: 6.2 Using QKD as a Security Mechanism
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2 使用 QKD 作为安全机制
- en: The concept of Quantum Key Distribution was introduced in Sect. [4.1](#Sec9).
    Scarani et al. [[33](#CR33)] have verified the proof of a practical QKD algorithm
    called BB84, and evaluated the effectiveness of different transmitters and channels
    in their working. Shor and Preskill [[34](#CR34)] evaluated the same considering
    overlapping quantum states, and found that the algorithm is resistant enough to
    thwart most attacks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 量子密钥分发的概念在[4.1](#Sec9)节中介绍。Scarani 等人[[33](#CR33)]验证了一个实用的 QKD 算法 BB84 的证明，并评估了不同发射机和通道在其工作中的有效性。Shor
    和 Preskill[[34](#CR34)]考虑到重叠的量子态对其进行了评估，并发现该算法足够抵御大多数攻击。
- en: Kiktenko et al. [[35](#CR35)] demonstrated a model in which blockchain itself
    can be secured using QKD. It is designed on top of a two-layer arrangement. QKD
    can securely generate symmetric keys. Hence layer 1 will be a mesh network that
    runs QKD between all pairs of nodes, thereby generating unconditionally secure
    keys between all of them. Layer 2 will be a conventional network that uses the
    securely generated private keys to perform further transmission. It also changes
    the framework by which new blocks are mined. Since quantum computers are empowered
    with massive inherent parallelism (because of superposition, they are in multiple
    states at once), a sufficiently powerful quantum computer can create enough blocks
    simultaneously to overwhelm the security and execute a 51% attack. Instead, the
    proposal in [[35](#CR35)] enforces a broadcast for each block, and individual
    approvals have to be obtained. The protocol performs periodic checks on the integrity
    of all chains. They were able to demonstrate it successfully on a small scale
    using optically modulated qubits.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Kiktenko 等人 [[35](#CR35)] 展示了一个模型，其中区块链本身可以使用量子密钥分发（QKD）进行安全保护。它设计在一个两层结构之上。QKD
    可以安全地生成对称密钥。因此，第一层将是一个网状网络，它在所有节点对之间运行 QKD，从而在它们之间生成无条件安全的密钥。第二层将是一个使用安全生成的私钥进行进一步传输的传统网络。它还改变了新区块被挖掘的框架。由于量子计算机具有巨大的固有并行性（因为叠加，它们同时处于多种状态），一个足够强大的量子计算机可以同时创建足够多的区块以压倒性地进行攻击并执行
    51% 攻击。相反，[[35](#CR35)] 中的建议强制要求为每个区块进行广播，并且必须获得个人批准。该协议对所有链的完整性进行周期性检查。他们能够使用光调制的量子比特成功地在小规模上进行演示。
- en: A number of cryptographic models that can survive a post-quantum ecosystem [[36](#CR36)]
    is described in [[37](#CR37)]. Rajan et al. [[38](#CR38)] takes it one step further
    and changes the notion of entanglement itself. They propose encoding the photons
    into a *Greenberger-Horne-Zeilinger (GHZ) state*, which ensures that simultaneous
    coexistence of superpositions don’t happen in space, but happens in time. This
    means that if there is a qubit state ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq1.png)
    at time t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq2.png)
    0, there is a possibility to generate the same state ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq3.png)
    at some t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq4.png)
    k. Hence the key need not be passed on immediately, and it could be regenerated
    at a later point of time. But it results in an increased risk of tampering, since
    changing the state at t=0 could potentially affect the working at its entangled
    time t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq5.png)
    k.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[[36](#CR36)]中描述了一些能够在后量子生态系统中生存的加密模型。Rajan等人[[38](#CR38)]将其推进一步，并改变了纠缠本身的概念。他们提出将光子编码成*格林伯格-霍恩-泽林格（GHZ）状态*，这确保了在空间中不会发生超定态的同时共存，而是发生在时间上。这意味着，如果在时刻
    t 时有一个量子位状态 ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq1.png)，那么在某个
    t 时刻也有可能生成相同的状态 ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq3.png)。因此，密钥不必立即传递，而可以在以后的某个时间重新生成。但这会增加篡改的风险，因为在
    t=0 时改变状态可能会影响到其纠缠时刻 t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq5.png)
    k 的工作。
- en: 7 Integrating QKD and Blockchain into Serverless Domain
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[将量子密钥分发（QKD）和区块链集成到无服务器领域](#) '
- en: As seen in previous sections, the crux of serverless platform is rapid resource
    provisioning and code execution. Both seem to be well taken care of using smart
    contracts on Ethereum. In addition, shared responsibility model of CSPs place
    the responsibility of security in the cloud on the developers and users themselves.
    This can be taken care of using cryptographic methods. Here, a method is proposed
    that uses blockchain and Quantum Key Distribution to create a scalable and secure
    platform to support conventional serverless platforms.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的部分所示，无服务器平台的关键是快速资源配置和代码执行。智能合约在以太坊上似乎很好地解决了这两个问题。此外，CSPs的共享责任模型将安全责任放在了开发人员和用户自身的云端。这可以通过使用加密方法来解决。在这里，提出了一种方法，利用区块链和量子密钥分发来创建一个可扩展且安全的平台，以支持传统的无服务器平台。
- en: 7.1 Deployment of Server Code
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 服务器代码的部署
- en: A well-defined programming model has been given for serverless platforms in
    [[1](#CR1)]. The aspects under discussion are given below.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[[1](#CR1)]中为无服务器平台提供了一个明确定义的编程模型。下面讨论的是以下方面。
- en: Since serverless programs are ephemeral, maintaining state will be difficult
    between executions. Subsequent executions may even be routed to different VMs.
    Hence they are stateless by design. In order to maintain continuity, state information
    (including security) is sent across as a parameter with each invocation. Another
    option would be to maintain the state in persistent storage or databases (like
    Amazon S3 buckets or Google Cloud SQL), which would be slower than stateless implementations.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于无服务器程序是短暂的，因此在执行之间保持状态将会很困难。后续执行甚至可能会被路由到不同的虚拟机。因此，它们从设计上就是无状态的。为了保持连续性，状态信息（包括安全信息）会作为参数随每次调用一起发送。另一个选择是在持久存储或数据库中（如Amazon
    S3桶或Google Cloud SQL）维护状态，但这会比无状态实现慢。
- en: A programming framework is essential to maintain proper sequencing. When using
    languages like Python or Node.js, routing frameworks will be helpful in connecting
    to web hooks and avoiding additional bridging code that may upset the load balancing
    capabilities.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护适当的顺序是至关重要的，因此编程框架是必不可少的。当使用诸如Python或Node.js之类的语言时，路由框架将有助于连接到web挂钩，并避免可能干扰负载平衡能力的额外桥接代码。
- en: The functions defined as serverless may require automatic triggering in response
    to various events (like adding a new file in storage), which is inherently stateless.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义为无服务器的函数可能需要根据各种事件（如在存储中添加新文件）自动触发，这在本质上是无状态的。
- en: Serverless functions may have to call other public APIs from within, because
    it may function as *glue code* to prevent end clients from invoking a chain of
    APIs. In that case, security should also be taken into consideration. This eventually
    leads to aggregated APIs.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器函数可能需要从内部调用其他公共API，因为它可能作为*粘合代码*，以防止终端客户端调用一系列API。在这种情况下，还应考虑安全性。这最终导致了聚合API。
- en: Hence each node that is spun up as part of demand-based autoscaling will have
    the following properties.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为基于需求的自动缩放的一部分启动的每个节点都将具有以下属性。
- en: The node will be loaded with a micro-VM or container that houses the blockchain
    layer, including the smart contract.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点将加载一个包含区块链层和智能合约的微型VM或容器。
- en: The chain won’t reside within the ephemeral node. Instead, it is offloaded to
    stable storage like Amazon S3 buckets or Google Cloud SQL.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链不会驻留在短暂的节点内。相反，它会被卸载到Amazon S3桶或Google Cloud SQL等稳定存储中。
- en: The working of nodes are completely stateless. There should not be any delay
    in execution because the node is waiting for input from stable storage.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的工作完全是无状态的。节点不应因等待来自稳定存储的输入而导致执行延迟。
- en: An abstract illustration of the layer is given in Fig. [9](#Fig9).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig9_HTML.png)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图9给出了该层的抽象示例。![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig9_HTML.png)
- en: Fig. 9
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9
- en: Smart contract deployment for serverless
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器智能合约部署
- en: 7.2 Blockchain and Consensus Algorithm
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链和共识算法
- en: As per NIST [[22](#CR22)], a *permissioned blockchain* is one in which users
    must be authorized by some authority. This makes restricting access much more
    easier. Read and write access can be managed at multiple levels by an entity that
    is centrally managing the access control. Even though blockchain as a concept
    thrives on decentralization, this centralized mode of control may be beneficial
    in the case of server execution, especially since the executing node is ephemeral,
    and can get initiated from any location. Use of permissioned blockchain will allow
    a service-based access control. As per the decision flowchart given in Fig. [4](#Fig4),
    permissioned blockchain is most preferred for serverless application since (i)
    stateful storage may be needed to persist across ephemeral executions, (ii) there
    are multiple writers, (iii) trusted third party may not always be available, (iv)
    all writer nodes are already known (they are spun up by the cloud provider), (v)
    all writers cannot be directly trusted (an attacker can still manipulate them
    since they are exposed to the internet, and security is not guaranteed under shared
    responsibility model), and (vi) public verifiability is not needed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 根据NIST [[22](#CR22)] 的说法，*权限区块链*是一种必须经过某种授权机构授权的区块链。这使得限制访问变得更加容易。读写访问可以由一个中央管理访问控制的实体在多个级别进行管理。尽管区块链作为一个概念在去中心化上蓬勃发展，但在服务器执行的情况下，这种集中式的控制模式可能是有益的，特别是由于执行节点是暂时的，并且可以从任何位置启动。使用权限区块链将允许基于服务的访问控制。根据图 [4](#Fig4)
    中给出的决策流程图，由于（i）需要持久化跨暂时执行的状态存储，（ii）存在多个写入者，（iii）信任的第三方可能并不总是可用，（iv）所有写入节点已知（它们由云提供商启动），（v）所有写入者不能直接信任（攻击者仍然可以操纵它们，因为它们暴露在互联网上，并且在共享责任模型下安全性不能得到保证），以及（vi）不需要公开可验证性，因此服务器无应用程序最好使用权限区块链。
- en: In order to avoid expensive computation, a Proof of Stake (PoS) consensus model
    is used. In this model, the participant with highest stake (currency) will get
    authority to insert the next block. The stake amount is verified by all nodes
    to reach the consensus. But in the long run it may become unfair because the richest
    node always gets the authority. Hence our model will use a semi-randomized selection
    process based on the key. In this model, each node will generate a random number,
    which is then hashed to generate a 256-bit number. This hash is XORed with the
    key to get the *stake*. This stake is then broadcast among the nodes and consensus
    is reached on who has the authority to add the next block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免昂贵的计算，采用了权益证明（PoS）共识模型。在这个模型中，拥有最高权益（货币）的参与者将获得插入下一个区块的权限。所有节点都验证权益金额以达成共识。但从长远来看，这可能变得不公平，因为最富有的节点总是获得权限。因此，我们的模型将使用基于密钥的半随机选择过程。在这个模型中，每个节点将生成一个随机数，然后对其进行哈希以生成一个256位的数字。这个哈希与密钥进行异或运算以获取*权益*。然后这个权益被广播给所有节点，并就谁有权添加下一个区块达成共识。
- en: Once the modified PoS is in place, the focus turns to key transfer. Key transfer
    is based on QKD, which uses polarized or modulated photons to carry their quantum
    state. As per the description in Sect. [4.1](#Sec9), it is inherently tamper-proof.
    Hence, we implement a multi-phase process as follows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦修改的PoS就位，焦点转向密钥传输。密钥传输基于QKD，使用偏振或调制的光子携带它们的量子状态。根据第[4.1](#Sec9)节的描述，它本质上是防篡改的。因此，我们实施以下多阶段过程。
- en: '1.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The client initiates a communication with the server. For that, Quantum Key
    Transfer is used to create a symmetric encryption channel between the client and
    load balancer at the service end. A payload of 1024 bits are transmitted from
    the client, which is received by the load balancer (recipient), and mapped from
    qubits to binary to generate the RQT. This RQT will be half the size of original
    payload, giving 512 bits. This RQT is then randomly verified with 256 bits announced,
    and if successful, the other 256 bits form the final **key**. The key may occasionally
    be renewed.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端启动与服务器的通信。为此，使用量子密钥传输创建客户端和服务端负载均衡器之间的对称加密通道。来自客户端的一个1024位的有效载荷被传输，这个有效载荷被负载均衡器（接收方）接收，并从量子比特映射到二进制，生成RQT。这个RQT将是原始有效载荷大小的一半，得到512位。然后，这个RQT随机验证成功，公布256位，如果成功，另外256位形成最终的**密钥**。密钥偶尔可能会更新。
- en: '2.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: When a request arrives at the load balancer, all available nodes will get activated,
    and they will generate a random number (**nonce**), which is then hashed to 256
    bits. This number is XORed with the key generated from QKD (which is also 256
    bits), and the result is broadcast as the **stake**.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当请求到达负载均衡器时，所有可用节点将被激活，并生成一个随机数（**nonce**），然后对其进行256位哈希处理。这个数字与从QKD生成的密钥（也是256位）进行异或运算，结果被广播为**股份**。
- en: '3.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Once all nodes broadcast their stake, the one with maximum stake becomes eligible
    for adding a block to the chain. This node is the **selected** node.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有节点广播它们的股份，拥有最大股份的节点有资格向链中添加块。这个节点是**选择的**节点。
- en: As an example, lets consider a case where we scale the system down to 16 bits
    of key. Hence the original communication needs to be 64 bits long. The process
    is tabulated in Table [4](#Tab4). Hexadecimal notation is considered in the beginning.Table
    4
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们考虑一个将系统缩小到16位密钥的情况。因此，原始通信需要64位长。这个过程在表[4](#Tab4)中进行了标记。在开始时考虑十六进制表示法。表4
- en: 'Sequence of execution of QKD and consensus: Example of 16-bit key'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: QKD和共识的执行顺序：16位密钥示例
- en: '| Operation | Bits | Content |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 位 | 内容 |'
- en: '| --- | --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Transmitted | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq6.png)
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 传输 | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq6.png)
    |'
- en: '| Received | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq7.png)
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 接收 | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq7.png)
    |'
- en: '| Assume alternate bits are valid as per base | 32 | ![$$4a284b5a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq8.png)
    = ![$$1001010001010000100101101011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq9.png)
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 假设交替位根据基数有效 | 32 | ![$$4a284b5a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq8.png)
    = ![$$1001010001010000100101101011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq9.png)
    |'
- en: '| Pick alternate bits for verification | 16 | ![$$3633_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq10.png)
    = ![$$011011000110011_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq11.png)
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 选取交替位进行验证 | 16 | ![$$3633_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq10.png)
    = ![$$011011000110011_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq11.png)
    |'
- en: '| Key after successful verification | 16 | ![$$809c_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq12.png)
    = ![$$1000000010011100_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq13.png)
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 成功验证后的密钥 | 16 | ![$$809c_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq12.png)
    = ![$$1000000010011100_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq13.png)
    |'
- en: '| Address: Node 1 | 64 | ![$$3de1016e288ba240_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq14.png)
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 地址: 节点 1 | 64 | ![$$3de1016e288ba240_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq14.png)
    |'
- en: '| Address: Node 2 | 64 | ![$$e1681f706a664a1a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq15.png)
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 地址: 节点 2 | 64 | ![$$e1681f706a664a1a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq15.png)
    |'
- en: '| Hash(nonce): Node 1 | 16 | ![$$f9f5_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq16.png)
    = ![$$1111100111110101_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq17.png)
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 哈希值(随机数): 节点 1 | 16 | ![$$f9f5_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq16.png)
    = ![$$1111100111110101_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq17.png)
    |'
- en: '| Hash(nonce): Node 2 | 16 | ![$$e686_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq18.png)
    = ![$$1110011010000110_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq19.png)
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 哈希值(随机数): 节点 2 | 16 | ![$$e686_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq18.png)
    = ![$$1110011010000110_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq19.png)
    |'
- en: '| Key XOR Nonce: Node 1 | 16 | ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq20.png)
    = ![$$0111100101101001_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq21.png)
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 密钥 XOR 随机数: 节点 1 | 16 | ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq20.png)
    = ![$$0111100101101001_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq21.png)
    |'
- en: '| Key XOR Nonce: Node 2 | 16 | ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq22.png)
    = ![$$0110011000011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq23.png)
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 密钥 XOR 随机数: 节点 2 | 16 | ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq22.png)
    = ![$$0110011000011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq23.png)
    |'
- en: '| Winner | 16 | Node 1 (since ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq24.png)
    > ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq25.png))
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 胜利者 | 16 | 节点 1 (因为 ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq24.png)
    > ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq25.png))
    |'
- en: 7.3 Execution of Smart Contract
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 智能合约执行
- en: Once a node is selected to execute the contract, the request is read by the
    contract and it runs the codebase loaded along with it. This codebase is loaded
    once per node, and is analogous to an API call. The sequence of steps are as follows.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了节点来执行合约，合约就会读取请求并运行加载的代码库。该代码库每个节点加载一次，并类似于 API 调用。步骤序列如下。
- en: '1.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The codebase for that node accepts the request parameters and performs validations
    if needed.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该节点的代码库接受请求参数，并在需要时执行验证。
- en: '2.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The function is executed, and result is generated as a transaction payload.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数被执行，并生成结果作为交易有效负载。
- en: '3.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: The payload is broadcast among all nodes, and one node is randomly selected
    to verify the result by executing its own local copy. If both match, the result
    is ready to be propagated. If not, a third node will have to execute and the majority
    answer is taken.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负载在所有节点之间广播，并随机选择一个节点通过执行其本地副本来验证结果。如果两者匹配，则结果已准备好传播。如果不匹配，则第三个节点将执行，并采用多数答案。
- en: '4.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: If there are insufficient nodes to verify and validate the transaction, the
    original output is accepted by default.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有足够的节点来验证和验证交易，则默认接受原始输出。
- en: '5.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: The transaction is written to stable storage in the format *{request header,
    request payload, key, nonce, execution timestamp, selected node details, validator
    node details, conflict details, response payload}* via its own blockchain API
    calls.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交易以 *{请求头、请求有效负载、密钥、随机数、执行时间戳、选定节点详情、验证节点详情、冲突详情、响应有效负载}* 的格式通过其自己的区块链 API 调用写入到稳定存储中。
- en: This is explained with the below example. A part of smart contract codebase
    to increment the input value is given below.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figa_HTML.png)The
    request is received from IP 119.208.23.5, and it is requesting to increment the
    value “100”. As seen previously, Node 1 is ready to execute the contract. It is
    executed, and the following payload is generated.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figb_HTML.png)This
    is sent to all nodes, and Node 2 will verify that it is correct. Since it is the
    correct output, it can be sent to stable storage. The following transaction is
    logged.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figc_HTML.png)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个解释。给出了增加输入值的智能合约代码库的一部分示例。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figa_HTML.png)从
    IP 119.208.23.5 收到请求，请求增加值“100”。如前所述，节点 1 准备执行合约。它被执行，并生成以下有效负载。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figb_HTML.png)这被发送到所有节点，节点
    2 将验证其正确性。由于它是正确的输出，因此可以发送到稳定存储。以下交易被记录。！[](../images/516210_1_En_5_Chapter/516210_1_En_5_Figc_HTML.png)
- en: 8 Discussion
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 讨论
- en: A reference model was proposed by Gill [[39](#CR39)], which incorporated blockchain,
    quantum computing, and serverless technology for IoT domain. A quantum integration
    for serverless domain was also proposed in [[40](#CR40)]. The architecture discussed
    in Sect. [7](#Sec14) has been created keeping in mind a generic use case, and
    has an inherent layered structure to it, like that in [[39](#CR39)]. In principle,
    it should be stable under dynamic loads. Kaplunovich et al. [[41](#CR41)] conducted
    a study using Hyperledger Fabric implemented on top of AWS SQS and Lambda, and
    found that even though the concept of serverless computing is supported, clouds
    had difficulty scaling up when it came to blockchain layers. This is since there
    is limited concurrency possible when updating chains. In order to manage it to
    the best extent, platforms like Amazon QLDB (Quantum Ledger Database), which is
    a fully managed and traceable solution outside blockchain, may be used. The proposed
    architecture is also designed to minimize the load on blockchain layer because
    of the following aspects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Gill提出了一个参考模型[[39](#CR39)]，其中结合了区块链、量子计算和无服务器技术，用于物联网领域。还在[[40](#CR40)]中提出了无服务器领域的量子整合。第 [7](#Sec14)节讨论的架构是针对一个通用用例而创建的，具有固有的分层结构，类似于[[39](#CR39)]中的那样。原则上，它应该在动态负载下保持稳定。
    Kaplunovich等人[[41](#CR41)]使用基于AWS SQS和Lambda的Hyperledger Fabric进行了研究，并发现即使支持无服务器计算的概念，云在涉及区块链层时很难扩展。这是因为在更新链时可能存在有限的并发性。为了尽可能地管理它，可以使用Amazon
    QLDB（量子分类数据库），这是一种在区块链之外完全受控且可追溯的解决方案。所提出的架构也旨在通过以下方面最小化对区块链层的负载。
- en: Blockchain is being used only as the logging utility. Data reads are non-existent
    during routine operation.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链仅被用作日志记录工具。在日常操作中不存在数据读取。
- en: All encryption and decryption are being managed at the load balancer level.
    No data access is required.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有加密和解密都在负载均衡器级别进行管理。不需要数据访问。
- en: Consensus is exclusively based on Proof of Stake, which is dependent solely
    on the incoming key and nonce.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识完全基于权益证明，这完全依赖于传入密钥和nonce。
- en: Xiaoqi et al. [[42](#CR42)] have conducted a detailed analysis on different
    security weaknesses in blockchains. The proposed architecture mitigates some of
    the identified weaknesses either inherently, or by design. Table [5](#Tab5) describes
    the measures taken and further opportunities available.Table 5
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Xiaoqi等人[[42](#CR42)]对区块链中不同安全弱点进行了详细分析。所提出的架构通过内在方式或设计方式缓解了一些已鉴定的弱点。表 [5](#Tab5)描述了采取的措施和进一步的机会。表5
- en: Security issues and their management in proposed solution
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在提出的解决方案中，安全问题及其管理
- en: '| Issue identified | Solution/Opportunity |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 鉴定的问题 | 解决方案/机会 |'
- en: '| --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 51% vulnerability | Handled because PoW is not used, and PoS uses stake values
    that are generated instantaneously using key and nonce |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 51%易受攻击性 | 因为没有使用PoW，而PoS使用即时生成的关键和nonce生成的权益值，因此已处理好。|'
- en: '| Private key security | Cloud-native key management systems can be used. Master
    key can be based on the key negotiated by QKD |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 私钥安全 | 可以使用云原生密钥管理系统。主密钥可以基于QKD协商的密钥 |'
- en: '| Criminal activity | Out of scope, since the domain of application is solely
    compute-based. As per shared responsibility principle, security in the cloud is
    the responsibility of the user |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 犯罪活动 | 超出范围，因为应用领域仅限于基于计算。根据共享责任原则，云安全由用户负责 |'
- en: '| Double spending | Can be safely ignored since double spending problem in
    serverless platform simply creates multiple copies of the same response payload
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 双重支付 | 由于无服务器平台中的双重支付问题只是创建相同响应有效负载的多个副本，因此可以安全地忽略 |'
- en: '| Transaction privacy leakage | No private information is saved. The log simply
    contains IP-level information |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 交易隐私泄露 | 不保存私人信息。日志只包含IP级别信息 |'
- en: '| Criminal smart contracts | Since transaction is computational in nature,
    criminal smart contracts can generate unwanted accesses to confidential data stored
    in remote locations. The user has to manually verify the contract occasionally.
    Since containers are used, it is difficult to spin up malicious code directly.
    But contract should be immune to injection attacks |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 犯罪智能合约 | 由于交易具有计算性质，犯罪智能合约可能会对存储在远程位置的机密数据生成不必要的访问。用户必须偶尔手动验证合约。由于使用了容器，直接启动恶意代码很困难。但合约应对注入攻击免疫
    |'
- en: '| Vulnerabilities in smart contract | Exceptions should be properly dealt with.
    Principle of shared responsibility applies here |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 智能合约中的漏洞 | 异常情况应得到妥善处理。共享责任原则在这里适用 |'
- en: '| Under-optimized smart contract | Developer should be responsible for creating
    optimized code. Proper budget alerts on the cloud platform will flag possible
    over-utilization of resources. Since serverless executions are ephemeral in nature,
    and last for a maximum of 15 min, poorly written code will lead to premature termination
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 未优化的智能合约 | 开发者应负责创建优化的代码。云平台上的适当预算警报将标记资源可能过度利用的情况。由于无服务器执行是短暂的，并且持续时间最长为15分钟，编写不良代码将导致过早终止
    |'
- en: '| Under-priced operations | Since no stake is transferred as part of operations,
    pricing is not a concern |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 低价操作 | 由于操作不涉及转移利益，因此定价不是问题 |'
- en: From both analysis, we can infer that the proposed architecture should be able
    to maintain scalability and security to a good extent when rolled out on serverless
    platforms.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个分析中，我们可以推断，当在无服务器平台上部署时，所提出的架构应该能够在很大程度上保持可扩展性和安全性。
- en: 9 Conclusion
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 结论
- en: With the advent of cloud computing, serverless execution has become a popular
    choice for application developers. It removes the overhead of infrastructure establishment,
    provisioning, and management from the hands of the developers by automating the
    provisioning and scaling process. But they suffer from security issues because
    of excessive automation, which is being mitigated with the help of blockchain.
    On adding blockchain to the mix, they have a potential reduction in scalability,
    which has been managed to a good extent by controlling which nodes are activated
    at each request. In addition, the layered architecture makes it easy to adapt
    to different types of workloads, keeping the concept of shared responsibility
    intact.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的出现，无服务器执行已成为应用开发人员的热门选择。它通过自动化提供和扩展过程，将基础设施的建立、配置和管理工作从开发人员手中解放出来，但由于过度自动化而遭受安全问题的困扰，这一问题正在借助区块链得到缓解。将区块链纳入其中，他们可能会在可扩展性上遭受潜在的减少，但通过控制每个请求时激活的节点，这一问题已得到很好的解决。此外，分层架构使其能够轻松适应不同类型的工作负载，保持了共享责任的概念完整性。
