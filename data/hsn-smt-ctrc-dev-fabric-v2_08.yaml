- en: Chapter 5\. Smart Contract Invocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 智能合约调用
- en: This chapter equips you with the knowledge you need to invoke smart contracts.
    We’ll use the prerequisites installed in [Chapter 4](ch04.xhtml#smart_contract_development).
    Then, using a script, we’ll start and stop a local Fabric test network and deploy
    the Fabcar smart contract.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供调用智能合约所需的知识。我们将使用在[第四章](ch04.xhtml#smart_contract_development)安装的先决条件。然后，使用脚本，我们将启动和停止本地Fabric测试网络并部署Fabcar智能合约。
- en: Since we are leveraging Fabcar and the Fabric test network, we start with a
    review of *fabric-samples*, the Fabcar smart contract, and the Fabric test network.
    We’ll then start our test network and deploy the Fabcar smart contract. Next,
    we’ll go through the steps executed by the script. Once our test network is up
    and running with the Fabcar smart contract deployed, we’ll invoke Fabcar smart
    contract functions. We’ll use the `peer invoke` command as well as a command-line
    Node.js application to execute a Fabcar smart contract function. The Node.js application
    will use the Fabric Client SDK for Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用Fabcar和Fabric测试网络，我们从回顾*fabric-samples*、Fabcar智能合约和Fabric测试网络开始。然后，我们将启动我们的测试网络并部署Fabcar智能合约。接下来，我们将详细介绍脚本执行的步骤。一旦我们的测试网络运行起来并部署了Fabcar智能合约，我们将调用Fabcar智能合约功能。我们将使用`peer
    invoke`命令以及命令行Node.js应用程序来执行Fabcar智能合约功能。Node.js应用程序将使用Fabric客户端SDK for Node.js。
- en: 'This chapter will help you achieve the following practical goals:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您实现以下实际目标：
- en: Invoking smart contracts via the command- line interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过命令行界面调用智能合约
- en: Evaluating transaction functions for queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估查询的事务函数
- en: Submitting transactions and query transaction history
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交交易和查询交易历史
- en: Creating and issuing an application contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和发行应用合约
- en: Overview of fabric-samples, Fabcar, and the Test Network
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fabric-samples、Fabcar和测试网络概述
- en: In this section, you’ll learn how to start, deploy, and invoke a smart contract
    on the Hyperledger Fabric test network. We’ll first look at the structure and
    components of *fabric-samples*. Then we’ll walk through the essential steps for
    deploying our sample smart contract, Fabcar. Once Fabric is set up and running,
    we will start invoking the Fabric smart contract through the `peer` command and
    Node.js methods. The Fabric test network is a great place for experimenting and
    running essential operations on smart contracts before moving your Fabric application
    to production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在Hyperledger Fabric测试网络上启动、部署和调用智能合约。我们首先看一下*fabric-samples*的结构和组件。然后，我们将详细介绍部署我们的示例智能合约Fabcar的基本步骤。一旦Fabric设置并运行，我们将通过`peer`命令和Node.js方法开始调用Fabric智能合约。Fabric测试网络是一个进行实验和在将您的Fabric应用程序移至生产之前运行智能合约的重要操作的好地方。
- en: fabric-samples
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fabric-samples
- en: Installing the prerequisites in [Chapter 4](ch04.xhtml#smart_contract_development)
    included *fabric-samples*, which is Hyperledger Fabric’s project for helping developers
    learn Fabric smart contract development. It contains many smart contract samples
    and tools for the rapid development of Fabric smart contracts. Included is a complete
    development Fabric network comprising two organizations. Each organization has
    a peer and CA. The network is containerized using Docker, which makes it easy
    and fast to launch and manage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](ch04.xhtml#smart_contract_development)安装先决条件时，包括了*fabric-samples*，这是超级账本
    Fabric 项目，旨在帮助开发者学习 Fabric 智能合约开发。它包含许多智能合约示例和用于快速开发 Fabric 智能合约的工具。其中包括一个完整的开发
    Fabric 网络，包括两个组织。每个组织都有一个对等方和 CA。网络使用 Docker 容器化，这使得启动和管理变得简单快捷。
- en: If you followed the instructions in [Chapter 4](ch04.xhtml#smart_contract_development)
    to install the prerequisites, you should have the *fabric-samples* directory.
    We will use the *bin*, *test-network*, *chaincode*, and *fabcar* subdirectories
    with this chapter and [Chapter 6](ch06.xhtml#testing_and_maintenance).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照[第四章](ch04.xhtml#smart_contract_development)中的说明安装了先决条件，您应该有*fabric-samples*目录。我们将在本章和[第六章](ch06.xhtml#testing_and_maintenance)中使用*bin*、*test-network*、*chaincode*和*fabcar*子目录。
- en: Hyperledger Fabric has shown firm support for *fabric-samples*. Fabric continues
    to introduce new functionality, improve existing code, and advance tools that
    together make *fabric-samples* the primary project for Hyperledger Fabric smart
    contract developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 超级账本 Fabric 坚定支持*fabric-samples*。Fabric 继续引入新功能，改进现有代码，并推进一起使*fabric-samples*成为超级账本
    Fabric 智能合约开发者的主要项目的工具。
- en: The *bin* subdirectory contains the `peer` executable, which we will use as
    the first method to invoke the Fabcar smart contract. The *chaincode* subdirectory
    contains the Fabcar smart contract, and the *fabcar* directory contains the command-line
    client for the Fabcar smart contract. We will use *test-network* to deploy the
    *fabcar* smart contract. Once the contract is deployed, we can invoke it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*bin*子目录包含`peer`可执行文件，我们将使用它作为调用 Fabcar 智能合约的第一种方法。*chaincode*子目录包含 Fabcar
    智能合约，而*fabcar*目录包含 Fabcar 智能合约的命令行客户端。我们将使用*test-network*部署*fabcar*智能合约。合约一旦部署完毕，我们就可以调用它。'
- en: In this chapter, we will launch a test network for Fabcar with the help of the
    *fabcar* script. Every Fabric smart contract needs a Fabric network. You can continue
    to advance your skills by leveraging the test network and apply what you learn
    in this chapter to the additional smart contracts in *fabric-samples*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用*fabcar*脚本的帮助启动 Fabcar 的测试网络。每个 Fabric 智能合约都需要一个 Fabric 网络。您可以通过利用测试网络来提高自己的技能，并将本章学到的应用到*fabric-samples*中的其他智能合约上。
- en: Fabcar
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabcar
- en: The Fabric smart contract, Fabcar, is one the earliest and simplest sample smart
    contracts in *fabric-samples*. It is great for learning the basics of Fabric smart
    contract operation and development. Getting hands-on with Fabric smart contract
    development is easy and fast with Fabcar because it is mature, stable, and simple
    in design, but fully functional. It implements the core functionality we need
    to understand and develop Fabric smart contracts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 智能合约 Fabcar 是 *fabric-samples* 中最早和最简单的样本智能合约之一。它非常适合学习 Fabric 智能合约操作和开发的基础知识。通过
    Fabcar，我们可以轻松快速地实践 Fabric 智能合约开发，因为它在设计上成熟、稳定且简单，但功能齐全。它实现了我们需要理解和开发 Fabric 智能合约的核心功能。
- en: Fabcar has two parts. The first part is the Fabcar smart contract, which we
    examined in [Chapter 4](ch04.xhtml#smart_contract_development). The other part
    is the Fabcar client. The client invokes the smart contract.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar 有两个部分。第一部分是 Fabcar 智能合约，我们在[第四章](ch04.xhtml#smart_contract_development)中对其进行了研究。另一部分是
    Fabcar 客户端。客户端调用智能合约。
- en: Fabcar client
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fabcar 客户端
- en: As you can see in [Figure 5-1](#fabcar_client_implementations), the Fabcar client
    has multiple implementations. We are interested in the JavaScript implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[图5-1](#fabcar_client_implementations)中所见，Fabcar 客户端有多种实现。我们对 JavaScript
    实现感兴趣。
- en: '![Fabcar client implementations](Images/HLF_0501.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar 客户端实现](Images/HLF_0501.png)'
- en: Figure 5-1\. Fabcar client implementations
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. Fabcar 客户端实现
- en: Provided are two shell scripts, *startFabric.sh* and *networkDown.sh,* to start
    and stop our Fabcar test network. The *startFabric.sh* script prepares and runs
    a new environment; then it deploys and initializes our Fabcar smart contract.
    The *networkDown.sh* script shuts down all Docker containers, removes them, and
    cleans up the environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两个 shell 脚本，*startFabric.sh* 和 *networkDown.sh*，用于启动和停止我们的 Fabcar 测试网络。*startFabric.sh*
    脚本准备并运行一个新环境；然后部署和初始化我们的 Fabcar 智能合约。*networkDown.sh* 脚本关闭所有 Docker 容器，删除它们，并清理环境。
- en: Warning
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When the Fabric network restarts, it typically cleans all of the data. If you
    need to persist any work that’s in a container that’s part of your Fabcar test
    network, you need to persist your data prior to starting or stopping the test
    network. Typically, you need to mount a volume for the directory */var/hyperledger/production*
    in the orderer and peer Docker containers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Fabric 网络重新启动时，通常会清除所有数据。如果您需要保留 Fabcar 测试网络中的任何容器中的工作，则需要在启动或停止测试网络之前持久化数据。通常，您需要为排序器和对等体
    Docker 容器中的目录 */var/hyperledger/production* 挂载卷。
- en: The Fabcar client is implemented as four Node.js command-line applications,
    highlighted in [Figure 5-2](#fabcar_nodedotjs_applications). Two of the applications,
    *enrollAdmin.js* and *registerUser.js,* handle enrolling an administrator and
    registering an application user. The other two Node.js applications, *invoke.js*
    and *query.js*, handle an invoke transaction and a query evaluation, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar 客户端实现为四个 Node.js 命令行应用程序，在 [图 5-2](#fabcar_nodedotjs_applications) 中有重点标出。其中两个应用程序，*enrollAdmin.js*
    和 *registerUser.js*，处理管理员注册和应用程序用户注册。另外两个 Node.js 应用程序，*invoke.js* 和 *query.js*，分别处理调用交易和查询评估。
- en: '![Fabcar Node.js applications](Images/HLF_0502.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar Node.js 应用程序](Images/HLF_0502.png)'
- en: Figure 5-2\. Fabcar Node.js applications
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. Fabcar Node.js 应用程序
- en: These are the four Node.js applications we will examine and execute to invoke
    the Fabcar smart contract. In [Chapter 6](ch06.xhtml#testing_and_maintenance),
    we will refactor and incorporate them into a new Node.js Express web application
    we develop, called Fabcar UI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们将要检查并执行以调用 **Fabcar** 智能合约的四个 Node.js 应用程序。在第 [6 章](ch06.xhtml#testing_and_maintenance)中，我们将重构并将它们整合到一个我们开发的新的
    Node.js Express web 应用程序中，称为 Fabcar UI。
- en: 'Fabric smart contract clients use a language-specific version of the Fabric
    Client SDK. Clients developed in JavaScript can use the [Fabric Client SDK for
    Node.js](https://github.com/hyperledger/fabric-sdk-node) to incorporate the Fabric
    smart contract functionality to authenticate, submit transactions, and evaluate
    queries. Because of these Node.js package dependencies from the *package.json*
    file, npm installs the four Node.js modules highlighted in [Figure 5-3](#fabcar_client_fabric_sdk_for_nodedotjs):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定语言版本的 Fabric 客户端 SDK 的 Fabric 智能合约客户端。用 JavaScript 开发的客户端可以使用 [Fabric 客户端
    SDK for Node.js](https://github.com/hyperledger/fabric-sdk-node) 来整合 Fabric 智能合约功能，进行身份验证、提交交易和评估查询。由于这些
    Node.js 包依赖关系来自 *package.json* 文件，npm 安装了 [图 5-3](#fabcar_client_fabric_sdk_for_nodedotjs)
    中突出显示的四个 Node.js 模块：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Fabcar client Fabric SDK for Node.js modules](Images/HLF_0503.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar 客户端 Fabric SDK for Node.js 模块](Images/HLF_0503.png)'
- en: Figure 5-3\. Fabcar client Fabric SDK for Node.js modules
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3. Fabcar 客户端 Fabric SDK for Node.js 模块
- en: The two packages we will directly use are *fabric-ca-client*, which handles
    the interaction with the authority to enroll, register, and administrate identities;
    and *fabric-network*, which provides `gateway`, `network` (channel), and `contract`
    objects to interact with the Fabric smart contract.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接使用的两个包是 *fabric-ca-client*，它处理与权威机构进行注册、注册和管理身份的交互；以及 *fabric-network*，它提供了
    `gateway`、`network`（通道）和 `contract` 对象来与 Fabric 智能合约交互。
- en: Fabcar smart contract
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Fabcar** 智能合约'
- en: The Fabcar smart contract, *fabcar.js*, like the client, is implemented in several
    languages; we discussed its implementation in [Chapter 4](ch04.xhtml#smart_contract_development).
    The *chaincode/fabcar/javascript* subdirectory with the *lib* subdirectory should
    be selected. The Fabcar smart contract that we will deploy and invoke in this
    chapter is in the *lib* subdirectory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**fabcar.js** 是一个 Fabcar 智能合约，和客户端一样，它也实现了多种语言；我们在[第 4 章](ch04.xhtml#smart_contract_development)讨论了它的实现。应选择带有
    *lib* 子目录的 *chaincode/fabcar/javascript* 子目录。本章我们将部署和调用的 Fabcar 智能合约位于 *lib* 子目录中。'
- en: 'The Node,js smart contract has dependencies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 智能合约有依赖关系：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two dependencies, *fabric-contract-api* and *fabric-shim*, result in
    the Node.js packages being imported into the project. Only one import is required
    for Fabric smart contracts, *fabcar.js*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个依赖项，**fabric-contract-api** 和 **fabric-shim**，导致了 Node.js 包被导入到项目中。对于 Fabric
    智能合约，只需要一个导入，即 *fabcar.js*：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The package *fabric-shim* is a low-level interface to the chaincode, and *fabric-shim-api*
    is used by both *fabric-shim* and *fabric-contract-api* to provide type definitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**fabric-shim** 包是一个提供给链码的低级接口，而**fabric-shim-api** 则被**fabric-shim** 和 **fabric-contract-api**
    共同使用，用于提供类型定义。'
- en: Fabric test network
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabric 测试网络
- en: The Fabric test network will launch a working Fabric network that can be used
    for smart contract deployment. The *network.sh* script is used indirectly when
    we use the Fabcar script, *startFabric.sh*, to start, and *networkDown.sh* to
    stop the test network. This script is modular and can be refactored into a set
    of granular tools, suitable to your workflow and style. It can also serve as a
    good example for learning how to develop a script or scripts to launch and manage
    your own custom Fabric network. For our development, it is a quick start and takes
    the pain out of designing, configuring, and managing all the resources required
    to implement a functional Fabric network.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 测试网络将启动一个可用的 Fabric 网络，用于智能合约的部署。当我们使用 Fabcar 脚本 *startFabric.sh* 启动和
    *networkDown.sh* 停止测试网络时，间接使用 *network.sh* 脚本。这个脚本是模块化的，可以重构为一系列细粒度的工具，适合你的工作流程和风格。它也可以作为一个很好的例子，学习如何开发脚本来启动和管理你自己的自定义
    Fabric 网络。对于我们开发来说，这是一个快速启动，减轻了设计、配置和管理实现功能性 Fabric 网络所需的所有资源的痛苦。
- en: Once you develop a production-ready smart contract, you can package and promote
    it to production. The process of deploying it is dependent on the network it is
    being deployed to. Each production network will be different, but the functioning
    of your smart contract will be consistent across each network. In [Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration),
    we discuss test networks for Hyperledger Fabric v2\. As applications grow in complexity,
    you will need to architect new custom networks to suit your specific requirements.
    The Fabric test network is a minimal network, but fully functional. It is designed
    with two organizations, and each runs a peer. Each organization has a CA to issue
    X.509 certificates to the members of the organization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开发了一个可以投入生产的智能合约，您可以将其打包并推广到生产环境中。部署的过程取决于要部署到的网络。每个生产网络都将不同，但您的智能合约的功能在每个网络上都是一致的。在
    [第 9 章](ch09.xhtml#hyperledger_fabric_vtwo_integration) 中，我们讨论了 Hyperledger Fabric
    v2 的测试网络。随着应用程序复杂性的增加，您将需要设计新的自定义网络来满足您的特定需求。Fabric 测试网络是一个最小化的网络，但是功能齐全。它设计有两个组织，每个都运行一个对等体。每个组织都有一个
    CA 来向组织成员发放 X.509 证书。
- en: Docker Container and CouchDB databases
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 容器和 CouchDB 数据库
- en: 'The test network configuration for Fabcar in the Docker Dashboard has the following
    servers running in Docker containers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Dashboard 中 Fabcar 的测试网络配置在 Docker 容器中运行以下服务器：
- en: '*ca_org2*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*ca_org2*'
- en: The credential authority for organization 2
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 2 的凭证机构
- en: '*ca_orderer*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*ca_orderer*'
- en: The credential authority for the network orderer
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 网络排序器的凭证机构
- en: '*ca_org1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*ca_org1*'
- en: The credential authority for organization 1
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 1 的凭证机构
- en: '*couchdb1*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*couchdb1*'
- en: The world state database for organization 2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 2 的世界状态数据库
- en: '*orderer.example.com*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*orderer.example.com*'
- en: The network order that creates blocks and sends them for commit
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建区块并将其发送以提交的网络排序器
- en: '*couchdb0*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*couchdb0*'
- en: The world state database for organization 1
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 1 的世界状态数据库
- en: '*peer0.org2.example.com*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*peer0.org2.example.com*'
- en: The peer for organization 2
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 2 的对等体
- en: '*peer0.org1.example.com*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*peer0.org1.example.com*'
- en: The peer for organization 1
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 1 的对等体
- en: The two top containers are the smart contract runtime containers for each organization’s
    peer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 两个顶级容器分别是每个组织对等体的智能合约运行时容器。
- en: 'The world state database for the organizations in our test network is CouchDB.
    We can access CouchDB with our browser by using the Fauxton web application, which
    is part of CouchDB. Open your browser and go to the following CouchDB URL: [*http://127.0.0.1:5984/_utils/*](http://127.0.0.1:5984/_utils/)#.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试网络中组织的世界状态数据库是 CouchDB。我们可以通过浏览器使用 CouchDB 的 Fauxton web 应用程序访问 CouchDB。打开您的浏览器并转到以下
    CouchDB URL：[*http://127.0.0.1:5984/_utils/*](http://127.0.0.1:5984/_utils/)。
- en: You will receive a page to log in to CouchDB. You can enter `**admin**` for
    username, and `**adminpw**` for the password, which are the defaults. These would
    be changed and secured with limited access in production, but for development,
    this works well. Also, the username and password will be part of network configurations
    and will be available in your *.yaml* file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到一个登录 CouchDB 的页面。您可以输入`**admin**`作为用户名，输入`**adminpw**`作为密码，这是默认设置。这些在生产环境中会被更改和限制访问以确保安全，但是在开发过程中，这很有效。此外，用户名和密码将成为网络配置的一部分，并且将在您的
    *.yaml* 文件中可用。
- en: After the login, you will receive the page displaying the *couchdb0* databases
    for organization 1\. The ninth row displays *mychannel_fabcar*. This is our Fabcar
    world state database. *mychannel* is the name of the Fabcar Fabric channel, and
    *fabcar* is the name of our chaincode.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将收到显示组织 1 的 *couchdb0* 数据库的页面。第九行显示 *mychannel_fabcar*。这是我们的 Fabcar 世界状态数据库。*mychannel*
    是 Fabcar Fabric 通道的名称，*fabcar* 是我们链代码的名称。
- en: Each CouchDB instance in our test network can be accessed by changing the port
    number in the URL to the port number displayed in the Docker Dashboard list of
    Fabric containers, which shows port 5984 is *couchdb0*, and port 7984 is *couchdb1*.
    So changing the port to `**7984**` in the CouchDB URL gives us access to *couchdb1,*
    the world state database for organization 2\. Notice they are identical, as they
    should be, since they represent the world state for Fabcar.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试网络中的每个 CouchDB 实例都可以通过更改 URL 中的端口号来访问。Docker 仪表板中 Fabric 容器列表显示端口 5984 是
    *couchdb0*，端口 7984 是 *couchdb1*。因此，在 CouchDB URL 中将端口更改为`**7984**`，我们可以访问 *couchdb1*，这是组织
    2 的世界状态数据库。请注意，它们是相同的，正如它们应该是的那样，因为它们代表了 Fabcar 的世界状态。
- en: 'Here is a summary of key takeaway points:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要点摘要：
- en: Every organization in a Fabric network can have one or multiple channels.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabric 网络中的每个组织都可以拥有一个或多个通道。
- en: Each channel will have a world state (like a database) per smart contract.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个通道将有一个世界状态（类似数据库）对应于智能合约。
- en: The world state database (and likely its contents) will be different for each
    channel.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个通道，世界状态数据库（及其内容）都将不同。
- en: Each instance of a smart contract will run simultaneously on all channels in
    a Fabric network.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个智能合约的实例将同时在 Fabric 网络中的所有通道上运行。
- en: Now that you understand the basics of *fabric-samples*, *fabcar*, and *test-network*,
    we’re ready to launch a Fabcar test network and deploy the Fabcar smart contract.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 *fabric-samples*、*fabcar* 和 *test-network* 的基础知识，我们准备启动一个 Fabcar 测试网络并部署
    Fabcar 智能合约。
- en: Deploying a Smart Contract
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署智能合约
- en: We need a Fabric network to deploy our Fabcar smart contract. For development,
    it is convenient to use *test-network,* part of *fabric-samples*. While you can
    execute *test-network*’s *network.sh* to start a default network, we use *startFabric.sh*
    to start *test-network* and *networkDown.sh* to stop *test-network*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 Fabric 网络来部署我们的 Fabcar 智能合约。对于开发来说，使用 *fabric-samples* 中的 *test-network*
    部分非常方便。虽然您可以执行 *test-network* 的 *network.sh* 来启动一个默认网络，但我们使用 *startFabric.sh*
    来启动 *test-network*，使用 *networkDown.sh* 来停止 *test-network*。
- en: When *startFabric.sh* is executed, the first thing it does, besides setting
    the default implementation language, is stop the network. This is to prevent runtime
    issues relating to resources and their runtime states.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 *startFabric.sh* 时，除了设置默认的实现语言之外，它的第一步是停止网络。这是为了防止与资源及其运行时状态相关的运行时问题。
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The test network has no persistence, and each execution brings up a new network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网络没有持久性，每次执行都会启动一个新的网络。
- en: Understand the startFabric.sh Anatomy
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 startFabric.sh 的结构
- en: 'Before we execute *startFabric.sh*, let’s examine it. The default implementation
    language is Go. This line from the script sets the default implementation to Go:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 *startFabric.sh* 之前，让我们先来看一下它。默认的实现语言是 Go。脚本中的这一行设置了默认的实现为 Go：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can choose another supported implementation language, like JavaScript,
    by supplying a supported argument as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供支持的参数来选择另一种支持的实现语言，比如 JavaScript，如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After setting the implementation language, run the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置实现语言之后，运行以下命令：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, all implementations have their *wallet* subdirectory contents
    removed. We will discuss wallets when we execute the Fabcar client applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，所有的实现都删除了它们的 *wallet* 子目录内容。在执行 Fabcar 客户端应用程序时，我们将讨论钱包。
- en: 'Finally, the script executes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本执行：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you see, *startFabric.sh* calls the *network.sh* script three times, supplying
    various arguments. The first call instructs *network.sh* to shut down the network.
    It does not matter if the network is not running; no errors are generated. It
    always runs and is a safety measure to ensure that a new error-free network is
    launched.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，*startFabric.sh* 调用 *network.sh* 脚本三次，并提供不同的参数。第一次调用指示 *network.sh* 关闭网络。如果网络未运行，也不会出错；它总是运行，并且是确保启动一个新的无错误网络的安全措施。
- en: The second execution, or `createChannel` command, brings up the network, creates
    a channel (network), and sets the world state database to CouchDB. After this
    command completes, the network is up and running.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次执行，或者 `createChannel` 命令，启动网络，创建一个通道（网络），并将世界状态数据库设置为 CouchDB。此命令完成后，网络就可以运行了。
- en: The third execution deploys the Fabcar chaincode (smart contract) to the network.
    The network provides many default *.sh* scripts—for example, the channel name,
    which is *mychannel*. Once completed, the Fabcar network is up and running, and
    our Fabcar smart contract is deployed and initialized.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次执行将Fabcar链码（智能合约）部署到网络中。网络提供许多默认的*.sh*脚本，例如通道名称为*mychannel*。完成后，Fabcar网络已启动运行，并且我们的Fabcar智能合约已部署和初始化。
- en: Execute startFabric.sh
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行startFabric.sh
- en: Now that we have looked at the *startFabric.sh* script and understand what it
    does, let’s execute it and briefly review the output. It’s verbose but informative,
    so becoming familiar with it will help us better understand what the *network.sh*
    script is accomplishing for us.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了*startFabric.sh*脚本并理解了它的作用，让我们执行它并简要审查输出。它很冗长但信息丰富，因此熟悉它将有助于我们更好地理解*network.sh*脚本为我们所完成的工作。
- en: 'Open a shell and make sure Docker is running. You can check whether Docker
    is running by executing the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个shell并确保Docker正在运行。您可以通过执行以下操作来检查Docker是否正在运行：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change to the *fabric-samples/fabcar* directory located where you installed
    the prerequisites described in [Chapter 4](ch04.xhtml#smart_contract_development)
    and execute this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到安装了[第四章](ch04.xhtml#smart_contract_development)中描述的先决条件的位置，并执行以下操作：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your console will begin scrolling text output and continue to completion. The
    script will take a few minutes to complete. Once it’s completed, you can save
    the text output for use and study. It contains the step-by-step sequence used
    to bring up the network. We are interested in the last command and the sequence
    of commands used to deploy the Fabcar smart contract.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的控制台将开始滚动文本输出并继续完成。该脚本将需要几分钟才能完成。完成后，您可以保存文本输出以供使用和学习。它包含用于启动网络的逐步序列。我们对最后一个命令和用于部署Fabcar智能合约的命令序列感兴趣。
- en: 'Before we look at the smart contract deployment, let’s take a quick look at
    the first part of the output, because it provides useful information, including
    the channel name and versions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看智能合约部署之前，让我们快速浏览一下输出的第一部分，因为它提供了有用的信息，包括通道名称和版本：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see our channel name is *mychannel*, and the Fabric version is 2.3.0, indicated
    by `LOCAL_VERSION` and `DOCKER_IMAGE_VERSION`. The credential authority is version
    1.4.9.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的通道名称是*mychannel*，Fabric版本是2.3.0，由`LOCAL_VERSION`和`DOCKER_IMAGE_VERSION`表示。凭证颁发机构的版本为1.4.9。
- en: Generate Fabric Certificate Authorities
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成Fabric证书颁发机构
- en: 'Next, we are informed the script is going to generate certificates for CAs,
    create the network, and create Docker containers for organization 1, organization
    2, and the orderer credential authorities (as shown in the following output).
    Credential authorities play an important role in managing identities for each
    organization and the orderer:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们被告知脚本将为CAs生成证书，创建网络，并为组织1、组织2和订单凭证颁发机构（如以下输出所示）创建Docker容器。凭证颁发机构在管理每个组织和订单者的身份方面起着重要作用：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we are informed that the script is going to create the identities for organization
    1\. This will take several commands to accomplish. The script repeats these steps
    for organization 2 and the orderer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们被告知脚本将为组织1创建身份。这将需要几个命令来完成。脚本为组织2和订购者重复这些步骤。
- en: Create Org1 Identities
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Org1 身份
- en: 'We can use this output to capture commands and have a record of their expected
    result. You can use a simple pattern to make this easy. First, the script employs
    descriptive and informative text to guide the reader. Second, the script commands
    are clearly identified by a leading `+` sign. For example, the following informative
    text tells us the action is to enroll the CA admin, and it is followed by the
    `+` character and command on the next line. The command to perform this action
    is `fabric-ca-client`. The command is followed by command output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个输出来捕捉命令并记录它们的预期结果。您可以使用一个简单的模式来实现这一点。首先，脚本使用描述性和信息性文本来引导读者。其次，脚本命令以前导的`+`符号清晰地标识出来。例如，以下信息性文本告诉我们，动作是注册
    CA 管理员，接着是`+`字符和下一行的命令。执行此操作的命令是`fabric-ca-client`。命令后跟着命令输出：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The commands the script executes, including `fabric-ca-client`, are contained
    in the *bin* subdirectory of *fabric-samples*. This means we can execute these
    commands by using this output as a model or guide. This pattern repeats for each
    command and group of commands. The script groups repeatable sequences; for example,
    we use a common sequence to create org1 identities, create org2 identities, and
    create orderer identities but supply different arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行的命令，包括`fabric-ca-client`，都包含在 *fabric-samples* 的 *bin* 子目录中。这意味着我们可以使用此输出作为模型或指南来执行这些命令。这种模式对于每个命令和命令组重复。脚本分组可重复的序列；例如，我们使用一个通用序列来创建
    org1 身份，创建 org2 身份和创建订购者身份，但提供不同的参数。
- en: Invoke the Peer Chaincode
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 Peer Chaincode
- en: 'We will discuss the smart contract deployment after we look at the last command
    executed by the script, which is `peer chaincode invoke`*.* We use this last command
    to initialize the Fabcar smart contract:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看脚本执行的最后一个命令之后，即`peer chaincode invoke`之后，我们将讨论智能合约部署。我们使用这个最后一个命令来初始化 Fabcar
    智能合约：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `peer` command has many subcommands, and one we are interested in is `peer
    chaincode invoke`. The `invoke` subcommand can invoke smart contract functions,
    which we will do shortly. The last parameter switch is `-c`. It is followed by
    an argument that designates the smart contract function to execute and any optional
    arguments. We will use this command as one method to invoke a smart contract transaction
    and evaluate a query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`peer`命令有许多子命令，我们感兴趣的一个是`peer chaincode invoke`。`invoke`子命令可以调用智能合约函数，我们很快将这样做。最后一个参数开关是`-c`。它后面跟着一个指定要执行的智能合约函数和任何可选参数的参数。我们将使用此命令作为调用智能合约事务和评估查询的一种方法。'
- en: Our primary purpose for this script is to start up our fully functional Fabric
    network, so we can develop Fabric smart contracts. The secondary purpose is to
    capture and leverage the script output. Toward this secondary purpose, we already
    have a command we can use to invoke our smart contract and query it. Next, we
    can leverage the script output’s smart contract deployment section by leveraging
    it in maintenance and testing, which we’ll discuss in [Chapter 6](ch06.xhtml#testing_and_maintenance).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们此脚本的主要目的是启动我们的完全功能的 Fabric 网络，以便我们可以开发 Fabric 智能合约。次要目的是捕获并利用脚本输出。为了实现这个次要目的，我们已经有一个命令可以用来调用我们的智能合约并查询它。接下来，我们可以利用脚本输出的智能合约部署部分，通过在维护和测试中利用它，我们将在[第
    6 章](ch06.xhtml#testing_and_maintenance)中讨论。
- en: When developing smart contracts, we want a fast iteration cycle. When we need
    to deploy or redeploy smart contracts repeatedly, starting and stopping the network
    will not work, so we need to customize the script and customize how we execute
    our deployment to facilitate fast iterations. Hyperledger Fabric v2 comes with
    external builders and launchers, which allow chaincodes to be deployed and executed
    independently ([Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration) covers
    this in more detail). First, we can examine the script output at the point where
    it deploys the smart contract, in order to capture the steps that show us how
    to deploy it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发智能合约时，我们希望有一个快速的迭代周期。当我们需要重复部署或重新部署智能合约时，启动和停止网络将不起作用，因此我们需要定制脚本并定制如何执行我们的部署以促进快速迭代。Hyperledger
    Fabric v2 配备了外部构建器和启动器，允许链码独立部署和执行（[第 9 章](ch09.xhtml#hyperledger_fabric_vtwo_integration)更详细地介绍了此内容）。首先，我们可以检查脚本输出部署智能合约的点，以捕获显示如何部署它的步骤。
- en: 'To locate the deployment section of the script output, go to the end of the
    output and scroll up to the beginning of the last command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到脚本输出的部署部分，请转到输出的末尾，向上滚动到最后一个命令的开头：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From there, scroll up until you see this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，向上滚动，直到看到这个：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the end of the script output’s deployment section. To locate the start
    of the script output’s deployment section, scroll up until you see this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本输出的部署部分的结尾。要找到脚本输出的部署部分的开头，请向上滚动，直到看到以下内容：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the beginning of the script output’s deployment section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本输出的部署部分的开头。
- en: 'In [Chapter 6](ch06.xhtml#testing_and_maintenance), we will look at the commands
    we need, and use the script output to help us deploy for maintenance and testing.
    Right now, let’s look at the six-step deployment sequence the script executed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.xhtml#testing_and_maintenance)中，我们将查看所需的命令，并使用脚本输出帮助我们进行维护和测试的部署。现在，让我们看一下脚本执行的六步部署顺序：
- en: Chaincode is packaged on *peer0.org1*
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*peer0.org1* 上已打包链码'
- en: Chaincode is installed on *peer0.org1*
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*peer0.org1* 上已安装链码'
- en: Chaincode is installed on *peer0.org2*
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*peer0.org2* 上已安装链码'
- en: Chaincode definition is approved on *peer0.org1* on channel *mychannel*
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*peer0.org1* 上的链码定义已获批准，通道为 *mychannel*'
- en: Chaincode definition is approved on *peer0.org2* on channel *mychannel*
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链码定义已经在通道*mychannel*上由*peer0.org2*批准。
- en: Chaincode definition is committed on channel *mychannel*
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链码定义已经提交到通道*mychannel*。
- en: 'These six steps are the required actions we need to perform to deploy our smart
    contracts so we can invoke them. We do not include the checks or queries the script
    executed because they are only informative on status. From the six actions, we
    can derive four groups of actions we need to execute for deployment:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个步骤是我们部署智能合约以便调用它们所必须执行的操作。我们不包括脚本执行的检查或查询，因为它们只是状态的信息。从这六个操作中，我们可以得出我们需要执行的四组部署操作：
- en: Package
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包
- en: Install
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装
- en: Approve
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批准
- en: Commit
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交
- en: We need to do the package action only once—in this case, on *peer0.org1*. We
    can then distribute the package as needed to organizations (*peer0.org2*). The
    install action must be executed for every peer that endorses. The approve action
    must be performed by all organizations as stated in policies, and the commit action
    is executed once but includes all organizations’ endorsing peers in the command.
    In [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl), we provide
    script files to execute all these commands.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需执行一次打包操作——在这种情况下，在*peer0.org1*上。然后，我们可以根据需要将包分发给组织（*peer0.org2*）。安装操作必须为每个背书节点执行。批准操作必须按照策略由所有组织执行，并且提交操作只执行一次，但在命令中包括所有组织的背书节点。在[第7章](ch07.xhtml#building_supply_chain_dapps_with_hyperl)中，我们提供了执行所有这些命令的脚本文件。
- en: With the successful completion of *startFabric.sh,* the Fabcar test network
    is up and running. You can generate this output anytime you need an example of
    a command or need to verify changes you may make.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过成功完成*startFabric.sh*，Fabcar测试网络已经启动运行。您可以随时生成此输出，以获取命令示例或验证可能进行的更改。
- en: Our Fabcar smart contract is deployed and initialized. The script executed a
    command that invoked Fabcar. We can also use the command to invoke Fabcar, which
    we will see next. But before we leave, we should appreciate the utility of this
    output. It maps out the commands and command responses for creating from scratch
    a Fabric network with an orderer; orderer credential authority; and two organizations,
    each with a peer, a database, and a credential authority. The *network.sh* script
    responsible for the output is a resource we can put to good use as our needs change.
    For now, all we need is provided by this script. It has launched our test network,
    deployed the Fabcar smart contract, and initialized it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Fabcar智能合约已部署并初始化。脚本执行了一个调用Fabcar的命令。我们还可以使用该命令来调用Fabcar，下面我们将看到。但在离开之前，我们应该赞赏此输出的效用。它映射了用于从头创建具有订购者、订购者凭证授权机构和两个组织（每个组织都有一个对等节点、一个数据库和一个凭证授权机构）的Fabric网络的命令和命令响应。负责该输出的*network.sh*脚本是一个资源，我们可以根据需要加以利用。目前，我们所需要的一切都由此脚本提供。它启动了我们的测试网络，部署了Fabcar智能合约并对其进行了初始化。
- en: We can now invoke the smart contract functions of Fabcar.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用Fabcar的智能合约函数。
- en: Invoking Smart Contract Transactions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用智能合约事务
- en: The `peer chaincode invoke` command is the first method we will look at and
    execute to invoke our Fabcar smart contract functions. The next method we will
    look at and use incorporates the Hyperledger Fabric SDK for Node.js, which can
    be used for developing smart contract clients.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`peer chaincode invoke`命令是我们将查看并执行以调用我们的 Fabcar 智能合约函数的第一种方法。我们将查看并使用下一种方法，其中包含可以用于开发智能合约客户端的
    Hyperledger Fabric SDK for Node.js。'
- en: By using the Hyperledger Fabric SDK for Node.js, you can develop both command-line
    Fabric smart contract clients, like Fabcar, and Fabric smart contract clients
    that incorporate a UI into the design of the Fabric smart contract client application.
    We discuss a UI version of the command-line Fabcar smart contract client in `[Chapter 6](ch06.xhtml#testing_and_maintenance)`.
    Let’s now look at and execute the `peer chaincode invoke` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Hyperledger Fabric SDK for Node.js，您可以开发命令行 Fabric 智能合约客户端，例如 Fabcar，以及将
    UI 合并到 Fabric 智能合约客户端应用程序设计中的 Fabric 智能合约客户端。我们在[第六章](ch06.xhtml#testing_and_maintenance)中讨论了命令行
    Fabcar 智能合约客户端的 UI 版本。现在让我们来看一下并执行`peer chaincode invoke`方法。
- en: Peer Command
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点命令
- en: 'The `peer` command is a Hyperledger Fabric core binary. When you installed
    the prerequisites, the *peer* binary along with several other binaries were downloaded
    and placed into the *bin* subdirectory of *fabric-samples*. This binary has five
    functions, or subcommands, it performs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`peer`命令是 Hyperledger Fabric 核心二进制文件。当您安装先决条件时，*peer*二进制文件以及其他几个二进制文件将被下载并放置在*fabric-samples*的*bin*子目录中。该二进制文件有五个功能或子命令，它执行：'
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `peer node` command is the subcommand used to function as a Fabric node
    or Fabric peer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`peer node`命令是用于充当 Fabric 节点或 Fabric 节点的子命令：'
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Examining *docker-compose-test-net.yaml* in the *docker* subdirectory of *test-network,*
    you see the startup command executed to start the node:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在*test-network*的*docker*子目录中检查*docker-compose-test-net.yaml*，您会看到执行启动节点的启动命令：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `peer` subcommand we are interested in is the `chaincode` subcommand. This
    subcommand also has several subcommands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的`peer`子命令是`chaincode`子命令。该子命令还有几个子命令：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We want to use the `invoke` subcommand. Some other `peer chaincode` subcommands
    were used in the script that launches the test network and can be found by searching
    the output text we saved from the launch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用`invoke`子命令。在启动测试网络的脚本中使用了其他一些`peer chaincode`子命令，并且可以通过搜索我们从启动时保存的输出文本找到。
- en: Using the `peer` command involves many parameters, so in a practice environment,
    we use variables to minimize the length of the resulting `peer` command-line text.
    We will use environment variables so we can execute `peer chaincode invoke` against
    our Fabcar test network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`peer`命令涉及许多参数，因此在实践环境中，我们使用变量来最小化生成的`peer`命令行文本的长度。我们将使用环境变量，以便我们可以针对我们的
    Fabcar 测试网络执行`peer chaincode invoke`。
- en: 'When we executed *startFabric.sh,* we were in the *fabric-samples/fabcar* subdirectory.
    The script executes a change directory command while saving the current directory,
    which is *fabric-samples/fabcar.* The script changes to *fabric-samples/test-network.*
    This makes *fabric-samples/test-network* the current directory for the execution
    of the script. This is important to us because we are going to reuse the `peer
    chaincode invoke` command from the script to execute our `invoke command`. For
    this to work, we need to open a shell and change the directory to *fabric-samples/test-network*.
    Then execute these export commands to configure your environment to find the *peer*
    binary in the *bin* subdirectory, the created *test-network* configuration in
    *fabric-samples/config*, and additional information `peer` needs to find in order
    to execute correctly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行*startFabric.sh*时，我们位于*fabric-samples/fabcar*子目录中。脚本执行了一个改变目录的命令，同时保存了当前目录，即*fabric-samples/fabcar*。脚本切换到*fabric-samples/test-network*。这使*fabric-samples/test-network*成为执行脚本的当前目录。这对我们很重要，因为我们将从脚本中重用`peer
    chaincode invoke`命令来执行我们的`invoke命令`。为了使其工作，我们需要打开一个 shell 并将目录更改为*fabric-samples/test-network*。然后执行这些导出命令以配置您的环境，以便在*bin*子目录中找到*peer*二进制文件，在*fabric-samples/config*中找到创建的*test-network*配置，并且`peer`需要找到的其他信息以正确执行：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you execute these, your environment is configured to execute `peer`. To
    test this, execute the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您执行了这些，您的环境就配置为执行`peer`。要测试这个，请执行以下操作：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Your versions may be different, but you should see a result like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您的版本可能不同，但您应该看到类似于这样的结果：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Locate the `peer chaincode invoke` command that initializes the Fabcar smart
    contract and copy it to your editor, so we can refactor it. Remember, it is at
    the last command executed in the launch script output and looks like this, except
    your paths will be different:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 定位初始化Fabcar智能合约的`peer chaincode invoke`命令，并将其复制到您的编辑器中，以便我们进行重构。请记住，它是在启动脚本输出中执行的最后一个命令，并且看起来像这样，除了您的路径将不同：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We want to modify the following text at the end of this command
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要修改此命令末尾的以下文本
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'into this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为这样：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure you delete the `--isInit` switch. Since we removed the command to
    be executed for initialization, it will fail and error, because this switch is
    informing the peer to perform an initialization.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确保删除`--isInit`开关。由于我们移除了初始化执行的命令，它会失败并报错，因为此开关是通知对等方执行初始化的。
- en: 'Once you modify the command text, it should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您修改了命令文本，它应该是这样的：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now copy the command to your shell and execute it. The output will look like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将命令复制到您的 shell 并执行它。输出将如下所示：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We just invoked the Fabcar smart contract. What we invoked was a query, which
    is a read transaction. When we invoke, we execute either a write or a read transaction.
    The read transactions are not committed to the ledger; only write transactions
    are committed, provided they get properly endorsed and validated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚调用了 Fabcar 智能合约。我们调用的是一个查询，即读取事务。当我们调用时，我们执行的是写入或读取事务。读取事务不会提交到总账上；只有写入事务会提交，前提是它们得到了正确的认可和验证。
- en: 'The Fabcar smart contract transaction we invoked was the `queryAllCars` transaction.
    Looking at *fabcar.js*, this Fabcar transaction is calling `getStateByRange` with
    the arguments set to an empty string. This will return all data for a specific
    car key, which we see in the result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的 Fabcar 智能合约事务是 `queryAllCars` 事务。查看 *fabcar.js*，这个 Fabcar 事务调用了 `getStateByRange`，参数设置为空字符串。这将返回特定汽车键的所有数据，我们在结果中看到了这一点：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember, the `ctx` object is the first argument passed to every smart contract
    transaction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`ctx` 对象是传递给每个智能合约事务的第一个参数。
- en: 'It provides access to the `stub` object, which instantiates a `ChaincodeStub`
    class (an implementation of `IChaincodeStub`), and the `clientIdentity` object,
    which instantiates a `ClientIdentity` class (which implements `IClientIdentity`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供对 `stub` 对象的访问，该对象实例化了一个 `ChaincodeStub` 类（`IChaincodeStub` 的实现），以及对 `clientIdentity`
    对象的访问，该对象实例化了一个 `ClientIdentity` 类（实现了 `IClientIdentity`）：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These two classes, `ChaincodeStub` and `ClientIdentity`, are part of the *fabric-shim*
    package, a Node.js module. We do not directly use the *fabric-shim* module, because
    we use the *fabric-contract-api* package, which provides the `Contract` object
    for our use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类，`ChaincodeStub` 和 `ClientIdentity`，是 *fabric-shim* 包的一部分，这是一个 Node.js 模块。我们不直接使用
    *fabric-shim* 模块，因为我们使用 *fabric-contract-api* 包，它为我们提供了 `Contract` 对象供我们使用：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Contract` object provides access to both `ChaincodeStub` and `ClientIdentity`
    via the `Context` object `ctx`, which all smart contract functions receive as
    their first argument. The `Contract` object also provides functions we can use
    as interceptors before and after an invoked transaction. We look at these in the
    next chapter, when we discuss maintenance and testing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contract` 对象通过 `Context` 对象 `ctx` 提供对 `ChaincodeStub` 和 `ClientIdentity` 的访问，所有智能合约函数都将其作为第一个参数接收。`Contract`
    对象还提供了我们可以在调用事务之前和之后使用的拦截器函数。在下一章中，我们将讨论维护和测试时会看到这些内容。'
- en: 'Now let’s use `peer chaincode invoke` to invoke a Fabcar write transaction.
    We can use the same command we used for the query. All we need to do is change
    the argument to the `-c` switch. Let’s execute `changeCarOwner`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `peer chaincode invoke` 来调用 Fabcar 写入事务。我们可以使用与查询相同的命令。我们所需要做的就是更改 `-c`
    开关的参数。让我们执行 `changeCarOwner`：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After you change the `-c` switch argument, you should have a command like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你改变 `-c` 开关参数后，你应该有这样的一个命令：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now execute it and see this for the result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行它并查看结果：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This shows the transaction executed successfully. Since we change the owner
    of `CAR0`, let’s check it with another query, but this time for specific data.
    Again using the same `peer` command, we just need to change the `-c` switch argument:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了事务成功执行。由于我们更改了`CAR0`的所有者，请让我们使用另一个查询再次检查它，但这次是针对特定数据。再次使用相同的`peer`命令，我们只需要更改`-c`开关参数：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After executing, you should see this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您应该看到这个：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It worked! We changed the owner. Later you will see how to get the history
    of transactions that are associated with the same key. The key for our write transaction,
    `changeCarOwner`, is `CAR0`. Remember, the ledger has two parts: the world state
    and the blockchain ledger (a file-based implementation of an immutable linked
    list, in simple terms). The world state is the current state of the blockchain
    for a given key. Our world state is implemented by CouchDB for our Fabcar test
    network.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们改变了所有者。稍后您将看到如何获取与同一键关联的交易历史记录。我们的写入事务`changeCarOwner`的键是`CAR0`。请记住，总账有两个部分：世界状态和区块链总账（简单来说，是不可变链接列表的基于文件的实现）。世界状态是给定键的区块链的当前状态。我们的世界状态由CouchDB为我们的Fabcar测试网络实现。
- en: 'We can see our change by using the CouchDB browser interface we discussed earlier
    in the chapter. Let’s view our change in the world state database. As we have
    already discussed accessing CouchDB earlier in this chapter, open your browser
    and log in to CouchDB with the username `**admin**` and password `**adminpw**`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用本章前面讨论的CouchDB浏览器界面来查看我们的更改。让我们在世界状态数据库中查看我们的更改。由于我们在本章前面已经讨论过访问CouchDB，打开您的浏览器并使用用户名`**admin**`和密码`**adminpw**`登录CouchDB：
- en: '[*http://127.0.0.1:5984/_utils/#login*](http://127.0.0.1:5984/_utils/#login)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[*http://127.0.0.1:5984/_utils/#login*](http://127.0.0.1:5984/_utils/#login)'
- en: 'Then go to this URL in CouchDB:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在CouchDB中转到此URL：
- en: '[*http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0*](http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[*http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0*](http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0)'
- en: You should see that the owner of `CAR0` is `Mark`, as displayed in [Figure 5-4](#carzero_record_in_couchdb).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`CAR0`的所有者是`Mark`，如[图5-4](#carzero_record_in_couchdb)中所示。
- en: '![CAR0 record in CouchDB](Images/HLF_0504.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![CouchDB中的CAR0记录](Images/HLF_0504.png)'
- en: Figure 5-4\. `CAR0` record in CouchDB
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-4。CouchDB中的`CAR0`记录
- en: We’ll use the `peer chaincode invoke` command for more advanced purposes in
    the next chapter. Now let’s look at the Fabcar client and see how it invokes the
    Fabcar smart contract.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章节中更深入地使用`peer chaincode invoke`命令进行更高级的目的。现在让我们看一下Fabcar客户端，看看它如何调用Fabcar智能合约。
- en: Fabric SDK for Node.js Command-Line Application
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js命令行应用程序的Fabric SDK
- en: 'In [Chapter 4](ch04.xhtml#smart_contract_development), we examined the Fabcar
    smart contract in depth. Now we are going to examine the Fabcar smart contract
    client and use it to invoke the contract. The Fabcar smart contract client, as
    discussed earlier in this chapter, is a group of four Node.js JavaScript command-line
    applications: *enrollAdmin.js, invoke.js, query.js,* and *registerUser.js*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.xhtml#smart_contract_development) 中，我们深入研究了 Fabcar 智能合约。现在，我们将研究
    Fabcar 智能合约客户端，并使用它来调用合约。如本章前面所述，Fabcar 智能合约客户端是四个 Node.js JavaScript 命令行应用程序的组合：*enrollAdmin.js,
    invoke.js, query.js,* 和 *registerUser.js*。
- en: 'We will execute each one and look at how they work to invoke the Fabcar smart
    contract. To begin, open a shell and change to the directory *fabric-samples/fabcar/javascript*.
    The Fabcar client is a Node.js command-line application, so we need to execute
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行每个模块，并查看它们如何工作来调用 Fabcar 智能合约。首先，打开一个 shell 并切换到目录 *fabric-samples/fabcar/javascript*。Fabcar
    客户端是一个 Node.js 命令行应用程序，因此我们需要执行以下操作：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This command will install project dependencies into our Fabcar project. When
    the command completes, you should have a *node_modules* subdirectory. This is
    where the dependencies listed here are placed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装项目依赖项到我们的 Fabcar 项目中。当命令完成时，您应该会有一个 *node_modules* 子目录。这是这里列出的依赖项放置的位置：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we look in the *node_modules* subdirectory for installed Fabric modules,
    we find the Fabric modules listed here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 *node_modules* 子目录中查找已安装的 Fabric 模块，我们会发现列在这里的 Fabric 模块：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These modules, which represent the Hyperledger Fabric SDK for Node.js, can be
    found in the [Fabric GitHub repo](https://github.com/hyperledger/fabric-sdk-node)
    *[fabric-sdk-node](https://github.com/hyperledger/fabric-sdk-node)*. The *fabric-protos*
    module implements the Protocol Buffers protocol, which is a binary encoded communication
    protocol. We don’t have to worry about this module, and we don’t directly use
    it. The *fabric-common* module contains code used by both *fabric-ca-client* and
    *fabric-network* modules. The *fabric-ca-client* module is used by the Fabcar
    client, but is not required for a Fabric smart contract client. You need to import
    and use *fabric-ca-client* only if your smart contract client needs to interact
    with Fabric CA to manage the life cycle of user certificates. This includes the
    ability to enroll, register, renew, and revoke users. If your smart contract client
    does not perform any of these functions, you do not need *fabric-ca-client*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块代表了 Hyperledger Fabric 的 Node.js SDK，可以在 [Fabric GitHub 仓库](https://github.com/hyperledger/fabric-sdk-node)
    *[fabric-sdk-node](https://github.com/hyperledger/fabric-sdk-node)* 中找到。*fabric-protos*
    模块实现了 Protocol Buffers 协议，这是一种二进制编码的通信协议。我们不必担心这个模块，也不直接使用它。*fabric-common* 模块包含
    *fabric-ca-client* 和 *fabric-network* 模块共同使用的代码。*fabric-ca-client* 模块被 Fabcar
    客户端使用，但对于 Fabric 智能合约客户端并非必需。只有当您的智能合约客户端需要与 Fabric CA 交互以管理用户证书的生命周期时，才需要导入和使用
    *fabric-ca-client*。这包括注册、注册、续订和撤销用户的能力。如果您的智能合约客户端不执行这些功能，则不需要 *fabric-ca-client*。
- en: The *fabric-network* module is the only Fabric module required for a Fabric
    smart contract client. It connects your client to the network, and provides the
    ability to invoke transactions including writing to the ledger, and querying the
    world state and ledger.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*fabric-network*模块是唯一需要的Fabric模块，用于Fabric智能合约客户端。它将您的客户端连接到网络，并提供了调用交易（包括写入分类账、查询世界状态和分类账）的能力。'
- en: 'Now that our dependencies are installed, we can perform the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的依赖已经安装好了，我们可以进行以下操作：
- en: Enroll our application administrator.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册我们的应用程序管理员。
- en: Register our application user.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册我们的应用用户。
- en: Invoke a write transaction.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个写入交易。
- en: Query the world state.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询世界状态。
- en: We first need to enroll an application admin to create an admin-level wallet.
    Then we can register users in an application with an assigned user wallet to secure
    network access.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要注册一个应用程序管理员来创建一个管理员级别的钱包。然后我们可以在应用程序中注册用户，并为其分配一个用户钱包，以确保网络访问的安全性。
- en: Enroll our application administrator
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册我们的应用程序管理员。
- en: 'To enroll our administrator, we execute the *enrollAdmin.js* application:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册我们的管理员，我们执行*enrollAdmin.js*应用程序：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see the following result:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can execute *registerUser.js* to register our user:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行*registerUser.js*来注册我们的用户：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! We can now invoke our smart contract by using the user identity we just
    registered. But first let’s look at what happened here. We need to understand
    what’s going on with these two applications to invoke transactions, because we
    use identities when we invoke our transactions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以使用刚刚注册的用户身份来调用我们的智能合约。但首先让我们看看这里发生了什么。我们需要了解这两个应用程序的情况，以便在调用交易时使用身份。
- en: 'The identities associate us with an organization as a member and permit us
    to perform transactions. Let’s start with the *enrollAdmin.js* application because
    it must be executed first. Open *enrollAdmin.js* in your editor. We are not going
    to parse every line but rather focus on the important ones. The imports are first:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 身份证明将我们与组织联系起来，成为成员并且允许我们执行交易。让我们首先执行*enrollAdmin.js*应用程序，因为它必须首先执行。在你的编辑器中打开*enrollAdmin.js*。我们不会逐行解析，而是专注于重要的部分。首先是导入：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can see the imports from *fabric-ca-client* and *fabric-network*. We import
    all of *fabric-ca-client* and only *Wallets* from *fabric-network*. This is a
    Node.js command-line application, so we have a `main` function that executes all
    the application logic. This will come in handy when we look at the Fabcar UI,
    which we ported Fabcar to. Now the main logic begins:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到从*fabric-ca-client*和*fabric-network*导入的内容。我们从*fabric-ca-client*中导入所有内容，只从*fabric-network*中导入*Wallets*。这是一个Node.js命令行应用程序，因此我们有一个`main`函数来执行所有应用逻辑。当我们看Fabcar
    UI时，这将派上用场，因为我们将Fabcar转移到了UI。现在主要逻辑开始了：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, the filesystem path to the connection profile for organization 1 is assembled
    and read. This path typically uses the *ccp-template.json* and *ccp-template.yaml*
    files as templates, passing organization name, peer port, CA port, and CA Privacy
    Enhanced Mail (PEM) certificates to generate organization connection files. [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl)
    discusses this in more detail. This defines the network configuration to the client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组织 1 的连接配置文件的文件系统路径被组装并读取。此路径通常使用 *ccp-template.json* 和 *ccp-template.yaml*
    文件作为模板，传递组织名称、对等端口、CA 端口和 CA Privacy Enhanced Mail (PEM) 证书以生成组织连接文件。[第 7 章](ch07.xhtml#building_supply_chain_dapps_with_hyperl)更详细地讨论了这一点。这将网络配置定义给客户端。
- en: Once the connection profile is loaded, the certificate authority info and certificate
    authority TLS certificate are set. Using the CA information and TLS certificate,
    the CA object is created. We are using self-signed certificates, so we set the
    `verify` parameter to `false`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载连接配置文件，将设置证书颁发机构信息和证书颁发机构 TLS 证书。使用 CA 信息和 TLS 证书，创建 CA 对象。我们使用自签名证书，因此将
    `verify` 参数设置为 `false`。
- en: 'After we have created our CA, we create our wallet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了我们的 CA 之后，我们创建了我们的钱包：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we create a path. The code is using the current path, which should be
    where our *fabric-samples/fabcar/javascript* subdirectory is located. The code
    appends to the path *wallet*. This is the *wallet* subdirectory in our *fabric-samples/fabcar/javascript*
    subdirectory. Using the full path as an argument to the `Wallets.newFileSystemWallet`
    function, we create a wallet object that we will use to store identities. Next,
    we check whether the *admin* is already enrolled:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个路径。代码正在使用当前路径，应该是我们的 *fabric-samples/fabcar/javascript* 子目录所在的位置。代码将
    *wallet* 追加到路径中。这是我们 *fabric-samples/fabcar/javascript* 子目录中 *wallet* 子目录。将完整路径作为
    `Wallets.newFileSystemWallet` 函数的参数，我们创建一个将用于存储身份的钱包对象。接下来，我们检查 *admin* 是否已经注册：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can enroll only once by design. If the admin is not enrolled, we continue
    and enroll the admin:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计只能注册一次。如果管理员尚未注册，我们将继续并注册管理员：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The CA we created is now used to execute the enroll function. We can see it
    takes the user ID and password for our `admin` as the `enrollmentID` and `enrollmentSecret`.
    Then we create an `x509Identity` object by using the enrollment object we just
    created. We are creating an `x509Identity` that contains the credentials—an object
    containing the certificate and private key, both of which were created and returned
    by the CA enroll function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 CA 现在用于执行注册函数。我们可以看到它将用户 ID 和密码作为 `admin` 的 `enrollmentID` 和 `enrollmentSecret`。然后，我们使用刚刚创建的注册对象创建了一个
    `x509Identity` 对象。我们正在创建一个包含凭据的 `x509Identity`——一个包含证书和私钥的对象，这两者都是由 CA 注册函数创建并返回的。
- en: Along with the credentials, we add object metadata that identifies the organization
    this identity belongs to and the type of identity. Here `x509Identity` indicates
    a certificate containing a public key paired with a private key. With the identity
    created, we pass it to the wallet we created, which will store it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了凭证之外，我们还添加了标识该身份所属组织和身份类型的对象元数据。这里的 `x509Identity` 表示包含与私钥配对的公钥的证书。创建了身份后，我们将其传递给我们创建的钱包，该钱包将其存储。
- en: You should see a file called *admin.id* in the *wallet* subdirectory. If you
    view it, you can see the data structure we just went over. This is it for the
    *enrollAdmin.js* application. Its purpose is to enroll the admin. To accomplish
    this, it requires a CA and a wallet. The CA comes from *fabric-ca-client*, and
    the wallet comes from *fabric-network*. This sequence is specific to the admin.
    Now let’s look at *registerUser.js* and see what’s different.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 *wallet* 子目录中看到一个名为 *admin.id* 的文件。如果你查看它，你可以看到我们刚刚讨论过的数据结构。这就是 *enrollAdmin.js*
    应用程序的全部内容。它的目的是注册管理员。为了实现这一点，它需要一个 CA 和一个钱包。CA 来自 *fabric-ca-client*，钱包来自 *fabric-network*。这个顺序是特定于管理员的。现在让我们看看
    *registerUser.js* 有什么不同。
- en: Register our application user
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册我们的应用用户。
- en: 'The beginning of *registerUser.js* contains the same imports as *enrollAdmin.js*,
    but in a different order, which does not matter. Like *enrollAdmin.js,* its logic
    is contained in a `main` function. The `main` logic starts off as in *enrollAdmin.js,*
    loading the network configuration, creating the certificate authority, and creating
    a wallet. We can see a pattern:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*registerUser.js* 的开头包含与 *enrollAdmin.js* 相同的导入，但顺序不同，这没关系。像 *enrollAdmin.js*
    一样，它的逻辑包含在一个 `main` 函数中。`main` 逻辑开始与 *enrollAdmin.js* 相同，加载网络配置，创建证书颁发机构和创建钱包。我们可以看到一个模式：'
- en: Load the network configuration.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载网络配置。
- en: Create the certificate authority.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建证书颁发机构。
- en: Create the wallet.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建钱包。
- en: 'What then follows is a check to determine whether the user has an identity
    in the wallet, which indicates the user is already registered and enrolled:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后跟随的是检查，以确定用户是否在钱包中拥有身份，这表明用户已经注册和注册：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We return if the user is already in the wallet. This will happen if you execute
    *startFabric.sh* and the *wallet* subdirectory contains these identities. At this
    point, these identities do not exist in the Fabcar test network. The Fabcar application
    is not designed for multiple enrollments by a user. When this happens, you need
    to delete the contents of the *wallet* subdirectory and try the client again.
    The *wallet* subdirectory is then checked for the `admin` identity, which should
    exist because we always execute *enrollAdmin.js* first. If the `admin` is not
    found*,* we return. At this point in the code, *registerUser.js* and *enrollAdmin.js*
    differ. They differ because building the identity for the user differs from building
    the admin identity.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经在钱包中，我们就返回。如果你执行*startFabric.sh*并且*钱包*子目录包含这些身份，就会发生这种情况。此时，这些身份在Fabcar测试网络中并不存在。Fabcar应用程序不适用于用户的多次注册。当发生这种情况时，你需要删除*钱包*子目录的内容，然后再次尝试客户端。接下来，我们检查*钱包*子目录中的`admin`身份，因为我们总是首先执行*enrollAdmin.js*。如果没有找到`admin`，我们就返回。在代码的这一点上，*registerUser.js*和*enrollAdmin.js*不同。它们不同是因为构建用户的身份与构建管理员身份不同。
- en: 'To build the user identity, we begin by using *wallet* to get a `provider`
    of the `x509` type and use it to create a `User` object from the `admin` identity.
    We will use this identity to authenticate to the CA when we register our application
    user:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建用户身份，我们首先使用*钱包*来获取`x509`类型的`提供者`，并使用它从`admin`身份创建一个`用户`对象。我们将使用这个身份来在注册我们的应用用户时向CA进行身份验证：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next we register our application user with the CA, providing our organization,
    our ID, and our role. We supply the `admin` user we created with the `x509 provider`.
    The CA registers our application user and returns an enrollment secret:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用CA注册我们的应用用户，提供我们的组织、我们的ID和我们的角色。我们提供了通过`x509提供者`创建的`admin`用户。CA注册我们的应用用户，并返回一个注册密钥：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: From this point on, the logic is the same as in *enrollAdmin.js,,* except *enrollAdmin.js*
    used the admin password for the enrollment secret, and *registerUser.js* will
    use the secret we got back from the CA when we registered using the admin user
    to authenticate to the certificate authority. Therefore, we need the admin identity
    because it is used to register users. The application user secret is like a password,
    except the user will not know it and does not care to know. They have an identity,
    which in this implementation is type `x509`, and it is stored in the wallet, which
    is a filesystem-based store. We are now ready to execute *invoke.js* and then
    *query.js* and compare the two.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，逻辑与*enrollAdmin.js*中相同，只是*enrollAdmin.js*使用管理员密码作为注册证书的密钥，而*registerUser.js*将使用我们在使用管理员用户注册时从CA获得的密钥来进行身份验证。因此，我们需要管理员身份，因为它用于注册用户。应用用户密钥就像密码一样，只是用户不会知道它，也不需要知道。他们有一个身份，在这个实现中是`x509`类型，并且存储在钱包中，这是一个基于文件系统的存储。现在我们可以执行*invoke.js*，然后执行*query.js*并比较两者。
- en: Invoke a write transaction
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用写事务
- en: 'The *invoke.js* application has a main function, and all logic is contained
    within the main function. The application imports from only *fabric-network*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*invoke.js* 应用程序有一个主函数，所有逻辑都包含在主函数中。该应用程序仅从 *fabric-network* 导入：'
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This means it requires no interaction with the CA to invoke transactions. Like
    *enrollAdmin.js* and *registerUser.js,* it too makes use of *Wallets* from *fabric-network*.
    This makes sense because we need an identity to submit requests to the network,
    and identities for a client are stored in a *wallet*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不需要与 CA 交互来调用事务。像 *enrollAdmin.js* 和 *registerUser.js* 一样，它也利用了 *fabric-network*
    中的 *Wallets*。这是有道理的，因为我们需要一个身份来向网络提交请求，而客户端的身份存储在 *wallet* 中。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A user can have several identities, each with a unique name and purpose, like
    a driver’s license, school ID, passport, and so forth.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以拥有多个身份，每个身份都有唯一的名称和用途，就像驾驶执照、学生证、护照等等。
- en: The `Gateway` from *fabric-network* is our means to connect to the network,
    as we will see shortly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 *fabric-network* 的 `Gateway` 是我们连接到网络的手段，我们很快就会看到。
- en: 'The logic begins with familiar-looking code we saw in *enrollAdmin.js* and
    *registerUser.js* to load the network configuration, which contains the information
    for connecting to the network, creating the wallet, and checking for an identity.
    We are seeing boilerplate code here that cross-cuts applications and is something
    we would want to pull out and place in common code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑从我们在 *enrollAdmin.js* 和 *registerUser.js* 中看到的熟悉代码开始加载网络配置，该配置包含了连接到网络、创建钱包和检查身份的信息。我们在这里看到的是贯穿应用程序的样板代码，这是我们希望提取并放置在公共代码中的内容：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need the user identity to exist so the gateway can find it, if it does not
    we return. To connect to the network, we use the `Gateway` we imported from *fabric-network*
    to create a `gateway` object and use it to connect. The arguments we pass to the
    `connect` function are the connection information, the wallet, the name of the
    identity to use, and some discovery options used to locate peers:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用户身份存在，以便网关可以找到它，如果不存在，我们就返回。要连接到网络，我们使用从 *fabric-network* 导入的 `Gateway`
    来创建一个 `gateway` 对象，并使用它来连接。我们传递给 `connect` 函数的参数是连接信息、钱包、要使用的身份名称以及用于定位对等方的一些发现选项：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After connecting, we use the gateway to get the network, which is our channel
    identified by our channel name:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，我们使用网关获取网络，这是由我们的通道名称标识的通道：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the `network` object, we get a connection to our Fabcar smart contract:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `network` 对象，我们获得了与 Fabcar 智能合约的连接：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we get to invoke our smart contract. We are performing a transaction
    that will change the ledger, so this is a write transaction, and we expect it
    to be committed. The `contract` API function we want to use is `submitTransaction`.
    This will call our `createCar` smart contract function with these arguments:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始调用我们的智能合约。我们正在执行一个将更改分类帐的事务，因此这是一个写事务，并且我们希望它被提交。我们要使用的 `contract` API
    函数是 `submitTransaction`。这将使用以下参数调用我们的 `createCar` 智能合约函数：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, we invoke our smart contract indirectly through the `contract`
    API. This design pattern is powerful but also risky if mitigations are not implemented
    to prevent unwanted side effects from unexpected character or binary data. The
    best industry practices should be implemented to validate and protect data integrity.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过`contract` API间接调用智能合约。这种设计模式非常强大，但如果不实施措施来防止由于意外字符或二进制数据而导致的意外副作用，就会带来风险。应该实施最佳的行业实践来验证和保护数据完整性。
- en: 'At the end, the gateway is disconnected, and the application exits:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，网关断开连接，应用程序退出：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now let’s execute *invoke.js:*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行*invoke.js*：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Did you notice the time to process and return? There is a large difference in
    the processing time to commit versus query, as we will see next when we execute
    *query.js* and return the results of our committed transaction, which created
    a new car.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到处理和返回的时间了吗？提交与查询的处理时间有很大的差异，下一步当我们执行*query.js*并返回我们提交的事务结果时，我们会看到这一点，这个事务创建了一辆新的汽车。
- en: Query the world state
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询世界状态
- en: 'Let’s execute *query.js* and compare its logic to *invoke.js* to see any differences
    and commonalities between them:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行*query.js*，比较它的逻辑与*invoke.js*，看看它们之间的差异和共性：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should see the following result:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Can you find the car we created, `CAR12`? It’s the third one right after `CAR1`.
    Great, our `submitTransaction` was committed. If we looked in CouchDB, we would
    see this data in our world state database: *mychannel_fabcar*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到我们创建的汽车，`CAR12`吗？它是在`CAR1`之后的第三辆。太好了，我们的`submitTransaction`已经提交。如果我们查看CouchDB，我们会在我们的世界状态数据库*mychannel_fabcar*中看到这些数据。
- en: 'Let’s look at the code. The code is the same except for the contract API function
    called:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码。代码是一样的，只是调用的合约API函数不同：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For the query, we use `evaluateTransaction` because a query transaction is not
    committed to the ledger. A query does not follow the same processing path as a
    write transaction, which will use `submitTransaction`, so the transaction is processed
    for committing to the ledger.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查询，我们使用`evaluateTransaction`，因为查询事务不会提交到总账。查询不遵循与写入事务相同的处理路径，后者将使用`submitTransaction`，因此该事务将被处理以提交到总账。
- en: Did you notice the difference in processing speed compared to *invoke.js*? Queries
    are much faster and can get cached, making them even faster because they do not
    access the database. Writes are much longer and may never be committed. As a Fabric
    smart contract developer, you will need to design for this long latency and for
    no guarantee of being committed. In [Chapter 6](ch06.xhtml#testing_and_maintenance),
    we will look at how events can help with these operating constraints.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到与*invoke.js*相比的处理速度的差异了吗？查询要快得多，并且可以被缓存，使它们变得更快，因为它们不访问数据库。写入时间要长得多，甚至可能永远不会提交。作为一个Fabric智能合约开发者，你需要为这种长时间的延迟和不确定性进行设计。在[第六章](ch06.xhtml#testing_and_maintenance)中，我们将看到事件如何帮助解决这些运行约束。
- en: We have executed the four applications that make up the Fabcar smart contract
    client. We saw the differences and common code they use. Each performs one application
    function, and has dependencies that determine the order they are executed. You
    learned we need to first enroll an application administrator, and then use the
    administrator to register and enroll application users. Once we have a user identity,
    we can submit transactions to commit data to the ledger and query the world state.
    These applications serve as good examples for solutions that are best implemented
    with a command-line application, like batch jobs or serverless commands.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经执行了组成 Fabcar 智能合约客户端的四个应用程序。我们看到了它们使用的不同和相同的代码。每个应用程序执行一个应用功能，并且具有确定其执行顺序的依赖关系。您学到了我们需要首先注册一个应用程序管理员，然后使用管理员注册和登录应用程序用户。一旦我们拥有了用户身份，我们就可以提交交易以将数据提交到分类账并查询世界状态。这些应用程序是用命令行应用程序（如批处理作业或无服务器命令）实现最佳的解决方案的良好示例。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to invoke a Fabric smart contract. We began
    with a review of the Hyperledger *fabric-samples*, Fabcar smart contract, and
    Fabric test network. This provided you with the background needed to understand
    the resources used for this chapter and the next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何调用 Fabric 智能合约。我们从回顾 Hyperledger *fabric-samples*、Fabcar 智能合约和 Fabric
    测试网络开始。这为你提供了理解本章和下一章所使用的资源所需的背景知识。
- en: We then launched our Fabric test network and discussed the launch script and
    its output to gain an understanding of what it takes to stand up a Fabric network
    for developing Fabric smart contracts. Besides launching the test network, the
    script also deployed the Fabcar smart contract. We went through the steps used
    by the script to deploy a smart contract, which will help you to understand and
    perform the deployment task for your own smart contracts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动了我们的 Fabric 测试网络，并讨论了启动脚本及其输出，以了解为开发 Fabric 智能合约建立 Fabric 网络需要哪些工作。除了启动测试网络外，该脚本还部署了
    Fabcar 智能合约。我们详细讨论了脚本用于部署智能合约的步骤，这将帮助您理解并执行自己智能合约的部署任务。
- en: Next, we executed each of the four Fabcar client’s Node.js command-line applications
    that together make up the Fabcar smart contract client. At the same time, we examined
    each Fabcar application’s code, noting the common code and differences in the
    applications, and their use of the Fabric SDK for Node.js. The Fabcar applications
    use the SDK to call the Fabric APIs for interacting with Fabric smart contracts,
    credential authorities, wallets, and invoking smart contracts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行了组成 Fabcar 智能合约客户端的四个 Fabcar 客户端的 Node.js 命令行应用程序。与此同时，我们检查了每个 Fabcar
    应用程序的代码，注意了应用程序中的通用代码和差异，以及它们对 Fabric SDK for Node.js 的使用。Fabcar 应用程序使用 SDK 调用
    Fabric API 与 Fabric 智能合约、凭证机构、钱包和调用智能合约进行交互。
- en: In the next chapter, we will take these four applications and refactor them
    into Node.js modules we can import into a Node.js and Express.js web application
    called Fabcar UI. This application mirrors the functionality of the four command-line
    Fabcar applications, but with a UI. You’ll continue to learn more about the Fabric
    SDK for Node.js and the API available to Fabric smart contract developers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这四个应用程序重构成可以导入到一个名为 Fabcar UI 的 Node.js 和 Express.js Web 应用程序中的 Node.js
    模块。该应用程序反映了四个命令行 Fabcar 应用程序的功能，但带有用户界面。您将继续学习有关 Fabric SDK for Node.js 和可用于 Fabric
    智能合约开发人员的 API 的更多信息。
