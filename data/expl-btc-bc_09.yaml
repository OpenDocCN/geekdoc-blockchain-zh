- en: '[CHAPTER 7](toc.xhtml#c07)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第7章](toc.xhtml#c07)'
- en: '[Node Communication](toc.xhtml#c07)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[节点通信](toc.xhtml#c07)'
- en: In the previous chapter, you learned about the structure of data stored at the
    nodes and their method of verification, creation, and versioning. In this chapter,
    we are investigating communication between nodes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了节点存储的数据结构以及它们的验证、创建和版本化方法。在本章中，我们研究节点之间的通信。
- en: The Bitcoin network is a peer-to-peer network where there is no master or server
    and no slave or client. To establish communication, a TCP connection is established,
    which is based on the server-client model. Once a connection is established, there
    is no difference for a node if it initiated a connection or accepted a connection
    request. Once the TCP connection is established, the Bitcoin network connection
    needs to be established. The Bitcoin network is a very democratic network, and
    nodes can choose their peers. The decision depends on the version or services
    the peer is going to offer. Once both sides agree, the connection is established,
    and they can then exchange information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络是一个点对点的网络，其中没有主服务器或客户端，也没有从服务器或奴隶。为了建立通信，需要建立一个基于服务器-客户端模型的TCP连接。一旦建立了连接，节点就无法区分是它发起的连接还是接受了连接请求。一旦建立了TCP连接，就需要建立比特币网络连接。比特币网络是一个非常民主的网络，节点可以选择它们的同伴。这个决定取决于对等方将要提供的版本或服务。一旦双方达成一致，连接就建立起来了，然后它们就可以交换信息了。
- en: There are nearly 10,000 known active nodes at almost any time, which is enough
    to allow most nodes to find and choose multiple suitable peers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候几乎都有近10,000个已知活跃节点，这足以允许大多数节点找到并选择多个合适的同伴。
- en: Being an open peer-to-peer network, each node relies on its peers to get information
    about other available peers so that it can connect with them too. It also needs
    to broadcast transactions and blocks and help propagate them across the network.
    Additionally, it needs to keep itself in sync with the network, which translates
    to having the blockchain updated with the latest blocks and mempool with the latest
    transactions. And it needs to verify transactions and blocks and help SPVs verify
    transactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开放的点对点网络，每个节点都依赖其同伴获取有关其他可用同伴的信息，以便它也可以与它们建立连接。它还需要广播交易和区块，并帮助它们在网络上传播。此外，它还需要与网络保持同步，这意味着拥有带有最新块的最新区块链和带有最新交易的最新内存池。它还需要验证交易和区块，并帮助SPV验证交易。
- en: In this chapter, you will understand the Bitcoin network topology, network nodes,
    and detailed information about how these nodes communicate with each other.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解比特币网络拓扑、网络节点以及这些节点之间如何进行详细通信的信息。
- en: '[Structure](toc.xhtml#s129a)'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s129a)'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Bitcoin network topology
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币网络拓扑
- en: Node bootstrapping
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点引导
- en: Network messaging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络消息传递
- en: Message format
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息格式
- en: Establishing connection
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立连接
- en: Disconnecting with inactive peer
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不活跃的对等体断开连接
- en: Node discovery
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点发现
- en: Receiving full blockchain
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收完整区块链
- en: Synchronizing blockchain
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步区块链
- en: Transaction broadcasting
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易广播
- en: Block broadcasting
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块广播
- en: Unsolicited Block Push
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无请求的区块推送
- en: Direct Headers Announcements
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接头部公告
- en: Compact Block Announcements
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑区块公告
- en: '![](images/ent.jpg) High Bandwidth Compact Block Announcements'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![](images/ent.jpg) 高带宽紧凑区块公告'
- en: '![](images/ent.jpg) Low Bandwidth Compact Block Announcements'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![](images/ent.jpg) 低带宽紧凑区块公告'
- en: '[Objectives](toc.xhtml#s130a)'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[目标](toc.xhtml#s130a)'
- en: The objective of this chapter is to help you learn about the Bitcoin network,
    which includes network topology and node communication as well as the progression
    of protocol messages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您了解比特币网络，包括网络拓扑和节点通信以及协议消息的进展。
- en: In this chapter, you will learn about the different types of nodes and their
    role in the Bitcoin network. You will learn about the mechanism by which each
    node discovers other nodes. You will also understand how to create and establish
    a connection with other nodes and exchange protocol messages. Plus, you will understand
    the different types of payload that protocol messages carry, their purpose, and
    the expected sequence of message types. Further on in the chapter, we will discuss
    node versions and their role in establishing connection and communication with
    peers, and you will understand connection termination.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到比特币网络中不同类型节点的角色。你将了解到每个节点如何发现其他节点的方法。你还将理解如何与其他节点创建和建立连接以及交换协议消息。此外，你将了解协议消息携带的不同类型的有效载荷、它们的目的以及消息类型的预期序列。在本章的后面部分，我们将讨论节点版本及其在建立与对等节点连接和通信中的作用，并且你将理解连接终止。
- en: '[Bitcoin network topology](toc.xhtml#s131a)'
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[比特币网络拓扑](toc.xhtml#s131a)'
- en: The Bitcoin network allows nodes running different versions of code to communicate
    and find peers who are fine with their version and the services they offer or
    request. For instance, a node may be an SPV and may need to communicate with only
    full nodes. A full node may not be interested in connection with SPV and so, may
    be disconnected. The following figure shows how the nodes are distributed. We
    can see that most nodes are in the US and Germany.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络允许运行不同版本代码的节点进行通信并找到与他们版本和服务提供或请求相匹配的对等节点。例如，一个节点可能是一个SPV，并且只需要与全节点通信。一个全节点可能对与SPV的连接不感兴趣，所以可能会断开连接。以下图表显示了节点的分布情况。我们可以看到，大多数节点位于美国和德国。
- en: '![](images/Figure-7.1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.1.jpg)'
- en: '**Figure 7.1:** Illustration of global node distribution'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.1:** 全球节点分布的说明'
- en: 'A Bitcoin node establishes a connection with its peer using a TCP handshake.
    It can have IPv4 or IPv6 IP Addresses. A node can even connect with its peer on
    the Tor network, which is an anonymous network and protects the node against surveillance
    and tracking. If we are running Tor in our system at port 9050, then our node
    can connect or accept connection using the Tor network with the following command-line
    option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个比特币节点使用TCP握手与其对等节点建立连接。它可以有IPv4或IPv6 IP地址。节点甚至可以连接到Tor网络上的对等节点，Tor是一个匿名网络，可以保护节点免受监视和追踪。如果我们在我们系统中运行Tor，端口为9050，那么我们的节点可以使用以下命令行选项通过Tor网络连接或接受连接：
- en: '`-proxy=127.0.0.1:9050`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`-proxy=127.0.0.1:9050`'
- en: 'The following chart shows the distribution of Bitcoin network connections based
    on the connection type and the address type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了基于连接类型和地址类型比特币网络连接的分布：
- en: '![](images/Figure-7.2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.2.jpg)'
- en: '**Figure 7.2:** Chart showing the distribution of nodes based on connection
    type and address type'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.2:** 显示基于连接类型和地址类型节点分布的图表'
- en: 'We have different kind of nodes in the network, some of which are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在网络中有不同类型的节点，其中一些如下：
- en: A Full node with complete blockchain, which is also called archival node.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个拥有完整区块链的全节点，也称为归档节点。
- en: A Full node verifies all the blocks but does not maintain the full blockchain.
    It is still full node because, by definition, full node verifies the full blockchain,
    which this node does. These are also called pruned nodes.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全节点验证所有区块，但不会维护完整的区块链。它仍然被称为全节点，因为，按定义，全节点验证完整的区块链，这个节点确实做到了。这些也被称为修剪节点。
- en: A SPV node maintains a chain of block headers with only the required transactions.
    It needs to talk to full nodes, which can help it verify blocks, but since it
    does not verify blocks themselves, they also do not relay transactions.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SPV节点维护带有所需交易的区块头链。它需要与全节点通信，这些全节点可以帮助它验证区块，但由于它不验证区块本身，所以也不会传递交易。
- en: A Full node that does not communicate with SPV nodes.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不与SPV节点通信的全节点。
- en: A Full node that only accepts blocks and not transactions.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只接受区块而不接受交易的全节点。
- en: So, there are quite a few variations among nodes. In addition, they can have
    different versions of software running. There could be an attacker node or group
    of attacker nodes that network or targeted nodes need to identify and blacklist.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，节点之间有很多变化。此外，它们可以运行不同版本的软件。可能存在一个攻击节点或一群攻击节点，网络或目标节点需要识别并将其列入黑名单。
- en: '[Node bootstrapping](toc.xhtml#s132a)'
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[节点引导](toc.xhtml#s132a)'
- en: As you have learned, Bitcoin doesn’t have a centralized server, so finding a
    node to connect is a challenge. To solve this problem, Bitcoin Core has hard-coded
    DNS Seeder addresses. These are called seed servers. These servers provide a list
    of addresses that may or may not be active. We need to iteratively find active
    address that we can connect with. The seed servers may get updated in the future.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所了解的，比特币没有中心化的服务器，因此找到要连接的节点是一个挑战。为了解决这个问题，比特币核心硬编码了 DNS Seeder 地址。这些被称为种子服务器。这些服务器提供了一系列可能活跃或不活跃的地址。我们需要迭代地找到可以连接的活动地址。种子服务器可能会在未来更新。
- en: 'Here are the hardcoded DNS seeds:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是硬编码的 DNS 种子：
- en: '![](images/187.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](images/187.jpg)'
- en: '**Table 7.1:** List of hardcoded DNS seeds'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7.1：** 硬编码的 DNS 种子列表'
- en: 'We are going to use following package to get the addresses from DNS seed node:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下包从 DNS 种子节点获取地址：
- en: '![](images/Figure-7.3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.3.jpg)'
- en: '**Figure 7.3:** Python package to communicate with DNS servers'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.3：** 与 DNS 服务器通信的 Python 包'
- en: 'The following program generates addresses from DNS seeds:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序生成了来自 DNS 种子的地址：
- en: '`import dns.name`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`import dns.name`'
- en: '`import dns.message`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`import dns.message`'
- en: '`import dns.query`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`import dns.query`'
- en: '`import dns.flags`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`import dns.flags`'
- en: '`import ipaddress`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`import ipaddress`'
- en: '`def getNodeAddresses(dnsseed: str):`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getNodeAddresses(dnsseed: str):`'
- en: '`dest = ‘8.8.8.8’`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`dest = ‘8.8.8.8’`'
- en: '`rdclass = 65535`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`rdclass = 65535`'
- en: '`domain = dns.name.from_text(dnsseed)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain = dns.name.from_text(dnsseed)`'
- en: '`if not domain.is_absolute():`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`if not domain.is_absolute():`'
- en: '`domain = domain.concatenate(dns.name.root)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain = domain.concatenate(dns.name.root)`'
- en: '`request = dns.message.make_query(`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`request = dns.message.make_query(`'
- en: '`domain,`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain,`'
- en: '`dns.rdatatype.A,`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dns.rdatatype.A,`'
- en: '`dns.rdataclass.IN)`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`dns.rdataclass.IN)`'
- en: '`request.flags |= dns.flags.RD|dns.flags.RA|dns.flags.AD`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.flags |= dns.flags.RD|dns.flags.RA|dns.flags.AD`'
- en: '`request.find_rrset(request.additional, dns.name.root, rdclass, dns.rdatatype.OPT,
    create=True, force_unique=True)`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.find_rrset(request.additional, dns.name.root, rdclass, dns.rdatatype.OPT,
    create=True, force_unique=True)`'
- en: '`responseudp = dns.query.udp(request, dest)`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`responseudp = dns.query.udp(request, dest)`'
- en: '`rrset = responseudp.answer`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`rrset = responseudp.answer`'
- en: '`rrset_l = []`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`rrset_l = []`'
- en: '`for rrset_val in rrset:`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`for rrset_val in rrset:`'
- en: '`rrset_l.extend(str(rrset_val).split(“\n”))`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`rrset_l.extend(str(rrset_val).split(“\n”))`'
- en: '`ipaddr_l = []`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipaddr_l = []`'
- en: '`for rrset_s in rrset_l:`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`for rrset_s in rrset_l:`'
- en: '`ipaddr_l.append(rrset_s.split(“ “)[4])`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipaddr_l.append(rrset_s.split(“ “)[4])`'
- en: '`return ipaddr_l`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ipaddr_l`'
- en: '`def getTestnetPeers():`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getTestnetPeers():`'
- en: '`port = 18333`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`port = 18333`'
- en: '`dns_seeds = [`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`dns_seeds = [`'
- en: '`“testnet-seed.bitcoin.jonasschnelli.ch”,`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`“testnet-seed.bitcoin.jonasschnelli.ch”,`'
- en: '`“seed.tbtc.petertodd.org”,`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`“seed.tbtc.petertodd.org”,`'
- en: '`“seed.testnet.bitcoin.sprovoost.nl”,`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`“seed.testnet.bitcoin.sprovoost.nl”,`'
- en: '`“testnet-seed.bluematt.me”`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`“testnet-seed.bluematt.me”`'
- en: '`]`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`]`'
- en: '`ipaddr_l = []`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipaddr_l = []`'
- en: '`for seed in dns_seeds:`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`for seed in dns_seeds:`'
- en: xwi
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: xwi
- en: '``ipaddr_l.extend(getNodeAddresses(seed))``'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '``ipaddr_l.extend(getNodeAddresses(seed))``'
- en: '``peers = []``'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '``peers = []``'
- en: '`for ipaddr in ipaddr_l:`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`for ipaddr in ipaddr_l:`'
- en: '`peers.append((ipaddr, port))`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers.append((ipaddr, port))`'
- en: '`return peers`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`return peers`'
- en: '**Program 7.1:** Program to get list of addresses from DNS seed'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.1：** 从 DNS 种子获取地址列表的程序'
- en: 'We call the preceding method as follows to get the list of the first five address
    and port numbers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '我们按以下方式调用上述方法以获取前五个地址和端口号的列表： '
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `__name__ == ‘__main__’:` '
- en: '`peers = getTestnetPeers()`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '获取测试网络节点 `peers = getTestnetPeers()` '
- en: '`for index in range(5):`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `range(5)` 中的每个索引： '
- en: '`print(peers[index])`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '打印 `print(peers[index])` '
- en: 'This gives us the following first five IP addresses and port numbers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '这给出了以下前五个 IP 地址和端口号： '
- en: '![](images/Figure-7.4.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/Figure-7.4.jpg)'
- en: '**Figure 7.4:** List of a few IP addresses and port numbers generated using
    DNS seed'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.4：** 使用 DNS 种子生成的一些 IP 地址和端口号列表 '
- en: 'There are also hardcoded IP Addresses in the Bitcoin Core source, which are
    used only as the last resort if the govt. blocks the connection to the known DNS
    seeds. These addresses are in the following file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bitcoin Core 源代码中还有一些硬编码的 IP 地址，仅在政府封锁到已知 DNS 种子的连接时作为最后的手段使用。这些地址在以下文件中： '
- en: '`chainparamsseeds.h`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`chainparamsseeds.h` '
- en: Bitcoin Core also maintains the `**peers.dat**` file, which maintains active
    addresses that it is connected to and since when. This helps in reconnecting to
    nodes after the connection is broken. Bitcoin Core daemon also has an `**addnode**`
    command option to specify a peer for connecting. This peer is treated at par with
    other peers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bitcoin Core 还维护着 `**peers.dat**` 文件，其中包含了它连接到的活动地址以及连接时间。这有助于在连接断开后重新连接到节点。Bitcoin
    Core 守护程序还具有 `**addnode**` 命令选项，用于指定连接的对等节点。这个节点被视为其他节点的平等。 '
- en: This information is specific to Bitcoin Core. In addition to utilizing the Bitcoin
    node bootstrapping method, we can connect to addresses available from other websites,
    such as **[https://bitnodes.io/api/v1/snapshots/latest](https://bitnodes.io/api/v1/snapshots/latest)**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息仅适用于Bitcoin Core。除了利用Bitcoin节点引导方法外，我们还可以连接来自其他网站的地址，例如**[https://bitnodes.io/api/v1/snapshots/latest](https://bitnodes.io/api/v1/snapshots/latest)**。
- en: 'The following code gets lists of nodes from this URL:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从该URL获取节点列表：
- en: '`import requests`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`import requests`'
- en: '`import socket`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`import socket`'
- en: '`from urllib.parse import urlparse`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`from urllib.parse import urlparse`'
- en: '`def isValidIPv6Addr(addr: str):`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`def isValidIPv6Addr(addr: str):`'
- en: '`try:`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`try:`'
- en: '`socket.inet_pton(socket.AF_INET6, addr)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.inet_pton(socket.AF_INET6, addr)`'
- en: '`except socket.error:`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`except socket.error:`'
- en: '`return False`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`return True`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def parseNodeInfo(ip_port: str, nodeinfo: dict):`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseNodeInfo(ip_port: str, nodeinfo: dict):`'
- en: '`node = {}`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`node = {}`'
- en: '`node[‘selected’] = False`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘selected’] = False`'
- en: '`node[‘port’] = int(ip_port.split(‘:’)[-1])`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘port’] = int(ip_port.split(‘:’)[-1])`'
- en: '`val = ip_port.rsplit(‘:’, 1)[0]`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`val = ip_port.rsplit(‘:’, 1)[0]`'
- en: '`parsed = urlparse(‘//{}’.format(val))`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`parsed = urlparse(‘//{}’.format(val))`'
- en: '`addr = parsed.hostname`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr = parsed.hostname`'
- en: '`if isValidIPv6Addr(addr) == False:`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`if isValidIPv6Addr(addr) == False:`'
- en: '`return node`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`return node`'
- en: '`node[‘selected’] = True`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘selected’] = True`'
- en: '`node[‘ipaddr’] = addr`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘ipaddr’] = addr`'
- en: '`node[‘type’] = nodeinfo[11]`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘type’] = nodeinfo[11]`'
- en: '`node[‘time’] = nodeinfo[2]`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`node[‘time’] = nodeinfo[2]`'
- en: '`return node`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`return node`'
- en: '`def getMainnetPeers():`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getMainnetPeers():`'
- en: '`url = ‘https://bitnodes.io/api/v1/snapshots/latest/’`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`url = ‘https://bitnodes.io/api/v1/snapshots/latest/’`'
- en: '`headers = {‘Accept’: ‘application/json’}`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers = {‘Accept’: ‘application/json’}`'
- en: '`r = requests.get(url=url, headers=headers)`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`r = requests.get(url=url, headers=headers)`'
- en: '`jsonobj = r.json()`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonobj = r.json()`'
- en: '`peers = []`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers = []`'
- en: '`for k, v in jsonobj[‘nodes’].items():`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`for k, v in jsonobj[‘nodes’].items():`'
- en: '`node = parseNodeInfo(k, v)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`node = parseNodeInfo(k, v)`'
- en: '`if node[‘selected’] == True:`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`if node[‘selected’] == True:`'
- en: '`peers.append(node)`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers.append(node)`'
- en: '`return peers`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`return peers`'
- en: '**Program 7.2:** Program to get the list of nodes using an external URL'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序7.2**：使用外部URL获取节点列表的程序'
- en: 'We call the above-mentioned methods to get peers as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用上述方法以如下方式获取对等节点：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`peers = getMainnetPeers()`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers = getMainnetPeers()`'
- en: '`for peer in peers:`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`for peer in peers:`'
- en: '`print(‘%s\t\t\t%d’ % (peer[‘ipaddr’], peer[‘port’]))`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘%s\t\t\t%d’ % (peer[‘ipaddr’], peer[‘port’]))`'
- en: 'This gives us the following first five peers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们以下前五个对等节点：
- en: '![](images/Figure-7.5.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.5.jpg)'
- en: '**Figure 7.5:** List of IP addresses and port numbers of peers obtained from
    an external website'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.5**：从外部网站获取的对等节点的IP地址和端口号列表'
- en: '[Network messaging](toc.xhtml#s133a)'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[网络消息传递](toc.xhtml#s133a)'
- en: Bitcoin network nodes communicate with each other for various reasons, like
    to learn about some other peers, to be sure that the connection is still active,
    to help other nodes to sync with itself, or ask for missing blocks, or to broadcast
    any new received block or transaction. In this topic, you will learn in detail
    about the messaging and its format, and program it by writing a client.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Bitcoin网络节点之间相互通信的原因有很多，比如了解其他对等节点，
- en: '[Message format](toc.xhtml#s134a)'
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[消息格式](toc.xhtml#s134a)'
- en: Messages exchanged over the network have headers and payload, and the payload
    is dependent on the command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上传交换的消息具有头部和负载，且负载取决于命令。
- en: 'Here’s the message format:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是消息格式：
- en: '![](images/Figure-7.6.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.6.jpg)'
- en: '**Figure 7.6:** Illustration of protocol message format'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.6**：协议消息格式说明'
- en: '*The following is the explanation of each field of the message format:*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下是对消息格式各字段的解释：*'
- en: '**Magic** is the same as we learned in the block structure in ***[Chapter 6,
    Blockchain, Transactions, and Mining](c06.xhtml)*** and we can look at its values
    in [table 6.3](c06.xhtml#tab6_3).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔数**与我们在***[第6章，区块链、交易和挖矿](c06.xhtml)***中学到的区块结构相同，我们可以在[表6.3](c06.xhtml#tab6_3)查看其值。'
- en: '**Command** is the command sent in ASCII padded with all zeroes i.e. b’\0’.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**是发送的ASCII命令，全部用零填充，即b''\\0''。'
- en: '**Length** is the length of the payload.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**是负载的长度。'
- en: '**Checksum** is the checksum of the payload.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**校验和**是负载的校验和。'
- en: '**Payload** is the parameters of the command sent.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载**是发送的命令的参数。'
- en: 'The following is the method that creates this message:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下创建此消息的方法：
- en: '`def createMessage(command, payload):`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createMessage(command, payload):`'
- en: '`magic = 0x0709110B`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`magic = 0x0709110B`'
- en: '`checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]`'
- en: '`magic_b = struct.pack(‘<L’, magic)`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`magic_b = struct.pack(‘<L'', magic)`'
- en: '`cmd_b = struct.pack(‘<12s’, command.encode(‘ascii’))`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd_b = struct.pack(‘<12s'', command.encode(‘ascii''))`'
- en: '`payload_len_b = struct.pack(‘<L’, len(payload))`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload_len_b = struct.pack(‘<L'', len(payload))`'
- en: '`checksum_b = struct.pack(‘<4s’, checksum)`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`checksum_b = struct.pack(‘<4s'', checksum)`'
- en: '`msg = magic_b + cmd_b + payload_len_b + checksum + payload`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg = magic_b + cmd_b + payload_len_b + checksum + payload`'
- en: '`return msg`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`return msg`'
- en: '**Program 7.3:** A method for creating protocol message'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.3**：创建协议消息的方法'
- en: '[Establishing connection](toc.xhtml#s135a)'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[建立连接](toc.xhtml#s135a)'
- en: 'Bitcoin establishes a connection by first exchanging versions and then acknowledging
    their acceptance. Before acknowledging the version, a node needs to send its own
    version. So, the network handshake looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币通过首先交换版本信息然后确认接受来建立连接。在确认版本之前，节点需要发送自己的版本信息。因此，网络握手如下所示：
- en: '![](images/Figure-7.7.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.7.jpg)'
- en: '**Figure 7.7:** An illustration of the sequence of message transfers to establish
    Bitcoin connection'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.7**：建立比特币连接的消息传输序列说明'
- en: 'The f*ollowing is the* `**version**` *message payload* structure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`**版本**`消息负载的结构：
- en: '![](images/Figure-7.8.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.8.jpg)'
- en: '**Figure 7.8:** Version message payload structure'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.8**：版本消息负载结构'
- en: '*The following is the explanation of each field of the `**version**` message:*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下是对`**版本**`消息各字段的解释：*'
- en: '`**Version**` is the Protocol version running on a host.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**版本**`是主机上运行的协议版本。'
- en: '**Service** is the service supported by the sending node. Here’s the list of
    service codes:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**是发送节点支持的服务。以下是服务代码的列表：'
- en: '| **Byte Code** | **Service Offered** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **字节码** | **提供的服务** | **描述** |'
- en: '| 1 | NODE_NETWORK | Full Node |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | NODE_NETWORK | 完整节点 |'
- en: '| 2 | NODE_GETUTXO | BIP 0064: Supports getutxos and utxos |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 2 | NODE_GETUTXO | BIP 0064: 支持getutxos和utxos |'
- en: '| 4 | NODE_BLOOM | BIP 0111: Supports Bloom filters |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 4 | NODE_BLOOM | BIP 0111: 支持Bloom过滤器 |'
- en: '| 8 | NODE_WITNESS | BIP 0144: Supports Segregated Witness |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 8 | NODE_WITNESS | BIP 0144: 支持隔离见证 |'
- en: '| 1024 | NODE_NETWORK_LIMITED | BIP 0159: Pruned node |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 1024 | NODE_NETWORK_LIMITED | BIP 0159: 支持修剪节点 |'
- en: '**Table 7.2:** List of service codes required by Version message'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7.2**：版本消息所需的服务代码列表'
- en: '**Timestamp** is the Unix epoch time of the payload.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**是负载的Unix纪元时间。'
- en: '**Addr Recv** is the address of the connection receiving node. So, the node
    sending the `**version**` payload will have the address and port of the peer it
    is connecting to. The Services field is normally set to zeroes.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Addr Recv** 是接收连接节点的地址。因此，发送`**版本**`负载的节点将包含它正在连接的对等点的地址和端口。服务字段通常设置为零。'
- en: '**Addr from** is the address of the connection originating node. So, the node
    sending the `**version**` payload will have its own address and port. It also
    includes services offered by the sender.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Addr from** 是原始连接节点的地址。因此，发送`**版本**`负载的节点将包含其自身的地址和端口。它还包括发送者的服务。'
- en: '**Nonce** is a random number that is useful in identifying whether we are not
    connected to ourselves.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nonce** 是一个随机数，它在识别我们是否没有连接到自身时很有用。'
- en: '**User Agent** is used to identify the software running at the node. It is
    defined in BIP-0014.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户代理**用于标识节点上运行的软件。它定义在BIP-0014中。'
- en: '**Start Height** is the current block height at the node blockchain.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始高度**是节点区块链当前的区块高度。'
- en: '**Relay** is an optional Boolean value that is set by SPV to false to indicate
    that the node will not participate in relaying a message. This means it does not
    want peers to advertise `**inv**` messages with MSG_BLOCK. This protects the node
    from getting flooded by `**inv**` messages. This is defined in BIP 0037.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中继**是一个可选的布尔值，由SPV设置为false以表示节点将不参与消息的中继。这意味着它不希望对等体宣传`**inv**`消息与MSG_BLOCK。这保护节点不会因`**inv**`消息而被淹没。这在BIP
    0037中定义。'
- en: 'The following is the distribution of version of nodes at the time of writing:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此书时节点的版本分布如下：
- en: '![](images/Figure-7.9.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.9.jpg)'
- en: '**Figure 7.9:** Chart showing the distribution of the version of nodes on the
    Bitcoin network'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.9**：显示比特币网络上节点版本的分布图'
- en: 'The following is the distribution of User Agents in the Bitcoin network:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比特币网络中用户代理的分布：
- en: '![](images/Figure-7.10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.10.jpg)'
- en: '**Figure 7.10:** Bar chart showing the distribution of user agents in the Bitcoin
    network'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.10**：柱状图显示比特币网络中用户代理的分布'
- en: 'The following is the program that creates `**version**` payload:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是创建 `**version**` 负载的程序： '
- en: '`from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `bitcoinrpc.authproxy` 模块中导入 `AuthServiceProxy` 和 `JSONRPCException`
- en: '`import struct`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `struct` 模块
- en: '`import random`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '导入 `random` 模块 '
- en: '`rpc_connection = AuthServiceProxy(“http://%s:%s@127.0.0.1:18332”%(‘test’,
    ‘test’))`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpc_connection = AuthServiceProxy(“http://%s:%s@127.0.0.1:18332”%(‘test’,
    ‘test’))` '
- en: '`def setVarInt(n: int):`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '定义函数 `setVarInt(n: int):` '
- en: '`if n < 0xfd:`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `n < 0xfd:` '
- en: '`n_h = ‘%02x’ % n`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘%02x’ % n` '
- en: '`elif n > 0xfd and n < 0xffff:`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '或者 `n > 0xfd` 且 `n < 0xffff:` '
- en: '`n_h = ‘fd%04x’ % n`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘fd%04x’ % n` '
- en: '`elif n > 0xffff and n < 0xFFFFFFFF:`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif n > 0xffff and n < 0xFFFFFFFF:` '
- en: '`n_h = ‘fe%08x’ % n`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘fe%08x’ % n` '
- en: '`else:`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '否则: '
- en: '`n_h = ‘ff%016x’ % n`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_h = ‘ff%016x’ % n` '
- en: '`return bytes.fromhex(n_h)`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 `bytes.fromhex(n_h)` '
- en: '`def getLastBlockHeight():`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '定义函数 `getLastBlockHeight():` '
- en: '`height = rpc_connection.getblockcount()`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '获取高度 `height = rpc_connection.getblockcount()` '
- en: '`return height`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '返回高度 `height` '
- en: '`def createUserAgent():`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '定义函数 `createUserAgent():` '
- en: '`sub_version = “/MyTestAgent:0.0.1/”`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub_version = “/MyTestAgent:0.0.1/”` '
- en: '`sub_version_b = sub_version.encode()`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub_version_b = sub_version.encode()` '
- en: '`len_b = setVarInt(len(sub_version_b))`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`len_b = setVarInt(len(sub_version_b))` '
- en: '`return len_b + sub_version_b`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 `len_b + sub_version_b` '
- en: '`def createRecvIPAddress(ip, port):`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '定义函数 `createRecvIPAddress(ip, port):` '
- en: '`service_b = struct.pack(‘<Q’, 1)`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`service_b = struct.pack(‘<Q’, 1)` '
- en: '`ip_b = socket.inet_aton(ip)`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_b = socket.inet_aton(ip)` '
- en: '`ipv4_to_ipv6 = bytearray.fromhex(“00000000000000000000ffff”) + ip_b`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv4_to_ipv6 = bytearray.fromhex(“00000000000000000000ffff”) + ip_b` '
- en: '`ipv6addr_b = struct.pack(‘>16s’, ipv4_to_ipv6)`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv6addr_b = struct.pack(‘>16s’, ipv4_to_ipv6)` '
- en: '`port_b = struct.pack(‘>H’, port)`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`port_b = struct.pack(‘>H’, port)` '
- en: '`addr_b = service_b + ipv6addr_b + port_b`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr_b = service_b + ipv6addr_b + port_b` '
- en: '`return(addr_b)`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`return(addr_b)`'
- en: '`def createTransIPAddress():`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createTransIPAddress():`'
- en: '`service_b = struct.pack(‘<Q’, 1)`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`service_b = struct.pack(‘<Q’, 1)`'
- en: '`ip_b = socket.inet_aton(“0.0.0.0”)`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_b = socket.inet_aton(“0.0.0.0”)`'
- en: '`ipv4_to_ipv6 = bytearray.fromhex(“000000000000000000000000”) + ip_b`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv4_to_ipv6 = bytearray.fromhex(“000000000000000000000000”) + ip_b`'
- en: '`ipv6addr_b = struct.pack(‘>16s’, ipv4_to_ipv6)`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv6addr_b = struct.pack(‘>16s’, ipv4_to_ipv6)`'
- en: '`port_b = struct.pack(‘>H’, 0)`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`port_b = struct.pack(‘>H’, 0)`'
- en: '`addr_b = service_b + ipv6addr_b + port_b`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr_b = service_b + ipv6addr_b + port_b`'
- en: '`return(addr_b)`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`return(addr_b)`'
- en: '`def createVersionPayload(s: socket, version: int):`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createVersionPayload(s: socket, version: int):`'
- en: '`version_b = struct.pack(‘<L’, version)`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = struct.pack(‘<L’, version)`'
- en: '`services_b = struct.pack(‘<Q’, 1)`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`services_b = struct.pack(‘<Q’, 1)`'
- en: '`timestamp_b = struct.pack(‘<Q’, int(time.time()))`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp_b = struct.pack(‘<Q’, int(time.time()))`'
- en: '`myip, myport = s.getsockname()`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`myip, myport = s.getsockname()`'
- en: '`addr_recv_b = struct.pack(‘<26s’, createRecvIPAddress(myip, myport))`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr_recv_b = struct.pack(‘<26s’, createRecvIPAddress(myip, myport))`'
- en: '`addr_trans_b = struct.pack(‘<26s’, createTransIPAddress())`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr_trans_b = struct.pack(‘<26s’, createTransIPAddress())`'
- en: '`nonce_b = struct.pack(‘<Q’, random.getrandbits(64))`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonce_b = struct.pack(‘<Q’, random.getrandbits(64))`'
- en: '`user_agent = createUserAgent()`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_agent = createUserAgent()`'
- en: '`user_agent_b = struct.pack(‘<%ds’ % len(user_agent), user_agent)`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_agent_b = struct.pack(‘<%ds’ % len(user_agent), user_agent)`'
- en: '`start_height_b = struct.pack(‘<L’, getLastBlockHeight())`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_height_b = struct.pack(‘<L’, getLastBlockHeight())`'
- en: '`payload = version_b \`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = version_b \`'
- en: '`+ services_b \`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ services_b \`'
- en: '`+ timestamp_b \`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ timestamp_b \`'
- en: '`+ addr_recv_b \`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ addr_recv_b \`'
- en: '`+ addr_trans_b \`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ addr_trans_b \`'
- en: '`+ nonce_b \`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ nonce_b \`'
- en: '`+ user_agent_b \`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ user_agent_b \`'
- en: '`+ start_height_b`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ start_height_b`'
- en: '`return payload`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '**Program 7.4:** Program for creating Version message payload'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.4：** 创建版本消息有效载荷的程序'
- en: 'To create the message payload, we use the Python struct pack. The following
    are the symbols and their meanings:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消息有效载荷时，我们使用 Python struct 包。以下是符号及其含义：
- en: '| **Symbols** | **Represents** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **表示** |'
- en: '| < | Little Endian |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| < | 小端序 |'
- en: '| > | Big Endian |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| > | 大端序 |'
- en: '| B | 1-byte Unsigned Integer |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| B | 1字节无符号整数 |'
- en: '| H | 2-byte Unsigned Integer |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| H | 2字节无符号整数 |'
- en: '| L | 4-byte Unsigned Integer |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| L | 4字节无符号整数 |'
- en: '| Q | 8-byte Unsigned Integer |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| Q | 8字节无符号整数 |'
- en: '| xs | Byte array of size x |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| xs | 大小为 x 的字节数组 |'
- en: '**Table 7.3:** List of Python struct pack symbols and their meanings'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7.3：** Python struct 包符号及其含义列表'
- en: 'You can check out the Python docs for more details:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看 Python 文档以获取更多详情：
- en: '**[https://docs.python.org/3.8/library/struct.html](https://docs.python.org/3.8/library/struct.html)**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**[https://docs.python.org/3.8/library/struct.html](https://docs.python.org/3.8/library/struct.html)**'
- en: IP address and port are in big endian, while the rest of the message is in the
    little-endian format. When we pack an ASCII string, it converts it into a byte
    array and pads it with zeroes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址和端口位于大端序，而其余消息位于小端序。当我们打包 ASCII 字符串时，它将其转换为字节数组并用零填充。
- en: 'We call the preceding methods as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之前的方法如下：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`peers = getTestnetPeers()`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers = getTestnetPeers()`'
- en: '`p = random.choice(peers)`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`p = random.choice(peers)`'
- en: '`s = None`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = None`'
- en: '`peerinfo = {}`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`peerinfo = {}`'
- en: '`print(“Trying to connect to “, p)`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“尝试连接到 “, p)`'
- en: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
- en: '`err = s.connect(p)`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`err = s.connect(p)`'
- en: '`print(‘TCP Connection Established’)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘TCP 连接已建立’)`'
- en: '`payload = createVersionPayload(s, 70015)`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createVersionPayload(s, 70015)`'
- en: '`print(‘Version payload: ‘, payload.hex())`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘版本有效载荷：‘, payload.hex())`'
- en: '`s.close()`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.close()`'
- en: 'This creates the following payload in hex string:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建以下十六进制字符串的有效载荷：
- en: '![](images/Figure-7.11.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.11.jpg)'
- en: '**Figure 7.11:** Shows version payload created by the CreateVersionPayload
    program'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.11：** CreateVersionPayload 程序创建的版本有效载荷的显示'
- en: 'When we receive the `***version***` message, we do the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到`***version***`消息时，我们执行以下操作：
- en: 'We first receive the message header, verify the magic number and checksum,
    and identify the command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先接收消息头，验证魔数和校验和，然后识别命令：
- en: '`flog = open(‘communication.log’, ‘wt+’)`'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`flog = open(‘communication.log’, ‘wt+’)`'
- en: '`def calculateChecksum(b: bytes):`'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def calculateChecksum(b: bytes):`'
- en: '`checksum = hashlib.sha256(hashlib.sha256(b).digest()).digest()[0:4]`'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`checksum = hashlib.sha256(hashlib.sha256(b).digest()).digest()[0:4]`'
- en: '`return checksum`'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return checksum`'
- en: '`def checkMessage(msghdr: dict, payload_b: bytes):`'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def checkMessage(msghdr: dict, payload_b: bytes):`'
- en: '`if msghdr[‘magic’] == ‘0709110b’:`'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if msghdr[‘magic’] == ‘0709110b’:`'
- en: '`print(‘Magic check passed’, file=flog)`'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘魔数检查通过’, file=flog)`'
- en: '`else:`'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘Magic check failed’, file=flog)`'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘魔数检查失败’, file=flog)`'
- en: '`print(‘magic = %s’ % msghdr[‘magic’], file=flog)`'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘魔数 = %s’ % msghdr[‘magic’], file=flog)`'
- en: '`raise Exception(‘Invalid Magic’, file=flog)`'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`raise Exception(‘无效的魔数’, file=flog)`'
- en: '`checksum_calc = calculateChecksum(payload_b)`'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`checksum_calc = calculateChecksum(payload_b)`'
- en: '`if msghdr[‘checksum’] == checksum_calc:`'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if msghdr[‘checksum’] == checksum_calc:`'
- en: '`print(‘checksum check passed’, file=flog)`'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘校验和检查通过’, file=flog)`'
- en: '`else:`'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`print(‘checksum check failed’, file=flog)`'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘校验和检查失败’, file=flog)`'
- en: '`print(‘payload = %s’ % payload_b.hex(), file=flog)`'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘有效载荷 = %s’ % payload_b.hex(), file=flog)`'
- en: '`print(‘expected checksum = %s’ % msghdr[‘checksum’].hex(), file=flog)`'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘预期校验和 = %s’ % msghdr[‘checksum’].hex(), file=flog)`'
- en: '`print(‘received checksum = %s’ % checksum_calc.hex(), file=flog)`'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘接收到的校验和 = %s’ % checksum_calc.hex(), file=flog)`'
- en: '`raise Exception(‘Invalid Checksum’)`'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`raise Exception(‘无效的校验和’)`'
- en: '`def parseMsgHdr(msghdr_b: bytes):`'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def parseMsgHdr(msghdr_b: bytes):`'
- en: '`msghdr = {}`'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr = {}`'
- en: '`msghdr[‘magic’] = msghdr_b[0:4][::-1].hex()`'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr[‘magic’] = msghdr_b[0:4][::-1].hex()`'
- en: '`msghdr[‘command’] = msghdr_b[4:16].decode(“ascii”).strip(‘\0’)`'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr[‘command’] = msghdr_b[4:16].decode(“ascii”).strip(‘\0’)`'
- en: '`msghdr[‘length’] = int.from_bytes(msghdr_b[16:20], byteorder=’little’)`'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr[‘length’] = int.from_bytes(msghdr_b[16:20], byteorder=’little’)`'
- en: '`msghdr[‘checksum’] = msghdr_b[20:24]`'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr[‘checksum’] = msghdr_b[20:24]`'
- en: '`return msghdr`'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return msghdr`'
- en: '**Program 7.5:** Program for parsing message header'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**程序 7.5：** 用于解析消息头的程序'
- en: We can see that the program checksum only contains the first 4 bytes of the
    double SHA256 hash; to get the command, we strip it.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到程序校验和只包含双 SHA256 哈希的前 4 个字节；为了获取命令，我们将其剥离。
- en: 'Next, we receive a message again from the socket and call the parser of the
    `***version***` payload. To do this, we call the method by name. We will create
    dummy methods for the ones not required by the subsequent programs:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次从套接字接收消息，并调用`***version***`载荷的解析器。为此，我们通过名称调用该方法。我们将为后续程序不需要的方法创建虚拟方法：
- en: '`MSGHDR_SIZE = 24`'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MSGHDR_SIZE = 24`'
- en: '`CMD_FN_MAP = {`'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CMD_FN_MAP = {`'
- en: '`‘version’: parseVersionPayload,`'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘version’: parseVersionPayload,`'
- en: '`‘addr’: parseAddrPayload,`'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘addr’: parseAddrPayload,`'
- en: '`‘filterload’: parseFilterLoadPayload,`'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘filterload’: parseFilterLoadPayload,`'
- en: '`‘filteradd’: parseFilterAddPayload,`'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘filteradd’: parseFilterAddPayload,`'
- en: '`‘merkleblock’: parseMerkleBlockPayload,`'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘merkleblock’: parseMerkleBlockPayload,`'
- en: '`‘ping’: parsePingPongPayload,`'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘ping’: parsePingPongPayload,`'
- en: '`‘pong’: parsePingPongPayload,`'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘pong’: parsePingPongPayload,`'
- en: '`‘feefilter’: parseFeeFilterPayload,`'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘feefilter’: parseFeeFilterPayload,`'
- en: '`‘inv’: parseInvPayload,`'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘inv’: parseInvPayload,`'
- en: '`‘getdata’: parseInvPayload,`'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘getdata’: parseInvPayload,`'
- en: '`‘notfound’: parseInvPayload,`'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘notfound’: parseInvPayload,`'
- en: '`‘tx’: parseTxPayload,`'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘tx’: parseTxPayload,`'
- en: '`‘block’: parseBlockPayload,`'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘block’: parseBlockPayload,`'
- en: '`‘getblocks’: parseGetBlocksGetHeadersPayload,`'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘getblocks’: parseGetBlocksGetHeadersPayload,`'
- en: '`‘getheaders’: parseGetBlocksGetHeadersPayload,`'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘getheaders’: parseGetBlocksGetHeadersPayload,`'
- en: '`‘headers’: parseHeadersPayload,`'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘headers’: parseHeadersPayload,`'
- en: '`‘reject’: parseRejectPayload,`'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘reject’: parseRejectPayload,`'
- en: '`‘sendcmpct’: parseSendCompactPayload,`'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘sendcmpct’: parseSendCompactPayload,`'
- en: '`‘cmpctblock’: parseCompactBlockPayload,`'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘cmpctblock’: parseCompactBlockPayload,`'
- en: '`‘getblocktxn’: parseGetBlockTxnPayload,`'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘getblocktxn’: parseGetBlockTxnPayload,`'
- en: '`‘blocktxn’: parseBlockTxnPayload`'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`‘blocktxn’: parseBlockTxnPayload`'
- en: '`}`'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`def recvAll(s: socket, payloadlen: int):`'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def recvAll(s: socket, payloadlen: int):`'
- en: '`payload_b = b’’`'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_b = b’’`'
- en: '`length = payloadlen`'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`length = payloadlen`'
- en: '`while True:`'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '`recvd_b = s.recv(length)`'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`recvd_b = s.recv(length)`'
- en: '`payload_b += recvd_b`'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_b += recvd_b`'
- en: '`if len(payload_b) == payloadlen:`'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if len(payload_b) == payloadlen:`'
- en: '`break`'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`length = payloadlen - len(payload_b)`'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`length = payloadlen - len(payload_b)`'
- en: '`return payload_b`'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return payload_b`'
- en: '`def recvMsg(s: socket):`'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def recvMsg(s: socket):`'
- en: '`msghdr_b = s.recv(MSGHDR_SIZE)`'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msghdr_b = s.recv(MSGHDR_SIZE)`'
- en: '`msg = parseMsgHdr(msghdr_b)`'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msg = parseMsgHdr(msghdr_b)`'
- en: '`payloadlen = msg[‘length’]`'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payloadlen = msg[‘length’]`'
- en: '`payload_b = recvAll(s, payloadlen)`'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_b = recvAll(s, payloadlen)`'
- en: '``checkMessage(msg, payload_b)``'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '``checkMessage(msg, payload_b)``'
- en: '`payload_m = mmap.mmap(-1, payloadlen + 1)`'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_m = mmap.mmap(-1, payloadlen + 1)`'
- en: '`payload_m.write(payload_b)`'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_m.write(payload_b)`'
- en: '`payload_m.seek(0)`'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload_m.seek(0)`'
- en: '`msg[‘payload’] = {}`'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msg[‘payload’] = {}`'
- en: '`if payloadlen > 0:`'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if payloadlen > 0:`'
- en: '`msg[‘payload’] = CMD_FN_MAP[msg[‘command’]](payload_m, payloadlen)`'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`msg[‘payload’] = CMD_FN_MAP[msg[‘command’]](payload_m, payloadlen)`'
- en: '`print(‘<== msg = %s’ % msg, file=flog)`'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘<== msg = %s’ % msg, file=flog)`'
- en: '`return msg`'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return msg`'
- en: '**Program 7.6:** Program to receive and process messages based on command'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Program 7.6:** 基于命令接收和处理消息的程序'
- en: 'The following code parses the `***version***` payload:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码解析`***version***`载荷：
- en: '`import ipaddress`'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import ipaddress`'
- en: '`import datetime`'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import datetime`'
- en: '`def parseIPAddress(ip_m: mmap):`'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def parseIPAddress(ip_m: mmap):`'
- en: '`addr = {}`'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr = {}`'
- en: '`addr[‘service’] = int.from_bytes(ip_m.read(8), byteorder=’little’)`'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘service’] = int.from_bytes(ip_m.read(8), byteorder=’little’)`'
- en: '`parseServices(addr[‘service’])`'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`parseServices(addr[‘service’])`'
- en: '`ip = ip_m.read(16)`'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ip = ip_m.read(16)`'
- en: '`if ip[0:12].hex() == “00000000000000000000ffff”:`'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if ip[0:12].hex() == “00000000000000000000ffff”:`'
- en: '`addr[‘version’] = ‘IPv4’`'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘version’] = ‘IPv4’`'
- en: '`addr[‘address’] = str(ipaddress.IPv4Address(ip[12:16]))`'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘address’] = str(ipaddress.IPv4Address(ip[12:16]))`'
- en: '`else:`'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`addr[‘version’] = ‘IPv6’`'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘version’] = ‘IPv6’`'
- en: '`addr[‘address’] = str(ipaddress.IPv6Address(ip[0:16]))`'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘address’] = str(ipaddress.IPv6Address(ip[0:16]))`'
- en: '`addr[‘port’] = int.from_bytes(ip_m.read(2), byteorder=’big’)`'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addr[‘port’] = int.from_bytes(ip_m.read(2), byteorder=’big’)`'
- en: '`return addr`'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return addr`'
- en: '`def parseServices(services: int):`'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def parseServices(services: int):`'
- en: '`service_l = []`'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l = []`'
- en: '`if services == 0x00:`'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services == 0x00:`'
- en: '`service_l.append(‘Unnamed’)`'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘Unnamed’)`'
- en: '`if services & 0x01 == 0x01:`'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services & 0x01 == 0x01:`'
- en: '`service_l.append(‘NODE_NETWORK’)`'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘NODE_NETWORK’)`'
- en: '`if services & 0x02:`'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services & 0x02:`'
- en: '`service_l.append(‘NODE_GETUTXO’)`'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘NODE_GETUTXO’)`'
- en: '`if services & 0x04:`'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services & 0x04:`'
- en: '`service_l.append(‘NODE_BLOOM’)`'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘NODE_BLOOM’)`'
- en: '`if services & 0x08:`'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services & 0x08:`'
- en: '`service_l.append(‘NODE_WITNESS’)`'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘NODE_WITNESS’)`'
- en: '`if services & 1024:`'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if services & 1024:`'
- en: '`service_l.append(‘NODE_NETWORK_LIMITED’)`'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service_l.append(‘NODE_NETWORK_LIMITED’)`'
- en: '`print(‘Services: %d implies: %s’ % (services, service_l), file=flog)`'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(‘Services: %d implies: %s’ % (services, service_l), file=flog)`'
- en: '`def parseVersionPayload(payload_m: mmap, payloadlen: int):`'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def parseVersionPayload(payload_m: mmap, payloadlen: int):`'
- en: '`payload = {}`'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`start = payload_m.tell()`'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start = payload_m.tell()`'
- en: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`payload[‘services’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘services’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`parseServices(payload[‘services’])`'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`parseServices(payload[‘services’])`'
- en: '`payload[‘timestamp’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘timestamp’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`payload[‘dt’] = datetime.datetime.fromtimestamp(payload[‘timestamp’]).strftime(‘%Y-%m-%d
    %H:%M:%S’)`'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘dt’] = datetime.datetime.fromtimestamp(payload[‘timestamp’]).strftime(‘%Y-%m-%d
    %H:%M:%S’)`'
- en: '`payload[‘addr_recv’] = parseIPAddress(payload_m)`'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘addr_recv’] = parseIPAddress(payload_m)`'
- en: '`payload[‘addr_trans’] = parseIPAddress(payload_m)`'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘addr_trans’] = parseIPAddress(payload_m)`'
- en: '`payload[‘nonce’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘nonce’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`payload[‘user_agent_size’] = getVarInt(payload_m)`'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘user_agent_size’] = getVarInt(payload_m)`'
- en: '`payload[‘user_agent’] = payload_m.read(payload[‘user_agent_size’])`'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘user_agent’] = payload_m.read(payload[‘user_agent_size’])`'
- en: '`payload[‘block_height’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘block_height’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`if payload_m.tell() - start != payloadlen:`'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if payload_m.tell() - start != payloadlen:`'
- en: '`payload[‘relay’] = int.from_bytes(payload_m.read(1), byteorder=’little’)`'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`payload[‘relay’] = int.from_bytes(payload_m.read(1), byteorder=’little’)`'
- en: '`return payload`'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '**Program 7.7:** Program to parse version payload'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Program 7.7:** Program to parse version payload'
- en: Bitcoin network messaging uses the same variable integer format as we had discussed
    in *[Chapter 6, Blockchain, Transactions, and Mining](c06.xhtml), [figure 6.25](c06.xhtml#fig6_25)*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络消息使用与我们曾在 *[第6章，区块链、交易和挖矿](c06.xhtml)，[图6.25](c06.xhtml#fig6_25)* 中讨论过的相同的变量整数格式。
- en: The `**verack**` message has no payload. It is an acknowledgment of the `***version***`
    received.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**verack** 消息没有负载。它是接收到的 **version** 的确认。'
- en: Once the `***version***` message is sent and received and `**verack**` message
    is sent and received, we consider the connection to have been established and
    are ready to send and receive other types of messages.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发送和接收了 **version** 消息，并发送和接收了 **verack** 消息，我们认为连接已经建立，并准备好发送和接收其他类型的消息。
- en: 'The following is the code for establishing a Bitcoin connection:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是建立比特币连接的代码：
- en: '`def sendVersionMessage(s: socket, version: int):`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendVersionMessage(s: socket, version: int):`'
- en: '`sndcmd = ‘version’`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘version’`'
- en: '`payload = createVersionPayload(s, version)`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createVersionPayload(s, version)`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`return True`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def waitForVersion(s: socket):`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForVersion(s: socket):`'
- en: '`recvmsg = recvMsg(s)`'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvmsg = recvMsg(s)`'
- en: '`vers_recvd = False`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`vers_recvd = False`'
- en: '`if recvmsg[‘command’] != ‘version’:`'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] != ‘version’:`'
- en: '`print(‘Invalid Response’)`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Invalid Response’)`'
- en: '`return False`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`services = recvmsg[‘payload’][‘services’]`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`services = recvmsg[‘payload’][‘services’]`'
- en: '`if services & 1 == 0x00:`'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`if services & 1 == 0x00:`'
- en: '`print(‘Peer is not full node’)`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Peer is not full node’)`'
- en: '`return False`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`return True`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def sendVerackMessage(s: socket):`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendVerackMessage(s: socket):`'
- en: '`sndcmd = ‘verack’`'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘verack’`'
- en: '`payload = b’’`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = b’’`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '``s.send(sndmsg)``'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`return True`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def waitForVerack(s: socket):`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForVerack(s: socket):`'
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``'
- en: '`verack_recvd = False`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`verack_recvd = False`'
- en: '`if recvmsg[‘command’] != ‘verack’:`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] != ‘verack’:`'
- en: '`return False`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`return True`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`def establishConnection(s: socket, version: int):`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`def establishConnection(s: socket, version: int):`'
- en: '`vers_sent = sendVersionMessage(s, version)`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`vers_sent = sendVersionMessage(s, version)`'
- en: '`vers_recvd = waitForVersion(s)`'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`vers_recvd = waitForVersion(s)`'
- en: '`if vers_recvd == False:`'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`if vers_recvd == False:`'
- en: '`return False`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '`verack_sent = sendVerackMessage(s)`'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`verack_sent = sendVerackMessage(s)`'
- en: '`verack_recvd = waitForVerack(s)`'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`verack_recvd = waitForVerack(s)`'
- en: '`if vers_sent and vers_recvd and verack_sent and verack_recvd:`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`if vers_sent and vers_recvd and verack_sent and verack_recvd:`'
- en: '`print(‘Connection is established’, file=flog)`'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Connection is established’, file=flog)`'
- en: '`return True`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`return True`'
- en: '`return False`'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`return False`'
- en: '**Program 7.8:** Program to establish Bitcoin connection'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序7.8:** 建立比特币连接的程序'
- en: 'We call the preceding method using the following program:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下程序调用前面的方法：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`peers = getTestnetPeers()`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers = getTestnetPeers()`'
- en: '`p = random.choice(peers)`'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`p = random.choice(peers)`'
- en: '`s = None`'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = None`'
- en: '`peerinfo = {}`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`peerinfo = {}`'
- en: '`print(“Trying to connect to “, p, file=flog)`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“Trying to connect to “, p, file=flog)`'
- en: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
- en: '`err = s.connect(p)`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`err = s.connect(p)`'
- en: '`print(‘connected’, file=flog)`'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘connected’, file=flog)`'
- en: '`if establishConnection(s, 70015) == False:`'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, 70015) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Establish connection failed’, file=flog)`'
- en: '`s.close()`'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.close()`'
- en: '`flog.close()`'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`flog.close()`'
- en: 'We get the following communication log:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下通信日志：
- en: '![](images/Figure-7.12.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.12.jpg)'
- en: '**Figure 7.12:** Communication log of message exchange during Bitcoin connection
    establishment'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.12:** 比特币连接建立过程中的消息交换通信日志'
- en: In this subtopic, you learned to establish a Bitcoin connection.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子主题中，你学会了建立比特币连接。
- en: '[Disconnecting with inactive peer](toc.xhtml#s136a)'
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[与不活跃的对等节点断开连接](toc.xhtml#s136a)'
- en: TCP/IP connection can become inactive without the knowledge of a peer. To disconnect
    an inactive connection, the node sends `**ping**` and expects `**pong**` as a
    response. The `**ping**` message contains an 8-byte nonce, which is a random number.
    In the response `**pong**` message, the receiving node sends back the same nonce
    message that it had received as part of the `**ping**` message.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP连接可能会在没有对端知识的情况下变为不活跃。为了断开一个不活跃的连接，节点发送`**ping**`消息并期待`**pong**`作为响应。`**ping**`消息包含一个8字节的随机数nonce。在`**pong**`响应消息中，接收节点会回传它作为`**ping**`消息一部分收到的相同nonce消息。
- en: 'The following method parses the `**ping**` message and respond with the `**pong**`
    message:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法解析`**ping**`消息并响应`**pong**`消息：
- en: '`def parsePingPongPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parsePingPongPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘nonce’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘nonce’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`return payload`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def createPongPayload(nonce: int):`'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createPongPayload(nonce: int):`'
- en: '`nonce_b = struct.pack(‘<Q’, nonce)`'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonce_b = struct.pack(‘<Q'', nonce)`'
- en: '`return nonce_b`'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`return nonce_b`'
- en: '`def sendPongMessage(s: socket, recvmsg: dict):`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendPongMessage(s: socket, recvmsg: dict):`'
- en: '`# send pong message`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 发送pong消息`'
- en: '`sndcmd = ‘pong’`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘pong’`'
- en: '`nonce = recvmsg[‘payload’][‘nonce’]`'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonce = recvmsg[‘payload’][‘nonce’]`'
- en: '`payload = createPongPayload(nonce)`'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createPongPayload(nonce)`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '``s.send(sndmsg)``'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.send(sndmsg)`'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '**Program 7.9:** Program for sending ping and receiving pong messages'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序7.9：** 发送ping和接收pong消息的程序'
- en: If the peer responds with a different nonce or does not respond, then we can
    safely assume that it is not active, and we can disconnect the connection.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对等节点响应了一个不同的nonce或者没有响应，那么我们可以安全地假设它不活跃，我们可以断开连接。
- en: '[Node discovery](toc.xhtml#s137a)'
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[节点发现](toc.xhtml#s137a)'
- en: As you have learned, there are almost 10,000 active nodes on average, it is
    important to distribute load across the network. Almost 95% of the full nodes
    run Bitcoin Core, which has some hardcoded DNS seeds, so if these nodes only depend
    on addresses from the DNS seeds, then those addresses can get overloaded. This
    will hamper the decentralized nature of the Bitcoin network, will affect performance,
    and will be prone to **Denial-of-Service** (**DoS**) *attacks*.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学习的，平均几乎有10,000个活跃节点，重要的是要在网络上分配负载。几乎95%的全节点运行Bitcoin Core，它有一些硬编码的DNS种子，所以如果这些节点只依赖DNS种子提供的地址，那么这些地址可能会过载。这会损害比特币网络的去中心化特性，会影响性能，并且容易受到**服务拒绝**（**DoS**）*攻击*。
- en: 'To find new peers, we have the following sequence diagram:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到新的对等节点，我们有一个以下顺序图：
- en: '![](images/Figure-7.13.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.13.jpg)'
- en: '**Figure 7.13:** Sequence diagram showing the steps to receive addresses of
    nodes from peer'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.13：** 显示从对等节点接收节点地址步骤的顺序图'
- en: 'As in `**verack**`, `**getaddr**` doesn’t have a payload. Here’s the payload
    structure of the `**addr**` message:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`**verack**`一样，`**getaddr**`没有负载。以下是`**addr**`消息的负载结构：
- en: '![](images/Figure-7.14.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.14.jpg)'
- en: '**Figure 7.14:** Payload structure of addr'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.14：** addr的负载结构'
- en: 'Now, we will try to get the `**addr**` message from a peer. To get an `**addr**`
    message, we will need to handle a few more messages as these might be sent by
    the peer. Also, we will send a lower version to avoid getting the `**sendcmpct**`
    request. We will use version *70013*. The following is the program that sends
    `**getaddr**` and receives `**addr**`:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试从一个对等节点获取`**addr**`消息。为了获取`**addr**`消息，我们需要处理一些更多的消息，因为这些可能由对等节点发送。此外，我们将发送一个较低版本以避免`**sendcmpct**`请求。我们将使用版本*70013*。以下是将发送`**getaddr**`并接收`**addr**`的程序：
- en: '`def parseAddrPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseAddrPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘count’] = getVarInt(payload_m)`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘count’] = getVarInt(payload_m)`'
- en: '`payload[‘addrs’] = []`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘addrs’] = []`'
- en: '`for i in range(payload[‘count’]):`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘count’]):`'
- en: '`addr = {}`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr = {}`'
- en: '`addr[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`addr[‘addr’] = parseIPAddress(payload_m)`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr[‘addr’] = parseIPAddress(payload_m)`'
- en: '`payload[‘addrs’].append(addr)`'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘addrs’].append(addr)`'
- en: '`return payload`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHandler(s: socket, version: int):`'
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘建立连接失败’, file=flog)`'
- en: '`return`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`# send getaddr message`'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send getaddr message`'
- en: '`sndcmd = ‘getaddr’`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getaddr’`'
- en: '`payload = b’’`'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = b’’`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '``s.send(sndmsg)``'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`while True:`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '`recvmsg = recvMsg(s)`'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvmsg = recvMsg(s)`'
- en: '`if recvmsg[‘command’] == ‘addr’:`'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘addr’:`'
- en: '`break`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '`# send pong message`'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send pong message`'
- en: '`sndcmd = ‘pong’`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘pong’`'
- en: '`nonce = recvmsg[‘payload’][‘nonce’]`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonce = recvmsg[‘payload’][‘nonce’]`'
- en: '`payload = createPongPayload(nonce)`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createPongPayload(nonce)`'
- en: '`elif recvmsg[‘command’] == ‘getheaders’:`'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘getheaders’:`'
- en: '`# send header message`'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send header message`'
- en: '`sndcmd = ‘headers’`'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘headers’`'
- en: '`hashes = recvmsg[‘payload’][‘block locator hashes’]`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashes = recvmsg[‘payload’][‘block locator hashes’]`'
- en: '`stophash = recvmsg[‘payload’][‘hash_stop’]`'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`stophash = recvmsg[‘payload’][‘hash_stop’]`'
- en: '`payload = createHeadersPayload(hashes, stophash)`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createHeadersPayload(hashes, stophash)`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`if recvmsg[‘command’] == ‘addr’:`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘addr’:`'
- en: '`print(‘Received Addr’, file=flog)`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Received Addr’, file=flog)`'
- en: '**Program 7.10:** Program for sending getaddr and receiving addr'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序7.10:** 发送getaddr和接收addr的程序'
- en: We need to also handle the `**getheaders**` requests, which you will understand
    in the next and upcoming subtopics.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理`**getheaders**`请求，这将在下一个和即将到来的子主题中解释。
- en: 'We use following code to call the preceding methods. The same calling code
    will be used to call the upcoming methods:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码来调用前述方法。相同的调用代码将用于调用即将进行的方法：
- en: '`if __name__ == ‘__main__’:`'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ‘__main__’:`'
- en: '`peers = getTestnetPeers()`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`peers = getTestnetPeers()`'
- en: '`print(peers)`'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(peers)`'
- en: '``p = random.choice(peers)``'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '``p = random.choice(peers)``'
- en: '`s = None`'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = None`'
- en: '``peerinfo = {}``'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '``peerinfo = {}``'
- en: '`print(“Trying to connect to “, p, file=flog)`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(“Trying to connect to “, p, file=flog)`'
- en: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`'
- en: '``err = s.connect(p)``'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '``err = s.connect(p)``'
- en: '`print(‘connected’, file=flog)`'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘connected’, file=flog)`'
- en: '`sendrecvHandler(s, 70013)`'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendrecvHandler(s, 70013)`'
- en: '``s.close()``'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.close()``'
- en: '``flog.close()``'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '``flog.close()``'
- en: 'We get the following communication log:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下通信日志：
- en: '![](images/Figure-7.15.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.15.jpg)'
- en: '**Figure 7.15:** Communication log of receiving addr from peer'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 7.15:** 从对等节点接收addr的通信日志'
- en: '[Receiving full blockchain](toc.xhtml#s138a)'
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[接收完整的区块链](toc.xhtml#s138a)'
- en: When we install Bitcoin software and it first connects to the network, it syncs
    all the existing blocks of the blockchain. It tells its peers that its block height
    is zero and requests its peers to give blocks. This is called **Initial Block
    Download** (**IBD**). Since Bitcoin Core version 0.10.0, we are using the IBD
    method called **Headers First**.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装比特币软件并且第一次连接到网络时，它会同步区块链的所有现有区块。它告诉它的对等节点它的区块高度为零，并请求对等节点提供区块。这被称为**初始区块下载**（**IBD**）。自从比特币核心版本0.10.0以来，我们一直在使用名为**首先获取头部**的IBD方法。
- en: 'The following figure shows the steps involved in this:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这个过程的步骤：
- en: '![](images/Figure-7.16.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.16.jpg)'
- en: '**Figure 7.16:** Sequence diagram showing steps involved in IBD'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 7.16:** 显示IBD步骤的序列图'
- en: The new node initially only has a genesis block. It sends this block’s hash
    in the `**getheaders**` requests. The peer responds with `headers` message containing
    a list of header hashes. Bitcoin Core sends a list of up to 2,000 block hashes.
    On receiving the block hashes, the node verifies the block hash and then sends
    `**getdata**` requests to its peers with a part of the header hashes it has received.
    Since the node is connected with multiple peers, it can ask all its peers for
    different sets of block hashes. The requested peer responds with all the blocks
    one by one. Once the node has received the requested blocks, it can again make
    a `**getdata**` request with a list of received block hashes. This process continues
    till the node receives all the blocks and the node’s blockchain is fully synchronized
    with the network.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点最初只有一个创世区块。它在`**getheaders**`请求中发送此区块的哈希。节点以`headers`消息响应，包含一个区块头哈希列表。比特币核心发送最多2000个区块哈希的列表。在接收到区块哈希后，节点验证区块哈希，然后向其对等方发送包含其收到的部分区块头哈希的`**getdata**`请求。由于节点与多个对等方连接，它可以向所有对等方请求不同的区块哈希集合。请求的对等方一个接一个地响应所有区块。一旦节点收到了请求的区块，它可以再次使用包含接收到的区块哈希列表的`**getdata**`请求。这个过程一直持续，直到节点接收到所有区块，并且节点的区块链完全与网络同步。
- en: 'The following is the structure of the `**getheaders**`, `**headers**`*,* and
    `**getdata**` messages:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`**getheaders**`、`**headers**`和`**getdata**`消息的结构：
- en: '![](images/Figure-7.17.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.17.jpg)'
- en: '**Figure 7.17:** Payload structure of getheaders and getdata'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.17：** `getheaders`和`getdata`的负载结构'
- en: The structure of the `**block**` is the same as we discussed in *[Chapter 6,
    Blockchain, Transactions, and Mining](c06.xhtml)* in *[figure 6.6](c06.xhtml#fig6_6)*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`**block**`的结构与我们在*[第6章，区块链、交易和挖矿](c06.xhtml)*中讨论的*[图6.6](c06.xhtml#fig6_6)*相同。'
- en: 'In the following code, we are only sending two `**getheaders**` requests: the
    first one is with only the genesis block hash, and the next one has hashes of
    32 received blocks. This means we expect to receive two sets of 2000 blocks. We
    are making multiple `**getdata**` requests for each `headers` response. In the
    following code, each `**getdata**` request contains 16 block header hashes.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们仅发送了两个`**getheaders**`请求：第一个仅包含创世区块哈希，下一个包含32个接收到的区块哈希。这意味着我们期望接收两组2000个区块。我们对每个`headers`响应进行多个`**getdata**`请求。在以下代码中，每个`**getdata**`请求包含16个区块头哈希。
- en: '`def getGenesisBlockHash():`'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getGenesisBlockHash():`'
- en: '`blkhash = rpc_connection.getblockhash(0)`'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkhash = rpc_connection.getblockhash(0)`'
- en: '`return blkhash`'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`return blkhash`'
- en: '`def parseSendCompactPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseSendCompactPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘announce’] = int.from_bytes(payload_m.read(1), byteorder=’little’)`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘announce’] = int.from_bytes(payload_m.read(1), byteorder=’little’)`'
- en: '`payload[‘version’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘version’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`return payload`'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseFeeFilterPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseFeeFilterPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘feerate’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘feerate’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`return payload`'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '``mempool_l_g = []``'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '``mempool_l_g = []``'
- en: '`def parseInvPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseInvPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`MSG_TX = 1`'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_TX = 1`'
- en: '`payload = {}`'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘count’] = getVarInt(payload_m)`'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘count’] = getVarInt(payload_m)`'
- en: '`payload[‘inventory’] = []`'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘inventory’] = []`'
- en: '`for i in range(payload[‘count’]):`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘count’]):`'
- en: '`inv = {}`'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`inv = {}`'
- en: '`inv[‘type’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`inv[‘type’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`if inv[‘type’] == MSG_TX:`'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`if inv[‘type’] == MSG_TX:`'
- en: '`mempool = rpc_connection.getrawmempool(True)`'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`mempool = rpc_connection.getrawmempool(True)`'
- en: '`if (len(mempool_l_g) > 0):`'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (len(mempool_l_g) > 0):`'
- en: '`new_tx = set(mempool.keys()) ^ set(mempool_l_g[-1].keys())`'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_tx = set(mempool.keys()) ^ set(mempool_l_g[-1].keys())`'
- en: '`if len(new_tx) > 0:`'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(new_tx) > 0:`'
- en: '``mempool_l_g.append(mempool)``'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '``mempool_l_g.append(mempool)``'
- en: '`print(‘inserted mempool’, file=flog)`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘inserted mempool’, file=flog)`'
- en: '`else:`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`mempool_l_g.append(mempool)`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`mempool_l_g.append(mempool)`'
- en: '`print(‘inserted mempool’, file=flog)`'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘inserted mempool’, file=flog)`'
- en: '`inv[‘hash’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`inv[‘hash’] = payload_m.read(32)[::-1].hex()`'
- en: '`payload[‘inventory’].append(inv)`'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘inventory’].append(inv)`'
- en: '`return payload`'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseBlockHeader(payload_m: mmap):`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseBlockHeader(payload_m: mmap):`'
- en: '`hdr = {}`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr = {}`'
- en: '`hdr[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`hdr[‘prev_blockhash’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘prev_blockhash’] = payload_m.read(32)[::-1].hex()`'
- en: '`hdr[‘merkle_root’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘merkle_root’] = payload_m.read(32)[::-1].hex()`'
- en: '`hdr[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`hdr[‘bits’] = payload_m.read(4)[::-1].hex()`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘bits’] = payload_m.read(4)[::-1].hex()`'
- en: '`hdr[‘nonce’] = payload_m.read(4)[::-1].hex()`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘nonce’] = payload_m.read(4)[::-1].hex()`'
- en: '`return hdr`'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`return hdr`'
- en: '`def parseGetBlocksGetHeadersPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseGetBlocksGetHeadersPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`payload[‘hash count’] = getVarInt(payload_m)`'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘hash count’] = getVarInt(payload_m)`'
- en: '`payload[‘block locator hashes’] = []`'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘block locator hashes’] = []`'
- en: '`for i in range(payload[‘hash count’]):`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘hash count’]):`'
- en: '`h = payload_m.read(32)[::-1].hex()`'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = payload_m.read(32)[::-1].hex()`'
- en: '`payload[‘block locator hashes’].append(h)`'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘block locator hashes’].append(h)`'
- en: '`payload[‘hash_stop’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘hash_stop’] = payload_m.read(32)[::-1].hex()`'
- en: '`return payload`'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseHeadersPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseHeadersPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘count’] = getVarInt(payload_m)`'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘count’] = getVarInt(payload_m)`'
- en: '`payload[‘headers’] = []`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘headers’] = []`'
- en: '`for i in range(payload[‘count’]):`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘count’]):`'
- en: '`hdr = {}`'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr = {}`'
- en: '``start = payload_m.tell()``'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '``start = payload_m.tell()``'
- en: '`h_b = hashlib.sha256(payload_m.read(80)).digest()`'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`h_b = hashlib.sha256(payload_m.read(80)).digest()`'
- en: '`hdr[‘blkhash’] = hashlib.sha256(h_b).digest()[::-1].hex()`'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘blkhash’] = hashlib.sha256(h_b).digest()[::-1].hex()`'
- en: '`payload_m.seek(start)`'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload_m.seek(start)`'
- en: '`hdr[‘header’] = parseBlockHeader(payload_m)`'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘header’] = parseBlockHeader(payload_m)`'
- en: '`hdr[‘txn_count’] = getVarInt(payload_m)`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr[‘txn_count’] = getVarInt(payload_m)`'
- en: '`payload[‘headers’].append(hdr)`'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘headers’].append(hdr)`'
- en: '`return payload`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseTxPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseTxPayload(payload_m: mmap, payloadlen = 0):`'
- en: '``payload = {}``'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = {}``'
- en: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`payload[‘tx_in count’] = getVarInt(payload_m)`'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_in count’] = getVarInt(payload_m)`'
- en: '`payload[‘tx_in’] = []`'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_in’] = []`'
- en: '`for i in range(payload[‘tx_in count’]):`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘tx_in count’]):`'
- en: '``txin = {}``'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '``txin = {}``'
- en: '`txin[‘prev_tx_hash’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`txin[‘prev_tx_hash’] = payload_m.read(32)[::-1].hex()`'
- en: '`txin[‘prev_tx_out_index’] = int.from_bytes(payload_m.read(4),`'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`txin[‘prev_tx_out_index’] = int.from_bytes(payload_m.read(4),`'
- en: '`byteorder=’little’)`'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`byteorder=’little’)`'
- en: '`txin[‘bytes_scriptsig’] = getVarInt(payload_m)`'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '`txin[‘bytes_scriptsig’] = getVarInt(payload_m)`'
- en: '`txin[‘sriptsig’] = payload_m.read(txin[‘bytes_scriptsig’]).hex()`'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`txin[‘sriptsig’] = payload_m.read(txin[‘bytes_scriptsig’]).hex()`'
- en: '`txin[‘sequence’] = payload_m.read(4)[::-1].hex()`'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`txin[‘sequence’] = payload_m.read(4)[::-1].hex()`'
- en: '`payload[‘tx_in’].append(txin)`'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_in’].append(txin)`'
- en: '`payload[‘tx_out count’] = getVarInt(payload_m)`'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_out count’] = getVarInt(payload_m)`'
- en: '`payload[‘tx_out’] = []`'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_out’] = []`'
- en: '`for i in range(payload[‘tx_out count’]):`'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘tx_out count’]):`'
- en: '``txout = {}``'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '``txout = {}``'
- en: '`txout[‘satoshis’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`txout[‘satoshis’] = int.from_bytes(payload_m.read(8), byteorder=’little’)`'
- en: '`txout[‘bytes_scriptpubkey’] = getVarInt(payload_m)`'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`txout[‘bytes_scriptpubkey’] = getVarInt(payload_m)`'
- en: '`txout[‘scriptpubkey’] = payload_m.read(txout[‘bytes_scriptpubkey’]).hex()`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`txout[‘scriptpubkey’] = payload_m.read(txout[‘bytes_scriptpubkey’]).hex()`'
- en: '`payload[‘tx_out’].append(txout)`'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘tx_out’].append(txout)`'
- en: '`payload[‘locktime’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘locktime’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`return payload`'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseBlockPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseBlockPayload(payload_m: mmap, payloadlen = 0):`'
- en: '``payload = {}``'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = {}``'
- en: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘version’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`payload[‘prev_blockhash’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘prev_blockhash’] = payload_m.read(32)[::-1].hex()`'
- en: '`payload[‘merkle_root’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘merkle_root’] = payload_m.read(32)[::-1].hex()`'
- en: '`payload[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘timestamp’] = int.from_bytes(payload_m.read(4), byteorder=’little’)`'
- en: '`payload[‘bits’] = payload_m.read(4)[::-1].hex()`'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘bits’] = payload_m.read(4)[::-1].hex()`'
- en: '`payload[‘nonce’] = payload_m.read(4)[::-1].hex()`'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘nonce’] = payload_m.read(4)[::-1].hex()`'
- en: '`payload[‘txn_count’] = getVarInt(payload_m)`'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txn_count’] = getVarInt(payload_m)`'
- en: '`payload[‘txns’] = []`'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txns’] = []`'
- en: '`for i in range(payload[‘txn_count’]):`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘txn_count’]):`'
- en: '`payload[‘txns’].append(parseTxPayload(payload_m))`'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txns’].append(parseTxPayload(payload_m))`'
- en: '`return payload`'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def createGetHeadersPayload(hdr_info_l: list, version: int):`'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createGetHeadersPayload(hdr_info_l: list, version: int):`'
- en: '`version_b = struct.pack(‘<L’, version)`'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = struct.pack(‘<L’, version)`'
- en: '`blk_locator_hashes_b = b’’`'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_locator_hashes_b = b’’`'
- en: '`count = 0`'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = 0`'
- en: '`for i in range(len(hdr_info_l) - 1, len(hdr_info_l) - 32, -1):`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(len(hdr_info_l) - 1, len(hdr_info_l) - 32, -1):`'
- en: '`if i < 1: # assuming first block is genesis`'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`if i < 1: # assuming first block is genesis`'
- en: '`break`'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`blk_locator_hashes_b += bytes.fromhex(hdr_info_l[i][‘blkhash’])[::-1]`'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_locator_hashes_b += bytes.fromhex(hdr_info_l[i][‘blkhash’])[::-1]`'
- en: '`count += 1`'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`count += 1`'
- en: '`blk_locator_hashes_b += bytes.fromhex(getGenesisBlockHash())[::-1]`'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_locator_hashes_b += bytes.fromhex(getGenesisBlockHash())[::-1]`'
- en: '`count += 1`'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '`count += 1`'
- en: '``hash_count_b = setVarInt(count)``'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '``hash_count_b = setVarInt(count)``'
- en: '`stop_hash_b = bytes(32)`'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop_hash_b = bytes(32)`'
- en: '`payload = version_b \`'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = version_b \`'
- en: '`+ hash_count_b \`'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ hash_count_b \`'
- en: '`+ blk_locator_hashes_b \`'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ blk_locator_hashes_b \`'
- en: '`+ stop_hash_b`'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`+ stop_hash_b`'
- en: '`return payload`'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def waitForBlock(s: socket):`'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForBlock(s: socket):`'
- en: '`while True:`'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``'
- en: '`if recvmsg[‘command’] == ‘block’:`'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘block’:`'
- en: '`break`'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '``sendPongMessage(s, recvmsg)``'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendPongMessage(s, recvmsg)``'
- en: '`return recvmsg`'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`def sendGetHeadersMessage(s: socket, hdr_info_l: list, version: int):`'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendGetHeadersMessage(s: socket, hdr_info_l: list, version: int):`'
- en: '`sndcmd = ‘getheaders’`'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getheaders’`'
- en: '``payload = createGetHeadersPayload(hdr_info_l, version)``'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = createGetHeadersPayload(hdr_info_l, version)``'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def waitForHeaders(s: socket):`'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForHeaders(s: socket):`'
- en: '`while True:`'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``'
- en: '`if recvmsg[‘command’] == ‘headers’:`'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘headers’:`'
- en: '`break`'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '``sendPongMessage(s, recvmsg)``'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendPongMessage(s, recvmsg)``'
- en: '`return recvmsg`'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`def createGetDataPayload(count: int, hash_l: list):`'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createGetDataPayload(count: int, hash_l: list):`'
- en: '`MSG_BLOCK = 2`'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_BLOCK = 2`'
- en: '`hash_count_b = setVarInt(count)`'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash_count_b = setVarInt(count)`'
- en: '`hashes_b = b’’`'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashes_b = b’’`'
- en: '`for i in range(count):`'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(count):`'
- en: '`type_b = struct.pack(‘<L’, MSG_BLOCK)`'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_b = struct.pack(‘<L’, MSG_BLOCK)`'
- en: '`hashes_b += type_b + bytes.fromhex(hash_l[i][‘blkhash’])[::-1]`'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashes_b += type_b + bytes.fromhex(hash_l[i][‘blkhash’])[::-1]`'
- en: '`payload_b = hash_count_b + hashes_b`'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload_b = hash_count_b + hashes_b`'
- en: '`return payload_b`'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload_b`'
- en: '`def sendGetDataMessage(s: socket, count: int, hash_l: list):`'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendGetDataMessage(s: socket, count: int, hash_l: list):`'
- en: '`sndcmd = ‘getdata’`'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getdata’`'
- en: '``payload = createGetDataPayload(count, hash_l)``'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = createGetDataPayload(count, hash_l)``'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def sendAndHandleGetHeaders(s: socket, hdr_info_l: list, version: int):`'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendAndHandleGetHeaders(s: socket, hdr_info_l: list, version: int):`'
- en: '``sendGetHeadersMessage(s, hdr_info_l, version)``'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendGetHeadersMessage(s, hdr_info_l, version)``'
- en: '``recvmsg = waitForHeaders(s)``'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = waitForHeaders(s)``'
- en: '`count = recvmsg[‘payload’][‘count’]`'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = recvmsg[‘payload’][‘count’]`'
- en: '`for i in range(0, count, 16):`'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(0, count, 16):`  '
- en: '`lindex = i + 16 if i + 16 < count else count`'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`lindex = i + 16 if i + 16 < count else count`  '
- en: '`print(i, lindex)`'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(i, lindex)`  '
- en: '`blk_l = recvmsg[‘payload’][‘headers’][i:lindex]`'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_l = recvmsg[‘payload’][‘headers’][i:lindex]`  '
- en: '`sendGetDataMessage(s, lindex - i, blk_l)`'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendGetDataMessage(s, lindex - i, blk_l)`  '
- en: '`for j in range(i, lindex):`'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '`for j in range(i, lindex):`  '
- en: '``waitForBlock(s)``'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitForBlock(s)``  '
- en: '`return recvmsg`'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`  '
- en: '`def sendrecvHeadersData(s: socket, version: int):`'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHeadersData(s: socket, version: int):`  '
- en: '``recvmsg = sendAndHandleGetHeaders(s, [], version)``'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = sendAndHandleGetHeaders(s, [], version)``  '
- en: '`sendAndHandleGetHeaders(s, recvmsg[‘payload’][‘headers’], version)`'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendAndHandleGetHeaders(s, recvmsg[‘payload’][‘headers’], version)`  '
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHandler(s: socket, version: int):`  '
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`  '
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Establish connection failed’, file=flog)`  '
- en: '``return``'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '``return``  '
- en: '``sendrecvHeadersData(s, version)``'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendrecvHeadersData(s, version)``  '
- en: '**Program 7.11:** Program for making IBD request to peer and receiving blocks'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**Program 7.11:** Program for making IBD request to peer and receiving blocks  '
- en: 'This gives the following output. First, we send the `**getheaders**` request
    with genesis block hash and no hash stop:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 'This gives the following output. First, we send the `**getheaders**` request
    with genesis block hash and no hash stop:  '
- en: '![](images/Figure-7.18.jpg)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.18.jpg)  '
- en: '**Figure 7.18:** getheaders request sent to the peer'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 7.18:** getheaders request sent to the peer  '
- en: 'The following is the truncated ***headers*** response containing 2,000 headers:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following is the truncated ***headers*** response containing 2,000 headers:  '
- en: '![](images/Figure-7.19.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.19.jpg)  '
- en: '**Figure 7.19:** Received headers response from the peer'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.19:** 从对等节点接收到头部响应'
- en: 'We responded with `**getdata**` requesting 16 blocks. Here’s the request:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回应了一个 `**getdata**` 请求，请求 16 个区块。请求内容如下：
- en: '![](images/Figure-7.20.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.20.jpg)'
- en: '**Figure 7.20:** Sent getdata request to the peer'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.20:** 向对等节点发送 getdata 请求'
- en: 'We got 16 blocks, and the following is one of them:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了 16 个区块，以下是其中之一：
- en: '![](images/Figure-7.21.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.21.jpg)'
- en: '**Figure 7.21:** Received block in response from the peer'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.21:** 从对等节点接收到的区块'
- en: After 16 blocks are received, we requested the next 16 blocks and again got
    16 blocks. This continued till all 2,000 blocks are received. A node also needs
    to verify each block according to the consensus rules. Some of these consensus
    rules were covered in *[Chapter 6, Blockchain, Transactions, and Mining](c06.xhtml)*.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到 16 个区块后，我们请求下一个 16 个区块，并再次获得 16 个区块。这个过程一直持续，直到我们接收到所有的 2,000 个区块。节点还需要根据共识规则验证每个区块。这些共识规则中的一些在
    *[第 6 章，区块链、交易和挖矿](c06.xhtml)* 中已经介绍过。
- en: 'After receiving 2,000 blocks, we again send `**getheaders**` requests with
    a list of the last 31 block hashes and the genesis block hash, making it 32 hashes.
    The following is the part of the request:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到 2,000 个区块后，我们再次发送 `**getheaders**` 请求，包含最后 31 个区块哈希列表和创世区块哈希，共计 32 个哈希。以下是请求的部分内容：
- en: '![](images/Figure-7.22.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.22.jpg)'
- en: '**Figure 7.22:** Truncated getheaders request made to the peer'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.22:** 向对等节点发送截断的 getheaders 请求'
- en: We again got the next 2,000 block `**headers**`*,* and we repeated the process.
    This can be continued till we receive all the blocks. Once less than 2,000 `**headers**`
    are received, we can also send `**getheaders**` request to other peers. By sending
    `**getheaders**` requests to other peers, we can guess the best blockchain and
    keep blocks in different chains to be able to undo blocks.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次获取了下一个 2,000 个区块的 `**headers**`*，并重复了该过程。这个过程可以一直持续，直到我们接收到所有的区块。一旦接收到的
    `**headers**` 少于 2,000 个，我们也可以向其他对等节点发送 `**getheaders**` 请求。通过向其他对等节点发送 `**getheaders**`
    请求，我们可以猜测最优质的区块链，并保持不同链上的区块，以便能够撤销区块。
- en: The IBD method is also used to synchronize blocks if blockchain is more than
    24 hours behind.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 如果区块链落后于 24 小时以上，还可以使用 IBD 方法同步区块。
- en: '[Synchronizing blockchain](toc.xhtml#s139a)'
  id: totrans-787
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[同步区块链](toc.xhtml#s139a)'
- en: If our node is less than 24 hours behind, we must consider the possibility that
    there may be competing chains. In this case, we need to get blocks from different
    peers and keep the blocks in competing chains to undo them if the other chain
    becomes longer. We use the same method to get blocks as in the last subtopic,
    the only difference here is that we are getting blocks from multiple peers. Our
    node also needs to decide which chain it needs to consider best and generally,
    the longer chain is preferred.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的节点落后于 24 小时以内，我们必须考虑可能存在竞争链的情况。在这种情况下，我们需要从不同的对等节点获取区块，并保持竞争链上的区块，以便如果另一条链更长时可以撤销它们。我们使用与上一个小节相同的方法获取区块，唯一的区别是我们现在是从多个对等节点获取区块。我们的节点还需要决定哪个链是最优的，通常情况下，更长的链是被优先考虑的。
- en: '[Transaction broadcasting](toc.xhtml#s140a)'
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[交易广播](toc.xhtml#s140a)'
- en: As we know, to spend an unspent output available as UTXO, we create a transaction
    and send it to the peer. We may also receive a transaction from our peers, which
    we may need to send to other peers. In this subtopic, we will understand how a
    node receives a transaction.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，要花费作为 UTXO 存在的未花费输出，我们需要创建一个交易并发送给对等节点。我们可能还需要从对等节点接收交易，然后发送给其他对等节点。在本小节中，我们将了解节点是如何接收交易的。
- en: 'The following figure shows the steps involved in getting transactions:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了获取交易步骤的过程：
- en: '![](images/Figure-7.23.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.23.jpg)'
- en: '**Figure 7.23:** Sequence diagram showing the steps involved in transaction
    broadcast'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.23:** 显示交易广播步骤的序列图'
- en: When a node receives a transaction, it sends an `**inv**` message to its peer.
    The peer node checks whether it has seen the transaction earlier. If not, it sends
    back `**getdata**` requests with option `**MSG_TX**` and the `**txid**`. The node
    that had sent the `**inv**` message responds with the actual raw transaction.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点接收到一个交易时，它会将其发送给对等节点的 `**inv**` 消息。对等节点检查它是否之前见过这个交易。如果没有，它会返回带有 `**MSG_TX**`
    选项和 `**txid**` 的 `**getdata**` 请求。发送 `**inv**` 消息的节点回应实际的原始交易。
- en: '`**inv**` has the same payload structure as `**getdata**`. The `**tx**` message
    has the same message structure as the Bitcoin transaction we discussed in *[Chapter
    6, Blockchain, Transactions, and Mining](c06.xhtml), [figure 6.30](c06.xhtml#fig6_30)*.'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`**inv**` has the same payload structure as `**getdata**`. The `**tx**` message
    has the same message structure as the Bitcoin transaction we discussed in *[Chapter
    6, Blockchain, Transactions, and Mining](c06.xhtml), [figure 6.30](c06.xhtml#fig6_30)*.  '
- en: 'The following code processes the `**inv**` message if it has the option `**MSG_TX**`:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following code processes the `**inv**` message if it has the option `**MSG_TX**`:  '
- en: '`def createGetDataTxPayload(payload: dict):`'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createGetDataTxPayload(payload: dict):`  '
- en: '`MSG_TX = 1`'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_TX = 1`  '
- en: '`data_b = b’’`'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_b = b’’`  '
- en: '`count = 0`'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = 0`  '
- en: '`for i in range(payload[‘count’]):`'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘count’]):`  '
- en: '`# we only request data for tx`'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '`# we only request data for tx`  '
- en: '`if payload[‘inventory’][i][‘type’] == MSG_TX:`'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`if payload[‘inventory’][i][‘type’] == MSG_TX:`  '
- en: '`type_b = struct.pack(‘<L’, payload[‘inventory’][i][‘type’])`'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_b = struct.pack(‘<L’, payload[‘inventory’][i][‘type’])`  '
- en: '`hash_b = bytes.fromhex(payload[‘inventory’][i][‘hash’])[::-1]`'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash_b = bytes.fromhex(payload[‘inventory’][i][‘hash’])[::-1]`  '
- en: '``data_b += type_b + hash_b``'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '``data_b += type_b + hash_b``  '
- en: '`count += 1`'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`count += 1`  '
- en: '``count_b = setVarInt(count)``'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '``count_b = setVarInt(count)``  '
- en: '``payload_b = count_b + data_b``'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload_b = count_b + data_b``  '
- en: '``return count, payload_b``'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '``return count, payload_b``  '
- en: '`def waitForInvMessage(s: socket):`'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForInvMessage(s: socket):`  '
- en: '`while True:`'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`  '
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``  '
- en: '`if recvmsg[‘command’] == ‘inv’:`'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘inv’:`  '
- en: '`break`'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`  '
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`  '
- en: '``sendPongMessage(s, recvmsg)``'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendPongMessage(s, recvmsg)``  '
- en: '`print(‘Received INV’, file=flog)`'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘收到 INV’, file=flog)`'
- en: '`return recvmsg`'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`def waitForTxMsg(s: socket):`'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForTxMsg(s: socket):`'
- en: '`while True:`'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``'
- en: '`if recvmsg[‘command’] == ‘tx’:`'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘tx’:`'
- en: '``break``'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '``break``'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '`sendPongMessage(s, recvmsg)`'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendPongMessage(s, recvmsg)`'
- en: '`def sendGetDataMessageWithTx(s: socket, recvmsg: dict):`'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendGetDataMessageWithTx(s: socket, recvmsg: dict):`'
- en: '`sndcmd = ‘getdata’`'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getdata’`'
- en: '`count, payload = createGetDataTxPayload(recvmsg[‘payload’])`'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '`count, payload = createGetDataTxPayload(recvmsg[‘payload’])`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> 命令 = %s, 消息 = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`return count`'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`return count`'
- en: '`def waitAndHandleInvTxnMessage(s: socket):`'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitAndHandleInvTxnMessage(s: socket):`'
- en: '``recvmsg = waitForInvMessage(s)``'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = waitForInvMessage(s)``'
- en: '``count = sendGetDataMessageWithTx(s, recvmsg)``'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '``count = sendGetDataMessageWithTx(s, recvmsg)``'
- en: '`for i in range(count):`'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(count):`'
- en: '``waitForTxMsg(s)``'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitForTxMsg(s)``'
- en: '`def sendrecvHeadersData(s: socket):`'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHeadersData(s: socket):`'
- en: '``waitAndHandleInvTxnMessage(s)``'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitAndHandleInvTxnMessage(s)``'
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHandler(s: socket, version: int):`'
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘建立连接失败’, file=flog)`'
- en: '``return``'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '``return``'
- en: '``sendrecvHeadersData(s)``'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendrecvHeadersData(s)``'
- en: '**Program 7.12:** Program for receiving and processing inv messages for transactions'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.12：** 用于接收和处理交易的 inv 消息的程序'
- en: 'The following are the communication logs showing the received `**inv**` message
    and the sent `**getdata**` message with a request for two transactions:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通信日志，显示了接收的 `**inv**` 消息和发送的带有对两笔交易的请求的 `**getdata**` 消息：
- en: '![](images/Figure-7.24.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.24.jpg)'
- en: '**Figure 7.24:** The inv message received from peer and the getdata request
    made to the peer in response'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.24：** 从节点接收的 `inv` 消息以及作为响应向节点发出的 `getdata` 请求'
- en: 'We received two transactions as requested by our node:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据我们的节点的请求收到了两笔交易：
- en: '![](images/Figure-7.25.jpg)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.25.jpg)'
- en: '**Figure 7.25:** tx messages containing transactions received from the peer
    in response to the getdata request'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.25：** 包含响应 `getdata` 请求从节点收到的交易的 tx 消息'
- en: Our node can send a received transaction to other connected nodes by first sending
    an `**inv**` message with the transaction IDs of the received transactions. This
    process continues till all active nodes have received the transaction.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的节点可以通过首先发送一个带有收到的交易的交易ID的 `**inv**` 消息来将收到的交易发送到其他连接的节点。这个过程一直持续到所有活动节点都收到了交易。
- en: In this subtopic, you learned how a transaction is broadcast on the Bitcoin
    network.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子主题中，您学习了在比特币网络上如何广播交易。
- en: '[Block broadcasting](toc.xhtml#s141a)'
  id: totrans-855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块广播](toc.xhtml#s141a)'
- en: Blocks also need to be propagated on the network as quickly as possible so that
    even the farthest node receives it in a reasonable time and, consequently, does
    not create too many or too long competing branches. Before we can receive recent
    blocks, we need to synchronize our node with the connected peer so that the peer
    is aware that our node is not lagging, and our node will be able to verify the
    recently received block.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 区块也需要在网络上尽快传播，以便即使最远的节点也能在合理的时间内收到它，从而不会创建太多或太长的竞争分支。在我们能够接收到最新的区块之前，我们需要与连接的节点同步，以便同伴知道我们的节点没有落后，我们的节点将能够验证最近接收的区块。
- en: Once blockchain is synchronized, we are ready for live updates from peers.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦区块链同步完成，我们就准备好接收同伴的实时更新。
- en: 'Here are the different methods to broadcast blocks:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是广播区块的不同方法：
- en: A miner that has mined a new block instead just broadcasts the new block via
    `**block**` message. This is called **Unsolicited Block Push**.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矿工挖出新区块时，只需通过`**block**`消息广播新区块。这被称为**未请求区块推送**。
- en: 'For a normal node, there are three methods to receive new blocks. These methods
    are called **Direct Headers Announcements**. This is enabled either by the `**sendheaders**`
    method or the `**sendcmpct**` message. The `**sendheaders**` method is the legacy
    Direct headers announcement method, which is available since 70012, while the
    `**sendcmpct**` method was introduced in 70014\. The following sub-points explain
    them:'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个普通节点，有三种方法可以接收新区块。这些方法被称为**直接头部声明**。这可以通过`**sendheaders**`方法或`**sendcmpct**`消息来实现。`**sendheaders**`方法是传统的直接头部声明方法，自70012以来一直可用，而`**sendcmpct**`方法是在70014中引入的。以下子点解释了它们：
- en: The node sends `**sendheaders**` immediately after the connection is established.
    This indicates to the peer that whenever it receives a new block, it can send
    *headers*. Based on `**headers**`, we can request `**getdata**`. And as a response
    to `**getdata**`*,* the peer sends blocks.
  id: totrans-861
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点在连接建立后立即发送`**sendheaders**`。这告诉同伴，每当它接收到一个新的区块时，它可以发送*headers*。基于`**headers**`，我们可以请求`**getdata**`。作为对`**getdata**`的响应，同伴发送区块。
- en: 'Relay latency can be further reduced by requesting compact blocks. The `**sendcmpct**`
    message can be sent immediately after the connection is established. There are
    two methods:'
  id: totrans-862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过请求紧凑区块，可以进一步减少中继延迟。可以在连接建立后立即发送`**sendcmpct**`消息。有两种方法：
- en: '**High Bandwidth Relay:** Whenever the peer receives a block, it sends `**cmpctblock**`.
    It contains a header and a list of short IDs. We look at `**mempool**` for a list
    of transaction IDs based on short IDs and reconstruct the block. If there are
    missing transactions in `**mempool**`, we request only those missing transactions
    by sending `**getblocktxn**`. And the peer responds with a `**blocktxn**` message
    containing the transactions.'
  id: totrans-863
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高带宽中继：** 每当同伴接收到一个区块时，它会发送`**cmpctblock**`。它包含一个头部和一个短ID列表。我们查看`**mempool**`，根据短ID获取交易ID列表，并重建区块。如果在`**mempool**`中缺少交易，我们通过发送`**getblocktxn**`仅请求那些缺失的交易。同伴用包含交易的`**blocktxn**`消息响应。'
- en: '**Low Bandwidth Relay:** Whenever the peer receives a block, it sends a `headers`
    message. We send a `**getdata**` *message with the* `**MSG_CMPCT_BLOCK**` type
    as a response. The peer responds with `**cmpctblock**`, and further processing
    is like in **high bandwidth relay**.'
  id: totrans-864
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低带宽中继：** 每当同伴接收到一个区块时，它会发送一个`headers`消息。我们发送一个`**getdata**`消息作为响应，带有`**MSG_CMPCT_BLOCK**`类型。同伴用`**cmpctblock**`响应，进一步处理类似于**高带宽中继**。'
- en: '[Unsolicited Block Push](toc.xhtml#s142a)'
  id: totrans-865
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**未请求区块推送](toc.xhtml#s142a)'
- en: The following figure shows an **unsolicited block push** by the miner, which
    has successfully mined a block. A miner does not need to first send ***headers***
    messages as it knows the peer will not have it. It also does not need to synchronize
    its node with peers as it can only mine a block if it is aware of the previous
    node in the chain.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了矿工成功挖出区块后的**未请求区块推送**。矿工不需要首先发送*headers*消息，因为它知道同伴不会有它。它也不需要与同伴同步节点，因为它只有在知道链中前一个节点的情况下才能挖出区块。
- en: '![](images/Figure-7.26.jpg)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.26.jpg)'
- en: '**Figure 7.26:** Illustration of miner broadcasting newly generated block to
    peers using Unsolicited Block Push'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.26：** 矿工使用未请求区块推送向同伴广播新生成区块的说明。'
- en: We can see that in the figure, a miner just pushes the newly mined block to
    all the connected peers. A miner does not require any other communication.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们可以看到，矿工刚刚将新挖出的区块推送给所有连接的同伴。矿工不需要进行其他通信。
- en: '[Direct Headers Announcements](toc.xhtml#s143a)'
  id: totrans-870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[直接头部声明](toc.xhtml#s143a)'
- en: 'The following figure shows Direct headers announcements (Legacy):'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了直接头部声明（传统方式）：
- en: '![](images/Figure-7.27.jpg)'
  id: totrans-872
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.27.jpg)'
- en: '**Figure 7.27:** Sequence diagram of the steps involved in Direct headers announcements
    (Legacy)'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.27**：直接头部声明（传统方式）的序列图'
- en: After a connection is established, we immediately send the `**sendheaders**`
    message to a peer to make the peer aware that instead of `**inv**` messages, the
    peer can directly send `***headers***` message for recently received new blocks.
    Before the peer can broadcast new blocks, we need to make the peer aware of the
    list of blocks we are holding. For this, we need to send a list of block hashes
    in reverse order, starting with recently received blocks and ending with the genesis
    block in `**getheaders**` requests. This is the same as we learned in the previous
    subtopic. As a response, the peer sends all the missing blocks in the blockchain.
    If there are no new blocks with the peer, then it sends a **headers** message
    as a response with count zero.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接后，我们立即向对等节点发送`**sendheaders**`消息，使对等节点意识到，与其发送`**
- en: Once the peer is aware of the blockchain we are holding and has all the blocks
    in sync with the peer, we can receive new blocks from the peer. Note that our
    best blockchain may be different from peers’ best blockchain, so we need to be
    receiving blocks from different peers.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对等节点意识到我们持有的区块链并且与该节点同步了所有区块，我们就可以从对等节点接收新区块。请注意，我们的最长区块链可能与对等节点的最长区块链不同，因此我们需要从不同的对等节点接收区块。
- en: 'In the following piece of code, the connection is already established and now
    we are sending and handling requests required for receiving new blocks:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，连接已经建立，现在我们正在发送和处理接收新区块所需的消息：
- en: '`def sendSendHeadersMessage(s: socket):`'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendSendHeadersMessage(s: socket):`'
- en: '`sndcmd = ‘sendheaders’`'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘sendheaders’`'
- en: '`payload = b’’`'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = b’’`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def createHeadersPayloadNoHeaders():`'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createHeadersPayloadNoHeaders():`'
- en: '`cnt_b = setVarInt(0)`'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '`cnt_b = setVarInt(0)`'
- en: '`headers_b = b’’`'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers_b = b’’`'
- en: '``payload = cnt_b + headers_b``'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = cnt_b + headers_b``'
- en: '``return payload``'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '``return payload``'
- en: '`def createHeadersPayload(hashes, stophash):`'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createHeadersPayload(hashes, stophash):`'
- en: '`b_cnt_d = {‘fd’: 2, ‘fe’: 4, ‘ff’: 8}`'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '`b_cnt_d = {‘fd’: 2, ‘fe’: 4, ‘ff’: 8}`'
- en: '`found = False`'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '`found = False`'
- en: '`for blk_hash in hashes:`'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '`for blk_hash in hashes:`'
- en: '``try:``'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '``try:``'
- en: '`blk = rpc_connection.getblock(blk_hash)`'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk = rpc_connection.getblock(blk_hash)`'
- en: '`found = True`'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '`found = True`'
- en: '``break``'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '``break``'
- en: '`except Exception as e:`'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '`except Exception as e:`'
- en: '``continue``'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '``continue``'
- en: '`if found == True:`'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '`if found == True:`'
- en: '`txcnt = 0`'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '`txcnt = 0`'
- en: '``txcnt_b = setVarInt(txcnt)``'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '``txcnt_b = setVarInt(txcnt)``'
- en: '`headers_b = b’’`'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers_b = b’’`'
- en: '`count = 0`'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = 0`'
- en: '`while True:`'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '``# returns block hex``'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '``# 返回区块十六进制``'
- en: '`print(‘block_hash = %s’ % blk_hash, file=flog)`'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘block_hash = %s’ % blk_hash, file=flog)`'
- en: '`blk = rpc_connection.getblock(blk_hash, False)`'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk = rpc_connection.getblock(blk_hash, False)`'
- en: '`blk_b = bytes.fromhex(blk)`'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_b = bytes.fromhex(blk)`'
- en: '`blkhdr_b = blk_b[:80]`'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkhdr_b = blk_b[:80]`'
- en: '``headers_b += blkhdr_b + txcnt_b``'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '``headers_b += blkhdr_b + txcnt_b``'
- en: '``blk = rpc_connection.getblock(blk_hash)``'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '``blk = rpc_connection.getblock(blk_hash)``'
- en: '`count += 1`'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`count += 1`'
- en: '`if count == 2000 or ‘nextblockhash’ not in blk or stophash == blk_hash:`'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '`if count == 2000 or ‘nextblockhash’ not in blk or stophash == blk_hash:`'
- en: '`print(count, file=flog)`'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(count, file=flog)`'
- en: '`print(stophash, file=flog)`'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(stophash, file=flog)`'
- en: '``break``'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '``break``'
- en: '`blk_hash = blk[‘nextblockhash’]`'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_hash = blk[‘nextblockhash’]`'
- en: '``cnt_b = setVarInt(count)``'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '``cnt_b = setVarInt(count)``'
- en: '``payload = cnt_b + headers_b``'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = cnt_b + headers_b``'
- en: '``else:``'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '``else:``'
- en: '`cnt_b = setVarInt(0)`'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '`cnt_b = setVarInt(0)`'
- en: '`headers_b = b’’`'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers_b = b’’`'
- en: '``payload = cnt_b + headers_b``'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = cnt_b + headers_b``'
- en: '``return payload``'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '``return payload``'
- en: '`def waitForHeaders(s: socket):`'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForHeaders(s: socket):`'
- en: '`while True:`'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '``recvmsg = recvMsg(s)``'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = recvMsg(s)``'
- en: '`if recvmsg[‘command’] == ‘headers’:`'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘headers’:`'
- en: '``break``'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '``break``'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '``sendPongMessage(s, recvmsg)``'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendPongMessage(s, recvmsg)``'
- en: '`elif recvmsg[‘command’] == ‘getheaders’:`'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘getheaders’:`'
- en: '``sendHeadersMessage(s)``'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendHeadersMessage(s)``'
- en: '``return recvmsg``'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '``return recvmsg``'
- en: '`def waitAndHandleHeaderResponse(s: socket):`'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitAndHandleHeaderResponse(s: socket):`'
- en: '``recvmsg = waitForHeaders(s)``'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = waitForHeaders(s)``'
- en: '`count = recvmsg[‘payload’][‘count’]`'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = recvmsg[‘payload’][‘count’]`'
- en: '`for i in range(0, count, 16):`'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(0, count, 16):`'
- en: '`lindex = i + 16 if i + 16 < count else count`'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '`lindex = i + 16 if i + 16 < count else count`'
- en: '`blk_l = recvmsg[‘payload’][‘headers’][i:lindex]`'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_l = recvmsg[‘payload’][‘headers’][i:lindex]`'
- en: '``sendGetDataMessage(s, lindex - i, blk_l)``'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendGetDataMessage(s, lindex - i, blk_l)``'
- en: '`for j in range(i, lindex):`'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '`for j in range(i, lindex):`'
- en: '``waitForBlock(s)``'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitForBlock(s)``'
- en: '`def getBlockHashListFromCoreClient():`'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '`def getBlockHashListFromCoreClient():`'
- en: '``blkhash_l = []``'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '``blkhash_l = []``'
- en: '``height = getLastBlockHeight()``'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '``height = getLastBlockHeight()``'
- en: '`for i in range(31, -1, -1):`'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(31, -1, -1):`'
- en: '``d = {}``'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '``d = {}``'
- en: '`d[‘blkhash’] = rpc_connection.getblockhash(height - i)`'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '`d[‘blkhash’] = rpc_connection.getblockhash(height - i)`'
- en: '``blkhash_l.append(d)``'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '``blkhash_l.append(d)``'
- en: '``return blkhash_l``'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '``return blkhash_l``'
- en: '`def sendrecvHeadersData(s: socket, version: int):`'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHeadersData(s: socket, version: int):`'
- en: '``sendSendHeadersMessage(s)``'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendSendHeadersMessage(s)``'
- en: '``blkhash_l = getBlockHashListFromCoreClient()``'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '``blkhash_l = getBlockHashListFromCoreClient()``'
- en: '``sendAndHandleGetHeaders(s, blkhash_l, version)``'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendAndHandleGetHeaders(s, blkhash_l, version)``'
- en: '``waitAndHandleHeaderResponse(s)``'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitAndHandleHeaderResponse(s)``'
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHandler(s: socket, version: int):`'
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Establish connection failed’, file=flog)`'
- en: '`return`'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '``sendrecvHeadersData(s, version)``'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendrecvHeadersData(s, version)``'
- en: '**Program 7.13:** Program to receive blocks using Direct Header Announcements
    (Legacy)'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序7.13:** 使用直接头部宣布（遗产）接收区块的程序'
- en: This gives us the following sequence of message exchanges between our node and
    the peer.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下消息交换序列，这些交换发生在我们节点和对等节点之间。
- en: 'First, we send `**sendheaders**` to the peer to indicate that we expect `***headers***`
    message instead of `**inv**` to receive blocks:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向对等节点发送`**sendheaders**`以指示我们期望`***headers***`消息而不是`**inv**`来接收区块：
- en: '![](images/Figure-7.28.jpg)'
  id: totrans-964
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.28.jpg)'
- en: '**Figure 7.28:** The getheaders message sent to the peer indicating that our
    node accepts direct header announcements'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.28:** 向对等节点发送getheaders消息，表明我们的节点接受直接头部宣布'
- en: 'We then sync the blockchain by sending the `**getheaders**` message with a
    list of recent blocks of best chain:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过发送带有最佳链最近区块的`**getheaders**`消息来同步区块链：
- en: '![](images/Figure-7.29.jpg)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.29.jpg)'
- en: '**Figure 7.29:** getheaders request made to sync with the peer'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.29:** 向对等节点发送getheaders请求以同步'
- en: 'Since the peer didn’t have any recent block, it responds with the following
    empty `**headers**` message:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对等节点没有最近的区块，它用以下空`**headers**`消息响应：
- en: '![](images/Figure-7.30.jpg)'
  id: totrans-970
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.30.jpg)'
- en: '**Figure 7.30:** Peer responds with headers message with a list of headers'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.30:** 对等节点响应带有头部列表的头部消息'
- en: The peer sends us an empty `***headers***` response as it does not have any
    new blocks.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 对等节点发送一个空`***headers***`响应，因为它没有任何新块。
- en: 'After this, we wait for the peer to send us new blocks whenever it receives
    them:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们等待对等节点在接收到区块时向我们发送新区块：
- en: '![](images/Figure-7.31.jpg)'
  id: totrans-974
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.31.jpg)'
- en: '**Figure 7.31:** Peer sends a list of headers to our node after receiving a
    new block'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.31:** 在接收到新块后，对等节点向我们节点发送一个头部列表'
- en: If we don’t have the block already, we request the peer to send the missing
    block. This is done by sending a `**getblock**` message to the peer with the block
    header hash which we received in the `**headers**` message.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有区块，我们就请求对等节点发送缺失的区块。这是通过向对等节点发送带有我们在`**headers**`消息中收到的区块头部哈希的`**getblock**`消息来完成的。
- en: '![](images/Figure-7.32.jpg)'
  id: totrans-977
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.32.jpg)'
- en: '**Figure 7.32:** Our node sends a getdata request to peer for blocks'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.32:** 我们的节点向对等节点发送getdata请求以获取区块'
- en: 'The peer responds with the raw block in a `**block**` message. The following
    is the truncated `**block**` message:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 对等节点用`**block**`消息发送原始区块。以下是截断的`**block**`消息：
- en: '![](images/Figure-7.33.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.33.jpg)'
- en: '**Figure 7.33:** Peer responds with the block message containing full block'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.33:** 对等节点响应包含完整区块的区块消息'
- en: In this subtopic, you learned how the original direct headers announcements
    method worked. In the next subtopic, you will understand the improved method of
    broadcasting recently received blocks.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子主题中，你学习了原始直接头部宣布方法是如何工作的。在下一个子主题中，你将了解最近接收的区块的改进广播方法。
- en: '[Compact Block Announcements](toc.xhtml#s144a)'
  id: totrans-983
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[紧凑区块宣布](toc.xhtml#s144a)'
- en: 'We are aware that blocks are a collection of transactions. Most of the transactions
    that a block is made up of are already received by almost all the peers. So, sending
    the whole block will not be required if we could send a compressed transaction
    list along with the block header. This is the idea behind the compact Block announcement.
    So, since, version 70014, Direct Headers Broadcasting has been replaced with `**cmpctblock**`*.*
    and now two methods are used:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道区块是交易的集合。一个区块由的大部分交易几乎所有对等节点都已经接收。所以，如果我们能发送一个与区块头一起的压缩交易列表，就不需要发送整个区块。这就是紧凑区块公告背后的想法。因此，自版本70014以来，直接头部广播已由`**cmpctblock**`*.*
    替换，现在使用两种方法：
- en: 'For high bandwidth communication: This method is normally enabled for only
    a few peers as it requires more processing.'
  id: totrans-985
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于高带宽通信：通常只有少数对等节点启用此方法，因为它需要更多处理。
- en: 'For low bandwidth communication: This method is enabled for other peers.'
  id: totrans-986
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于低带宽通信：此方法为其他对等节点启用。
- en: After the connection is established, we instantly send a `**sendheaders**` message
    to a peer to make our peer aware that instead of `**inv**` messages, the peer
    can directly send `***headers***` message for new incoming blocks. Then, we send
    a `**sendcmpct**` message to make our peer aware that for both segregated witness
    and non-segregated witness transactions, we expect `**headers**` or `**cmpctblock**`
    messages.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们会立即向一个对等节点发送`**sendheaders**`消息，让我们的对等节点知道，与其发送`**inv**`消息，不如直接发送`***headers***`消息来接收新到来的区块。然后，我们发送一个`**sendcmpct**`消息，让我们的对等节点知道，对于隔离见证和非隔离见证交易，我们期望收到`**headers**`或`**cmpctblock**`消息。
- en: 'The following is the structure of the `**sendcmpct**` payload:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`**sendcmpct**`负载的结构：
- en: '![](images/Figure-7.34.jpg)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.34.jpg)'
- en: '**Figure 7.34:** Structure of a sendcmpct message'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.34：** sendcmpct消息结构'
- en: 'In the `**sendcmpct**` message, there are two fields:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在`**sendcmpct**`消息中，有两个字段：
- en: '**Announce** is a one-byte Boolean value. Value **0** indicates support for
    low bandwidth relay, while value **1** indicates support for high bandwidth relay.'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '**Announce**是一个字节长的布尔值。值**0**表示支持低带宽传输，而值**1**表示支持高带宽传输。'
- en: '**Version** is an 8-byte field; currently, it can have either of the following:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**Version**是一个8字节字段；目前，它可以有以下值之一：'
- en: Value 1, which indicates support for `**wtxid**`, which is witness transaction
    ID in segregated witness.
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值1，表示支持`**wtxid**`，即隔离见证中的见证交易ID。
- en: Value 0, which indicates support for other transactions that have transaction
    IDs as this.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值0，表示支持具有与该值相同的交易ID的其他交易。
- en: We will cover segregated witness transactions in an upcoming chapter.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论隔离见证交易。
- en: The next subtopic covers each of these relay methods.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子主题将涵盖这些中继方法中的每一个。
- en: High Bandwidth Compact Block Announcements
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高带宽紧凑区块公告
- en: 'The following is the sequence of message exchanges in the activity diagram:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是活动图中消息交换的顺序：
- en: '![](images/Figure-7.35.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.35.jpg)'
- en: '**Figure 7.35:** Sequence Diagram of Compact Block Announcement for High Bandwidth
    Relay'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.35：** 高带宽传输的紧凑区块公告序列图'
- en: After receiving `**sendcmpct**` request for both segregated witness and non-segregated
    witness transactions, we send a `**getheaders**` request with a list of recent
    blocks and genesis block and synchronize our node with the peer, as we did in
    the previous subtopic with heading **synchronizing blocks**.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到`**sendcmpct**`请求，无论是隔离见证交易还是非隔离见证交易后，我们会发送一个`**getheaders**`请求，带上最近区块和创世区块的列表，并与对等节点同步，就像在前一子主题**同步区块**中做的那样。
- en: Once the peer is aware that we have all the blocks in the blockchain which it
    considers as the best blockchain, we can be ready to receive new blocks from the
    peer. Note that our best blockchain may be different from peers’ best blockchain
    because we will be receiving blocks from multiple peers. The best blockchain means
    the chain with the highest accumulated proof-of-work. This can be calculated by
    adding the difficulty recorded in each block in the chain. The difficulty adjustment
    happens only after every 2016 blocks, so the chain with the highest accumulated
    proof-of-work is generally the chain with more blocks.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对等节点意识到我们拥有区块链中所有区块，而这些区块是它认为的最佳区块链，我们就可以准备好从对等节点接收新区块。请注意，我们的最佳区块链可能与对等节点的最佳区块链不同，因为我们将从多个对等节点接收区块。最佳区块链意味着累积工作量证明最高的链。这可以通过将链中每个区块记录的难度相加来计算。难度调整每2016个区块后发生一次，所以累积工作量证明最高的链通常是区块数更多的链。
- en: 'When the peer receives a new block, it sends a `**cmpctblock**` message containing
    compressed or short IDs of all the transactions in the block. To parse and generate
    short IDs, we need to install the following Python package:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点接收到一个新的区块时，它会发送一个包含该区块中所有交易的压缩或短 ID 的 `**cmpctblock**` 消息。为了解析和生成短 ID，我们需要安装以下
    Python 包：
- en: '![](images/Figure-7.36.jpg)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.36.jpg)'
- en: '**Figure 7.36:** pip package to generate and parse short IDs'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.36：** 用于生成和解析短 ID 的 pip 包'
- en: 'The following are the structures of the `**cmpctblock**`, `**getblocktxn**`,
    and `**blocktxn**` messages:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `**cmpctblock**`、`**getblocktxn**` 和 `**blocktxn**` 消息的结构：
- en: '![](images/Figure-7.37.jpg)'
  id: totrans-1008
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.37.jpg)'
- en: '**Figure 7.37:** Payload structure of cmpctblock, getblocktxn and blocktxn'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.37：** cmpctblock、getblocktxn 和 blocktxn 的载荷结构'
- en: 'The following are the details of these message payloads:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些消息载荷的详细信息：
- en: '![](images/233.jpg)'
  id: totrans-1011
  prefs: []
  type: TYPE_IMG
  zh: '![](images/233.jpg)'
- en: '**Table 7.4:** List of compact messages and their description'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7.4：** 紧凑消息列表及其描述'
- en: 'In the following code, the connection is already established, and now we are
    sending and handling requests required for receiving new blocks:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，连接已经建立，现在我们正在发送和处理接收新区块所需的请求：
- en: '`def parseShortIds(payload_m: mmap, shortids_len: int):`'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseShortIds(payload_m: mmap, shortids_len: int):`'
- en: '`shortids = []`'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortids = []`'
- en: '`for i in range(shortids_len):`'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(shortids_len):`'
- en: '`shortids.append(payload_m.read(6).hex())`'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortids.append(payload_m.read(6).hex())`'
- en: '`return shortids`'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '`return shortids`'
- en: '`def parsePrefilledTxn(payload_m: mmap, prefilledtxn_len: int):`'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parsePrefilledTxn(payload_m: mmap, prefilledtxn_len: int):`'
- en: '`prefilledtxn_l = []`'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilledtxn_l = []`'
- en: '`for i in range(prefilledtxn_len):`'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(prefilledtxn_len):`'
- en: '`prefilledtxn = {}`'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilledtxn = {}`'
- en: '`prefilledtxn[‘index’] = getVarInt(payload_m)`'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilledtxn[‘index’] = getVarInt(payload_m)`'
- en: '`prefilledtxn[‘tx’] = parseTxPayload(payload_m)`'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilledtxn[‘tx’] = parseTxPayload(payload_m)`'
- en: '`prefilledtxn_l.append(prefilledtxn)`'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilledtxn_l.append(prefilledtxn)`'
- en: '`return prefilledtxn_l`'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`return prefilledtxn_l`'
- en: '`def parseCmpctBlockPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseCmpctBlockPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`pos = payload_m.tell()`'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '`pos = payload_m.tell()`'
- en: '`payload[‘hdr_nonce’] = payload_m.read(88).hex()`'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘hdr_nonce’] = payload_m.read(88).hex()`'
- en: '`payload_m.seek(pos)`'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload_m.seek(pos)`'
- en: '`payload[‘header’] = parseBlockHeader(payload_m)`'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘header’] = parseBlockHeader(payload_m)`'
- en: '`payload[‘nonce’] = payload_m.read(8)[::-1].hex()`'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘nonce’] = payload_m.read(8)[::-1].hex()`'
- en: '`payload[‘shortids_length’] = getVarInt(payload_m)`'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘shortids_length’] = getVarInt(payload_m)`'
- en: '`payload[‘shortids’] = parseShortIds(payload_m, payload[‘shortids_length’])`'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘shortids’] = parseShortIds(payload_m, payload[‘shortids_length’])`'
- en: '`payload[‘prefilledtxn_length’] = getVarInt(payload_m)`'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘prefilledtxn_length’] = getVarInt(payload_m)`'
- en: '`payload[‘prefilledtxn’] = parsePrefilledTxn(payload_m, payload[‘prefilledtxn_length’])`'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘prefilledtxn’] = parsePrefilledTxn(payload_m, payload[‘prefilledtxn_length’])`'
- en: '`return payload`'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def parseBlockTxnPayload(payload_m: mmap, payloadlen = 0):`'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '`def parseBlockTxnPayload(payload_m: mmap, payloadlen = 0):`'
- en: '`payload = {}`'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = {}`'
- en: '`payload[‘blkhash’] = payload_m.read(32)[::-1].hex()`'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘blkhash’] = payload_m.read(32)[::-1].hex()`'
- en: '`payload[‘txn_len’] = getVarInt(payload_m)`'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txn_len’] = getVarInt(payload_m)`'
- en: '`payload[‘txn’] = []`'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txn’] = []`'
- en: '`for i in range(payload[‘txn_len’]):`'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(payload[‘txn_len’]):`'
- en: '`txn = parseTxPayload(payload_m)`'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '`txn = parseTxPayload(payload_m)`'
- en: '`payload[‘txn’].append(txn)`'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload[‘txn’].append(txn)`'
- en: '`return payload`'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def createSendCompactPayload(announce: int, version: int):`'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createSendCompactPayload(announce: int, version: int):`'
- en: '`announce_b = struct.pack(‘<B’, announce)`'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '`announce_b = struct.pack(‘<B’, announce)`'
- en: '`version_b = struct.pack(‘<Q’, version)`'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`version_b = struct.pack(‘<Q’, version)`'
- en: '`payload = announce_b + version_b`'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = announce_b + version_b`'
- en: '`return payload`'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def createHeadersPayloadNoHeaders():`'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createHeadersPayloadNoHeaders():`'
- en: '`cnt_b = setVarInt(0)`'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '`cnt_b = setVarInt(0)`'
- en: '`headers_b = b’’`'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers_b = b’’`'
- en: '`payload = cnt_b + headers_b`'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = cnt_b + headers_b`'
- en: '`return payload`'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def createGetBlockTxnPayload(payload: dict, shortIDs_index_l: list):`'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '`def createGetBlockTxnPayload(payload: dict, shortIDs_index_l: list):`'
- en: '`hdr_b = bytes.fromhex(payload[‘hdr_nonce’])[0:80] #header`'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr_b = bytes.fromhex(payload[‘hdr_nonce’])[0:80] #header`'
- en: '`blkhash_b = hashlib.sha256(hashlib.sha256(hdr_b).digest()).digest()`'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkhash_b = hashlib.sha256(hashlib.sha256(hdr_b).digest()).digest()`'
- en: '`print(‘blkhash = %s’ % blkhash_b[::-1].hex())`'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘blkhash = %s’ % blkhash_b[::-1].hex())`'
- en: '`indexes_len_b = setVarInt(len(shortIDs_index_l))`'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexes_len_b = setVarInt(len(shortIDs_index_l))`'
- en: '`indexes_b = b’’`'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexes_b = b’’`'
- en: '`for shortIDs_index in shortIDs_index_l:`'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '`for shortIDs_index in shortIDs_index_l:`'
- en: '`indexes_b += setVarInt(shortIDs_index)`'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexes_b += setVarInt(shortIDs_index)`'
- en: '`payload = blkhash_b + indexes_len_b + indexes_b`'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = blkhash_b + indexes_len_b + indexes_b`'
- en: '`return payload`'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '`return payload`'
- en: '`def sendSendCompactMessage(s: socket):`'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendSendCompactMessage(s: socket):`'
- en: '`# send sendcmpct message for Segwit`'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send sendcmpct message for Segwit`'
- en: '`sndcmd = ‘sendcmpct’`'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘sendcmpct’`'
- en: '`payload = createSendCompactPayload(1, 2)`'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createSendCompactPayload(1, 2)`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '`s.send(sndmsg)`'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.send(sndmsg)`'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`# send sendcmpct message for others`'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send sendcmpct message for others`'
- en: '`sndcmd = ‘sendcmpct’`'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘sendcmpct’`'
- en: '`payload = createSendCompactPayload(1, 1)`'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createSendCompactPayload(1, 1)`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '`s.send(sndmsg)`'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.send(sndmsg)`'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def sendHeadersMessage(s: socket):`'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendHeadersMessage(s: socket):`'
- en: '`# send header message`'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '`# send header message`'
- en: '`sndcmd = ‘headers’`'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘headers’`'
- en: '`payload = createHeadersPayloadNoHeaders()`'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createHeadersPayloadNoHeaders()`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '`s.send(sndmsg)`'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.send(sndmsg)`'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def convertTxIDs2ShortIDs(payload: dict, txid_l: list):`'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '`def convertTxIDs2ShortIDs(payload: dict, txid_l: list):`'
- en: '`hdr_nonce_b = bytes.fromhex(payload[‘hdr_nonce’])`'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '`hdr_nonce_b = bytes.fromhex(payload[‘hdr_nonce’])`'
- en: '`shortids_l = []`'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortids_l = []`'
- en: '`for txid in txid_l:`'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`for txid in txid_l:`'
- en: '`txid_b = bytes.fromhex(txid)[::-1]`'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_b = bytes.fromhex(txid)[::-1]`'
- en: '`h_b = hashlib.sha256(hdr_nonce_b).digest()[0:16]`'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '`h_b = hashlib.sha256(hdr_nonce_b).digest()[0:16]`'
- en: '`sip = siphash.SipHash_2_4(h_b, txid_b)`'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '`sip = siphash.SipHash_2_4(h_b, txid_b)`'
- en: '`siphash_b = sip.digest()`'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '`siphash_b = sip.digest()`'
- en: '`shortid = siphash_b[:-2].hex()`'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortid = siphash_b[:-2].hex()`'
- en: '`shortid_l = siphash_b[2:].hex()`'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortid_l = siphash_b[2:].hex()`'
- en: '`shortids_l.append(shortid)`'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortids_l.append(shortid)`'
- en: '`return shortids_l`'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '`return shortids_l`'
- en: '`def findMissingShortIDs(payload: dict):`'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '`def findMissingShortIDs(payload: dict):`'
- en: '`for i in range(len(mempool_l_g)):`'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(len(mempool_l_g)):`'
- en: '`stored_mempool = mempool_l_g[-1-i]`'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '`stored_mempool = mempool_l_g[-1-i]`'
- en: '`txid_l = []`'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l = []`'
- en: '`for k, v in stored_mempool.items():`'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '`for k, v in stored_mempool.items():`'
- en: '``if ‘wtxid’ in v:``'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '``if ‘wtxid’ in v:``'
- en: '`txid_l.append(v[‘wtxid’])`'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l.append(v[‘wtxid’])`'
- en: '`else:`'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '`else:`'
- en: '`txid_l.append(k)`'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '`txid_l.append(k)`'
- en: '`shortIDs = convertTxIDs2ShortIDs(payload, txid_l)`'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortIDs = convertTxIDs2ShortIDs(payload, txid_l)`'
- en: '`shortIDs_index_l = []`'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortIDs_index_l = []`'
- en: '`for recvd_shortID in payload[‘shortids’]:`'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '`for recvd_shortID in payload[‘shortids’]:`'
- en: '`if recvd_shortID not in shortIDs:`'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvd_shortID not in shortIDs:`'
- en: '`shortIDs_index_l.append(payload[‘shortids’].index(recvd_shortID) + 1)`'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortIDs_index_l.append(payload[‘shortids’].index(recvd_shortID) + 1)`'
- en: '`if len(shortIDs_index_l) > 0:`'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(shortIDs_index_l) > 0:`'
- en: '`break`'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`return shortIDs_index_l`'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '`return shortIDs_index_l`'
- en: '`def waitForCmpctBlock(s: socket):`'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForCmpctBlock(s: socket):`'
- en: '`while True:`'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '`recvmsg = recvMsg(s)`'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvmsg = recvMsg(s)`'
- en: '`if recvmsg[‘command’] == ‘cmpctblock’:`'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘cmpctblock’:`'
- en: '`return recvmsg`'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '`sendPongMessage(s, recvmsg)`'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendPongMessage(s, recvmsg)`'
- en: '`return recvmsg`'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`def sendGetBlockTxn(s: socket, recvmsg: dict, shortIDs_index_l):`'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendGetBlockTxn(s: socket, recvmsg: dict, shortIDs_index_l):`'
- en: '`sndcmd = ‘getblocktxn’`'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getblocktxn’`'
- en: '`payload = createGetBlockTxnPayload(recvmsg[‘payload’], shortIDs_index_l)`'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createGetBlockTxnPayload(recvmsg[‘payload’], shortIDs_index_l)`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '`s.send(sndmsg)`'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.send(sndmsg)`'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def waitForBlockTxn(s: socket):`'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitForBlockTxn(s: socket):`'
- en: '`while True:`'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True:`'
- en: '`recvmsg = recvMsg(s)`'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvmsg = recvMsg(s)`'
- en: '`if recvmsg[‘command’] == ‘blocktxn’:`'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '`if recvmsg[‘command’] == ‘blocktxn’:`'
- en: '`return recvmsg`'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recvmsg`'
- en: '`elif recvmsg[‘command’] == ‘ping’:`'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif recvmsg[‘command’] == ‘ping’:`'
- en: '`sendPongMessage(s, recvmsg)`'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendPongMessage(s, recvmsg)`'
- en: '`def waitAndHandleHeaderResponse(s: socket):`'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '`def waitAndHandleHeaderResponse(s: socket):`'
- en: '`recvmsg = waitForCmpctBlock(s)`'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvmsg = waitForCmpctBlock(s)`'
- en: '`shortIDs_index_l = findMissingShortIDs(recvmsg[‘payload’])`'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortIDs_index_l = findMissingShortIDs(recvmsg[‘payload’])`'
- en: '`if len(shortIDs_index_l) > 0:`'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(shortIDs_index_l) > 0:`'
- en: '`sendGetBlockTxn(s, recvmsg, shortIDs_index_l)`'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendGetBlockTxn(s, recvmsg, shortIDs_index_l)`'
- en: '`waitForBlockTxn(s)`'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForBlockTxn(s)`'
- en: '`def sendrecvHeadersData(s: socket, version: int):`'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHeadersData(s: socket, version: int):`'
- en: '`sendSendHeadersMessage(s)`'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendSendHeadersMessage(s)`'
- en: '`sendSendCompactMessage(s)`'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendSendCompactMessage(s)`'
- en: '`blkhash_l = getBlockHashListFromCoreClient()`'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkhash_l = getBlockHashListFromCoreClient()`'
- en: '`sendAndHandleGetHeaders(s, blkhash_l, version)`'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendAndHandleGetHeaders(s, blkhash_l, version)`'
- en: '`waitAndHandleHeaderResponse(s)`'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitAndHandleHeaderResponse(s)`'
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '`def sendrecvHandler(s: socket, version: int):`'
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘Establish connection failed’, file=flog)`'
- en: '`return`'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`sendrecvHeadersData(s, version)`'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendrecvHeadersData(s, version)`'
- en: '**Program 7.14:** Program for receiving and processing compact messages for
    High Bandwidth relay'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.14:** 用于接收和处理高带宽中继的紧凑消息的程序'
- en: We executed the above-mentioned code and got the following communication messages.
    I have ignored other messages, such as `**ping**` or `**addr**` or `**inv**`.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了上述代码，并得到了以下的通信消息。我忽略了一些其他消息，比如 `**ping**` 或者 `**addr**` 或者 `**inv**`。
- en: 'First, we sent `**sendheaders**` and `**sendcpmct**` for segwit and `**sendcmpct**`
    for non-segwit:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们发送了`**sendheaders**` 和 `**sendcpmct**` 以支持 segwit，以及 `**sendcmpct**` 以支持非
    segwit：
- en: '![](images/Figure-7.38.jpg)'
  id: totrans-1158
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.38.jpg)'
- en: '**Figure 7.38:** Messages sent to peer that our node accepts compact messages
    for both segwit and non-segwit payload'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.38:** 我们节点发送给对等节点的消息，接受 segwit 和非 segwit 有效负载的紧凑消息'
- en: 'Then, we sent a `**getheaders**` message and received **headers** message.
    The following is the truncated `**getheaders**` message and received `***headers***`
    message:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们发送了一个`**getheaders**`消息，并接收到了**headers**消息。以下是截断的`**getheaders**`消息和接收到的`***headers***`消息：
- en: '![](images/Figure-7.39.jpg)'
  id: totrans-1161
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.39.jpg)'
- en: '**Figure 7.39:** Truncated getheaders request sent to peer with a list of block
    hashes'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.39:** 向具有块哈希列表的对等节点发送截断的 getheaders 请求'
- en: 'We get a list of headers in response, which is empty, in the following incoming
    message:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到响应中的一个头部列表，它是空的，如下面的传入消息所示：
- en: '![](images/Figure-7.40.jpg)'
  id: totrans-1164
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.40.jpg)'
- en: '**Figure 7.40:** Peer responds with a list of recent headers, not in getheaders
    request'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.40:** 对等节点响应时发送最近的头部列表，而不是在 getheaders 请求中'
- en: The peer responded with `***headers***` messages without any *headers* with
    count zero.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 对等节点响应了`***headers***`消息，其中没有*headers*，计数为零。
- en: 'Next, we waited for the peer to send us a `**cmpctblock**` message. Meanwhile,
    we received `**inv**` messages having transactions. The following is the truncated
    `**cmpctblock**` message we received:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们等待对等节点发送一个`**cmpctblock**`消息。与此同时，我们收到了具有交易的`**inv**`消息。以下是截断的`**cmpctblock**`消息：
- en: '![](images/Figure-7.41.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.41.jpg)'
- en: '**Figure 7.41:** Peer sends cmpctblock message on receiving a new block'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.41:** 在接收到新块时，对等节点发送 cmpctblock 消息'
- en: 'On receiving the `**cmpctblock**` message, we search received short IDs in
    mempool by generating short IDs for each `**txid**` and `**wtxid**`. If there
    are any missing transactions, we send a `**getblocktxn**` request message to a
    peer with the index of missing short IDs in the `**cmpctblock**` message. The
    following is the transaction message we sent:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到`**cmpctblock**`消息后，我们通过为每个`**txid**`和`**wtxid**`生成短ID来在 mempool 中搜索接收到的短ID。如果有任何缺失的交易，我们就向在`**cmpctblock**`消息中缺失短ID的索引发送一个`**getblocktxn**`请求消息给对等节点。以下是我们发送的交易消息：
- en: '![](images/Figure-7.42.jpg)'
  id: totrans-1171
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.42.jpg)'
- en: '**Figure 7.42:** Our node sends getblocktxn request to peer with a list of
    missing short ID indexes'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.42:** 我们的节点向具有缺失短ID索引列表的对等节点发送 getblocktxn 请求'
- en: 'On receiving the `**getblocktxn**`*,* the peer sends a `**blocktxn**` message
    with only the missing transaction it received in the `**getblocktxn**` message.
    The following is the truncated `**blocktxn**` message received from a peer:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到`**getblocktxn**`*时，对等节点只发送了`**blocktxn**`消息，其中只包含在`**getblocktxn**`消息中接收到的缺失交易。以下是从对等节点接收到的截断的`**blocktxn**`消息：
- en: '![](images/Figure-7.43.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.43.jpg)'
- en: '**Figure 7.43:** Peer responds with blocktxn message containing the missing
    transaction'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.43:** 对等节点响应包含缺失交易的 blocktxn 消息'
- en: Low Bandwidth Compact Block Announcements
  id: totrans-1176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低带宽紧凑块公告
- en: 'The following is the sequence of message exchanges between the host and its
    peer in the form of an activity diagram:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在主机与其对等节点之间交换消息的序列，以活动图的形式表示：
- en: '![](images/Figure-7.44.jpg)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.44.jpg)'
- en: '**Figure 7.44:** Sequence Diagram of Compact Block Announcement for Low Bandwith
    Relay'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.44:** 低带宽中继的紧凑块公告序列图'
- en: In the low bandwidth compact block announcement method, we set to announce as
    0 in the `**sendcmpct**` message and send a `**sendcmpct**` message for both segregated
    witness and non-segregated witness transactions. Once the blockchain is synchronized,
    we wait for the `**headers**` message from the peer. In response to the `***headers***`
    message, we send a `**getdata**` message with `**MSG_CMPCT_BLOCK**` as the response.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在低带宽紧凑区块公告方法中，我们在`**sendcmpct**`消息中设置为0，并为分离见证和非分离见证交易发送`**sendcmpct**`消息。一旦区块链同步，我们等待来自对等方的`**headers**`消息。作为对`***headers***`消息的回应，我们发送一个带有`**MSG_CMPCT_BLOCK**`作为响应的`**getdata**`消息。
- en: 'The following code does this:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行此操作：
- en: '`def sendSendCompactMessage(s: socket):`'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 定义发送SendCompactMessage函数如下：
- en: '`# send sendcmpct message for Segwit`'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 发送Segwit的sendcmpct消息`'
- en: '`sndcmd = ‘sendcmpct’`'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘sendcmpct’`'
- en: '`payload = createSendCompactPayload(0, 2)`'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createSendCompactPayload(0, 2)`'
- en: '`sndmsg = createMessage(sndcmd, payload)`'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndmsg = createMessage(sndcmd, payload)`'
- en: '``s.send(sndmsg)``'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`# send sendcmpct message for others`'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 发送其他情况的sendcmpct消息`'
- en: '`sndcmd = ‘sendcmpct’`'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘sendcmpct’`'
- en: '`payload = createSendCompactPayload(0, 1)`'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload = createSendCompactPayload(0, 1)`'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def createGetDataPayloadCMPCTBlock(hash_l: list):`'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '`定义创建GetDataPayloadCMPCTBlock函数如下：`'
- en: '`MSG_CMPCT_BLOCK = 4`'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_CMPCT_BLOCK = 4`'
- en: '`count = len(hash_l)`'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '`count = len(hash_l)`'
- en: '``hash_count_b = setVarInt(count)``'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '``hash_count_b = setVarInt(count)``'
- en: '`hashes_b = b’’`'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashes_b = b’’`'
- en: '`for i in range(count):`'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i in range(count):`'
- en: '`type_b = struct.pack(‘<L’, MSG_CMPCT_BLOCK)`'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_b = struct.pack(‘<L’, MSG_CMPCT_BLOCK)`'
- en: '`hashes_b += type_b + bytes.fromhex(hash_l[i][‘blkhash’])[::-1]`'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashes_b += type_b + bytes.fromhex(hash_l[i][‘blkhash’])[::-1]`'
- en: '``payload_b = hash_count_b + hashes_b``'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload_b = hash_count_b + hashes_b``'
- en: '``return payload_b``'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '``return payload_b``'
- en: '`def sendGetDataMessage(s: socket, recvmsg: dict):`'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 定义发送GetDataMessage函数如下：
- en: '`sndcmd = ‘getdata’`'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '`sndcmd = ‘getdata’`'
- en: '`blk_l = recvmsg[‘payload’][‘headers’]`'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '`blk_l = recvmsg[‘payload’][‘headers’]`'
- en: '``payload = createGetDataPayloadCMPCTBlock(blk_l)``'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '``payload = createGetDataPayloadCMPCTBlock(blk_l)``'
- en: '``sndmsg = createMessage(sndcmd, payload)``'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '``sndmsg = createMessage(sndcmd, payload)``'
- en: '``s.send(sndmsg)``'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '``s.send(sndmsg)``'
- en: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(‘==> cmd = %s, msg = %s’ % (sndcmd, sndmsg.hex()), file=flog)`'
- en: '`def waitAndHandleHeaderResponse(s: socket):`'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '`定义等待并处理头部响应函数如下：`'
- en: '``recvmsg = waitForHeaders(s)``'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = waitForHeaders(s)``'
- en: '``sendGetDataMessage(s, recvmsg)``'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendGetDataMessage(s, recvmsg)``'
- en: '``recvmsg = waitForCmpctBlock(s)``'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '``recvmsg = waitForCmpctBlock(s)``'
- en: '`shortIDs_index_l = findMissingShortIDs(recvmsg[‘payload’])`'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortIDs_index_l = findMissingShortIDs(recvmsg[‘payload’])`'
- en: '`if len(shortIDs_index_l) > 0:`'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '`if len(shortIDs_index_l) > 0:`'
- en: '`sendGetBlockTxn(s, recvmsg, shortIDs_index_l)`'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendGetBlockTxn(s, recvmsg, shortIDs_index_l)`'
- en: '``waitForBlockTxn(s)``'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '``waitForBlockTxn(s)``'
- en: '`def sendrecvHandler(s: socket, version: int):`'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 定义发送接收处理函数如下：
- en: '`if establishConnection(s, version) == False:`'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '`if establishConnection(s, version) == False:`'
- en: '`print(‘Establish connection failed’, file=flog)`'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(''建立连接失败'', file=flog)`'
- en: '``return``'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '``return``'
- en: '``sendrecvHeadersData(s, version)``'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '``sendrecvHeadersData(s, version)``'
- en: '**Program 7.15:** Program for receiving and processing compact messages for
    low bandwith relay'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序 7.15：** 用于接收和处理低带宽中继紧凑消息的程序'
- en: 'We execute the preceding code and get the communication log. First, our node
    sends `**sendheader**` and `**sendcmpct**` messages to let it know that our node
    supports Direct Header Announcements. When the peer receives a new block, it sends
    our node the following `***headers***` message:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行前述代码并获得通信日志。首先，我们的节点发送`**sendheader**`和`**sendcmpct**`消息，让对方知道我们的节点支持直接头部公告。当节点收到新的区块时，它会向我们的节点发送以下`***headers***`消息：
- en: '![](images/Figure-7.45.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.45.jpg)'
- en: '**Figure 7.45:** Received headers message from a peer with a list of blockhash
    and header'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.45：** 从对等方接收到的包含区块哈希和头部的headers消息'
- en: 'We respond with the following `**getdata**` message containing the `**MSG_CMPCT_BLOCK**`
    flag and a list of blockhash we expect from the peer:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下包含`**MSG_CMPCT_BLOCK**`标志和我们期望从对等方获取的区块哈希列表的`**getdata**`消息进行回复：
- en: '![](images/Figure-7.46.jpg)'
  id: totrans-1230
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.46.jpg)'
- en: '**Figure 7.46:** getdata request sent to the peer with a list of blockhash'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.46：** 向对等方发送包含区块哈希列表的getdata请求'
- en: 'The peer responds with the following `**cmpctblock**` message containing block
    header and list of short IDs for included transactions:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 对等方用以下包含区块头部和包含的交易的短 ID 列表的`**cmpctblock**`消息进行回复。
- en: '![](images/Figure-7.47.jpg)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.47.jpg)'
- en: '**Figure 7.47:** Peer sends cmpctblock message with a list of short IDs'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.47:** peer 发送 cmpctblock 消息，其中包含短ID列表'
- en: 'After receiving the list of short IDs and block header, our node responds to
    the peer with the following `**getblocktxn**` message with a list of short IDs
    representing the missing transaction in our node’s mempool:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到短ID和区块头的列表之后，我们的节点以下列 `**getblocktxn**` 消息响应 peer，其中包含表示我们节点 mempool 中缺失交易的短ID列表：
- en: '![](images/Figure-7.48.jpg)'
  id: totrans-1236
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.48.jpg)'
- en: '**Figure 7.48:** getblocktxn request sent to the peer with a list of missing
    short IDs indexes'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.48:** 向拥有缺失短ID索引的 peers 发送 getblocktxn 请求'
- en: 'The peer then responds with a `**blocktxn**` message containing only the required
    transactions:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，peer 用一个包含所需交易的 `**blocktxn**` 消息响应：
- en: '![](images/Figure-7.49.jpg)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
  zh: '![](images/Figure-7.49.jpg)'
- en: '**Figure 7.49:** Peer sent blocktxn message with a requested list of transactions'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.49:** 拥有所需交易的 peers 发送 blocktxn 消息'
- en: This brings us to the end of this chapter.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们结束了本章。
- en: '[Conclusion](toc.xhtml#s145a)'
  id: totrans-1242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](toc.xhtml#s145a)'
- en: In this chapter, you started off by learning about Bitcoin network topology,
    and you learned that nodes run different versions and may be of different types,
    like an archival node, a pruned node, or SPV. You also learned how a node finds
    out addresses of peers to connect and understood how a node gets all the blocks
    when it first connects with its peers and how it gets all the competing blockchain
    branches. Next, you learned how a node broadcasts transactions and block messages
    to all the remaining nodes. We did not cover network communication done by the
    SPV node to receive the required transactions and verify blocks. We also did not
    cover segregated witness transactions.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了比特币网络拓扑，并了解到节点运行不同的版本，可能是不同类型的节点，如归档节点、修剪节点或 SPV 节点。你也了解到了节点如何找到连接到
    peer 的地址，以及节点在首次与 peer 连接时如何获取所有区块，以及它是如何获取所有竞争的区块链分叉的。接下来，你又学习了节点如何将交易和区块消息广播给所有剩余的节点。我们没有涵盖
    SPV 节点为接收所需交易和验证区块而进行的网络通信。我们也没有涵盖隔离见证交易。
- en: In the next chapter, you will understand the limitations of technology, its
    impact on nature, and the potential risks, and vulnerabilities that exist because
    of the design. We will thoroughly look at them and gauge whether they are real,
    risky, or just a myth.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解技术的局限性，它对自然的影响，以及由于设计而存在的外潜在风险和漏洞。我们将彻底研究它们并评估它们是真实的、有风险的，还是只是一个神话。
- en: '[Points to remember](toc.xhtml#s146a)'
  id: totrans-1245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[需记住的要点](toc.xhtml#s146a)'
- en: Bitcoin is a peer-to-peer network that needs a TCP connection or a tor network
    to connect to a peer.
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币是一个点对点的网络，需要一个 TCP 连接或一个 tor 网络来连接到一个 peer。
- en: Bitcoin network is nonhierarchical, which means all nodes are equal, and there
    are no masters or servers. There will be TCP servers but not Bitcoin network servers.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币网络是非层次化的，这意味着所有节点都是平等的，没有主节点或服务器。将会有 TCP 服务器，但不会有比特币网络服务器。
- en: Nodes can connect and disconnect anytime and can choose which nodes they need
    to connect.
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以随时连接和断开，可以选择连接哪些节点。
- en: Nodes require an initial set of addresses, or we need to provide initial addresses
    so that they can make the initial connection to peers.
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点需要一组初始地址，或者我们需要提供初始地址，以便它们可以与 peer 建立初始连接。
- en: '`**Version**` message is the first message each node sends. If a node is fine
    with the information it received in the `**version**` message, it responds with
    `**verack**`.'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Version**` 消息是每个节点发送的第一个消息。如果一个节点对其在 `**version**` 消息中收到的信息感到满意，它将以 `**verack**`
    响应。'
- en: Once `**version**` and `**verack**` messages are exchanged, the connection is
    considered established. Before that, nodes do not receive any other message.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦交换了 `**version**` 和 `**verack**` 消息，连接就被认为是建立起来了。在此之前，节点不会接收任何其他消息。
- en: A node can send a `**ping**` message to a peer anytime to know if a peer is
    still connected.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以随时向一个 peer 发送 `**ping**` 消息，以了解 peer 是否仍然连接。
- en: A node should reduce dependency on hardcoded DNS seeds by storing active addresses
    locally and requesting new addresses from its peer.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点应该通过在本地存储活动地址并从其 peer 请求新地址来减少对硬编码 DNS 种子的依赖。
- en: The first time a node is starting, it fetches a list of all block headers till
    the 24 hours older block. After it has received them, it needs to get headers
    from all the connected nodes to get all the competing chains.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点首次启动时，它会获取直到24小时前的所有区块头的列表。在收到它们之后，它需要从所有连接的节点获取头部，以获取所有竞争的链。
- en: Once the node’s blockchain is synchronized with all the peers, it is ready to
    receive new blocks and transactions.
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦节点的区块链与所有对等节点同步，它就可以准备接收新区块和交易。
- en: '[Questions](toc.xhtml#s147a)'
  id: totrans-1256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[问题](toc.xhtml#s147a)'
- en: How do we understand that the peer is sending Bitcoin blocks or blocks in a
    different network?
  id: totrans-1257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何理解对等节点正在发送比特币区块或不同网络的区块？
- en: Why does a node need to receive recent blocks from multiple peers?
  id: totrans-1258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么节点需要从多个对等节点接收最近的区块？
- en: How does the Initial Block Download method differ from Blockchain synchronization?
  id: totrans-1259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始区块下载方法与区块链同步有何不同？
- en: When do you think we should use pruned node instead of an archival node?
  id: totrans-1260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您认为在什么情况下我们应该使用精简节点而不是归档节点？
- en: When does a node send `***sendheaders***` and `***sendcmpct***` messages?
  id: totrans-1261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点何时发送`***sendheaders***`和`***sendcmpct***`消息？
- en: 'Programming questions:'
  id: totrans-1262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程问题：
- en: Write a program that connects with multiple peers and sends the address of one
    peer to another.
  id: totrans-1263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，与多个对等节点连接并向另一个对等节点发送一个地址。
- en: Write a program to receive multiple TCP connections and limit active connections.
  id: totrans-1264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接收多个TCP连接并限制活动连接数。
- en: Write a program to relay blocks to other connected nodes.
  id: totrans-1265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，将区块传递给其他已连接节点。
- en: Create a raw transaction using Bitcoin Core wallet and publish it using your
    own program.
  id: totrans-1266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Bitcoin Core钱包创建一个原始交易，并使用您自己的程序发布它。
- en: 'True/False:'
  id: totrans-1267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：
- en: It is necessary for a node to respond to `***cmpctblock***` message to the sending
    peer.
  id: totrans-1268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点响应发送方的`***cmpctblock***`消息是必要的。
- en: Transaction `***inv***` messages need the node blockchain to be synchronized
    with the peer blockchain.
  id: totrans-1269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易`***inv***`消息需要节点的区块链与对等节点的区块链同步。
- en: During the initial block download, we send `***getdata***` request to multiple
    peers to improve download performance.
  id: totrans-1270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始区块下载过程中，我们向多个对等节点发送`***getdata***`请求以提高下载性能。
- en: 'Fill in the blanks:'
  id: totrans-1271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填空：
- en: In high bandwidth compact block announcements, a node sends __________ message
    after receiving block instead of __________ message.
  id: totrans-1272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高带宽紧凑区块公告中，节点在接收到区块后发送_________消息，而不是_________消息。
- en: The `***inv***` messages are not used for broadcasting _________ anymore.
  id: totrans-1273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`***inv***`消息不再用于广播_________。'
- en: Unsolicited block push method is only ffused by the _______ node to publish
    _______.
  id: totrans-1274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无请求的区块推送方法仅由_______节点用来发布__________。
