- en: some basic math concepts first. This will help us to not only understand causality
    but
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 首先学习一些基本的数学概念。这将帮助我们不仅理解因果关系，而且
- en: will also help with concepts explained later in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 也将有助于以后在本书中解释的概念。
- en: '**Set**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**'
- en: A set is a collection of elements. It is denoted by a capital letter. All elements
    of the set are listed inside the brackets. If an element x is present in a set,
    then it is written as *x* ∈ *X*, which means x is in X or x belongs to X. Similarly,
    if an element x is not present in a set X, it is written as *x* ∉ *X*. It does
    not matter which order the elements are in. Two sets are equal if they have the
    same elements. Equality is expressed as *X* = *Y*, meaning set X is equal to set
    Y. If two sets X and Y are not equal, it is written as *X* ≠ *Y*. A set that does
    not have any elements is called an empty set and is denoted as { } or *ϕ*. An
    example of a set is *X* = {1 5
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是元素的集合。用大写字母表示。集合的所有元素都列在括号中。如果一个元素x存在于集合中，则写为 *x* ∈ *X*，表示x在X中或x属于X。类似地，如果元素x不在集合X中，则写为
    *x* ∉ *X*。元素的顺序不重要。两个集合如果具有相同的元素，则它们相等。相等表示为 *X* = *Y*，表示集合X等于集合Y。如果集合X和Y不相等，则写为
    *X* ≠ *Y*。一个不含任何元素的集合称为空集，表示为{}或*ϕ*。集合的一个例子是 *X* = {1 5
- en: ', ,2 8'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ', ,2 8'
- en: ', , }'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ', , }'
- en: '9'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'A set Y is a subset of set X if every element of Y is also an element of X,
    for example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合Y的每个元素也是集合X的元素，则集合Y是集合X的子集，例如：
- en: '*Y* = {2 }'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y* = {2 }'
- en: '8'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: ','
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: Set Y is a subset of set X. This relationship is written as
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 集合Y是集合X的子集。这种关系写作
- en: '*Y* ⊆ *X*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y* ⊆ *X*'
- en: 'A union of two sets A and B contains all the elements in A and B, for example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合A和B的并集包含了A和B中的所有元素，例如：
- en: '*A* = {1,2, }'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = {1,2, } '
- en: '3'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: and
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '*B* = {3,4, }'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = {3,4, }'
- en: '5'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '48'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: Chapter 1 IntroduCtIon
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 引论
- en: A union of sets A and B is
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集合A和B的并集是
- en: '*S* = {1,2 3'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* = {1,2 3'
- en: ', ,4, }'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ', ,4, }'
- en: '5'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: The cartesian product of two sets A and B is the set of ordered pairs (a, b)
    for each
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合A和B的笛卡尔积是每个
- en: element in sets A and B. It is denoted as *A* × *B*. It is a set of ordered
    pairs (a, b) for each *a* ∈ *A* and *b* ∈ *B*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 集合A和B中的元素之间的关系。它用 *A* × *B* 表示。它是对每个 *a* ∈ *A* 和 *b* ∈ *B* 的有序对（a，b）的集合。
- en: An ordered pair is composed of two elements inside parentheses, for example,
    (1,
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有序对由括号内的两个元素组成，例如(1,
- en: 2) or (2, 1). Note here that the order of elements is important and matters
    in the case of ordered pairs, whereas in sets the order of elements does not matter.
    For example, (1, 2) is not the same as (2, 1), but {1,2} and {2,1} are the same
    or equal sets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '2）或（2, 1）。请注意，这里有序对的元素顺序很重要，并且在有序对的情况下很重要，而在集合中，元素的顺序并不重要。例如，（1, 2）和（2, 1）是不同的，但{1,2}和{2,1}是相同的或相等的集合。 '
- en: An example of a cartesian product, *A* × *B*, for sets shown earlier is
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合*A*和*B*的笛卡尔积*A* × *B*的一个例子是
- en: '{(1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,3), (3,4), (3,5)}'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '{(1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,3), (3,4), (3,5)}'
- en: Note that in the ordered pair, the first element is taken from set A and the
    second
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在有序对中，第一个元素来自集合A，第二个
- en: element from set B.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 集合B的元素。
- en: '**Relation**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系**'
- en: A relation (binary) between two sets A and B is a subset of the cartesian product
    *A* × *B*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合A和B之间的关系（二元）是笛卡尔积 *A* × *B* 的子集。
- en: The relationship between two elements is binary and can be written as a set
    of
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 两个元素之间的关系是二元的，可以写成一组
- en: ordered pairs. We can express this as a R b (infix notation) or (a, b) \in R,
    meaning the ordered pair (a, b) is in relation R.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有序对。我们可以表示为a R b（中缀表示法）或（a，b）\in R，表示有序对（a，b）在关系R中。
- en: When a binary relation on a set S has properties of reflexivity, symmetry, and
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合S上的二元关系具有自反性、对称性，和
- en: transitivity, it is called an **equivalence relation**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性时，它被称为**等价关系**。
- en: When a binary relation on a set S has three properties of reflexivity, antisymmetry,
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合S上的二元关系具有自反性、反对称性时
- en: and transitivity, then it is called a **partial ordering** on S.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以及传递性时，则称为S的**偏序关系**。
- en: '**Partial Order**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**偏序**'
- en: It is a binary relation ≤ (less than or equal to – for comparison) between the
    elements of a set S. A binary relation on a set S, which is reflexive, antisymmetric,
    and transitive, is known as a partial ordering on S. We now define the three conditions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它是集合S的元素之间的二元关系≤（小于或等于 - 用于比较）。 集合S上的二元关系，它是自反的，反对称的，以及传递的，被称为S的偏序关系。我们现在定义了三个条件。
- en: '**Reflexivity**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**自反性**'
- en: 'This property means that every element is related to itself. Mathematically,
    we can write it like this: ∀ *a* ∈ *S*, *a* ≤ *a*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个元素与自身相关。数学上，我们可以这样写：∀ *a* ∈ *S*，*a* ≤ *a*。
- en: '49'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: Chapter 1 IntroduCtIon
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章介绍
- en: '**Antisymmetry**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**反对称性**'
- en: This means that two elements cannot be related in both directions. Mathematically,
    it
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个元素不能在两个方向上相关。在数学上，
- en: can be written as ∀ *a*, *b* ∈ *S*, *if a* ≤ *b* ∧ *b* ≤ *a*, *a* = *b*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成 ∀ *a*, *b* ∈ *S*，*如果 a* ≤ *b* ∧ *b* ≤ *a*，*a* = *b*。
- en: '**Transitivity**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递性**'
- en: The transitive property indicates a comparative relationship where if *a* <
    *b* and *b* < *c*, it implies that *a* < *c*. Mathematically, it can be written
    as ∀ *a*, *b*, *c* ∈ *S*, *if a* ≤ *b* ∧ *b* ≤ *c then a* ≤ *c*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性质表示了一种比较关系，如果 *a* < *b* 且 *b* < *c*，则意味着 *a* < *c*。在数学上，可以写成 ∀ *a*, *b*,
    *c* ∈ *S*，*如果 a* ≤ *b* ∧ *b* ≤ *c* 则 a* ≤ *c*。
- en: A set with a partial order is called a partially ordered set or poset. In terms
    of the
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 具有偏序的集合称为偏序集或 poset。在
- en: happens-before relationship, the set S is a set of all events.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生-之前关系中，集合 *S* 是所有事件的集合。
- en: '**Irreflexive Partial Order**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**非自反性偏序**'
- en: The irreflexive partial order or strict partial order is irreflexive, antisymmetric,
    and
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 非自反性偏序或严格偏序是非自反的、反对称的和
- en: transitive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传递。
- en: '**Irreflexive**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**非自反性**'
- en: This property means that there is no element that is related to itself. Mathematically,
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着没有元素与自身有关。在数学上，
- en: we can write it like ∀ *a* ∈ *S*, *a* ≰ *a*, or given a relation R on a set
    S, R is irreflexive if
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样写：∀ *a* ∈ *S*，*a* ≰ *a*，或者给定集合 S 上的关系 R，如果
- en: '∀ *s* ∈ *S* : ( *s*, *s*) ∉ *R*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ∀ *s* ∈ *S*：（*s*, *s*）∉ *R*。
- en: '**Total Order**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**全序**'
- en: A total order or linear order is a partial order in which each pair of elements
    is
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 全序或线性序是一个偏序，其中每对元素都是
- en: comparable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可比较的。
- en: After this brief introduction to some math concepts, let us now look into what
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一些数学概念做了简要介绍之后，现在让我们看看什么
- en: causality is and what is a happens-before relationship.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因果性是什么，以及发生-之前关系是什么。
- en: '**Happens-Before Relationship and Causality**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**发生-之前关系和因果关系**'
- en: We saw earlier that a node could perform some events. It can either do the local
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前面看到一个节点可以执行一些事件。它可以执行本地
- en: computation, send a message, or receive a message. All events happen in a sequential
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 计算、发送消息或接收消息。所有事件按顺序发生
- en: order on a single node, and it is easy to see what happened before the next
    event. It is a strict total order imposed on each node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个节点上有一个顺序，很容易看到下一个事件之前发生了什么。对每个节点施加的严格全序。
- en: '50'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: '![](index-70_1.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](index-70_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章介绍
- en: 'A happens-before relationship is an irreflexive partial order (strict partial
    order) with three properties: **irreflexivity**, **antisymmetry**, and **transitivity**.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 发生-之前关系是一个非自反性的偏序（严格偏序），具有三个属性：**非自反性**，**反对称性**和**传递性**。
- en: Now imagine there are two events e and f that have happened. To ascertain if
    event e
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象有两个事件 e 和 f 已经发生。为了确定事件 e
- en: happened before event f, we use the following rules.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在事件 f 之前，我们使用以下规则。
- en: 'Event e happened before event f if and only if (iff) : e → f (right arrow used
    as a'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 e 发生在事件 f 之前当且仅当（当且仅当）：e → f（箭头表示为一个
- en: 'symbol for happens-before):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 发生-之前关系的符号)：
- en: • If e and f occurred on the same process and e executed before f
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果 e 和 f 发生在同一进程上，并且 e 在 f 之前执行
- en: on this process, then we can deduce that e precedes f, that is, a
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们可以推断出 e 先于 f，也就是说，
- en: sequential order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序顺序。
- en: • Event e is a message send event of some (unique) message m, and
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: • 事件 *e* 是某个（唯一）消息 *m* 的发送事件，且
- en: event f is the receipt of message m.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 f 是消息 m 的接收。
- en: • If there exists an event g such that e→g and g→f, then e→f. This is
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果存在一个事件 g，使得 e→g 且 g→f，则 e→f。这是
- en: called a transitive relationship.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为传递关系。
- en: We can visualize all these three rules in Figure [1-23\.](#p70)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图 [1-23\.](#p70) 中可视化所有这些三条规则。
- en: '***Figure 1-23\.** Happens-before rules*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '***图1-23\.** 发生-之前规则*'
- en: If *e* and *f* are partially ordered, we then say that e happened before *f*.
    If *e* and *f* are not partially ordered, then we say that *e* and *f* are concurrent.
    This also doesn’t mean that *e* and *f* are executed independently exactly at
    the same time. It just means that *e* and *f* are not causally related. In other
    words, there is no sequence of messages which leads from
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *e* 和 *f* 部分排序，那么我们说 e 发生在 *f* 之前。如果 *e* 和 *f* 不是部分排序的，则我们说 *e* 和 *f* 是并发的。这并不意味着
    *e* 和 *f* 完全独立地在同一时间执行。这只是意味着 *e* 和 *f* 没有因果关系。换句话说，不存在导致
- en: one event to another. The concurrency is written as *e* ∥ *g*. Figur[e 1-24
    sho](#p71)ws an example scenario in detail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个事件到另一个事件的。并发写为 *e* ∥ *g*。图[1-24展](#p71)示了一个详细的示例场景。
- en: '51'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '51'
- en: '![](index-71_1.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](index-71_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: '***Figure 1-24\.** Example happens-before relationship*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***图1-24***。示例发生-之前的关系*'
- en: In Figur[e 1-24](#p71), the relations *e* → *f*, *g* → *h*, *i* → *j* are due
    to the order in which processes execute the events. The relations *f* → *g*, *h*
    → *j* are due to messages *m* 1 and *m* 2\. Moreover *e* → *g*, *e* → *h*, *e*
    → *j*, *f* → *h*, *f* → *j*, *g* → *j* represent transitive relation. Finally,
    the concurrent events are *e* ∥ *i*, *f* ∥ *i*, *g* ∥ *i*, *h* ∥ *i*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[1-24](#p71)中，*e* → *f*，*g* → *h*，*i* → *j*之间的关系是由于进程执行事件的顺序。*f* → *g*，*h*
    → *j*之间的关系是由于消息*m*1和*m*2。此外，*e* → *g*，*e* → *h*，*e* → *j*，*f* → *h*，*f* → *j*，*g*
    → *j*代表传递关系。最后，并发事件为 *e* ∥ *i*，*f* ∥ *i*，*g* ∥ *i*，*h* ∥ *i*。
- en: '**Logical Clocks**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑时钟**'
- en: Logical clocks do not depend on physical clocks and can be used to define the
    order of
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑时钟不依赖于物理时钟，可以用于定义事件的顺序
- en: events in a distributed system. Logical clocks only measure the order of events
    without
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的事件。逻辑时钟只测量事件的顺序，不带有
- en: any reference to external physical time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于外部物理时间的任何引用。
- en: '**Lamport Clocks**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lamport时钟**'
- en: A Lamport clock is a logical counter that is maintained by each process in a
    distributed
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport时钟是分布式系统中每个进程维护的逻辑计数器
- en: system, and with each occurrence of an event, it is incremented to provide a
    means of
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中，每次事件发生时，计数器都会递增，以提供一种
- en: maintaining and observing a happens-before relationship between events occurring
    in
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 维护和观察在分布式系统中发生的事件之间的发生-之前的关系。
- en: the distributed system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统。
- en: The key idea here is that each event is assigned a number which increments as
    the
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键思想是每个事件都被分配一个数字，随着
- en: event occurs in the system. This number is also called the Lamport clock. A
    Lamport
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在系统中发生。此数字也称为Lamport时钟。Lamport
- en: clock captures causality.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟捕捉因果关系。
- en: 'The algorithm for Lamport’s clocks/logical clocks is described as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport时钟/逻辑时钟的算法描述如下：
- en: • Every process maintains a local counter which is set to zero at
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个进程维护一个本地计数器，该计数器被设置为零
- en: initialization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化。
- en: • With every event on a process, the counter is incremented by one by
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: • 每次事件发生时，计数器都会增加1。
- en: that process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那个过程。
- en: '52'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: Chapter 1 IntroduCtIon
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: • When a message is sent, a process includes its current value of the
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: • 当发送消息时，进程会包含其当前值
- en: counter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器。
- en: • When a message is received, a process sets its counter value to
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: • 当接收到消息时，进程将其计数器值设置为
- en: max(local + received) + 1\.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值（本地 + 接收） + 1。
- en: In a happens-before relationship where *e* → *f*, we can say that possibly *e*
    caused *f*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生-之前的关系中，即*e* → *f*，我们可以说可能是*e*引起了*f*。
- en: This means that the happens-before relationship captures causality of the events.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着发生-之前的关系捕捉事件的因果关系。
- en: More formally, the Lamport algorithm is shown in Listin[g 1-1\.](#p72)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，Lamport算法如列表1-1中所示。
- en: '***Listing 1-1\.*** Lamport clock'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '***列表1-1***。Lamport时钟'
- en: on init
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在init上
- en: t := 0
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: t:=0
- en: on event localcomputation do
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件localcomputation上执行
- en: t := t + 1
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: t := t + 1
- en: end
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: on event send(m) do
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件send(m)上执行
- en: t := t + 1
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: t := t + 1
- en: send(m, t)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: send(m, t)
- en: end
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: on event receive(m', t') do
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件receive(m', t')上执行
- en: t := max(t, t') + 1
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: t := max(t, t') + 1
- en: end
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: Lamport clocks are consistent with causality. We can write this like
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport时钟与因果关系一致。我们可以这样写
- en: '*if e* → *f* ⇒ *LC* ( *e*) < *LC* ( *f* )'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*if e* → *f*⇒*LC*(*e*)< *LC*(*f*)'
- en: This means that if e happened before f, then it implies that the timestamp (Lamport
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果e发生在f之前，那么意味着事件e的时间戳（Lamport
- en: clock – LC) of event e is less than the timestamp of event f.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟-LC）小于事件f的时间戳。
- en: 'There is a correctness criterion called the **clock condition** which is used
    to evaluate the logical clocks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个称为**时钟条件**的正确性准则，用于评估逻辑时钟：
- en: '∀ *a*, *b* : *a* → *b* ⇒ *LC* ( *a*) < *LC* ( *b*) 53'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ∀*a*, *b*：*a* → *b*⇒*LC*(*a*)< *LC*(*b*) 53
- en: '![](index-73_1.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](index-73_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: 'This is read as follows: for all a and b, a happened before b implies that
    the Lamport'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 读法如下：对于所有a和b，a发生在b之前意味着Lamport
- en: clock (timestamp) of a is less than the Lamport clock (timestamp) of b.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: a的时钟（时间戳）小于b的Lamport时钟（时间戳）。
- en: This means that if event A happens before event B, then it implies that the
    Lamport
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果事件A发生在事件B之前，那么意味着Lamport
- en: clock of event A is less than the Lamport clock of event B.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 事件A的时钟小于事件B的Lamport时钟。
- en: Now we can see a picture emerging. Without using physical clocks, we can now
    see
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到一个画面正在浮现。不使用物理时钟，现在我们可以看到
- en: how events in a distributed system can be assigned a number which can be used
    for
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的事件如何被分配一个可以用于
- en: ordering them by using Lamport clocks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Lamport 时钟对它们进行排序。
- en: Now let’s run this algorithm on a simple distributed system composed of three
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在由三个组成的简单分布式系统上运行此算法
- en: processes (nodes, computers) – P, Q, and R.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 过程（节点，计算机）– P、Q 和 R。
- en: 'There are two key properties of this algorithm:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法有两个关键属性：
- en: 1\. If
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如果
- en: '*a* → *b*, then LC(a) < LC(b).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* → *b*，那么 LC(a) < LC(b)。'
- en: 2\. But
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 但是
- en: '*LC*( *a*) < *LC*( *b*) does not mean that *a* → *b*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*LC*( *a*) < *LC*( *b*)并不意味着 *a* → *b*。'
- en: This means that two events can have the same timestamp. As shown in Figur[e
    1-25](#p73), on process lines P and R, notice event timestamp 1 as the same. Did
    you spot a problem
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个事件可以具有相同的时间戳。如图[1-25](#p73)所示，在进程线 P 和 R 上，注意事件时间戳 1 是相同的。你发现了一个问题吗
- en: here? In this scheme, the total order is not guaranteed because two events can
    get the
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里？在这种方案中，总顺序不能被保证，因为两个事件可以得到
- en: same timestamp.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的时间戳。
- en: '***Figure 1-25\.** Example run of a Lamport clock algorithm*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 1-25\.** Lamport 时钟算法的示例运行*'
- en: One obvious way to fix this is to use an identifier for the process with the
    timestamp.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个的一个明显方法是为带有时间戳的进程使用标识符。
- en: This way, the total order can be achieved.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可以实现总排序。
- en: Figur[e 1-26 sho](#p74)ws executions with a totally ordered logical clock.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图[1-26](#p74)以完全有序的逻辑时钟展示了执行。
- en: '54'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: '![](index-74_1.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](index-74_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章 介绍
- en: '***Figure 1-26\.** Example run of a Lamport clock with a total order*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 1-26\.** 具有总序的 Lamport 逻辑时钟的示例运行*'
- en: Knowing the order of events in a distributed system is very useful. The order
    of
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 知道分布式系统中事件的顺序非常有用。事件的顺序
- en: events allows us to find the causality between the events. The knowledge of
    causality in
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 事件使我们能够找到事件之间的因果关系。因果关系的知识
- en: distributed systems helps to solve several problems. Some examples include but
    are not
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统有助于解决几个问题。一些示例包括但不限于
- en: limited to consistency in replicated databases, figuring out causal dependency
    between
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制数据库中的一致性方面有限，找出
- en: different events, measuring the progress of executions in a distributed system,
    and
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不同事件，测量分布式系统中执行的进度，并
- en: measuring concurrency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测量并发。
- en: We can use it to build distributed state machines. If events are timestamped,
    we
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来构建分布式状态机。如果事件被标记了时间戳，我们
- en: can also see when exactly an event has occurred and what happened before and
    what
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以看到确切地发生了一个事件以及之前发生了什么
- en: occurred after, which can help debug and investigate distributed systems’ faults.
    This
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在之后，有助于调试和探索分布式系统的故障。这
- en: knowledge can be instrumental in building debuggers, snapshotting a point in
    time,
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 知识可以在构建调试程序、快照某���特定时间点、
- en: pruning some data before a point in time, and many other use cases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个特定时间点之前修剪一些数据，以及许多其他用例。
- en: The limitation that *LC*( *a*) < *LC*( *b*) does not mean that *a* → *b*. This
    means that Lamport clocks cannot tell if two events are concurrent or not. This
    problem can be
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*LC*( *a*) < *LC*( *b*)的限制并不意味着 *a* → *b*。这意味着 Lamport 时钟不能告诉两个事件是否同时发生。这个问题可以通过'
- en: addressed using vector clocks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量时钟来解决。
- en: '**Vector Clocks**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量时钟**'
- en: It is a type of logical clock which allows detecting concurrent events in addition
    to
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种逻辑时钟类型，允许检测并发事件，以及
- en: determining partial ordering of events and detecting causality violations. Here
    is how
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 确定事件的部分顺序和检测因果关系违规。下面是如何
- en: 'it works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的：
- en: –
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: –
- en: At the start, all vector clocks in a distributed system are set to zero,
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，分布式系统中的所有向量时钟都被设置为零，
- en: that is, [0,0,0,0,0].
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 即，[0,0,0,0,0]。
- en: –
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: –
- en: Whenever an internal event occurs at a process, the process’s logical
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每当进程发生内部事件时，该进程的逻辑
- en: clock value in the vector increments by one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的时钟值递增一。
- en: '55'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: '![](index-75_1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](index-75_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章 介绍
- en: –
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: –
- en: Whenever a process sends a message, the process’s logical clock
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个进程发送消息时，该进程的逻辑时钟
- en: value in the vector increments by one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的值递增一。
- en: –
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: –
- en: Whenever a process receives a message, the process’s logical clock
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个进程接收消息时，该进程的逻辑时钟
- en: value in the vector increments by one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的时钟值递增一。
- en: –
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: –
- en: Each element in the vector increments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的每个元素都会增加。
- en: '**Faults and Fault Tolerance**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障和容错**'
- en: Faults in a distributed system are inevitable. In fact, distributed systems
    are
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们逐一定义每一种。  '
- en: characterized by faults. A large body of work is dedicated to fault tolerance
    and is at
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进程可能表现出较慢行为或运行速度比其他进程快的情况。
- en: the core of the distributed systems research. To understand faults, let’s look
    at a small example.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '分布式系统研究的核心。要了解故障，让我们看一个小例子。  '
- en: Imagine a simplest distributed system with two nodes, shown in Figur[e 1-27](#p75).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，进程未能发送消息。  '
- en: '***Figure 1-27\.** A simplest distributed system*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***图1-27\.** 最简单的分布式系统*'
- en: 'Think about what faults can occur:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: • The processor p1 or p2 may crash.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '遗漏故障是指消息可能丢失。  '
- en: • Communication link can fail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**遗漏故障**'
- en: • Latency on the communication link.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们捕捉处理器响应不正确的情况。  '
- en: • Slow processing at p1 or p2\.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: • p1或p2处的处理速度过慢\。
- en: • P1 can pretend that it sent some message; in fact, it has not.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '多种方式。  '
- en: 'There can be several faults that occur in a distributed system:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '由故障特征化。有很多工作致力于容错，并且是  '
- en: • Process/program faults
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '分布式系统中的故障是不可避免的。事实上，分布式系统是  '
- en: • Communication/link faults
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: • 通信/链接故障
- en: • Storage faults
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '• 存储故障  '
- en: '56'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收遗漏**'
- en: Chapter 1 IntroduCtIon
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '系统文献。这些类型被归类为所谓的故障模型，其中  '
- en: There are several types of faults that have been formally defined in distributed
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中已经形式定义的几种故障。
- en: systems literature. These types are categorized under the so-called fault model
    which
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭故障**'
- en: basically tells us which kind of faults can occur.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，进程可能在任何时间点停止函数。这可能  '
- en: We now define each one of these as follows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种模型中，进程可以展示任意行为；然而，存在对接收到的消息进行验证的过程，这可以通过使用身份验证和数字  '
- en: '**Crash-Stop**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**崩溃-停止**'
- en: In this scenario, a process can fail to stop a function at any point in time.
    This can
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 想想可能发生的故障：
- en: happen when a hardware fault may have occurred in a node. Other nodes are unable
    to
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '发生硬件故障的情况下可能出现的故障。其他节点无法  '
- en: find out about the crash of the node in this model.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: '**Fail-Stop**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统通常可以通过使用故障检测器了解这种故障。
- en: In this model, a process can fail by stopping execution of the algorithm. Other
    nodes in
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个模型中，进程可能通过停止算法的执行来失败。其他节点在这时可能无法  '
- en: the distributed system can learn about this failure, usually by using failure
    detectors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '分布式系统可能发生几种故障：  '
- en: '**Omission Faults**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: • 处理器p1或p2可能会崩溃。
- en: Omission faults are where a message can be lost.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时故障**'
- en: '**Send Omission**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障停止**'
- en: This is where a process fails to send a message.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有身份验证的拜占庭故障**'
- en: '**Receive Omission**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: • 进程/程序故障
- en: This is where a process fails to receive a message.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '在此情况下，进程无法接收消息。  '
- en: '**General Omission**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规遗漏**'
- en: This is where a process may exhibit either a send omission or a receive omission.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，进程可能会出现发送遗漏或接收遗漏。
- en: '**Covert Faults**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐形故障**'
- en: This model captures a behavior where a failure might remain hidden or undetected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '该模型捕捉了可能隐藏或未被检测到的故障。  '
- en: '**Computation Faults**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '找出此模型中节点崩溃的情况。  '
- en: In this scenario, we capture the situation where a processor responds incorrectly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: '57'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '想象一个只有两个节点的最简单的分布式系统，如图[1-27](#p75)所示。  '
- en: Chapter 1 IntroduCtIon
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送遗漏**'
- en: '**Byzantine Faults**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间未收到消息可以视为此类型的例子之一。
- en: This model captures the arbitrary faults where a process may fail in arbitrarily
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型捕捉了进程可能以任意方式失败的故障。
- en: many ways.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: • 通信链路可以失败。
- en: '**Byzantine Faults with Authentication**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有身份验证的拜占庭故障**'
- en: In this model, a process can exhibit arbitrary behavior; however, there is a
    verification of received messages to this process, which is possible by using
    authentication and digital
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '在此模型中，进程可以展示任意行为，但不进行消息验证  '
- en: signatures. This nonrepudiation and verification can make dealing with Byzantine
    faults
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '签名。这种不可否认性和验证可以使处理拜占庭故障  '
- en: a bit easier.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '变得更容易一些。  '
- en: '**Byzantine Faults Without Authentication**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算故障**'
- en: In this model, a process can exhibit arbitrary behavior, but no message verification
    is
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '最初可能看起来像部分同步行为，但一个未能及时  '
- en: possible to ascertain the validity of the messages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可以确定消息的有效性。
- en: '**Timing Faults**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: • 通信链路上的延迟。
- en: This is where a process can exhibit slow behavior or may run faster than other
    processes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上告诉我们可能发生的哪些类型的故障。
- en: This can initially look like a partially synchronous behavior, but a node that
    has not
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 执行函数的节点。
- en: received a message for a very long time can be seen as one example of this type
    of
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: • p1可以假装发送了某个消息；实际上并没有。
- en: fault. This covers scenarios where an expected message delivery is not in line
    with the
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 故障。这涵盖了预期消息交付与
- en: expected delivery time or lies outside the specified time interval.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 预期交付时间或超出指定的时间间隔。
- en: Failures can be detected using failure detectors where a process can be suspected
    of
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用故障检测器来检测故障，其中一个进程可以被怀疑
- en: a failure. For example, a message not received for an extended period of time
    or that has gone past the threshold of timeout can be marked as a failed process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 失效。例如，一条在很长时间内没有收到的消息或超过了超时阈值的消息可以标记为失败进程。
- en: More on failure detector in Chapt[er 3; no](https://doi.org/10.1007/978-1-4842-8179-6_3)w
    let’s discover what a fault model is and fault classes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chapt[er 3; 进一步深入](https://doi.org/10.1007/978-1-4842-8179-6_3)nw让我们来了解什么是故障模型和故障类别。
- en: In Figur[e 1-28](#p78), we can visualize various classes of faults, where Byzantine
    faults encompass all types of faults at varying degrees of complexity and can
    happen
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Figur[e 1-28](#p78)中，我们可以将各种故障类别可视化，拜占庭故障包含了各种不同程度的复杂故障，并且可以发生
- en: arbitrarily, whereas crash faults are the simplest type of faults.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 任意地，而崩溃故障是最简单的故障类型。
- en: '58'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: '![](index-78_1.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](index-78_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 引言
- en: '***Figure 1-28\.** Diagram of fault models and fault classes*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '***图1-28**.** 故障模型和故障类别示意图*'
- en: Fault classes allow us to see what faults can occur, whereas fault models help
    us
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 故障类别让我们看到可能发生的故障，而故障模型则帮助我们
- en: to see what kind of faults the system can exhibit and what types of faults should
    be
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 来看一下系统可能出现的故障类型和应该被
- en: tolerated in our distributed algorithm.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的分布式算法中是可以容忍的。
- en: A system or algorithm that can tolerate crash faults only is called a crash
    fault
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 只能容忍崩溃故障的系统或算法被称为崩溃故障
- en: tolerant or CFT in short. In contrast, a system that can handle Byzantine faults
    is called the Byzantine fault–tolerant system or algorithm. Usually, this applies
    to consensus
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 耐拜占庭或简称CFT。相比之下，系统可以处理拜占庭故障的算法或系统被称为拜占庭容错系统或算法。通常情况下，这适用于一致性
- en: mechanisms categorized and developed with the goal of crash fault tolerance
    or
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 机制被分类和开发的目标是崩溃故障容忍或
- en: Byzantine fault tolerance. We will see more about this in Chapt[er 3, wher](https://doi.org/10.1007/978-1-4842-8179-6_3)e
    we discuss consensus algorithms.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭故障容忍。我们在Chapt[er 3, wher](https://doi.org/10.1007/978-1-4842-8179-6_3)e讨论共识算法时会详细讨论更多内容。
- en: '**Safety and Liveness**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性和活性**'
- en: Remember we discussed in communication abstractions that broadcast protocols
    and
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在通信抽象中讨论了广播协议和
- en: point-to-point links have some properties. For example, a fair-loss property
    ensures that messages sent will eventually be delivered under fair-loss links.
    This type of property
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点链路具有一些属性。例如，公平丢失属性确保在公平丢失链路下发送的消息最终会被传递。这种属性
- en: where something will eventually happen is considered a liveness property. Colloquially
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中最终会发生某事情被看作是一个活性属性。口头上
- en: speaking, this means that something good will eventually occur.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这意味着最终会发生一些好事情。
- en: '59'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '59'
- en: Chapter 1 IntroduCtIon
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 引言
- en: Also, remember that under the finite duplication property for fair-loss links,
    we said
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还记得在公平丢失链路的有限复制属性下，我们说
- en: that there are finite message duplications. This type of property where something
    can be
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有有限的消息复制。这种属性就是一个系统可以容忍
- en: measured and observed infinite time is called a safety property. Colloquially
    speaking,
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 测量和观察无限时间的叫做安全性属性。口头上说
- en: this means that something bad never happens. Of course, if you don’t do anything,
    then
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着永远不会发生坏事情。当然，如果你什么也不做，那么
- en: nothing will ever happen, which theoretically satisfies the safety property;
    however, the system is not making any progress in this scenario. Therefore, the
    liveness property,
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不会发生任何事情，这从理论上满足了安全性属性；然而，在这种情况下系统没有任何进展。因此，活性属性
- en: which ensures the progress of the system, is also necessary.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 进行系统的进展也是必要的。
- en: These properties are used in many different distributed algorithms to reason
    about
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性用于许多不同的分布式算法来推理
- en: the correctness of the protocols. In addition, they are frequently used in describing
    the safety and liveness requirements and properties of consensus protocols. We
    will cover
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的正确性。此外，它们经常用于描述一致性协议的安全性和活性要求和属性。我们将会覆盖
- en: distributed consensus in detail in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3)中详细讨论分布式一致性。
- en: Safety and liveness are correctness properties of a distributed algorithm. For
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和活跃性是分布式算法的正确性属性。对于
- en: example, the safety and liveness of traffic signals at a crossing can be described
    as
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，交叉路口交通信号的安全性和活跃性可以描述为
- en: follows. The safety properties in this scenario are that, at a time, only one
    direction must be a green light, and no signal should have all lights turned on
    at the same time. Another safety property could be that the system should turn
    off no signals. And the liveness
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 随之而来的是：在这种情况下的安全属性是，任何时刻，只有一个方向必须是绿灯，而且没有信号应该同时亮着所有灯。另一个安全属性可能是系统不应该关闭任何信号。而活跃性
- en: property is that, eventually, each signal must get the green light.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是，最终，每个信号灯都必须变成绿灯。
- en: For example, in a partially synchronous system, to prove safety properties,
    it is
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在部分同步系统中，为了证明安全属性，这是
- en: assumed that the system is asynchronous, whereas to prove the liveness of the
    system,
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统是异步的，而为了证明系统的活跃性，
- en: the partial synchrony assumption is used. The progress of liveness of the system
    is
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 部分同步假设被使用。系统的活跃性进展是
- en: ensured in a partially synchronous system, for example, after GST when the system
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分同步系统中得到保证，例如，GST之后，系统
- en: is synchronous for long enough to allow the algorithm to achieve its objective
    and
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间的同步的确足以让算法实现其目标并
- en: terminate.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 终止。
- en: For a distributed system to be practical, safety and liveness properties must
    be
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要使分布式系统实际可行，必须保证安全性和活跃性属性
- en: specified and guaranteed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 指定和保证。
- en: '**Forms of Fault Tolerance**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**容错形式**'
- en: A correct program (distributed algorithm) satisfies both its safety and liveness
    properties.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的程序（分布式算法）满足其安全性和活跃性属性。
- en: If a program tolerates a given class of faults and remains alive and safe, we
    call this type of fault tolerance masking. If a program can remain safe but not
    live, we call this type of fault tolerance fail-safe. Similarly, in the presence
    of faults, a program cannot remain
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序容忍一类给定的故障并保持活跃和安全，我们称这种容错能力为掩护式。如果一个程序可以保持安全但不能保持活跃，我们称这种容错能力为故障安全。同样，在故障存在的情况下，程序不能保持
- en: safe (not safe) but remains live. Such behavior is called nonmasking. If a program
    is
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 安全（不安全）但仍然保持活跃。这种行为称为非掩护。如果程序是
- en: neither live nor safe in the presence of faults, it means that this program
    does not depict any form of fault tolerance.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障存在的情况下，既不活跃也不安全，这意味着这个程序不具备任何形式的容错能力。
- en: '60'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '60'
- en: Chapter 1 IntroduCtIon
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章 引言
- en: '**CAP Theorem**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP定理**'
- en: The CAP theorem states that a distributed system can only deliver two of three
    desired
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理规定分布式系统只能实现三项中的两项所需的
- en: features, that is, consistency, availability, and partition tolerance. Let’s
    first define these terms, and then we’ll investigate the theorem in more detail.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 特性，即一致性，可用性和分区容忍。让我们首先定义这些术语，然后我们将更详细地调查定理。
- en: '**Consistency**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性**'
- en: The consistency property means that data should be consistent across all nodes
    in the
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性属性意味着数据应该在所有节点之间保持一致
- en: distributed system, and the client connecting to the distributed system at the
    same time
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统，以及同时连接到分布式系统的客户端
- en: should see the same consistent data. This is commonly achieved using replication.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 应该看到相同一致的数据。这通常是通过复制来实现的。
- en: '**Availability**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性**'
- en: Availability means the distributed system responds to the client requests even
    in the
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性意味着分布式系统即使在
- en: presence of faults. This is achieved using fault tolerance techniques such as
    replication, partitioning, or sharding.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 故障存在的情况下。这是使用容错技术如复制，分区或分片来实现的。
- en: '**Partition Tolerance**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区容错**'
- en: A partition refers to a scenario where the communication link between two or
    more
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 分区指的是两个或多个之间的通信链路
- en: nodes breaks. A distributed system should be able to tolerate that and continue
    to
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 节点中断。分布式系统应该能够容忍并继续
- en: operate correctly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地运行。
- en: We know that partitions in a network are almost inevitable; sooner or later,
    there
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道网络中的分区几乎是不可避免的; 迟早会有
- en: will be some communication disruption. This means that as network partitions
    are
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一些通信中断。这意味着随着网络分区的出现
- en: unavoidable, the choice really becomes to choose between availability and consistency.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免的，选择实际上是在可用性和一致性之间做出选择。
- en: The question becomes, in the case of partitions, what we are willing to sacrifice,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，在分区的情况下，我们愿意牺牲什么，
- en: consistency or availability. It all depends on the use case. For example, in
    a financial
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性或可用性。这完全取决于具体情况。例如，在一个金融
- en: application, it’s best to sacrifice availability in favor of consistency, but
    perhaps on web search results, we could sacrifice a bit of consistency in favor
    of availability. It should be noted that when there are no network partitions,
    consistency and availability are
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序时，最好牺牲可用性而取得一致性优势，但在 web 搜索结果中，我们可以牺牲一定的一致性来换取可用性。应该注意的是，在没有网络分区时，一致性和可用性是
- en: both provided. But then again, if a network partition occurs, then what do we
    choose,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 都提供。但再一次，如果出现网络分区，那么我们选择什么，
- en: availability or consistency?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性还是一致性?
- en: A Venn diagram shown in Figure [1-29](#p81) can be used to visualize this concept.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 1-29  图中所示的 Venn 图可以用来直观展示这个概念。
- en: '61'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '61'
- en: '![](index-81_1.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![1-29\. CAP 定理*](index-81_1.png)'
- en: Chapter 1 IntroduCtIon
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章介绍
- en: '***Figure 1-29\.** CAP theorem*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 1-29\.** CAP 定理*'
- en: The CAP theorem allows us to categorize databases (NoSQL DBs) based on the
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: CAP 定理允许我们根据
- en: properties they support. For example, a CP database provides consistency and
    partition
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它们支持的属性。例如，CP 数据库提供了一致性和分区
- en: tolerance but sacrifices availability. In the case of a partition, the nonconsistent
    nodes are shut down until the network partition heals. An AP database sacrifices
    consistency
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 容错性，但牺牲了可用性。在分区的情况下，非一致性节点被关闭，直到网络分区恢复。AP 数据库牺牲了一致性
- en: but offers availability and partition tolerance. In the case of a network partition,
    there is a chance that nodes that have not been able to get the updates due to
    a network
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 但提供可用性和分区容忍性。在网络分区的情况下，存在一种可能性，即由于网络
- en: partition will continue to serve old data. This might be acceptable in some
    scenarios,
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 分区将继续提供旧数据。在某些场景中，这可能是可以接受的，
- en: such as a web search. When the partition heals, the out-of-sync nodes are synchronized
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 web 搜索。当分区恢复时，不同步的节点会被同步
- en: with the latest updates. On the other hand, a CA database is not partition tolerant
    and
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与最新的更新。另一方面，CA 数据库没有容错性和
- en: can provide both consistency and availability only if the network is healthy.
    As we saw
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在网络健康的情况下才能提供一致性和可用性。正如我们看到的
- en: earlier, network partitions are inevitable; therefore, CA databases only exist
    in an ideal world where no network partitions occur.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 早先，网络分区是不可避免的；因此，CA 数据库只存在于理想的世界中，即没有网络分区发生的世界。
- en: While the CAP theorem is helpful, there are many other more precise impossibility
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CAP 定理是有帮助的，但还有许多其他更精确的不可能
- en: results in distributed computing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 导致分布式计算。
- en: Let’s now discuss what eventual consistency is. Eventual consistency refers
    to a
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下最终一致性是什么。最终一致性指的是
- en: situation where nodes may disagree or not update their local database, but,
    eventually,
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可能存在不一致或不更新他们的本地数据库，但最终
- en: the state is agreed upon and updated.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一致的并得到更新。
- en: One example of such a scenario could be when an electronic voting system captures
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的情景的一个例子可能是当一个电子投票系统捕获
- en: voters’ votes and writes them to a central vote registration system. However,
    it could
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 选民的选票并将其写入中央投票注册系统。但是，它可能
- en: happen that due to a network partition, the communication link in the central
    vote
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络分区，中央投票的通信链路可能发生故障
- en: '62'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '62'
- en: Chapter 1 IntroduCtIon
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章介绍
- en: registration system is lost, and this voting machine is now not able to write
    data to the backend voting registration system. It could now keep receiving votes
    from the user and
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注册系统丢失，这台投票机现在无法将数据写入后端投票注册系统。现在它能够从用户那里不断地接收选票，并且
- en: record them locally, and when the network partition heals, it can write the
    ballots back
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们记录在本地，并在网络分区恢复时，可以将选票写回
- en: to the central vote registration system. During the network partition from the
    central vote registration system’s point of view, the count of votes is different
    from what the voting machine can see. The machine can write back to the central
    vote registration system
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到中央投票注册系统。在中央投票注册系统的网络分区中，选票的数量与投票机所见到的不同。机器可以写回中央投票注册系统
- en: when the partition heals to achieve consistency. The consistency between the
    backend
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当分区恢复以实现一致性时。后端之间的一致性
- en: server storage and local storage is not achieved immediately, but, over time,
    this type of consistency is called eventual consistency.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器存储和本地存储不会立即实现，但随着时间的推移，这种一致性称为最终一致性。
- en: A now established example of an eventually consistent system is Bitcoin. We
    will
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当前已经确立的一个最终一致性系统的例子是比特币。我们将
- en: learn more about this in Chapt[er 4](https://doi.org/10.1007/978-1-4842-8179-6_4)
    and see how Bitcoin is eventually consistent.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多信息，请查看第[4](https://doi.org/10.1007/978-1-4842-8179-6_4)章，看看比特币如何实现最终一致性。
- en: The domain name system (DNS) is the most prevalent system that implements
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）是实现
- en: eventual consistency. When a name is updated, it is distributed as per a configured
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性。当名称更新时，它会根据配置的方式进行分发
- en: pattern, and, eventually, all clients see the update.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 模式，并且最终所有客户端都能看到更新。
- en: Through the lens of the CAP theorem, the distributed consensus is a CP system
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CAP理论的视角看，分布式共识是一个CP系统
- en: where availability is sacrificed in favor of consistency. As a result, the distributed
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在牺牲可用性以保证一致性的情况下。因此，分布式
- en: consensus is used to provide strong consistency guarantees.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 共识被用来提供强一致性的保证。
- en: For example, if you have a five-node system and three nodes go down, then the
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个五节点系统，其中三个节点宕机，那么
- en: whole system stalls until the other three nodes come up. This is so that a consistency
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统会一直停滞，直到其他三个节点重新上线。这是因为一致性
- en: guarantee can be maintained, even if the system is not available for some time.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 即使系统一段时间不可用，也可以保持这种保证。
- en: If we look at Bitcoin, it appears that it is an AP system where consistency
    is sacrificed for some time due to forks, but, eventually, the consistency is
    achieved. Therefore,
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看比特币，似乎它是一个牺牲一致性一段时间的AP系统，但是最终一致性被实现。因此，
- en: Bitcoin can also be considered a CP system where consistency is eventually strong.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币还可以被视为是一个保证最终强一致性的CP系统。
- en: Usually, strong consistency (also called linearizability) is for what distributed
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，强一致性（也称为线性一致性）是分布式系统
- en: consensus is used for; however, eventual consistency in systems like Bitcoin
    is also
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 共识这是专门用于的；然而，在比特币等系统中，最终一致性也是
- en: acceptable.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的。
- en: '**Cryptography in Distributed Systems**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式系统中的密码学**'
- en: Distributed systems operate under challenging conditions where they are exposed
    to
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统在暴露于具有挑战性的条件下运行，他们面对着
- en: adversaries, faults, and untrusted users. In such conditions, it becomes critical
    to protect the distributed system against all these threats. Therefore, appropriate
    security measures are put in place to thwart any attempts to disrupt the system.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对手、故障和不受信任的用户。在这种情况下，保护分布式系统免受所有这些威胁变得至关重要。因此，必须采取适当的安全措施来阻止任何破坏系统的企图。
- en: '63'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '63'
- en: Chapter 1 IntroduCtIon
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: The usual security services required in a distributed system include confidentiality,
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中通常需要的安全服务包括保密性，
- en: integrity, access control, and authentication. To this end, cryptography plays
    a vital role in distributed systems.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性、访问控制和认证。为此，加密学在分布式系统中发挥着重要作用。
- en: Cryptographic protocols provide security services in a distributed system by
    utilizing
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 加密协议通过利用
- en: cryptographic primitives such as symmetric cryptography, asymmetric cryptography,
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对统称密码学原语，如对称密码学、非对称密码学
- en: and hash functions.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 和哈希函数。
- en: We will cover this topic in Chapter [2, wher](https://doi.org/10.1007/978-1-4842-8179-6_2)e
    we study cryptography in general and its applications in distributed systems and
    blockchain. Chapter [2](https://doi.org/10.1007/978-1-4842-8179-6_2) will introduce
    several primitives that are useful in consensus protocols and blockchain for achieving
    data
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [2, wher](https://doi.org/10.1007/978-1-4842-8179-6_2)章学习加密学以及其在分布式系统和区块链中的应用时，介绍这个主题。第
    [2](https://doi.org/10.1007/978-1-4842-8179-6_2)章将介绍几种在共识协议和区块链中实现数据一致性的原语。
- en: integrity and relevant security purposes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性和相关的安全目的。
- en: '**Summary**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: 'We covered several topics in this chapter:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章中涵盖了几个主题：
- en: • A distributed system is a set of interconnected computers
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: • 分布式系统是一组互相连接的计算机
- en: coordinating together via messages to achieve a common goal.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息协调一起达成共同目标。
- en: • Distributed systems face several challenges. The most prominent are
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: • 分布式系统面临着几个挑战。最突出的是
- en: (1) no common global knowledge, (2) no global time, (3) achieving
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: （1）没有共同的全局知识，（2）没有全局时间，（3）实现
- en: consistency, and (4) failures.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性，以及（4）故障。
- en: • A distributed system model allows us to reason about the system and
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: • 分布式系统模型使我们能够推理出系统并
- en: abstract away all unnecessary details.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象出所有不必要的细节。
- en: • The leap second bug that is a cause of significant disruption of
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: • 长秒钟错误是导致
- en: Internet services and several techniques has been developed to
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务和已开发出多种技术
- en: address this.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题。
- en: • Safety and liveness properties must be ensured in distributed
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: • 必须确保分布式系统中的安全性和活性属性
- en: systems.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。
- en: • Crash fault–tolerant distributed algorithms only handle crash faults,
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: • 故障容错分布式算法仅处理崩溃故障，
- en: whereas Byzantine fault–tolerant algorithms are designed to handle
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 而拜占庭容错算法则被设计用于处理
- en: arbitrary faults.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 任意故障。
- en: • Logical clocks do not depend on physical clocks and can be used to
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: • 逻辑时钟不依赖于物理时钟，可以用来
- en: define the order of events in a distributed system.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 定义分布式系统中事件的顺序。
- en: '64'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '64'
- en: Chapter 1 IntroduCtIon
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章 介绍
- en: • In a distributed system, the same algorithm runs on all computers
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: • 在分布式系统中，相同的算法在所有计算机上运行
- en: concurrently to achieve a common goal.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 并发地实现共同目标。
- en: • The CAP theorem states that a distributed system can only deliver
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: • CAP定理指出分布式系统只能提供
- en: two of three desired features, that is, consistency, availability, and
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 三个所需特性中的两个，即一致性、可用性和
- en: partition tolerance.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 分区容错。
- en: '**Bibliography**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: 1\. Safety and liveness properties were first formalized in a paper
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 安全性和活性特性首次在一篇论文中形式化
- en: by Alpern, B. and Schneider, F.B., 1987\. Recognizing safety and
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由Alpern, B.和Schneider, F.B., 1987\. 识别安全性和
- en: liveness. Distributed computing, 2(3), pp. 117–126\.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 活性。分布式计算, 2(3), 第117–126页\.
- en: 2\. Notion of timing and ordering of events was first introduced in
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 事件的时序和排序的概念首次在
- en: 1978 in "Lamport, L., 2019\. Time, clocks, and the ordering of
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 1978年在"Lamport, L., 2019\. 时间、钟表和
- en: 'events in a distributed system. In Concurrency: the Works of Leslie'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的事件。在并发：Leslie的作品
- en: Lamport (pp. 179–196)."
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Lamport（第179–196页）。“
- en: 3\. Cachin, C., Guerraoui, R., and Rodrigues, L., 2011\. Introduction to
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. Cachin, C., Guerraoui, R.,和Rodrigues, L., 2011\. 引言到
- en: reliable and secure distributed programming. Springer Science &
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠和安全的分布式编程。Springer Science &
- en: Business Media.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 商业媒体。
- en: 4\. Brewer, E.A., 2000, July. Towards robust distributed systems. In
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. Brewer, E.A., 2000年7月。走向稳健的分布式系统。在
- en: PODC (Vol. 7, No. 10.1145, pp. 343477–343502).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: PODC（第7卷, No. 10.1145, 第343–343502页）。
- en: 5\. Van Steen, M. and Tanenbaum, A., 2002\. Distributed systems
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. Van Steen, M.和Tanenbaum, A., 2002\. 分布式系统
- en: principles and paradigms. Network, 2, p. 28\.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 原则和范例。网络, 2, p. 28\.
- en: '6\. Coulouris, G., Dollimore, J., and Kindberg, T. Distributed Systems:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. Coulouris, G., Dollimore, J., 和Kindberg, T. 分布式系统：
- en: Concepts and Design Edition 3\. System, 2(11), p. 15\.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和设计第3版。系统，2(11), p. 15\.
- en: '7\. Kleppmann, M., 2017\. Designing data-intensive applications: The'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. Kleppmann, M., 2017\. 设计数据密集型应用程序：The
- en: big ideas behind reliable, scalable, and maintainable systems.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠、可扩展和易维护系统背后的重要理念。
- en: O’Reilly Media, Inc.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: O’Reilly Media, Inc.
- en: 8\. Kleppmann, M., Distributed Systems. Vancouver.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. Kleppmann, M., 分布式系统。温哥华。
- en: '9\. Sapphire clocks[: https://sciencemeetsbusiness.com.au/](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '9\. 蓝宝石钟[: https://sciencemeetsbusiness.com.au/](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
- en: '[sapphire-clock/](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[蓝宝石钟](https://sciencemeetsbusiness.com.au/sapphire-clock/)'
- en: '65'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '65'
- en: Chapter 1 IntroduCtIon
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章 介绍
- en: 10\. Sapphire clocks[: https://spectrum.ieee.org/for-precision-](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '10\. 蓝宝石钟[: https://spectrum.ieee.org/](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
- en: '[the-sapphire-clock-outshines-even-the-best-atomic-](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[蓝宝石钟超越了最好的原子钟](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
- en: '[clocks?utm_campaign=post-teaser&utm_content=7190c3vu](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[时钟？utm_campaign=post-teaser&utm_content=7190c3vu](https://spectrum.ieee.org/for-precision-the-sapphire-clock-outshines-even-the-best-atomic-clocks?utm_campaign=post-teaser&utm_content=7190c3vu)'
- en: '11\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. Bashir, I., 2020\. 掌握区块链：深度挖掘
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式分类帐、共识协议、智能合约、DApp等，
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学货币、以太坊等。 Packt Publishing Ltd.
- en: '12\. Baran, Paul. On Distributed Communications: I. Introduction to'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. Baran, Paul. 关于分布式通信：I. 介绍到
- en: 'Distributed Communications Networks. Santa Monica, CA: RAND'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式通信网络。圣莫尼卡，加利福尼亚：兰德
- en: Corporation, 1964\. [www.rand.org/pubs/research_memoranda/](http://www.rand.org/pubs/research_memoranda/RM3420.html)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 公司，1964年。[www.rand.org/pubs/research_memoranda/](http://www.rand.org/pubs/research_memoranda/RM3420.html)
- en: '[RM3420.html. Als](http://www.rand.org/pubs/research_memoranda/RM3420.html)o
    available in print form.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[RM3420.html. 也](http://www.rand.org/pubs/research_memoranda/RM3420.html)可打印形式。'
- en: '66'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '66'
- en: '**CHAPTER 2**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2章**'
- en: '**Cryptography**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码学**'
- en: This chapter will cover cryptography and its two main types, symmetric cryptography
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖密码学及其两种主要类型，对称密码学
- en: and public key cryptography. After exploring some fundamental ideas, we will
    dive
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 和公钥密码学。在探索了一些基本思想之后，我们将深入研究
- en: deeper into symmetric key primitives and then public key primitives.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地了解对称密钥原语，然后是公钥原语。
- en: Moreover, we will examine hash functions, message authentication codes, digital
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们将审查哈希函数、消息认证码、数字
- en: signature schemes, and elliptic curve cryptography. Finally, we’ll shed some
    light on
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 签名方案和椭圆曲线密码学。最后，我们将为你解释一些信息
- en: some progressive ideas, proposals, and techniques, especially those which are
    used in
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一些渐进的想法，提议和技术，特别是那些用于
- en: blockchain consensus.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链共识。
- en: '**Introduction**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**介绍**'
- en: Cryptography is the science of secret communication in the presence of adversaries.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是在敌手存在的情况下进行秘密通信的科学。
- en: Historically, this subject was more of an art, but, now, it is a rigorous and
    formal science with formal definitions, assumptions, and security proofs.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上讲，这个主题更多的是艺术，但是现在它是一个严格的和正式的科学，有着正式的定义、假设和安全性证明。
- en: 'There are three fundamental principles of cryptography: confidentiality, integrity,'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个密码学的基本原则：保密性，完整性，
- en: and authenticity. Confidentiality is the assurance that the information is available
    only to the authorized entities. Integrity assures that only authorized entities
    can modify the information. Finally, authenticity guarantees the message validity
    or identity of an entity.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 和真实性。保密性是确保信息只可用于授权实体。完整性确保只有授权实体能够修改信息。最后，真实性保证消息的有效性或实体的身份。
- en: Authentication can be of two types, entity authentication or data origin authentication.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 认证可以是两种类型，实体认证或数据来源认证。
- en: Entity authentication ensures that an entity claiming some identity (the claimant)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 实体认证确保一个声称某种身份的实体（申请者）
- en: is verifiably identifiable to another identity (the verifier) and that the entity
    is alive and participating. Different methods such as something you have (e.g.,
    a hardware token),
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 可以确切地识别另一个身份（验证者）并且实体是活着并参与的。一些不同的方法，如你拥有的东西（例如，硬件令牌），
- en: something you know (e.g., a password), and something you are (e.g., fingerprint)
    are
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 你所知道的东西（例如，密码），以及你是什么（例如，指纹）
- en: used to achieve entity authentication in identification protocols. Entity authentication
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在识别协议中实现实体认证。实体认证
- en: is of a fundamental concern in a secure distributed system. As a distributed
    system
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 是安全分布式系统中的基本关注点。作为分布式系统
- en: is dispersed and heterogenous, with multiple users, it can become an easy target
    for
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 是分散和异质的，具有多个用户，它可以成为一个容易的攻击目标
- en: '67'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '67'
- en: © Imran Bashir 2022
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: © 伊姆兰·巴希尔 2022
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_2](https://doi.org/10.1007/978-1-4842-8179-6_2#DOI)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: I. 巴希尔，*区块链共识*，[https://doi.org/10.1007/978-1-4842-8179-6_2](https://doi.org/10.1007/978-1-4842-8179-6_2#DOI)
- en: '![](index-87_1.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](index-87_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章 密码学
- en: adversarial attacks. Especially in the case of blockchains and specifically
    consensus
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗攻击。特别是在区块链的情况下，特别是共识
- en: protocols running on blockchains, entity authentication is of prime importance
    to
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 运行于区块链的协议，实体认证对
- en: ensure protection against adversarial attacks. Authentication protocols are
    built using
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 确保防范对抗攻击。认证协议是使用
- en: symmetric and public key cryptography.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对称和公钥密码学。
- en: Another related assurance is nonrepudiation, where an entity after performing
    an
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的保证是不可否认，即实体在执行后
- en: action cannot deny its action. Usually, this is achieved by digital signatures.
    In addition to two-party protocols, there also are multiparty nonrepudiation protocols
    that are
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 行为不能否认其行为。通常，这是通过数字签名实现的。除了双方协议，还有多方不可撤销协议
- en: suitable for multiple parties.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于多方。
- en: Data origin authentication or message authentication ensures that the source
    of
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来源认证或消息认证确保信息
- en: information is authentic and verified. Message authentication codes (MACs) and
    digital
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 信息是真实和经过验证的。消息认证码（MAC）和数字
- en: signatures are used to provide data origin authentication.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 签名用于提供数据的原始认证。
- en: '**A Typical Cryptosystem**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型的密码系统**'
- en: A typical model of a cryptographic system is shown in Figur[e 2-1\. W](#p87)e
    can define a cryptographic system as a combined manifestation of cryptographic
    primitives,
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的密码系统模型如图[2-1\. 中](#p87)所示，我们可以将密码系统定义为密码原语的组合体，
- en: protocols, and algorithms to accomplish specified security goals. Thus, a cryptosystem
    is composed of several components.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和算法来实现指定的安全目标。因此，加密系统由几个组件组成。
- en: '***Figure 2-1\.** A model of a cryptographic system or cryptographic scheme*'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-1\.** 密码系统或加密方案的模型*'
- en: '68'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '68'
- en: Chapter 2 Cryptography
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码术
- en: 'There are three key actors in this system: sender, receiver, and adversary.
    The sender'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在该系统中有三个主要角色：发送方、接收方和对手。发送方
- en: wants to send a secret message to the receiver via an insecure channel in the
    presence
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 想要通过不安全的通道发送秘密消息给接收方，在对方存在的情况下
- en: of an adversary who is a malicious attacker wishing to learn about the message.
    Other
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意的攻击者希望了解有关消息的消息的对手。其他
- en: 'elements are plaintext, ciphertext, keys, secure channel, encryption function,
    decryption function, and key source:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 元素包括明文、密文、密钥、安全通道、加密函数、解密函数和密钥源：
- en: • A sender is the sending party of the message.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: • 发送方是消息的发送方。
- en: • A receiver is the intended recipient of the message.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: • 接收方是消息的预期接收方。
- en: • An encryption function is the encryption algorithm which transforms
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: • 加密函数是将加密算法转换为的的算法
- en: a plaintext into ciphertext by using an encryption key and plaintext
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加密密钥和明文将明文转换为密文。
- en: as input.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入。
- en: • A decryption function is the decryption algorithm which converts
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: • 解密函数是将解密算法转换为的的算法
- en: ciphertext into plaintext by using a decryption key and ciphertext
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用解密密钥和密文将密文转换为明文
- en: as input.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入。
- en: • Plaintext is the raw message which Alice wants to send to Bob in
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: • 明文是Alice希望发送给Bob的原始消息
- en: such a way that no one learns about the original message except the
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就没有人可以了解原始消息，除了
- en: intended recipient. It is readable and accessible by Alice and any
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的接收方。它是可读的并且易于Alice和任何
- en: authorized entity.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 授权实体。
- en: • Ciphertext is the scrambled form of the plaintext, which unless
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: • 密文是明文的混淆形式，除非
- en: decrypted is meaningless to anyone reading it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 解密是对读取它的任何人都毫无意义。
- en: • A key source is a key management system or some source of
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: • 密钥源是密钥管理系统或一些
- en: cryptographic keys from which keys are obtained or generated.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 生成或获得密钥的密码。
- en: • A key is some value that is used to encrypt and/or decrypt data.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: • 密钥是用于加密和/或解密数据的某个值。
- en: • A secure channel is some channel through which messages can pass
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: • 安全通道是通过该通道可以传递消息的一些通道
- en: unencrypted without the possibility of eavesdropping.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 未经窥视的情况下对消息进行解密。
- en: • An adversary is some malicious hacker (or eavesdropper, observer)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: • 对手是一些恶意的黑客（或窥视者，观察者）
- en: who can read the encrypted data and tries to learn some information
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 谁可以读取加密数据并尝试了解一些信息
- en: by cryptanalyzing it or by some other means.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对其进行密码分析或其他手段来获取。
- en: '69'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '69'
- en: '![](index-89_1.png)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](index-89_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码术
- en: '**Cryptographic Primitives**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码原语**'
- en: A cryptographic primitive is a fundamental method that delivers particular security
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 加密原语是提供特定安全性的基础方法。
- en: services, for example, confidentiality or integrity. These cryptographic primitives
    are
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 服务，例如保密性或完整性。这些密码原语
- en: used to build security protocols, such as authentication protocols. Cryptographic
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建安全协议，例如认证协议。密码
- en: primitives include symmetric primitives, asymmetric primitives, and keyless
    primitives.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 原语包括对称原语、非对称原语和无密钥原语。
- en: A high-level taxonomy of cryptographic primitives is shown in Figure [2-2](#p89).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了密码原语的高级分类，如图[2-2](#p89)所示。
- en: '***Figure 2-2\.** Cryptographic primitives*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-2\.** 密码原语*'
- en: Now let’s have a look at the symmetric primitives.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看对称原语。
- en: '**Symmetric Cryptography**'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**对称加密**'
- en: Symmetric cryptosystems use the same key for encryption and decryption. The
    key
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密系统使用相同的密钥进行加密和解密。该密钥
- en: must be kept secret and transferred over a secure channel before the data transfer
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 必须保密并在数据传输之前通过安全通道传输
- en: between a sender and a receiver. For secure key transfers, key establishment
    protocols
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方和接收方之间。对于安全的密钥传输，密钥建立协议
- en: are used. Usually, public key cryptography is used to exchange keys, allowing
    for easier
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用公钥密码学来交换密钥，从而更容易
- en: key management than symmetric key management, where it can become challenging
    to
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥管理比对称密钥管理更具挑战性，因为它可能变得具有挑战性
- en: manage keys as the number of users grows.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用户数量的增长，管理密钥变得困难。
- en: '70'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: '![](index-90_1.png)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![](index-90_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: The primary purpose of designing symmetric cryptography algorithms is to provide
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密码算法的主要目的是提供
- en: confidentiality, but we can also use them to provide other security services,
    such as data origin authentication.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性，但我们也可以使用它们来提供其他安全服务，如数据源认证。
- en: There are two classes of symmetric cryptosystems, stream ciphers and block ciphers.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 有两类对称加密系统，流密码和分组密码。
- en: Figur[e 2-3 sho](#p90)ws how stream and block ciphers operate at a high level.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-3展示](#p90)了流密码和分组密码的高层操作方式。
- en: '***Figure 2-3\.** Stream (left) vs. block ciphers (right)*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-3\.** 流密码（左）vs. 分组密码（右）*'
- en: '**Stream Ciphers**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**流密码**'
- en: These cryptosystems encrypt the plaintext one bit at a time. The algorithm takes
    a single bit of the plaintext as input, processes it, and produces a single bit
    of ciphertext. The processing involves the use of XOR operations to perform encryption
    and decryption.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这些加密系统一个比特一次加密明文。算法以明文的单个位为输入，对其进行处理，生成单个位的密文。处理涉及使用异或操作执行加密和解密。
- en: The model of stream ciphers is in Figure [2-4](#p91).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码模型如图[2-4](#p91)所示。
- en: '71'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '71'
- en: '![](index-91_1.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![](index-91_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-4\.** Stream cipher model*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-4\.** 流密码模型*'
- en: In this model, plaintext feeds into the encryption function bit by bit along
    with a
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，明文逐位输入到加密函数中，与
- en: keystream generated by the key generator. The key generator generates a pseudorandom
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥生成器生成的密钥流。密钥生成器生成一个伪随机
- en: keystream which is usually much smaller than the plaintext. Usually, the key
    length is
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 通常比明文要小得多。通常，密钥长度是
- en: 128 bits. The keystream and plaintext go through the XOR to produce the ciphertext.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 128位。密钥流和明文经过异或运算产生密文。
- en: During decryption, the same process applies again, and plaintext is retrieved.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在解密过程中，相同的过程再次应用，明文被检索出来。
- en: Pseudorandom generation means that the bits generated are not random but appear
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机生成意味着生成的位不是随机的，但看起来是
- en: random, hence the term pseudorandom. Keystreams are commonly generated using
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 随机，因此称为伪随机。密钥流通常使用
- en: linear feedback shift registers (LFSRs). The input bit of LFSR is a linear function
    of its previous state, where the linear function is usually the XOR operation.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 线性反馈移位寄存器（LFSR）。LFSR的输入位是其先前状态的线性函数，其中线性函数通常是异或操作。
- en: The key generator is a cryptographically secure pseudorandom number generator
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥生成器是一个密码安全的伪随机数生成器。
- en: (CSPRNG or CPRNG). Being “pseudo,” we can compute the number, and anyone
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: （CSPRNG或CPRNG）。“伪”，我们可以计算出数字，而其他任何人
- en: computing it will have the same result, which implies that these PRNGs are also
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 计算它将产生相同的结果，这意味着这些PRNG也是
- en: deterministic. If they are truly random and not deterministic, then once generated,
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性。如果它们确实是随机的而不是确定性的，那么一旦生成，
- en: the random number cannot be regenerated by anyone else, meaning the decryption
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数不能由其他人重新生成，这意味着解密
- en: won’t be possible. So, they look random, but actually they are not and are computable.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能。因此它们看起来是随机的，但实际上它们不是，而是可计算的。
- en: CPRNGs have a particular property that the numbers they generate are unpredictable.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: CPRNG具有一种特殊的属性，即它们生成的数字是不可预测的。
- en: 'There are two types of stream ciphers: synchronous stream ciphers and'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的流密码：同步流密码和
- en: asynchronous stream ciphers. In synchronous stream ciphers, the keystream is
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 异步流密码。在同步流密码中，密钥流是
- en: dependent only on the key. In contrast, the keystream relies on the fixed number
    of
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 仅依赖于密钥。相反，密钥流依赖于固定数量的
- en: previously transmitted encrypted bits and the key in asynchronous stream ciphers.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步流密码中，先前传输的加密位和密钥。
- en: '72'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '72'
- en: '![](index-92_1.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](index-92_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: Stream ciphers are usually more suited for hardware devices; however, they can
    also
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码通常更适合硬件设备；然而，它们也可以
- en: be used in software environments. Many examples of stream ciphers exist, such
    as A5/1,
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件环境中使用。流密码的许多例子存在，如A5/1，
- en: used in GSM communications to provide confidentiality. However, Salsa20 and
    ChaCha
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 用于GSM通信以提供机密性。然而，Salsa20和ChaCha
- en: are most used in software environments. Some other stream ciphers include Trivium,
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件环境中最常使用。其他一些流密码包括 Trivium，
- en: Rabbit, RC4, and SEAL.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Rabbit，RC4和SEAL。
- en: '**Block Ciphers**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**块密码**'
- en: Block ciphers encrypt the plaintext by dividing it into blocks of fixed length.
    Historically, block ciphers, such as DES, were built using Feistel mechanisms.
    Modern ciphers, such
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码通过将明文分成固定长度的块来加密。历史上，块密码，如DES，是使用费斯特尔机制构建的。现代密码，如
- en: as AES, use a substitution-permutation network (SPN).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 例如AES，使用替换-置换网络（SPN）。
- en: A simple model of a block cipher is shown in Figur[e 2-5\.](#p92)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码的简单模型如图所示。[2-5\.](#p92)
- en: '***Figure 2-5\.** Block cipher*'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-5** 块密码*'
- en: The model shown in Figur[e 2-5 com](#p92)prises plaintext, encryption, and ciphertext.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中所示的模型。[2-5 com](#p92)们包括明文、加密和密文。
- en: The encrypter takes the plaintext in fixed-length blocks and the secret key
    as input and
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 加密器接受固定长度块的明文和秘钥作为输入
- en: produces the ciphertext blocks.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 产生密文块。
- en: Block ciphers are primarily used for encryption but can be used to build hash
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码主要用于加密，但也可以用来构建哈希
- en: functions, create stream ciphers, and build pseudorandom number generators and
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，创建流密码，并构建伪随机数生成器和
- en: message authentication codes.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 消息认证码。
- en: There are two necessary properties that encryption tries to achieve, confusion
    and
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 加密试图实现的两个必要属性是混淆和
- en: diffusion. Confusion adds obscurity to the relationship between the encrypted
    text and
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 扩散。混淆为加密文本和
- en: the plaintext. It is achieved by using substitution, which is performed by lookup
    tables
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 明文之间的关系添加了隐晦性。
- en: called S-boxes in modern encryption algorithms, such as AES.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 现代加密算法中称为S盒，例如AES。
- en: Diffusion ensures that plaintext statistically spreads over the encrypted data.
    In other
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 扩散确保了明文在加密数据上的统计分布。换句话说
- en: words, it ensures that even if a single bit changes in the plaintext, the ciphertext
    changes so much that the relationship between the plaintext and the ciphertext
    is hidden.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它确保即使明文中的一个单一位发生改变，密文也发生了如此大的变化，以至于明文和密文之间的关系被隐藏了。
- en: In other words, it hides the statistical properties of the plaintext to thwart
    statistical 73
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它隐藏了明文的统计属性，以防止统计73
- en: Chapter 2 Cryptography
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章密码学
- en: analysis attacks. In addition, permutation boxes provide diffusion in modern
    encryption
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 分析攻击。此外，置换盒在现代加密中提供扩散
- en: algorithms, such as AES. Thus, both confusion and diffusion are combined to
    create
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 算法，如AES。因此，混淆和扩散结合在一起创建
- en: secure cipher algorithms.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的密码算法。
- en: The Data Encryption Standard (DES) was developed in the 1970s and was used
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是在1970年代开发的，并且被使用
- en: widely in the 1980s and 1990s. Over time, due to technological advancements,
    the
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛用于1980年代和1990年代。随着时间的推移，由于技术进步，这
- en: efficacy of DES started to decrease. It was mainly due to its smaller 56-bit
    key length.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: DES的效力开始减弱。主要是因为它的56位较小的密钥长度。
- en: After some successful brute-force attacks in the late 1990s, such as deep crack
    and
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代末出现一些成功的穷举攻击，如深拆和
- en: COPACOBANA, it became clear that the DES was no longer secure. As a result,
    triple
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: COPACOBANA，显然DES不再安全。因此，三重
- en: DES was introduced, which encrypts three times in a row (triple encryption)
    to increase
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: DES由三重DES替代，后者将加密三次以增加
- en: the key length to 112 bits essentially. It helped to protect against brute-force
    attacks, and indeed triple DES is still unbreakable today. However, NIST finally
    replaced DES with
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥长度基本上为112位。这有助于防止穷举攻击，事实上，三重DES直到今天仍然无法破解。然而，NIST最终用
- en: AES due to concerns over slow performance and 64-bit block size in 2001\.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 由于2001年性能缓慢和64位块大小的担忧，AES应运而生。
- en: There are different modes in which block ciphers work. These modes enable block
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码的不同工作模式。这些模式使块
- en: ciphers to not only provide confidentiality but also integrity and authenticity.
    Some of
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 密码不仅提供机密性，而且提供完整性和真实性。一些
- en: the modes include
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 模式包括
- en: • Electronic codebook mode
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: • 电子密码本模式
- en: • Cipher block chaining mode
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: • 密码块链接模式
- en: • Counter mode
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: • 计数器模式
- en: • Cipher feedback (CFB) mode
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: • 密码反馈（CFB）模式
- en: • Galois/Counter Mode (GCM)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: • 伽罗瓦/计数器模式（GCM）
- en: • Output feedback (OFB) mode
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: • 输出反馈（OFB）模式
- en: We will explain just three modes here.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会在这里解释三种模式。
- en: '**Electronic Codebook**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子码本**'
- en: Electronic codebook (ECB) is a fundamental mode of operation in which the encrypted
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 电子码本（ECB）是一种基本的操作模式，其中加密
- en: data results from applying the encryption algorithm to each block of plaintext,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是应用加密算法到每个明文块，
- en: one by one.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 一次一个。
- en: This mode is the most straightforward, but we should not use it in practice
    as it is
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式最为直接，但在实践中我们不应该使用它，因为它是
- en: insecure and can reveal information.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全且可能透露信息。
- en: '74'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '74'
- en: '![](index-94_1.png)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](index-94_1.png)'
- en: '![](index-94_2.png)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](index-94_2.png)'
- en: Chapter 2 Cryptography
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-6\.** Electronic codebook mode for block ciphers*'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-6\.**- 电子码本模式 用于块密码*'
- en: Figur[e 2-6 sho](#p94)ws that we have plaintext P provided as an input to the
    block cipher encryption function and a key, which produces ciphertext C as output.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](#p94)显示，我们将明文 P 作为输入提供给块密码加密函数并使用一个密钥，产生输出密文 C。'
- en: '**Cipher Block Chaining**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码块链接**'
- en: In cipher block chaining (CBC) mode, each plaintext block is XORed with the
    previously
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码块链接（CBC）模式中，每个明文块与先前的 XOR
- en: encrypted block. CBC mode uses the IV to encrypt the first block. The IV must
    be
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 加密块。CBC模式使用IV来加密第一个块。IV必须是
- en: randomly chosen. CBC mode operation is shown in Figur[e 2-7\.](#p94)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择。CBC模式的操作如[图2-7\.](#p94)所示
- en: '***Figure 2-7\.** Cipher block chaining mode*'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-7\.** 密码块链接模式*'
- en: '75'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '75'
- en: '![](index-95_1.png)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](index-95_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Counter Mode**'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**计数器模式**'
- en: The counter (CTR) mode uses a block cipher as a stream cipher. In this case,
    a unique
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器（CTR）模式使用块密码作为流密码。在这种情况下，一个独特
- en: nonce is concatenated with the counter value to generate a keystream.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数与计数器值连接在一起以生成密钥流。
- en: As shown in Figur[e 2-8](#p95), CTR mode works by utilizing a nonce N and a
    counter C that feed into the block cipher encryption function. The block cipher
    encryption
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图2-8](#p95)所示，CTR模式通过利用一个随机数 N 和一个计数器 C 输入块密码加密函数。块密码
- en: function takes the secret key “KEY” as input and produces a keystream (a stream
    of
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将秘钥“KEY”作为输入，并产生一个密钥流（一串
- en: pseudorandom or random characters), which, when XORed with the plaintext (P),
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机或随机字符），当与明文（P）进行XOR操作时，
- en: generates the ciphertext (C).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密文（C）。
- en: '***Figure 2-8\.** Counter mode*'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-8\.** 计数器模式*'
- en: There are other modes that we can use for different purposes other than encryption.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他我们可以用于不同目的的模式。
- en: We discuss some of these in the following section.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的部分讨论其中一些。
- en: '**Keystream Generation Mode**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥流生成模式**'
- en: In keystream generation mode, the encryption function generates a keystream.
    Stream
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥流生成模式下，加密函数生成密钥流。流
- en: ciphers use this keystream where it is XORed with the plaintext stream to produce
    the
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 密码使用这个密钥流，其中它与明文流进行XOR操作，产生
- en: ciphertext.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 密文。
- en: '76'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '76'
- en: Chapter 2 Cryptography
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Message Authentication Mode**'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息认证模式**'
- en: A message authentication code (MAC) is produced from an encryption function
    in the
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 消息认证码（MAC）是从加密函数中产生的
- en: message authentication mode. A MAC is a cryptographic checksum that provides
    the
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 消息认证模式。MAC是提供
- en: integrity service. Block ciphers in the cipher block chaining mode (CBC mode)
    are used
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性服务。密码块密码（CBC模式）中的块密码用于
- en: to generate MACs. We can use a MAC to check if an unauthorized entity has modified
    a
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 以生成MAC。我们可以使用MAC来检查非授权实体是否修改了
- en: message. We achieve this by encrypting the message with a key using the MAC
    function.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 消息。我们通过使用MAC函数使用密钥加密消息来实现这一点。
- en: Then, the receivers check the message’s MAC by encrypting the received message
    again
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，接收者通过再次加密收到的消息来检查消息的MAC
- en: with the key and comparing it with the received MAC. If they match, it means
    that no
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 与密钥进行比较。如果它们匹配，就意味着没有
- en: unauthorized entity has modified the message; thus, an integrity service is
    provided. If
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 未经授权的实体已经修改了消息；因此，提供完整性服务。如果
- en: they don’t match, then it means that some unauthorized entity has altered the
    message
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不匹配，那么意味着一些未经授权的实体已经改变了消息
- en: during transmission.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输期间。
- en: Any block cipher such as AES in CBC mode can generate a MAC. The MAC of
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 任何块密码，如CBC模式中的AES都可以生成MAC。MAC
- en: the message is the output of the last round of the CBC operation. The length
    of the
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是CBC操作的最后一轮的输出。密文的长度
- en: MAC output is the same as the block length of the block cipher used to generate
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: MAC输出与用于生成
- en: the MAC. Even though MACs work like digital signatures, they cannot provide
    the
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: MAC。尽管MACs的工作方式类似于数字签名，但它们无法提供
- en: nonrepudiation service due to their symmetric nature.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其对称性质，不可辩驳的服务。
- en: '**Cryptographic Hash Mode**'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码哈希模式**'
- en: Hash functions are primarily used to compress a message to a fixed-length digest.
    Block
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数主要用于将消息压缩为固定长度的摘要。块
- en: ciphers in cryptographic hash mode can also be used as a compression function
    to
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希模式中的密码也可以用作压缩功能
- en: produce a hash.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 生成哈希。
- en: Now we describe the Advanced Encryption Standard (AES) in detail.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们详细描述高级加密标准（AES）。
- en: '**Advanced Encryption Standard**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级加密标准**'
- en: AES was originally named Rijndael, after its inventors’ names Joan Daemen and
    Vincent
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: AES最初被命名为Rijndael，以其发明者的名字Joan Daemen和Vincent
- en: Rijmen. It was standardized as Advanced Encryption Standard (AES) by NIST in
    2001
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: Rijmen。它在2001年被NIST标准化为高级加密标准（AES）
- en: after an open competition.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 经过公开竞赛后。
- en: In the original version of Rijndael, different key and block sizes of 128 bits,
    192 bits, and 256 bits are allowed. However, only a 128-bit block size and key
    sizes of 128 bits, 192
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rijndael的原始版本中，允许128位、192位和256位不同的密钥和块大小。然而，只允许128位块大小和128位、192位密钥大小
- en: bits, and 256 bits are allowed in AES.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 位和256位在AES中是被允许的。
- en: AES processes an array of bytes of size 4 x 4 called state in multiple rounds
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: AES在多轮中处理一个称为状态的4 x 4字节数组
- en: depending on the key size. For example, if the key length is 128 bits, 10 rounds
    are
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于密钥大小。例如，如果密钥长度为128位，则有10轮
- en: required; for 192 bits, it needs 12 rounds; and for 256 bits, it needs 14 rounds.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 需要；对于192位，需要12轮；对于256位，需要14轮。
- en: '77'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '77'
- en: Chapter 2 Cryptography
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: After state initialization using the input plaintext, AES sequentially performs
    the
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用输入明文进行状态初始化后，AES按顺序执行
- en: 'following four operations to produce the ciphertext:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四种操作生成密文：
- en: '• **AddRoundKey**: First, the state array is XORed with a subkey derived'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: • **AddRoundKey**：首先，状态数组与派生的子密钥进行异或
- en: from the master key.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 从主密钥。
- en: '• **SubBytes**: This step performs **byte substitution** where a fixed lookup'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: • **SubBytes**：这一步执行**字节替换**，其中使用固定查找
- en: table (S-box) is used to replace all bytes of the 4 x 4 state array.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 表（S-盒）用来替换4 x 4状态数组的所有字节。
- en: '• **ShiftRows**: This step shifts each row to the left in the state array in
    a'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: • **ShiftRows**：这一步将状态数组中的每一行向左移动
- en: cyclic and incremental manner. The first row is excluded, the second
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和增量方式。第一行除外，第二行
- en: row is shifted left by one byte, the third row is shifted left by two bytes,
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 行向左移动一个字节，第三行向左移动两个字节，
- en: and the fourth row is shifted left by three bytes or positions.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行向左移动三个字节或位置。
- en: '• **MixColumns**: Finally, all bytes are mixed in a linear fashion (i.e.,'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: • **MixColumns**：最后，所有字节都以线性方式混合（例如，
- en: linear transformation), where four bytes of the column are taken as
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换），其中该列的四个字节被视为
- en: input by this function, and four new bytes are produced as output
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个函数输入，并产生四个新字节作为输出
- en: which replaces the input column.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 取代输入列。
- en: The abovementioned four steps form a single round of AES. In the final round,
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 上述四个步骤形成AES的一轮。在最后一轮
- en: step 4 (MixColumns) is not performed. Instead, it is replaced with the AddRoundKey
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤4（MixColumns）不执行。而是用AddRoundKey代替
- en: step to ensure that the first three steps cannot be simply reversed. This process
    is shown in Figure [2-9](#p98).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤以确保前三步不能简单地被反转。该过程在图 [2-9](#p98) 中显示。
- en: '78'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '78'
- en: '![](index-98_1.png)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![](index-98_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-9\.** AES block cipher*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-9\.** AES块密码*'
- en: '**Some Basic Mathematics**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些基本数学**'
- en: Before we dive into cryptography, it is important to understand some very basic
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究密码学之前，了解一些非常基本的东西很重要
- en: mathematics and related terminology.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 数学和相关术语。
- en: '**Prime**'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**质数**'
- en: A prime is a number which is only divisible fully by itself and 1\. For example,
    23 is a
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 质数是只能被自身和1整除的数字。例如，23是一个
- en: prime number as it can only be divided precisely without leaving any remainder
    either
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 质数，因为它只能被精确地除尽，不留下任何余数
- en: by 23 or 1\.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 23或1\。
- en: '79'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '79'
- en: Chapter 2 Cryptography
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Modular Arithmetic**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**模运算**'
- en: It is a system of performing arithmetic operations on integers where numbers
    wrap
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一种在整数上执行算术运算的系统，其中数字会循环
- en: around when they reach a certain fixed number. This fixed number is called a
    modulus,
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们达到某个固定数量时，它们将围绕某个固定数字。这个固定数字称为模数，
- en: and all arithmetic operations are performed based on this modulus.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 并且所有的算术运算都是基于这个模来执行的。
- en: '**Group**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**群**'
- en: 'A group *G* is a set whose elements can be combined with an operation ∘. It
    has the following properties:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 一个群体 *G* 是一个集合，它的元素可以使用一个运算∘进行组合。它具有以下属性：
- en: '**Closure** means that all group operations are closed. Formally, ∀ *a*,'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**封闭性** 表示所有的群运算都是封闭的。形式上，∀ *a*，'
- en: '*b* ∈ *G* : *a* ∘ *b* = *c* ∈ *G*.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* ∈ *G* : *a* ∘ *b* = *c* ∈ *G*.'
- en: '**Associativity** means that all group operations are associative. Formally,'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合性** 表示所有的群运算都是结合的。形式上来说，'
- en: '*a* ∘ ( *b* ∘ *c*) = ( *a* ∘ *b* ) ∘ *c* : ∀ *a*, *b*, *c* ∈ *G*.'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ∘ ( *b* ∘ *c*) = ( *a* ∘ *b* ) ∘ *c* : ∀ *a*, *b*, *c* ∈ *G*.'
- en: 'There exists a special **identity** element *i* such that ∀ *a* ∈ *G* : *a*
    ∘ *i* = *i* ∘ *a* = *a*.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '存在一个特殊的**单位元** *i*，使得∀ *a* ∈ *G* : *a* ∘ *i* = *i* ∘ *a* = *a*。'
- en: In each element *a* ∈ *G* , there is a corresponding **inverse** element *a*−1
    such that *a* ∘ *a*−1 = *a*−1 ∘ *a* = *i*.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个元素 *a* ∈ *G* 中，有一个相应的**逆元素** *a*−1，使得 *a* ∘ *a*−1 = *a*−1 ∘ *a* = *i*。
- en: '**Abelian Group**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**阿贝尔群**'
- en: A group is a commutative or abelian group if in addition to the abovementioned
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了上述的
- en: 'properties of groups, ∀ *a*, *b* ∈ *G* : *a* ∘ *b* = *b* ∘ *a* .'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '群体的性质，∀ *a*, *b* ∈ *G* : *a* ∘ *b* = *b* ∘ *a* .'
- en: '**Field**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**域**'
- en: A field F is a set with two operations on F called addition and multiplication.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: F是具有F上两个称为加法和乘法的操作的集合。
- en: '**Finite Field (Galois Field)**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限域（伽罗华域）**'
- en: A finite field is a field with a finite number of elements.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 有限域是一个具有有限个元素的域。
- en: '**Prime Fields**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**素域**'
- en: A prime field is a finite field containing a prime number of elements.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 一个素域是包含素数个元素的有限域。
- en: '80'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '80'
- en: '![](index-100_1.png)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![](index-100_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Generator**'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**'
- en: A generator is a point on an elliptic curve.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生成器是椭圆曲线上的一个点。
- en: '**Public Key Cryptography**'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥密码学**'
- en: Public key cryptographic systems use two different keys for encryption and decryption.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密系统使用两个不同的密钥进行加密和解密。
- en: The public key is known openly, and the private key must remain secret. In these
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥是公开的，私钥必须保密。在这些
- en: systems, the sender uses the recipient’s public key to encrypt data. The recipient
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 系统，发送方使用接收方的公钥来加密数据。接收方
- en: decrypts the ciphertext by using the corresponding private key.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用相应的私钥解密密文。
- en: This model is shown in Figur[e 2-10\.](#p100)
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型如图2-10所示。(#p100)
- en: '***Figure 2-10\.** Public key cryptography–based cryptosystem*'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-10\.** 基于公钥密码体系的加密系统*'
- en: A fundamental issue in symmetric key systems is that they need a secret key
    to be
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥系统中的一个基本问题是它们需要一个秘密密钥才能
- en: shared before the communication using a secure channel, which can be challenging
    to
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 共享密钥的数量，这可能是一个具有挑战性的任务。
- en: achieve. Another issue with symmetric key systems is key management. The number
    of
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 进行。对称密钥系统的另一个问题是密钥管理。在使用安全信道之前交换
- en: keys grows exponentially as the number of users grows in the system. An n user
    network
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的密钥随着用户数量的增加而呈指数增长。一个n用户的网络
- en: will need n(n-1)/2 keys where each user will store n-1 keys. In a 100-user network,
    each
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 将需要n(n-1)/2个密钥，每个用户将存储n-1个密钥。在一个100用户的网络中，每个
- en: user will store 99 keys. The formula 100(100-1)/2 means there are 4950 keys
    in total,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将存储99个密钥。公式100(100-1)/2表示总共有4950个密钥，
- en: which is quite tricky to manage practically. Public key cryptography solves
    this issue of key distribution and key management.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实际上是相当棘手的。公钥加密解决了这个密钥分发和密钥管理的问题。
- en: A typical use of public key cryptography is to establish a shared secret key
    between
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码的一个典型用途是在两个当事方之间建立一个共享的秘密密钥
- en: two parties. This shared secret key is used by symmetric algorithms, such as
    AES, to
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 两个当事方。这个共享的秘密密钥被对称算法使用，比如AES，来
- en: encrypt the data. As they have already established a secret key, both parties
    can then
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 加密数据。因为他们已经建立了一个秘密密钥，双方可以
- en: '81'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '81'
- en: Chapter 2 Cryptography
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: encrypt and decrypt without ever transmitting the secret key on the wire. This
    way, the
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和解密，而不必在网络上传输秘密密钥。这样，这个
- en: parties get the high security of public key cryptography with the speed of symmetric
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 当事方既获得了公钥加密的高安全性，又获得了对称加密的速度
- en: encryption. Asymmetric cryptography is not used much for bulk encryption due
    to slow
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 加密。由于速度慢，非对称加密不常用于大量加密的性能；
- en: performance; however, this is the norm for key establishment. Such systems where
    a
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是密钥建立的正常使用。这些系统允许一个
- en: symmetric key is used to encrypt the data and a secret key is encrypted using
    public key
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥用于加密数据，并且一个秘密密钥使用公钥加密
- en: cryptography are called hybrid cryptosystems. For example, the Integrated Encryption
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学被称为混合加密系统。例如，集成加密
- en: Scheme is a hybrid encryption scheme. ECIES is the elliptic curve (EC) version
    of the
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 是混合加密方案。ECIES 是椭圆曲线 (EC) 版本的
- en: IES scheme.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: IES 方案。
- en: '**Diffie-Hellman Key Exchange**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '**Diffie-Hellman 密钥交换**'
- en: For key exchange, the pioneering and fundamental scheme is the Diffie-Hellman
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密钥交换，开创性和基础性的方案是 Diffie-Hellman
- en: key exchange. It is an interactive protocol that runs between two parties. A
    basic and
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换。这是一个在两方之间运行的互动协议。一个基本
- en: 'intuitive mathematical example of the Diffie-Hellman exchange is shown as follows:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 直观的 Diffie-Hellman 交换的数学例子如下所示：
- en: 1\. Alice and Bob want to establish a shared secret key.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. Alice 和 Bob 想建立一个共享的秘密密钥。
- en: 2\. Both agree on two numbers, a prime number *P* = 13 and a
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 两者商定两个数字，一个素数 *P* = 13 和一个
- en: generator of *P*, *G* = 6\. In practice, however, *P* is very large.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 发生器 *P*，*G* = 6\. 但在实践中，*P* 是非常大的。
- en: 3\. Both randomly choose a large random integer (i.e., private keys).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 两者随机选择一个大的随机整数（即私钥）。
- en: a. Alice’s private key = 5, Bob’s private key = 4
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: a. Alice 的私钥 = 5，Bob 的私钥 = 4
- en: '4\. Both calculate public keys:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 两者计算公钥：
- en: a. Alice
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: a. Alice
- en: 65 *mod* 13
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 65 *mod* 13
- en: 7776 *mod* 13 = 2
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 7776 *mod* 13 = 2
- en: '*Public key* = 2'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '*公钥* = 2'
- en: b. Bob
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: b. Bob
- en: 64 *mod* 13
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 64 *mod* 13
- en: 1296 *mod* 13 = 9
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 1296 *mod* 13 = 9
- en: '*Public key* = 9'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '*公钥* = 9'
- en: 5\. Bob sends public key 9 to Alice, and Alice sends public key
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. Bob 向 Alice 发送公钥 9，Alice 向 Bob 发送公钥
- en: 2 to Bob.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 2 给 Bob。
- en: '82'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '82'
- en: '![](index-102_1.png)'
  id: totrans-791
  prefs: []
  type: TYPE_IMG
  zh: '![](index-102_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: 6\. Both calculate the shared key using private keys 5 and 4\.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 两者使用私钥 5 和 4 计算共享密钥。
- en: a. Alice
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: a. Alice
- en: 95 *mod* 13 = 3
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 95 *mod* 13 = 3
- en: b. Bob
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: b. Bob
- en: 24 *mod* 13 = 3
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 24 *mod* 13 = 3
- en: 7\. A shared secret key is established.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 建立了一个共享的秘密密钥。
- en: Public key cryptosystems rely on one-way trap door functions. Trapdoor functions
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密系统依赖于单向陷门函数。陷门函数
- en: are easy to compute in one direction but difficult to compute in the opposite
    direction,
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在一方向上容易计算但是在相反方向上却难以计算，
- en: unless there is a special value, called the trapdoor, available. This concept
    can be
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有一个特殊的值，称为陷门，可用。这个概念可以
- en: visualized in Figure [2-11](#p102).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[2-11](#p102)中展示。
- en: '***Figure 2-11\.** Trapdoor function*'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-11\.** 陷门函数*'
- en: Different hard computational problems, such as a large integer factorization
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的困难计算问题，比如大整数分解
- en: problem and a discrete logarithm problem, provide suitable one-way trapdoor
    functions.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 问题和离散对数问题，提供适当的单向陷门函数。
- en: Cryptography schemes using integer factorization are based on the infeasibility
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数分解的密码学方案是基于不可行性
- en: of factoring large integers. A typical example that relies on such an assumption
    is
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 分解大整数的难度。依赖这种假设的典型例子是
- en: RSA. Integer factorization is the decomposition of a composite number (formed
    by
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: RSA。整数分解是复合数的分解（由
- en: multiplying two smaller integers) into smaller integers (factors).
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个较小的整数) 分解为较小的整数(因子)。
- en: In cryptography, factors are restricted to prime numbers. We can demonstrate
    the
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，因子被限制为质数。我们可以演示
- en: problem with a simple example as follows.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样一个简单的示例来说明问题。
- en: '83'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '83'
- en: Chapter 2 Cryptography
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: For example, it is straightforward to see that 15 is the product of 5 and 3
    as 5 x 3 = 15\.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很容易看出 15 是 5 和 3 的乘积，即 5 x 3 = 15\。
- en: What about a larger prime number, for example, 6887? It is comparatively difficult,
    but
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 那么较大的质数呢，比如 6887？这相对来说就困难一些，但是
- en: we get 71 and 97 as factors with some calculation. What if the number is huge,
    say 1024
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行一些计算得到 71 和 97 作为因子。如果这个数字非常大呢，比如 1024
- en: bits, and prime? Then multiplying two such primes is easy to do but extremely
    hard to
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 位数，和素数？然后将两个这样的素数相乘很容易，但是极其难以
- en: factor, making it a one-way function that we can use in cryptography.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 因子，使其成为我们可以在密码学中使用的单向函数。
- en: A discrete logarithm problem is the basis for many different cryptography schemes
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 一个离散对数问题是许多不同的密码学方案的基础
- en: such as the Diffie-Hellman key exchange and digital signature algorithms. It
    is based
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Diffie-Hellman 密钥交换和数字签名算法。它是基于
- en: on a problem in modular arithmetic where it is easy to calculate the result
    of a modulo
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 基于一个在模算术中的问题，计算模的结果是容易的
- en: operation, but it is hard to find the exponent of the generator. This hardness
    creates
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 运算，但是找到发生器的指数却很难。这种困难创造了
- en: a one-way function where it is computationally infeasible to find the input
    from
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单向函数，从计算上来说，从输入中找到输出是困难的。
- en: the output.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 输出。
- en: 'A simple example can demonstrate the crux of this problem:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子可以演示这个问题的关键所在：
- en: '2'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '10'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '9'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '*mod*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod*'
- en: '='
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: Now, given 9, finding 2, the exponent of the generator 3, is extremely hard
    to do.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给定9，找到2，生成器3的指数是非常难的。
- en: Formally, we can say that given numbers *a* and *n* where *n* is a prime, the
    function *f b*
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地，我们可以说，给定数字*a*和*n*，其中*n*是质数，函数*f b*
- en: '*ab*'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '*ab*'
- en: ( ) = *mod n*
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: （）= *mod n*
- en: is a one-way function, because calculating *f*( *b*) is easy, but given *f*(
    *b*), finding *b* is hard.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个单向函数，因为计算*f*（*b*）很容易，但是给定*f*（*b*），找到*b*很难。
- en: Another method developed in the mid-1980s is elliptic curve cryptography. Elliptic
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代中期发展出的另一种方法是椭圆曲线密码学。椭圆
- en: curve cryptography has gained special attention due to its usage in blockchain
    platforms, such as Bitcoin and Ethereum. Protocols such as the Elliptic Curve
    Diffie-Hellman key
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线密码学因其在区块链平台（如比特币和以太坊）中的应用而受到特别关注
- en: exchange and elliptic curve digital signature algorithms are most prevalent
    in this space.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 交换和椭圆曲线数字签名算法在这个领域最为普遍。
- en: ECC is fundamentally a discrete logarithm problem but founded upon elliptic
    curves
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ECC基本上是一个离散对数问题，但是构建在椭圆曲线之上
- en: over finite fields. A key advantage of ECC is that a smaller key size provides
    the same
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限域上传输。ECC的一个关键优势是，较小的密钥尺寸提供了相同的
- en: level of security as a larger key size in RSA. For example, a security level
    of a 1024-bit integer factorization scheme, such as RSA, can be achieved by only
    a 160-bit elliptic
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 安全级别与RSA中较大的密钥尺寸相同。例如，1024位整数因子分解方案的安全级别，比如RSA，可以通过只有160位的椭圆
- en: curve–based scheme, such as ECDSA.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 基于曲线的方案，如ECDSA。
- en: Public key cryptosystems can be used for encryption, though it is very less
    common
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码系统可以用于加密，尽管这种情况非常少见
- en: and not efficient for large datasets. It is also used for providing other security
    services and protocols, such as digital signatures, entity authentication, and
    key agreement.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型数据集来说并不高效。它还用于提供其他安全服务和协议，比如数字签名，实体认证和密钥协商。
- en: '84'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '84'
- en: Chapter 2 Cryptography
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Digital Signatures**'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字签名**'
- en: Digital signatures are one of the most common uses of public key cryptography.
    Digital
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是公钥密码学的最普遍应用之一。数字
- en: signatures provide nonrepudiation services. Most common examples include RSA-based
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 签名提供不可否认的服务。最常见的例子包括基于RSA的
- en: digital signatures, digital signature algorithms, and ECDSA and Schnorr signatures.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名，数字签名算法，ECDSA和Schnorr签名。
- en: '**Entity Authentication**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体认证**'
- en: Entity authentication or identification is another service that public key cryptosystems
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 实体认证或识别是公钥密码系统的另一个服务
- en: can provide. Usually, challenge-response mechanisms are in widespread use where
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供。通常情况下，挑战-响应机制在广泛使用，其中
- en: a challenge sent by the verifier is required to be responded to correctly by
    the prover
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者发送的一个挑战需要由证明者作出正确的回应
- en: (claimant of identity) to ascertain the legitimacy of the claimant.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: （声明身份）来确定申明者的合法性。
- en: '**Key Agreement**'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥协商**'
- en: Key agreement protocols are used to establish secret keys before an encrypted
    data
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥协商协议用于在加密数据
- en: transfer. The most common example of such protocols is the Diffie-Hellman key
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 传输。这类协议的最常见例子是Diffie-Hellman密钥
- en: exchange protocol.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 交换协议。
- en: '**RSA**'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA**'
- en: RSA is widely used for secure key transport and building digital signatures.
    Diffie and
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: RSA广泛用于安全密钥传输和构建数字签名。Diffie和
- en: Hellman invented public key cryptography in 1976\. Based on this idea, in 1978,
    the RSA
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: Hellman在1976年发明了公钥密码学。基于这个想法，在1978年，RSA
- en: public key cryptosystem was developed by Rivest, Shamir, and Adleman.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码系统是由Rivest，Shamir和Adleman开发的。
- en: In this section, I will walk you through the steps of generating key pairs in
    RSA and
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将带您了解RSA中生成密钥对的步骤以及
- en: how to encrypt and decrypt.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 如何加密和解密。
- en: '**Key Pair Generation**'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥对生成**'
- en: 1\. Generate a modulus.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 产生一个模数。
- en: a. Select *p* and *q*, two large prime numbers. Usually, 2^1024 bits or more.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: a. 选择*p*和*q*，两个大素数。通常是2^1024位或更多。
- en: 2\. Multiply
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 乘
- en: '*p* and *q* to generate modulus *n*. *n* = *p*. *q*. n becomes 2^2048\.'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*和*q*生成模数*n*。*n* = *p*。*q*。n变成2^2048\。'
- en: '85'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '85'
- en: Chapter 2 Cryptography
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: 3\. Choose a random number with some special properties. Assume
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 选择一个具有特殊属性的随机数。假设
- en: that we call this number *e*.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称此数字为 *e*。
- en: 'a. This number *e* should have some special properties:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: a. 这个数字 *e* 应该有一些特殊属性：
- en: i. It should be greater than 1\.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: i. 它应该大于1\。
- en: ii. It should be less than *ϕ*( *n*) = ( *p* − 1) ( *q* − 1).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: ii. 它应该小于 *ϕ*( *n*) = ( *p* − 1) ( *q* − 1)。
- en: iii.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: iii.
- en: '*gcd*( *e*, ( *p* − 1)( *q* − 1) = 1\.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '*gcd*( *e*, ( *p* − 1)( *q* − 1) = 1\。'
- en: iv.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: iv.
- en: '*e* ∈ {1, 2, . . . , *ϕ*( *n*) − 1}.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* ∈ {1, 2, . . . , *ϕ*( *n*) − 1}。'
- en: Formally speaking, this number e should be the coprime (relatively
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，这个数字e应该是互质的（相对
- en: prime) of ( *p* − 1) ( *q* − 1), that is, no number other than 1 can
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 素数）的( *p* − 1) ( *q* − 1)，也就是说，除了1以外，没有其他数字可以
- en: be divided fully into e and ( *p* − 1) ( *q* − 1). Coprimes have no
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 完全分为e和 ( *p* − 1) ( *q* − 1)。 互质数没有
- en: common factors except 1, so the greatest common divisor (GCD) of
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 除了1以外的所有公因数，因此最大公约数（GCD）为
- en: coprimes is 1\.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 互质数是1\.
- en: 4\. Public key generation
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 公钥生成
- en: a. The modulus n generated in step 1 and the special number e generated
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: a. 步骤1生成的模数n和步骤2生成的特殊数字e
- en: in step 2 is pair (n, e) that is the public key. This pair is public, so it
    can be
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中是一对 (n, e) 即公钥。 这对是公开的，因此可以
- en: shared with anyone; however, p and q must be kept secret.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何人共享；但是，p和q必须保密。
- en: 5\. Private key generation
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 私钥生成
- en: a. The private key, let’s call it *d*, is calculated from two primes *p* and
    *q* from step 1 and the special number *e* from step 2\. The private key is the
    inverse of
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: a. 私钥，让我们称之为 *d*，是从步骤1的两个质数 *p* 和 *q* 和步骤2的特殊数字 *e* 计算得出的。私钥是
- en: '*e* modulo ( *p* − 1)( *q* − 1), which we can write as'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*模( *p* − 1)( *q* − 1)，我们可以写成'
- en: '*ed* =1 *mod* ( *p* − )'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*ed* =1 *mod* ( *p* − )'
- en: 1 ( *q* − )
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ( *q* − )
- en: '1'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '*ed* =1 *mod* φ *n*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '*ed* =1 *mod* φ *n*'
- en: −1
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: −1
- en: '*d* = *e* = 7'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '*d* = *e* = 7'
- en: '20'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '*mod*'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod*'
- en: In practice, the extended Euclidean algorithm is used to calculate *d* which
    takes *p*, *q*, and e as input and outputs *d*. *d* must be kept secret.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，扩展的欧几里德算法用于计算 *d*，它需要 *p*、*q* 和 e 作为输入，并输出 *d*。*d*必须保密。
- en: '86'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '86'
- en: Chapter 2 Cryptography
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Encryption and Decryption**'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密和解密**'
- en: Now, let’s see how encryption and decryption operations are performed using
    RSA. RSA
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用RSA执行加密和解密操作。RSA
- en: 'uses the following equation to produce ciphertext:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方程式生成密文：
- en: '*e*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*'
- en: '*C* = *P mod n*'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = *P mod n*'
- en: This means that plaintext P is raised to the power of e and then reduced to
    modulo n.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着明文P提高到幂e，然后减少到模n。
- en: 'Decryption in RSA is provided in the following equation:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: RSA中的解密由以下方程式提供：
- en: '*d*'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*'
- en: '*P* = *C mod n*'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = *C mod n*'
- en: This means that the receiver who has a public key pair ( *n*, *e*) can decipher
    the data by raising *C* to the value of the private key *d* and then reducing
    to modulo *n*.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着拥有一对公钥 ( *n*, *e*) 的接收方可以将数据解密，方法是将 *C* 提高到私钥 *d* 的值，然后减少到模 *n*。
- en: '**Example of Key Generation, Encryption, and Decryption**'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成、加密和解密示例**'
- en: 1\. Let the plaintext be message *m*. *m* = 5, to be sent from Alice to Bob.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 让明文消息为 *m*。 *m* = 5，从Alice发送给Bob。
- en: 2\. Let
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 让
- en: '*p* = 3 and *q* = 11\.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '*p* = 3 和 *q* = 11\。'
- en: 3\. *n* = *pq* = 3 *x* 11 = 33\.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. *n* = *pq* = 3 *x* 11 = 33\.
- en: 4\. *e* = 3, because (3 − 1) (11 − 1) = 20 which is greater than 1 and less
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. *e* = 3，因为(3 − 1) (11 − 1) = 20，大于1且小于
- en: than 20 and *GCD*(3, 20) = 1\.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 大于20且 *GCD*(3, 20) = 1\。
- en: 5\. The public key is pair ( *n*, *e*) = (33, 3).
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 公钥是一对 ( *n*, *e*) = (33, 3)。
- en: 6\. The private key is *ed* = 1 *mod* ( *p* − 1)( *q* − 1).
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 私钥是 *ed* = 1 *mod* ( *p* − 1)( *q* − 1)。
- en: '*d* = *e*−1 7'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '*d* = *e*−1 7'
- en: 20 (33 7
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 20 (33 7
- en: '*mod* ,'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod* ，'
- en: ', )'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: ', )'
- en: 7\. Send public key ( *n*, *e*) (33, 3) to Alice.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 发送公钥 ( *n*, *e*) (33, 3) 给Alice。
- en: 8\. Alice does 53 = 125 *mod* 33 = 26\.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. Alice做 53 = 125 *mod* 33 = 26\。
- en: 9\. Alice sends 26 as the encrypted text to Bob.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. Alice将26作为加密文本发送给Bob。
- en: 10\. Bob does 267 = 8031810176 = 8031810176 *mod* 33 = 5 and retrieves
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. Bob做 267 = 8031810176 = 8031810176 *mod* 33 = 5 并恢复
- en: the plaintext message 5\.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 明文消息 5\.
- en: '87'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '87'
- en: Chapter 2 Cryptography
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Elliptic Curve Cryptography**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆曲线加密**'
- en: Elliptic curve cryptography (ECC) is based on a concept in mathematics called
    elliptic
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线加密（ECC）基于数学中称为椭圆的概念
- en: curves. It is a set of points on a plane whose x, y coordinates satisfy a specific
    equation and some conditions. Typically, it is the Weierstrass form *y* 2 = *x*
    3 + *ax* + *b* where *a* and *b* are fixed.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线。它是一组在平面上的点，其x，y坐标满足特定的方程和一些条件。通常，它是威尔斯特拉斯形式 *y* 2 = *x* 3 + *ax* + *b*，其中
    *a* 和 *b* 是固定的。
- en: Elliptic curves are groups. They are used in many different areas of mathematics,
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线是群。它们在数学的许多不同领域中使用，
- en: including number theory, complex analysis, and mathematical physics. When used
    in
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 包括数论，复分析和数学物理。 在椭圆曲线
- en: cryptography, a suitable elliptic curve’s points over a finite field form a
    group structure which allows to build cryptography schemes based on a discrete
    logarithm problem.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学，适当的椭圆曲线上有限域中的点形成一种允许基于离散对数问题构建密码学方案的群结构。
- en: A prime field is used in elliptic curve cryptography. *In a prime field, all
    arithmetic* *operations are performed modulo a prime number p*.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线密码学中使用素数域。 *在素数域中，所有算术* *操作都在模素数p*中执行。
- en: 'An elliptic curve is defined in the following equation:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线在以下方程中定义：
- en: '2'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '*y* = *x* + *ax* + *b mod p*'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *x* + *ax* + *b mod p*'
- en: Here, a and b belong to a finite field *Zp* or *Fp* (prime finite field), that
    is, ( *a*, *b*) ∈ *Z*, and an imaginary point of infinity. The point of infinity
    ∞ is used to provide identity
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处，a 和 b 属于有限域*Zp*或*Fp*（素有限域），即，（*a*，*b*）∈*Z*，以及一个无穷的虚点。 无穷点∞ 用于提供身份
- en: operations for points on the curve.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线上点的操作。
- en: Furthermore, a condition shown below ensures that the curve is nonsingular,
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，下面显示的条件确保曲线是非奇异的，
- en: 'meaning the curve does not self-intersect or has vertices:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着曲线不自交或者有顶点：
- en: '3'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '4'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: + 27 ≠ 0
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: + 27 ≠ 0
- en: '*a*'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*'
- en: '*b*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*b*'
- en: '*mod p*'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod p*'
- en: To construct the discrete logarithm problem based on elliptic curves, a large
    enough
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构造基于椭圆曲线的离散对数问题，需要足够大的
- en: cyclic group is required. First, the group elements are identified as a set
    of points that satisfy the elliptic curve equation. After this, group operations
    need to be defined on
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 需要循环群。 首先，群元素被确定为满足椭圆曲线方程的点集。 之后，需要在群上定义群操作
- en: these points. The fundamental group operations on elliptic curves are point
    addition
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点。椭圆曲线上的基本群操作是点的加法
- en: and point doubling. Point addition is a process where two different points are
    added,
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 与点的加倍。 点的加法是两个不同的点相加的过程，
- en: and point doubling means that the same point is added to itself.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 和点加倍意味着将同一点加到自身。
- en: An elliptic curve can be visualized over real numbers as shown in Figure [2-12\.](#p108)
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线可以在实数上可视化，如图[2-12\.](#p108)所示
- en: '88'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '88'
- en: '![](index-108_1.png)'
  id: totrans-965
  prefs: []
  type: TYPE_IMG
  zh: '![](index-108_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-12\.** An elliptic curve over real numbers y2 = x3* − *3x + 5*'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-12\.** 实数上的椭圆曲线 y2 = x3* − *3x + 5*'
- en: We can visualize the curve and group operations, that is, addition and doubling,
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以可视化曲线和群操作，即，加法和加倍，
- en: geometrically over real numbers, which helps to build intuition. In practice,
    however, the curve over prime field is used to build ECC-based schemes. Though,
    when we try to plot
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 几何上在实数范围内，这有助于构建直觉。然而，在实践中，使用素域上的曲线来构建基于ECC的方案。然而，当我们试图绘制
- en: it, it appears quite random and not intuitive.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 它，它似乎相当随机且不直观。
- en: '**Point Addition**'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '**点的加法**'
- en: For adding two points, a line is drawn through points P and Q (the diagonal
    line in
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 对于添加两个点，通过点P和Q画一条直线（在
- en: Figur[e 2-13) t](#p109)o obtain a third point. This point, when reflected, is
    point R, shown as P+Q
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-13](#p109)来获得第三个点。 当反射时，这一点是P+Q。
- en: in Figure [2-13](#p109).
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[2-13](#p109)中。
- en: '89'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '89'
- en: '![](index-109_1.png)'
  id: totrans-976
  prefs: []
  type: TYPE_IMG
  zh: '![](index-109_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-13\.** Point addition*'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-13\.** 点的加法*'
- en: Algebraically speaking, in point addition operation, two points P and Q are
    added to
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 代数上说，在点的加法操作中，两个点P和Q相加
- en: 'obtain the coordinates of the third point R on the curve:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 获取曲线上第三个点R的坐标：
- en: '*P* + *Q* = *R*'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* + *Q* = *R*'
- en: where *P* = ( *x* 1, *y* 1) and *Q* = ( *x* 2, *y* 2) and *R* = ( *x* 3, *y*
    3).
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *P* =（*x*1，*y*1）和 *Q* =（*x*2，*y*2）和 *R* =（*x*3，*y*3）。
- en: 'For addition, we calculate the gradient between the points:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加法，我们计算点之间的斜率：
- en: ( *y* 2 − *y* 1)
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: （*y*2 − *y*1）
- en: '*S* ='
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* ='
- en: '*mod p*'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod p*'
- en: ( *x*
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: （*x*
- en: 2 − *x* 1 )
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 2 − *x*1）
- en: where S depicts the line going through P and Q.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 其中S表示通过P和Q的线。
- en: 'Now to obtain the new point R:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 现在获得新点R：
- en: '2'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '*x* = − − *mod*'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = − − *mod*'
- en: '3'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '*s*'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*'
- en: '*x* 1 *x* 2'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*1 *x*2'
- en: '*p*'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*'
- en: '*y* = ( − ) − *mod*'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = （ − ）− *mod*'
- en: '3'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '*s x* 1 *x* 2'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '*s x*1 *x*2'
- en: '*y* 1'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*1'
- en: '*p*'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*'
- en: '90'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '90'
- en: '![](index-110_1.png)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![](index-110_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Point Doubling**'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**点的加倍**'
- en: In point doubling, P is added to itself. In other words, P and Q are the same
    point. As the point adds to itself, we can call this operation point doubling.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 在点加倍中，P被加到自身。 换句话说，P和Q是相同的点。 由于点加到自身，我们可以称这个操作为点加倍。
- en: To double a point, a tangent line (the dotted diagonal line in Figure [2-14)
    is dr](#p110)awn through point P, which obtains a second point where the line
    intersects with the curve.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 要加倍一个点，必须通过穿过点 P 的切线（在图 [2-14]中，为虚线对角线）来得到第二个点，该切线与曲线相交。
- en: This point is reflected to yield the result R, shown as 2P in Figure [2-14\.](#p110)
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 此点被反射以产生结果 R，如图 [2-14\.](#p110) 中的 2P 所示。
- en: '***Figure 2-14\.** Elliptic curve point doubling*'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-14\.** 椭圆曲线点双倍*'
- en: For doubling, we use
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 对于乘以二，我们使用
- en: (3 *x* 21 + *a*)
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: (3 *x* 21 + *a*)
- en: '*S* ='
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* ='
- en: '*mod p*'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod p*'
- en: '2'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '*y*'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*'
- en: '1'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: where S depicts the tangent line going through point P.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *S* 描述了穿过点 P 的切线。
- en: 'Now to obtain the point R:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '现在要获得点 R:'
- en: '2'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '*x* = − − *mod*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = −− *mod*'
- en: '3'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '*s*'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*'
- en: '*x* 1 *x* 2'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 1 *x* 2'
- en: '*p*'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*'
- en: '*y* 3 = *s*( *x* 1 − *x* 2) − *y* 1 *mod p*'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 3 = *s*( *x* 1 − *x* 2) − *y* 1 *mod p*'
- en: '91'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '91'
- en: Chapter 2 Cryptography
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: '**Scalar Point Multiplication**'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '**标量点乘**'
- en: This operation is used to multiply a point on the elliptic curve by a given
    integer, for
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算用于将椭圆曲线上的点乘以给定整数，以用于
- en: example, an integer d and the point P. We get dP by repeatedly adding P, d times,
    as
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个整数 d 和点 P。我们通过重复加 P，d 次，来得到 dP，如
- en: 'shown in the following:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '如下所示:'
- en: '*P* + *P* +…+ *P* = *dP*'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* + *P* +…+ *P* = *dP*'
- en: This operation is used to generate a public key in ECC-based cryptosystems.
    It is
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作用于在基于 ECC 的密码系统中生成一个公钥。这是
- en: a very computationally expensive process as both point addition and doubling
    are
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常计算密集的过程，因为点加法和双倍都是
- en: 'performed repeatedly to calculate:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '反复执行来计算:'
- en: '*Q* = *dP*'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '*Q* = *dP*'
- en: where P is a point on the curve, d is a randomly chosen integer as the private
    key,
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 P 是曲线上的一个点，d 是一个随机选择的整数作为私钥，
- en: and Q is the public key obtained after the multiplication.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 Q 是相乘后得到的公钥。
- en: Making point multiplication faster is an active area of research. While there
    are many
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 使点乘法更快是一个积极的研究领域。虽然有许多
- en: algorithms for making scalar multiplication more quickly, we describe a quick
    example
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 用于更快地进行标量乘法的算法，我们描述了一个快速示例
- en: here using the double and add algorithm. It combines point addition and doubling
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用双倍和加算法。它结合了点加法和双倍
- en: operations to achieve performance.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 操作以达到性能。
- en: For example, if using addition only, to get 9P we must do P + P + P + P + P
    + P + P +
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果只进行加法，要得到 9P，我们必须执行 P + P + P + P + P + P + P +
- en: P + P, which can become impracticable very quickly if the number of Ps increases.
    We
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: P + P, 如果 Ps 的数量增加，这可能会变得不切实际。我们
- en: can use the double and add mechanism to make this faster. Here, we first convert
    nine
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用双倍和加的机制来加速这一过程。在这里，我们首先将九
- en: into binary. Starting from the most significant bit (MSB), for each bit that
    is one (high), perform the double and addition operations, and for each zero,
    perform only the double
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成二进制。从最高有效位（MSB）开始，对于每个为一（高）的位，执行双倍和加法操作，对于每个零，只执行双倍操作
- en: operation. We do not perform any operation on the most significant bit. Nine
    is 1001 in
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 操作。我们不对最高有效位执行任何操作。九用二进制表示为 1001
- en: binary, so for each bit we get (starting from left to right) P, 2P, 4P, 8P+P.
    This scheme produces 9P only with three double operations and one addition operation,
    instead of
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制, 因此对于每个位，我们（从左到右开始）得到 P，2P，4P，8P+P。这个方案只需要三次双倍操作和一次加法操作就能得到 9P，而不是
- en: nine addition operations.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 九次加法操作。
- en: '**Elliptic Curve Discrete Logarithm Problem**'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆曲线离散对数问题**'
- en: Now consider that *dP* results in producing another point *Q* on the curve.
    Even if we know the points *P* and *Q*, it is computationally infeasible to reconstruct
    the sequence of all the double and addition operations that we did to calculate
    the number d. Even if
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 *dP* 导致在曲线上产生另一个点 *Q*。即使我们知道点 *P* 和 *Q*，也计算上不可能重构我们计算数字 d 所需的所有双倍和加法操作的序列。即使
- en: someone knows *P* and *Q*, it is impossible for them to find *d*. This means
    that it is a one-way (trapdoor function) function. It is the basis of the elliptic
    curve discrete logarithm problem (ECDLP).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 如某人知道 *P* 和 *Q*，他们不可能找到 *d*。这意味着它是一个单向（陷阱函数）函数。这是椭圆曲线离散对数问题（ECDLP）的基础。
- en: '92'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '92'
- en: Chapter 2 Cryptography
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: Consider an elliptic curve E, with two elements P and Q. The discrete logarithm
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个椭圆曲线 E，其中有两个元素 P 和 Q。离散对数
- en: 'problem is to find the integer d, where 1 < = *d* < = # *E*, such that *P*
    + *P* +…+ *P* = *dP* = *Q*'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '问题是找到整数 d，其中 1 < = *d* < = # *E*，使得 *P* + *P* +…+ *P* = *dP* = *Q*'
- en: Here, *Q* is the public key (a point generated on the curve, (x, y)), and *d*
    is the private key (another point on the curve). The public key is a random multiple
    of the generator
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Q* 是公钥（曲线上生成的一个点，（x，y）），*d* 是私钥（曲线上的另一个点）。公钥是生成器的随机倍数
- en: point *P*, whereas the private key is the integer d that is used to generate
    the multiple. The Generator point or base point G is a point on the curve that
    generates a cyclic subgroup, which means that every point in the group can be
    reached by repeated addition of the
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 点 *P*，而私钥是用于生成多个的整数d。生成点或基点G是曲线上的一个点，它生成一个循环子群，这意味着群中的每个点都可以通过重复加法到达
- en: base point.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 基本点。
- en: '#E represents the order of the group (elliptic curve), which means the number
    of'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '#E代表群的阶（椭圆曲线），也就是群的数量'
- en: points that are present in the cyclic subgroup of the elliptic curve. A cyclic
    group is
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于椭圆曲线的循环子群的点。循环群是
- en: formed by a combination of points on the elliptic curve and the point of infinity.
    Cofactor *h* is the number of points in the curve divided by the order of the
    subgroup.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 由椭圆曲线上的点组合而成的，以及无穷点。余因子 *h* 是曲线上的点的数目除以子群的阶。
- en: The initial starting point *P* is a public parameter, and the public key *Q*
    is also published, whereas d, the private key, is kept secret. If d is not known,
    it is unfeasible to calculate with only the knowledge of Q and P, thus creating
    the hard problem on which
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 初始起始点 *P* 是一个公共参数，公钥 *Q* 也是公开的，而私钥d是保密的。如果d未知，仅凭Q和P的知识是不可行的，从而创建了难以解决的问题
- en: ECDLP is built.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: ECDLP是如何构建的。
- en: A key pair is linked with the specific domain parameters of an elliptic curve.
    Domain
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥对与椭圆曲线特定的域参数相关联。域
- en: parameters are public values that are required to implement ECC schemes. These
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是实现ECC方案所需的公共值。这些
- en: 'parameters are represented as a tuple { *p*, *a*, *b*, *G*, *n*, *h*}:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 参数表示为元组{*p*, *a*, *b*, *G*, *n*, *h*}：
- en: '• *P*: Field (modulo prime)'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '• *P*: 域（对素数取模）'
- en: '• *a*, *b*: Fixed elliptic curve coefficients'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '• *a*, *b*: 固定的椭圆曲线系数'
- en: '• *G*: The generator point to generate a cyclic group'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '• *G*: 生成循环群的生成器点'
- en: '• *n*: Order of the group (curve)'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '• *n*: 群的阶（曲线）'
- en: '• *h*: Cofactor'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '• *h*: 余因子'
- en: 'For example, Bitcoin uses the SECP256k1 curve with the equation *y* 2 = *x*
    3 + 7 and domain parameters as defined here: [https://en.bitcoin.it/wiki/Secp256k1\.](https://en.bitcoin.it/wiki/Secp256k1)'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，比特币使用方程为 *y* 2 = *x* 3 + 7 和域参数如下所定义的SECP256k1曲线：[https://en.bitcoin.it/wiki/Secp256k1\.](https://en.bitcoin.it/wiki/Secp256k1)
- en: The most used curves are NIST proposed curves, such as P-256\. Other curves
    include
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的曲线是NIST提出的曲线，比如P-256。其他曲线包括
- en: Curve25519, Curve1174, and many more. Of course, it is advisable to choose a
    safe curve.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519、Curve1174等等。当然，建议选择一条安全的曲线。
- en: An excellent resource of safe and unsafe curves along with explanations is maintained
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 一个维护着安全和不安全曲线及其解释的优秀资源
- en: 'online here: [https://safecurves.cr.yp.to](https://safecurves.cr.yp.to).'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里在线：[https://safecurves.cr.yp.to](https://safecurves.cr.yp.to)。
- en: '93'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '93'
- en: Chapter 2 Cryptography
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Digital Signatures**'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字签名**'
- en: Public key cryptography is used to create digital signatures. It is one of the
    most common applications of public key cryptography. In this section, we will
    discover how RSA,
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码术用于创建数字签名。这是公钥密码术最常见的应用之一。在本节中，我们将发现RSA、
- en: ECDSA, and Schnorr signatures work. Concepts such as aggregate signatures and
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA和Schnorr签名是如何工作的。诸如合成签名等概念
- en: multisignatures, also commonly used in blockchains, will be introduced.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 多重签名，也常用于区块链，将被介绍。
- en: Digital signatures provide a means of associating a message with an entity from
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名提供了一种将消息与实体联系起来的手段
- en: which the message has originated. Digital signatures are used to provide data
    origin
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的来源。数字签名用于提供数据的来源
- en: authentication and nonrepudiation.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和不可否认性。
- en: Digital signatures are used in consensus algorithms and especially in blockchain
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名在共识算法中使用，特别是在区块链中
- en: networks to sign the transactions and messages sent by a user on the blockchain
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上对区块链上的用户发送的交易和消息进行签名
- en: network. Blocks are sealed cryptographically using a digital signature so that
    the
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。区块被加密密封，以使用数字签名，以便
- en: recipient can verify the authenticity of the transmitted block. Similarly, all
    transactions are signed as well. It is common in consensus algorithms that blocks
    are sealed and
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者可以验证传输块的真实性。同样，所有交易也进行了签名。 在共识算法中，块被封存并
- en: broadcast to the network that recipients (other nodes) receive, who verifies
    the signature to ascertain the block’s authenticity. The blocks are inserted into
    the local blockchain
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 广播到网络，接收者（其他节点）接收，验证签名以确定块的真实性。 块被插入到本地区块链
- en: after verification.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 验证后。
- en: 'Digital signatures have three security properties: authenticity, unforgeability,
    and'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名有三个安全属性：真实性，不可伪造性和
- en: nonreusability.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 不可复用性。
- en: '**Authenticity**'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '**真实性**'
- en: This means that the digital signatures are verifiable by the receiving party.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数字签名可以被接收方验证。
- en: '**Unforgeability (Nonrepudiation)**'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可伪造性（不可否认性）**'
- en: This property guarantees that only the message’s sender can sign using the private
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性保证只有消息发送方才能使用私人
- en: key. Digital signatures must also protect against forgery. Forgery means an
    adversary
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥。数字签名还必须防止伪造。 伪造意味着对手
- en: fabricating a valid signature for a message without access to the legitimate
    signer’s
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一份有效签名给消息而没有合法签名者的访问权限
- en: private key. In other words, unforgeability implies that no one else can produce
    the
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥。 换句话说，不可伪造性意味着没有其他人可以产生
- en: signed message produced by a genuine sender.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 由真正的发送方产生的已签名消息。
- en: '94'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '94'
- en: '![](index-114_1.png)'
  id: totrans-1104
  prefs: []
  type: TYPE_IMG
  zh: '![](index-114_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Nonreusability**'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可复用性**'
- en: This property necessitates that the digital signature cannot be separated from
    a message
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性要求数字签名不能与消息分离
- en: and used again for another message. In other words, the digital signature is
    firmly bound to the corresponding message and cannot be separated from its original
    message and
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 并且再次用于另一个消息。 换句话说，数字签名牢固地与相应的消息绑定在一起，并且不能从其原始消息中分离出来
- en: attached to another.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到另一个。
- en: The process of signing and verification using digital signatures is shown in
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字签名进行签名和验证的过程显示在
- en: Figur[e 2-15\.](#p114)
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-15.](#p114)
- en: '***Figure 2-15\.** Digital signing (left) and verification process (right)*'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-15.** 数字签名（左）和验证过程（右）*'
- en: First, we produce the hash of the data for which we want to prove data origin
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为想要证明数据来源的数据生成哈希
- en: authentication. Then we encrypt the hash using the prover’s private key (signing
    key) to
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 身份。 然后我们使用证明者的私钥（签名密钥）加密哈希
- en: create a “signature” and attach it with the data. Finally, this signed object
    is sent to the verifier.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个“签名”并将其与数据附加。 最后，这个签名的对象被发送给验证者。
- en: The verifier decrypts the encrypted hash of the data using the signer’s (sender)
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者使用签署者（发送方）的私钥解密数据的加密哈希
- en: public key to retrieve the original hash. The verifier then takes the data and
    hashes it
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 以公钥检索原始哈希。验证者然后取数据并对其进行哈希处理
- en: again through the hash function to produce the hash. If both these hashes match,
    the
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过哈希函数再次生成哈希。如果这两个哈希匹配，那么
- en: verification is successful, proving that the signer indeed signed the data.
    It also proves the data origin authentication, along with nonrepudiation and data
    integrity properties.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 验证成功，证明签名者确实签署了数据。 它还证明了数据的原始身份认证，以及不可否认性和数据完整性属性。
- en: Now we describe how ECDSA (elliptic curve digital signature algorithm) works.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们描述ECDSA（椭圆曲线数字签名算法）的工作原理。
- en: '95'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '95'
- en: Chapter 2 Cryptography
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**ECDSA Signatures**'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECDSA 签名**'
- en: ECDSA is a DSA based on elliptic curves. The DSA is a standard for digital signatures.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA 是基于椭圆曲线的 DSA。 DSA是数字签名的标准。
- en: It is based on modular exponentiation and the discrete logarithm problem. It
    is used
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法基于模幂和离散对数问题。 它用于
- en: on Bitcoin and Ethereum blockchain platforms to validate messages and provide
    data
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币和以太坊区块链平台上验证消息并提供数据
- en: integrity services.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性服务。
- en: Now, we’ll describe how ECDSA works.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述ECDSA的工作原理。
- en: 'To sign and verify using the ECDSA scheme, first a key pair needs to be generated:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ECDSA方案进行签名和验证，首先需要生成密钥对：
- en: '1\. Define an elliptic curve E with the following:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 定义椭圆曲线 E 如下：
- en: • Modulus *P*
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: • 模 *P*
- en: • Coefficients *a* and *b*
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: • 系数 *a* 和 *b*
- en: • A generator point *A* that forms a cyclic group of prime order *q*
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个生成点 *A* 形成一个质数次阶循环群 *q*
- en: 2\. Choose an integer *d* randomly such that 0 < *d* < *q*.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 随机选择整数 *d*，使得 0 < *d* < *q*。
- en: 3\. Calculate the public key *B* so that *B* = *dA*.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 计算公钥 *B*，使得 *B* = *dA*。
- en: '• The public parameters are a sextuple in the form shown here:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '• 公共参数是六元组，格式如下:'
- en: '*Kpb* = ( *p*, *a*, *b*, *q*, *A*, *B*)'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kpb* = ( *p*, *a*, *b*, *q*, *A*, *B*)'
- en: '• The private key is a randomly chosen integer d in step 2:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '• 私钥是在步骤 2 中随机选择的整数 d:'
- en: '*Kpr* = *d*'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kpr* = *d*'
- en: Now, the signature can be generated using the private and public keys.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用私钥和公钥生成签名。
- en: 4\. An ephemeral key *Ke* is chosen, where 0 < *Ke* < *q*. Also, ensure that
    *Ke* is random and that no two signatures end up with the same key;
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 选择一个临时密钥 *Ke*，其中 0 < *Ke* < *q*。并且确保 *Ke* 是随机的，不会出现两个签名最终相同密钥;
- en: otherwise, the private key can be calculated.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，私钥可以被计算。
- en: 5\. A value *R* is calculated using *R* = *Ke* *A*, that is, by multiplying
    *A* (the generator point) and the random ephemeral key.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 使用 *R* = *Ke* *A* 计算值 *R*，即，将 *A*（生成点）和随机临时密钥相乘。
- en: 6\. Initialize a variable *r* with the *x* coordinate value of point *R* so
    that *r* = *xR*.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 使用 *R* 的 *x* 坐标值初始化变量 *r*，以确保 *r* = *xR*。
- en: '7\. The signature can now be calculated as follows:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '7\. 现在，可以计算签名如下:'
- en: '*s* = ( *h*( *m*) + *d r*.) *K mod*'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* = ( *h*( *m*) + *d r*.) *K mod*'
- en: −1
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: −1
- en: '*q*'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '*q*'
- en: '*e*'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*'
- en: '96'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '96'
- en: Chapter 2 Cryptography
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: Here, *m* is the message for which the signature is calculated, and *h*( *m*)
    is the hash of the message *m*.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*m* 是为其计算签名的消息，*h*( *m*) 是消息 *m* 的哈希。
- en: '8\. Signature verification is carried out as follows:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '8\. 签名验证进行如下:'
- en: • A value *w* is calculated as *w* = *s*−1 *mod q*.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: • 计算值 *w*，其中 *w* = *s*−1 *mod q*。
- en: • A value *u* 1 = *w*. *h*( *m*) *mod q*.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: • 值 *u* 1 = *w*. *h*( *m*) *mod q*。
- en: • A value *u* 2 = *w*. *r mod q*.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: • 计算值 *u* 2 = *w*. *r mod q*。
- en: '• Calculate point *P*:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '• 计算点 *P*:'
- en: '*P* = *u* 1 *A* + *u* 2 *B*'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = *u* 1 *A* + *u* 2 *B*'
- en: '9\. Verification is carried out as follows:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '9\. 验证进行如下:'
- en: • *r*, *s* is accepted as a valid signature if the x coordinate of point *P*
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果点 *P* 的 x 坐标,*r*, *s* 被接受为有效签名
- en: calculated in step 4 has the same value as the signature parameter
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4 中计算得到的值与签名参数相同
- en: '*r* mod *q*; that is:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '*r* mod *q*; 即:'
- en: '*Xp* = *r mod q* means a valid signature.'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Xp* = *r mod q* 意味着有效签名。'
- en: '*Xp* ≠ *r mod q* means an invalid signature.'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Xp* ≠ *r mod q* 意味着无效签名。'
- en: This completes our introduction to digital signatures and especially ECDSA.
    ECDSA
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对数字签名和特别是 ECDSA 的介绍。ECDSA
- en: is quite commonly used in blockchain networks, including Bitcoin, Ethereum,
    and
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链网络中被广泛使用，包括比特币、以太坊和
- en: several enterprise chains. Now we describe some other digital signature variations.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 几个企业链。现在我们描述一些其他数字签名变体。
- en: '**Multisignatures**'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重签名**'
- en: In this scheme, multiple unique keys held by their respective owners are used
    to sign a
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方案中，由其各自所有者拥有的多个唯一密钥用于签署
- en: single message. In blockchain implementations, multisignature schemes allow
    multiple
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 单个消息。在区块链实现中，多重签名方案允许多个
- en: users to sign a transaction, which results in increased security. Moreover,
    in blockchain networks, these schemes can be used so that users can set the condition
    of at least one or more than one signature to authorize transactions.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对交易进行签名，从而增加了安全性。此外，在区块链网络中，这些方案可以用作用户设置至少一个或多个签名以授权交易的条件。
- en: For example, a 1-of-2 multisignature scheme can represent a joint account where
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，1-of-2 多重签名方案可以表示一个联合账户，其中
- en: either one of the joint account holders is required to authorize a transaction
    by signing it. In another variation, a 2-of-2 multisignature can be used where
    both joint account
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 联合账户持有者之一需要授权交易，进行签名。在另一种变体中，可以使用 2-of-2 多重签名，其中联合账户
- en: holders’ signatures must authorize the transaction. This concept is generalized
    as m of
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 持有方的签名必须授权交易。该概念被概括为 m 个
- en: n signatures, where m is the minimum number of expected signatures and n is
    the total
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: n 个签名，其中 m 是预期签名的最小数量，n 是总数
- en: number of signatures.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 签名数量。
- en: '97'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '97'
- en: '![](index-117_1.png)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![](index-117_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 章 密码学
- en: This process is shown in Figur[e 2-16](#p117).
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程如图[2-16](#p117)所示。
- en: '***Figure 2-16\.** Multisignature scheme*'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-16\.** 多重签名方案*。'
- en: Figur[e 2-16 sho](#p117)ws the signing process on the left-hand side, where
    m is the number of different users, and holding m unique signatures signs a single
    transaction. When the
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-16 显](#p117)示了左侧的签名过程，其中 m 是不同用户的数量，持有 m 个唯一签名对单个交易进行签名。当
- en: validator or verifier receives it, all the signatures in it need to be individually
    verified.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者或验证方接收到时，其中的所有签名都需要被逐个验证。
- en: '**Threshold Signatures**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '**阈值签名**'
- en: This scheme does not rely on users to sign the message with their individual
    keys;
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案不依赖于用户用其个人密钥签名消息；
- en: instead, it requires only one public key and one private key to produce the
    digital
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，只需要一个公钥和一个私钥来生成数字
- en: signature. In a multisignature scheme, the signed message contains digital signatures
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 签名。在多重签名方案中，已签名消息包含数字签名
- en: from all signers. It requires verification individually by the verification
    party, but the verifier must verify only one digital signature in threshold signatures.
    The key idea in this scheme is to split the private key into multiple parts, and
    each signer keeps its share of the private key. The signing process requires each
    user to use their respective share of
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 来自所有签名者。它需要由验证方逐个验证，但在阈值签名中验证者只需要验证一个数字签名。该方案的关键思想是将私钥分割为多个部分，每个签名者保留其私钥的份额。签名过程要求每个用户使用其各自的份额
- en: the private key to sign the message. A particular communication protocol manages
    the
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私钥签署消息。一种特殊的通信协议管理
- en: communication between the signers.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 签名者之间的通信。
- en: In contrast with multisignatures, the threshold signatures result in smaller
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 与多重签名相比，阈值签名导致更小
- en: transaction sizes and are faster to verify. A downside, however, is that for
    threshold
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 交易大小并且更快地验证。然而，一个缺点是对于阈值
- en: signatures to work, all signers must remain online. In multisignature schemes,
    the
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 签名要起作用，所有签名者必须保持在线。在多重签名方案中，签名者
- en: '98'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '98'
- en: '![](index-118_1.png)'
  id: totrans-1195
  prefs: []
  type: TYPE_IMG
  zh: '![](index-118_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: signatures can be delivered asynchronously. In other words, users can provide
    signatures
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 签名可以异步地传递。换句话说，用户可以提供签名
- en: whenever available. One downside is that there could be a situation where users
    may
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时都应该提供签名。一个缺点是可能出现用户
- en: withhold their signature maliciously, resulting in a denial of service. We can
    also use
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意地拒绝签署，导致服务拒绝。我们还可以使用
- en: threshold signatures to provide anonymity in a blockchain network, as individual
    signers
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值签名用于在区块链网络中提供匿名性，因为个体签名者
- en: are unidentifiable in multisignature schemes.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重签名方案中是不可识别的。
- en: Figur[e 2-17 sho](#p118)ws the signing process on the left-hand side, where
    an m number of different users, holding different parts (shares) of a digital
    signature, sign a single transaction. When the validator or verifier receives
    it, only one signature needs to be
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-17显示了左侧的签名过程，其中有m个不同的用户，持有数字签名的不同部分（份额），对单个交易进行签名。当验证者或验证方接收到时，只需要一个签名即可。
- en: verified.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 验证。
- en: '***Figure 2-17\.** Threshold signatures*'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-17.** 阈值签名*'
- en: '**Aggregate Signatures**'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合签名**'
- en: Aggregate signatures reduce the size of digital signatures. This scheme is beneficial
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合签名减小了数字签名的大小。这种方案是有益的。
- en: in scenarios where multiple digital signatures are in use. The core idea is
    to aggregate
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个数字签名被使用的情景中。其核心思想是聚合
- en: multiple signatures into a single signature without increasing the size of the
    signature of a single message. It is simply a type of digital signature that supports
    aggregation.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个签名聚合成单个签名而不增加单个消息签名的大小。简而言之，它是一种支持聚合的数字签名类型。
- en: The small aggregate signature is enough to prove to the verifier that all users
    signed
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 小的聚合签名足以向验证者证明所有用户都签署了
- en: their original messages. Thus, aggregate signatures are commonly used to reduce
    the
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的原始消息。因此，聚合签名通常用于减少
- en: size of messages in network and security protocols. For example, we can significantly
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和安全协议中信息的大小。例如，我们可以显著
- en: reduce the size of digital certificate chains in Public Key Infrastructure (PKI)
    by
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 减小公钥基础设施（PKI）中数字证书链的大小
- en: compressing all signatures in the chain into a single signature. Boneh-Lynn-Shacham
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有签名压缩成单个签名。Boneh-Lynn-Shacham
- en: '99'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '99'
- en: '![](index-119_1.png)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
  zh: '![](index-119_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: (BLS) aggregate signatures are a typical example of the aggregate signature.
    BLS has also been used in various blockchains and especially in Ethereum 2.0\.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: （BLS）聚合签名是聚合签名的典型示例。BLS也已经被各种区块链特别是以太坊2.0所使用。
- en: Schnorr signatures are another type of signature based on elliptic curve
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: Schnorr签名是另一种基于椭圆曲线的签名类型
- en: cryptography that allows key and signature aggregation. Schnorr signatures are
    64 bytes
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学允许密钥和签名聚合。 Schnorr签名是64字节
- en: in size as compared to ECDSA, which is 71 bytes in signature size. ECDSA’s private
    key
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 与ECDSA相比，其大小为71字节。 ECDSA的私钥
- en: size is 32 bytes and its public key is 33 bytes, whereas the Schnorr scheme’s
    private
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 大小为32字节，其公钥为33字节，而Schnorr方案的私钥
- en: and public keys are 32 bytes in size. Overall, Schnorr signatures are smaller
    and faster
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 和公钥大小为32字节。总的来说，Schnorr签名更小，更快
- en: than ECDSA.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是ECDSA。
- en: Figur[e 2-18 sho](#p119)ws how the aggregate signatures work.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-18显示](#p119)了如何使用聚合签名。
- en: '***Figure 2-18\.** Aggregate signatures*'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-18\.** 聚合签名*'
- en: Schnorr signatures are proposed to be used in Bitcoin under Bitcoin Improvement
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 计划在比特币中使用Schnorr签名，这是比特币改进
- en: Proposal (BIP) 340\.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 提案（BIP）340\.
- en: '**Ring Signatures**'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '**环签名**'
- en: Ring signature schemes are mechanisms where any member of a group of signers
    can
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 环签名方案是一种任何签署者群体的机制都可以
- en: sign a message on behalf of the entire group. Each member of the ring group
    keeps
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 代表整个群体签署消息。环组的每个成员都保留
- en: a public key and a private key. The key point here is that the identity of the
    actual
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公钥和一个私钥。关键点在于实际碰撞的身份
- en: signer who signed the message must remain unknown (computationally infeasible
    to
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 签署消息的签名者必须保持未知（计算上不可
- en: determine) to an outside observer. It looks equally likely that anyone from
    the trusted
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 确定）对外部观察者来说。看起来任何来自可信
- en: group of signers could have signed the message, but it is not possible to figure
    out the
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 签名者群体可能已签署了消息，但不可能找出
- en: individual user who signed the message. Thus, we can use ring signatures to
    provide an
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 签署消息的个人用户。因此，我们可以使用环签名提供
- en: anonymity service.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名服务。
- en: '100'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '100'
- en: '![](index-120_1.png)'
  id: totrans-1238
  prefs: []
  type: TYPE_IMG
  zh: '![](index-120_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Hash Functions**'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '**散列函数**'
- en: Hash functions are keyless primitives which create fixed-length digests of arbitrarily
    long input data. There are three security properties of hash functions.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 散列函数是无密钥原语，可以创建任意长度输入数据的固定长度摘要。散列函数有三个安全属性。
- en: '**Preimage Resistance**'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '**预像抗力**'
- en: This property is also called a one-way property. It can be explained by using
    the simple
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性也称为单向属性。可以使用简单的方式来解释
- en: 'equation:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '方程:'
- en: '*h*( *x*) = *y*'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*( *x*) = *y*'
- en: where *h* is the hash function, *x* is the input, and *y* is the output hash.
    The first security property requires that *y* cannot be reverse-computed to *x*.
    *x* is the preimage of *y*, thus the name preimage resistance. This property is
    depicted in Figure [2-19\.](#p120)
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*h*是散列函数，*x*是输入，*y*是输出散列。第一个安全属性要求*y*不能被逆向计算为*x*。*x*是*y*的预像，因此称为预像抗力。此属性在图[2-19\.](#p120)中显示。
- en: '***Figure 2-19\.** Preimage resistance*'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-19\.** 预像抗力*'
- en: '**Second Preimage Resistance**'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二预像抗力**'
- en: This property is also known as the weak collision resistance property. This
    property
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性也称为弱碰撞抗性属性。此属性
- en: ensures that given *x* and *h*( *x*), it is almost impossible to find any other
    message *m*, where *m* ≠ *x* and hash of *m* = hash of *x* or *h*( *m*) = *h*(
    *x*). This property is shown in Figure [2-20\.](#p121)
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 确保给定*x*和*h*( *x*)，几乎不可能找到任何其他消息*m*，其中*m* ≠ *x*并且*m*的哈希=*x*的哈希或*h*( *m*)=*h*(
    *x*)。此属性显示在图[2-20\.](#p121)
- en: '101'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '101'
- en: '![](index-121_1.png)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![](index-121_1.png)'
- en: '![](index-121_2.png)'
  id: totrans-1253
  prefs: []
  type: TYPE_IMG
  zh: '![](index-121_2.png)'
- en: Chapter 2 Cryptography
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-20\.** Second preimage resistance*'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-20\.** 第二预像抗力*'
- en: '**Collision Resistance**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞抗力**'
- en: The collision resistance property requires that two different input messages
    should not
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞抗性属性要求两个不同的输入消息不应该
- en: hash to the same output. In other words, *h*( *x*) ≠ *h*( *z*). Figure [2-21
    sho](#p121)ws a depiction of collision resistance.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 散列到相同的输出。换句话说，*h*( *x*) ≠ *h*( *z*)。图[2-21显示](#p121)了碰撞抗性的描绘。
- en: '***Figure 2-21\.** Strong collision resistance*'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-21\.** 强碰撞抗性*'
- en: 'In addition, there are two functional properties of hash functions:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，散列函数还有两个功能属性：
- en: • Compression of arbitrary size data into a fixed-length digest
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: •将任意大小数据压缩为固定长度摘要
- en: • Easy to compute
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: •易于计算
- en: Hash functions, due to their very nature, are always expected to have collisions,
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其本质，散列函数总是可能存在碰撞，
- en: where two different messages hash to the same output, but in a good hash function,
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不同的消息散列到相同的输出，但在良好的散列函数中，
- en: collisions must be computationally infeasible to find.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞必须是计算上不可行的。
- en: Moreover, hash functions should also have a property that a small change, even
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，哈希函数还应具有一个特性，即即使是微小的变化
- en: a single character change in the input text, should result in an entirely different
    hash
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本中的一个字符更改，也应导致完全不同的哈希
- en: output. This is known as the **avalanche effect**.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出。这被称为**雪崩效应**。
- en: '102'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '102'
- en: Chapter 2 Cryptography
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章 密码学
- en: Hash functions are usually designed by using the iterated hash function method,
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数通常使用迭代哈希函数方法设计，
- en: where the input data is divided into equal block sizes and then they are processed
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 其中输入数据分成相等的块大小，然后对它们进行处理
- en: iteratively through the compression functions.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过压缩函数迭代。
- en: Some prominent approaches to build hash functions using iterative methods are
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代方法构建哈希函数的一些杰出方法如下：
- en: 'listed as follows:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 列如下：
- en: • Merkle-Damgard construction
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: • Merkle-Damgart 结构
- en: • Sponge construction
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: • 海绵结构
- en: The most common hash function schemes are SHA-0, SHA-1, SHA-2, SHA-3,
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的哈希函数方案是 SHA-0、SHA-1、SHA-2、SHA-3、
- en: RIPEMD, and Whirlpool.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: RIPEMD和Whirlpool。
- en: '**Design of Secure Hash Algorithms (SHA)**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全哈希算法（SHA）的设计**'
- en: In this section, we will introduce the design of SHA-256 and SHA-3\. Both are
    used
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍 SHA-256 和 SHA-3 的设计。二者都用于
- en: in Bitcoin and Ethereum, respectively. However, Ethereum uses Keccak, the original
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币和以太坊中有用。然而，以太坊采用了原始的 Keccak
- en: algorithm presented to NIST, rather than NIST standard SHA-3\. NIST, after some
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 提交给 NIST 的算法，而不是 NIST 标准的 SHA-3。经过一些
- en: modifications, such as an increase in the number of rounds and simpler message
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 修改，比如增加轮数和更简单的消息
- en: padding, standardized Keccak as SHA-3\.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 填充，将 Keccak 标准化为 SHA-3。
- en: '**Design of SHA-256**'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHA-256 的设计**'
- en: SHA-256 has an input message size limit of 264 − 1 bits. The block size is 512
    bits, and it has a word size of 32 bits. The output is a 256-bit digest.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256 的输入消息大小限制为 2^64-1 位。块大小为 512 位，字长为 32 位。输出为 256 位摘要。
- en: The compression function processes a 512-bit message block and a 256-bit
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩函数处理 512 位消息块和 256 位
- en: 'intermediate hash value. There are two main components of this function: the'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 中间哈希值。这个函数有两个主要组成部分：中间哈希值的
- en: compression function and a message schedule.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩函数和消息计划。
- en: The algorithm works as follows, in nine steps.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法工作如下，在九步中。
- en: '**Preprocessing**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理**'
- en: • Padding of the message is used to adjust the length of a block to 512
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: • 用于调整块长度为 512 的消息填充
- en: bits if it is smaller than the required block size of 512 bits.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 位，如果小于要求的 512 位块大小。
- en: • Parsing the message into message blocks, which ensures that the
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: • 解析消息为消息块，以确保
- en: message and its padding are divided into equal blocks of 512 bits.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 消息及其填充被分成相等的 512 位块。
- en: '103'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '103'
- en: '![](index-123_1.png)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![](index-123_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章 密码学
- en: • Setting up the initial hash value, which consists of the eight 32-bit
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: • 设置初始哈希值，由八个 32 位组成
- en: words obtained by taking the first 32 bits of the fractional parts of the
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取小数部分的前32位获得的字
- en: square roots of the first eight prime numbers. These initial values
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个八个质数的平方根。这些初始值
- en: are fixed and chosen to initialize the process. They provide a level of
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 是固定的并被选择来初始化该进程。他们提供了一定程度的
- en: confidence that no backdoor exists in the algorithm.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 确信算法中不存在后门。
- en: '**Hash Computation**'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希计算**'
- en: • Each message block is then processed in a sequence, and it requires
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: • 然后每个消息块按顺序处理，需要
- en: 64 rounds to compute the full hash output. Each round uses slightly
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 64轮来计算完整的哈希输出。每轮使用稍微
- en: different constants to ensure that no two rounds are the same.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的常数以确保没有两轮是相同的。
- en: • The message schedule prepares.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: • 消息计划准备。
- en: • Eight working variables initialize.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: • 八个工作变量初始化。
- en: • The compression function runs 64 times.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: • 压缩函数运行 64 次。
- en: • The intermediate hash value is calculated.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: • 计算中间哈希值。
- en: • Finally, after repeating steps 5 through 8 until all blocks (chunks
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: • 最后，在重复步骤 5 到 8 直到所有块（
- en: of data) in the input message are processed, the output hash is
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 数据）被处理，输出哈希值是
- en: produced by concatenating intermediate hash values.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 由中间哈希值连接生成。
- en: At a high level, SHA-256 can be visualized in Figure [2-22\.](#p123)
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次上，SHA-256 可以在图 [2-22\.](#p123) 中可视化。
- en: '***Figure 2-22\.** SHA-256 high-level overview*'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-22\.** SHA-256 高层次概述*'
- en: As shown in Figur[e 2-22](#p123), SHA-256 is a Merkle-Damgard construction that
    takes the input message and divides it into equally sized blocks of 512 bits.
    Initial hash values, or the initialization vector, which are composed of eight
    32-bit words (i.e., 256 bits), are fed 104
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[2-22](#p123)所示，SHA-256是一种Merkle-Damgard构造，将输入消息分成大小相同的512位块。初始哈希值，或初始化向量，由八个32位字(即256位)组成，被馈送104
- en: '![](index-124_1.png)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
  zh: '![](index-124_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章密码学
- en: into the compression function with the first message. Subsequent blocks are
    fed into the
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 到压缩函数，第一个消息被输入。随后的块被输入到
- en: compression function until all blocks are processed to produce the output hash.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩函数，直到所有块被处理以产生输出散列。
- en: The compression function of SHA-256 is shown in Figure [2-23](#p124).
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256的压缩函数显示在图[2-23](#p124)中。
- en: '***Figure 2-23\.** One round of the SHA-256 compression function*'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-23\.** SHA-256压缩函数的一个轮*'
- en: In Figur[e 2-23](#p124), *a*, *b*, *c*, *d*, *e*, *f*, *g*, and *h* are the
    registers for eight working variables. Maj and Ch are functions which are applied
    bitwise. *Σ* 0 and *Σ* 1 perform bitwise rotation. The round constants are *Wj*
    and *Kj*, which are added in the main loop (compressor function) of the hash function,
    which runs 64 times.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中[2-23](#p124)，*a*、*b*、*c*、*d*、*e*、*f*、*g*和*h*是八个工作变量的寄存器。Maj和Ch是按位应用的函数。*Σ*
    0和*Σ* 1执行按位旋转。轮常数是*Wj*和*Kj*，它们在哈希函数的主循环(压缩器函数)中加入，该函数运行64次。
- en: '**Design of SHA-3 (Keccak)**'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHA-3(Keccak)的设计**'
- en: The structure of SHA-3 is very different from that of SHA-1 and SHA-2\. SHA-3
    is based
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-3的结构与SHA-1和SHA-2非常不同。SHA-3是基于
- en: on unkeyed permutations instead of other typical hash function constructions
    that used
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在未键控排列上而不是其他典型的哈希函数构造
- en: keyed permutations. Keccak also does not use the Merkle-Damgard transformation,
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 键控排列。Keccak也不使用Merkle-Damgard转换，
- en: commonly used to handle arbitrary-length input messages in hash functions. Instead,
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于处理哈希函数中任意长度的输入消息。相反，
- en: a newer approach, called sponge and squeeze construction, is used in Keccak.
    It is a
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 一种新的方法，称为海绵和挤压构造，用于Keccak。这是一种
- en: random permutation model.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 随机排列模型。
- en: Different variants of SHA-3 have been standardized, such as SHA3-224, SHA3-256,
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 已标准化不同的SHA-3变体，如SHA3-224、SHA3-256、
- en: SHA3-384, SHA3-512, SHAKE128, and SHAKE256\. In addition, SHAKE128 and
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: SHA3-384、SHA3-512、SHAKE128和SHAKE256。此外，SHAKE128和
- en: SHAKE256 are extendable-output functions (XOFs), which allow the output to be
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: SHAKE256是可扩展输出函数(XOFs)，允许输出为
- en: extended to any desired length.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展到任意所需长度。
- en: '105'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '105'
- en: '![](index-125_1.png)'
  id: totrans-1338
  prefs: []
  type: TYPE_IMG
  zh: '![](index-125_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章密码学
- en: Figur[e 2-24 sho](#p125)ws the sponge and squeeze model on which SHA-3 or Keccak
    is based. Analogous to a sponge, the data (m input data) is first “absorbed” into
    the sponge after applying padding. It is then changed into a subset of permutation
    state using
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-24 sho](#p125)ws的海绵和挤压模型是基于SHA-3或Keccak的。类似于海绵，数据(m输入数据)首先被“吸收”到海绵中，然后应用填充。然后通过置换状态的子集转换成
- en: XOR (exclusive OR), and, finally, the output is “squeezed” out of the sponge
    function
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 异或(异或)，最后，输出从海绵函数中“挤出来”
- en: representing the transformed state. The rate r is the input block size of the
    sponge
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 代表变换后的状态。速率r是海绵的输入块大小
- en: function, whereas capacity c determines the security level.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，而容量c决定了安全级别。
- en: '***Figure 2-24\.** The SHA-3 absorbing and squeezing function*'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-24\.** SHA-3吸收和挤压函数*'
- en: In Figur[e 2-24](#p125), state size b is calculated by adding bit rate r and
    capacity bits c. r and c can be any values if sizes of r + c are 25, 50, 100,
    200, 400, 800, or 1600\. The state is a three-dimensional bit matrix which is
    initially set to 0\. The data m is entered into the
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中[2-24](#p125)，状态大小b由添加比特率r和容量位c计算。如果r + c的大小为25、50、100、200、400、800或1600，则r和c可以是任何值。状态是一个三维位矩阵，最初设置为0。数据m输入到
- en: absorb phase block by block via XOR ⊕ after applying padding.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用填充后，按块通过XOR ⊕吸收阶段。
- en: Table [2-1](#p126) shows the value of bit rate r (block size) and capacity c
    required to achieve the desired output hash size under the most efficient setting
    of r + c = 1600\.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 表[2-1](#p126)显示了为实现所需的输出哈希大小所需的比特率r(块大小)和容量c的值，在r + c = 1600\的最有效设置下。
- en: '106'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '106'
- en: '![](index-126_1.png)'
  id: totrans-1349
  prefs: []
  type: TYPE_IMG
  zh: '![](index-126_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章密码学
- en: '***Table 2-1\.** Bit rate and capacity supported in SHA-3*'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '***表2-1\.** SHA-3支持的比特率和容量*'
- en: '-'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: The function f is a permutation function. It contains five transformation operations
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 f 是一个排列函数。它包含五个转换操作
- en: 'named Theta, Rho, Pi, Chi, and Iota, which are described as follows:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 分别命名为 Theta、Rho、Pi、Chi 和 Iota，分别描述如下：
- en: '*θ*− *Theta*: XOR bits in the state, used for mixing'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '*θ*− *Theta*：状态中的位异或操作，用于混合'
- en: '*ρ*− *Rho*: Diffusion function performing rotation of bits'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '*ρ*− *Rho*：执行位旋转的扩散函数'
- en: '*π*− *Pi*: Diffusion function'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '*π*− *Pi*：扩散函数'
- en: '*χ*− *Chi*: XOR each bit, bitwise combine'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '*χ*− *Chi*：对每一位进行异或操作，位级组合'
- en: '*ι*− *Iota*: Combination with round constants'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '*ι*− *Iota*：与轮常数结合'
- en: The key idea is to apply these transformations to achieve the avalanche effect,
    which
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是应用这些转换以实现雪崩效应
- en: ensures that even a tiny change in the input results in a substantial change
    in the output.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 确保即使在输入中的微小变化也会导致输出的大幅变化。
- en: These five operations combined form a single round. In the SHA-3 standard, the
    number
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个操作合并成一个单轮。在SHA-3标准中，轮数为24，以达到所需的安全级别。
- en: of rounds is 24 to achieve the desired level of security.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 轮数为 24 以达到所需的安全级别。
- en: '**Message Authentication Codes**'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息认证码**'
- en: Message authentication codes (MACs) are used to provide authentication services
    in a
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 消息认证码（MACs）用于在
- en: cryptosystem. MACs are sometimes called keyed hash functions, and we can use
    them
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统。MACs 有时被称为带密钥的哈希函数，我们可以使用它们
- en: to provide message integrity and data origin authentication. MACs can be constructed
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 用于提供消息完整性和数据起源认证。MACs 可以构造
- en: using block ciphers or hash functions.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用块密码或散列函数。
- en: Figur[e 2-25 sho](#p127)ws a MAC operation where a sender has appended an authentication
    tag T to the message M. MACs are symmetric cryptographic primitives that use a
    shared
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-25 显](#p127)示了一个发送者追加认证标签 T 到消息 M 的 MAC 操作。MACs 是对称加密原语，使用共享的
- en: key between the sender and the receiver. The sender uses this key to generate
    the
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者和接收者之间的密钥。发送方使用该密钥生成
- en: authentication tag, whereas the receiver uses the same key for verification.
    The MAC
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 认证标签，而接收方使用相同密钥进行验证。MAC
- en: function takes the key and message M as input and produces the authentication
    tag T.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将密钥和消息 M 作为输入，并生成认证标签 T。
- en: '107'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '107'
- en: '![](index-127_1.png)'
  id: totrans-1374
  prefs: []
  type: TYPE_IMG
  zh: '![](index-127_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '***Figure 2-25\.** Operation of a MAC function*'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 2-25\.** MAC 函数的运行*'
- en: T and M are sent to the receiver who runs the same process and compares T with
    T’,
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: T 和 M 发送给接收者，接收者运行相同的过程并将 T 与 T’（）比较，
- en: which the verifier has generated by applying the same MAC function, and if they
    match,
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者通过应用相同的 MAC 函数生成，并且如果它们匹配，
- en: the verification is successful.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 验证成功。
- en: '**Hash-Based MACs (HMACs)**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于哈希的 MACs（HMACs）**'
- en: Like the hash functions, hash-based MACs (HMACs) produce a fixed-length output
    and
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 像散列函数一样，基于散列的 MACs（HMACs）产生固定长度的输出
- en: take an arbitrarily long message as the input. In this scheme, the sender signs
    a message using the MAC, and the receiver verifies it using the shared secret
    key. The key is hashed with the message using either the secret prefix or the
    secret suffix method. With the
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 将任意长的消息作为输入。在此方案中，发送方使用 MAC 签署消息，接收方使用共享的秘密密钥验证。密钥使用秘密前缀或秘密后缀方法对消息进行哈希处理。使用该方法
- en: secret prefix method, the key is concatenated with the message, that is, the
    key comes
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密前缀方法，密钥与消息连接在一起，也就是密钥位于
- en: first, and the message comes afterward, whereas with the secret suffix method,
    the key
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是密钥，然后是消息，而秘密后缀方法中，密钥
- en: 'comes after the message, as shown in the following:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息之后，如下所示：
- en: '*Secret* *prefix* : *M* = *MAC* ( ) = ('
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '*秘密* *前缀*： *M* = *MAC*() = ('
- en: )
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*k x*'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '*k x*'
- en: '*h k* || *x*'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '*h k* || *x*'
- en: '*Secret* *suffix* : *M* = *MAC* ( ) = ('
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '*秘密* *后缀*： *M* = *MAC*() = ('
- en: )
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*k x*'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '*k x*'
- en: '*h x* || *k*'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '*h x* || *k*'
- en: '108'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '108'
- en: Chapter 2 Cryptography
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: There are pros and cons to both methods. Some attacks on both schemes have
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法各有利弊。一些攻击针对这两种方案
- en: occurred. HMAC construction schemes use *ipad* (inner padding) and *opad* (outer
    padding) for padding, which is considered secure with some assumptions.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 发生。HMAC 构造方案使用*ipad*（内部填充）和*opad*（外部填充）进行填充，假设安全性较高。
- en: Various significant applications of hash functions are used in peer-to-peer
    networks
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 在等级认证中有着重要应用，并且用在点对点网络中
- en: and blockchain networks, such as Merkle trees, Patricia tries, Merkle Patricia
    tries, and distributed hash tables.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 和区块链网络中使用，例如 Merkle 树、Patricia tries、Merkle Patricia tries 和分布式哈希表。
- en: Some latest advancements, such as verifiable delay functions, are discussed
    next.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论一些最新进展，例如可验证延迟函数。
- en: '**Verifiable Delay Functions**'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '**可验证延迟函数**'
- en: Verifiable delay functions (VDFs) are cryptographic primitives that require
    a sequential
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 可验证延迟函数（VDFs）是需要顺序的密码原语
- en: number of steps (substantial time) to evaluate but are very quick and efficient
    to verify.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 需要若干步骤（大量时间）来评估，但验证非常迅速和高效。
- en: The evaluation must be sequential, and even with parallelization, the evaluation
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 评估必须是顺序的，即使并行化，评估
- en: must take the specified amount of time. However, the verification is efficient.
    VDFs
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 必须花费指定的时间。但验证是高效的。VDFs
- en: have multiple applications in distributed networks, for example, they can be
    used as
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式网络中有多种应用，例如，它们可以用作
- en: randomness beacons that publish random, unpredictable, and non-manipulable values
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性信标发布随机、不可预测和不可操控的值
- en: at fixed intervals. Randomness beacons can be used to build random leader election
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定的时间间隔。随机性信标可用于构建随机领导者选举
- en: algorithms. VDFs also have applications in multiparty computations, permissionless
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 算法。VDFs还在多方计算、无许可
- en: consensus, and timestamping of events.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: consensus, and timestamping of events.
- en: Formally, VDFs can be defined as follows. There are three procedures involved
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，VDFs可以定义如下。涉及三个过程
- en: 'in a VDF:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 在VDF中：
- en: '*setup*( *λ*, *t*) → *pp* where *λ* is the security parameter and *t* is the
    time parameter, for example, a ten-minute delay.'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup*( *λ*, *t*) → *pp* 其中 *λ* 是安全参数，*t* 是时间参数，例如，十分钟的延迟。'
- en: '*evaluate*( *pp*, *x*) → *y*, *π* where *x* is the input, *pp* is the public
    parameters, *y* is the output, and *π* is the proof. *π* can be optional depending
    on the construction.'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '*evaluate*( *pp*, *x*) → *y*, *π* 其中 *x* 是输入，*pp* 是公共参数，*y* 是输出，*π* 是证明。根据构造方式，*π*
    可能是可选项。'
- en: '*verify*( *pp*, *x*, *y*. *π*) → { *true*, *false*} which outputs either true
    or false indicating the success or failure of the verification which checks'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '*verify*( *pp*, *x*, *y*. *π*) → { *true*, *false*} 输出真或假表示验证是否成功，检查'
- en: the correctness of the output.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的正确性。
- en: There are two security properties of VDFs, uniqueness and sequentiality. Uniqueness
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: VDFs有两个安全属性，唯一性和顺序性。唯一性
- en: ensures that the output y produced by VDF is unique for every input x. The sequentiality
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 确保VDF产生的输出 y 对于每个输入 x 是唯一的。顺序性
- en: property ensures that the delay parameter t is enforced.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 属性确保延迟参数 t 被执行。
- en: '109'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '109'
- en: '![](index-129_1.png)'
  id: totrans-1421
  prefs: []
  type: TYPE_IMG
  zh: '![](index-129_1.png)'
- en: Chapter 2 Cryptography
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章密码学
- en: Figur[e 2-26 sho](#p129)ws the operation of VDFs.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-26](#p129)展示了VDF的操作。
- en: '***Figure 2-26\.** Operation of a VDF*'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '***图2-26。** VDF的操作*'
- en: There are many proposals on how to construct VDFs. Some approaches include
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 如何构建VDF有很多提案。一些方法包括
- en: hardware enclaves to store cryptographic keys inside the enclave and use those
    keys to
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部存储加密密钥并使用这些密钥
- en: generate VDFs. Using hash functions to iteratively hash the output again as
    input to form a hash chain is another way of constructing verifiable delay functions.
    Creating a hash
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 生成VDF。使用散列函数将输出再次迭代哈希作为输入以形成散列链是构建可验证延迟函数的另一种方法。创建散列
- en: chain using a hash function iteratively is a sequential process and takes time;
    thus, it can work as an evaluation function of the VDF. Another method gaining
    more popularity
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 用散列函数迭代生成区块链是一个顺序过程，需要时间；因此，它可以作为VDF的评估函数。另一种越来越受欢迎的方法
- en: is the algebraic construction, where finite cyclic groups are used which are
    assumed to
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 是代数结构，使用假定
- en: have unknown order.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 有未知的顺序。
- en: VDFs have many innovative applications in blockchains, including constructing
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: VDFs在区块链中有许多创新应用，包括构建
- en: consensus algorithms, as a source of verifiable randomness and leader election.
    You will
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法，作为可验证随机性和领导者选举的来源。您将
- en: explore these applications in detail when we discuss relevant consensus protocols
    in
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论相关的共识协议时，我们会详细探讨这些应用。
- en: Chapt[er 8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 第[8章](https://doi.org/10.1007/978-1-4842-8179-6_8)。
- en: '**Verifiable Random Functions**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '**可验证随机函数**'
- en: A verifiable random function (VRF) is a pseudorandom public key function that
    provides
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 可验证随机函数（VRF）是提供
- en: a proof that the output it has generated is correctly calculated. The owner
    of the private key generates the proof and output of the function which is verifiable
    publicly by a
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成的输出的证明是正确计算的。拥有私钥的所有者生成函数的证明和输出，可以公开验证
- en: public key to ascertain that the value is indeed correctly calculated. VRFs
    have many
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 通过公钥来确定该值是否确实是正确计算的。VRF在文献中有许多
- en: applications in consensus algorithms and blockchains, for example, Cardano and
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法和区块链，例如，卡达诺和
- en: Polkadot use them in the block production mechanism. They also have been used
    to
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: Polkadot在块生成机制中使用它们。它们还被用于
- en: provide verifiable randomness on chains, for example, in the case of chainlink.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 在链上提供可验证的随机性，例如，链链接的情况。
- en: '110'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '110'
- en: Chapter 2 Cryptography
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: '**Summary**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: • Cryptography is the science of secret communication.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: • 密码学是秘密通信的科学。
- en: • Symmetric key cryptography and asymmetric cryptography are the
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: • 对称密钥密码学和非对称密码学是
- en: two main categories of cryptography.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的两个主要类别。
- en: • Elliptic curve cryptography has found major applications in
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: • 椭圆曲线密码学在
- en: blockchains and relevant consensus protocols, where commonly
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链和相关共识协议，通常
- en: ECDSA is used for digitally signing blocks and transactions.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA用于数字签名区块和交易。
- en: • Hash functions create a fixed-length message digest of an arbitrary-
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: • 散列函数创建任意长度的消息摘要——
- en: length input.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 长度输入。
- en: • MACs are message authentication codes used for message
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: • MAC是用于消息的消息认证码
- en: authentication.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 认证。
- en: • Digital signatures provide nonrepudiation, integrity, and
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: • 数字签名提供不可否认性、完整性和
- en: authentication services.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 认证服务。
- en: • Authentication protocols are used in distributed systems to provide
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: • 认证协议用于分布式系统，提供
- en: entity authentication.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 实体认证。
- en: • Hybrid encryption schemes combine public and symmetric key
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: • 混合加密方案结合了公钥和对称密钥
- en: cryptography to achieve performance and security.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密码学实现性能和安全。
- en: • Verifiable delay functions are functions that take time to evaluate
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: • 可验证延迟函数是需要花费时间来评估的函数
- en: but are quick to verify and have many applications in consensus
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 但是验证迅速，且在共识方面有许多应用
- en: protocols and blockchains.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和区块链。
- en: • VRFs are public key–based functions which generate a verifiable
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: • VRF是基于公钥的函数，可生成可验证
- en: correct output.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的输出。
- en: '**Bibliography**'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: '1\. Paar, C. and Pelzl, J., 2009\. Understanding cryptography: a'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 帕尔，C.和佩尔兹，J.，2009。《理解密码学：一种
- en: textbook for students and practitioners. Springer Science &
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 学生和从业者的教科书。施普林格科学与
- en: Business Media.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 商业媒体。
- en: '111'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: '111'
- en: Chapter 2 Cryptography
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章 密码学
- en: 2\. Martin, K.M., 2012\. Everyday cryptography. Everyday
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 马丁，K.M.，2012。《日常密码学》。日常
- en: 'Cryptography: Fundamental Principles and Applications.'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学：基本原理和应用。
- en: 'Print publication date: 2017 Print ISBN-13: 9780198788003,'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 印刷出版日期：2017年 印刷ISBN-13：9780198788003，
- en: 'Published to Oxford Scholarship Online: July 2017, DOI:10.1093/'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 发表于牛津奖学金在线：2017年7月，DOI:10.1093/
- en: oso/9780198788003.001.0001\.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: oso/9780198788003.001.0001。
- en: '3\. Multisignatures: This scheme was introduced in 1983 by Itakura'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 多重签名：这种方案是由伊塔库拉于1983年引入的
- en: et al. in their paper A Public-key Cryptosystem Suitable for Digital
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 等人在他们的论文中提出了一种适用于数字
- en: Multisignatures, vol. 71, Nec Research & Development (1983),
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 多重签名，第71卷，Nec研究与发展（1983年），
- en: pp. 474–480\. Multisignatures are also sometimes called multiparty
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 页474—480。多重签名有时也被称为多方
- en: signatures in literature.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 签名。
- en: '4\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 巴希尔，伊，2020。《区块链技术探秘：深入解析》
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式总账，共识协议，智能合约，DApps，
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币、以太坊等。Packt出版社有限公司。
- en: '5\. Daniel J. Bernstein and Tanja Lange. SafeCurves: choosing safe'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 丹尼尔·J·伯恩斯坦和坦娅·朗格。SafeCurves：选择安全的
- en: curves for elliptic-curve cryptograph[y. https://safecurves.](https://safecurves.cr.yp.to)
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线用于椭圆曲线加密[https://safecurves.](https://safecurves.cr.yp.to)
- en: '[cr.yp.to](https://safecurves.cr.yp.to), accessed August 7, 2021\.'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: '[cr.yp.to](https://safecurves.cr.yp.to)，于2021年8月7日访问。'
- en: '6\. VDF research[: https://vdfresearch.org](https://vdfresearch.org)'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. VDF研究：[https://vdfresearch.org](https://vdfresearch.org)
- en: 7\. Boneh, D., Bonneau, J., Bünz, B., and Fisch, B., 2018, August.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 鲍内，D.，邦尼，J.，邦兹，B.，菲舍，B.，2018年8月。
- en: Verifiable delay functions. In *Annual international cryptology*
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 可验证延迟函数。在*年度国际密码学*
- en: '*conference* (pp. 757–788). Springer, Cham.'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '*会议*（页757—788）。施普林格，钦。'
- en: '112'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '112'
- en: '**CHAPTER 3**'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章**'
- en: '**Distributed Consensus**'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式一致性**'
- en: Consensus is a fundamental problem in distributed computing. This chapter will
    cover
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是分布式计算中的一个基本问题。本章将 cover
- en: the fundamentals of the consensus problem and discuss some history covering
    the
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性问题的基本原理，并讨论一些历史，涵盖了
- en: Byzantine generals problem, building blocks of consensus, and how we can solve
    this
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题，一致性的构建模块，以及我们如何解决这个
- en: problem in distributed systems.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的问题。
- en: As fault tolerance is a fundamental requirement in distributed systems, several
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容错是分布式系统中的一个基本要求，所以有几个
- en: primitives introduce fault tolerance. Fault-tolerant broadcast algorithms allow
    for the
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 原语介绍了容错。容错广播算法允许
- en: development of fault-tolerant applications. Consensus enables processes to reach
    a
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 开发容错应用。一致性使进程能够达成
- en: common decision despite failures. Both topics are well researched in academia
    and the
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在故障，也能做出共同决策。这两个主题在学术界得到了广泛的研究，并且
- en: industry.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中的问题。
- en: Before we dive into discussing consensus and agreement problems in detail, let’s
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论一致性和协议问题的细节之前，让我们
- en: cover some building blocks in continuation of link abstractions from Chapt[er
    1](https://doi.org/10.1007/978-1-4842-8179-6_1) that are closely related to consensus
    and agreement problems.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 继续从第[1章]（https://doi.org/10.1007/978-1-4842-8179-6_1）中的链接抽象开始一些构建模块，这些模块与一致性和协议问题密切相关。
- en: '**Broadcast Primitives**'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播原语**'
- en: Earlier in Chapt[er 1, w](https://doi.org/10.1007/978-1-4842-8179-6_1)e learned
    about links that pass messages between a pair of processes in a point-to-point
    or one-to-one setting. This one-to-one communication
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 早在第[1章时]（https://doi.org/10.1007/978-1-4842-8179-6_1），我们就了解到了在点对点或一对一设置中传递消息的链接。这种一对一通信
- en: (also called unicast) is quite common and used in the client-server architecture.
    For
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: （也称为单播）在客户端-服务器体系结构中非常常见和使用。对于
- en: example, a web server making requests to a backend database can be seen as an
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个向后端数据库发出请求的web服务器可以被视为一个
- en: example of this type of two-sided connection. There is one sender and one specific
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双向连接。有一个发送方和一个特定的
- en: recipient, that is, the web server and backend database, respectively.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 接收方，即web服务器和后端数据库。
- en: However, in many cases where multiple nodes are involved, the client-server
    type
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多涉及多个节点的情况下，客户-服务器类型
- en: scheme is not adequate. Moreover, in many situations, one-to-one communication
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 方案是不够的。此外，在许多情况下，一对一通信
