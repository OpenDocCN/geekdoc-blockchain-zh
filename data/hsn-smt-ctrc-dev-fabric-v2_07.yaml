- en: Chapter 4\. Smart Contract Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 智能合约开发
- en: In this chapter, you will learn about Fabric smart contract development by examining
    a simple smart contract and the Fabric APIs used to implement Fabric smart contracts.
    Once you understand the basics of coding a smart contract and the APIs, we can
    move on to [Chapter 5](ch05.xhtml#smart_contract_invocation), where we will take
    the content from this chapter and apply it to invoking smart contracts. To get
    started, we first need to download the Hyperledger Fabric development tools. They
    provide a rapid start to developing Fabric smart contracts by encapsulating a
    complete two-organization Fabric runtime with scripts to bring it up and take
    it down.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过查看一个简单的智能合约和用于实现Fabric智能合约的Fabric API来学习Fabric智能合约的开发。一旦您了解了编写智能合约和API的基础知识，我们就可以继续进行[第5章](ch05.xhtml#smart_contract_invocation)，在那里我们将从本章内容中获取内容并应用于调用智能合约。首先，为了开始，我们需要下载Hyperledger
    Fabric开发工具。它们通过封装一个完整的双组织Fabric运行时和脚本来启动和关闭，提供了一个快速开始开发Fabric智能合约的方法。
- en: We are going to use the Hyperledger–provided binaries and sample projects from
    the Fabric project. These binaries and sample projects will help us start a Fabric
    test network, and the sample projects provide several example smart contracts
    from which to learn how to develop your own. This chapter examines an example
    smart contract from a sample project called Fabcar. The binaries we use have the
    same name on all supported operating systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Hyperledger提供的二进制文件和来自Fabric项目的示例项目。这些二进制文件和示例项目将帮助我们启动一个Fabric测试网络，示例项目提供了几个示例智能合约，供我们学习如何开发自己的。本章将从一个名为Fabcar的示例项目中的示例智能合约中进行讨论。我们使用的二进制文件在所有支持的操作系统上都具有相同的名称。
- en: 'This chapter will help you achieve the following practical goals:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您实现以下实际目标：
- en: Writing a Fabric smart contract by using the JavaScript programming language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript编程语言编写Fabric智能合约
- en: Installing and instantiating a Fabric smart contract
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和实例化一个Fabric智能合约
- en: Validating and sanitizing inputs and arguments in a smart contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和清理智能合约中的输入和参数
- en: Creating and running simple or complex queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和运行简单或复杂的查询
- en: Working with a private data collection in Fabric
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fabric中使用私有数据集
- en: Installing Prerequisites and Setting Up Hyperledger Fabric
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件并设置Hyperledger Fabric
- en: Before we can develop Fabric smart contracts, we need to download and install
    the software required to download Hyperledger Fabric. To download and set up Hyperledger
    Fabric for developing Fabric smart contracts, we will execute a script that requires
    certain software to exist on the platform you are developing on—Windows, Linux,
    or Mac. We need to install Git, cURL, Node.js, npm, Docker and Docker Compose,
    and the Fabric installation script.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够开发 Fabric 智能合约之前，我们需要下载并安装下载 Hyperledger Fabric 所需的软件。要下载并设置 Hyperledger
    Fabric 以开发 Fabric 智能合约，我们将执行一个脚本，该脚本需要存在于您正在开发的平台上——Windows、Linux 或 Mac 上的某些软件。我们需要安装
    Git、cURL、Node.js、npm、Docker 和 Docker Compose，以及 Fabric 安装脚本。
- en: Git
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: 'Git is used to clone the *fabric-samples* repository from GitHub to your local
    machine. If you don’t have Git installed, you can download it from [*https://git-scm.com/downloads*](https://git-scm.com/downloads).
    Once you download and install it, verify Git installation with the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git 用于从 GitHub 克隆 *fabric-samples* 存储库到您的本地计算机。如果您尚未安装 Git，则可以从[*https://git-scm.com/downloads*](https://git-scm.com/downloads)下载。下载并安装完成后，通过以下命令验证
    Git 安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: cURL
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cURL
- en: 'We use cURL to download the Fabric binaries from the web. You can download
    cURL from [*https://curl.haxx.se/download.html*](https://curl.haxx.se/download.html).
    Once it’s downloaded and installed, verify the installation by executing the following
    command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用cURL从网络上下载Fabric二进制文件。您可以从[*https://curl.haxx.se/download.html*](https://curl.haxx.se/download.html)下载cURL。下载并安装完成后，通过执行以下命令验证安装：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Node.js and npm
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 和 npm
- en: 'We will be using JavaScript for developing our Fabric smart contracts. Fabric
    uses Node.js and npm for processing smart contracts. The supported versions of
    Node.js are 10.15.3 and higher, and 12.13.1 and higher. The supported version
    of npm is 6 and higher. Node.js includes npm in the installation. You can download
    Node.js from [*https://nodejs.org/en/download/*](https://nodejs.org/en/download/).
    You can verify the installation of Node.js and npm by executing the following
    commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JavaScript 开发我们的 Fabric 智能合约。Fabric 使用 Node.js 和 npm 处理智能合约。支持的 Node.js
    版本为 10.15.3 及更高版本，以及 12.13.1 及更高版本。支持的 npm 版本为 6 及更高版本。Node.js 在安装中包含 npm。您可以从[*https://nodejs.org/en/download/*](https://nodejs.org/en/download/)下载
    Node.js。您可以通过执行以下命令验证 Node.js 和 npm 的安装：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Docker and Docker Compose
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 和 Docker Compose
- en: 'Hyperledger Fabric consists of several components, each of which operates as
    a separate executable service, so Fabric maintains Docker images of each component.
    The images are hosted on the official Docker Hub website. At minimum, you need
    Docker version 17.06.2-ce. You can get the latest version of Docker at [*https://www.docker.com/get-started*](https://www.docker.com/get-started).
    When Docker is installed, Docker Compose is also installed. You can verify the
    Docker version by executing the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric由几个组件组成，每个组件都作为单独的可执行服务运行，因此Fabric维护了每个组件的Docker镜像。这些镜像托管在官方Docker
    Hub网站上。最低要求是Docker版本17.06.2-ce。你可以在[*https://www.docker.com/get-started*](https://www.docker.com/get-started)获取最新版本的Docker。安装Docker后，Docker
    Compose也会被安装。你可以通过执行以下命令验证Docker版本：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then verify your Docker Compose version by executing this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下命令验证你的Docker Compose版本：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before proceeding, start Docker, because Docker needs to be running to complete
    the installation of the Fabric installation script.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，启动Docker，因为Docker需要运行以完成Fabric安装脚本的安装。
- en: Fabric Installation Script
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabric安装脚本
- en: Create and change to the directory you will use to install the Fabric binaries
    and sample projects. Docker must be running because the script requires Docker
    to download the Fabric images.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并切换到你将用于安装Fabric二进制文件和样本项目的目录。脚本需要Docker运行，因为它需要Docker下载Fabric镜像。
- en: 'The script will do the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将执行以下操作：
- en: Download the Fabric binaries
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Fabric二进制文件
- en: Clone *fabric-samples* from the GitHub repo
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub仓库克隆*fabric-samples*
- en: Download the Hyperledger Fabric Docker images
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Hyperledger Fabric Docker镜像
- en: 'Here is the command to execute the script:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行脚本的命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But we are not going to execute this command yet. First, we are going to save
    the command output, so we can examine it. Make sure you are in the directory you
    have created to install the Fabric binaries and sample projects, and then execute
    the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们暂时不会执行这个命令。首先，我们要保存命令的输出，这样我们就可以检查它。确保你在你创建的目录中来安装Fabric二进制文件和样本项目，然后执行以下命令：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you can open *FabricDevInstall.sh* in your favorite editor and examine the
    script to see how it clones *fabric-samples* from GitHub, downloads the Fabric
    binaries, and downloads the Docker images. Understanding the operation of this
    script may help you later if you want to customize your Fabric development environment
    or optimize it based on your workflow.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在你喜欢的编辑器中打开*FabricDevInstall.sh*并检查脚本，看看它是如何从GitHub克隆*fabric-samples*，下载Fabric二进制文件和下载Docker镜像的。理解这个脚本的操作可能有助于你以后如果想要根据你的工作流程定制你的Fabric开发环境或者优化它。
- en: 'After you finish examining the script, open a shell and change *FabricDevInstall.sh*
    to an executable by executing the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成脚本检查后，在shell中打开*FabricDevInstall.sh*，通过执行以下命令将其更改为可执行文件：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let’s execute *FabricDevInstall.sh* with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过以下命令执行*FabricDevInstall.sh*：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the script completes execution, we should be all set. The *fabric-samples*
    directory, Docker images, and Fabric binaries are installed in the *fabric-samples/bin*
    directory. In the directory where you ran the command, there should now be a directory
    called *fabric-samples*. Everything we need is in *fabric-samples*. First, we
    will dig into the Fabcar sample smart contract, which you can find in the *fabric-samples*
    directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本执行完毕，我们应该已经准备好了。 *fabric-samples* 目录、Docker映像和Fabric二进制文件都安装在 *fabric-samples/bin*
    目录中。在您运行命令的目录中，现在应该有一个名为 *fabric-samples* 的目录。我们所需的一切都在 *fabric-samples* 中。首先，我们将深入了解Fabcar示例智能合约，您可以在
    *fabric-samples* 目录中找到它。
- en: Fundamental Requirements of a Smart Contract
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能合约的基本要求
- en: 'The Fabcar example smart contract is a valid, functional example of a basic
    smart contract. We have much more to add before it would be ready for production,
    including security, error management, reporting, monitoring, and testing. We want
    to remember several important points from this example smart contract. Let’s go
    through them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fabcar示例智能合约是一个有效的、功能完善的基本智能合约示例。在准备投入生产之前，我们还有很多工作要做，包括安全性、错误管理、报告、监控和测试。我们想从这个示例智能合约中记住几个重要点。让我们逐一看看：
- en: '`Contract` class'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contract` 类'
- en: Smart contracts extend the `Contract` class. This is a simple class with few
    functions. We will look at this class later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约扩展了 `Contract` 类。这是一个简单的类，具有很少的函数。我们将在本章后面查看这个类。
- en: Transaction context
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 交易上下文
- en: All smart contract transaction functions pass a transaction context object as
    their first argument. This transaction context object is a `Context` class. When
    we look at the `Contract` class, we will look at this class too.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有智能合约交易函数都将交易上下文对象作为它们的第一个参数传递。此交易上下文对象是一个 `Context` 类。当我们查看 `Contract` 类时，我们也会查看这个类。
- en: Constructor
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数
- en: All smart contracts must have a constructor. The constructor argument is optional
    and represents the name of the contract. If not passed, the class name will be
    used. We recommend you pass a unique name and think of this in terms of a namespace,
    like a reverse domain name structure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有智能合约都必须有一个构造函数。构造函数参数是可选的，并表示合约的名称。如果未传递，将使用类名。我们建议您传递一个唯一的名称，并将其考虑为命名空间，类似于反向域名结构。
- en: Transaction function
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 交易函数
- en: A transaction function to initialize a smart contract can be created and called
    prior to client requests. You can use this to set up and execute your smart contract
    with any required resources. These resources could be tables or maps of data used
    for lookups, translations, decoding, validating, enriching, security, and so forth.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个初始化智能合约的交易函数可以在客户端请求之前创建和调用。您可以使用此功能设置和执行您的智能合约以及任何所需的资源。这些资源可以是用于查找、翻译、解码、验证、丰富、安全等用途的数据表或地图。
- en: World state
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 世界状态
- en: We can query the world state in multiple ways. The *simple query* is a key lookup,
    and a *range query* gets a set. There is another called a *rich query*. We look
    at world state in [Chapter 5](ch05.xhtml#smart_contract_invocation).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式查询世界状态。*简单查询*是一个键查找，*范围查询*获取一个集合。还有一种称为*丰富查询*。我们在[第5章](ch05.xhtml#smart_contract_invocation)中查看世界状态。
- en: '`putState`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`putState`'
- en: To write data to the ledger, we use the `putState` function. It takes as arguments
    a `key` and `value`. The `value` is a byte array, so the ledger can store any
    data. Typically, we will store the equivalent of business objects that are marshaled
    into byte arrays prior to being passed as the `value` argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据写入分类帐，我们使用`putState`函数。它的参数是`key`和`value`。`value`是一个字节数组，因此分类帐可以存储任何数据。通常，我们将存储事务前的转换为字节数组的业务对象的等价物，然后将其作为`value`参数传递。
- en: '`ChaincodeStub`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStub`'
- en: The `ChaincodeStub` class contains several functions used to interact with the
    ledger and world state. All smart contracts get an implementation of this class
    as the `stub` object contained and exposed by the `Context` class implementation
    called `ctx`, which all transaction functions receive as their first argument.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStub`类包含用于与分类帐和世界状态交互的几个函数。所有智能合约都会得到该类的一个实现，作为包含和公开由称为`ctx`的`Context`类实现所包含的`stub`对象，所有事务函数都将其作为第一个参数接收。'
- en: Read/write transactions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 读/写事务
- en: 'An update in a smart contract is executed in three steps: a read transaction,
    an update to the in-memory data returned from the read transaction, followed by
    a write transaction. This creates a new world state for the key while maintaining
    the history of the key in the immutable file-based ledger.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约中的更新分为三个步骤执行：读取事务、对从读取事务返回的内存数据进行更新，然后进行写入事务。这为密钥创建了一个新的世界状态，同时保持了密钥在不可变的基于文件的分类帐中的历史。
- en: 'This point is important to remember: *you cannot update (or write to) the ledger
    and read back what you wrote in the same transaction*. It does not matter how
    many other transaction functions you call from a transaction function. You need
    to think about the data flow of a transaction request. Clients submit transaction
    requests to peers, which endorse the request transaction (this is where the smart
    contract executes), the endorsements with read and write sets are sent back to
    clients; endorsed requests are sent to an orderer, which orders the transactions
    and creates blocks. The orderer sends the ordered requests to commit peers, which
    validate the read and write sets prior to committing the writes to the ledger
    and updating the world state.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要记住：*你不能在同一个事务中更新（或写入）分类帐并读取你在同一事务中写入的内容*。不管你从事务函数中调用多少其他事务函数，都需要考虑事务请求的数据流。客户端向对等方提交事务请求，对等方支持请求事务（这是智能合约执行的地方），具有读取和写入集的认可发送回客户端；经认可的请求发送到排序器，排序器对事务进行排序并创建区块。排序器将排序后的请求发送给提交对等方，在将写入提交到分类帐并更新世界状态之前验证读取和写入集。
- en: In the simplest form, a smart contract is a wrapper around `ChaincodeStub`,
    because smart contracts must use the interface exposed through this class to interact
    with the ledger and world state. This is an important point to remember. You should
    consider implementing business logic in a modular design, treating your `Contract`
    subclass like a datasource. This will facilitate evolving your code over time
    and partitioning logic into functional components that can be shared and reused.
    In [Chapter 5](ch05.xhtml#smart_contract_invocation), we look into design in the
    context of packaging and deploying, and in [Chapter 6](ch06.xhtml#testing_and_maintenance),
    we delve into modular design and implementation to facilitate maintenance and
    testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，智能合约是围绕着`ChaincodeStub`的封装，因为智能合约必须使用通过这个类暴露的接口与账本和世界状态进行交互。这是一个重要的要点需要记住。你应该考虑以模块化的设计来实现业务逻辑，将你的`Contract`子类视为数据源。这样做有助于随着时间的推移演进代码并将逻辑分区成可以共享和重用的功能组件。在[第5章](ch05.xhtml#smart_contract_invocation)中，我们将在打包和部署的上下文中探讨设计，在[第6章](ch06.xhtml#testing_and_maintenance)中，我们深入探讨模块化设计和实现以促进维护和测试。
- en: Multiple peers, the endorsing peers, will be executing your smart contracts.
    Today the architecture places the smart contracts behind a gateway, which is middleware
    in the smart contract SDK. The gateway receives smart contract requests, processes
    them, and dispatches them to one or more peers. The peers instantiate the chaincode
    for execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 多个对等节点，即背书对等节点，将执行您的智能合约。今天的架构将智能合约放置在一个网关后面，该网关是智能合约SDK中的中间件。网关接收智能合约请求，处理它们，并将它们发送到一个或多个对等节点。对等节点实例化链码以执行。
- en: SDK
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDK
- en: Fabric provides an SDK implemented in Go, Java, and Node.js (JavaScript) for
    developing smart contracts. We are interested in the Hyperledger Fabric smart
    contract development SDK for Node.js, which is called *fabric-chaincode-node*.
    While you do not need to download it for smart contract development, you can download
    or clone *fabric-chaincode-node* from [GitHub](https://github.com/hyperledger/fabric-chaincode-node).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric提供了用于开发智能合约的Go、Java和Node.js（JavaScript）实现的SDK。我们对Node.js的Hyperledger Fabric智能合约开发SDK感兴趣，它被称为*fabric-chaincode-node*。虽然你在智能合约开发中不需要下载它，但你可以从[GitHub](https://github.com/hyperledger/fabric-chaincode-node)下载或克隆*fabric-chaincode-node*。
- en: The *fabric-chaincode-node* SDK has a lot going on. We are interested in a few
    components that are central to developing smart contracts. The remaining files
    are low-level interfaces, support artifacts, tools, and more required to implement
    the `Contract` interface with Node.js. This SDK helps developers like us by providing
    a high-level API so we can learn fast and focus on our smart contract business
    logic and design.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*fabric-chaincode-node* SDK有很多功能。我们对一些对于开发智能合约至关重要的组件感兴趣。其余的文件是低级接口、支持工件、工具等，是用于使用Node.js实现`Contract`接口所需的更多内容。这个SDK通过提供高级API来帮助像我们这样的开发者，这样我们就可以快速学习并专注于我们的智能合约业务逻辑和设计。'
- en: The first API we are interested in is *fabric-contract-api*. It is located under
    the *apis* subdirectory of *fabric-chaincode-node*. The other API you see, *fabric-shim-api*,
    is the type definition and pure interface for the *fabric-shim* library, which
    we look at later in this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的第一个 API 是 *fabric-contract-api*。它位于 *fabric-chaincode-node* 的 *apis* 子目录下。另一个
    API *fabric-shim-api* 是 *fabric-shim* 库的类型定义和纯接口，我们稍后在本章中会看到。
- en: 'When we start our smart contract project and execute `npm install`, which we
    will do in [Chapter 5](ch05.xhtml#smart_contract_invocation), npm will download
    *fabric-contract-api* as a module from the npm public repository as well as *fabric-shim*.
    This download happens because we have two explicit smart contract dependencies
    for developing Hyperledger Fabric smart contracts. These are displayed in this
    excerpt from the *package.json* file of the Fabcar smart contract:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动智能合约项目并执行 `npm install` 时，npm 会从 npm 公共存储库中下载 *fabric-contract-api* 作为模块，以及
    *fabric-shim*。这种下载发生是因为我们有两个明确的智能合约依赖项用于开发 Hyperledger Fabric 智能合约。这些显示在 Fabcar
    智能合约的 *package.json* 文件中的摘录中：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *fabric-contract-api* and *fabric-shim* are the only modules we need to
    develop our smart contracts. The *fabric-contract-api* contains the *contract.js*
    and *context.js* files, which implement the `Contract` and `Context` classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*fabric-contract-api* 和 *fabric-shim* 是我们开发智能合约所需的唯一模块。*fabric-contract-api*
    包含实现 `Contract` 和 `Context` 类的 *contract.js* 和 *context.js* 文件。'
- en: Contract class
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合约类
- en: '`Contract` is a simple class. Beyond the constructor are utility functions
    that you can override to implement logic before and after transactions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contract` 是一个简单的类。除构造函数外，还有一些实用函数，您可以重写这些函数以在事务之前和之后实现逻辑：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `beforeTransaction` function is called before any contract transaction
    functions are invoked. You can override this method to implement your own custom
    logic:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用任何合约事务函数之前都会调用 `beforeTransaction` 函数。您可以重写此方法以实现自己的定制逻辑：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `afterTransaction` function is called after any contract transaction functions
    are invoked. You can override this method to implement your own custom logic:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用任何合约事务函数之后都会调用 `afterTransaction` 函数。您可以重写此方法以实现自己的定制逻辑：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `getName` function is a getter that returns the contract name:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`getName` 函数是一个 getter，返回合约名称：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the `createContext` function creates a custom transaction context:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContext` 函数创建一个自定义事务上下文：'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Transaction context
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务上下文
- en: 'You can create a custom transaction context to store your own objects that
    your functions can access through the `ctx` object, which all transaction functions
    receive as their first argument. Here is an example of creating a custom context:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个自定义事务上下文来存储您自己的对象，这些对象可以通过所有事务函数的第一个参数 `ctx` 对象来访问。这里是创建自定义上下文的一个示例：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the custom context `MyContext`, transactions can access *assetList* as
    *ctx.assetList*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义上下文 `MyContext`，事务可以通过 *ctx.assetList* 访问 *assetList*。
- en: As you can see, creating a simple, smart contract is easy. You import `Contract`
    from *fabric-contract-api* and extend it. Then create a no-argument constructor
    and export our contract. That’s it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，创建一个简单而智能的合约很容易。你需要从*fabric-contract-api*中导入`Contract`并对其进行扩展。然后创建一个无参数的构造函数并导出我们的合约。就是这样。
- en: Context class
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文类
- en: 'OK, that’s the `Contract` class, but what about the `Context` class? You just
    learned how to create a custom transaction context, but what does the `Context`
    class contain? As you have learned, every transaction function gets a `Context`
    object called `ctx` as its first argument. This is the transaction context. It
    contains two important objects: `stub` and `clientIdentity`. The `stub` is a `ChaincodeStub`
    class implementation, and `clientIdentity` is a `ClientIdentity` class implementation.
    We discuss these classes next.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是 `Contract` 类，但 `Context` 类呢？你刚学会了如何创建自定义事务上下文，但 `Context` 类包含了什么？正如你所学的，每个事务函数都会获得一个名为
    `ctx` 的 `Context` 对象作为其第一个参数。这就是事务上下文。它包含两个重要对象：`stub` 和 `clientIdentity`。`stub`
    是 `ChaincodeStub` 类的实现，而 `clientIdentity` 是 `ClientIdentity` 类的实现。我们接下来会讨论这些类。
- en: '`ChaincodeStub` has all the functions we need to interact with the ledger and
    world state. It is our API for the ledger and world state. It is contained in
    the *fabric-shim* module under the *lib* directory and implemented in the *stub.js*
    file. The two primary functions are `getState` and `putState`. Several additional
    functions are available. Most can be grouped into the following categories:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStub` 拥有我们与分类账和世界状态交互所需的所有函数。它是我们与分类账和世界状态交互的 API。它包含在 *lib* 目录下的
    *fabric-shim* 模块中，并在 *stub.js* 文件中实现。其两个主要函数是 `getState` 和 `putState`。还提供了几个其他函数。大多数可以分为以下几类：'
- en: State related
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与状态相关
- en: Query related
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询相关
- en: Transaction related
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务相关
- en: Private data related
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与私有数据相关
- en: These four groups represent most of the functions. The *state-related functions*
    are used to read from and write to the ledger. They use or involve the use of
    a key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个组代表了大部分功能。*与状态相关的函数*用于从分类账中读取和写入数据。它们使用或涉及使用密钥。
- en: The *query-related functions* are two rich query functions, one with pagination.
    *Rich queries* are string queries native to the database. To use rich queries,
    you need to use CouchDB for the database. We will do this in [Chapter 5](ch05.xhtml#smart_contract_invocation),
    where you’ll learn about invoking smart contracts. Another unique query function
    is `getHistoryForKey`, which takes a key and returns the history for it. This
    can be used to audit changes and find transactions that failed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询相关的函数*有两个丰富的查询函数，其中一个包含分页功能。*丰富查询*是数据库原生的字符串查询。要使用丰富查询，您需要在数据库中使用 CouchDB。我们将在[第五章](ch05.xhtml#smart_contract_invocation)中进行这样的操作，届时您将学习如何调用智能合约。另一个独特的查询函数是
    `getHistoryForKey`，它接受一个键并返回其历史记录。这可用于审计更改并找到失败的交易。'
- en: 'Hyperledger has five *transaction-related functions*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger 有五个*与事务相关的函数*：
- en: '`getTxID(): *string*;`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTxID(): *string*;`'
- en: '`getChannelID(): *string*;`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getChannelID(): *string*;`'
- en: '`getCreator(): SerializedIdentity;`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCreator(): SerializedIdentity;`'
- en: '`getMspID(): *string*;`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMspID(): *string*;`'
- en: '`getTransient(): Map<*string*, *Uint8Array*>;`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTransient(): Map<*string*, *Uint8Array*>;`'
- en: Use `getTxID` to retrieve the transaction ID, `getChannelID` for the channel’s
    ID, `getCreator` for the client, `getMspID` for the organization the client belongs
    to, and `getTransient` for private data. We will execute each of these in the
    next two chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `getTxID` 来检索交易 ID，`getChannelID` 来获取通道 ID，`getCreator` 来获取客户端，`getMspID`
    来获取客户端所属的组织，以及 `getTransient` 来获取私有数据。在接下来的两个章节中，我们将执行每一个。
- en: 'Hyperledger has nine *private data–related functions*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger 有九个 *私有数据相关的函数*：
- en: '`getPrivateData(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateData(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
- en: '`getPrivateDataHash(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateDataHash(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
- en: '`putPrivateData(collection: *string*, key: *string*, value: *Uint8Array*):
    Promise<void>;`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putPrivateData(collection: *string*, key: *string*, value: *Uint8Array*):
    Promise<void>;`'
- en: '`deletePrivateData(collection: string, key: string): Promise<void>;`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deletePrivateData(collection: string, key: string): Promise<void>;`'
- en: '`setPrivateDataValidationParameter(collection: *string*, key: *string*, ep:
    *Uint8Array*): Promise<void>;`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPrivateDataValidationParameter(collection: *string*, key: *string*, ep:
    *Uint8Array*): Promise<void>;`'
- en: '`getPrivateDataValidationParameter(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateDataValidationParameter(collection: *string*, key: *string*): Promise<*Uint8Array*>;`'
- en: '`getPrivateDataByRange(collection: *string*, startKey: *string*, endKey: *string*):
    Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateDataByRange(collection: *string*, startKey: *string*, endKey: *string*):
    Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
- en: '`getPrivateDataByPartialCompositeKey(collection: *string*, objectType: *string*,
    attributes: *string[]*): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateDataByPartialCompositeKey(collection: *string*, objectType: *string*,
    attributes: *string[]*): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
- en: '`getPrivateDataQueryResult(collection: *string*, query: *string*): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>;`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrivateDataQueryResult(collection: *string*, query: *string*): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>;`'
- en: These nine private data functions provide the ability to read and write to a
    private data collection, get a private data hash, delete from private data, set
    and get an endorsement policy for private data validation, get private data by
    range or partial composite key, and, finally, by rich query. We will execute some
    of these in [Chapter 5](ch05.xhtml#smart_contract_invocation) and [Chapter 6](ch06.xhtml#testing_and_maintenance)
    when we employ the use of private data with our smart contract transactions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这九个私有数据函数提供了读取和写入私有数据集合的能力，获取私有数据哈希，从私有数据中删除，设置和获取私有数据验证的背书策略，通过范围或部分复合键获取私有数据，以及通过丰富的查询。当我们在智能合约交易中使用私有数据时，我们将在[第五章](ch05.xhtml#smart_contract_invocation)和[第六章](ch06.xhtml#testing_and_maintenance)执行其中一些。
- en: Now that you have a good idea of what sort of functionality is available through
    the `stub` object we get from the `ctx` object, let’s look at `ClientIdentity`,
    the other object in the transaction context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经对我们从`ctx`对象中获取的`stub`对象可以提供什么样的功能有了一个很好的了解，让我们看一看事务上下文中的另一个对象`ClientIdentity`。
- en: 'The `clientIdentity` object contained in the transaction context as `ctx.clientIdentity`
    is the implementation of the `ClientIdentity` class, which is a small class with
    only five functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事务上下文中包含的`clientIdentity`对象，即`ctx.clientIdentity`，是`ClientIdentity`类的实现，它是一个仅具有五个函数的小类：
- en: '`assertAttributeValue(attrName: *string*, attrValue: *string*): boolean;`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAttributeValue(attrName: *string*, attrValue: *string*): boolean;`'
- en: '`getAttributeValue(attrName: *string*): string | null;`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAttributeValue(attrName: *string*): string | null;`'
- en: '`getID(): *string*;`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getID(): *string*;`'
- en: '`getIDBytes(): *Uint8Array*;`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIDBytes(): *Uint8Array*;`'
- en: '`getMSPID(): *string*;`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMSPID(): *string*;`'
- en: The `assertAttributeValue` and `getAttributeValue` functions operate on the
    client certificate. Using these functions, granular security can be implemented
    by employing the certificate attribute values. The `getID` and `getIDBytes` functions
    retrieve the client’s identity, and `getMSPID` is used to get the organization
    the client belongs to. Using these functions, you can implement a wide range of
    authentication and authorization design patterns.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertAttributeValue`和`getAttributeValue`函数作用于客户端证书。使用这些函数，可以通过使用证书属性值实现细粒度安全。`getID`和`getIDBytes`函数检索客户端的身份，`getMSPID`用于获取客户端所属的组织。使用这些函数，您可以实现各种身份验证和授权设计模式。'
- en: Transaction functions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务函数
- en: '*Transaction functions* are the smart contract functions that clients call.
    These are the business functions you design and implement in your smart contracts.
    Here is an example of three transaction functions from the Fabcar smart contract.
    We will define them in [“Defining a Smart Contract”](#defining_a_smart_contract):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*事务函数*是客户端调用的智能合约函数。这些是您在智能合约中设计和实现的业务函数。以下是来自Fabcar智能合约的三个事务函数的示例。我们将在[“定义智能合约”](#defining_a_smart_contract)中定义它们：'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All transaction functions receive as the first argument the transaction context,
    the `ctx` object. Transaction functions use this object to reference the `stub`
    and `clientIdentity` objects—for example, `ctx.stub` and `ctx.clientIdentity`.
    The `stub` is an instance of `ChaincodeStub`. The `clientIdentity` is an implementation
    of `ClientIdentity` and exposes functions for getting the transaction ID, client
    ID, any client attributes, and the organization ID. These functions can be used
    for application- and transaction-specific authentication and authorization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事务函数都将事务上下文`ctx`对象作为第一个参数。事务函数使用此对象来引用`stub`和`clientIdentity`对象，例如`ctx.stub`和`ctx.clientIdentity`。`stub`是`ChaincodeStub`的一个实例。`clientIdentity`是`ClientIdentity`的实现，并公开用于获取事务ID、客户端ID、任何客户端属性和组织ID的函数。这些函数可用于应用程序和事务特定的身份验证和授权。
- en: It is common for most transaction functions to contain a call to the ledger
    or world state. The `stub` provides the functions for reading from the world state
    and writing to the ledger, which updates the world state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数交易函数包含对总账或世界状态的调用是很常见的。`stub`提供了从世界状态读取和写入总账的函数，从而更新世界状态。
- en: The way you design your transaction functions is completely under your control.
    You can group them, mix them, create libraries, and more. Remember, for transactions
    that write, all of the designated endorsing peers must execute your smart contracts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您设计交易函数的方式完全由您控制。您可以将它们分组、混合、创建库等等。请记住，对于写入的交易，所有指定的背书节点都必须执行您的智能合约。
- en: Endorsement policies determine whether a transaction gets committed. For example,
    an endorsement policy might state that three out of four peers must endorse the
    transaction. If, for some reason, fewer than three peers can endorse the transaction,
    then the transaction will not get committed, meaning the data will not be available
    on the ledger.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 背书策略决定了交易是否被提交。例如，一个背书策略可能规定四个节点中有三个节点必须对交易进行背书。如果由于某种原因，少于三个节点可以对交易进行背书，那么交易将不会被提交，这意味着数据将不会在总账上可用。
- en: A point to remember is that even though a write transaction may fail, it will
    be flagged as invalid and written to the ledger. An invalid transaction will not
    be part of the world state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，即使写入事务可能失败，它也将被标记为无效并写入总账。无效的交易不会成为世界状态的一部分。
- en: As a best practice, Fabric smart contracts demand deterministic code. Many peers
    need to execute the code, and they all need to arrive at the same result. Therefore,
    the inputs must always return the same result. It must not matter what peer executes
    the code. Given the same inputs, the peer should return the same results. This
    should happen no matter the number of times the code is executed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，Fabric 智能合约要求确定性代码。许多节点需要执行代码，并且它们都需要得出相同的结果。因此，输入必须始终返回相同的结果。无论哪个节点执行代码，都不应该有关系。给定相同的输入，节点应该返回相同的结果。无论代码执行多少次，这都应该发生。
- en: 'The code should have a beginning and an end. It should never depend on dynamic
    data or long random executions. The code should be fast and efficient, with clear
    logic flows that are not circular. For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该有一个开始和一个结束。它永远不应该依赖于动态数据或长时间的随机执行。代码应该快速有效，具有清晰的逻辑流程，而不是循环的。例如：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When creating an asset, we will expect the asset ID, amount, and owner as inputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资产时，我们将期望资产 ID、数量和所有者作为输入。
- en: Validate and sanitize arguments
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证和清理参数
- en: Transactions must validate and sanitize their arguments. This is not unique
    to smart contracts. It is a wise default practice if you want to ensure the integrity
    and availability of your smart contract.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 交易必须验证和清理其参数。这不是智能合约独有的。如果您想确保智能合约的完整性和可用性，这是一个明智的默认做法。
- en: 'Employ known techniques for validating your arguments and preventing any data
    that may harm your smart contract. You also want to sanitize your arguments and
    ensure the quality of the data you expect. You want to limit unnecessary processing
    of data that will later in your logic cause a failure or edge case not covered.
    Here is an example that checks whether the function is `Process`; if it is not,
    we will throw an exception:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已知的技术验证您的参数并防止可能损害智能合约的任何数据。您还希望清理您的参数并确保您期望的数据的质量。您希望限制不必要的数据处理，在您的逻辑中稍后可能会导致失败或未涵盖的边缘情况。以下是一个检查函数是否为
    `Process` 的示例；如果不是，则会引发异常：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Simple state interaction (Get, Put, Delete)
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的状态交互（获取、放置、删除）
- en: 'Fabric smart contracts at the core are state machines that evolve over time,
    keeping an immutable history of all prior states. The three primary `stub` functions
    you will use are the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 智能合约在核心上是随着时间演变的状态机，保留了所有先前状态的不可变历史记录。您将使用的三个主要 `stub` 函数如下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `stub` functions provide your smart contracts the functionality to read
    from the world state, write to the ledger, and delete from the world state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`stub` 函数提供了智能合约读取世界状态、写入账本和从世界状态删除的功能。'
- en: The ledger and world state are key-value data stores. This keeps it simple and
    easy but allows rich data to be stored on the ledger, queried, and viewed by the
    world state, a document, or NoSQL database. Currently, LevelDB and CouchDB are
    supported. LevelDB is a simple key-value data store, while CouchDB is a rich and
    robust NoSQL document database. This means you can read and write simple to complex
    JSON data structures to the ledger and query the world state database for rich
    data. Several functions are available for queries.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 账本和世界状态是键值数据存储。这使得它简单易用，但允许在账本上存储丰富的数据，并由世界状态、文档或 NoSQL 数据库查询和查看。目前支持 LevelDB
    和 CouchDB。LevelDB 是一个简单的键值数据存储，而 CouchDB 是一个丰富且强大的 NoSQL 文档数据库。这意味着您可以将简单到复杂的
    JSON 数据结构写入账本并查询世界状态数据库以获取丰富的数据。有几个函数可用于查询。
- en: Create and Execute Queries
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和执行查询
- en: Smart contracts often need to look up or query data from the world state while
    processing a transaction. Remember the update to our Fabcar sample smart contract?
    To perform an update, a smart contract typically must find and load the existing
    object to update. Then it updates the in-memory data and writes the updated data
    to the ledger—remember `putState` to write and `getState` to read.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理交易时，智能合约通常需要查找或查询世界状态中的数据。还记得我们的 Fabcar 示例智能合约的更新吗？要执行更新，智能合约通常必须找到并加载要更新的现有对象。然后它会更新内存中的数据并将更新后的数据写入账本——记住使用
    `putState` 写入和 `getState` 读取。
- en: Unlike a relational database in which we can update a field without selecting
    the row first, with Fabric smart contracts, we must load the value of a key and
    update the value. That may be a single field in a very large and complex JSON
    data structure, or it may be a simple object with one field, the field we are
    updating. Why is this? Because all data is tied to a unique key. If a key’s associated
    value is an object with four fields, we think of each field as a value—but to
    the ledger, it is all just one value object identified by a single unique key.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库不同，我们可以在不先选择行的情况下更新字段，但是在 Fabric 智能合约中，我们必须加载键的值并更新该值。 这可能是非常大且复杂的 JSON
    数据结构中的一个字段，也可能是一个带有一个字段的简单对象，该字段是我们正在更新的字段。 为什么这样？ 因为所有数据都与唯一键绑定。 如果键的关联值是一个具有四个字段的对象，我们将每个字段视为一个值，但对于分类帐来说，它们仅是一个由单个唯一键标识的值对象。
- en: 'Here are the available `stub` functions you can use for finding data:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可以用来查找数据的可用`stub`函数：
- en: '`getState(key: *string*): Promise<*Uint8Array*>;`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState(key: *string*): Promise<*Uint8Array*>;`'
- en: '`getStateByRange(startKey: *string*, endKey: *string*): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>;`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStateByRange(startKey: *string*, endKey: *string*): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>;`'
- en: '`getStateByRangeWithPagination(startKey: *string*, endKey: *string*, pageSize:
    *number*, bookmark?: *string*): Promise<StateQueryResponse<Iterators.StateQueryIterator>>
    & AsyncIterable<Iterators.KV>;`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStateByRangeWithPagination(startKey: *string*, endKey: *string*, pageSize:
    *number*, bookmark?: *string*): Promise<StateQueryResponse<Iterators.StateQueryIterator>>
    & AsyncIterable<Iterators.KV>;`'
- en: '`getQueryResult(query: *string*): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueryResult(query: *string*): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>;`'
- en: '`getQueryResultWithPagination(query: *string*, pageSize: *number*, bookmark?:
    *string*): Promise<StateQueryResponse<Iterators.StateQueryIterator>> & AsyncIterable<Iterators.KV>;`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueryResultWithPagination(query: *string*, pageSize: *number*, bookmark?:
    *string*): Promise<StateQueryResponse<Iterators.StateQueryIterator>> & AsyncIterable<Iterators.KV>;`'
- en: '`getHistoryForKey(key: *string*): Promise<Iterators.HistoryQueryIterator> &
    AsyncIterable<Iterators.KeyModification>;`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHistoryForKey(key: *string*): Promise<Iterators.HistoryQueryIterator> &
    AsyncIterable<Iterators.KeyModification>;`'
- en: We discuss these in [Chapter 5](ch05.xhtml#smart_contract_invocation),when we
    use them in a smart contract and invoke them from a client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在智能合约中使用它们并从客户端调用它们时，我们会在[第五章](ch05.xhtml#smart_contract_invocation)讨论这些内容。
- en: Defining a Smart Contract
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义智能合约
- en: 'Let’s start with the simple Fabcar smart contract. In the *fabric-samples*
    directory, locate the *chaincode* directory. In the *chaincode* directory, locate
    the *fabcar* directory. In the *fabcar* directory, locate the *javascript* directory.
    Change to this directory in your shell and execute the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的 Fabcar 智能合约开始。在 *fabric-samples* 目录中，找到 *chaincode* 目录。在 *chaincode*
    目录中，找到 *fabcar* 目录。在 *fabcar* 目录中，找到 *javascript* 目录。在你的 shell 中切换到此目录并执行以下命令：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will create the *node_modules* directory and install the dependent modules
    defined in *package.json*. We did this because we depend on the *fabric-contract-api*
    and *fabric-shim* modules. These are the two modules we use when developing Fabric
    smart contracts in JavaScript. We will look at these after we examine the Fabcar
    smart contract.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 *node_modules* 目录，并安装 *package.json* 中定义的依赖模块。我们这样做是因为我们依赖于 *fabric-contract-api*
    和 *fabric-shim* 模块。这两个模块是我们在 JavaScript 中开发 Fabric 智能合约时使用的。我们将在检查 Fabcar 智能合约后查看这些内容。
- en: Now let’s examine the Fabcar smart contract. This simple smart contract is a
    great example for learning Fabric smart contract development because it contains
    necessary details to form a foundation from which we can move on to more advanced
    smart contracts. It is located in the *lib* directory in the current directory,
    which should be the *fabric-samples/chaincode/fabcar/javascript* directory. Open
    *fabcar.js* in your favorite editor; [Example 4-1](#example_four_onedot_fabcardotjs)
    shows the source code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来查看 Fabcar 智能合约。这个简单的智能合约是学习 Fabric 智能合约开发的一个很好的例子，因为它包含了形成更高级智能合约基础的必要细节。它位于当前目录中的
    *lib* 目录中，应该是 *fabric-samples/chaincode/fabcar/javascript* 目录。在您喜欢的编辑器中打开 *fabcar.js*；[示例 4-1](#example_four_onedot_fabcardotjs)
    显示了源代码。
- en: Example 4-1\. fabcar.js
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. fabcar.js
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (1) We start by importing the *fabric-contract-api* module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 我们首先导入 *fabric-contract-api* 模块。
- en: (2) All Fabric smart contracts extend the `Contract` class. We get the `Contract`
    class from the *fabric-contract-api* module we imported in line 1.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (2) 所有 Fabric 智能合约都扩展自 `Contract` 类。我们从第 1行导入的 *fabric-contract-api* 模块中获取 `Contract`
    类。
- en: (3) Smart contracts can use transactions to initialize them prior to processing
    client application requests. This line is the beginning of the function that initializes
    the smart contract. All smart contract functions receive a transaction context
    object as an argument, called by convention `ctx`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (3) 智能合约可以使用交易在处理客户端应用程序请求之前对其进行初始化。这行是初始化智能合约的函数的开头。所有智能合约函数按照约定都接收一个称为 `ctx`
    的交易上下文对象作为参数。
- en: (4) In this example, the `initLedger` function is creating an array of objects
    called `cars`. Each array object contains key-value pairs. You can think of the
    array of objects as records of assets, and the object key-value pairs as the fields.
    This function effectively preloads an array of `car` objects for exercising the
    transaction functions in the smart contract.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (4) 在这个例子中，`initLedger` 函数正在创建一个名为 `cars` 的对象数组。每个数组对象包含键值对。您可以将对象数组视为资产的记录，将对象键值对视为字段。此函数有效地预加载了一个包含
    `car` 对象的数组，以便在智能合约中执行交易函数。
- en: (5) Next, the `initLedger` function is iterating through the array of `car`
    asset objects and adding a field called `docType` to each object, and assigning
    the string value `car` to each object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (5) 接下来，`initLedger` 函数正在遍历 `car` 资产对象的数组，并向每个对象添加一个名为 `docType` 的字段，并为每个对象赋予字符串值
    `car`。
- en: (6) This line is the first use of the `ctx` object (`Context` class) passed
    as the first function argument to all `Contract` class transaction functions.
    The `ctx` object contains the `stub` object, which is a `ChaincodeStub` class.
    The `ChaincodeStub` class implements an API to access the ledger. This line calls
    the `putState` function, which writes the key and value to the ledger and world
    state.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: （6）这一行是第一次使用传递给所有`Contract`类事务函数的第一个函数参数 `ctx` 对象（`Context` 类）。`ctx` 对象包含 `stub`
    对象，它是 `ChaincodeStub` 类。`ChaincodeStub` 类实现了一个API来访问账本。这一行调用了 `putState` 函数，将键和值写入账本和世界状态。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Hyperledger Fabric implements the blockchain ledger in two components: a file-based
    component and a database component. The *file-based component* is the low-level
    immutable data structure implementing the ledger, and the *database component*
    exposes the current state of the file-based ledger. The database component is
    called the *world state* because it represents the current state of the ledger.
    The file-based component maintains the perpetual immutable ledger. The *fabric-contact-api*
    accesses the world state. Lower-level APIs access the file-based ledger.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 实现了两个组件的区块链账本：一个基于文件的组件和一个数据库组件。*基于文件的组件*是实现账本的底层不可变数据结构，*数据库组件*则暴露了基于文件的账本的当前状态。数据库组件被称为*世界状态*，因为它代表了账本的当前状态。基于文件的组件维护着永久不变的账本。*fabric-contact-api*
    访问世界状态。更低级别的 API 访问基于文件的账本。
- en: (7) The first transaction function comes next. As stated earlier, the first
    argument of all smart contract transaction functions is the `ctx` object, which
    represents the transaction context and is a `Context` class. Any other arguments
    are optional.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: （7）接下来是第一个事务函数。如前所述，所有智能合约事务函数的第一个参数是表示事务上下文的 `ctx` 对象，它是一个 `Context` 类。任何其他参数都是可选的。
- en: (8) The `queryCars` function is a read transaction. Using the `ctx` object,
    it calls the `stub`’s `getState` function, which will read from the world state—the
    database. The `stub` is an implementation of the `ChaincodeStub` class, which
    we will cover later. For this function, the argument called `carNumber` is the
    `key` passed to the `getState` function, which will search the world state database
    for the `key` and return the associated value stored for it. The remainder of
    the function checks whether data was returned and, if so, converts the byte array
    returned into a string and returns the string that represents the value of the
    key stored in the world state. Remember, the world state is a representation of
    the perpetual immutable file-based ledger’s current state for any key-value pair
    stored in the ledger. While the database may be mutable, the file-based ledger
    is not. So even when a key-value pair is deleted from the database or world state,
    the key-value pair is still in the file-based ledger where all history is maintained
    in the perpetual immutable ledger.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (8) `queryCars` 函数是一个读事务。使用 `ctx` 对象，它调用 `stub` 的 `getState` 函数，该函数将从世界状态——即数据库中读取数据。`stub`
    是 `ChaincodeStub` 类的实现，我们稍后会介绍。对于这个函数，被称为 `carNumber` 的参数是传递给 `getState` 函数的 `key`，该函数将在世界状态数据库中搜索
    `key` 并返回与其关联的值。函数的其余部分检查是否返回了数据，如果是，则将返回的字节数组转换为字符串，并返回表示存储在世界状态中的键值的字符串。请记住，世界状态是永久不变的基于文件的分类帐的当前状态的表示，用于存储在分类帐中的任何键值对。虽然数据库可能是可变的，但基于文件的分类帐不是。因此，即使从数据库或世界状态中删除了键值对，该键值对仍然存在于基于文件的分类帐中，其中所有历史记录都在永久不变的分类帐中维护。
- en: (9) Then we have the second transaction function. It passes the values required
    to create a new `car` record object, which we will add to the ledger.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (9) 接下来是第二个事务函数。它传递了创建新的 `car` 记录对象所需的值，我们将将其添加到分类帐中。
- en: (10) With the `car` record object built from the function arguments, we call
    the `ChaincodeStub` API function implemented by `stub`, called `putState`, which
    will write the `key` and `value` to the ledger and update the current world state.
    The first two arguments that pass to the `putState` function are a key and a value,
    respectively. We need to change the `value`, the `car` record object, into a byte
    array, which `ChaincodeStub` APIs require.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (10) 使用从函数参数构建的 `car` 记录对象，我们调用由 `stub` 实现的 `ChaincodeStub` API 函数，称为 `putState`，它将
    `key` 和 `value` 写入分类帐并更新当前的世界状态。传递给 `putState` 函数的前两个参数分别是键和值。我们需要将 `value`——即
    `car` 记录对象转换为字节数组，这是 `ChaincodeStub` API 所要求的。
- en: '(11) The next transaction function, called `queryAllCars`, is a read transaction
    and demonstrates a range query. A range query, like all queries, is executed by
    the peer that receives the request. A range query takes two arguments: the beginning
    key and the ending key. These two keys represent the beginning and end of the
    range. All keys that fall into the range are returned along with their associated
    values. You can pass an empty string for both keys to retrieve all keys and values.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (11) 下一个交易函数名为`queryAllCars`，是一个读取交易，并演示了一个范围查询。与所有查询一样，范围查询由接收到请求的对等方执行。范围查询需要两个参数：起始键和结束键。这两个键代表范围的起始和结束。所有落入范围内的键以及它们的关联值都会返回。你可以为两个键都传递空字符串以检索所有键和值。
- en: (12) A `for` loop is executed, which stores all the keys and associated values
    returned from the `ChaincodeStub` API function `getStateByRange`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (12) 执行一个`for`循环，该循环将从`ChaincodeStub` API函数`getStateByRange`返回的所有键和关联值存储起来。
- en: '(13) The last transaction function, `changeCarOwner`, combines both read and
    write tasks to change the world state. The business logic here is a transfer of
    ownership. In addition to the `ctx` argument, two arguments are passed: a `key`
    called `carNumber`, and a `value` object called `newOwner`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (13) 最后一个交易函数`changeCarOwner`结合了读取和写入任务来更改世界状态。这里的业务逻辑是所有权的转移。除了`ctx`参数之外，还传递了两个参数：一个名为`carNumber`的`key`和一个名为`newOwner`的`value`对象。
- en: (14) Next, we need to retrieve the record object from the world state, which
    represents the current key and value for this record. The `key` is `carNumber`.
    We use it to execute the `ChaincodeStub` API `getState`, passing it for the `key`.
    Once we retrieve the current `car` record object for `carNumber`, we change the
    `owner` field to `newOwner`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (14) 接下来，我们需要从世界状态中检索记录对象，该对象表示此记录的当前键和值。`key`是`carNumber`。我们使用它来执行`ChaincodeStub`
    API的`getState`，将其传递给`key`。一旦我们检索到`carNumber`的当前`car`记录对象，我们就将`owner`字段更改为`newOwner`。
- en: (15) After retrieving the ledger data representing the world state and updating
    the retrieved data, we update the ledger for this `car` record object by executing
    the `ChaincodeStub` API `putState`. This writes a new `key` and `value` to the
    ledger that represents the world state. If the `car` record object is now retrieved,
    the ledger will not show the new owner until the record object is committed to
    the ledger. It is important to understand that once committed, the ledger is appended,
    and the database state will be changed (the world state will be updated). You
    can think of the ledger as an ever-growing stack of objects, each with a unique
    identifier called the *key*. There can be many keys with the same value, but only
    one represents the current or world state. This is how the database implements
    the view of the world state, while the file-based ledger implements the immutable
    history of all keys in timestamp order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: （15）在检索表示世界状态的分类账数据并更新检索到的数据后，我们通过执行`ChaincodeStub`API`putState`更新此`car`记录对象的分类账。这将向表示世界状态的分类账写入一个新的`key`和`value`。如果现在检索`car`记录对象，分类账将不会显示新的所有者，直到记录对象提交到分类账。重要的是要理解，一旦提交，分类账就会被追加，数据库状态将会改变（世界状态将会更新）。你可以把分类账想象成一个不断增长的对象堆栈，每个对象都有一个称为*key*的唯一标识符。可以有许多具有相同值的键，但只有一个表示当前或世界状态。这是数据库实现世界状态视图的方式，而基于文件的分类账实现了所有键的不可变历史按时间戳顺序。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The file-based ledger stores all write transactions. Both successful and unsuccessful
    write transactions are part of the file-based immutable ledger. Flags control
    the validity of transactions stored in the immutable file-based ledger. This facilitates
    an audit of all submitted write transactions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的分类账存储所有写入交易。成功和失败的写入交易都是基于文件的不可变分类账的一部分。标志控制存储在不可变文件分类账中的交易的有效性。这有助于审计所有提交的写入交易。
- en: (16) This line is Node.js specific. We discuss exporting smart contract modules
    in [Chapter 5](ch05.xhtml#smart_contract_invocation), when we cover smart contract
    execution, including project structure, packaging, and deployment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （16）这一行是特定于 Node.js 的。当我们讨论智能合约执行时，包括项目结构、打包和部署时，我们将在[第五章](ch05.xhtml#smart_contract_invocation)中讨论导出智能合约模块。
- en: This completes this simple smart contract. We will now discuss it, in summary,
    to point out the fundamental requirements to develop a smart contract. From this
    basic smart contract, complex smart contract applications can be designed and
    developed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了这个简单的智能合约。我们现在将简要讨论它，以指出开发智能合约的基本要求。从这个基本的智能合约开始，可以设计和开发复杂的智能合约应用。
- en: Define Assets by Using Key-Value Pairs
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键值对定义资产
- en: 'When designing smart contracts, you may need to think in terms of assets. *Assets*
    are generic and can represent many things, including tangible and intangible objects.
    They could be machine parts, dog food, currency, or green derivatives. We use
    name-value pairs, or key-value pairs, depending on how you want to think about
    it, to create our data structures. Here is an example we can discuss:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计智能合约时，您可能需要考虑资产的问题。*资产*是通用的，可以代表许多事物，包括有形和无形物体。它们可以是机器零件、狗食、货币或绿色衍生品。我们使用名称-值对或键-值对来创建我们的数据结构，这取决于您如何想要思考它。下面是一个我们可以讨论的示例：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve seen this before in the Fabcar example. It is a good example of basic
    processing, from which you can advance based on your unique use case. This example
    creates an array of objects that represent assets. The key-value pairs define
    the attributes, or characteristics, of each asset. The array acts as a simple
    database of assets. Each asset is written to the ledger by calling `ctx.stub.putState`,
    which takes a key and value. The value must be a byte array, so we convert the
    JSON object to a string and then convert the string to the byte array. You will
    do this a lot and may want to simplify it and start building a utility or library.
    This particular code was used to initialize the smart contract.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在Fabcar示例中见过这个。这是一个基本处理的好例子，可以根据您独特的用例进行进阶。此示例创建了一个代表资产的对象数组。键-值对定义了每个资产的属性或特征。该数组充当资产的简单数据库。每个资产通过调用`ctx.stub.putState`写入分类帐，该方法接受键和值。值必须是字节数组，因此我们将JSON对象转换为字符串，然后将字符串转换为字节数组。您将经常执行此操作，并可能希望简化它并开始构建实用程序或库。此特定代码用于初始化智能合约。
- en: 'We can also define assets by using a smart contract transaction. The `createAsset`
    transaction function shown next illustrates how simple it is to create an asset
    and write it to the ledger. This function would be called by a client. The client
    could be a user or process. What’s important to remember is the asset will not
    be available until the transaction is committed to the ledger. So you can’t write
    a bunch of assets to the ledger and later in your smart contract expect to read
    and use their data to continue processing. This disconnected state is something
    to think about when you begin designing and brainstorming. Here’s the `createAsset`
    transaction function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过智能合约交易定义资产。接下来展示的`createAsset`交易函数说明了创建资产并将其写入分类帐是多么简单。这个函数将由客户端调用。客户端可以是用户或进程。重要的是要记住，在交易提交到分类帐之前，资产是不可用的。因此，你不能在分类帐上写入大量资产，并期望在智能合约中读取和使用它们的数据来继续处理。在开始设计和头脑风暴时，这种断开的状态是需要考虑的事情。这是`createAsset`交易函数：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Collect Private Data
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集私有数据
- en: The *private data collection* (*PDC*) is a partition of ledger data belonging
    to an organization that stores private data and keeps data private from other
    organizations on that channel. This includes private data and the hash value of
    private data. [Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration) provides
    more details. The need to keep specific data private is important to developing
    smart contracts. Many smart contracts need to be compliant with privacy and security
    requirements. Fabric supports private data for transaction functions and smart
    contracts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*私有数据集合*（*PDC*）是属于一个组织的分类账数据的一部分，它存储私有数据，并将数据与通道上的其他组织保持私密。这包括私有数据和私有数据的哈希值。[第9章](ch09.xhtml#hyperledger_fabric_vtwo_integration)提供了更多细节。需要保持特定数据私密对于开发智能合约非常重要。许多智能合约需要符合隐私和安全要求。Fabric支持用于交易函数和智能合约的私有数据。'
- en: The private data can be shared or kept isolated and secure. We can expire the
    private data after a number of blocks are created or on demand. The data placed
    into the PDCs remains separate from the public data, and PDCs are local and protected.
    The world state can be used in conjunction with PDCs by the use of hashes as well
    as public keys.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 私有数据可以共享或保持隔离和安全。我们可以在创建了一定数量的区块或按需时使私有数据过期。放入PDC的数据与公共数据保持分离，并且PDC是本地和受保护的。可以通过哈希和公钥将世界状态与PDC结合使用。
- en: '[Table 4-1](#commands_for_working_with_private_data) lists several functions
    that are available from `stub`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#commands_for_working_with_private_data) 列出了可从`stub`中使用的几个函数。'
- en: Table 4-1\. Commands for working with private data
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-1\. 用于处理私有数据的命令
- en: '| API | Note |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| API | 注释 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Returns the endorsement policy from the collection name and the specified
    key. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 从集合名称和指定的键返回认可策略。 |'
- en: '| `putPrivateData(collection: `*string*`, key: `*string*`, value: `*Uint8Array*`):
    Promise<void>` | Puts the collection name, the specified key and value into the
    transaction’s private `writeSet`. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `putPrivateData(collection: `*string*`, key: `*string*`, value: `*Uint8Array*`):
    Promise<void>` | 将集合名称、指定的键和值放入交易的私有`writeSet`中。 |'
- en: '| `deletePrivateData(collection: `*string*`, key: `*string*`): Promise<void>`
    | Deletes the endorsement policy by providing the collection name and private
    data variable key. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `deletePrivateData(collection: `*string*`, key: `*string*`): Promise<void>`
    | 通过提供集合名称和私有数据变量键删除认可策略。 |'
- en: '| `setPrivateDataValidationParameter(collection: `*string*`, key: `*string*`,
    ep: `*Uint8Array*`): Promise<void>` | Sets the endorsement policy by providing
    the collection name and private data variable key. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `setPrivateDataValidationParameter(collection: `*string*`, key: `*string*`,
    ep: `*Uint8Array*`): Promise<void>` | 通过提供集合名称和私有数据变量键设置认可策略。 |'
- en: '| `getPrivateDataValidationParameter(collection: `*string*`, key: `*string*`):
    Promise<Uint8Array>` | Returns the endorsement policy by providing the collection
    name and private data variable key. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `getPrivateDataValidationParameter(collection: `*string*`, key: `*string*`):
    Promise<Uint8Array>` | 通过提供集合名称和私有数据变量键返回认可策略。 |'
- en: '| `getPrivateDataByRange(collection: `*string*`, startKey: `*string*`, endKey:
    `*string*`): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>`
    | Returns the endorsement policy from the collection name and the private data
    variable key. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `getPrivateDataByRange(collection: `*string*`, startKey: `*string*`, endKey:
    `*string*`): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>`
    | 通过集合名称和私有数据变量键返回认可策略。 |'
- en: '| `getPrivateDataByPartialCompositeKey(collection: `*string*`, objectType:
    `*string*`, attributes: string[]): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>`
    | Queries the endorsement policy in a given collection name and a given partial
    composite key. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `getPrivateDataByPartialCompositeKey(collection: `*string*`, objectType:
    `*string*`, attributes: string[]): Promise<Iterators.StateQueryIterator> & AsyncIterable<Iterators.KV>`
    | 查询给定集合名称和给定部分复合键的认可策略。 |'
- en: '| `getPrivateDataQueryResult(collection: `*string*`, query: `*string*`): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>` | Performs a rich query against a given private
    collection. It is supported for state databases that can run a rich query (e.g.,
    CouchDB). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `getPrivateDataQueryResult(collection: `*string*`, query: `*string*`): Promise<Iterators.StateQueryIterator>
    & AsyncIterable<Iterators.KV>` | 对给定私有集合执行丰富的查询。支持可以运行丰富查询的状态数据库（例如，CouchDB）。
    |'
- en: Employing private data can be tricky, and patterns exist for using it under
    differing circumstances. We will cover most of these functions in [Chapter 5](ch05.xhtml#smart_contract_invocation),
    when we implement private data functions to invoke, and again in [Chapter 6](ch06.xhtml#testing_and_maintenance),
    when we use them in maintenance and testing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有数据可能会有些棘手，并且存在用于在不同情况下使用它的模式。我们将在[第五章](ch05.xhtml#smart_contract_invocation)中涵盖大多数这些功能，当我们实现私有数据函数以调用时，并且在[第六章](ch06.xhtml#testing_and_maintenance)中再次使用它们进行维护和测试。
- en: Set Attribute-Based Access Control
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基于属性的访问控制
- en: Eventually, you will need a way to implement granular authentication and authorization.
    Clients have an identity that controls access. The identities must belong to authorized
    organizations, and organizations belong to channels that host chaincode. A certificate
    represents the client’s identity. A certificate supports attributes that can be
    used to implement transactions and smart-contract-level authentication control
    and authorization policies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您将需要一种实现细粒度认证和授权的方式。客户端具有控制访问的身份。这些身份必须属于授权组织，组织属于托管链码的通道。证书代表客户端的身份。证书支持可以用来实现交易和智能合约级别的认证控制和授权策略的属性。
- en: 'You access this information from the `clientIdentity` object contained in the
    transaction context. This object has two functions related to attribute values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从事务上下文中包含的`clientIdentity`对象中访问此信息。该对象有两个与属性值相关的函数：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use `assertAttributeValue` to check for the presence of an attribute and use
    `getAttributeValue` to retrieve a specific attribute. It is good practice to assert
    the attribute before retrieving it. In [Chapter 5](ch05.xhtml#smart_contract_invocation)
    and [Chapter 6](ch06.xhtml#testing_and_maintenance), we will employ attributes
    for security and other purposes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assertAttributeValue` 检查属性是否存在，并使用 `getAttributeValue` 检索特定属性。在检索之前断言属性是一个好习惯。在[第五章](ch05.xhtml#smart_contract_invocation)和[第六章](ch06.xhtml#testing_and_maintenance)中，我们将利用属性进行安全和其他目的。
- en: Initialize the Ledger State
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化账本状态
- en: The initialization of the ledger is often a required task. The following example
    from the Fabcar code we looked at earlier illustrates how to initialize your smart
    contract state. You will initialize it right after it has been committed. After
    that, you can start to submit transactions and query ledger data by invoking smart
    contract methods.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 账本的初始化通常是一个必需的任务。我们之前看过的 Fabcar 代码示例清楚地说明了如何初始化智能合约状态。你将在提交后立即初始化它。之后，你可以开始提交交易并通过调用智能合约方法查询账本数据。
- en: 'You create a function that you will call to execute your initialization; here,
    it is called `initLedger`. In the `initLedger` function, you can perform what
    you need to do to initialize. In this example, we create an array of business
    objects, loop through the `cars` array, and then add an additional attribute `docType`
    to each `car` object in the `cars` array. Here is the `initLedger` logic:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数，用于执行初始化；在这里，它被称为 `initLedger`。在 `initLedger` 函数中，你可以执行初始化所需的操作。在这个例子中，我们创建一个业务对象数组，遍历
    `cars` 数组，然后为 `cars` 数组中的每个 `car` 对象添加一个额外的属性 `docType`。下面是 `initLedger` 的逻辑：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `initLedger` function writes the array objects to the ledger by using the
    `putState` function. To execute the `initLedger` function, we need to invoke the
    smart contract. We can use the peer command-line interface (CLI) `invoke` command.
    Let’s take a look at how we can call `initLedger` through the `invoke` command.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`initLedger` 函数使用 `putState` 函数将数组对象写入账本。要执行 `initLedger` 函数，我们需要调用智能合约。我们可以使用对等命令行接口（CLI）的
    `invoke` 命令。让我们看看如何通过 `invoke` 命令调用 `initLedger`。'
- en: Chaincode invoke init
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链码调用初始化
- en: 'To execute a transaction function on our smart contract, we can use the `invoke`
    command provided by the *peer* binary. This binary offers many commands, several
    of which you will learn in [Chapter 5](ch05.xhtml#smart_contract_invocation) and
    [Chapter 6](ch06.xhtml#testing_and_maintenance). Here we use it to invoke our
    `initLedger` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的智能合约上执行事务函数，我们可以使用 *peer* 二进制提供的 `invoke` 命令。该二进制提供了许多命令，其中几个你将在[第五章](ch05.xhtml#smart_contract_invocation)和[第六章](ch06.xhtml#testing_and_maintenance)学到。这里我们用它来调用我们的
    `initLedger` 函数：
- en: Note
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We have printed the following command on multiple lines for readability. When
    you type in the command, it must be on one line, or it will fail to execute.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下命令打印在多行上以增强可读性。当你输入命令时，它必须在一行上，否则将无法执行。
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `invoke` command executes the command object following the `-c` command
    argument flag. The command object specifies the function to execute and any function
    arguments. Here we are executing the `initLedger` function, and there are no function
    arguments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke`命令执行紧随`-c`命令参数标志的命令对象。命令对象指定要执行的函数以及任何函数参数。在这里，我们正在执行`initLedger`函数，没有函数参数。'
- en: We can test the results of the `initLedger` function. We expect to return the
    contents of the array written to the ledger. We will use the `query` command;
    let’s look at how we can query ledger data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试`initLedger`函数的结果。我们期望返回写入账本的数组内容。我们将使用`query`命令；让我们看看如何查询账本数据。
- en: Chaincode query
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链码查询
- en: 'Using the peer’s `query` command, we can execute one of our smart contract
    query functions. In this case, we set the `-c` command flag to execute `queryAllCars`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用peer的`query`命令，我们可以执行我们的智能合约查询函数之一。在这种情况下，我们设置`-c`命令标志以执行`queryAllCars`：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is the return output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回输出：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result shows the `initLedger` function executed, and our smart contract
    is initialized.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示`initLedger`函数已执行，并且我们的智能合约已初始化。
- en: Installing and Instantiating a Smart Contract
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和实例化智能合约
- en: 'In preparation for [Chapter 5](ch05.xhtml#smart_contract_invocation), let’s
    go over what we need to do once we finish coding our smart contract. This section
    discusses several steps that we need to perform to reach a point where we can
    invoke our smart contract either from the command line or from a smart contract
    client. These steps are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备[第五章](ch05.xhtml#smart_contract_invocation)，让我们看看在编写智能合约完成后我们需要做什么。本节讨论了我们需要执行的几个步骤，以便达到可以从命令行或智能合约客户端调用我们的智能合约的程度。这些步骤如下：
- en: Package the chaincode.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包链码。
- en: Install the chaincode.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装链码。
- en: Query the installation.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询安装情况。
- en: Approve the package.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批准该包。
- en: Check commit readiness.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查提交准备情况。
- en: Commit the chaincode definition,
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交链码定义，
- en: Query whether the chaincode is committed.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询链码是否提交。
- en: Initialize the contract.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化合约。
- en: Execute a query.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查询。
- en: '[Chapter 5](ch05.xhtml#smart_contract_invocation) covers these steps in more
    detail. They contain example command-line code, and some have output. The following
    `peer` commands can be referenced in the [Hyperledger Fabric documentation.](https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.xhtml#smart_contract_invocation)详细介绍了这些步骤。它们包含示例命令行代码，有些还有输出。可以在[Hyperledger
    Fabric文档](https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html)中参考以下`peer`命令。'
- en: Package the Chaincode
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包链码
- en: The first thing we need to do is package our code. As you can see from the following
    command, we use the `peer` CLI to perform this step and all remaining steps.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事就是打包我们的代码。正如您从以下命令中看到的那样，我们使用`peer` CLI来执行此步骤和所有剩余步骤。
- en: 'To prepare our smart contract, we use the following `peer` package command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的智能合约，我们使用以下`peer`打包命令：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once this command completes, we have a *tar.gz* file containing our smart contract.
    Next, we need to install this package.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此命令完成，我们就会得到一个包含智能合约的*tar.gz*文件。接下来，我们需要安装此包。
- en: Install the Chaincode
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装链码
- en: After we have packaged our smart contract, we can install it. If several organizations
    are collaborating, there is no need for all organizations to package smart contracts
    separately. One smart contract package can be used by all organizations. Once
    an organization receives the package, it is installed on their endorsing peers.
    [Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration) covers this in more
    detail.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包智能合约之后，我们可以安装它。如果有几个组织在协作，那么没有必要让所有组织单独打包智能合约。一个智能合约包可以被所有组织使用。一旦组织收到包，它就会被安装在它们的背书节点上。[第九章](ch09.xhtml#hyperledger_fabric_vtwo_integration)中详细介绍了这一点。
- en: 'Here is the installation command, which shows a successful output message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安装命令，显示成功输出消息：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once the contract is installed, you may want to verify it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合同安装完成，您可能希望进行验证。
- en: Query the Installation
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询安装情况
- en: 'You can execute the following command to get the details of the latest chaincode
    installed:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行以下命令来获取最新安装的链码的详细信息：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You may receive many package IDs, depending on the number of installed packages.
    You can use a script to filter the output if you need to automate a task that
    is dependent on a particular package being installed or not installed. Once a
    chaincode package is installed, it must be approved.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到许多包标识符，这取决于已安装的包数量。如果您需要自动化依赖特定包是否已安装或未安装的任务，则可以使用脚本来过滤输出。一旦安装了链码包，就必须对其进行批准。
- en: Approve the Package
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批准包
- en: 'After installing a package, an organization must approve it before it can be
    committed and accessed. This command has a lot of parameters. The one of most
    interest, for our purposes, is `–package-id`. We can get it from the output of
    the preceding `queryinstalled` command. `package-id` is used as the identifier
    for the chaincode installation package:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包后，组织必须批准才能提交和访问。此命令具有许多参数。对我们而言最感兴趣的是`–package-id`。我们可以从前面的`queryinstalled`命令的输出中获取它。`package-id`用作链码安装包的标识符：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the approve command completes, we are ready to determine whether we can
    commit it. We use the `checkcommitreadiness` command.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦批准命令完成，我们就可以确定是否可以提交。我们使用`checkcommitreadiness`命令。
- en: Check Commit Readiness
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查提交就绪性
- en: 'A number of organizations must approve the chaincode package before it can
    be committed. The number depends on the policy, which could demand that all organizations
    or a subset of organizations approve. Ideally, you want all organizations to approve.
    We can use the `checkcommitreadiness` command to determine whether we can commit
    the package. In this case, we cannot because `Org2` has not approved yet. Once
    it does, this command will show `true` for `Org1` and `true` for `Org2`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交链码包之前，必须有一些组织批准它。 数量取决于政策，该政策可能要求所有组织或一些组织的批准。 理想情况下，您希望所有组织都同意。 我们可以使用 `checkcommitreadiness`
    命令来确定是否可以提交该包。 在这种情况下，我们不能，因为 `Org2` 还没有批准。 一旦批准，此命令将对 `Org1` 和 `Org2` 显示 `true`：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In a Hyperledger configuration, we can define different types of life-cycle
    endorsement policies. The default is `MAJORITY Endorsement`. This requires a majority
    of the peers to endorse a chaincode transaction for validation and execution in
    the channel and commit the transaction to the ledger. [Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration)
    covers this in more detail. Once all approvals are true, we can commit the chaincode
    package.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hyperledger 配置中，我们可以定义不同类型的生命周期背书政策。 默认为 `MAJORITY Endorsement`。 这要求大多数同行支持链码事务以在通道中进行验证和执行，并将事务提交到分类账中。[第
    9 章](ch09.xhtml#hyperledger_fabric_vtwo_integration)对此进行了更详细的介绍。 一旦所有批准都为真，我们就可以提交链码包。
- en: Commit the Chaincode Definition
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交链码定义
- en: 'Once all organizations or subsets of the organization have been approved to
    satisfy the policies mentioned, the chaincode can be committed to the ledger.
    To commit the chaincode, we use the commit command shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有组织或组织的子集已获得批准以满足提到的政策，链码就可以提交到分类账中。 要提交链码，我们使用如下的 commit 命令：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is the output after the command runs:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令后，以下是输出结果：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we can check whether the chaincode is committed with `querycommitted`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `querycommitted` 检查链码是否已提交。
- en: Query Whether the Chaincode is Committed
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询链码是否已提交
- en: 'Chaincode must be committed before it can be invoked. To determine whether
    chaincode is committed, use the `querycommitted` chaincode command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用链码之前，必须提交链码。 要确定链码是否已提交，请使用 `querycommitted` 链码命令：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running the `querycommitted` command tells us our chaincode is ready. This chaincode
    contains a smart contract that needs initialization. To initialize it, we will
    invoke it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `querycommitted` 命令会告诉我们我们的链码已准备就绪。 此链码包含一个需要初始化的智能合约。 要对其进行初始化，我们将调用它。
- en: Initialize the Contract
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化合同
- en: 'We can finally initialize our smart contract because the chaincode is approved
    and committed. We can use the `invoke` command to execute smart contract transactions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为链码已经获得批准并已提交，所以我们最终可以初始化我们的智能合约。 我们可以使用 `invoke` 命令来执行智能合约事务：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After executing the `invoke` command, we will see the following output; it
    returns a 200 response status if chaincode invocation is successful:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`invoke`命令后，我们将看到以下输出；如果链码调用成功，它将返回200的响应状态：
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At the bottom of the `invoke` command, we see the `-c` command flag and command
    object, which contains the function key and value `initLedger` with no arguments.
    This means the smart contract transaction function `initLedger` will be executed.
    The output shows a successful result. Our smart contract is now initialized and
    ready for clients. We can test our smart contract now by executing a query.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invoke`命令的底部，我们看到了`-c`命令标志和命令对象，其中包含了没有参数的函数键和值`initLedger`。这意味着将执行智能合约事务函数`initLedger`。输出显示成功的结果。我们的智能合约现在已初始化并准备好接受客户端。我们现在可以通过执行查询来测试我们的智能合约。
- en: Execute a Query
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'We have gone through the steps to take your smart contract source-code project
    and instantiate it. We can test it by executing a query like this one:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了将您的智能合约源代码项目实例化的步骤。我们可以通过执行像这样的查询来测试它：
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the output after executing the `queryAllCars` command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`queryAllCars`命令后，以下是输出：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This query executes the smart contract transaction function called `queryAllCars`.
    Writes get committed and thus require endorsing, which involves several peers.
    A query should not have to task more than one peer for execution. This is what
    the client-side code does for us. This example illustrates how a transaction function
    wraps a `ChaincodeStub` function, in this case a `rangeQuery` abstracted as `queryAllCars`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询执行智能合约的事务函数，称为`queryAllCars`。写入将被提交，因此需要背书，这涉及到多个对等体。一个查询不应该要求执行超过一个对等体。这就是客户端代码为我们所做的。这个示例说明了事务函数如何封装`ChaincodeStub`函数，这种情况下是一个抽象为`queryAllCars`的`rangeQuery`。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We began by setting up our Hyperledger Fabric development environment in preparation
    for Chapters [5](ch05.xhtml#smart_contract_invocation) and [6](ch06.xhtml#testing_and_maintenance)
    and using it to explore and examine a simple but complete smart contract called
    Fabcar. The code we write for Fabric smart contracts depends on the APIs provided
    by the SDKs. We covered the Fabcar code because it is small and simple to learn.
    This allowed us to focus on the code of smart contracts, the classes and interfaces
    employed, and the Fabric smart contract APIs we depend on.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始设置我们的超级账本 Fabric 开发环境，以准备进行[第5章](ch05.xhtml#smart_contract_invocation)和[第6章](ch06.xhtml#testing_and_maintenance)的操作，并使用它来探索和检查一个简单但完整的智能合约称为
    Fabcar。我们编写的代码取决于 SDK 提供的 API。我们涵盖了 Fabcar 代码，因为它小而且容易学习。这使我们能够专注于智能合约的代码，使用的类和接口，以及我们依赖的超级账本智能合约
    API。
- en: Fabric smart contract SDKs are available for JavaScript, Java, and Go, with
    more coming. We used the JavaScript Fabric smart contract SDK for Node.js. Using
    it allowed us to explore *fabric-contract-api*, and the core classes and objects
    we need to develop Fabric smart contracts.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 智能合约 SDK 提供了 JavaScript、Java 和 Go 的版本，更多版本正在开发中。我们使用了 Node.js 的 JavaScript
    Fabric 智能合约 SDK。使用它使我们能够探索 *fabric-contract-api*，以及我们开发 Fabric 智能合约所需的核心类和对象。
- en: With knowledge of the API, we covered how to create a smart contract and what
    smart contract transaction functions are. Functions execute our smart contract
    transactions, so it was important to introduce several important topics like validating
    and sanitizing function arguments, initializing smart contracts, and interacting
    with the ledger. The Fabric contract API provides the interface to the ledger,
    which you learned how to access in our smart contracts through the transaction
    context every transaction receives. There was a lot to cover, but we tried to
    keep it simple yet provide you with exposure to the *fabric-contract-api,* which
    contains the interfaces you need to design and implement robust smart contracts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解 API，我们介绍了如何创建智能合约以及智能合约交易函数是什么。函数执行我们的智能合约交易，因此介绍了一些重要主题，如验证和净化函数参数、初始化智能合约以及与分类账交互。Fabric
    合约 API 提供了与分类账的接口，你学会了如何通过每个事务接收的交易上下文在我们的智能合约中访问它。需要涵盖的内容很多，但我们试图保持简单，同时为你提供对
    *fabric-contract-api* 的了解，其中包含你需要设计和实现强大智能合约的接口。
- en: Once the smart contract code is written, we need to package and deploy it to
    the Fabric network. This requires several steps to accomplish. Step by step, we
    went through each one. It is important to know these steps to take our smart contracts
    from source code to instantiated chaincode. We can execute only instantiated code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约代码编写完成，我们需要将其打包并部署到 Fabric 网络。这需要完成几个步骤。我们逐步进行了每一步。了解这些步骤对于将我们的智能合约从源代码转换为已实例化的链码非常重要。我们只能执行已实例化的代码。
- en: In Chapters [5](ch05.xhtml#smart_contract_invocation) and [6](ch06.xhtml#testing_and_maintenance),
    we’ll package and instantiate the smart contracts we create by using the knowledge
    you learned in this chapter. Now we can move on to [Chapter 5](ch05.xhtml#smart_contract_invocation)
    and focus on the invocation of smart contracts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#smart_contract_invocation)和[第6章](ch06.xhtml#testing_and_maintenance)中，我们将使用本章学到的知识，打包和实例化我们创建的智能合约。现在我们可以继续阅读[第5章](ch05.xhtml#smart_contract_invocation)，并关注智能合约的调用。
